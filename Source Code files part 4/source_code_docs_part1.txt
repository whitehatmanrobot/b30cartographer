
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\copyr.txt ===
These are files that contain displayable copyright strings that need
to be modified when updating the copyright

DOSSHELL: \dosshell\inc\about.des
                   \loader\transmsg.inc
                   \copyrite.txt

FDISK:    \cmd\fdisk\fdisk.msg

EMM386:   \dev\emm386\emmmes.asm
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\readme.txt ===
How to build COW libraries from here:

1.  Make sure you've got a lot of memory (around 570 K)

2.  Run BUILDLQB.BAT to build all libraries (cowlqb, cowtandy.lib)

3.  Propogate the new COW library to \45\qb5\qbas as COW.LIB.
    Propogate the new COWTANDY.LIB to \45\qb5\qbas also.


NOTES:	If you CTRL-BREAK out of the batch file, you should answer 'N' to
	the prompt to terminate the batch file.  It will still terminate,
	but it will restore the environment variables that it modified.

WHEN YOU COMPARE YOUR NEWLY BUILT COWLQB.LIB to 45\QB5\QBAS\COW.LIB:
        You will have a few bytes not match.  These bytes are a
        Date/Time Stamp in the Library. These bytes would be:
        00018B37
        00018B38  Day Of Week
        00018B39

        00018B3B
        00018B3C  Month Of Year
        00018B3D

        00018B3F  Day Of Month
        00018B40

        00018B42  Hour
        00018B43

        00018B45  Minute
        00018B46

        00018B48  Second
        00018B49

        00018B54  Checksum Value
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\readme.txt ===
From:	BenS
Subj:	Building QBASIC, QEDIT, and HELP for MS-DOS
Date:	16-Mar-1992 bens Initial changes to files from QB group.
	23-Apr-1992 bens Updated for first delta of online HELP.

ENLISTING IN THIS PROJECT
=========================
To compile QBASIC, enlist this project (QBASIC) into the root of
a drive, e.g.:

    cd \
    md \45
    cd \45
    enlist -vs \\guilo\slm -p qbasic

NOTE: I know "45" is not very intuitive.  However, it IS a very short
      path name, and, as such, allows this project to build under DOS
      with the 128 character command line length limit!

SEMI-ORIGINAL SOURCES, TECHNICAL CONTACT
========================================
\\tal\oaks\5a\45 [password==skao] was where ericar put the source tree that
came from the QB group.  MarkCha is a technical contact in the QB group.


QBASIC SOURCE DELIVERY
======================
This source delivery contains all sources, tools, and libraries needed to
build QBASIC.EXE and EDIT.COM.  Also included are the sources, libraries,
tools, and makefiles needed to build BQB50.LIB, the runtime routines used
by the interpreter.

The build processes are set up to build in DOS.  To do the build in OS/2,
some minor alterations to the build process may be required.


BUILDING SOURCES
================
To build QBASIC.EXE, EDIT.COM, HELP.COM, and associated HELP files:

	1) Change directories to \45\QB5\QBAS
        2) Type SAMPLE

The built files are placed in \45\QB6\QBAS, and these should be installed
by setup into the DOS directory:
    edit.com	- editor (calls QBASIC with /EDCOM switch)
    edit.hlp	- editor help file
    help.com	- on-line help (calls QBASIC with /QHELP switch)
    help.hlp	- on-line help file for MS-DOS commands
    qbasic.exe	- quick basic
    qbasic.hlp	- quick basic help

NOTE:  The first NMAKE process may fail making the parser tables from
bnf.prs.  This error can be ignored -- it happens because there is not
enough memory (usually) to do the operation under NMAKE.  The operation
will get completed in the second NMAKE process, which echoes its commands
to a batch file which is executed later.

With 561,296 bytes free (in a DOS Window under Win 3.1), the parser tables
*do* build the first time, and take about 1 min 45 sec on a Compaq 386/33.


BUILDING BQB50.LIB
==================
A built BQB50.LIB is already present in the \45\QB5\QBAS directory.  If
you want to rebuild the BQB50.LIB library:

	1) Change directories to \45\RUNTIME\QBASIC
	2) Make sure the TL environment variable is set to \45\TL\BIN
	3) Type \45\TL\BIN\NMAKE

The library build by this process should exactly match the existing one
in \45\QB5\QBAS if no changes have been made to the sources.

NOTE:  Due to an apparent memory leak in NMAKE.EXE, the build process may
not finish the first time.  If an out of memory error occurs, simply
restart NMAKE, and it will pick up where it left off.


BUILDING COW.LIB and COWTANDY.LIB
=================================
A build COW.LIB and COWTANDY.LIB are already present in the \45\QB5\QBAS
directory.  If you want to rebuild either of these libraries, instructions
are in \45\BEEF\CW\README.TXT.

---- the end ----
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\inc\readme.txt ===
Files copied from other places:
===============================

CMACROS.INC	: generated in \lib\inc
STD.INC		: generated in \lib\inc
VKEY.INC	: generated in \lib\cw\inc
INDRV.INC	: generated in \lib\cw\inc
INSCR.INC	: generated in \lib\cw\inc (should be called INCSD.INC)
INKBD.INC	: generated in \lib\cw\inc
INSYD.INC	: generated in \lib\cw\inc
INMOU.INC	: generated in \lib\cw\inc
INGXD.INC	: generated in \lib\cw\inc

Note: these files are copied here in order for the DRV project to build
outside the rest of the LIB directory tree (since we export parts of the DRV
tree outside of Microsoft).

Changes in these files must be scrutinized (especially IN*.INC) since
incorrect changes may not be backwardly compatible with existing drivers.

Problems or questions -- see ScottRa.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\cowtandy.txt ===
KKOFSS                  T_KKOFSS
SETSHIFTKKKBD           T_SETSHIFTKKKBD
DOSHIFT                 T_DOSHIFT
MKGETSHIFTSTATESKBD     T_MKGETSHIFTSTATESKBD
CHALTERNATEKEYTOPKBD    T_CHALTERNATEKEYTOPKBD
XLATEKEY                T_XLATEKEY
VWFROMSC                T_VWFROMSC
POLLKEYBOARDKBD         T_POLLKEYBOARDKBD
FLUSHKEYRGCHKBD         T_FLUSHKEYRGCHKBD
RGWDATAKBD              T_RGWDATAKBD
INKJ                    TNKJ
ENABLEKEYBOARDKBD       T_ENABLEKEYBOARDKBD
INKEY                   T_INKEY
MPSCVWPLAIN             T_MPSCVWPLAIN
MPSCVWSHIFT             T_MPSCVWSHIFT
LOCKINSERTQUEUE 	T_LOCKINSERTQUEUE
LOCKREMOVEQUEUE 	T_LOCKREMOVEQUEUE
RELEASEREMOVEQUEUE	T_RELEASEREMOVEQUEUE
RELEASEINSERTQUEUE	T_RELEASEINSERTQUEUE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cow3.txt ===
Introduction

This document describes implementation details of modules of CW.
Applications should not depend upon anything contained herein.


SWAPPING
--------

The CODE SWAPPING/LRU scheme used by CW is significantly different than
Windows.
The concepts as used in CW are described below and notably how they differ
from Windows.
This is not an attempt to document the Windows system.

THUNKS
------

The thunks used for CW are shorter (6 vs 10 bytes) than Windows,
do not require the INT 3FH handler
and implement a more efficient form of LRU.
Noteably the SAR CS:[xxxx],1 instruction is not present in CW

Thunks may take one of three forms:

FORM 1 (ENTMOVE) : Resident code segment.
	JMPF	seg:off
	DB	segno
  -- action of jumping to thunk:
	jump to resident program

FORM 2 (ENTMOVE1) : Resident 
	CALLN	relative to JMPF RelruSegment
	DW	offset
	DB	segno
  -- action of jumping to thunk:
	update LRU for segment, change ENTMOVE1 -> ENTMOVE
	then jump to resident program

FORM 3 (ENTMOVE2) : Not-resident
	CALLN	relative to JMPF RelruSegment
	DW	offset
	DB	segno
  -- action of jumping to thunk:
	load in segment, change ENTMOVE1 -> ENTMOVE
	then jump to resident program



LRU
---

LRU for discardable (i.e. moveable) code segments is defined completely
by the segment reference bytes (1 per code segment).

The following values for these bytes are used:
	0	- Most recently used
	1..0x7f	- less recently used
	0x80	- non-resident (i.e. discarded) code segment
	0xFF	- FIXED segment

The "ReLru" process only occurs for resident segments (i.e. segrefbyte <= 0x7f).
This consists of setting the proper segrefbyte to 0 indicating that this
segment is the Most Recently Used segment. The "Relru" process is initiated
by the program calling a thunk of FORM2.

The "Sweep" process occurs periodically (currently about every 1/4 of a second)
and asynchronously to the main program.
The "Sweep" process consists of bumping the segref bytes in the range 0 .. 0x7e
(this keeps 0x7f .. 0xff from being changed), and going through the entry
table (i.e. the list of thunks) and changing ENTMOVE (FORM1) to ENTMOVE (FORM2)
thunks.

Question : Why are we doing this ?
Answer : the Window's LRU system puts a SAR CS:[xxxx],1 instruction at the
start of each thunk (requiring 31 cycles on an 8088 - more than tripling the
time it takes for a thunk).

So far all the changes in the LRU scheme have been improvements over the
Windows LRU. The thing involved with LRU is the determination of which
segments are the least recently used. This is where the CW system suffers
(i.e. is less efficient than Windows). In windows (due to the fact Windows
updates a linked LRU list) it is just a matter of removing the head item
from the lru linked list. For CW the extra work of scanning the array
of segref bytes is needed.
This should happens relatively rarely (i.e. over a long session,
each discard will correspond to re-reading in the code -
making this an already slow process).


RETURN THUNKS
-------------

Return thunks are also dissimilar from Windows.
First, they are of a different form (ENTRET) :
	CALLN relative to JMPF ReturnThunk
	DB segno
	DW offset

Note : these are kept in a table (pretthunks). There is one per code segment
(even for FIXED segments, in which case it is not used).

The segno is the segment number (and is used since dividing by 5 is slow on
the 8086).
The offset is either -1 (0xffff) or a valid offset:
	if offset == 0xffff then this means that either:
		a) the segment is resident
	   or   b) the segment is not resident, and there are no returns
			to that segment on the stack.
	if offset != 0xffff then this means that the segment IS NOT resident
		AND the
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cboxdist.txt ===
The following file is called CBOXDIST.TXT (checked into LIB\CW\DOC).

CBOX Distribution for Multiplan 4.x:
====================================

All builds are made from FAVOG.

Favog has distribution directory enlisted, build is made from DOS machine
(all .OBJs and original sources remain on FAVOG).
Special dedicated CBOX and DRV directories for Plan have been created.
The Sbmgr, Interpreter and Mathpack are from standard distributions (since
they do not change significantly) -- and the resulting .LIB files checked
into the CW\LIB directory.

The Plan distribution directories will get out of sync, but will represent
the time that the Plan build was made.

The distribution root is /u/eu/dist on favog, or \\favog\slm\dist

CW + final CBOX build:

	lib/cbox/plan40/dcbox/cw

Distribution steps:
1) check everything in
2) log in to favog
3) ssync the /u/eu/dist/lib/cbox/plan40/dcbox/cw directory ("ssync -vrf")
	(this may be a selective "ssync" if only specific changes are to
	be changed in the build).
4) connect to FAVOG\SLM from DOS machine
5) go to build directory (\DIST\LIB\CBOX\PLAN40\DCBOX\CW).
6) run the "make_all" batch file.
7) run the update batch file UPDCBOX.BAT (in \LIB\CW\CBOX on your machine,
	updcbox uses P: and V: so don't start it from these drives).

All distributed files are copied to \\PSTOOLS\DIST\CBOX.

========== ========== ==========

Yet to be added to the standard distribution are:

standard libraries: SBMGR/MATH/LMEM/INTER.
CW drivers.

========== ========== ==========
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cows.doc ===
1           kG        C:\EDITORS\C#.STY                                                   HPLASMS  @           		--	
	CW API Guide : Swapped	
Character WindowsAPI Guide : Swapped Environment (2.22)
Scott RandellMicrosoft Applications Division
.c.1. Introduction
This document is an Appendix to the CW API Guide with specific information about the swapped CW environment.
.c.2. Limitations
A swapped CW app must have only 1 preload segment (named INIT).
.c.:2.1 Definition of a Directory/Pathname
A fully qualified pathname is of the form drive:\dir1\dir2\filename.ext.  Examples are c:\dir1\file.txt and c:\file.txt.  A not fully qualified pathname (or just pathname) is of the form [drive:][\][dir1\]filename.ext.  Examples are c:\file.txt, file.txt, ..\file.txt, c:..\file.txt, and \file.txt.
A directory is just a pathname without the filename on the end.  Therefore, directories may or may not be fully qualified.  The only trick to directories is the trailing backslash: is it there or not?  The rule is that a directory does not contain the trailing backslash, unless it is the root directory.  Therefore, examples of fully qualified directories are c:\, c:\dir1, c:\dir1\dir2, and examples of (unqualified) directories are c:\dir1, c:.., ..\..\..\dir1\..\dir2\..\dir3, and c:\dir1\...  Note that the final example does not have a trailing backslash, even though it really is the root directory.
If you're appending a filename to a directory, the easiest way to determine if you need to add the intermediate backslash is to apply the following rule: add the backslash unless the length = 3 and the second character is a colon.  Ugly but correct.
The maximum length of a pathname in MS/DOS, OS/2 1.0, and any 3xBox = 3+64+12+1 (c:\=3, top\next\..\bottom\=64, filename.ext=12, null termination = 1) = 80 characters, the suggested size of the string buffer.
The maximum length of a directory in MS/DOS, OS/2 1.0, and any 3xBox = 3+64-1+1 (c:\=3, top\next\..\bottom\=64, subtract one for no trailing backslash, null termination = 1) = 67 characters, the suggested size of the string buffer.
The maximum length of a pathname in OS/2 1.1 = 3+112+12+1 (c:\=3, top\next\..\bottom\=112, filename.ext=12, null termination = 1) = 128 characters, the suggested size of the string buffer.
The maximum length of a directory in OS/2 1.1 = 3+112-1+1 (c:\=3, top\next\..\bottom\=112, subtract one for no trailing backslash, null termination = 1) = 115 characters, the suggested size of the string buffer.
.c.3. .DEF file
A swapped CW app must be linked with the segmented linker LINK4.  Look at the sample .DEF file for an outline of the definitions needed.
The fixed segments "CORE" and "DRV_FIXED" must be defined in the .DEF file as FIXED.
For a multiple swap file DUAL mode CW app, the .DEF format is changed slightly.  All segments for the main swap file must be specified except for the data segment.  This includes the PRELOAD MOVEABLE segment which typically appears at the end of the list in non-DUAL CW apps.
.c.4. Initialization
The WinMain entry point is the first thing called by the CW system to initialize the application.  The WinMain procedure must do two things :
The application is responsible for initializing the keyboard/mouse and screen devices (see CWDRV for more info).
Provide a message pump.
The WinMain entry is called with one parameter, a far pointer to the command line (zero-terminated) that was passed to the program.  If the application wants to use command line switches to determine alternate screen modes, the application must query the hardware directly, parse any command line switches and set the hardware to the new mode.  Then the FInitScreen() procedure is called to initialize the character mode for the CW system (to the current value set by the hardware).
In order to have faster application idle loops, the fMessage and fPollKeyboard flags are tested and acted upon as illustrated below.
The structure of the application should look somewhat like
Winmain(lszCmdLine)char far *lszCmdLine;	{	-- parse command line, query hardware	-- set video mode	if (!FInitScreen())		exit(1);		/* invalid screen */	-- initialize stuff	-- create root window	while (1)		{		/* clear all messages */		while (PeekMessage(&msg))			DispatchMessage(&msg);		while (!fMessage)			{			/* Idle Loop (poll keyboard if needed) */			if (fPollKeyboard)				{				PollKeyboard();				}			/* application's idle loop */			}		}	/* NOTREACHED */	}
exit() is a special procedure that should only be called to terminate the application.  Since WM_QUIT does not have to be trapped in the main loop, when the application wants to quit, it can call exit() immediately.
.c.5. Screen Initialization
The FInitScreen() procedure must be called to initialize the screen.  See the document on installable screen drivers for more info.
.c.6. WINTER
The Windows Pcode Interpreter, and all the services it provides, is available as an optional part of the Swapped CW system.  See the interpreter documentation for more details (i.e. how to write a Pcode Winapp).
.c.7. Huge Pointer Support
The huge pointer interface provided by the SB Manager (i.e. CbAllocSb, ...).  See the SB Manager document for more details.
.c.8. Local Memory Manager
The LMEM standard local memory manager is used by SDM for local memory management.  LMEM is also available for use by the application.  See the LMEM document for more details.
.c.9. Miscellaneous
The following additional services are provided by CW.
.c.:9.1 Running Sub-shells
Invoke a different program.
The RerrExec() procedure is provided for running commands and command shells (i.e. $COMSPEC or COMMAND.COM).  Before running the sub-shell, the global heap is shrunk.  It is the responsibility of the application to redraw the screen on return.
DWORDRerrExec(szCmd, szParm)char *szCmd;char *rgchParm;char *rgchPrompt;BOOL fClearScreen;BOOL fRestoreScreenMode;
szCmd is the program to be exec'ed.  If szCmd is NULL, then a command shell is invoked.  This means we exec the COMSPEC environment variable if it exists, "\COMMAND.COM" under DOS if it doesn't, and "\CMD.EXE" under OS/2 if it doesn't.  Otherwise szCmd is the full path of the command; the PATH variable is not checked to find it.
Note: only friendly programs should be exec'ed directly via RerrExec since this is not a full execute (i.e. default FCBs are not filled).  Unsafe programs can be run via a command shell with the /C parameter (this requires that COMMAND.COM be loaded of course).
rgchParm points to a byte-length prefixed, carriage-return terminated, command string.  The string length does not include the carriage return.  rgchParm should never be NULL.  If szCmd = NULL (exec'ing a Command shell), then the format for rgchParm will usually be "\020/C parm1 parm2 parm3\m"; the "/C" is for COMMAND.COM & CMD.EXE to execute the following arguments.
rgchPrompt points to a "$"-terminated string to be displayed to the User after the Exec is done.  If rgchPrompt = -1, RerrExec doesn't bother with it.  If used, RerrExec will exec the program, display the string, wait for a keystroke, and return.  The typical string is "Press a key to resume MangoSoft:$"
fClearScreen will clear the screen before exec'ing.  This will usually be true for exec'ed programs that have some I/O, and will usually be false for exec'ed programs that operate totally transparently to the user.
fRestoreScreenMode, after exec'ing, will set the video mode to what it was before the exec was done.  This will usually be true, unless the app wants to examine the screen that the exec'ed program left behind.
Thus, to run the command A:\FOO.EXE directly, with no arguments and no prompt, without clearing or restoring the screen (that is, totally transparently):
RerrExec("A:\FOO.EXE", "", -1, False, False);
To run FOO from a shell (COMMAND.COM and CMD.EXE will search the PATH), where FOO can be anything (even a batch file), clearing the screen beforehand, with a prompt and video mode restoration afterwards:
RerrExec(NULL, "\006/C FOO\m", "Press a key to resume MangoSoft:$", True, True);
The low word of the DWord return value of RerrExec is either:
rerrOk	The exec was successful.
rerrBadFile	File not found.
rerrBadPath	Bad path.
rerrAccessDenied	Access denied.
rerrNoMemory	Insufficient memory.
rerrBadEnv	Bad environment.
rerrBadFormat	Bad format.
rerrMemUnstable	We can't recover enough memory to continue swapping; a TSR was run and ate a bunch.
other values	Unspecified/unknown error.
The high word of the DWord return value of RerrExec is the return code of the child process (and it's undefined if the low word of RerrExec = rerrOk).
After a call to RerrExec() it is the application's responsibility to redraw the screen, if necessary.
.c.::9.1.1 fShellPresent
BYTE PASCAL fShellPresent;
The fShellPresent flag is used to indicate whether the MS-DOS Manager is present or not (for running RerrExec(NULL, "")).  This allows the application to not prompt for exiting to DOS.
.c.:9.2 GetProgDir
VOIDGetProgDir(szBuff)char szBuff[115];
Get the directory that the program was run from.  szBuff must be large enough to hold a directory (see definition above).  Note!  The directory returned may not be fully qualified; it could be a relative path from the current directory (e.g. c:..).
.c.:9.3 Code swapping
Code swapping will be provided in the similar fashion as Windows (i.e. thunks).  This will be invisible to the application.
.c.:9.4 MUNGE
The program MUNGE.EXE is provided with the CW system.  It is used to reformat the .EXE file into the COW format.  In order to use this, the application should be linked with a final executable of name appname0.EXE.  This base .EXE file can be kept around for incremental linking (after each ILINK, the MUNGE and FIXSTUB steps must be performed).
To MUNGE step is as follows :
munge -cw0 appname0.EXE appname.EXE [swap_file_names]
Where appname is the application name, and swap_file_names is a list of zero or more (limit of 7) extra swap files for the split .EXE option (see the New EXE document for details).
.c.:9.5 FIXSTUB
The program FIXSTUB.EXE is provided with the CW system.  This fixes a problem with the current LINK4 linker.  Place the following line in your makefile after the LINK4 (or ILINK) step.
fixstub appname.EXE COWSTUB.EXE cparaSwap
Where appname is the application name.  This will make the loading of the final program much faster.  cparaSwap is a decimal number specifying the swap fence size in 16 byte paragraphs (i.e. 8192 will provide 128K of code swap area).  The code swap area will be the minimum size for code in the system (i.e. data memory allocations will not grow into this area, code can on the other hand grow into the data area).
.c.:9.6 COWSTUB.EXE
Due to the need for the CW loader (i.e. COWSTUB) to search for the application file (in DOS 2.x), the application name must be hard coded into the COWSTUB.EXE file.  At present we will supply separate COWSTUB.EXE stubs for each application (currently only 1 for WORKS).
.c.:9.7 BindSegment
In order to prevent a segment from being discarded, BindSegment is used.  This does not lock down the segment but just prevents it from being discarded.
VOID BindSegment(pfn, fBind)PFN	pfn;BOOL	fBind;
Bind (if fBind) or unbind (if !fBind) a moveable segment.  pfn is the address of a procedure in the segment.  For pcode segments the segmentname_q label may be used.  The special labels cw_init and cw_exit can be used to bind the initialization and termination segments of CW.
You can run subshells with bound segments.
.c.:9.8 AccessSwapFile
VOID AccessSwapFile(fOpen)BOOL fOpen;
Tells the CW swapper what the application expects to happen with the main swap file.  If fOpen is TRUE, then the main swap file will be opened (i.e. if the program disk is not in the drive, the user will be prompted before going on).  If fOpen is FALSE, the swap file will be closed (i.e. the application is about to prompt the user to insert a data disk in place of the program disk).
.c.:9.9 LszPromptSwapDisk
Prompting of the user for swap disks is performed automatically by CW by default.  For most complicated applications (and for localization), the application can provide an LszPromptSwapDisk procedure.  This procedure is called by CW to prompt the user to insert the program.
CHAR FAR * FAR PASCAL LszPromptSwapDisk(lszPath, ifile, rpsd)char far * lszPath;		// path name (and buffer)WORD ifile;		// index to fileWORD	rpsd;
On entry to this routine, lszPath is the full path name of the file required.  This is also the address of the kernel buffer (good enough for the special MessageBox buffer).  Normally this string is copied onto the frame (and composed into a "Please insert ..." message), then MessageBox() is called.
ifile is the index of the file requested and takes on the following values:
0 : main swap file (always needed)
1 .. 3 : aux. swap files.
-1 : RerrExec program.
rpsd is the reason LszPromptSwapDisk is being called and takes on the following values:
rpsdNULL		only given with ifile == -1
rpsdNotFound	unable to find lszPath
rpsdLocked	file exists but access denied
rpsdLoadError	file opened successfully but either a read error occurred or the loaded segment was invalid
LszPromptSwapDisk returns either a NULL pointer or a far pointer to a string containing the path to be used when searching for the ifile overlay.  CW will append the name corresponding to ifile directly to this path.  CW makes a copy of this string.
This is an extremely restricted procedure.  The following rules apply:
* the code must be fixed (and all procedures it calls).
* the only CW procedure that may be called is MessageBox.
* all calls to MessageBox must be prefixed with:
InitSpecialMessageBox(szPath);
* and terminated by:
EndSpecialMessageBox();
Other notes for use:
* The first letter of the path contains the drive letter of interest.
* The procedure can use the ifile variable (as well as global application variables) to decide whether to prompt or not.  There are 2 suggested cases:
1) The file is needed (ifile == 0), bring up a MB_RETRY message box.
2) The file is optional (ifile != 0), bring up a MB_RETRYCANCEL message box (if cancel then DoJmp to some handler code).
* The application should close all of its files associated with the swap drive upon entry to the procedure (i.e. what the old PrepareSwapDisk (no longer supported) did).
If missing, a STUB routine (which provides a generic English prompt) is included from the CW library.
.c.::9.9.1 InitSpecialMessageBox
VOID /*MACRO*/ InitSpecialMessageBox(rgbBuff)BYTE *rgbBuff;
Initialize the next MessageBox() call to use the special work buffer rgbBuff.  No help will be allowed for this alert.
.c.::9.9.2 EndSpecialMessageBox
VOID /*MACRO*/ EndSpecialMessageBox()
End the use of the special MessageBox() buffer.
.c.10. Saving DS and Code swapping
This is very important if you are coding in assembler.
The CW system differs slightly from Windows in the way items are updated on the stack.  Since the application's Default Data Segment (DDS) is always fixed, there is no need to save the DS on far calls.  This has one side effect, if you use alternate data segments (i.e. moveable huge blocks allocated by CbAllocSb()) and put the address in the DS segment register, then FAR calls may move the data block, hence invalidating DS.  For the same reason, do not push DS and do any FAR calls.  If you wish to save information about a data segment (other than the DDS) it is best to save the sb, and dereferece the sb after returning from the FAR call.  The same rules do not apply to ES, since according to convention, it is trashable across calls anyway.
.c.11. Debugging Support
The following CW entries are provided for debugging purposes.  The header file cowdebug.h should be included to reference these procedures.
Also note that the debugging version of the CW system has some internal integrity checks that may cause assertion failures.
VOIDPrDebugRgch(lpch, cch);char far *lpch;WORD cch;
Print cch characters from the far buffer *lpch on the debugging console.  This does nothing if the debugger (SYMDEB) is not attached.
BOOLFCheckGlobalHeap(lpckh);CKH FAR *lpckh;
Checks the global heap for integrity.  Returns TRUE if global heap is ok.  If this function returns FALSE, then the integrity of the entire CW system is in question.  lpckh is a far pointer to a CKH structure to fill in with information (this may be NULL).
TYPE CKH - Heap checking structure
typedef struct	{	WORD cblkTotal;		/* number of heap items */	WORD cblkCode;		/* number of code heap items */	WORD cblkData;		/* number of data heap items */	WORD cblkFree;		/* number of heap items free */	DWORD cbTotal;		/* total # of bytes in heap */	DWORD cbCode;		/* total # of code bytes in heap */	DWORD cbData;		/* total # of data bytes in heap */	DWORD cbFree;		/* total # of bytes free in heap */	} CKH;
.c.:11.1 Run-time debug helpers
The label abort is available as a quick escape from the CW environment (similar, but more fool proof that ExitWindows in Windows).  Typing "G =abort" from SYMDEB will abort CW.
Document Revision History
July 20 / 87 (1.9)PrepareSwapDisk -> PromptSwapDisk
Jan 27 / 88 (2.20)Remove items for LMEM and installable drivers
Apr 8  / 88 (2.21)Fully installable
May 2  / 88 (2.22) [SAR]DRV_FIXED fixed segment required.PromptSwapDisk takes FAR pointer to string now.
Nov 3  / 88 [MRD]rpsd argument to PromptSwapDisk.
Nov 11 / 88 [MRD]PromptSwapDisk changed to LszPromptSwapDisk.
Table Of Contents
.Begin Table C.
1. Introduction	1
2. Limitations	1
3. .DEF file	1
4. Initialization	1
5. Screen Initialization	2
6. WINTER	2
7. Huge Pointer Support	2
8. Local Memory Manager	3
9. Miscellaneous	3
9.1 Running Sub-shells	3
9.1.1 fShellPresent	4
9.2 GetProgDir	4
9.3 Code swapping	4
9.4 MUNGE	4
9.5 FIXSTUB	5
9.6 COWSTUB.EXE	5
9.7 BindSegment	5
9.8 AccessSwapFile	5
9.9 LszPromptSwapDisk	5
9.9.1 InitSpecialMessageBox	7
9.9.2 EndSpecialMessageBox	7
10. Saving DS and Code swapping	7
11. Debugging Support	7
11.1 Run-time debug helpers	8
.End Table C.
܀         v       q      m   h     f     d     b     `   			 @@ @ @ @  ,  y <  Y  w i  y  u ~    s     q     o     m     k     i 	      y   ,  w 2  ;  u @  I  s T  \  q *  -  o N  T  m _  m  k   	    y     w     u     s     q      o #  -  m     k     i 	      y     w     u     s 	    q 2  4  o i  k  m     k   	    y     w     u R  T  s l  t  q     o     m     k     i 	  	  	  y *	  3	  w M	  P	  u T	  g	  s 	  	  q 	  	  o 	  m 
  
  k 
  
  i 		
  )  ,  y _  e  w     u 5  =  s B  O  q     o m  q  m     k   			    y $  '  w   
  u     s m  p  q     o     m a  f  k     i 						  X  ]  y     w E  M  u h  m  s     q '  1  o     m Z  f  k 2  	2  D  y -   3   w N   Y   u k   v   s       q       o       m       k    !  i 	!  "   "  y 4"  <"  w "  "  u "  "  s "  "  q {#  #  o #  #  m #  #  k 5$  			5$  :$  y $  $  w $  $  u H%  L%  s c%  m%  q  &  '&  o ,&  m &  &  k &  &  i &  			&  &  y &  w &  u &  s &  '  q '  '  o 3'  B'  m '  '  k '  '  i (  (  g (  	(  (  y (  w (  (  u (  (  s )  #)  q T*  X*  o x+  |+  m ,,  7,  k d,  i,  i z,  		z,  ,  y ,  ,  w ,  ,  u ,  s -  -  q !-  (-  o -  -  m -  -  k 6.  ;.  i .  	.  .  y `/  d/  w '0  80  u 0  0  s @1  H1  q T2  Y2  o 2  2  m 
3  3  k Q3  Y3  i 	Y3  k3  p3  y x3  3  w 3  3  u 3  3  s 3  3  q 24  C4  o 4  4  m 4  4  k 6  6  6  y v7  |7  w 7  7  u 8  8  s 19  69  q b9  w9  o 9  9  m 	:  :  k 9:  M:  i 		M:  :  :  y =  =  w 6>  >>  u >  ?  s /?  2?  q S?  W?  o ?  ?  m @  @  k B  		B  B  y B  B  w B  B  u -E  >E  p \G  kG  k 2?  q S?  W?  o ?  ?  m @  @  k B   @ @		      Y    7    5   3               I       kG A?!H $                   p `'!H $                    `'  $  v   q   l   g   b >        I   I   I   I   I   I   I   I    =  =    k  T  	  	  	  v 
  q 
  q   q   l   I   I   I   I   I   I   I   I   I  =  	    v   q   q   l   l   l   g   b   I   I   I   I   I   I   I   I  = W = W =     v $  q 2  l   g #  b   ]   X   I   I   I   I   I   I   I   I =  =  =    m  v   q   l   g   b   b a  ]   I   I   I   I   I   I   I   I W =  =  = a    v   v '  v Z  v 2  v   v   v   q   l   I   I   I   I   I   I   I   I   I = W = 	    v -   q N   l k   l    l    l    l    l    l   I   I   I   I   I   I   I   I   I U = W 	   c!  v !  v $"  q "  q "  l "  g {#  b   I   I   I   I   I   I   I   I   I  = W  = U {#  #  v #  q $  l $  g H%  b W%  ] &  X   I   I   I   I   I   I   I   I=  =  = W  &  &  v '  q '  l '  g (  b (  ] T*  X   I   I   I   I   I   I   I   I= M =  = W = T*  i*  v x+  q +  l ',  g [,  b q-  ] -  ]   I   I   I   I   I   I   I   I= = W =  =  -  -  v -  q `/  l {/  g 0  b &1  ] T2  X   I   I   I   I   I   I   I   I= W =  = W  T2  2  v 2  q 2  q 2  q Q3  l x3  g 3  g 3  g   I   I   I   I   I   I   I   I = U = E = 3  24  v -5  q u5  q 5  q 5  q 6  q ;6  l Q6  g   I   I   I   I   I   I   I   I = = W = U Q6  j6  v 6  q 6  l _7  l 7  g 8  g 8  b   I   I   I   I   I   I   I   I   I E W E = W 8  19  v S9  q 9  l 	:  g *:  b Q:  ] :  X   I   I   I   I   I   I   I   I= W  = W  = :  :  v :  q =  q =  l t>  g >  g )?  b   I   I   I   I   I   I   I   I= W W =  =  )?  ?  v ?  q @  l A  g B  b B  ] C  X   I   I   I   I   I   I   I   I=  W M = W = C  C  v C  q D  q 9D  q D  q D  q E  q E  l         I   I   I   I   I             W M = U ? E  -E  v >E  QE  \ cE  \ sE  \ E  \ E  \   I         I   I   I   I   I                         !? E  E  a E  a E  a E  a F  G   I   I   I   I   I   I   I                !                !F  ,F  a >F  G SF  G `F  G oF  G   I   I   I   I   I   I   I                !      	           !oF  F  a F  a F  a F  a F  G   I   I   I   I   I   I   I      	           !                !F  G  a $G  G =G  G   I   I   I   I   I   I   I   I   I                !      	           !=G  \G  a kG  \ lG    I   I   I   I   I   I   I   I   I              =                 ! 
           ~   	(  0  J8  a@   C  D  F      q     a     ?     e     +                $    	     
           D   F           (       01/15/8901/15/89F  
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cow35.doc ===
1           q  ' - - - - . C:\EDITORS\C#.STY                                                   HPLASMS /                     		--	
	CW API Guide : Swapped	
Character WindowsAPI Guide : Non-Swapped Environment (2.22.02)
Scott RandellMicrosoft Applications Division
.c.1. Introduction
This appendix describes the two non-swapped CW implementations.  One is for DOS 3 the second for DOS 5 (OS/2).  The API for both versions is nearly identical, as is the user interface, thus making dual mode programs easy to write for CW applications.
In this document DOS 5 refers to OS/2.
.c.2. Files provided
One main include file cwindows.h is provided for both DOS 3 and 5 non-swapped applications.  The libraries are version dependent.  COW3.lib and COW5.lib are provided for DOS 3 and 5 respectively (and DCOW3.lib and DCOW5.lib for debugging versions).
.c.3. Initialization
The application is just like any other application with two major exceptions.  FInitCow() must be called before any CW functions are used.  If this function fails, the CW system can not be initialized (usually an indication of something very wrong at the system level).  EndCow(fClearScreen) must be called before the normal exit() of the program (see COWAPI.DOC for details.
After the FInitCow() call the application is responsible for initializing the keyboard/mouse and screen devices (see CWDRV for more info).
.c.4. Standard Library
The standard library can be used with no (known) restrictions.  The main entry point main() is called just like any other non-CW C program, and exit() should be called to exit it (be sure to do a FInitCow() .. EndCow() in the middle).
.c.5. AUXCOW.C
In the sample "HELLO" application, a file AUXCOW.C provides some routines that the CW system relys on (most are for local memory management).  You may, if you wish, change the functions in this module to implement a more efficient memory management system.  Warning : only change the contents of this file if you are certain of what you are doing.
At present, the SDM dialog manager in the non-swapped version of CW still uses handles to near objects (i.e. double indirect pointers).  Since the local memory manager provided in AUXCOW.C uses malloc() and free() which all return fixed memory blocks, the extra indirection is not needed (This should have no effect on the application since you should always lock a CAB before accessing its contents).
.c.6. Message Pump
The main routine should look something like :
main(argc, argv)int argc; char **argv;	{	-- parse command line		if (!FInitCow())		exit(1);		/* invalid screen */	-- initialize stuff	-- create root window	while (1)		{		/* clear all messages */		while (PeekMessage(&msg))			DispatchMessage(&msg);		while (!fMessage)	/* DOS 3 use of fMessage */			{			/* Idle Loop (poll keyboard if needed) */			if (fPollKeyboard)				{				fPollKeyboard = FALSE;				PollKeyboard();				}			/* application's idle loop */			}		}	/* NOTREACHED */	}
.c.:6.1 hsemaMessage
In DOS 5 the fMessage flag is replaced by an OS/2 RAM semaphore.  hsemaMessage is the handle of the semaphore.  This semaphore must be treated like fMessage except for instead of testing for fMessage != 0, a DosSemWait should be issued.  When an input message occurs, the semaphore will be cleared, PeekMessage should be called until it returns FALSE.
The single semaphore is used to allow threads to wait on events in addition to hsemaMessage (using DosMuxSemWait).
The same mechanism for waiting can be used in a dialog procedure to process a dlmIdle message.
CW internally will wait on the hsemaMessage semaphore in the following cases :
1) while in menu mode (a menu pulled down).
2) while in a dialog without a dialog proc.
3) while in a MessageBox.
WARNING : in order to make your OS/2 CW app be a nice app (i.e. go to sleep when idle - NOT BUSY WAIT) you must:
1) Perform the semaphore-wait/PeekMessage in the main pump.
2) for all DialogProcs, perform a semaphore-wait on all dlmIdle messages.
See the example HELLO app for more details.
.c.7. .DEF files
The following MUST be in the OS/2 .DEF file under the SEGMENTS section:
IOPL_TEXT IOPL

Document Revision History
May 27/88 (2.22.02) [SAR]Added IOPL_TEXT.
Table Of Contents
.Begin Table C.
1. Introduction	1
2. Files provided	1
3. Initialization	1
4. Standard Library	1
5. AUXCOW.C	1
6. Message Pump	2
6.1 hsemaMessage	2
7. .DEF files	3
.End Table C.
                       v       q      m   h     f O  R  d {    b     `   		 @@ @ @ @    y -  6  w ;  D  u _  b  s     q     o      m z  }  k ~    i 				  ~	  	  y     w     u     s `  h  q     o |    m     k    				   ,  y     w     r b  q  m   s `  h  q     o |    m     k    		 @ @	      Y    7    5   3 +  . '  ) q  m=  A?!H $                   p `'!H $                    `''  O  v e  q _  l u  g   b z  b   ] ~  X   S   N ~	  N 	  I  =  =  =  =  = 	  	  v   q   l -  g   g   g Q  g ~  b   b   b 8  ] u  X   X =  E = E =  W =     v   q H  l X  g Z  b v  ]   X   S     b 8  ] u  X   X = ? U ? = W =  = 	    a   a   a   a *  a =  a Q  G   S     b 8  ] u  X                !                !Q  b  a q  \ r    a *  a =  a Q  G   S     b 8  ] u  X              =                 !       ў  ՞  w 0  5  u M  e  s p  q   Ɵ  o     m   k     i %  g ^  							         (       9/1/88  8/25/88   s T  X  q m  r  o   ǡ  m ϡ  k     i   					    y     w #  8  u @  s     q !  -  o d  h  m     k   i K  Q  g 					
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cowapi.doc ===
1           35 mmtuuC#.STY                                                              HPLASMS2v@ @rmm  s		--	
	CW API Guide 2.22		
Character WindowsAPI Guide 2.22.02
Scott RandellMicrosoft Applications Division
Table Of Contents
.Begin Table C.
1. Introduction	1
2. Versions	2
3. CW Services	2
3.1 Coordinates	2
3.2 A Window	3
3.3 CW Rules	3
4. Supplied Files	4
5. TYPES / GLOBALS	4
5.1 Base Types	5
5.2 GLOBALS axMac, ayMac.	5
5.3 TYPE WND/PWND - The Window Data Structure	5
5.4 TYPE RRC - a RELATIVE Rectangle	7
5.5 TYPE ARC - an ABSOLUTE rectangle	7
5.6 TYPE BOX - a box format type	7
5.7 GLOBALS boxSingle, boxDouble	8
5.8 TYPE MSG - the message structure.	8
5.9 TYPE MENUBAR - a menu bar.	9
5.10 TYPE MENU - a MENU (drop down).	9
5.11 TYPE MENUITEM - a menu item (inside drop down).	10
5.12 TYPE MPVKEYID - accelerator entry.	11
5.13 TYPE FDE - file directory entry.	11
6. Keyboard Input and Control	12
7. Mouse Input and Control	12
7.1 Mouse Globals	12
7.1.1 fMousePresent	12
7.2 Mouse Driver Routines	12
7.2.1 FEnableMouse	12
7.2.2 SetMouseCursor	12
7.2.3 MouseConditionalOff	13
7.2.5 SetMouseDoubleSpeed	13
7.2.6 Mouse Capture Routines	14
7.2.7 SetCapture	14
7.2.8 ReleaseCapture	14
7.3 Misc Mouse Functions	14
8. Windows	14
8.1 Statically Creating Windows	14
8.1.1 Examples	16
8.2 General Window Control	17
8.2.1 AddChild	17
8.2.2 RemoveChild	17
8.2.3 EnableWindow	17
8.2.4 GetClientRrc	17
8.2.5 SetWindowStyle	17
8.2.6 SetWindowSize	17
8.2.7 MoveWindow	18
8.2.8 SetWindowProc	18
8.2.9 GetWindowWord	18
8.2.10 SetWindowWord	18
8.2.11 PwndParent, PwndChild, PwndSibling	18
8.3 Window Drawing Routines	19
8.3.1 DrawWindow	19
8.3.2 DrawBorder	19
8.3.3 DrawBorder2	19
8.4 Rectangle Utilities	19
8.4.1 SetRect	19
8.4.2 IntersectRect	20
8.4.3 UnionRect	20
8.4.4 IsRectEmpty	20
8.4.5 PtInRect	20
8.4.6 CopyRect	20
8.4.7 SetRectEmpty	20
8.5 Listbox Control	21
8.5.1 InitListBox	21
8.5.2 GetListBoxOrientation	21
8.5.3 InitListBoxOriented	21
9. Drawing inside a Window	21
9.1 Drawing	22
9.1.1 TextOut	22
9.1.2 CharOut	22
9.1.4 DrawBox	22
9.2 Area Operations	23
9.2.1 FillRrc	23
9.2.2 BltArc	23
9.2.3 Area Save/Restore	23
9.2.4 SaveRrc	23
9.2.5 RestoreRrc	23
9.2.6 CbSizeRrc/CwSizeRrc	24
9.3 Cursor Operations	24
9.3.1 EnableCursor	24
9.3.2 MoveCursor	24
9.4 Color Control	24
9.4.1 SetSysColor	25
9.4.2 SetIsaColor	25
9.4.3 GetIsaColor	25
9.4.4 SetRgca	25
9.4.5 SetIsaFfont	25
9.5 Drawing Modes	26
9.6 Coordinate Conversions	27
9.7 Screen Particulars	27
9.7.1 fMonochrome	27
9.7.2 chShadow/diShadow	27
10. Focus Control	27
10.1 Focus Routines	27
10.1.1 SetFocus	27
10.1.2 GetFocus	28
10.2 VARIABLE fMessage	28
10.3 VARIABLE abAbort - User abort.	28
10.5 VARIABLES fKeyIsUp, fKeyWasUp - DOS3 Keyboard test	29
10.6 TSR Support	29
10.6.1 SetTsrProtocol	29
11. Messages	30
11.1 Message Routines	30
11.1.1 PeekMessage	30
11.1.2 UngetMessage	30
11.1.3 DispatchMessage	30
11.1.4 PostMessage	30
11.1.5 SendMessage	30
12. Menus	31
12.1 Menu Bar	31
12.1.1 InitMenu	31
12.1.2 FEnableMenuBar	31
12.1.3 EnableMenu	31
12.1.4 EnableMenuItem	31
12.1.5 CheckMenuItem	32
12.1.6 FMenuItemChecked	32
12.1.7 FindMenuItem	32
12.1.8 DrawMenubar	32
12.1.9 OpenMenu	32
12.1.10 SetMenuKeys	32
12.2 Menu Creation Macros	33
13. Help	33
14. Miscellaneous	35
14.1 Misc System Routines	35
14.1.1 ClockTicks	35
14.1.2 Beep	35
14.1.3 Click	35
14.1.4 RepaintScreen	35
14.1.5 RspAppIdle	35
14.2 Dialog Boxes	36
14.2.1 MessageBox	36
14.3 Scroll Bar Functions	36
14.3.1 SetScrollPos	36
14.3.2 GetScrollPos	37
14.3.3 SetScrollRange	37
14.4 Edit Functions	37
14.4.1 SetEditText	37
14.4.2 SetEditWidth	37
14.4.3 GetEditText	37
14.5 Exported Managers	38
14.6 Work Buffer	38
14.6.1 PbAllocWork	38
14.6.2 FreeWork	38
14.6.3 OutOfMemory	38
14.6.4 LpbAllocWorkFar	38
14.6.5 FreeWorkFar	39
14.7 Floppy control	39
14.7.1 fSingleFloppy	39
14.7.2 FValidDrive	39
14.8 Extra Init/Term	39
14.8.1 LeaveCow	39
14.8.2 EndCow	39
14.9 INT 24 Errors	40
14.10 Mouse Saving	40
14.10.1 CbSizeMouseState	40
14.10.2 SaveMouseState	40
14.10.3 RestoreMouseState	40
14.11 Alarm Function	40
14.11.1 SetAlarm	41
Set the alarm to send a message to the window pointed at by pwnd in ctick system ticks.	41
14.11.2 KillAlarm	41
14.12 File Searching	41
14.12.1 FFindFirst	41
14.12.2 FFindNext	41
14.12.3 FindClose	41
15. SDM - Standard Dialog Manager	42
16. Initialization / Message Pump.	42
17. Development	42
.c.1. Introduction
This document describes the Application Programming Interface to the Character Windows environment.  This document assumes a familiarity with standard Microsoft Windows (refered to as Windows in this document).
CW (Character Windows) is designed with simplicity and speed in mind.  All CW I/O is character oriented and CW uses a much simpler window and process model than that of Windows.
There are several appendices to this documents:
COWS.DOC	Swapped CW extensions.
COW35.DOC	Non-swapped CW extensions.
COWWM.DOC	CW Messages.
CWDRV.DOC	CW Installable driver information.
CWGRAPHIC.DOC	Graphic Drawing information (with GSD/GPD drivers).
CWKANJI.DOC	Kanji / DBCS extensions.
CWTWIN.DOC	TWIN-compatible extensions.
For writing CW compatible device drivers, there are the following documents:
DRV.DOC	The format of CW installable drivers.
DRVCSD.DOC	CSD character screen drivers.
DRVKBD.DOC	KBD keyboard drivers.
DRVGSD.DOC	GSD graphical screen driver.
There are some implementation documents:
CW.IMP	CW internal implementation (PRIVATE information).
.c.2. Versions
There are currently 3 different version of CW:
Swapped CW : the CW system which supports swapped code in a non-protected environment (i.e. WORKS).
CW 3 : the CW user interface to non-swapped DOS 3 applications.
CW 5 : the CW user interface to DOS 5 applications.
All versions have very similar APIs (with only minor differences for some lower level services and how idle loops are implemented).  All versions have a medium model interface (FAR calls, NEAR data) making CW usable for Small, Medium and mixed model programs (Large and Huge CW programs make little sense).
There are several sub-version control options for specific projects.
Kanji support is also a variation (see Appendix for differences).
.c.3. CW Services
Services provided by the CW system include :
KERNEL : Memory management, code swapping and other low level services (code swapping for Swapped CW only).
USER : Windows User interface (similar to Windows USER).
SDM : the Standard Dialog Manager (CW variant).
Note : Since the CW system is far less general than the Windows system, the interfaces are tighter and more optimized providing a more efficient implementation of the Windows-like services.
Additional services (such as Pcode interpreter, SbMgr, Lmem, ...) have CW variants.  Please refer to the corresponding documents for more info.
CW is built upon a set of run-time installable device drivers.  The body of CW code is portable between different display/keyboard hardware.  An 8086 processor (80286 for OS/2) as well as MS-DOS or OS/2 for the operating system are the underlying base requirements.  Please refer to the driver document (DRV.DOC) for more info.
.c.:3.1 Coordinates
Coordinates are always specified in characters.  The horizontal axis runs from left to right, the vertical axis runs from top to bottom.
Absolute coordinates are specified in (ax, ay) pairs that are screen absolute.  The upper left corner of the screen is (ax=0, ay=0), the bottom right corner is (ax=axMac-1, ay=ayMac-1).  Absolute rectangles are called ARC's.
Relative coordinates are always specified relative to some window.  Relative coordinates are specified in (rx, ry) pairs.  The upper left corner of the relative drawing area is determined by the  window's client area (see below).  Relative rectangles are called RRC's.
All drawing is done in window relative coordinates (for extremely rare cases of absolute drawing to the screen, a NULL pwnd parameter makes relative coordinates interpreted as absolute coordinates by most of the drawing routines).
.c.:3.2 A Window
A window is a rectangle that is located somewhere on the screen.  It may have a border (always one character wide).  It may have one or more scroll bars.  Scroll bars are always located on bottom, or the right side of a window.  The size of the window always includes the size of any borders or scroll bars.  Windows with borders can have a name (the name is drawn in the center of the top border).
Inside a window is a client area, that area of the window that can be drawn in.  The client area excludes any borders or scroll bars (i.e. a window with a border has a client area that is 2 columns narrower and 2 rows shorter than the window rectangle).  All drawing inside the window is done relative to the client area.  As a result the upper left corner of the client area is always (0, 0) in relative coordinates.
All drawing is clipped to be inside the client area.
Active windows are those that on the screen and can receive mouse messages.  All active windows are defined in a tree, descending from root windows.  Root windows are specified by the AddChild function added to a parent window of NULL.
Each window must have a parent (the parent of root windows is NULL).  Each window may have one or more children.  Child windows must be physically contained in their parent.  Sibling windows (child windows with the same parent) may not overlap each other.
Child windows can control their parents, as an example, scroll bars are children of the window that they scroll.  When scroll messages get sent to the scroll bar, they in turn pass the scroll requests to their parent.
Child windows can be added to or removed from the parent.  As a result, child windows can be easily re-used by switching their parents.
.c.:3.3 CW Rules
The following general points should be kept in mind while reading this document, and writing CW apps.
All near pointers are relative to the default data segment.
Relative (window) coordinates are always expressed relative to the client area.
Coordinates are always zero based.
A child window is always physically contained in its parent.
No two sibling windows can overlap.
Only the root window and its children are active at any time (i.e. are displayable and may receive mouse messages).
The bottom right corner of rectangles (both RRC's and ARC's) is specified as a MAC value (i.e. like Windows).
.c.4. Supplied Files
CW includes/libraries and tools are distributed in the CWENV project (\\pstools\env) which parallel the DOSENV and WINENV distribution.  CWENV is built upon DOSENV and WINENV.
The following files are provided:
.i.cwindows.h(file);cwindows.h is provided to the application and is usually included by all source files that need to interface with CW (in order to use this file with the Cmerge compiler, CC must be defined (-DCC)).
.i.csdm.h (file);csdm.h is provided for macros needed by sdm portions of the application.
.i.csdmtmpl.h (file);csdmtmpl.h provides additional information required by application files that include SDM templates (.sdm files).
.i.cgraphic.h (file);cgraphic.h provides additional information required by application files perform graphical drawing (refer to CWGRAPH.DOC for more info).

The CW code is contained in a library (.i.cow.lib (file);COW.lib, .i.cow3.lib (file);COW3.lib or .i.cow5.lib (file);COW5.lib for the 3 different versions).  Debugging versions of the libraries are also provided (.i.dcow.lib(file);DCOW.lib, .i.dcow3.lib(file);DCOW3.lib or .i.dcow5.lib(file);DCOW5.lib).
For Pcode CW applications the following additional files are provided.
.i.cwindows.txt (file);cwindows.txt provides toolbox definitions for Pcode CW applications.
.i.cgraphic.txt (file);cgraphic.txt provides toolbox definitions for graphic drawing.
For Swapped CW the following additional files are provided.
.i.cowdebug.h (file);cwdebug.h is provided for CW entries and information that is specific to the debugging version of CW.
.i.cow.def (file);cow.def is a template .DEF file for linking you CW application (the definitions in this file MUST be used in the applications .DEF file).
.i.cowstub.exe (file);cowstub.exe is provided as the stub and loader portion of the CW application.
.i.munge.exe (file);.i.munge.exe (program);munge.exe is provided to compress the .EXE file (convert from New Exe format into CW compressed format).
.i.fixstub.exe (file);.i.fixstub.exe (program);fixstub.exe is provided to fix a problem in the LINK4 linker (see section below for details).
.c.5. TYPES / GLOBALS
The following types are used throughout the CW system (and will be used to a high degree in any CW application).  Note that the base types that fix into a BYTE will be defined as a WORD for the CS compiler (since BYTE local variables are expensive in Pcode).  The BYTE/WORD type when used in a structure will always be BYTE.
Global variables are of the PASCAL naming convention.
.c.:5.1 Base Types
.i.BYTE (type);BYTE : an unsigned 8 bit quantity.
.i.WORD (type);WORD : an unsigned 16 bit quantity.
.i.DWORD (type);DWORD : an unsigned 32 bit quantity.
.i.AX (type);AX : an absolute screen x coordinate (BYTE/WORD).
.i.AY (type);AY : an absolute screen y coordinate (BYTE/WORD).
.i.RX (type);RX : a window relative x coordinate (BYTE/WORD).
.i.RY (type);RY : a window relative y coordinate (BYTE/WORD).
.i.PFN (type);PFN : an address of a FAR PASCAL procedure.
.i.BOOL (type);BOOL : a 16 bit quantity used for a flag value.
.i.HANDLE (type);HANDLE : a general use handle (WORD).
.i.ISA (type);ISA : an index to a screen attribute (see colors) (BYTE/WORD).
.i.TMC (type);TMC : an item code, used for SDM (WORD).
.i.DLM (type);.i.TMM (type);DLM, TMM : dialog and item messages types, used for SDM (WORDs).
.i.SB (type);SB : huge pointer segment base (WORD, for swapped CW only).
.c.:5.2 GLOBALS axMac, ayMac.
BYTE .i.axMac (global);axMac;
BYTE .i.ayMac (global);ayMac;
The top, leftmost character on the screen is position (0, 0) and the bottom rightmost position on the screen is (axMax-1, ayMax-1). ayMac is a global variable set to the height of the screen in lines (0 < ayMac <= ayMax).  axMac is a global variable set to the width of the screen in columns (0 < axMac < axMax).
Both axMac and ayMac are read-only by the application and valid only after screen initialization (FInitScreen).
The current CW has axMac == 80 (i.e. 40 column mode is not supported).  This fact should not be relied upon in application code.
.c.:5.3 TYPE WND/PWND - The Window Data Structure
typedef struct	{	WORD	id;	BITS	style:14;	BITS	fCursorOn:1;	BITS	fEnabled:1;	ARC	arcWindow;	ARC	arcClient;	PLFN	pfnWndProc;			/* Medium Model */	struct _wnd *pwndParent;	struct _wnd *pwndSibling;	struct _wnd *pwndChild;	BYTE	axCursor;	BYTE	ayCursor;	WORD	rgwExtra[cwExtraWnd];	} .i.WND (type);WND;typedef WND *PWND;
WND is a Window structure, PWND is a near pointer to a WND.
NOTE : DO NOT ACCESS THE ELEMENTS OF THE WND STRUCTURE DIRECTLY, use the macros and procedures provided [see below for suggested access method].
id an identifier for the window.  This is useful to distinguish between different windows using the same WndProc.  This field should not be changed at run-time.
style is the type of the window: either WS_TILED for root windows, or WS_CHILD for children of the root.  The style parameter is also used to indicate the subtype of a window, WS_VSCROLL and WS_HSCROLL must be defined if the window has vertical or horizontal scroll bars (respectively).  WS_BORDER must be defined if the window is to have a border.  e.g., scroll bar windows are WS_CHILD windows but in addition are either SBS_HORZ, or SBS_VERT to distinguish between horizontal and vertical scroll bars [SetWindowStyle()].
fEnabled is a flag that reflects whether the window is enabled or not (and can receive mouse messages) [EnableWindow()].
arcWindow is the absolute rectangle defining the absolute top right and bottom left corners of the window [MoveWindow() and SetWindowSize()].
arcClient is the absolute rectangle that defines the client area [GetClientArc()].
pfnWndProc is a pointer to the window manager for the window [SetWindowProc()].
pwndParent is a pointer to a window's parent [PwndParent()].  For example, a scroll bar scrolls (i.e. controls) its parent's window.
pwndChild is a pointer to a child window of the current window [PwndChild()].  The child window is physically contained within the parent window.
pwndSibling is a pointer to the next sibling window [PwndSibling()].  All children of a window are chained using pwndSibling.
Use the procedures AddChild() and RemoveChild() to re-organize the window tree. PwndParent(), PwndChild() and PwndSibling() can be used to walk the window tree but should not be used to restructure it.
rgwExtra defines zero or more words of extra data.  The size of cwExtraWnd is variable.  For compilation with the CS compiler, .i.cwExtraWnd;cwExtraWnd is defined as nothing, hence the WND structure is variable length.  For compilation with the CC compiler, cwExtraWnd is defined as 1, unless it is explicitly defined before "cwindows.h" is included.  Since the CC compiler does not allow variable length structures, WND's should be defined with the wndXXX macros (see below) in the CS compiler if at all possible.  Use the GetWindowWord(), and SetWindowWord() macros to access this field.
.c.:5.4 TYPE RRC - a RELATIVE Rectangle
typedef struct	{	BYTE	rxLeft;	BYTE	ryTop;	BYTE	rxRight;	BYTE	ryBottom;	} .i.RRC (type);RRC;typedef RRC *PRRC;
The RRC type defines a rectangle in Window relative coordinates.  Windows relative coordinates are defined relative to the Window's client area.
ryTop is the relative position of the top line.
rxLeft is the relative position of the leftmost column.
ryBottom is the relative position of the bottom line plus one.
rxRight is the relative position of the rightmost column plus one.  Note that the bottom and right values are MAC values.
.c.:5.5 TYPE ARC - an ABSOLUTE rectangle
typedef struct	{	BYTE	axLeft;	BYTE	ayTop;	BYTE	axRight;	BYTE	ayBottom;	} .i.ARC (type);ARC;typedef ARC *PARC;
The ARC type defines a rectangle in ABSOLUTE Screen coordinates.  The contents are similar to the RRC structure.
.c.:5.6 TYPE BOX - a box format type
typedef struct	{	char	chTopLeftCorner;	char	chTopRightCorner;	char	chBottomLeftCorner;	char	chBottomRightCorner;	char	chTopSide;	char	chBottomSide;	char	chLeftSide;	char	chRightSide; 	} .i.BOX (type);BOX;typedef BOX *PBOX;
Boxes are drawn using character I/O.  The characters to use when displaying a box are specified by the BOX data structure.
chTopLeftCorner, chTopRightCorner, chBottomLeftCorner, chBottomRightCorner are the characters to use for the corners of the box.
chTopSide, chBottomSide, chLeftSide, chRightSide, are the characters to use for the sides.
.c.:5.7 GLOBALS boxSingle, boxDouble
BOX boxSingle, boxDouble;
These constant boxes are defined for general use.
boxSingle uses a single line to draw the box, while boxDouble uses a double line.
The pre-defined boxes are read-only for the application.
.c.:5.8 TYPE MSG - the message structure.
struct	{	PWND		pwnd;	WORD		message;	WORD		wParam;	DWORD	lParam;	DWORD	time;	} .i.MSG (type);MSG;
The MSG structure is the form of all messages in the CW system.
pwnd defines the window that is to receive the message.
message is a code identifying the message.  All ids less than WM_USER are reserved for CW.  All ids equal to and above WM_USER can be used by the application.
wParam is a single word parameter with many uses.
lParam is a double word parameter with many uses.
time is the time that the message was queued (in system time units - do not rely upon this value).
You should not normally access the fields of the MSG structure.  See the section on Window Messages for more details on which messages are sent, and what parameters are used.
.c.:5.9 TYPE MENUBAR - a menu bar.
typedef struct	{	WORD		cmenu;	MENU *	rgmenu;	MPVKEYID *rgmpvkeyid;	} .i.MENUBAR (type);MENUBAR;
Defines a Menu bar (always at the top of the screen) containing MENU's.
cmenu is the number of MENU's on the menu bar.
rgmenu is an array of MENU's.
rgmpvkeyid is an array of mappings between virtual keys and menu items (see below) sometimes called accelerators (the list is terminated by a null MPVKEYID element that has both vkey and idItem fields zero).
.c.:5.10 TYPE MENU - a MENU (drop down).
typedef struct	{	WORD	idMenu;	BYTE	rxTitle;	BITS	ichHilite:4;	BITS	fHandle:1;	BITS	fEnabled:1;	BITS	filler:2;	WORD	cchTitle;	char *	pchTitle;	WORD	citem;	WORD	cchitemMax;	union		{		MENUITEM *rgmenuitem;		/* if fHandle is FALSE */		MENUITEM **prgmenuitem;		/* if fHandle is TRUE */		};	WORD	wParamUser;	} .i.MENU (type);MENU;
Defines a menu (a list of MENUITEMs).
idMenu is an identifier for the menu and should be unique among the menus on the menu bar.
rxTitle is the starting column of the menu title on the menu bar.
fHandle is TRUE if the array of menu items is specified by a handle.
fEnabled is FALSE if you wish the menu title to be greyed.
ichHilite is the index of the hilited character.  This character should be unique across the menu bar (and should normally be 0).  Zero indicates to hilite the first letter.
cchTitle is the length of the title in characters.
pchTitle is the text of the title.
citem is the number of menu items in the menu.
cchMaxItem is the length of the longest menu item in characters.
rgmenuitem is an array of menu items and is used if fHandle is FALSE.
prgmenuitem is a pointer to an array of menu items (i.e. a handle to a block of menu items) and is used if fHandle is FALSE.
wParamUser is an extra word that can be used by the application for anything it wants.  Normally wParamUser will contain information for utilizing the interactive menu help feature.
.c.:5.11 TYPE MENUITEM - a menu item (inside drop down).
typedef struct	{	WORD	idItem;	BITS	fEnabled:1;	BITS	fChecked:1;	BITS	fSeparator:1;	BITS	fHandle:1;	BITS	ichHilite:4;	BITS	bParamUser:8;	union		{		char	*szItem;		char	**pszItem;		};	WORD	wParamUser;	} .i.MENUITEM;MENUITEM;
Each menu item specifies one item that may be selected.
idItem is a identifier used to identify the menu item to the code that needs to handle WM_COMMAND messages.  The idItem should be unique for all items in the menu (and also must be unique relative to all idMenu fields of all MENU structures).
fEnabled indicates if the item is enabled.
fChecked indicates if the item is checked.
fSeparator indicates if the item is a horizontal line separator.
fHandle is TRUE if the item name is specified by a handle.
ichHilite is the index of the hilited character.  This character should be unique for the menu (and should normally be 0).  Zero indicates to hilite the first letter.
szItem is the text of the item and is used if fHandle is FALSE.
pszItem is a handle (double indirect near pointer) to the text of the item and is used if fHandle is TRUE.
bParamUser and wParamUser are a byte and a word (respectively) that may be used by the application.  Normally wParamUser will contain information for utilizing the interactive menu help feature.
.c.:5.12 TYPE MPVKEYID - accelerator entry.
typedef struct	{	WORD	vkey;	WORD	idItem;	} .i.MPVKEYID (type);MPVKEYID;
Defines one of a list of key accelerators (see MENUBAR).
vkey is a combined VK and KK.  Use the .i.VkeyOfVkKk();VkeyOfVkKk() macro to define the key and the keystates.  Only function keys and Backspace may be used as accelerators.  The valid KK values for this function are 0 (no shifts), KK_SHIFT, KK_CONTROL and KK_MENU (which all may be |'d together).
idItem is the id of the menu item that this key translates into.
The menu item with idItem should exist in the menu (if not the accelerator is ignored).  If the menu item is disabled, the accelerator will not work.  See the CW Messages document for more details on menus, KKs and interactive menu help.
.c.:5.13 TYPE FDE - file directory entry.
typedef struct	{	char reserved[21];	BYTE .i.atr (field);atr;	WORD wTime;	WORD wDate;	DWORD cbSize;	char szName[13];	} .i.FDE (type);FDE;
typedef FDE *PFDE;
This structure is used by .i.FFindFirst;FFindFirst / FFindNext to return information about the file located.
reserved is information used by the operating system in file searching.  This should not be read or written.
atr is the attribute mask of the file.
wTime and wDate give the system date stamp when the file was last modified.  They can be combined into a DWORD and compared to the time/date of another file.
cbSize is the size, in bytes, of the file.
szName is the name of the file.  This is not a full path specification; it is of the format "NAME" or "NAME.EXT" where NAME is the file's name, and EXT is its extension (if any).
.c.6. Keyboard Input and Control
See the document CWDRV.DOC for Keyboard functions.
.c.7. Mouse Input and Control
Various routines are provided to control the mouse input functions.
???? REVIEW ??? Later put into an installable driver ????
Currently we assume Microsoft Mouse 6.0 (or better) functionality.
.c.:7.1 Mouse Globals
.c.::7.1.1 fMousePresent
BYTE .i.fMousePresent (global);fMousePresent;
TRUE if a mouse is present in the system (FALSE otherwise).  Read-only by the application, valid only after screen initialization (FInitScreen).
.c.:7.2 Mouse Driver Routines
.c.::7.2.1 FEnableMouse
BOOL.i.FEnableMouse();FEnableMouse(fDisplay)BOOL fDisplay;
If fDisplay is TRUE then the mouse is turned on, otherwise the mouse is turned off.  Returns the previous state, or always FALSE if mouse does not exist.  The mouse is initially off.
.c.::7.2.2 SetMouseCursor
typedef struct	{	WORD	colHot;	WORD	rowHot;	WORD	rgwAndMaskGfx[16];	WORD	rgwXorMaskGfx[16];	WORD	wAndMaskText;	WORD	wXorMaskText;	} .i.MPVKEYID (type);MCB;
VOID.i.SetMouseCursor();SetMouseCursor(pMcb)MCB	pMcb;
Sets the mouse cursor to the attributes specified in the given MCB.  This allows the application to change the mouse cursor as desired.  If the application does not call SetMouseCursor, then the system default mouse cursors will be used (text: color inverting; graphics: arrow pointing up to the left).  See the Microsoft Mouse User's Guide for more details (functions 9 and 10).
The fields of the MCB structure are as follows:
colHot is the horizontal hot spot in the bitmap of the graphics mouse cursor.
rowHot is the vertical hot spot in the bitmap of the graphics mouse cursor.
rgwAndMaskGfx is the bitmap of the screen mask of the graphics mouse cursor.
rgwXorMaskGfx is the bitmap of the cursor mask of the graphics mouse cursor.
wAndMaskText is the screen mask of the text mouse cursor.
wXorMaskText is the cursor mask of the text mouse cursor.
.c.::7.2.3 MouseConditionalOff
typedef struct	{	WORD	xLeft;	WORD	yTop;	WORD	xRight;	WORD	yBottom;	} .i.MPVKEYID (type);MCOB;
VOID.i.SetMouseCursor();MouseConditionalOff(pMcob)MCOB	pMcob;
The mouse will not be drawn in the given screen region.
7.2.4 SwapMouseButton
BOOL.i.SwapMouseButtons();SwapMouseButton(fSwap)BOOL fSwap;
Set the swap state of the mouse buttons (fSwap TRUE => reverse buttons).  Return the old swap state.  This function is optional.
.c.::7.2.5 SetMouseDoubleSpeed
VOID.i.SetMouseDoubleSpeed();SetMouseDoubleSpeed(mps)WORD mps;
Sets the mouse's double speed threshold to mps Mickeys per second.  See the Microsoft Mouse User's Guide for more details (fxn 15).
.c.::7.2.6 Mouse Capture Routines
.c.::7.2.7 SetCapture
PWND.i.SetCapture();SetCapture(pwnd)PWND pwnd;
Captures the mouse.  All mouse events are sent to pwnd until the mouse is released.  Note that mouse events outside the window will also be sent to the window capturing the mouse so that care should be taken when using relative mouse coordinates.  Returns the address of the window that had the capture (or NULL if not captured).
.c.::7.2.8 ReleaseCapture
VOID.i.ReleaseCapture();ReleaseCapture()
Releases capture of the mouse.
.c.:7.3 Misc Mouse Functions
WORD.i.SetDoubleClickTime();SetDoubleClickTime(time)WORD time;
Set the mouse double click detection time.  Returns the old double click time (DOS 3 only).
.c.8. Windows
Windowing is an important concept to the CW system.  The main differences between CW and Windows, are that CW uses near pointers to windows, and does not have window classes.
.c.:8.1 Statically Creating Windows
The wnd* macros are provided for creating statically allocated WND structures (see Examples for use).
For the wnd* macros, the following parameters are used:
id is the id to be used to identify the window.
style is either WS_TILED or WS_CHILD.  In addition either any of the flags WS_BORDER, WS_HSCROLL, or WS_VSCROLL joined with the | operator. (a substyle may also be included).
fEnable specifies whether the window is initially enabled or disabled.
ax and ay specify the upper left corner of the window rectangle (in absolute coordinates).
dax and day specify the size of the window (in characters).
pfnWnd specifies the window manager procedure (i.e. WndProc).
pwndParent specifies the parent window.  (i.e., the window that this window sends messages to).
pwndSibling specifies the next sibbling window.
pwndChild specifies the first child window.

.i.wndGeneric();wndGeneric(id, style, fEnable, ax, ay, dax, day, pfnWndProc, pwndParent, pwndSibling, pwndChild)returns a window.
The wndGeneric function must be followed by the contents of the rgwExtra array in the window.  This is in turn followed by the endWndGeneric macro which finishes the definition of the window (see examples below).

.i.wndScrollBar();wndScrollBar(id, fVert, fEnable, ax, ay, dax, day, pwndParent, pwndSibling, ctickRep)returns a scroll window.
fVert indicates if the scroll bar is vertical (otherwise horizontal).
ctickRep is the repeat rate for scrolling (in system ticks : 1/18 second for DOS 3, 1/1000 second for OS/2).

.i.wndListBox();wndListBox(id, fBorder, fSorted, fEnable, ax, ay, dax, day, pfnWndProc, pwndParent, pwndSibling, pwndChild, isaBox, isaHilite, ctickRep)returns a vertical listbox window.
isaBox is the color index of the listbox.  
isaHilite is the color index of the listbox hilite. 
fBorder indicates if the listbox has a border.
fSorted indicates if the listbox is to be sorted.
ctickRep is the repeat rate for scrolling the listbox with the mouse.
The listbox should use ListBoxWndProc as its window manager procedure. isaBox and isaHilite can be accessed using .i.IsaListBox;IsaListBox(pwnd) and .i.IsaHiliteListBox;IsaHiliteListBox(pwnd). 

.i.wndEdit();wndEdit(id, fBorder, fEnable, ax, ay, dax, day, pwndParent, pwndSibling, rgchEdit, cchEdit, chFill, isa, isaSel)returns an edit window.
fBorder indicates if the edit window has a border.
rgchEdit is a character string to use as the edit buffer.
cchEdit is the size of the edit buffer in characters.
chFill is the character used for padding the blank space from the right end of the edit string to the right end of the window.
isa is the normal color for characters in the edit item (isaEdit for SDM edit items).
isaSel is the color for selections in the edit item (isaHilite for SDM edit items).
.c.::8.1.1 Examples
The following shows some examples of using the initialization macros for a window with one scroll bar.
extern WND wndTwoScroll;	/* forward declaration */
WND wndOne =	wndGeneric(idMain, WS_TILED, TRUE, 1, 1, 50, 20,	     FooWndProc, NULL, NULL, &wndScroll)	{1}	endWndGeneric;
WND wndTwo =	wndListBox(idList, TRUE, TRUE, TRUE, 5, 5, 10, 10,	     WndListBoxProc, NULL, NULL, &wndTwoScroll);WND wndTwoScroll =	wndScrollBar(idScroll, TRUE, TRUE, 14, 6, 1, 8,   &wndTwo, NULL);
. . . . .
	AddChild(&wndTwo,&wndTwoScroll);
	AddChild(&wndOne,&wndTwo);
  AddChild(NULL, &wndOne)
. . . . .
The {1} is the rgwExtra array for wndOne.  This array is variable length and its use is up to the application.
To initialize these windows for use, wndOne must be linked with the root window (i.e. AddChild(NULL, &wndOne) -- see above).
Note that the listbox must have a parent window to send messages to.  Also, scroll bars should be located on the right side of a listbox.

???????? REVIEW ???? Add exported listboxes ?????????
.c.:8.2 General Window Control
.c.::8.2.1 AddChild
VOID.i.AddChild();AddChild(pwndParent, pwndChild)PWND pwndParent, pwndChild;
Links the child window so that it is a child of the parent window.  If pwndParent is NULL, then the window is made a root window.
.c.::8.2.2 RemoveChild
VOID.i.RemoveChild();RemoveChild(pwndChild)PWND pwndChild;
Removes a child from its parent window.
.c.::8.2.3 EnableWindow
VOID.i.EnableWindow();EnableWindow(pwnd, fEnable)PWND pwnd;BOOL fEnable;
Enables (if fEnable == TRUE) or disables (if fEnable == FALSE) the specified window.  Disabled windows can not recieve mouse input.
.c.::8.2.4 GetClientRrc
VOID.i.GetClientRrc();GetClientRrc(pwnd, prrc)PWND pwnd;RRC *prrc;
Fills an RRC structure with the client rectangle of the specified window.
.c.::8.2.5 SetWindowStyle
VOID.i.SetWindowStyle();SetWindowStyle(pwnd, style)PWND pwnd;WORD style;
Sets or changes the style of the specified window.
.c.::8.2.6 SetWindowSize
VOID.i.SetWindowSize();SetWindowSize(pwnd, dax, day)PWND pwnd;BYTE dax, day;
Re-size the window to be dax columns wide, and day rows high.
.c.::8.2.7 MoveWindow
VOID.i.MoveWindow();MoveWindow(pwnd, ax, ay)PWND pwnd;AX ax;AY ay;
Move upper left corner of a window to the absolute coordinate on the screen.  This routine will only position the window logically.  It will not automatically move the window's contents.  It is primarily used to position a window and all its children before it is first painted.
.c.::8.2.8 SetWindowProc
VOID.i.SetWindowProc();SetWindowProc(pwnd, pfn)PWND pwnd;PFN pfn;
Set the WndProc of the specified window to *pfn.
.c.::8.2.9 GetWindowWord
WORD.i.GetWindowWord();GetWindowWord(pwnd, iw)PWND pwnd;WORD iw;
Returns the iw'th extra word of the WND structure specified.  Note this returns a WORD, cast it into the desired type.  It is the application's responsibility to ensure that the index is valid.
.c.::8.2.10 SetWindowWord
VOID.i.SetWindowWord();SetWindowWord(pwnd, iw, wExtra)PWND pwnd;WORD iw;WORD wExtra;
Set the iw'th extra word of the WND structure specified to wExtra.
.c.::8.2.11 PwndParent, PwndChild, PwndSibling
PWND.i.PwndParent();PwndParent(pwnd), .i.PwndChild();PwndChild(pwnd), .i.PwndSibling();PwndSibling(pwnd)PWND pwnd;
Return the parent, child or sibbling of the given window.  Note : these may be NULL.  Note : use these as read only (don't use them to restructure the window tree).
.c.:8.3 Window Drawing Routines
.c.::8.3.1 DrawWindow
VOID.i.DrawWindow();DrawWindow(pwnd)PWND pwnd;
Redraw (re-paints) an entire window and all its children  (implemented by SendMessage of WM_PAINT).  If pwnd is NULL, all windows will be painted (i.e. all root windows and their siblings).
.c.::8.3.2 DrawBorder
VOID.i.DrawBorder();DrawBorder(pwnd, pbox, di, szTitle)PWND pwnd;BOX *pbox;WORD di;char *szTitle;
Draw a border around a given window, using the box style defined by *pbox using di.  If szTitle is non-NULL then it is output at the left top hand corner of the border.  This does nothing if the window does not have style WS_BORDER.  Note: this is a macro call to DrawBorder2 with di for both diTop and diRest.
.c.::8.3.3 DrawBorder2
VOID.i.DrawBorder2();DrawBorder2(pwnd, pbox, diTop, diRest, szTitle)PWND pwnd;BOX *pbox;WORD diTop;WORD diRest;char *szTitle;
Draw a border around a given window, using the box style defined by *pbox using diTop for the top border line and diRest for the other 3.  If szTitle is non-NULL then it is output at the left top hand corner of the border.  This does nothing of the window does not have style WS_BORDER.
.c.:8.4 Rectangle Utilities
The following procedures provide Windows-like control of rectangles.  The are defined for relative rectangles (RRC's) but may also be used to operate on absolute rectangles (ARC's).
.c.::8.4.1 SetRect
VOID.i.SetRect();SetRect(prrc, rx1, ry1, rx2, ry2)PRRC prrc;RX rx1, rx2;RY ry1, ry2;
Set rectangle *prrc to coordinates specified.  Note : rx2 and ry2 are MAC values.  (Note : also works for ARCs).
.c.::8.4.2 IntersectRect
BOOL.i.IntersectRect();IntersectRect(prrcDest, prrcSrc1, prrcSrc2)PRRC prrcDest, prrcSrc1, prrcSrc2;
Fill *prrcDest with the intersection rectangle of rectangles *prrcSrc1 and *prrcSrc2.  Returns TRUE if intersection is not empty.  (Note : also works for ARCs).
.c.::8.4.3 UnionRect
VOID.i.UnionRect();UnionRect(prrcDest, prrcSrc1, prrcSrc2)PRRC prrcDest, prrcSrc1, prrcSrc2;
Fill *prrcDest with the union rectangle of rectangles *prrcSrc1 and *prrcSrc2 (i.e. smallest rectangle containing both rectangles).  (Note : also works for ARCs).
.c.::8.4.4 IsRectEmpty
BOOL.i.IsRectEmpty();IsRectEmpty(prrc)PRRC prrc;
Returns TRUE if rectangle *prrc is empty. (Note : also works for ARCs).
.c.::8.4.5 PtInRect
BOOL.i.PtInRect();PtInRect(prrc, rx, ry)PRRC prrc;RX rx;RY ry;
Returns TRUE if point (rx, ry) is in rectangle *prrc.  (Note : also works for ARCs).
.c.::8.4.6 CopyRect
VOID.i.CopyRect();CopyRect(prrcDest, prrcSrc)PRRC prrcDest, prrcSrc;
Copy rectangle *prrcSrc to *prrcDest.
.c.::8.4.7 SetRectEmpty
VOID.i.SetRectEmpty();SetRectEmpty(prrcDest)PRRC prrcDest;
Set a rectangle (*prrcDest) to be an empty rectangle.
.c.:8.5 Listbox Control
.c.::8.5.1 InitListBox
VOID.i.InitListBox();InitListBox(pwndListBox, pwfn)PWND pwndListBox;PWFN pwfn;
Initializes the listbox and fills it with items. pwfn is a pointer to a listbox control procedure as described in the SDM API document (12.2).  This procedure is the "on demand" procedure that provides the strings to fill the listbox.
.c.::8.5.2 GetListBoxOrientation
VOID.i.GetListBoxOrientation();GetListBoxOrientation(pwndListBox, pisz, pdisz)PWND pwndListBox;WORD pisz;WORD pdisz;
Gets the current listbox "orientation".  *pisz receives the index of the current selection and *pdisz gets the number of lines between the top of the displayed listbox and the current selction.  This routine is for use with InitListBoxOriented.
.c.::8.5.3 InitListBoxOriented
VOID.i.InitListBoxOriented();InitListBoxOriented(pwndListBox, pwfn, pisz, pdisz)PWND pwndListBox;PWFN pwfn;WORD *pisz;WORD *pdisz;
Reinitializes the contents of the listbox, and redisplays it with the given orientation.  If illegal values are given for *pisz or *pdisz, the corrected values are returned.


.c.9. Drawing inside a Window
The following routines are provided for screen output inside of a window.  Note that everything is character based, and all positions are (rx, ry), i.e. window relative coordinates.  Window relative coordinates are determined from the top left corner of the applicable client area (0 based).  All drawing will be clipped to the client area of the window.
.c.:9.1 Drawing
.c.::9.1.1 TextOut
VOID.i.TextOut();TextOut(pwnd, rx, ry, pch, cch, di)PWND pwnd;RX rx;RY ry;char *pch;short cch;WORD di;
Draw a character string to the specified window.  rx and ry specify the starting character.  pch points to the string to print (a near pointer).  cch is the number of characters to print.  If cch is -1, then the string is assumed to be zero-terminated.  di defines the di (draw mode | isa) to use for drawing.
.c.::9.1.2 CharOut
VOID.i.CharOut();CharOut(pwnd, rx, ry, ch, di)PWND pwnd;RX rx;RY ry;char ch;WORD di;
Draw a single character to the specified window.  rx and ry specify the window-relative coordinate.  ch is the character to output.  di defines the di (draw mode | isa) to use for drawing.
.c.::9.1.3 CharOutBorder
VOID.i.CharOutBorder();CharOutBorder(pwnd, rx, ry, ch, di)PWND pwnd;RX rx;RY ry;char ch;WORD di;
Draw a single character to the specified window.  rx and ry specify the window-relative coordinate (border included). ch is the character to output. di defines the di (draw mode | isa) to use for drawing.  This can be used to draw characters on the window border, and should only be used when necessary.
.c.::9.1.4 DrawBox
VOID.i.DrawBox();DrawBox(pwnd, prrc, pbox, di)PWND pwnd;PRRC prrc;PBOX pbox;WORD di;
Draws a box specified by the rectangle *prrc using the characters defined in *pbox.
.c.:9.2 Area Operations
.c.::9.2.1 FillRrc
VOID.i.FillRrc();FillRrc(pwnd, prrc, ch, di)PWND pwnd;PRRC prrc;WORD ch;WORD di;
Fill a rectangular region (rrc) within a window with character ch using di as color and draw mode.
.c.::9.2.2 BltArc
VOID.i.BltRrc();BltRrc(pwnd, rxDest, ryDest, drx, dry, rxSrc, rySrc)PWND pwnd;RX rxDest, rxSrc;RY ryDest, rySrc;BYTE drx, dry;
Move the a relative rectangle based at (rxSrc, rySrc) that is of size drx, dry to be based at point (rxDest, ryDest).  It moves both characters and attributes.  It does not erase under the source or anything other than a simple move (It is up to the application to do the rest of the work for a scrolling operation).
.c.::9.2.3 Area Save/Restore
.c.::9.2.4 SaveRrc
VOID.i.SaveRrc();SaveRrc(pwnd, prrc, lpbBuff)PWND pwnd;PRRC prrc;BYTE FAR * lpbBuff;
Save the relative rectangle *prrc into the far buffer *lpbBuff.  The size required to save the rectangle may be obtained by the CbSizeRrc() function.  The characters as well as the character colors are saved.
If font attribute mode is enabled (fFontAvailable != 0) then the font attributes are also saved.
.c.::9.2.5 RestoreRrc
VOID.i.RestoreRrc();RestoreRrc(pwnd, prrc, lpbBuff)PWND pwnd;PRRC prrc;BYTE FAR * pbBuff;
Restore the relative rectangle *prrc from the far buffer *lpbBuff.
.c.::9.2.6 CbSizeRrc/CwSizeRrc
WORD.i.CbSizeRrc();CbSizeRrc(prrc)PRRC prrc;
WORD.i.CwSizeRrc();CwSizeRrc(prrc)PRRC prrc;
Returns the number of bytes (CbSizeRrc) or words (CwSizeRrc) required to save the relative rectangle *prrc.  Note: the size required to save a rectangle depends on the screen mode (if font attributes are enabled (fFontAvailable != 0), the size needed is increased).
.c.:9.3 Cursor Operations
.c.::9.3.1 EnableCursor
VOID.i.EnableCursor();EnableCursor(pwnd, fDisplay)PWND pwnd;BOOL fDisplay;
Controls whether the character cursor for keyboard input is displayed or not for the specified window (note : only the window in focus will actually have use of the real hardware cursor).
.c.::9.3.2 MoveCursor
VOID.i.MoveCursor();MoveCursor(pwnd, rx, ry)PWND pwnd;RX rx;RY ry;
Moves the character cursor to the appropriate position within the window.
.c.:9.4 Color Control
The color entries allow changing of the current screen color, as well as setting system colors.  Colors and attributes are specified by an ISA (index to screen attribute) that defines the color as well as the blinking and highlight attributes.  The actual parameter passed to the output routines (TextOut, CharOut, FillRrc), is a "di" that is the drawing mode ("dm") combined with an "isa".
See the section on Draw modes for more information.
Note the system ISA's (i.e. <isaUserMin) are changable, the file .i.defcolor.c (file);defcolor.c will be provided to allow the application to customize the default system colors.  The ISAs in the range isaUserMin .. isaUserMax-1 are available for use by the application.
.i.isaUserMin;isaUserMin : the first user color available to the user.
.i.isaUserMax;isaUserMax : the last+1 color available to the user.
.c.::9.4.1 SetSysColor
VOID.i.SetSysColor();SetSysColor(isa, coBack, coFore, fHiBack, fHiFore)ISA isa;WORD coBack, coFore;BOOL fHiBack, fHiFore;
Sets the screen attributes for a specified isa.  coFore and fHiFore go together to form the foreground color (fHiFore => highlighed foreground).  coBack and fHiBack go together to form the backround color (fHiBack => highlighed background).
.c.::9.4.2 SetIsaColor
VOID.i.SetIsaColor();SetIsaColor(isa, coFore, coBack)ISA	isa;WORD coFore, coBack;
Set the color for the specified ISA.  Colors are limited to the range 0 <= co < instCur.coMac (the current color maximum for the color mode).  This function is better than SetSysColor since the IBM specific interpretation of Hilite is not relied upon.
.c.::9.4.3 GetIsaColor
VOID.i.GetIsaColor();GetIsaColor(isa, pcoFore, pcoBack)ISA	isa;WORD *	pcoFore;WORD *	pcoBack;
Get the colors for the specified ISA.  *pcoFore gets set to the foreground color, *pcoBack gets set to the background color.
.c.::9.4.4 SetRgca
VOID.i.SetRgca();SetRgca(isa, rgca)ISA isa;WORD *rgca;
Sets the array of ca's for the specified isa.  rgca specified a near pointer to a special fill array used by special drawing modes.
.c.::9.4.5 SetIsaFfont
VOID SetIsaFfont(isa, ffont)ISA	isa;WORD	ffont;
Set the font attributes for a specified ISA.  See CWDRV.DOC for explanation of font attributes (ffont).
.c.:9.5 Drawing Modes
The CW system provides a very powerful drawing mechanism.  Each isa specified a both a color (foreground, background and blinking), and a drawing mode.  The normal drawing mode dmNormal is the default drawing mode.  dm is a number specifying the drawing mode.  Drawing is defined as combining an old image (the old contents of the screen) and a new image (the new data) to form an output image (what gets shown on the screen).
Each component of an image is defined as a character and a character attribute (SAT).
A character attribute (CA) is the attribute byte that gets put on the screen (upper nibble = background color, lower nibble = foreground color).
The possible drawing modes are described below :
Values determined by old screen contents :
chOld = old screen character.caOld = old character attributes.
Values determined by the draw function.
chNew = new screen character.(one of a string for TextOut, a constant for FillRrc).
caNew = new character attribute.(the values set by SetSysColor for the particular isa).
Values output to the display :
chOut = screen character output.caOut = character attributes output.
Draw mode : rules
dmNormal : chOut = chNew; caOut = caNew;
dmText (aka. dmTextOnly) : chOut = chNew;
dmForeBack (aka. dmAttrOnly) : caOut = caNew;
dmFore : caOut = (caOld & 0xf0) | caNew;
dmBack : caOut = (caOld & 0xf) | caNew;
dmTextFore : chOut = chNew; caOut = (caOld & 0xf0) | caNew;
dmTextBack : chOut = chNew; caOut = (caOld & 0xf) | caNew;
dmTextMapB : chOut = chNew; caOut = rgcaFill[(caOld & 0xf0) >> 4];
dmTextMapF : chOut = chNew; caOut = rgcaFill[caOld & 0xf];
dmMapB : caOut = rgcaFill[(caOld & 0xf0) >> 4];
dmMapF : caOut = rgcaFill[caOld & 0xf];
For code space considerations not all modes will be supported for both the TextOut and the FillRrc operation.  The rgcaFill is an array of 16 bytes that specify the mappings of foreground of background colors.  Note that CW uses the high bit of the attribute for defining high intensity background colors (hence CW does not support any blinking characters - other than the input cursor).
The .i.DiMake();DiMake() macro is available for combining an isa and a dm (i.e. DiMake(dm, isa) == dm | isa, but it looks nicer).
.c.:9.6 Coordinate Conversions
The following four routines allow conversion between screen absolute and screen relative coordinates.
.i.AxOfRx();AxOfRx(pwnd, rx) : convert relative x -> absolute x
.i.AyOfRy();AyOfRy(pwnd, ry) : convert relative y -> absolute y
.i.RxOfAx();RxOfAx(pwnd, ax) : convert absolute x -> relative x
.i.RyOfAy();RyOfAy(pwnd, ay) : convert absolute y -> relative y
.c.:9.7 Screen Particulars
For more screen specific control, several variables are provided.
.c.::9.7.1 fMonochrome
BOOL .i.fMonochrome (global);fMonochrome;
Set if a monochrome adapter card is present.  Read only for the application.
.c.::9.7.2 chShadow/diShadow
char .i.chShadow (global);chShadow;WORD .i.diShadow (global);diShadow;
For drawing the shadows behind menus and dialogs, the chShadow is the character that is used, diShadow is the draw info (di | isa).  These are initialized and may be modified by the application (Read Write for application).  If diShadow is set to 0, then no shadows are drawn.
.c.10. Focus Control
.c.:10.1 Focus Routines
.c.::10.1.1 SetFocus
SetFocus provides control over the input focus.
PWND.i.SetFocus();SetFocus(pwnd)PWND pwnd;
Makes pwnd be the window in focus.
It sends a WM_KILLFOCUS message to the old window in focus and posts a WM_SETFOCUS message to the new window in focus.  All further keyboard input will be sent to pwnd until another SetFocus call is made.  SetFocus returns the former window in focus.
.c.::10.1.2 GetFocus
GetFocus returns the window having the current input focus or NUULL.
PWND.i.GetFocus();GetFocus(pwnd)PWND pwnd;
.c.:10.2 VARIABLE fMessage
BOOL .i.fMessage (global);fMessage;	// DOS 3 only
This global flag is set whenever the application should call PeekMessage to remove messages from the message queues.  This flag is only set if "important" messages come into the CW system.  This variable is read-only for the application.  "important" messages are defined as all messages except :
Mouse movement messages, VK_KEYUP messages and VK_KEYDOWN messages, unless they will generate a WM_CHAR message.
The fMessage flag is replaced by an OS/2 semaphore (hsemaMessage).  See the non-swapped CW document for more details.
.c.:10.3 VARIABLE abAbort - User abort.
WORD .i.abAbort (global);abAbort;
The global flag is set whenever the user types an ABORT key.  This variable is read-only for the application.  If the input queue is full, abAbort may be set but the ABORT key may not be inserted in the queue (in this case FlushAbort() will flush to the end of the input queue).
When abAbort is detected to be abAbortESC by the application, the FlushAbort function should be called to flush the input queue.
VOID .i.FlushAbort();FlushAbort();
Flush the ABORT key from the keyboard input queue and any key messages before it.
The abAbort values are:
abAbortNone (==0)	no ABORT
abAbortESC			ABORT (ESCAPE key)
abAbortBRK			ABORT (CTRL+BREAK key struck, no message in queue)
10.4 VARIABLE fPollKeyboard - DOS3 Keyboard test
BOOL .i.fPollKeyboard (global);fPollKeyboard;
The global flag is set when the application should call .i.PollKeyboard(); PollKeyboard().  This variable is read-only for the application, see the Message Pump section for proper usage.
.c.:10.5 VARIABLES fKeyIsUp, fKeyWasUp - DOS3 Keyboard test
BYTE .i.fKeyIsDown (global);fKeyIsUp;BYTE .i.fKeyWasUp (global);fKeyWasUp;
The fKeyIsUp flag is cleared when any key is depressed and set when any key is released.  This global is read-only to the application.
The fKeyWasUp flag is set when any key is released.  This global is read-write to the application (after clearing it, after a key is released the flag will be set).
The fKeyIsUp flag will not be cleared with TSR packages (thus repeat count problems will not exist).
There are two problems with keyboard repeat on the PC, both related to the fact that holding down a key causes it to repeat at a variable repeat rate (the type-matic rate programmed into the keyboard controller).  There are two useful features that are hindered by this problem.  First, fast scrolling on a fast machine, if the machine is fast enough to keep ahead of scrolling, then scrolling speed is limited to keyboard repeat speed.  Second, the overshoot problem, on slow machines the keyboard can repeat faster than the screen can be updated, when letting go of a repeating scroll key, the screen can scroll past where you want to go.  Thus the need to detect for (1) a key still depressed and (2) the key released.
A reasonably complicated fast-scroll-mode detection loop is required to implement clean scrolling (see examples for details).
.c.:10.6 TSR Support
.c.::10.6.1 SetTsrProtocol
VOID.i.SetTsrProtocol();SetTsrProtocol(wProtocol, verMajor, verMinor)WORD	wProtocol;BYTE	verMajor;BYTE	verMinor;
This procedure should be called only once and only if the app desires special TSR protocols to be observed.  The call must be made before the first call to EnableKeyboard.
The verMajor and verMinor values are reported the TSR (if present) and are determined by the app.  Since the TSR protocol codes identify the product to the TSR, these are typically assigned by the CW group.  Current wProtocol assignments are:
Word		55FFWorks	55FEMultiplan	55FD
The default protocol code is NULL, indicating no special TSR communication.
.c.11. Messages
The following procedures provide control of messages (see the document COWWM.DOC for a complete list of CW messages).
.c.:11.1 Message Routines
.c.::11.1.1 PeekMessage
BOOL.i.PeekMessage();PeekMessage(pmsg)MSG *pmsg;
Test and optionally get a message from the queue. Fill *pmsg with a message if one is ready.  Return TRUE if message is ready.  Return FALSE if no messages ready.
.c.::11.1.2 UngetMessage
VOID.i.UngetMessage();UngetMessage(pmsg)MSG *pmsg;
Push the message *pmsg back to the front of the message queue.  There is only 1 level of unget allowed.
.c.::11.1.3 DispatchMessage
DWORD.i.DispatchMessage();DispatchMessage(pmsg)MSG *pmsg;
Dispatches the specified message.
.c.::11.1.4 PostMessage
BOOL.i.PostMessage();PostMessage(pwnd, message, wParam, lParam)PWND pwnd;WORD message;WORD wParam;DWORD lParam;
Puts a message on the application queue.  Return FALSE if no room.
.c.::11.1.5 SendMessage
DWORD.i.SendMessage();SendMessage(pwnd, message, wParam, lParam)PWND pwnd;WORD message;WORD wParam;DWORD lParam;
Sends a message directly to the specified windows message handler (WndProc).  The DWORD return value is the value returned by the WndProc.
.c.12. Menus
The menu bar is the primary mechanism for choosing commands.  It provides a WINDOWS style menu interaction with multiple menus across a menu bar and multiple menu items under each menu.  When an item is selected, either via the mouse or via the keyboard, a WM_COMMAND message is sent to the root window.  The wParam component of the message is the identifier for the menu item selected.
.c.:12.1 Menu Bar
.c.::12.1.1 InitMenu
VOID.i.InitMenu();InitMenu(pwnd, pmenubar)PWND pwnd;MENUBAR *pmenubar;
Attaches the menu bar *pmenubar to the window *pwnd.  Only one window may have the menu at any time.  The new menu bar is drawn and enabled.  If either of pwnd or pmenubar is NULL, then the menu bar is deactivated (the application must draw over the menubar if desired).  Note : there can only be one menu bar active, and it is always displayed on the top line.
.c.::12.1.2 FEnableMenuBar
BOOL.i.FEnableMenuBar();FEnableMenuBar(fEnable)BOOL fEnable;
Controls whether the menu bar is enabled or not.  A disabled menu bar is still visible (the application can draw on top of it if desired).
.c.::12.1.3 EnableMenu
VOID.i.EnableMenuItem();EnableMenuItem(id, fEnable)WORD id;BOOL fEnable;
Controls whether a menu title is enabled or not.  A disabled menu is greyed, however it can still be pulled down.
.c.::12.1.4 EnableMenuItem
VOID.i.EnableMenuItem();EnableMenuItem(id, fEnable)WORD id;BOOL fEnable;
Controls whether a menu item is enabled or not.  A disabled menu item cannot be selected and is shown using different screen attributes from an enabled menu item.
.c.::12.1.5 CheckMenuItem
VOID.i.CheckMenuItem();CheckMenuItem(id, fChecked)WORD id;BOOL fChecked;
Controls whether a menu item is shown with a check mark after it or not.
.c.::12.1.6 FMenuItemChecked
BOOL.i.FMenuItemChecked();FMenuItemChecked(id)WORD id;
Returns TRUE or FALSE indicating whether the identified menu item is selected or not.
.c.::12.1.7 FindMenuItem
MENUITEM *.i.FindMenuItem();FindMenuItem(id)WORD id;
Returns the menu item identified.
.c.::12.1.8 DrawMenubar
VOID.i.DrawMenubar();DrawMenubar()
Draws the current menubar.
.c.::12.1.9 OpenMenu
VOID.i.OpenMenu();OpenMenu(id)WORD id;
Open the specified menu (id is the menu id).  This allows a dropdown to be opened by application control.
.c.::12.1.10 SetMenuKeys
VOID.i.SetMenuKeys();SetMenuKeys(vkPrim, vkSec)VK	vkPrim;VK	vkSec;
Allows two new keys to be defined as the menu activation keys.  The keys will function identicially.  The default values are VK_MENU and VK_F11.
.c.:12.2 Menu Creation Macros
In the future the concept of menus will be added to SDM to provide a standard Menu service (and associated editor).  For the current version, several menuitem() macros are provided to help define menu items.  The interested reader is refered to the example application for full use of menus, menu items, these macros and the menu help function.
MENUITEM.i.menuitem();menuitem(mid, sz, w)WORD mid;char *sz;WORD w;
Create a menuitem (static) that is initially enabled.  mid is the id for the item (it should be unique).  sz is the text of the item.  w is the wParamUser field (usually a string or id for the menu help function).  This macro assumes the first letter in the string shall be the hilited letter.
MENUITEM.i.menuitemD();menuitemD(mid, sz, w)WORD mid;char *sz;WORD w;
Like menuitem() except start with the item initially disabled.
MENUITEM.i.menuitemX();menuitemX(mid, sz, ich, w)WORD mid;char *sz;WORD ich;WORD w;
Like menuitem() except start with the ich specifies the index of the character to hilite (must be within the first 16 characters).
MENUITEM.i.menuitemSep();menuitemSep()
Defines a line separator item.

Other menuitem() macros may be available for other variants.
.c.13. Help
There is an integrated help hook in CW that allows the application to supply a context sensitive help mechanism.  The Application provides a Help() procedure that will be called by CW when the user hits the HELP key (VK_HELP_KEY, hard coded to be the F1 key).
The format of the Help() routine is as follows :
VOID FAR PASCAL.i.Help();Help(hem, hid, pv, kk)WORD hem, hid;VOID *pv;WORD kk;
Called by CW (and the application) to initiate a Help request.
hem is the help message which defines the major context of the help request.
hid is a (major context sensitive) id that specifies what to get help on (the minor context - a finer resolution of the context).
pv is an extra pointer that (depending on hem) can point to extra information structures (i.e. MENUs and MENUITEMs).
kk is the key shift states of the help key (i.e. since the HELP (F1) key maps to help regardless of shifts, this kk value can be used to implement Shift-F1 for tutorial).
There are five major contexts of HELP, each context has its own help message (hem) :
1) Help in an application window (hemUserMin and up).  This must be trapped by the application (check the WM_CHAR message for VK_HELP_KEY).  It is the application's responsibility to call Help() if desired in this case.  Th is indicates that the user wants help about an application window.  The use of the hid and pv fields are up to the application.
2) Help in menu bar (hemMenu).  The user wants help about the menus.  hid is the id of the menu (pmenu->idMenu).  pv is a pointer to the menu structure (pmenu).
3) Help in a menu item (hemMenuItem).  The user wants help about a menu item.  hid is the id of the menuitem (pmenuitem->idMenu).  pv is a pointer to the menuitem structure (pmenuitem).
4) Help in a dialog.  The user wants help about a dialog.  hid is the help id defined in the dialog template (definable in the dialog editor).
5) Help in an alert (MessageBox).  The user wants help about an alert.  hid is one of the hidMbox.... values (see cwindows.h).
Notes :
o The application may break down Application Window help contexts in any way desired (hemUserMin .. are available for this purpose).
o Help may be recursive (i.e. getting Help while within help), it is the applications responsibility to limit the level of recursion allowed (see the sample app for example).
o The only case where CW internally limits help is the prompt for the swap disk (Swapped CW only).
o Help ids for application windows and dialogs must be defined (and maintained) by the application.  For alerts, the values are predefined.  For menus, the values are the same as the menu/menuitem ids.
o If the Help() procedure is not supplied, a stub routine will be used.
.c.14. Miscellaneous
.c.:14.1 Misc System Routines
These are actually replaceable via an installable driver.
.c.::14.1.1 ClockTicks
DWORD .i.ClockTicks();ClockTicks();
Returns the time in approx. 1/18th of a second intervals.
.c.::14.1.2 Beep
VOID.i.Beep();Beep()
Produce an tone on the speaker.
.c.::14.1.3 Click
VOID.i.Click();Click()
Produce an click on the speaker (useful for key click).
.c.::14.1.4 RepaintScreen
VOID.i.RepaintScreen();RepaintScreen(wParam)WORD wParam;
Must be called when a WM_REPAINT message is received.  The wParam of WM_REPAINT must be passed to RepaintScreen.  Any graphics drawing must be rerendered.
.c.::14.1.5 RspAppIdle
WORD.i.RspAppIdle();RspAppIdle(cnx, lParam)WORD		cnx;DWORD	lParam;
This call-back allows the app to redefine idle processing on a global scale and is called whenever CW enters an idle state.  The cnx and lParam values are as follows:
cnx			LOWORD(lParam)
cnxDialog		pdlg of the current dialog.
cnxMenu		pmenu of the current menu item.
cnxMBox		sz0 parm passed in the MessageBox call.
Valid return values are:
rspSleep		the app instructs CW to wait for an input event.
rspContinue	the app has done some idle processing of its own.
rspAbort		the app instructs CW to abort the current context.
The default RspAppIdle returns rspSleep except for one case.  During the dialog context, RspAppIdle call the associated dialog proc with dlmIdle.  If the dialog proc returns TRUE, rspSleep is returned, otherwise it is assumed that some other idle processing has been performed and rspContinue is returned.
.c.:14.2 Dialog Boxes
The MessageBox Dialog Box is the only dialog box provided outside of SDM.
.c.::14.2.1 MessageBox
WORD.i.MessageBox();MessageBox(szText, sz1, sz2, mb)char *szText;char *sz1, *sz2;WORD mb;
Creates and displays a dialog box with one, two or three buttons.
szText is the text of the message.
sz1 and sz2 are additional message lines (should be NULL if not used).
mb is the message box type, and is either MB_OK, MB_YESNOCANCEL, MB_RETRYCANCEL, MB_OKCANCEL, MB_ABORT, MB_YESNO, MB_RETRY.  In addition the values MB_BEEP (to give a audible Beep) and MB_CAPTION (to use szText as the dialog-box caption) may be ORed with the MB_ value.
MessageBox returns which button was selected, either IDOK, IDYES, IDNO, IDCANCEL, IDRETRY or IDABORT.
.c.:14.3 Scroll Bar Functions
The current position of the scroll bar may be set / obtained as well as changing the scroll bar range.  Note: the window that gets specified in the following procedures is the scroll bar window itself.
.c.::14.3.1 SetScrollPos
short.i.SetScrollPos();SetScrollPos(pwnd, pos, fRedraw)PWND pwnd;short pos;BOOL fRedraw;
Set the scroll bar to the specified position (pos).  Re-draws the scroll bar if fRedraw is set.  Returns the old position of the scroll bar.
.c.::14.3.2 GetScrollPos
short.i.GetScrollPos();GetScrollPos(pwnd)PWND pwnd;
Returns the current scroll bar position.
.c.::14.3.3 SetScrollRange
VOID.i.SetScrollRange();SetScrollRange(pwnd, posMin, posMax, fRedraw)PWND pwnd;short posMin, posMax;BOOL fRedraw;
Set the scroll bar range to be [posMin, posMax].  Re-draws the scroll bar if fRedraw is set.
.c.:14.4 Edit Functions
.c.::14.4.1 SetEditText
VOID.i.SetEditText();SetEditText(pwnd, sz, fRedraw)PWND pwnd;char *sz;BOOL fRedraw
Copies sz to the text buffer associated with the edit window (pwnd).  Note that the text may be truncated if sz is larger than the buffer associated with the edit window.  Redraws the edit window if fRedraw is TRUE.
.c.::14.4.2 SetEditWidth
VOID.i.SetEditWidth();SetEditWidth(pwnd, cch)PWND pwnd;WORD cch;
Causes the edit item to become fixed in width.  After this call, the edit window will not scroll and the maximum number of characters that may be entered is cch.  cch must be less than or equal to the length of the edit space.  If cch < 0 then the window becomes a normal non-fixed edit item.
.c.::14.4.3 GetEditText
WORD.i.GetEditText();GetEditText(pwnd, sz, cchMax)PWND pwnd;char *sz;WORD cchMax;
Copies the contents of the edit buffer into sz up to a maximum of cchMax characters.  Returns the number of characters copied.
.c.:14.5 Exported Managers
The following exported window managers (WndProc's) will be provided for the pfnWndProc field of WND structures.
.i.ScrollBarWndProc();ScrollBarWndProc - for scroll bars.
.i.EditWndProc();EditWndProc - for edit items.
.c.:14.6 Work Buffer
The application must provide a near work buffer to the CW system.  The work buffer is used by the menu manager, the MessageBox and SDM functions.  The work buffer must be a fixed object in the default data segment.
Screen images are saved in a far work buffer (using the far work buffer interface).
.c.::14.6.1 PbAllocWork
BYTE *.i.PbAllocWork();PbAllocWork(cb)WORD cb;
Supplied by application : returns a near pointer to a work buffer that is guaranteed to have at least cb bytes free.  If the application can not supply the buffer, it must provide the error handler.  The maximum size requested will vary depending on the action being performed by the CW system.
.c.::14.6.2 FreeWork
VOID.i.FreeWork();FreeWork(pb)BYTE *pb;
Supplied by application.  Free the work buffer previously allocated with PbAllocWork.  Calls to PbAllocWork and FreeWork can be nested.
.c.::14.6.3 OutOfMemory
VOID.i.OutOfMemory();OutOfMemory()
Supplied by application.  This procedure is called by the SDM if it runs out of memory.  It is the application's responsiblity to handle this situation.  After handling the error, the application should return from OutOfMemory.
.c.::14.6.4 LpbAllocWorkFar
BYTE FAR *.i.LpbAllocWorkFar();LpbAllocWorkFar(cb)WORD cb;
Supplied by application : returns a far pointer to a far work buffer that is guaranteed to have at least cb bytes free.  If the application can not supply the buffer, it must provide the error handler (like MessageBox()) and return NULL (in which case the action for which this allocation was made will be cancelled -- eg: dialog or menu will not be brought up on the screen).  The maximum size requested will vary depending on the action being performed by the CW system.
.c.::14.6.5 FreeWorkFar
VOID.i.FreeWorkFar();FreeWorkFar(lpb)BYTE FAR *lpb;
Supplied by application.  Free the far work buffer previously allocated with LpPbAllocWork.  Calls to PbAllocWork and FreeWork can be nested.
.c.:14.7 Floppy control
CW does not provide file i/o facilities.  It does however provide the low level trapping for Phantom drives (the fake drive B: in single drive systems).  These services only exist for DOS 3 versions of CW (swapped and non-swapped).
.c.::14.7.1 fSingleFloppy
BYTE .i.fSingleFloppy (global);fSingleFloppy;
Global variable set (after FInitCow) if there is a single floppy in the system.
.c.::14.7.2 FValidDrive
BOOL .i.FValidDrive();FValidDrive(chDrive)char chDrive;
This provides a means of checking whether a drive exists or not (must be a real drive -- no phantom B: allowed).  To be safe all path names must be ok'd via this mechanism before being passed to DOS.
Note : the CW system is not totally Phantom drive free, there are some cases where the CW app starting from a phantom drive is not handled properly (currently -- Windows doesn't so why should we worry about it).
.c.:14.8 Extra Init/Term
.c.::14.8.1 LeaveCow
The .i.LeaveCow;LeaveCow call provides a means of unhooking CW from the system.  Upon returning to a windowing system, the system should be re-initialized with BackToCow and any corrupted windows re-painted.
VOID .i.LeaveCow();LeaveCow(fClearScreen)BOOL fClearScreen;
If fClearScreen is true, then clear the screen (otherwise keep old contents).
.c.::14.8.2 EndCow
The .i.LeaveCow;EndCow call must be called before the app terminates.  Its parameter is identical to LeaveCow with the following restriction.  EndCow(FALSE) must be called if no screen mode has been initialized successfully.
VOID .i.LeaveCow();EndCow(fClearScreen)BOOL fClearScreen;
If fClearScreen is true, then clear the screen (otherwise keep old contents).
.c.:14.9 INT 24 Errors
For DOS 3 (Swapped and non-swapped) there are some cases where DOS does not respond to the "ignore" return value.  Since file I/O is not provided by CW, it is the applications responsibility to use INT 21H calls to access the file system.  For such a system to be robust, it should clear the fInt24Error flag before each INT 21H call, and even if the INT 21H call returns success (i.e. not carry), if the fInt24Error flag is set, then the routine should fail.
This is a real-mode DOS bug and CW is merely providing a mechanism (bogus as it may be) for an application to write a robust file package.
.c.:14.10 Mouse Saving
The following optional routines are available for debuggers who wish to save the state of the mouse driver.
.c.::14.10.1 CbSizeMouseState
WORD .i.CbSizeMouseState();CbSizeMouseState()
Return the number of bytes needed to save the state of the mouse.  This size should be used to allocate the buffer to be passed to SaveMouseState().
Returns 0 if the mouse driver is not installed or the save feature is not supported.
.c.::14.10.2 SaveMouseState
WORD .i.SaveMouseState();SaveMouseState(lpbBuffer)BYTE FAR *	lpbBuffer;
Save the current state of the mouse into the buffer specified.  The buffer should be at least CbSizeMouseState() bytes in size.
.c.::14.10.3 RestoreMouseState
WORD .i.RestoreMouseState();RestoreMouseState(lpbBuffer)BYTE FAR *	lpbBuffer;
Restores the state of the mouse from the buffer specified.  The buffer must have been filled from a previous SaveMouseState() call.
.c.:14.11 Alarm Function
The message WM_ALARM will be sent to a window after SetAlarm has been called and the specified time has passed.  This feature can be used to force the timing of events, however, only one window at a time may have the alarm set.
.c.::14.11.1 SetAlarm
WORD .i.SetAlarm();SetAlarm(pwnd,ctick)
.c.::Set the alarm to send a message to the window pointed at by pwnd in ctick system ticks.
.c.::14.11.2 KillAlarm
WORD .i.KillAlarm();KillAlarm()
Kill the alarm that is currently set.
.c.:14.12 File Searching
.c.::14.12.1 FFindFirst
WORD .i.FFindFirst();FFindFirst(pfde, szName, atr)PFDE pfde;char *szName;WORD wAttr;
Finds the first occurrence of the file specified by szName with file attributes specified by atr.  szName can be a full path specification and may include the global file characters '*' and '?'.  The FDE structure pointed to by pfde is filled with information about the file located.  The return value is zero if no such files could be located, nonzero otherwise.
.i.atr (field);atr is a bitwise OR of the following masks:
Mask		Meaning if set-----	---------------0x01		include read-only files0x02		include hidden files0x04		include system files0x08		include volume label files0x10		include subdirectory files0x20		include archive files
.c.::14.12.2 FFindNext
WORD .i.FFindNext();FFindNext(pfde)char *szName;PFDE pfde;WORD wAttr;
Finds the next occurrence of the file specified in the immediately previous call to FFindFirst.  pfde must be the same as the pfde passed to FFindFirst.  The return value is zero if no more files could be located, nonzero otherwise.
.c.::14.12.3 FindClose
WORD .i.FindClose();FindClose();
Terminates the FFindFirst / FFindNext sequence.  This function must be called after the final FFindNext, before FFindFirst can be called again.
.c.15. SDM - Standard Dialog Manager
.i.SDM;The Standard Dialog Manager contains an implementation of New SDM.  Please refer to the SDM 2.0 documentations for details.
The CW SDM automatically centers dialogs for larger screens.  Dialog should be laid out to look nice in a 80x25 character screen (standard IBM CGA).
.c.16. Initialization / Message Pump.
The main program entry point is different for different versions of CW (see Appendices B and C).  The primary mechanism for communicating between windows is via messages, and it is the responsibility of the application to provide the main message pump.
The structure of the message pump should look somewhat like :
	{	while (1)		{		if (.i.PeekMessage();PeekMessage(&msg))			{			.i.DispatchMessage();DispatchMessage(&msg);			}		else			{			/* Idle Loop */			}		}	/* NOTREACHED */	}
You must explicitly call exit() to end the application (a WM_QUIT message type is provided for the application, but is not used by CW).
For DOS 3 versions, if an idle loop is used, then PollKeyboard() must be called whenever the fPollKeyboard flag is set.
.c.17. Development
The Development (i.e. Debug) versions of CW contain many assertions that check internal CW states as well as validating the interfaces to CW routines.
In addition, there are a few additional features that are provided to assist debugging and general development of a CW App.  Please check the version specific API supplements for more details pertaining to the CW version of interest (i.e. Swapped version has several heap checking routines).
The FTrapMouseRbutton() entry provides a means of using the right mouse button (which should NOT be used by the CW App) to signal some event.  The HELLO application provides code that illustrates one such purpose, dumping the character screen to a PAINT file (for screen shot generation).
BOOL.i.FTrapMouseRbutton();FTrapMouseRbutton()
Application procedure, called by CW when right mouse button hit.  Returns TRUE if message should be eaten.
If FTrapMouseRbutton() is not defined in an application, then a stub (that returns FALSE) will be provided.
Document Revision History
May xx / 87 (2.x) [SAR]Various WORKS specific changes.
Mar 9 / 87 (1.1 -- renumber) [SAR]Conversion to PC Word format (table of contents + indexed)New Menu structures (MENU/MENUITEM)New section on Menu MacrosSDM now in separate document
Mar 27 / 87 (2.1) [SAR]New version numbers (CW version and date stamped)Help, development hooks added
May 1 / 87 (2.4) [SAR]New keyboard handler (KK_KEYDOWN gone).UpdateShiftState() added.TSR keyboard macro support.PollKeyboard() for DOS3
July 7 / 87 (2.8) [SAR]2.8 release cleanup.
July 13 / 87 [SAR]Help recursive allowed.
Feb 6 / 88 (2.20) [SAR]Misc cleanup for installable drivers.UpdateShiftState now has 3 parms.SetCursorBlock() added
Apr 8 / 88 (2.21) [SAR]Full installable driverdriver API calls moved to CWDRV.DOCSetCursorBlock() removedSaveRrc/RestoreRrc -> far pointer
Apr 29 / 88 (2.22) [SAR]fFontAvailable stuffgraphic drawing supportSetColorMode() removedFar work buffer documented
Aug 19 / 88LpbAllocWorkFar can fail and return NULL.
Oct 21 / 88 [MRD]RepaintScreen, WM_REPAINT
Nov 30 / 88 [JC]DrawBorder2, CharOutBorder
Dec  6 / 88 [MRD]SetMenuKeys
Jan  4 / 89 [MRD]Some sections erroneously suggest that the screen is initialized after a call to FInitCow.  This is not true.  All apps except CBOX must call FInitCow and FInitScreen.
Jan 15 / 89 [MRD]SetTsrProtocol
Feb 12 / 89 [MRD]GetFocus, RspAppIdle
Feb 16 / 89 [CP]FFindFirst / FFindNext / FindClose, FDE
Mar 15 / 89 [MRD]IsaListBox, IsaHiliteListBox macros
Index
.Begin Index.
AbAbort (global)  28
AddChild()  17
ARC (type)  7
Atr (field)  11, 41
AX (type)  5
AxMac (global)  5
AxOfRx()  27
AY (type)  5
AyMac (global)  5
AyOfRy()  27
Beep()  35
BltRrc()  23
BOOL (type)  5
BOX (type)  8
BYTE (type)  5
CbSizeMouseState()  40
CbSizeRrc()  24
Cgraphic.h (file)  4
Cgraphic.txt (file)  4
CharOut()  22
CharOutBorder()  22
CheckMenuItem()  32
ChShadow (global)  27
Click()  35
ClockTicks()  35
CopyRect()  20
Cow.def (file)  4
Cow.lib (file)  4
Cow3.lib (file)  4
Cow5.lib (file)  4
Cowdebug.h (file)  4
Cowstub.exe (file)  4
Csdm.h (file)  4
Csdmtmpl.h (file)  4
CwExtraWnd  6
Cwindows.h(file)  4
Cwindows.txt (file)  4
CwSizeRrc()  24
Dcow.lib(file)  4
Dcow3.lib(file)  4
Dcow5.lib(file)  4
Defcolor.c (file)  24
DiMake()  27
DiShadow (global)  27
DispatchMessage()  30, 42
DLM (type)  5
DrawBorder()  19
DrawBorder2()  19
DrawBox()  22
DrawMenubar()  32
DrawWindow()  19
DWORD (type)  5
EditWndProc()  38
EnableCursor()  24
EnableMenuItem()  31
EnableWindow()  17
FDE (type)  11
FEnableMenuBar()  31
FEnableMouse()  12
FFindFirst  11
FFindFirst()  41
FFindNext()  41
FillRrc()  23
FindClose()  41
FindMenuItem()  32
Fixstub.exe (file)  4
Fixstub.exe (program)  4
FKeyIsDown (global)  29
FKeyWasUp (global)  29
FlushAbort()  28
FMenuItemChecked()  32
FMessage (global)  28
FMonochrome (global)  27
FMousePresent (global)  12
FPollKeyboard (global)  29
FreeWork()  38
FreeWorkFar()  39
FSingleFloppy (global)  39
FTrapMouseRbutton()  42
FValidDrive()  39
GetClientRrc()  17
GetEditText()  37
GetFocus()  28
GetIsaColor()  25
GetListBoxOrientation()  21
GetScrollPos()  37
GetWindowWord()  18
HANDLE (type)  5
Help()  34
InitListBox()  21
InitListBoxOriented()  21
InitMenu()  31
IntersectRect()  20
ISA (type)  5
IsaHiliteListBox  15
IsaListBox  15
IsaUserMax  24
IsaUserMin  24
IsRectEmpty()  20
KillAlarm()  41
LeaveCow  39
LeaveCow()  39, 40
LpbAllocWorkFar()  38
MENU (type)  9
MENUBAR (type)  9
MENUITEM  10
Menuitem()  33
MenuitemD()  33
MenuitemSep()  33
MenuitemX()  33
MessageBox()  36
MoveCursor()  24
MoveWindow()  18
MPVKEYID (type)  11, 12, 13
MSG (type)  8
Munge.exe (file)  4
Munge.exe (program)  4
OpenMenu()  32
OutOfMemory()  38
PbAllocWork()  38
PeekMessage()  30, 42
PFN (type)  5
PollKeyboard()  29
PostMessage()  30
PtInRect()  20
PwndChild()  18
PwndParent()  18
PwndSibling()  18
ReleaseCapture()  14
RemoveChild()  17
RepaintScreen()  35
RestoreMouseState()  40
RestoreRrc()  23
RRC (type)  7
RspAppIdle()  35
RX (type)  5
RxOfAx()  27
RY (type)  5
RyOfAy()  27
SaveMouseState()  40
SaveRrc()  23
SB (type)  5
ScrollBarWndProc()  38
SDM  42
SendMessage()  30
SetAlarm()  41
SetCapture()  14
SetDoubleClickTime()  14
SetEditText()  37
SetEditWidth()  37
SetFocus()  28
SetIsaColor()  25
SetMenuKeys()  32
SetMouseCursor()  12, 13
SetMouseDoubleSpeed()  13
SetRect()  19
SetRectEmpty()  20
SetRgca()  25
SetScrollPos()  36
SetScrollRange()  37
SetSysColor()  25
SetTsrProtocol()  29
SetWindowProc()  18
SetWindowSize()  17
SetWindowStyle()  17
SetWindowWord()  18
SwapMouseButtons()  13
TextOut()  22
TMC (type)  5
TMM (type)  5
UngetMessage()  30
UnionRect()  20
VkeyOfVkKk()  11
WND (type)  6
WndEdit()  15
WndGeneric()  15
WndListBox()  15
WndScrollBar()  15
WORD (type)  5
.End Index.
܀         v       q       m    h     c     a     _     ] 	 @ @@ @ @ @      y     w   &  u \  g  s     q     o '  1  m Q  [  k s   @s  }  y     w      u     s     q     o       m &  &  k @)  C)  i 						C)  **  >*  y H*  w +  +  u +  s `+  u+  q +  o +  +  m +  k ,  i j,  u,  g ,  C)  i 				,  ,  y ,  ,  w ,  u ,  ,  s ,  q ,  ,  o -  m ]-  o-  k w-  i y-  -  g -  e C)  i					-  -  -  y -  w .  .  u $.  s ^.  u.  q .  o .  /  m /  k n/  /  i /  g 0  C)  i					0  !0  y ,0  w p0  0  u 0  s 1  41  q ?1  o 1  1  m '3  +3  k ;3  J3  i N3  g n3  C)  i						n3  }3  y 3  w 3  3  u 3  s 3  3  q 3  o 4  %4  m '4  k X4  e4  i f4  e g4  c 4  C)  @					4  4  y 4  w 4  4  u 4  s 5   5  q $5  o Q5  b5  m h5  k 5  5  i 5  g 5  5  e C) 						5  5  y 6  +6  w .6  u 06  36  s m6  z6  q |6  o 6  6  m 6  6  k 6  i 6  7  g C) 						7  7  y 7  7  w 7  7  u 7  7  s =8  B8  q S8  X8  o ]8  b8  m A9  E9  k :  :  i 				:  :  y :  :  w :  :  u :  :  s ;  ;  q 2<  7<  o ?>  G>  m >  >  k H?  Q?  i 		Q?  ?  ?  y ?  ?  w s@  |@  u A  A  s PB  XB  q B  B  o D  D  m E  %E  k (E  i 					(E  8E  <E  y CE  FE  w E  E  u F  F  s ;F  CF  q {F  F  o F  F  m oG  }G  k G  i 				G  G  G  y G  G  w 	H  H  u H  I  s I  q I  I  o I  I  m I  I  k I  I  i 				I  I  I  y J  "J  w $J  0J  u 2J  <J  s >J  IJ  q uJ  yJ  o J  J  m J  J  k J  			J  J  y K  &K  w vK  zK  u K  L  s L  o L  m KL  OL  k L  L  i $M  *M  g WM  J  	 @		WM  ]M  y M  M  w N  N  u O  O  s %O  q qO  vO  o O  O  m O  O  k P  P  i Q  				Q  R  y R  w :R  @R  u R  R  s R  R  q S  'S  o [S  dS  m 
T  T  k >T  FT  i bT  		bT  gT  y T  T  w T  T  u U  &U  s U  U  q PV  TV  o aW  mW  m uW  k W  W  i X  			X  X  y X  X  w X  Y  u ?Y  FY  s {Y  Y  q #Z  )Z  o dZ  kZ  m Z  Z  k Z  Z  i 	Z  [  [  y [  \  w \  u H\  L\  s o\  \  q \  o s]  y]  m ]  ]  k ^  ^  i ^  					^  
_  y M_  [_  w ^_  u n_  r_  s _  _  q _  o _  _  m _  _  k Q`  T`  i y`  ~`  g 				~`  `  `  y `  `  w a  a  u Da  Ja  s a  a  q Nb  Qb  o 1c  5c  m Hc  Mc  k gc  					gc  c  y c  w #d  'd  u Bd  Gd  s `d  rd  q ~d  o d  d  m Qe  Ve  k e  
f  i f  g f  							f  )f  y 7f  w g  g  u Fh  Lh  s h  h  q h  h  o /i  ;i  m ji  vi  k i  i  i j  			j  #j  y 'j  w /j  Cj  u Vj  s j  j  q j  o |k  k  m k  k  k k  i 	l  l  g cl  j  						cl  hl  y l  l  w l  l  u l  s m  m  q n  n  o :n  Nn  m \n  k n  n  i n  n  g 								n  n  y =o  @o  w o   p  u p  p  s p  p  q rq  sq  o q  q  m q  q  k q  q  i 				q  Fr  Ir  y Nr  Qr  w r  r  u r  r  s #s  .s  q Ts  ]s  o s  s  m s  k t  t  i 				t  t  y au  fu  w u  u  u v  (v  s 2v  q v  v  o w  w  m 8w  ?w  k hw  ow  i w  			w  w  y )x  /x  w 4x  =x  u Tx  bx  p rx  n wx  x  i x  g x  x  e x  c >y  Ey  a 	 @ @Ey  ry  zy  y y  y  w y  y  u dz  gz  s z  z  q {  {  o ~  ~  m .  2  k N  	 		N  S  y h  v  w ~  u     s 6  ;  q S  d  o o  m     k Ӏ    i   g   							    y   Ё  w ܁  u K  P  s k    q   o ǂ  ̂  m     k     i &  g k  							k  n  y     w     u     s ǃ  q     o '  :  m G  k     i     g 						    ̅  y م  w     u     s ܆    q   o 9  ;  m l  r  k u  z  i   						    y ć  w ̇  ۇ  u   s     q   o   ň  m     k     i   g     							    y     w    u     s     q   Ȋ  o q  |  m     k     i   			    y     w   u   ϋ  s ڋ  q     o     m     k ̌  ӌ  i ^  b  g 				b  2  7  y K  X  w _  u     s     q 1  D  o Q  m     k ҏ  ڏ  i   						    y 6  ;  w Q  `  u i  s     q     o     m P  U  k m  ~  i   g 					      y     w     u   s U  W  q Y  [  o n  r  m     k     i 					  Ē  y     w     u     s 6  H  q T  o     m     k   ē  i ܓ  					ܓ    y   w [  _  u     s =  X  q m  o ە    m     k     i ͖    g 						    y ˗  З  w ԗ  ڗ  u     s     q     o     m ř  k K  O  i T  						T  V  y v  {  w     u ۚ  ޚ  s     q R  W  o k  x  m   k     i   				    y %  )  w E  I  u     s     q   o 3  6  m ;  =  k x  z  i   				    y 3  8  w L  Y  u `  s ʞ  Ξ  q     o     m     k )  6  i =  g 						=      y     w ß  ş  u ߟ    s     q 	  o     m     k     i 			     Š  y ܠ    w     u     s ӡ  ء  q     o    m ^  b  k x    i 				  u  z  y     w   u     s %  ,  q /  4  o T  c  m l  k     i   g 						  ̤  դ  y     w     u     s ե  ڥ  q     o   m     k   &  i 						&  0  y     w   Ω  u ة  s     q   o Ъ  ު  m   k     i 1  B  g &  i 							B  M  y ֫  ٫  w ܫ    u     s ;  C  q H  O  o     m   ˬ  k ֬  i [  				[  b  y c  h  w   ­  u     s %  6  q A  o     m ֮  ݮ  k     i   					  '  y .  w y  |  u     s կ  گ  q     o     m     k Q  Y  i v  					v  z  y '  /  w Q  W  u ^  h  s |    q     o     m յ  ۵  k     i 		  ;  E  y w    w   Ŷ  u     s (  .  q ķ  ̷  o ٸ  ڸ  m   k   i   			    y     w Y  ]  u     s   q !  -  o 3  m b  n  k t  i     g   						    y     w C  H  u `  x  s   q Ի  ٻ  o     m   k   0  i 8  g q  							q  y  y     w   '  u Q  T  s g  k  q     o ̽  ڽ  m   k     i   					    y     w v    u   s     q   տ  o ݿ  m     k     i     g 						  /  C  y J  w     u j  q  s     q     o   m b  i  k w    i   				    y     w ,  F  u S  s     q     o     m T  k  k s  i z    g 						    y     w (  1  u     s     q     o     m   k     i   					    y     w     u >  A  s     q     o     m   k f  j  i   						    y     w   u 4  8  s     q     o   m     k &  7  i B  g   							    y     w   u     s     q     o     m   k     i ,  0  g 							0      y     w h  m  u     s   q P  U  o m    m   k (  -  i I  						I  ]  y k  w 5  :  u U  h  s u  q     o 
     m 0  k     i     g I  								    y     w )  :  u E  s e  j  q     o   m     k   i /  @  g I  							@  K  y     w   u     s     q   o     m   	  k /  1  i L  M  g 			M  U  _  y     w   u     s   q     o ^  o  m z  k     i     g 					  2  <  y @  w     u     s     q     o     m 2  5  k :  <  i 			<      y     w Q  T  u     s     q     o     m     k   			    y     w   "  u ,  s l  q  q     o   m     k     i   g   								     y ;  N  w [  u     s +  ;  q E  o     m     k +  4  i 6  :  g 					:  S  Z  y \  a  w }    u     s     q     o D  L  m     k   	    y     w     u 0  4  s 6  >  q     o     m     k 4  D  i 				D  N  y     w     u      s =  ?  q 	    o     m     k     i 				    y C  F  w e  l  u     s     q   o   #  m ?  S  k a  i     g 					      y     w     u (  -  s F  W  q b  o r  w  m     k   i   						    y   &  w 1  u     s t    q   o     m   k     i "  '  g B  								B  S  y ^  w     u     s     q   o _ d m }  k  i   g  							  y  w F H u   s   q  o   m   k   i  g 3 							3 8 y Q b w m u $	 (	 s >	 C	 q X	 d	 o l	 m 	 	 k *
 8
 i @
 g f
 							f
 r
 y 
 
 w 
 
 u 
 s   q  o   m 3 7 k o z i   g 					   y ) . w M c u s s   q c h o   m  k ( 8 i K 						K P y p  w  u ( 6 s @ D q   o ? D m [ i k q i   g 							   y  	 w  u = A s W \ q u  o  m   k & ) i , 							, 2 y   w   u 6 E s H q P U o m | m  k   i   g 				 0 4 y ? I w   u   s  q   o   m 4 = k F P i 			P g j y   w   u # 4 s O d q y  o   m   k   							    y ' ' u ' q ' l %5 25 g 35 O d q y  o   m   k   	 @ @ @A	      Y    7    5    0               I       ? ?!H $                   p `'!H $                    `'     v   /  \ >  \ P  \   I         I   I   I                   p `'!H                 !? P  c  a s  a   a   G   G   I   I   I   I   I                           !                !    a   a   a 5  a ]  a   a   a   a   I   I   I   I   I   I   I   I                 !    a   a Q  a }  a   a   I   I   I   I   I   I   I   I   I   I   I                 !    a   a   G   I   I   I   I   I   I   I   I   I                !                !    a 4  G K  -   I   I   I   I         	           !                !      	           !K  d  a   a   a   a   a   a   I   I   I   I   I   I                 !      	           !    a   G ?  -   I   I   I   I                   !                !                !?  R  a q  G   -   I   I   I   I         	           !                !      	           !    a   a   a   a   a   a &  a >  a   I   I   I   I   I   I   I   I       	           !>  W  a   a   G   I   I   I &  a >  a   I   I   I   I                !      	           !    a   a   a   G   I   I   I   I   I   I   I   I                !      	           !    a +  a ?  a U  a h  a {  a   a   I   I   I   I   I   I   I           !      	           !    a   G   G   G   I   I   I   I   I   I   I   I      	           !                !    a -  G ?  -   I   I   I   I         	           !                !                !?  Q  a c  a {  G   I   I   I   I         	           !                !      	           !{    a   a   a   a   a   a   I   I   I   I   I   I                 !      	           !  	  a 0	  G E	  G   I   I   I   I   I   I   I   I   I      	           !                !E	  [	  a q	  G 	  G 	  G 	  G   I   I   I   I   I   I   I      	           !                !	  	  a 	  G 	  G 
  G   I   I   I   I   I   I   I   I                !      	           !
  +
  a G
  a ]
  G   I   I   I   I   I   I   I   I   I                !      	           !]
  u
  a 
  G 
  G   I   I   I   I   I   I   I   I   I      	           !                !
  
  a 
  a   a 1  a K  G   I   I   I   I   I   I   I      	           !                !K  \  a v  G   -   I   I   I   I         	           !                !                !    a   a   a   a   G   I   I   I   I   I         !                !      	           !    a "  G <  G R  G l  G   I   I   I   I   I         !      	           !                !l    a   a   a   a   a   a   I   I   I   I   I   I       	           !      	           !    a '  G =  G   I   I   I   I   I   I   I   I   I                !                !=  [  a q  G   G   G   G   I   I   I   I   I   I   I      	           !                !    a   G   -   I   I   I   I         	           !                !      	           !    a #  G ;  G U  G   I   I   I   I     	           !      	           !                !U  m  a   G   G   G   I   I   I   I     	           !      	           !                !    a   a   G   G %  G   I   I   I   I   I         !      	           !                !%  @  a W  a o  G   I   I   I   I   I   I   I         !                !      	           !o    a   a   G   I   I   I   I   I   I   I         !                !      	           !    a   a   G   G   I   I   I   I   I   I         !                !      	           !  )  a D  a b  a {  G   I   I   I   I   I   I         !                !      	           !{    a   a   a   G   I   I   I   I   I   I         !                !      	           !  2  a H  a ^  a   G   G   I   I   I   I   I         !                !      	           !    a   \   W [  W   W   R   I         I   I   I   I      U =                  !    v   v   v \  v   v   v   q '  l Q  l   I   I   I   I   I   I   I   I   I U = U 	Q  s  v   v   q    l   g @  b   ]   I   I   I   I   I   I   I   I   E =  U = U     v   v O  q   q   q   l   g   b   I   I   I   I   I   I   I   I E =  = E     v   v   q A  q   q   l )  g   g   I   I   I   I   I   I   I   I E =  = E     v    v    q !  l F#  l |#  l i$  l j%  l E&  l   I   I   I   I   I   I   I   I   I =  = 	E&  &  v &  q G'  l '  g '  g '  g 7(  g \(  g   I   I   I   I   I   I   I   I   I  E =  = \(  (  v @)  v V)  q *  l **  l +  g `+  g +  g   I   I   I   I   I   I   I   I   I  E =  E +  ,  v ,  q -  l .  g ^.  b .  b .  ]   I   I   I   I   I   I   I   I   = E = E Y E .  n/  v 0  v p0  v 1  v 1  v 1  q 2  l '3  l   I   I   I   I   I   I   I   I E = =  E '3  ;3  v n3  q 3  q 3  q 4  q X4  q 4  q 4  q 5  q   I   I   I   I   I   I   I   I   I = E  	5  Q5  v 5  v 5  v 6  v m6  v 6  v 6  q 6  l 7  l   I   I   I   I   I   I   I   I   I =  E 	7  N8  v 8  v A9  v t9  q :  l :  l ;  g 2<  b   I   I   I   I   I   I   I   I  E = W  = 2<  ?>  v >  v H?  v ?  v ?  v s@  v A  v A  v PB  q   I   I   I   I   I   I   I   I   I W = E 	PB  D  v D  q ?E  l E  g F  b ;F  b {F  b F  b   I   I  	 I   I   I   I   I   I  E = W  = F   G  v G  q 	H  l /H  g I  b I  ] J  X   I  	 I   I   I   I   I   I   IE = W  = W  J  uJ  v J  q J  l J  g <K  g vK  g K  b   I   I   I   I   I   I   I   IE =  = W  E K  
L  v KL  q L  l $M  l WM  l M  l M  l N  g   I   I   I   I   I   I   I   I  = E = W N  N  v (O  q qO  l O  g O  g P  g P  b   I   I   I   I   I   I   I   I   I  E = W  P  R  v :R  q R  l R  l S  l [S  l 
T  l >T  l bT  l   I   I   I   I   I   I   I   I   I E = W 	bT  T  v T  v U  v U  v PV  v V  q xW  l W  g   I   I   I   I   I   I   I   I   I  = W  E W  X  v X  v X  v ?Y  v {Y  v #Z  v dZ  v Z  v [  v   I   I   I   I   I   I   I   I   I W  E 	[  [  v \  q H\  l s]  g ]  g ^  b ^  ]   I   I   I   I   I   I   I   I    = E = W  ^  a_  v u_  v _  q Q`  l y`  l a  l Da  l a  l  	 I   I   I   I   I   I   I   I = E E = W a  b  v Nb  q mb  l b  g b  g 1c  g Hc  b   I   I   I   I   I   I   I   I   I  =  =  Hc  bc  v c  q #d  l Bd  g [d  b d  ] Qe  X   I   I   I   I   I   I   I   I= W   = W  Qe  le  v f  q If  q g  l g  l Fh  g h  g h  g   I  	 I   I   I   I   I   I   I  E = W  h  /i  v ji  v i  v i  q *j  l kj  l j  g j  b   I   I   I   I   I   I   I   I  = W  E j  j  v |k  q k  l k  g cl  b l  ] l  ]   I   I   I   I   I   I   I   I    = W  = W l  l  v n  q 5n  l `n  g n  b n  ] n  X   I   I   I   I   I   I   I   IW  = W  = W n  =o  v Lo  q o  l !p  g p  b p  b p  ]   I   I   I   I   I   I   I   IW E =  =  = p  q  v q  v Fr  v r  v r  v #s  v Ts  v s  v s  q   I   I   I   I   I   I   I   I   I = Y E 	s  t  v t  q t  q au  l u  l v  l v  l v  l w  l   I   I   I   I   I   I   I   I   I E = E 	w  8w  v hw  v w  v w  v x  q x  l >y  g ry  g   I   I   I   I   I   I   I   I   I  E Y = E ry  y  v y  v dz  v z  v {  v %{  q {  l {  g   I   I   I   I   I   I   I   I   I  W =  E {  @|  v }  v }  q 9}  q V}  q q}  q |}  q }  q j~  q   I   I   I   I   I   I   I   I   I = = W 	j~  ~  v ~  v .  v N  q c  l   g 6  b   I   I   I   I   I   I   I   I   I  = W   = 6  N  v   q   l ΀  g   b   ]   X   I   I   I   I   I   I   I   I = W  = W       v K  q f  l   g   b   ] R  X   I   I   I   I   I   I   I   IW  = W  = W R    v   q   l   g "  b h  ]   X   I   I   I   I   I   I   I   I= W  = W  =     v   q   l ׆  g 1  b u  ]   X   I   I   I   I   I   I   I   I = W  = W      v   q   l   g +  b   ]   X   I   I   I   I   I   I   I   I = W   = W   i  v   q   l >  g ^  b {  ] 2  X   I   I   I   I   I   I   I   I=  = W  = W 2  F  v   q   l ,  g   b 6  ] L  X   I   I   I   I   I   I   I   I = W  = W  L    v P  q h  l   g   b   ] >  X   I   I   I   I   I   I   I   IW  = W  = W >    v   q   l   g 1  b o  ]   X   I   I   I   I   I   I   I   I= W  = W  =     v ד  q *  l   g 8  b   ]   X   I   I   I   I   I   I   I   I= W  = W     Ȗ  v Q  q    l   l   l #  g   b   I   I   I   I   I   I   I   I= W =  = W      v   q   l R  g f  b   ]   X   I   I   I   I   I   I   I   I= W  = W       v   q 3  l G  g   b   ]   X   I   I   I   I   I   I   I   I = W  = W    $  v {  q ߟ  l   g w  b   ] ӡ  X   I   I   I   I   I   I   I   I = W  = W  ӡ    v A  q   l u  l   g   b /  ]   I   I   I   I   I   I   I   I = W  = W  /  O  v   q   q   l ե  g   b =  ]   I   I   I   I   I   I   I   I W   = W  =    v   q Y  l   g   b C  ] x  ]   I   I   I   I   I   I   I   I =  = W  = x    v Ъ  q   q ,  l   g   b   ]   I   I   I   I   I   I   I   I  = W  E =     v   q    l   g   b   ] P  X   I   I   I   I   I   I   I   IW  = W  = W P  կ  v   q    l   g   b L  ]   X   I   I   I   I   I   I   I   IK =  = W  =   5  v g  q   q Գ  l   g S  b   b   I   I   I   I   I   I   I   IK = W = W = K   ʹ  v   q '  l Q  g |  g   g յ  g   g   I   I   I   I   I   I   I   I W E = W =   ;  v w  v   v   v (  v Q  v ָ  q Y  q y  l   I   I   I   I   I   I   I   I   I  = E 	y    v !  v b  v   v   v    q C  l [  g   I   I   I   I   I   I   I   I   I   =  = [    v Ի  q   l ;  g Q  b g  ]   X   I   I   I   I   I   I   I   I  = W  = W     v ǽ  q   l   g   g +  b q  ]   I   I   I   I   I   I   I   I =  = W =  q    v   q   l   g   b   ] *  X   I   I   I   I   I   I   I   I = K = W  W *  M  v e  q   q   l ^  g w  g   b   b   I   I   I   I   I   I   I   I U = W = W     v '  q V  l   g O  b   ] $  X   I   I   I   I   I   I   I   I= W  = W  U $    v 0  v   v   v   q   l *  g   b   I   I   I   I   I   I   I   I = W   =     v   q >  l O  g   b   ]   X   I   I   I   I   I   I   I   I  =  = W =   .  v   q   l "  g   b   ]   X   I   I   I   I   I   I   I   IW  = W  = W     v !  q   l   g   b k  ]   X   I   I   I   I   I   I   I   I= W  = W  =     v   q   l   g   b h  ]   X   I   I   I   I   I   I   I   I = W   =      v P  q h  l   g (  b D  ]   X   I   I   I   I   I   I   I   IW  = W  = W   5  v P  q   l   g   b ?  ]   X   I   I   I   I   I   I   I   I= W  = W  =     v   q   l $  g I  b e  ] {  X   I   I   I   I   I   I   I   I = W  = W  {    v   q *  l q  g   b "  ] |  X   I   I   I   I   I   I   I   I=  = W  = W |    v   q 7  l w  g   b U  ] ~  X   I   I   I   I   I   I   I   IW = W = W = W ~    v   q   l   g   b "  b v  ]   I   I   I   I   I   I   I   IW W =  = Y = v    v   q   q   q   q   l `  g   g   I   I   I   I   I   I   I   I = E = W =     v M  v   v   q \  l   l p  l ;  l   l   I   I   I   I   I   I   I   I   I E W E 	    v   q   l   g 1  b l  ] ~  X   I   I   I   I   I   I   I   I = W  =   ~    v   q   l   g   b 6  ] r  X   I   I   I   I   I   I   I   IW  = W  = W r    v &  q m  l   g +  b S  ] }  ]   I   I   I   I   I   I   I   IW U W = W  = }    v   q   l D  l   l   g   b   I   I   I   I   I   I   I   IW U  = U = U     v /  q   l   g   b =  b L  b   I   I   I   I   I   I   I   IW U E = W  = L    v   q   l   g   b   ]   X   I   I   I   I   I   I   I   I = W  =  =     v   q :  l   g   b (  ] A  X   I   I   I   I   I   I   I   I  = W  = W A    v r  q   l   g   b   ] g  X   I   I   I   I   I   I   I   IW  = W  = W g    v   q t  l   g   g   b   ]   I   I   I   I   I   I   I   IW =  E =  =   "  v ;  q m  l   g   b   ] _ X   I   I   I   I   I   I   I   I= W  = W  = _ x v  q  l  g  b  ]  X   I   I   I   I   I   I   I   I = W  = W    v  q  l  g  b  ] 3 X   I   I   I   I   I   I   I   I= W  =  = W 3 L v  q O l $	 l >	 g T	 b %
 ]   I   I   I   I   I   I   I   I= =   = W  %
 c
 v 
 q 
 l  g  b 3 ] K X   I   I   I   I   I   I   I   I = W =  = W K  v  v  q ) l H g w b  ]   I   I   I   I   I   I   I   I = W  =  =  c v  q  l K g k b  ] @ X   I   I   I   I   I   I   I   I= W  = W  = @ Z v ? q V l  g  b  ]  X   I   I   I   I   I   I   I   IW  = W  =   = v W q p l  g 6 b r b P ]   I   I   I   I   I   I   I   IW W = W   = P h v  q  l  g  b g ]  X   I   I   I   I   I   I   I   I = W  = W    v  v  q  l  l  g G b  b   I   I   I   I   I   I   I   I = W =  =   v l q  q   q   l P! g ! g ! b   I   I   I   I   I   I   I       ? = W =  ! " v " v 7# v # v # v $ v $ v '% v % v   I   I   I   I   I   I   I   I   I W = U 	% % v & v 1& v P& v ' v -' v U' v ' v ' v   I   I   I   I   I   I   I   I       W = U 	' ' v ' q ' ' f ( f ( f '( f 5( f         I         I   I   I   I   I   I 
     @? = 5( H( p V( p d( p w( p ( p ( p ( p ( p ( p   I   I   I   I   I   I   I   I   I  @
     @	( ( p ( p ( p ) p %) p 4) p I) p ^) p u) p   I   I   I   I   I   I   I   I   I  @
     @	u) ) p ) p ) p ) p ) p ) p ) p * p * p   I   I   I   I   I   I   I   I   I  @
     @	* 1* p G* p V* p k* p * p * p * p * p * p   I   I   I   I   I   I   I   I   I  @
     @	* * p * p + p &+ p 5+ p G+ p Z+ p i+ p |+ p   I   I   I   I   I   I   I   I   I  @
     @	|+ + p + p + p + p + p + p  , p , p *, p   I   I   I   I   I   I   I   I   I  @
     @	*, :, p L, p ], p l, p }, p , p , p , p , p   I   I   I   I   I   I   I   I   I  @
     @	, , p - p - p 4- p N- p j- p - p - p - p   I   I   I   I   I   I   I   I   I  @
     @	- - p - p - p . p . p (. p ;. p X. p l. p   I   I   I   I   I   I   I   I   I  @
     @	l. . p . p . p . p . p . p . p / p / p   I   I   I   I   I   I   I   I   I  @
     @	/ '/ p 7/ p G/ p Z/ p k/ p y/ p / p / p / p   I   I   I   I   I   I   I   I   I  @
     @	/ / p / p / p / p 	0 p 0 p ,0 p >0 p P0 p   I   I   I   I   I   I   I   I   I  @
     @	P0 m0 p |0 p 0 p 0 p 0 p 0 p 0 p 0 p 1 p   I   I   I   I   I   I   I   I   I  @
     @	1 1 p ,1 p <1 p M1 p _1 p r1 p 1 p 1 p 1 p   I   I   I   I   I   I   I   I   I  @
     @	1 1 p 1 p 1 p 1 p 
2 p 2 p &2 p 42 p J2 p   I   I   I   I   I   I   I   I   I  @
     @	J2 Y2 p g2 p 2 p 2 p 2 p 2 p 2 p 2 p 2 p   I   I   I   I   I   I   I   I   I  @
     @	2 2 p 3 p !3 p 43 p N3 p i3 p x3 p 3 p 3 p   I   I   I   I   I   I   I   I   I  @
     @	3 3 p 3 p 3 p 3 p 4 p 4 p .4 p C4 p [4 p   I   I   I   I   I   I   I   I   I  @
     @	[4 j4 p y4 p 4 p 4 p 4 p 4 p 4 p 4 p 4 p   I   I   I   I   I   I   I   I   I  @
     @	4 5 p 5 p %5 p 25 k 35 k 45   I   I   I                     I   I   I   I   I   I= 
     @5 
     v     
    @    !  h+  4  ;  QE  6J  P  U  [  b  %i   n  (u  3|    d    e  (     5  z  ٭  M  ú  
          4  =    ]          >! % G' + U/ X3 4                        F           	 @   
     1    3    *                        n    X    &        4    T                Z    *    G    C     w   !    "    # \   $ >   %    &    '    ( o   )    * !   + (   ,    - <   . 7   /  	  0    .     /    0    1    2            4       G'  4  4        " *         03/18/9210/21/884 
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cowwm.doc ===
1           K        C#.STY                                                              HPLASMS2 @ @r     		--	
	CW API Guide (2.21) Messages	
Character WindowsAPI Guide (2.21 : Messages)
Scott RandellMicrosoft Applications Division
Table Of Contents
.Begin Table C.
1. Introduction	3
2. Control Messages	3
4. Mouse Input Messages	5
5. Menu Messages	6
6. Scroll Bar Messages	7
7. Edit Messages	8
8. Listbox Messages	8
9. Overlapping Window Messages	9
10. User Messages	10
.End Table C.


.c.1. Introduction
This is an Appendix to the CW API Guide that details the messages sent to a CW application (as well as some used internally in CW).
A CW application is a message driven system, and understanding of messages is very important to writing CW apps.  Messages are normally sent or dispatched to a WndProc.  The parameters to a WndProc are the fields of the message (except the time stamp).
The pwnd parameter specifies which window this message is describing.  If a WndProc services only one window, than this parameter can be ignored (or even better put in an assertion check).
The message parameter determines the message type, and how the wParam and lParam are to be interpreted.
In the following, we list all messages types used by CW, when they are sent, what should be done when they are received, and how the parameters are to be interpreted.
.c.2. Control Messages
 The following messages specify certain control events:
.i.WM_PAINT;WM_PAINTThe WM_PAINT message is sent to a window (and its children) whenever the DrawWindow() procedure is called. The CW system will never send a WM_PAINT message on its own.
At this time bordered windows should call DrawBorder() with the correct border style, color and optional window title.
wParam and lParam are not used.
.i.WM_REPAINT;WM_REPAINTThe WM_REPAINT message is sent to a single root window (each root window should be prepared to process the message) when CW determines that a system event (currently just under OS/2) requires that the screen be repainted.  Only the CW system should send a WM_REPAINT message.
At this time the application must call RepaintScreen(wParam) with the wParam of the message.  Any graphic drawing must be rerendered by the application.
lParam is not used.
3. Keyboard Input Messages
Keyboard input is always sent to one window at a time (the window in focus).  This window is set by the SetFocus() procedure.
.i.WM_SETFOCUS;WM_SETFOCUSThe window is now getting the keyboard input focus (and will receive keyboard input messages).  At this point you can decide if you wish to enable the input cursor [EnableCursor()] or re-position the cursor [MoveCursor()].
wParam and lParam are not used.
.i.WM_KILLFOCUS;WM_KILLFOCUSThe window is now losing the keyboard input focus.  There is no need to disable the input cursor since this is done automatically by CW (i.e. only the window with focus will have a visible input cursor).
wParam and lParam are not used.
.i.WM_KEYDOWN;WM_KEYDOWN / .i.WM_KEYUP;WM_KEYUPThese messages indicate key transitions.  Normally these messages are ignored (use the WM_CHAR message instead).
wParam is the virtual key that was depressed / released.
lParam is the same as the WM_CHAR message (below) except that the KK_VK field contains a scan code (do not rely on scan codes).
.i.WM_CHAR;WM_CHARThe implementation of WM_CHAR is slightly different in CW than in Windows.  The WM_CHAR contains translated as well as non-translanted key codes.  By definition Virtual Key codes are all greater than 255.  Translated key codes are all less than 256.  Hence, if a key sequence can be translated into an ascii character,
wParam will contain that translated ascii code (i.e. <256).
If a key can not be translated (for example : the HOME key), then the virtual key code (>=256) will be in wParam.  This allows one big case statement for WM_CHAR messages, and allows most applications to ignore WM_KEYDOWN/WM_KEYUP messages altogether.
The lParam for WM_KEYDOWN, WM_KEYUP and WM_CHAR messages is defined as follows :
LOWORD(lParam) contains the repeat count for the key.
HIWORD(lParam) contains the keyboard shift state at the time the key event occured.  HIWORD(lParam) can be masked with the following masks to determine  information about the shift states and so on :
.i.KK_EXTENDED;KK_EXTENDED	if the key came from the extended keypad.
.i.KK_ALT;.i.KK_MENU;KK_ALT (KK_MENU)	if the menu key was active when the key event occured.
.i.KK_CONTROL;KK_CONTROL	if any control key was down when the key event occured.
.i.KK_SHIFT;KK_SHIFT	if any shift key was down when the key event occured.
.i.KK_CAPLOCK;.i.KK_CAPITAL;KK_CAPLOCK (KK_CAPITAL)	if Caps lock key was down when the key event occured.
.i.KK_NUMLOCK;KK_NUMLOCK	if the Num lock key was down when the key event occured.
.i.KK_SCRLOCK;KK_SCRLOCK	if the Scroll lock key was down when the key event occured.
.i.KK_VK;KK_VK	9 bit virtual key before the ToAscii conversion.
.c.4. Mouse Input Messages
Mouse input is usually sent to the window which the mouse points to.  For all messages, lParam contains the position of the mouse within the window.
LOBYTE(lParam) is the rx coordinate.
HIBYTE(lParam) is the ry coordinate.
LOBYTE(HIWORD(lParam)) is the ax coordinate.
HIBYTE(HIWORD(lParam)) is the ay coordinate.
The absolute coordinates are useful in the case that the mouse is outside the client area (i.e. on the border, see MK_NONCLIENT).
wParam can be masked with the following masks to determine information about the mouse shift states and so on :
.i.MK_LBUTTON;MK_LBUTTON : if Mouse left button is down.
.i.MK_RBUTTON;MK_RBUTTON : if Mouse right button is down.
.i.MK_MBUTTON;MK_MBUTTON : if Mouse middle button is down.
.i.MK_SHIFT;MK_SHIFT : if Keyboard shift key is held down.
.i.MK_CONTROL;MK_CONTROL : if Keyboard control key is held down.
.i.MK_NONCLIENT;MK_NONCLIENT : set if mouse is outside the client area (i.e. on the border).
.i.MK_NONCLIENT_X;MK_NONCLIENT_X : set if X coordinate outside clientrea
.i.MK_NONCLIENT_Y;MK_NONCLIENT_Y : set if Y coordinate outside client area
The following is a list of all mouse messages :
.i.WM_MOUSEMOVE;WM_MOUSEMOVEthe mouse has moved.
.i.WM_LBUTTONDOWN;WM_LBUTTONDOWNthe left button has just been depressed.
.i.WM_LBUTTONUP;WM_LBUTTONUPthe left button has just been released.
.i.WM_RBUTTONDOWN;WM_RBUTTONDOWNthe right button has just been depressed.
.i.WM_RBUTTONUP;WM_RBUTTONUPthe right button has just been released.
.i.WM_LBUTTONDBLCLK;WM_LBUTTONDBLCLKthe left button has been double clicked
.i.WM_RBUTTONDBLCLK;WM_RBUTTONDBLCLKthe right button has been double clicked.
The double click interval is set by the SetDoubleClickTime() procedure.  Reversing the mouse buttons is provided by the SwapMouseButton() procedure (this is an optional feature).
.i.WM_NCLBUTTONDOWN;WM_NCLBUTTONDOWNthe left button has just been depressed.
The WM_NCLBUTTONDOWN is a special message only sent for overlap window processing.  Refer to the overlap window API (OVERLAP.DOC) for details.
.c.5. Menu Messages
There are two messages sent to a window if that window has the menubar attached to it (see InitMenu()).
.i.WM_INITMENUPOPUP;WM_INITMENUPOPUPThis message is sent just before a pull-down menu is pulled down.  This allows the application to re-structure menuitems and only enable those that it wants enabled.
wParam contains the id of the menu that is about to be openned.
LOWORD(lParam) = pmenu = pointer to the MENU structure that has been pulled down.
HIWORD(lParam) will normally be 0, but will be 1 if the menu item was activated by an accelerator.
.i.WM_COMMAND;WM_COMMANDThis message is sent in one of three cases :
The user selects an enabled menu item.  wParam is the id of the menuitem.  LOWORD(lParam) = pmenuitem = pointer to MENUITEM structure selected.  HIWORD(lParam) == 0.
The user selected a menu item by using an accelerator.  wParam is the id of the menuitem.  LOWORD(lParam) = pmenuitem = pointer to MENUITEM structure selected.  HIWORD(lParam) == 1.
The user selects a menu (i.e. pull-down), but closes the menu before selecting a menu item.  wParam is the id of the menu.  LOWORD(lParam) = pmenu = pointer to MENU structure pulled down and released.  HIWORD(lParam) == 2.
.i.WM_DISABLEDCOMMAND;WM_DISABLEDCOMMANDThis message is sent when a user clicks on a disabled menu item
wParam will contain the id of the menuitem, LOWORD(lParam) = pmenuitem = pointer to MENUITEM structure selected. HIWORD(lParam) == 0.
.i.WM_MENUSELECT;WM_MENUSELECTthe user has moved to a menu title or item (but has not activated it).  This is used to implement the interactive single line menu help feature.  It is up to the application to supply code for this feature.
When the help line is should be cleared (when the menu gets closed) WM_MENUSELECT will be sent with lParam == 0.  wParam containd more information about why the help should be cleared.  Values are: .i.enClear;enClear (== 0) the help line must be cleared, .i.enCommand;enCommand prepare for a WM_COMMAND message.
If HIWORD(lParam) == 0, then CW is asking for help regarding a menu item.  wParam is the id of the menuitem.  LOWORD(lParam) = pmenuitem = pointer to MENUITEM structure selected (see exception below).
If HIWORD(lParam) == 1, then CW is asking for help regarding an accelerated menu item.  wParam is the id of the menuitem.  LOWORD(lParam) = pmenuitem = pointer to MENUITEM structure selected (see exception below).
If HIWORD(lParam) == 2, then CW is asking for help regarding a menu title.  wParam is the id of the menu.  LOWORD(lParam) = pmenu = pointer to MENU structure pulled down and released.
.i.WM_MENUINACTIVE;WM_MENUINACTIVEsent when the menu has become inactive.
.c.6. Scroll Bar Messages
The scroll window sends commands to the parent window to cause the parent window to scroll based on user requests.  The parent must respond to the WM_VSCROLL and WM_HSCROLL messages (for vertical and horizontal scrolling respectively).  HIWORD(lParam) always contains the scrollbar (i.e. child) window.
wParam contains one of the following:
.i.SB_LINEUP;SB_LINEUPscroll up a line or left a character.
.i.SB_LINEDOWN;SB_LINEDOWNscroll down a line or right a character.
.i.SB_PAGEUP;SB_PAGEUPscroll up or left a page.
.i.SB_PAGEDOWN;SB_PAGEDOWNscroll down or right a page.
.i.SB_THUMBPOSITION;SB_THUMBPOSITIONscroll to the position requested.  LOWORD(lParam) is the scroll position.
.i.SB_THUMBTRACK;SB_THUMBTRACKfor tracking scroll bars.  LOWORD(lParam) is the current scroll position.
.i.SB_ENDSCROLL;SB_ENDSCROLLsent when the thumb is released, as well as SB_THUMBPOSITION.  LOWORD(lParam) is the scroll position.
.i.SB_TOP;SB_TOPscroll to top.
.i.SB_BOTTOM;SB_BOTTOMscroll to bottom.
.c.7. Edit Messages
In order to set and examine the contents of the text buffer the functions SetEditText and GetEditText should be used.  Messages are provided to perform CUT, COPY, PASTE, and INSERT functions and also to let the edit window to inform the application when the contents of the edit buffer have been changed.
.i.EM_SETSET;EM_SETSELset the selection within the edit window.  The starting position is in the low order word of lParam.  The ending position is in the high order word.  The position values 0 to 32767 select the entire string.
.i.EN_CHANGE;EN_CHANGEsent to the application when the edit window loses focus and the contents of the edit buffer have changed.
.i.WM_CUT;WM_CUTdelete the selected region of edit buffer and copy the contents of that region into a far character string supplied as the lParam element of the message.
.i.WM_COPY;WM_COPYcopy the selected region into the far character string supplied as the lParam element of the message.
.i.WM_PASTE;WM_PASTEcopy the contents of the far character string supplied as the lParam element of the message into the edit buffer after the cursor.
.i.WM_INSERT;WM_INSERTinsert the character contained in wParam at the current cursor location.  This message can be used to insert control characters into the edit string that cannot be entered via the keyboard.
.c.8. Listbox Messages
A listbox window notifies its parent window of any selection changes using the message WM_LISTBOX_COMMAND.  wParam contains the id of the listbox window that sent the message.
HIWORD(lParam) contains one of the following:
.i.LBN_DBLCLK;LBN_DBLCLKthe mouse was double clicked on an item
.i.LBN_SELCHANGE;LBN_SELCHANGEthe current selection was changed.  LOWORD(lParam) gives the method by which the selection was made.  (LOWORD(lParam)&lbrCause) takes one of the values lbrMouse, lbrOther, lbrScroll, lbrKeys or lbrSpace depending whether the selection was made using the mouse, clicking the mouse in a weird place, the scroll bar, the cursor keys, or the space bar respectively.  (LOWORD(lParam)&flbrReselect) indicates that an item was reselected.
.i.LBN_SELECT_DONE;LBN_SELECT_DONEthis message is generated when the mouse button is released after the mouse is used to make a selection in the listbox.
The following messages can be sent to a listbox to change the contents of the listbox:
.i.LB_RESETCONTENT;LB_RESETCONTENTThis message erases the contents of the listbox.
.i.LB_ADDSTRING;LB_ADDSTRINGThis message adds an item to the end of the listbox (or at the appropriate position if the listbox is sorted).  wParam contains a near pointer to a zero terminated string (hence the string must be in the default data segment).  LOWORD(lParam) is fRedraw (whether the string should be displayed or not).  HIWORD(lParam) is the ISA this string should be displayed with (isaNil will get replaced with the default ISA for the listbox).
.i.LB_INSERTSTRING;LB_INSERTSTRINGThis message inserts an item into the listbox.  wParam contains a near pointer to an SZI (a struct containing a zero terminated string and an ISA).  If the ISA is isaNil then the default ISA of the listbox is used.  HIWORD(lParam) contains the index where the string is to be inserted (before).  LOWORD(lParam) is the fRedraw flag.
.i.LB_DELETESTRING;LB_DELETESTRINGThis message deletes an item in the listbox.  HIWORD(lParam) should contain the index of the item to be deleted.
NOTE: For the ADD, INSERT, and DELETE functions, (LOWORD(lParam) == TRUE) will cause the changes to be displayed as they are made.
.i.LB_REPLACESTRING;LB_REPLACESTRINGThis message is used to replace an item in the listbox.  wParam contains a near pointer to a zero terminated string and HIWORD(lParam) contains the index of the item to be replaced.  LOWORD(lParam) is the ISA to be used with the new string.  If isaNil is passed, the ISA of the string being replaced is used.  The new string MUST be exactly the same length as the old one.  If the item is currently visible, it will be changed on the screen.
.i.LB_SETCURSEL;LB_SETCURSELSets the selected item.  wParam contains the index of the item to be hilited.  If wParam is iszNil then the currently selected item is unselected.
.i.LB_GETCURSEL;LB_GETCURSELReturns the index of the selected item.  If there is no currently selected item then iszNil is returned.
.i.LB_HILITECURSEL;LB_HILITECURSELwParam is a near pointer to the RRC that should be displayed as highlighted.  LOWORD(lParam) is the ISA, HIWORD(lParam) is the corresponding isz.
.i.LB_GETCOUNT;LB_GETCOUNTReturns the number of strings in the listbox.
.i.LB_GETTEXT;LB_GETTEXTGets the text of the currently selected item.  wParam should contain a pointer to a character array in the default data segment where the string will be copied (including a '\0').  HIWORD(lParam) contains the maximum number of characters to copy.  The number of characters copied is returned.  If no item is currently selected, then a null string is copied.
.c.9. Overlapping Window Messages
The following messages are provided with the optional support for overlapping windows.  All of these messages are sent to moveable windows by CW.
.i.WM_ZOOM;WM_ZOOMthe user has clicked on the zoom button.  It up to the application to do something.
.i.WM_CLOSE;WM_CLOSEthe user has clicked on the close button.  It up to the application to do something.
.i.WM_MOVE;WM_MOVEthe user has moved the window outline.  The final position of the outline is contained in lParam as: position ax = HIBYTE(HIWORD(lParam)), ay = LOBYTE(HIWORD(lParam)), size dax = HIBYTE(LOWORD(lParam)), day = LOBYTE(LOWORD(lParam)).  It is up to the application to actually move the window at this point. 
.i.WM_SIZE;WM_SIZEthe user has sized the window outline.  The final position of the outline is contained in lParam as before.  It is up to the application to actually size the window at this point. 
.i.WM_ACTIVATE;WM_ACTIVATEthis message is sent with wParam == FALSE to the current foreground window when CW wishes to move it back, and with wParam == TRUE to a window when CW wishes to move it to the foreground.  If the window returns FALSE to this message then CW won't move the window.
.c.10. User Messages
The application may define its own messages for its own message passing (via PostMessage() and SendMessage()).  The values of WM_USER and above (i.e. to 0xffff inclusive) are available for the use of the application.
In addition, the following Window messages are defined, but not used by CW :
.i.WM_CREATE;WM_CREATE, .i.WM_QUIT;WM_QUIT.
These may be used by the application if desired.
Revision History
87-4-17	removed KK_KEYDOWN for DOS3
87-4-21	WM_MENUSELECT for menu title help
87-6-7	2.8 clean up.
88-4-8	2.21 : changed KK_ values.
88-5-16	added listbox messages(w-stephs).
88-5-24	fix WM_MENUSELECT
88-8-10	overlapping windows! (+WM_INSERT)
88-10-21	WM_REPAINT
88-11-30	WM_DISABLEDCOMMAND
Mar 15 / 89 [MRD]Added ISA parms to LB_ADDSTRING, LB_REPLACESTRING, LB_INSERTSTRINGAdded LB_HILITECURSEL
Mar 20 / 89 [MRD]Added enClear and enCommand parms to WM_MENUSELECT
Mar 24 / 89 [MRD]Added WM_MENUINACTIVE
Index
.Begin Index.
EM_SETSET  6
EN_CHANGE  6
EnClear  5
EnCommand  5
KK_ALT  2
KK_CAPITAL  3
KK_CAPLOCK  3
KK_CONTROL  3
KK_EXTENDED  2
KK_MENU  2
KK_NUMLOCK  3
KK_SCRLOCK  3
KK_SHIFT  3
KK_VK  3
LB_ADDSTRING  7
LB_DELETESTRING  7
LB_GETCOUNT  8
LB_GETCURSEL  7
LB_GETTEXT  8
LB_HILITECURSEL  8
LB_INSERTSTRING  7
LB_REPLACESTRING  7
LB_RESETCONTENT  7
LB_SETCURSEL  7
LBN_DBLCLK  7
LBN_SELCHANGE  7
LBN_SELECT_DONE  7
MK_CONTROL  3
MK_LBUTTON  3
MK_MBUTTON  3
MK_NONCLIENT  3
MK_NONCLIENT_X  3
MK_NONCLIENT_Y  3
MK_RBUTTON  3
MK_SHIFT  3
SB_BOTTOM  6
SB_ENDSCROLL  6
SB_LINEDOWN  5
SB_LINEUP  5
SB_PAGEDOWN  5
SB_PAGEUP  5
SB_THUMBPOSITION  6
SB_THUMBTRACK  6
SB_TOP  6
WM_ACTIVATE  8
WM_CHAR  2
WM_CLOSE  8
WM_COMMAND  4
WM_COPY  6
WM_CREATE  8
WM_CUT  6
WM_DISABLEDCOMMAND  5
WM_INITMENUPOPUP  4
WM_INSERT  6
WM_KEYDOWN  2
WM_KEYUP  2
WM_KILLFOCUS  2
WM_LBUTTONDBLCLK  4
WM_LBUTTONDOWN  4
WM_LBUTTONUP  4
WM_MENUINACTIVE  5
WM_MENUSELECT  5
WM_MOUSEMOVE  4
WM_MOVE  8
WM_NCLBUTTONDOWN  4
WM_PAINT  1
WM_PASTE  6
WM_QUIT  8
WM_RBUTTONDBLCLK  4
WM_RBUTTONDOWN  4
WM_RBUTTONUP  4
WM_REPAINT  1
WM_SETFOCUS  2
WM_SIZE  8
WM_ZOOM  8
.End Index.

܀         v       q      m 	  h   0  c     ^     \     Z 	 @ @ @@ @ @ @  s  z  y     w     u     s     q   o     m     k (  6  i 			6  @  y s  w  w     u 	  	  s 	  q 
  
  o 
  
  m 
  
  k 
  i     g 		      y     w   u     s   q   o i  o  m     k $  /  i 7  g w  			w  }  y   $  w     u 
    s A  G  q     o     m   k J  _  i p  g 		p      y   w     u   s I  e  q }  o     m   k 	    i "  g `  p  g 					`  i  y o  w     u     s T  Z  o z  k   g   c   _   [   W " @ @@ @@ @@		    w   s   o   k   g     e     c   a *  8  _ B  ] e  s  [ 			 @@ @@ @s  }  y     w   u     s   q   /  o ;  m }    k   i     g   e 							  D  T  y `  w w    u   s     q   o     m (  k T  d  i p  g   							    y   w     u   s     q   o     m J  ^  k n  i     g ^  							^  d  y     w     u '  s }    q     o     m 4  :  k ^  d  i   	    y       w 6   <   u       s       q    o    !  m 0!  6!  k u!  {!  i !  	!  !  y !  w "  "  u "  "  s 9#  D#  n K#  l r#  #  g #  e #  #  c #  #  a  @ @	#  !$  '$  y $  $  w $  $  u $  $  s W%  ]%  q %  %  o %  %  m &  &  k )&  i  	)&  R&  U&  y a'  g'  w '  '  u '  '  s '  q (  (  o (  m G(  T(  k ^(  i y(  (  g 					(  (  y (  (  w (  u )  )  s ")  3)  q A)  o c)  i)  m )  )  k )  i )  )  g *  			*  *  y !*  w 1*  >*  u H*  s [*  ^*  q +  +  o +  m ,  ,  k ,  i -  -  g -  e *  						-  -  -  y -  w 2.  >.  u F.  s .  .  q .  o /  
/  m /  /  k 0  "0  i %0  +0  g 				+0  q0  w0  y 0  0  w 0  u 0  0  s 0  q %1  +1  o h1  n1  m m2  s2  k 2  2  i 2  g 			2  3  3  y 3  w 3  4  u 4  s 4  4  q 4  5  o H5  N5  m 5  5  k 5  i 6  6  g 			6  6  6  y 7  7  w 27  E7  u U7  s 7  7  q  8  8  o K8  _8  m p8  k 8  8  i 8  		8  8  y .9  49  w +:  ;:  u H:  s `:  g:  q :  :  o :  :  m :  k c;  v;  f ;  d 8   @		;  ;  ;  y ;  ;  w ;  ;  u <  (<  s 4<  q c<  q<  o |<  m <  <  k 8=  >=  i =   @		=  =  y >  >  w >  u ?  ?  s ?  q l?  w?  o ~?  m ?  ?  k  @  @  i @  #@  g @@  				@@  F@  y ^@  d@  w @  @  u @  s A  %A  q {A  A  o A  m A  A  k 
B  B  i B  B  g 			B  C  C  y C   D  w ^F  mF  r K  K  m K  i A  o A  m A  A  k 
B  B  i B  B  g 	 @ @ @			      Y    7    5   3               I       K A?!H $                   p `'!H $                    `'    v 0  C  \ Z  \ u  \   \   \               I   I   I   I   I  `'!H                !?     a   a   a   a   \     W   I   I   I   I         I        ` =                !  .  v   q   q o  q   q   q   l   g   I   I   I   I   I   I   I   I     =  =      v   q (  q V  l   g 	  g !	  b   I   I   I   I   I   I   I   I   I  W E W E !	  	  v 
  q 
  l   g   b i  ]   X   I   I   I   I   I   I   I   IW E W E W E =   $  v w  q   l   l   l :  g   g J  b   I   I   I   I   I   I   I   I W E W E W J    v   v I  v   v 	  v `  v   v   q T  l   I   I   I   I   I   I   I   I   I =  W 	T  z  v   v   v   v   q   q *  l e  l   l   I   I   I   I   I   I   I   I   I E = E 	    v   v }  v   v   v D  q w  l   l   l   I   I   I   I   I   I   I   I   I E = E 	  T  v   v   v 9  v   q <  l   g   b   I   I   I   I   I   I   I   I   = E = E   J  v   q W  l   l   l U  g   b   b   I   I   I   I   I   I   I   I  W E W E =      v    q !  l s"  g #  b v$  b M%  b &  b   I   I   I   I   I   I   I   I  W E W E W &  R&  v m&  q '  l '  l (  g G(  g y(  g (  g   I   I   I   I   I   I   I   I  W E =  E (  ")  v )  v *  v 1*  v [*  v p*  q +  l ,  g   I   I   I   I   I   I   I   I  W E =  E ,  -  v -  v 2.  v .  v /  v /  q j0  l 0  l   I   I   I   I   I   I   I   I  W E =  E 0  0  v 2  v G3  v 3  q 3  l 5  l 27  l 7  l K8  l   I   I   I   I   I   I   I   I   I W = E 	K8  +:  v :  v c;  v <  v c<  v =  v >  q >  l   I   I   I   I   I   I   I   I   I   I =  W >  ?  v l?  v @  v {A  v B  v B  q C  l C  l 
D  l   I   I   I   I   I   I   I   I   I =  E 	
D  <D  v OD  q tD  l D  l D  l D  l E  l E  l IE  l   I         I   I   I   I   I   I   I U ? = 	IE  ^E  v {E  v E  v -F  v VF  v WF  q ^F  l mF    I   I   I   I               I         I   I ? = U mF  {F  p F  p F  p F  p F  p F  p F  p F  p F  p   I   I   I   I   I   I   I   I   I ? 
     @	F  F  p G  p G  p "G  p ,G  p =G  p QG  p aG  p rG  p   I   I   I   I   I   I   I   I   I ? 
     @	rG  G  p G  p G  p G  p G  p G  p G  p H  p H  p   I   I   I   I   I   I   I   I   I ? 
     @	H  'H  p 6H  p EH  p VH  p iH  p |H  p H  p H  p H  p   I   I   I   I   I   I   I   I   I ? 
     @	H  H  p H  p H  p H  p H  p I  p I  p %I  p 5I  p   I   I   I   I   I   I   I   I   I ? 
     @	5I  AI  p NI  p ]I  p iI  p wI  p I  p I  p I  p I  p   I   I   I   I   I   I   I   I   I ? 
     @	I  I  p I  p I  p I  p J  p "J  p 6J  p HJ  p YJ  p   I   I   I   I   I   I   I   I   I ? 
     @	YJ  eJ  p zJ  p J  p J  p J  p J  p J  p J  p J  p   I   I   I   I   I   I   I   I   I ? 
     @	J  J  p K  p K  p K  k K   K    I   I   I         I         I   I   I   I   I   I= 
     @ 
          <
      !  )  t3  >  C  E  I  J                 B    N    9         	 k   
                         J     !   E   J         " *         03/18/9203/15/89J  
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cbox.doc ===
1           ;  C:\EDITORS\C#.STY                                                   POSTSCRP@ 0q  		--	
	C# Document-Draft		
CBox APIDraft
Kirk GlerumMicrosoft Applications Division
ABSTRACT (PC)
This document describes the CBox world, as a mutation/extension of the CW world.
.c.1. Introduction
CBox ("Character Boxes") is a layer wrapped around a subset of CW (aka "COW" aka "Character Windows").  The term 'CBox' can refer to the layer itself - meaning code and functionality that isn't strictly in CW itself - or it can refer to the layer plus the underlying CW code (the entire library).  In all likelihood, this will change somewhat post-Word5; I'll probably split the CBox out into multiple seperate libraries, away from the CW code.
Why does CBox exist?  CBox was invented for three clients: Multiplan (4.0), Word (5.0), and CBT (Word 5.0 & Works 2.0).  Prior versions of these apps ran under the Qinter Interpreter system.  The Qinter code was pushed to the wall, and could not support the needed changes (protect mode operation arguably being the largest).
CW provides a great deal of functionality that isn't needed for the current CBox apps; specifically, video support - they don't use pull-down menus.  That's not a problem, as there are no attachments to this code, and it just doesn't get linked in.
This document describes the API for the CBox system routines.  In the prior versions of Multiplan (3.5, 3.04, etc.) and Word (4.00A and below), these functions were performed by OSCalls, handled by the Qinter (Q-code) interpreter.  For MP4 and Word5, they will be handled by various libraries, such as the MathPack and the SBMgr.  One purpose of this document is to show specifically how each of the old OSCalls are to be handled: either by an existing function in a library, or by a mapping to existing functions, or by a brand new function.
MP4/Word5 will use the C# Mathpack, which is a descendant of earlier Multiplan mathpacks, so adaptation is straightforward.  Many of the functions need only a name change or a simple macro or procedure.
File I/O functions and DOS functions are not provided for by CW; CBox contains Toolbox calls for them, often using wholesale code from Qinter.  This document describes their functionality and interface.
Video functions are provided for by CW, but differently than what MP4/Word5 requires.  For these, I've described the mapping between the two.
.c.2. Files involved.
CBOX.DOC
This file.  It contains the API for the routines provided for Multiplan.
DCBOX??.LIB and CBOX??.LIB
These are the various debugging and non-debugging versions of the CBox libraries.  They contain: the SBMgr, Winter, the MathPack, CW, and the CBox modules for video, fileio, and DOS calls.
MAKEFILE
This is used for the construction of my CBOX Test Program, and can be used as a reference.
CBOX.TXT
This file is to become part of Multiplan's TOOLBOX.TXT file.  CBOX.TXT contains the calling sequence for all the routines described in this document: Video, File I/O, DOS calls, and Math calls.  It does not contain the calling sequences for the SBMgr, Winter, the Mathpack, or any hand coded application-specific toolbox functions.  Those are to be provided by other .TXT files.
A typical CBox app's TOOLBOX.TXT will be constructed as such:
toolbox.txt = sbmgr.txt + winter.txt + mathpack.txt + cbox.txt + handcode.txt
.c.3. Routines that the CBox app must provide.
.c.:3.1 Main
VOID Main(lszCmdLine)LPSTR lszCmdLine;			/* ptr to command line */
This is where the application lives.  CBox calls this when it's done initializing.
.c.:3.2 Exit
VOID Exit(exitValue)WORD exitValue;			/* 0 if no error, etc. */
The CBox app calls this to exit; it does not just return from Main.
.c.:3.3 MathError
The CBox app should provide this, if it expects to use the mathpack.  This is spec'ed out in MATH.DOC, and in the Math section of this document.
.c.4. Translation of old XOS calls to new Toolbox calls.
This section is provided for historical purposes as much as anything else.  It shows how the old Qinter calls map to CBox calls.
.c.:4.1 Implemented functions
  Qinter XOS name:	 	CBox Toolbox name:
.c.::4.1.1 Video functions:
XOSOutRgch			; OutRgch(char *,WORD,char *);XOSAlterAtr			; AlterAttr(WORD,WORD);XOSAtPos				; SetCursor(WORD,WORD);XOSErase				; EraseScreen(void);XOSScroll				; MoveRectangle(WORD,WORD,WORD,WORD,WORD,WORD);XOSOutCons			; OutCons(WORD,WORD);XOSXCO				; XCo(void);XOSYCO				; YCo(void);XOSOUTCHAR			; OutChar(WORD);XOSVideoOutput			; VideoFreeze(BOOL);XOSSETATR:	get normal video		; GetDfltNormalColors(void);	get reverse video		; GetDfltInverseColors(WORD);	turn cursor on			; EnableCurs(void);	turn cursor off		; DisableCurs(void);	beep					; Beep(void);	set foreground color	; SetForeColor(WORD);	set background color	; SetBackColor(WORD);	set dflt fore/back co	; SetColorsDflt(void);	get max # screen lines	; GetMaxScreenLines(void);	get current Code Page	; CodePageCur(void);
.c.::4.1.2 File i/o functions
XOSRead 			; ReadFile(WORD,void HUGE *,WORD);XOSWrite			; WriteFile(WORD,void HUGE *,WORD);XOSClose			; CloseFile(WORD);XOSSetPos			; SeekFileSector(WORD,WORD);XOSDelete			; DeleteFile(WORD,char HUGE *);XOSCreate			; CreateFile(WORD,char HUGE *,WORD);XOSAccess			; AccessFile(WORD,char HUGE *,WORD);XOSDir			; FindFile(char *,WORD,char *,WORD);
.c.::4.1.3 Keyboard functions
XOSInChar			; InChar(void);
.c.::4.4.2 Math functions:
XOSDL			; DL(pnum);XOSDS			; DS(pnum);XOSDADD			; DAdd(pnum);XOSDSUB			; DSub(pnum);XOSDMUL			; DMul(pnum);XOSDDIV			; DDiv(pnum);XOSDCOND			; DCond(void);XOSDNEG			; DNeg(void);XOSDCL			; DClr(void);XOSFLOAT			; Float(int);XOSFIX			; Fix(void);XOSTENTO			; TenTo(exp);XOSDABS			; DAbs(void);XOSDINTXOSROUNDXOSUNPACK19		; Unpack(char *);
.c.::4.1.4 Windows Clipboard functions
IdentifyWinOldApVersionOpenClipboardEmptyClipboardSetClipboardDataGetClipboardDataSizeGetClipboardDataRegisterClipboardFormatEnumClipboardFormatsCloseClipboardClipboardCompactGetDeviceCaps
.c.::4.1.5 Misc. DOS functions
XOSDate 			; GetDate(void HUGE *);XOSTime 			; GetTime(void HUGE *);XOSDOSVersion		; VerDOSCur(void);XOSCountry		; GetCountry(void HUGE *);XOSFRemoveable		; FRemoveableDrive(WORD,char HUGE *);XOSFNetwork		; FNetworkDrive(WORD,char HUGE *);
.c.:4.2 Stub functions
StubVoid		; Does nil, returns nil.StubWord		; Does nil, returns a Word value of 0.StubDWord		; Does nil, returns a Double Word value of 0.
.c.:4.3 Not yet implemented functions
XOSReadChkXOSDefault	; open/set/close/ret printer -> DoPrintDev			; set Dflt Dir -> SetCurDirXOSGetDir			; ret name of current dirXOSLoadDrvrXOSCallDrvrXOSFixupXOSPrintXOSExecXOSSetAtr:  set # of screen linesXOSReadMouse		; ReadMouse(void HUGE *)XOSMouseOnOff		; MouseEnable(BOOL)XOSInitMouse		; FInitMouse(void)XOSSetMouse		; SetMouse(void HUGE *)XOSPACK19			; Pack(int *,int *,char *);XOSIEEEtoBCDXOSBCDtoIEEEXOSDERROR
.c.:4.4 Already provided library functions
XOSQUITXOSSCALLXOSSetJmpXOSJMP
.c.::4.4.1 Debug functions:
XOSBreakStartUMeasStopUMeas
.c.:4.5 Discarded functions
XOSSetEOMXOSDebugCmdXOSDebugMovedSegXOSDebugSetSegXOSServiceReturnXOSCheckSumXOSSetAtr:  turn kbd key click on/off  reset screen  get current video modeXOSPACK			; We only need one pair of Pack and XOSUNPACK			; Unpack procedures now, not two.
.c.5. API
.c.:5.1 Types.
BYTE: an unsinged 8 bit quantity.
WORD: an unsigned 16 bit quantity.
DWORD: an unsigned 32 bit quantity.
CO: a color (BYTE/WORD).  coBlack = 00  coWhite = 07  coGetDflt = 0xFE  coGetTotal = 0xFF
ATTR: background color in high nybble, foreground in low (BYTE/WORD).
AX: an absolute screen x coordinate (BYTE/WORD).
AY: an absolute screen y coordinate (BYTE/WORD).
FD: a file descriptor, or handle, for the file.
SE: a system error, returned by some functions.  These are defined in cbox.h and cbox.inc.
CF: the format of the Windows Clipboard (BYTE/WORD).  CF_TEXT = 1.  Text format.  As described in MS Windows reference.  CF_BITMAP = 2.  Bitmap as defined by BITMAP data structure.  CF_METAFILEPICT = 3.  Metafile picture as defined by the METAFILEPICT data structure.  CF_DISPTEXT = 81h.  OEM text format.  Adaptation Specific.  CF_DSPBITMAP = 82h.  Bitmap display format associated with display device.  CF_DSPMETAFILEPICT = 83h.  Metafile picture display format associated with private format.
.c.:5.2 Math pack.
.c.::1.1.1 DError
When the MP354 mathpack detected an error (overflow, divide by zero, etc.), it would drop a latch in a byte that the PCode would keep an eye on.  The C# Mathpack requires that a MathError procedure be provided for the Mathpack to call when an error is detected.  MathError is passed a parameter describing the error.  If the MP354 PCode just calls a routine when it sees that its Math Error latch is dropped, then that routine can perhaps be modified to become MathError.  If it's not that simple, then I can provide a MathError routine that simply drops the latch, and the PCode can continue to watch for it.
.c.::1.1.1 Pack and Unpack
In MP354, there were two pairs of Pack and Unpack routines: XOSPack & XOSUnpack, and XOSPack19 & XOSUnPack19.  The first pair was only used by the Debugger; CW doesn't need them, so we can reduce to just Pack and Unpack.
The UnPack routine had a second parameter for how much precision was desired; this was so the procedure could quit early to save time.  Since C#'s Unpack does the whole thing automatically, this parameter would be a waste of time unless C# were modified to support it.
.c.::1.1.1 Fix and Float
XOSFix and XOSFloat in Qinter worked with unsigned integers.  If you wanted to put -10 into the accumulator, you would first Float in 10, then negate it with XOSDNeg.  The equivalent routines in the C# Mathpack use signed integers, so you can just Float in -10.  Of course, Floating in 50,000 is more difficult with C# than it would be with Qinter.
XOSFix did not set the DError flag; rather it just returned FFFF to indicate overflow.  The equivalent C# routine will call MathError on overflow.  
It is hoped that MP4 can be modified to use signed integers for Fix and Float.
It is hoped that MP4 can use MathError (or DError) for Fix overflow conditions, rather than depending on a certain return value.
.c.:5.3 Video functions.
Most of the MP3 video functions can be mapped to CW video functions rather easily.  
.c.::5.3.1 OutRgch
CHAR *OutRgch(pchSrc,cch,pchDst)CHAR *pchSrc;				/* ptr to source */WORD cch;					/* contains flags */CHAR *pchDst;				/* ptr to destination */cch: the bottom ten bits are the maximum character count:       cchMask		= 3Fh     the top five bits are flags:       fcchExt		= 80h       fcchCount	= 40h       fcchArray	= 20h       fcchCap		= 10h       fcchUpper	= 08h     the bit 04h is not used.fchStop	= 80h			/* signals end-of-input when set in a char of the input stream */
There are three different functions contained within this: output to screen, output to memory, and move to end of string.  Which function is performed is determined by the flags.
The first is to output characters pointed at by pchSrc to the screen.  It starts at the current cursor position and uses the current attributes.
The second is to copy characters pointed at by pchSrc to the memory location pointed at by pchDst.  No attributes are involved.
Both of these functions continue for cch characters, or until a character is reached with its fchStop bit on.  Both have a flag to capitalize the first character of the string, and a flag to capitalize all characters in the string.  Both return a near pointer to one past the last character of the input string that was output.
The third is to return a near pointer to one past the last character of the input string.  The 'last character' is defined as being the cch'th character, or the first character with its fchStop bit on.  In other words, this function returns the same as the first two, but without doing any of the actual transfers.
Within cch, only the low 10 bits contain the count.  The high byte contains fcchExt, fcchCount, fcchArray, fcchCap, and fcchUpper.  These are used to determine which of the three functions to call, if any capitalization is needed, and if the Stop Bit should be watched for in the input stream.
.c.::5.3.2 AlterAttr
VOID AlterAttr(fInverse,cch)BOOL fInverse;				/* True -> Inverse; False -> Normal*/WORD cch;					/* count of characters to do */
Starting at the current cursor position, change the attributes of the next cch characters to be normal video if !fInverse, and inverse video if fInverse.
Changing a character to Inverse Video means translating its (normal, non-inverse) foreground and background colors to new colors.  If a Normal cell is Red on Blue, then its Inverse might be Yellow on Green.  
Note that it is a requirement that the available range of colors be broken into half Normal colors and half Inverse colors.  This is because an AlterAttr(False) can be done on attributes that are already normal, and we can't have them change.
.c.::5.3.3 GetDfltNormalColors
ATTR GetDfltNormalColors()
Returns the default normal colors for foreground and background (black background + white foreground).  This function returns the same thing every time.
.c.::5.3.4 GetDfltInverseColors
ATTR GetDfltInverseColors(gdic)WORD gdic;			/* low byte = code */
gdic:  gdicMenuItem = 1		/* it's a menu item */  gdicHiLite = 2		/* it's an edit highlight */
Returns the default inverse video colors for foreground and backgound.  
If (gdic = gdicMenuItem) or   (gdic = gdicHiLite) or   (coCurBack = coWhite)then return (white background + black foreground)else return (black background + white foreground)
.c.::5.3.5 EnableCurs
VOID EnableCurs()
Turn on the physical cursor.
.c.::5.3.6 DisableCurs
VOID DisableCurs()
Turn off the physical cursor.
.c.::5.3.7 SetCursor
VOID SetCursor(ax,ay)AX ax;AY ay;
Set the internal (software) cursor to the location (ax,ay).
.c.::5.3.8 XCo
AX XCo()
This function returns the column position of the software (internal) cursor.
.c.::5.3.9 YCo
AY YCo()
This function returns the row position of the software (internal) cursor.
.c.::5.3.10 SetForeColor
CO SetForeColor(co)CO co;
  coGetDflt = 0xFE  coGetTotal = 0xFF
There are three different functions contained within this: set foreground color, get default foreground color, and get total number of available colors.
If co = coGetTotal, then it returns cColors, the total number of available colors.
Else if co = coGetDflt, then it returns the default foreground color.  This is hard coded to coWhite.
Else if co > cColors, then it resets the Current Attribute (background and foreground) to their default values (black and white), and returns that Current Attribute value.
Else, with co <= cColors, it sets the Current Foreground Color (low nybble of the Current Attribute) to co, and returns the Current Attribute value.
.c.::5.3.11 SetBackColor
CO SetBackColor(co)CO co;
This function is the background equivalent to SetForeColor.  The coGetDflt function here always returns coBlack.  Notice that the coGetTotal function of each return the same value, because currently there are always as many foreground colors as background colors.
.c.::5.3.12 SetColorsDflt
VOID SetColorsDflt()
This function has no input and no output.  It resets the current foreground and background colors to their defaults (black background + white foreground).
.c.::5.3.13 GetMaxScreenLines
WORD GetMaxScreenLines()
This function returns the current maximum number of rows.  This means 25 when we're in 25x80 mode, 43 when we're in 43x80 mode on an EGA, 66 when we're on a Genius, etc.
(NYI)
.c.::5.3.14 SetRows
WORD SetRows(cRows)				/* low byte only */WORD cRows;					/* low byte only */
This function sets the number of rows on the screen to cRows.  If it crosses a threshold between video modes (like from 22 to 38 on an EGA), then a modeswitch is done.
The functionality of SetRows and SetRowsForceMode (see below) will depend greatly on some things not yet implemented in CW.  CW currently does not support modeswitching (25 lines <-> 43 lines, text <-> graphics); it will.  CW will have the functions: QueryModes, to get from the driver information on all of the modes it's capable of supporting; GetCurrentMode, to get from the driver what mode it's now in; and SetMode, to tell the driver which of its available modes to go into.  This is low-priority stuff, so I'll just leave it at this for now.
(NYI)
.c.::5.3.15 SetRowsForceMode
VOID SetRowsForceMode
This function forces a call to Terminal_Init, with the current number of lines on the screen.  This means it'll re-initialize the terminal, but in the same mode that it's already in.  There is no input and no output.
.c.::5.3.16 EraseScreen
VOID EraseScreen()
This function has no input and no output.  It fills the whole screen with spaces, using the current attribute.
.c.::5.3.17 MoveRectangle
VOID MoveRectangle(dx,dy,xFrom,yFrom,xTo,yTo)WORD dx;WORD dy;WORD xFrom;WORD yFrom;WORD xTo;WORD yTo;
Move a rectangle of charaters and attributes from one place to another.  This routine does not fill in behind itself.
.c.::5.3.18 OutChar
VOID OutChar(ch)WORD ch;						/* low byte only */
This function will output the character ch to the screen, at the current cursor position with the current attributes.  It then updates the internal software cursor position.
.c.::5.3.19 OutCons
VOID OutCons(cch,ch)WORD cch;WORD ch;						/* low byte only */
This function will output the character ch to the screen cch times.  It starts at the current cursor position and uses the current attributes.  It then updates the internal software cursor position.
.c.::5.3.20 VideoFreeze
VOID VideoFreeze(fFreeze)BOOL fFreeze;			/* True -> Freeze; False -> Thaw */
Change all functions that output to the screen to 'frozen' versions; they'll perform the same internally, but output nothing.  The 'thaw' call puts them back to their normal routines.
.c.:5.4 File I/O functions
.c.::5.4.2 AccessFile
FD AccessFile(szFile,amd)CHAR *szFile;				/* pointer to filename */WORD amd;					/* low byte = Access mode */
The amd field specifies the Access and Share modes requested for the file:
amd:  famdDenyBothRW  famdDenyWriteRO  famdDenyWriteRW  famdDenyNoneRO
This function returns the file descriptor (handle) if there's no error, seTooManyOpenFiles if we ran out of handles, and seNoFile for all other errors.
.c.::5.4.1 CreateFile
FD CreateFile(szFile)CHAR *szFile;				/* pointer to filename */
This function returns the file descriptor (handle) if there's no error, seTooManyOpenFiles if we ran out of handles, and seNoDiskSpace for all other errors.
.c.::5.4.6 SeekFileSector
SE SeekFileSector(fd,cSec)FD fd;					/* file descriptor */WORD cSec;				/* sector count */
This function will set Read/Write Pointer to cSec sectors past the start of the file.
This functions always returns seNoError, even though they could occur - bad file handle, or whatever.  There's an Assert on any error.
.c.::5.4.6 FSetFilePointer
BOOL FSetFilePointer(fd,long pbFile,int method)FD fd;					/* file descriptor */long pbFile;				/* offset for file pointer */int method;				/* 0/1/2: from start, current, end of file */
This function will set Read/Write Pointer in the file, pbFile bytes from the start, current spot, or end of the file, depending on method.  Returns True/False.
.c.::5.4.8 DeleteFile
SE DeleteFile(szFile)CHAR *hpszFile;		/* pointer to filename */
This function returns seNoError, seAccessDenied, or seNoFile.
..c.::5.4.3 ReadFile
INT ReadFile(fd,hpb,cb)FD fd;					/* file descriptor */BYTE HUGE *hpb;			/* ptr to array to read to */WORD cb;					/* num of bytes to read in */
This function returns the number of bytes read, or seOutOfBounds.
.c.::5.4.4 WriteFile
SE WriteFile(fd,hpb,cb)FD fd;					/* file descriptor */BYTE HUGE *hpb;			/* pointer to source array */WORD cb;					/* number of bytes to write */
This function returns seNoError, or seNoDiskSpace.
.c.::5.4.5 CloseFile
SE CloseFile(fd)FD fd;					/* file descriptor to close */
This function returns seNoError, or seNoFile.
.c.::5.4.5 SetMaxHandles
SE SetMaxHandles(cHandReq)int cHandReq;				/* number of file handles requested.*/
This routine is provided for OS/2 support, where you can't always be sure that you'll be able to get a file handle on the next file open or access.  You can free a file and immediately thereafter fail a create because your handle has been snagged by the system.  With this routine, you can request more handles from the system.
This function returns seNoError, seInvalidParm, or seNotEnoughMemory.  Under DOS, it always returns seInvalidParm, although DOS 3.3 and above does support the call.  I will modify the DOS portion if there is a need for it.
.c.::5.4.5 RenameFile
SE RenameFile(szOld,szNew)CHAR * szOld;			/* old filename */CHAR * szNew;			/* new filename */
This function returns seNoError if there's no error, or a nonzero value if either a file with the old name couldn't be found or a file with the new name already exists.
.c.::5.4.5 FCommitFile
BOOL FCommitFilee(szOld,szNew)FD fd;					/* file descriptor */
This function flushes a file to disk, thus updating the FAT.  If a file has been Commited, but not Closed, and the system crashes, the info will be on the disk.
.c.::5.4.7 GetFileLength
VOID GetFileLength(pcbFile,fd)LONG *pcbFile;			/* where to store the length */FD fd;					/* file descriptor */
This function will determine the size of the file, and store it at the long pointed at by pcbFile.  As a side effect, this function resets the Read/Write Pointer to the end of the file.
This function returns nothing, but an error (invalid handle) can occur.  An Assert exists for this.
.c.::5.4.5 GetFileAttr
WORD GetFileAttr(szFile)CHAR *szFile;
This function returns the attributes of the file if there's no error, and an error code if there was (attributes are all greater than zero).
.c.::5.4.7 DateStamp
VOID DateStamp(handle,pDStamp,dsFunc)WORD handle;				/* handle of file to use */DWORD *pDStamp;			/* ptr to two word structure */WORD dsFunc;				/* 0/1 -> Get/Set Datestamp */
This function will either Get (dsFunc = 0) or Set (dsFunc = 0) the Date & Time of the file.  pDStamp is a near pointer to two words - the Date and the Time.  Their forms are:
date = yyyyyyymmmmdddddtime = hhhhhmmmmmmsssss
The year is post-1980.  I don't know how 60 seconds fit into 32 unique combinations.
This function returns nothing.  It can err (bogus handle), but there are Asserts for that.
.c.::5.4.5 BuildDriveTable
LONG BuildDriveTable(pbBuff)BYTE *pbBuff;			/* ptr to 26 byte table */
This function fills a 26 byte table with information about each of the potential drives.  A=0, B=1, etc.  The values are:
0	invalid drive1	floppy drive2	network drive3	valid non-network hard disk
Note that RAMdrives come out as type 4.
Under DOS, A: and B: are either floppy or invalid.  On a single-floppy system, either A: or B: will be invalid.  Under DOS 2.x, C: thru Z: are either valid non-net or invalid.
Under OS/2, A: and B: are either floppy or invalid.  I don't know what happens on single-floppy systems.  Drives C: thru Z: are either network or invalid.
I will someday implement a Lanman call to determine OS/2 net-ness for real, but since the usual interpretation of net drives is that someone else could be poking at your files, and since OS/2 is multitasking and another process could be poking at your files, the assumption that all drives are 'net' drives makes sense.
.c.::5.4.5 LszGetEnv
LONG LszGetEnv(prgchVar)CHAR * prgchVar;			/* env var to look for */
This function returns a far pointer to the value of an environment variable, or 0000:0000 if not found.  The passed-in variable string should be of the form "MANGO="; it does not need to be zero terminated.  If you pass in "MANGO =", then that's what'll get scanned for in the environment; we don't parse for spaces or anything.
The far pointer passed back points directly into the environment space itself, so the application should be modifying it.
.c.::5.4.9 GetProgDir
VOID GetProgDir(pch)CHAR *pch;			/* pointer to buffer */
Returns the name of the startup directory as a null-terminated string.
The returned directory name is not necessarily fully-qualified!  You can get ".." or "C:." as the return string.  Actually, I think it'll always be fully qualified under DOS.
The returned directory name does not contain a filename.  See the definition in COWS.DOC of a directory.
The buffer passed in must be long enough to handle a maximum directory name for the given operating system.  With OS/2 this limit varies, and needs to be researched and documented.
c.::5.4.9 GetCurrentDir
VOID GetCurrentDir(szDir)CHAR *szDir;			/* pointer to buffer */
Gets the name of the default directory for any drive as a null-terminated string.  If the second character of szDir is a colon then we use the first character as the drive letter; otherwise we use the current drive.  The buffer passed in must be capable of holding a maximum-length directory; see COWS.DOC for a definition.
If there's an error (passing in "Q:xxx" when Q is not a valid drive), it returns with pszDir unchanged.
.c.::5.4.11 FSetCurrentDir
BOOL FSetCurrentDir(pszDir)CHAR *pszDir;		/* ptr to ASCIIZ new directory */
Returns True/False.  If false, we preserve the old current drive and directory.
.c.::5.4.10 FindFile
WORD FindFile(pszFile,ffc,lpBuff,attr)CHAR *pszFile;			/* pointer to filename */WORD ffc;				/* low byte = Find First or Next code */DWORD *lpBuff;			/* ptr to where to put DTA ptr */WORD attr;			/* search attribute */ffc:  ffcFirst = 0			/* do the Find First */  ffcNext = 2			/* do the Find Next */  ffcClose = 3			/* do the Find Close */
There are three functions contained within this: Find First Directory Entry, Find Next Directory Entry, and Close Find.
For First First, pszFile is a pointer to a string containing a directory and/or a filename.  The filename can contain global filename characters.
Find First and Find Next both return the found filename in pszFile.
lpBuff is a near pointer to a 4 byte buffer, where Find First and Find Next will place a far pointer to a DTA that DOS|OS/2 fills with info on the found file.  If the caller doesn't want to deal with lpBuff (like Multiplan), just pass in FFFF for the pointer, and FindFile won't bother with it.
attr is the attribute for what type of file to search for.  Multiplan can just pass in zero to be backwards compatible.
Find First and Find Next both return the length of the First or Next filename.
The app is supposed to call Find Close if and only if the search has found all matching files, but FindFile will help out with this: we use a latch to determine if a Find Close has been done.
(NYI)
.c.::5.4.12 DoPrintDev
SE DoPrintDev(hpszDev,pdc)CHAR HUGE *hpszDev;			/* ptr to input string */WORD pdc;					/* low byte = print device code */pdc:  pdcOpen = 2				/* do OpenPrintDev */  pdcSet = 3				/* do SetPrintDev */  pdcClose = 4				/* do ClosePrintDev */  pdcRet = 5				/* do RetPrintDev */
NOTE!  Under Qinter, these crazy functions had differing returns for success and failure.  Now, RetPrintDev returns the length of the print device name string; the others return seNoError or sePrintError.
Note that only SetPrintDev and RetPrintDev require the input string parameter.  
.c.:::5.4.12.1 OpenPrintDev
No input.  If the print device is already open, return with seNoError.  Have DOS open the file whose name is kept locally as the logical print device.  This name will be 'PRN', unless it's been changed via SetPrintDev.  If success, save the handle locally, and return seNoError; else return sePrintError.
.c.:::5.4.12.2 SetPrintDev
Use DOS to open the file hpszDev; return if error.  Get the Device Information about the device; return if error, or if it's an Illegal Device - but close it first for either.  Otherwise, copy hpszDev to the local string for the device name; this will be used by subsequent OpenPrintDev and RetPrintDev calls.
This function will not err if the print device's currently open, but it won't re-route the subsequent printings, either.  I presume that it is only called when the print device is closed, but an Assert ought to be in there.
.c.:::5.4.12.3 ClosePrintDev
Have DOS close the print device, using the handle kept locally. This handle is then set to -1.  This always returns success.
If you do two ClosePrintDevs in a row, the second one will request a Close File Handle function from DOS, with the handle being -1.  DOS will presumably return an error, but ClosePrintDev will return with success.  An Assert should be added.
.c.:::5.4.12.4 RetPrintDev
Copy the logical printer name to the input string hpszDev.  This will be 'PRN' unless a SetPrintDev has changed it.  Return the size of the string in bytes, not counting the 0 at the end.
.c.:5.5 Keyboard functions
.c.::5.5.1 FCheckEvent
BYTE FCheckEvent
Set to true if there's a character in the queue, or if a mouse event has happened, or if the buttons on the mouse are down.  Otherwise, leave false.
.c.::5.5.2 InChar
WORD InChar()
Returns the input character if one is available; returns -1 if there's no character available.
This function is very complicated for MP3.  It watches for keyboard and mouse activity; it watches for special characters like ctrl-c and ctrl-b; it deals with DOS' keyboard queue, and our internal queue; it watches for shift state and caps-num-scrolllock status transitions; and it performs a translation on the character.
It also returns a single code for certain multiple key combinations of <ctrlr> followed by another keystroke.
.c.::5.5.3 GetPrtScKey
LONG GetPrtScKey()
Reset the Print Screen vector (int 05) to point to our internal Int05 handler.
.c.:5.6 DOS functions
.c.::5.11.7 ExecCmd
LONG ExecCmd(szCommand,rgchPrompt,fDirect,fClearScreen)char *szCommand;		/* command string to execute */char *rgchPrompt;		/* "Press a key to resume.$" */BOOL fDirect;			/* Use Comspec? */BOOL fClearScreen;		/* Clear the screen beore? */
Returns:   low:   >=  0 - successful; return code from child process          = -1 - failure; insufficient memory          = -2 - failure; command not found  high:  Child return code.
Note that rgchPrompt is not a zero-terminated string; it's $-terminated.
If fDirect=True, then we don't use the Comspec.  Rather, we parse szCommand into the command and its arguments.  The only real limit on szCommand is the length of the arguments.  The argument portion (not counting the first space between the command and the arguments) has to be <= 127 characters.  The command portion has to be a legal filename, but we don't check for that.  We don't search the path to find the file. 
A bug for direct exec's is that we actually munge the input szCommand string: we put a 0 byte between the filename and its arguments (replacing the first spaec).  This should be preserved, or else we should transfer the command string to the stack.
If fDirect=False, then we use the Comspec.  In this case, rgchPrompt is the argument string for COMMAND.COM or CMD.EXE.  ExecCmd will prepend the necessary "/C " to rgchPrompt.  For this reason, the max length of rgchPrompt here is 124, not 127 like for fDirect.
Under OS/2, the max length of the argument string could be larger than 127 (OS/2 supports it), but it hasn't been researched, so the 127/124 limit still applies.
.c.::5.6.3 VerDOSCur
WORD VerDOSCur
Returns the current DOS Version.  Low byte = major version number, High byte = minor version number.  Note that minor version number is 00..99, decimal.  DOS 3.30 returns 0x1E03.
.c.::5.6.7 GetCodePage
WORD GetCodePage()
Returns the active current code page.  DOS < 3.30 returns 0.
.c.::5.6.7 FSetCodePage
BOOL FSetCodePage(usCodePage)
Sets the active code page.  DOS < 3.30 returns True for 437, False for all others.
.c.::5.6.1 GetDate
VOID GetDate(pdte)DTE *pdte;			/* ptr to where to put date */
typedef struc	{	WORD year;			/* year (1980..2099) */	BYTE mday;			/* month of the year (1..12) */	BYTE month;			/* day of the month (1..31) */	} DTE;
.c.::5.6.2 GetTime
VOID GetTime(ptme)TME *ptme;			/* ptr to where to put time */
typedef struc	{	BYTE min;	BYTE hour;	BYTE centisecs;	BYTE secs;	} TME;
.c.::5.6.4 GetCountry
VOID GetCountry(pb)CNTRY *pb;			/* where to put the info */
The CNTRY structure is defined in cbox.h & cbox.inc.
.c.::5.6.5 GetDiskSpace
LONG GetDiskSpace(szPath,fFreeSpace)CHAR *szPath;			/* file to get drive letter from */WORD fFreeSpace;		/* true/false -> get free/total space */
If fFree, return the amount of free space on the disk; else return the total amount of space on the disk.  In either case, return -1 if there's an error.  This call returns an error under DOS 1.x (as if we care).  This call won't work on drives of over 1 gigabyte.  Does the current file system support those?
.c.::5.6.5 FRemoveable
BOOL FRemoveableDrive(hpszFile)CHAR HUGE *hpszFile;	/* ptr to filename to get drive from*/
Returns TRUE if the drive is removeable, and FALSE if it is not.
For DOS 2.x, A: and B: are removeable, and C: thru Z: are not.
On a single floppy system, the phantom drive (A: or B:) is not removeable.
This is still kludged for OS/2; it currently says that A: and B: are removeable, and C: thru Z: are not.
.c.::5.6.6 FNetworkDrive
BOOL FNetWorkDrive(hpszFile)CHAR HUGE *hpszFile;		/* ptr to filename */
Returns TRUE if the drive is a network drive, and FALSE if it is not.
For DOS < 3.10, all drives are not network.
This is still kludged for OS/2; it currently says that all drives are network drives.
For the 3xBox (DOS 10.x), to match the protect mode side, all drives are network drives.
(NYI for OS/2)
.c.:5.7 Windows Clipboard functions
	These routines provide CBOX Apps the ability to transfer information to and from the Windows Clipboard.
.c.::5.7.1 IdentifyWinOldApVersion
 BOOL IdentifyWinOldApVersion ();
Returns True if running under a Windows version capable of supporting the desired functionality.
.c.::5.7.2 OpenClipboard
BOOL OpenClipboard ();
Allows the CBOX App to open and master lock the Clipboard.  Returns True if successful.
.c.::5.7.3 EmptyClipboard
BOOL EmptyClipboard ();
Purge the contents of the Windows clipboard.  Returns True if successful.
.c.::5.7.4 SetClipboardData
BOOL SetClipboardData (cf, hpTransferBuffer, cbTransferBuffer);CF cf;					/* Clipboard format */char HUGE *hpTransferBuffer;	/* Ptr to transfer data*/long cbTransferBuffer;		/* Number of bytes to transfer  */
Transfers data from the CBOX App to the Windows clipboard. Returns True if successful.  The OldApp should call ClipboardCompact prior to this to determine if the data can be accomodated in memory.
.c.::5.7.5 GetClipboardDataSize
LONG GetClipboardDataSize (cf);CF cf;					/* Clipboard format */
Returns the size of the data (in bytes, including any headers) in the Windows clipboard.	 Returns 0 if there is no data of this format in the clipboard.  Use this value as a guideline for how much space to allocate when getting data with GetClipboardData
.c.::5.7.6 GetClipboardData
BOOL GetClipboardData (cf, pTransferBuffer);CF cf;char Huge *hpbTransferBuffer;	/* Buffer to hold xfer data */
Transfer data from the Windows clipboard to the CBOX App.  Returns True if successful.
(NYI)
.c.::5.7.7 RegisterClipboardFormat
CF RegisterClipboardFormat (hpszFormat);char Huge *hpszFormat;
Register a new clipboard format.  Returns value of newly registered format or 0 if error.
(NYI)
.c.::5.7.8 EnumClipboardFormats
CF EnumClipboardFormats (cfPrev);CF cfPrev;	/* Previous format, or 0 for 1st format */
Enumerate clipboard formats.  Returns the next clipboard format.
.c.::5.7.9 CloseClipboard
BOOL CloseClipboard ();
Close and relinquish control of the Windows Clipboard.  Returns True if successful.
.c.::5.7.10 ClipboardCompact
DWORD ClipboardCompact (cbMemoryRequest);DWORD cbMemoryRequest;		/* Desired size */
Check to see if there is enough room in the clipboard for a data transfer.  Returns the number of bytes in the largest block of free memory.  The OldApp is responsible for including the size of any headers in the desired memory size.
(NYI)
.c.::5.7.11 GetDeviceCaps
WORD GetDeviceCaps (IndexGDIInfo);word IndexGDIInfo		/* GDI information index */
Get device information.  Returns integer value of desired item.  The implied hDC for this call will be for the display.
.c.:5.8 Mouse functions
(NYI)
.c.::5.8.1 ReadMouse
VOID ReadMouse(hpmsb)MSB HUGE *hpmsb;		/* ptr to Mouse Structure Block */
Query the mouse driver about its status, and fill in the MSB with the corresponding information.
(NYI)
.c.::5.8.2 MouseEnable
VOID MouseEnable(fStatus)BOOL fStatus;			/* true -> on, false -> off */
Give the mouse driver a routine to call when the buttons are pushed.  The 'mouse off' routine does nothing; the 'mouse on' routine drops a flag in the pCode's data segment, indicating that a mouse event has occured.  Also, tell the mouse driver to turn the mouse cursor on or off.
(NYI)
.c.::5.8.3 FInitMouse
BOOL FInitMouse()
Tell the mouse driver to: reset the mouse; set the mouse cursor shape; set the mickey/pixel ratio; set its button-push routine; turn the mouse on; do any other housekeeping stuff.
If there's a mouse in the system, it does all this and returns 1 for success.  Else, it returns 0 for failure.
(NYI)
.c.::5.8.4 SetMouse
VOID SetMouse(hpmcb)MCB HUGE *hpmcb;		/* ptr to Mouse Cursor Block */
Give the mouse driver the MCB, to set up its cursor.  This function does some potential massaging of the MCB, to avoid some sort of trunction problem.
This function does not currently check to see if the mouse is installed; it'll do an int 33 regardless.  An Assert should be added.
.c.:5.9 Debug functions
Note:  We haven't got an OS/2 PCode debugger yet.
.c.::5.9.1 Break
VOID Break
No input or output.  
Break out of a user program into the debugger.  This is the way a user can hardcode a breakpoint.  NOTE: this is treated as a user interrupt to avoid unexpected breakpoint error.
.c.::5.9.2 StartUMeas
Start user measurement.  Used to set up measurement information for the debugger.  Passes information to debugger that's used by profile to isolate sections of code.
Note:  We don't how this will work under OS/2.
.c.::5.9.3 StopUMeas
See StartUMeas, above.
.c.::5.9.4 DebugCmd, DebugMovedSeg, DebugSetSeg, and ServiceReturn
These functions existed as XOS calls in Multiplan 3. They do not exist for MP4.
.c.:5.10 Transfer of control functions
.c.::5.10.1 SCall
.c.::5.10.2 SetJmp
.c.::5.10.3 DoJmp
.c.:5.11 Miscellaneous functions
.c.::5.11.1 Beep
VOID Beep
Sounds the bell.
(NYI)
.c.::5.11.2 CheckSum
WORD CheckSum(cw,hpb)WORD cw;				/* number of words to sum up */WORD huge *hpb;		/* ptr to block of data to sum */
Returns the summation of cWords words starting at hpData.  If this function existed only for use by the swapper, then it's no longer needed; else it will be easy to create.
(NYI)
.c.::5.11.3 LoadDrvr
WORD LoadDrvr(hpchDrv,hpchDevTbl,hpchLoad,cbMacLoad,fLoad)char huge *hpchDrv;		/* filename to load */char huge *hpchDevTbl;	/* array to copy Dev Table */char huge *hpchLoad;	/* address to load file */WORD cbMacLoad;		/* maximum size of file allowed */WORD fLoad;			/* 1 = load, 0 = not load */
Returns the space needed for the driver, or 0 for failure.
(NYI)
.c.::5.11.4 FixupDrvr
WORD FixupDrvr(hpbDrv,  ,wSegLast,hpbGlobs)char huge *hpbDrv;		/* ptr to driver block in memory */  ???  cbDriver ??		/* I don't know what this is */unsigned wSegLast;		/* last segment used for fixups */char huge *hpbGlobs;	/* address of global pCode vars */
Returns 0 if there's an error, else the segment of the driver.
(NYI)
.c.::5.11.5 CallDrvr
WORD CallDrvr(fcd,hpbParms)WORD fcd;				/* which function of CallDrvr */BYTE HUGE *hpbParms		/* parameters to the function */fcdSetVec = -1
There are two functions within here.  If fcd = fcdSetVec, then it's a SetVector, which always returns 0.  Else, it's a true CallDrvr function, which returns whatever the function itself returns.
(NYI)
.c.::5.11.6 Print
WORD Print(hpch,cch)char huge *hpch;		/* string to print out */word cch;				/* count of characters to print */
Returns 0 if succesful, -1 if error.
The OSPrint routine for MP35 is much simpler than the one for MP304.  Let's hope that's the one we have to emulate.
.c.6. Structures
.c.:6.1 Mouse Status Block
typedef struct			/* Mouse Status Block */	{	WORD xco;			/* mouse position coordinates */	WORD yco;	BOOL fLeft;		/* left button press history */	BOOL fRight;		/* right button press history */	} MSB
.c.7. Revision History
September 1, 1987.  Created the document.
September 16, 1987.  Second pass.
September 29, 1987.  Added the document to the C# project.
October 26, 1987.  Version 1.01.02.  Implemented OutCons, EraseScreen, AlterAttr, CreateFile, AccessFile, ReadFile, WriteFile, DeleteFile, VideoFreeze, GetDate, GetTime, GetCountry.  Fixed some mouse stuff, but the OS routines still aren't fully there.
November 11, 1987.  Version 1.1.  Implemented the first pass of OS/2 routines.  All the routines supported by DOS are supported by OS/2 except:  GetCountry, AccessFile, CreateFile, FRemoveable, FNetworkDrive, CodePageCur, and all the Windows clipboard calls.
Table Of Contents
.Begin Table C.
1. Introduction	1
2. Files involved.	1
3. Routines that Multiplan must provide.	2
3.1 Main	2
3.2 Exit	2
3.3 MathError	2
4. Translation of old XOS calls to new Toolbox calls.	2
4.1 Implemented functions	2
4.1.1 Video functions
4.1.2 File i/o functions	3
4.1.3 Keyboard functions	3
4.1.4 Windows Clipboard functions	3
4.1.5 Misc. DOS functions	3
4.2 Stub functions	4
4.3 Not yet implemented functions	4
4.4 Already provided library functions	4
4.4.1 Debug functions
4.4.2 Math functions
4.5 Discarded functions	5
5. API	5
5.1 Types.	5
5.2 Math pack.	6
5.3 Video functions.	6
5.3.1 OutRgch	7
5.3.2 AlterAttr	7
5.3.3 GetDfltNormalColors	8
5.3.4 GetDfltInverseColors	8
5.3.5 EnableCurs	8
5.3.6 DisableCurs	8
5.3.7 SetCursor	8
5.3.8 XCo	8
5.3.9 YCo	8
5.3.10 SetForeColor	9
5.3.11 SetBackColor	9
5.3.12 SetColorsDflt	9
5.3.13 GetMaxScreenLines	9
5.3.14 SetRows	9
5.3.15 SetRowsForceMode	10
5.3.16 EraseScreen	10
5.3.17 MoveRectangle	10
5.3.18 OutChar	10
5.3.19 OutCons	10
5.3.20 VideoFreeze	10
5.4 File I/O functions	11
5.4.1 CreateFile	11
5.4.2 AccessFile	11
5.4.3 ReadFile	11
5.4.4 WriteFile	12
5.4.5 CloseFile	12
5.4.6 SeekFileSector	12
5.4.7 FileSize	12
5.4.8 DeleteFile	12
5.4.9 GetCurDir	12
5.4.10 FindFile	13
5.4.11 SetCurDir	13
5.4.12 DoPrintDev	13
5.4.12.1 OpenPrintDev	14
5.4.12.2 SetPrintDev	14
5.4.12.3 ClosePrintDev	14
5.4.12.4 RetPrintDev	14
5.5 Keyboard functions	14
5.5.1 FCheckEvent	14
5.5.2 InChar	14
5.6 DOS functions	15
5.6.1 GetDate	15
5.6.2 GetTime	15
5.6.3 VerDOSCur	15
5.6.4 GetCountry	15
5.6.5 FRemoveableDrive	16
5.6.6 FNetworkDrive	16
5.6.7 CodePageCur	16
5.7 Windows Clipboard functions	16
5.7.1 IdentifyWinOldApVersion	16
5.7.2 OpenClipboard	16
5.7.3 EmptyClipboard	17
5.7.4 SetClipboardData	17
5.7.5 GetClipboardDataSize	17
5.7.6 GetClipboardData	17
5.7.7 RegisterClipboardFormat	17
5.7.8 EnumClipboardFormats	17
5.7.9 CloseClipboard	17
5.7.10 ClipboardCompact	18
5.7.11 GetDeviceCaps	18
5.8 Mouse functions	18
5.8.1 ReadMouse	18
5.8.2 MouseEnable	18
5.8.3 FInitMouse	18
5.8.4 SetMouse	18
5.9 Debug functions	19
5.9.1 Break	19
5.9.2 StartUMeas	19
5.9.3 StopUMeas	19
5.9.4 DebugCmd, DebugMovedSeg, DebugSetSeg, and ServiceReturn	19
5.10 Transfer of control functions	19
5.10.1 SCall	19
5.10.2 SetJmp	19
5.10.3 DoJmp	19
5.11 Miscellaneous functions	19
5.11.1 Beep	19
5.11.2 CheckSum	20
5.11.3 LoadDrvr	20
5.11.4 FixupDrvr	20
5.11.5 CallDrvr	20
5.11.6 Print	20
5.11.7 DOSExec	21
6. Structures	21
6.1 Mouse Status Block	21
7. Revision History	22
.End Table C.
܀         v       q       m    h       f A  D  d 	  	  b 	  	  _  @		 @@ @ @ @	  	  y 
  
  w 
   
  u 
  
  s D  N  q Z  ]  o     m     k     i 		      y 1  5  w D  H  u I  R  s Y  b  q     o     m k  n  k '  			'  +  y o  t  w     u -  2  s i  n  q     o     m     k     i 									  t  x  y     w     u      s (  ,  q 8  <  o [  _  m     k   						    y     w     u     s     q     o J  L  m |  ~  k     i       y ;  =  w r  y  u     s      q L   W   o       m       k 2!  2!  6!  y F!  K!  w "  "  u #  #  s $  $  q $  $  o %  %  m %  %  k %  %  i 				%  %  %  y |&  &  w <'  B'  u '  '  s (  (  q (  (  o Y(  ](  m (  (  k )  	)  )  y .)  5)  w 6)  <)  u =)  @)  s A)  G)  q O)  U)  o s)  v)  m )  )  k )  )  i 	)  )  *  y 5*  <*  w K*  T*  u b*  k*  s y*  *  q *  *  o *  *  m +  +  k ,  ,  ,  y ,  ,  w ,   -  u 6-  =-  s .  .  q .  .  o d/  g/  m /  /  k /  /  i /  /  /  y /  /  w /  /  u 0  0  s 0  0  o 0  k 0  g 0  e 0  a 0  _ /   @ @A @	0  0  w 0  u 0  q 0  o 1  k i1  l1  i 1  1  g 1  1  e 3  $3  c %3  *3  a 3   @ @ @3  3  y 3  3  w U4  Z4  u {4  4  s 4  4  q 4  4  o 4  4  m 4  4  k 4  4  i 		4  4  4  y i5  n5  w p5  |5  u 5  5  s 5  5  q 5  5  o 5  5  m 6  6  k 56  	56  ?6  y a6  f6  w ~6  6  u 6  6  s 6  6  q 6  6  o 6  6  m 6  6  k 6  6  i 		6  7  7  y 7   7  w $7  )7  u 77  :7  s 7  7  q 7  7  o 7  7  m 8  8  k 8  			8  8  y "8  $8  w )8  28  u 48  58  s <8  F8  q H8  I8  o 8  8  m 8  8  k 8  8  i 8  8  8  y 8  8  w 9  9  u E9  G9  s J9  S9  q 9  9  o 9  9  m 9  9  k \:  \:  ^:  y b:  i:  w :  :  u :  :  s ;  ;  q ;  ;  o ;  ;  m K;  W;  k ^;  g;  i 	g;  ;  ;  y ;  ;  w $<  &<  u +<  s F<  S<  q U<  W<  o <  <  m =  (=  k =  =  i 			=  =  =  y  >  >  w #>  (>  u P>  Q>  s z>  >  q ?  ?  o ?  ?  m ?  ?  k F@  		F@  T@  y @  @  w A  A  u A  A  s <A  NA  q (B  -B  o FB  QB  m SB  UB  k B  B  i 			B  B  B  y B  B  w B  B  u B  B  s B  C  q C  C  o 	C  C  m C  C  k C  	C  C  y %C  *C  w 1C  6C  u =C  @C  s GC  JC  q C  C  o C  C  m C  C  k C  C  i 	C  5D  7D  y D  D  w D  D  u D  D  s D  D  q D  D  o D  D  m ;E  =E  k LE  	LE  OE  y E  E  w E  F  u F   G  s G  G  q 2G  <G  o =G  CG  m DG  GG  k OG  UG  i 			UG  yG  |G  y G  G  w G  G  u G  H  s H  H  q H  %H  o (H  6H  m H  H  k H  H  H  y H  H  w H  H  u H  H  s I  
I  q rI  I  o I  I  m I  I  k I  I  i 		I  I  I  y I  I  w J  J  u $J  (J  s nJ  rJ  q J  J  o J  J  m  K  %K  k AK  	AK  PK  y QK  SK  w YK  _K  u dK  jK  s oK  qK  q K  K  o K  K  m 0L  6L  k |L  L  i L  L  L  y L  L  w L  L  u L  L  s 	M  M  q M  "M  o 'M  /M  m 2M  8M  k LM  		LM  TM  y UM  WM  w XM  [M  u \M  ^M  s cM  eM  q M  M  o M  M  m N  N  k  N  %N  i 	%N  9N  BN  y CN  EN  w FN  IN  u JN  LN  s QN  SN  q zN  }N  o N  N  m N  N  k N  	N  N  y  O  O  w O  "O  u #O  %O  s *O  ,O  q hO  qO  o vO  ~O  m O  O  k O  O  i 		O  O  O  y O  O  w NQ  WQ  u YQ  fQ  s kQ  |Q  q Q  Q  o R  R  m 2R  <R  k =R  	=R  BR  y CR  HR  w QR  VR  u tR  yR  s R  R  q ;S  @S  o XS  dS  m eS  jS  k kS  pS  i 	pS  uS  wS  y 6T  ;T  w UT  bT  u cT  jT  s kT  mT  q uT  |T  o T  T  m U  #U  k U  	U  U  y U  
V  w V  V  u V  V  s V  V  q V  V  o V  V  m V  V  k V  V  i 		V  W  &W  y OW  UW  w W  W  u W  W  s W  W  q Y  Y  o .Y  =Y  m >Y  DY  k LY  	LY  RY  y \  \  w \  \  u ]  ]  s ]  ]  q ']  0]  o _  _  m /_  :_  k ;_  >_  i 		>_  F_  I_  y _  _  w ~a  a  u a  a  s a  a  q a  a  o Gb  Lb  m tc  zc  k c  	c  c  y c  c  w c  c  u c  c  s Bd  Gd  q \d  ed  o fd  md  m nd  qd  k rd  xd  i 		xd  yd  }d  y d  d  w d  d  u d  d  s e  e  q 8e  ;e  o ?e  Ge  m Ke  Ne  k Pe  Pe  Qe  y he  oe  w e  e  u Af  Hf  s f  g  q g  g  o g  g  m h  h  k 0h  4h  i 4h  i  i  y i  i  w i  i  u i  i  s i  j  q )j  ,j  o Vj  Yj  m ]j  dj  k hj  	hj  lj  y j  j  w j  j  u j  j  s j  j  q j  j  o j  j  m j  j  h k  k  f  A0k  k  k  y l  l  w ol  xl  u m  m  s ?m  Hm  q Vm  bm  o em  km  m m  m  k Bn   A		Bn  In  y n  n  w n  n  u o  o  s Cp  Pp  q p  p  o (q  .q  m vq  }q  k q  q  i 		q  r  r  y r  "r  w :r  Gr  u r  r  s r  r  q u  u  o 0u  ;u  m u  u  k u  					u  u  y u  u  w  |  |  u |  $|  s |  |  q |  }  o D}  I}  m b}  n}  k }  }  i 					}  }  }  y }  }  w }   ~  u ~  ~  s ~  ~  q ~  ~  o ~  ~  m ~  ~  k \  		\  _  y b  g  w ~    u     s     q     o     m   )  k 1  7  i 		7  d  n  y     w ҁ  ׁ  u     s      q     o     m     k   		    y   Ƀ  w     u     s   Ʌ  q х    o P  U  m [  h  k o  |  i 			|  ۆ    y     w   	  u Z  _  s e  u  q |    o     m     k   		    y     w     u   %  s     q   1  o 8  L  m N  P  k V  X  i 	X  v  {  y     w     u     s     q Ê  Ŋ  o Ҋ    m d  i  k o  		o    y     w     u   Ƌ  s +  0  q 6  J  o O  c  m e  k  k q  w  i 	w      y      w     u p  u  s |    q     o     m   ͍  k ֎  		֎  ێ  y     w     u     s   %  q     o ݏ    m     k     i 			      y     w Ő  А  u ѐ  ؐ  s ߐ    q +  0  o G  Q  m S  U  k   		    y     w     u     s     q     o G  L  m ^  c  k 0  5  i 				5    #  y 8  B  w L  Q  u     s 	    q   !  o 0  5  m C  G  k e  								e  j  y |    w     u     s @  F  q Y  _  o ܙ    m     k a  f  i 				f  }    y ǜ  ̜  w     u     s     q     o 2  :  m ^  g  k   		    y     w 9  >  u Q  V  s Y  \  q k  o  o N  Q  m S  W  k     f  @				  +  :  v ;  9  >  u Q  V  s Y  \  q k  o  o N  Q  m S  W  k     f  @			 @      i    W    U    S    Q A  O                                     Q  m SKCA?G             G             A  U  v   q Z  q T  q t  q @  q 	  q 	  q 	  l                                                        =  		  	  v 
  q "
  l 
  g 
  b F  ] P  X                                               W = W = W = W P    v   v Z  q   l   g   e 1  ?  `                                                  W  W = ?    y     t k    o '  m F  h o                                                   W E  Wo    v   t   o -  m L  h i  f   a                                                        W W W     y   t   r   m   k   f   d                                                        W W W W    v t  t   o   m   h   f   a                                                        W W W     y (  t 8  o [  m   m   m   m J  m |  m                                                       W  W	|    y   y ;  y 2!  y F!  t Y!  o #  j #  e                                                       =   W#  $  v %  v %  q <'  l '  l "(  l (  l (  g                                                       =  = (  )  ()  v +  q +  l W,  l ,  l !.  l ]/  l 0  l                                                       = W  	0  0  v 1  q 1  l 2  l 3  l 3  g 3  b                                                         W  = W  3  U4  v v4  q 4  l 5  l e5  g 6  b 06  ]                                                     W = W  = 06  C6  v a6  v y6  q 6  l 6  l 6  g 6  b                                                     W  W  W 6  $7  v 47  q >7  o 7  7  j 7  h 7  8  c                                                  W W = 8  '8  v O8  v 8  q =9  q 9  q Q:  q :  q ;  l                                                  W = W ;  ;  v &<  q A<  l W<  g <  b =  ] ,=  [                                                  W = W  = W ,=  =  v =  t =  o C>  j >  e A  e A  c                                                  W a= W  a= A  7A  v NA  q (B  l AB  g UB  b B  ] B  X                                                = W  = W  B  MC  v C  q C  l D  g D  b D  ] E  [                                                W = W  = W E  E  E  v CF  t F  G  o /G  j G  h G  h                                                 = W  W G  8H  y H  y H  t *I  r I  r I  m AJ  k J                                                  = WW W WJ   K  <K  v K  t L  L  o L  m 2M  HM  h                                                 =  W W HM  M  y  N  6N  t N  r  O  O  m RO  k O                                                  =  W W WO  O  v O  t 8Q  R  /R  o R  m ;S  SS  h                                                 =  W W SS  S  y 6T  PT  t T  r }U  U  U  m "V  k                                                 =  W W W"V  V  V  v zW  t *X  [X  r X  Y  )Y  m                                                 =  W WW )Y  rY  y Y  ;Z  w dZ  [  [  \  ]  r O]  p                                                       W W EW	O]  ^  _  +_  v f_  t _  ^`  `  ~a  a  o                                                       W W 	a  a  y c  c  c  t c  r Bd  Xd  m e  k                                                            W W We  0f  f  g  0h  h  h  i  i  y i  t                                                       W W a	i  j  y k  l  3l  t em  m  o n  o                                                              W  Wo  o  v 5p  (q  Dq  q r  r  l 5r  g Gr  e   I   I   I   I   I   I   I   I      W    Gr  r  r  v r  t _s  t  u  +u  o ?u  m u    I   I   I   I   I   I   I   I   I W W 	u  u  v u  q v  o kw  o w  [y  Uz  ]{   |    I   I   I   I   I   I   I   I   I WW  	 |  |  v &|  t |  |  o }  m D}  ]}  h |}  f   I   I   I   I   I   I   I   I   I W W W |}  }  }  v $~  t ~  t ~  o   m b  m y  h   I   I   I   I   I   I   I   I   I W W W y    y   y   t   r ҁ    m G  k     I   I   I   I   I   I   I   I   I W W W W  ɂ        v   t *  W        I   I   I   I   I   I   I   I   I W WW 	    y =  t   ˅  o   m P  j  h   f   I   I   I   I   I   I   I   I   I W W  a  ۆ    v   t Z  w  o L  m   3  h   I   I   I   I   I   I   I   I   I W W W 3  v  y v    t   r ]  d  p   k ɋ  i   I   I   I   I   I   I   I   I   I WW aW Wɋ  $  +  y L  t   r     m   k p    I   I   I   I   I   I   I   I   I WWW W ap    v   t ώ  ֎  r   m D  k   ֏  f   I   I   I   I   I   I   I   I   I  W aW ֏  ݏ  y   t ?  r     p   k 
  i $    I   I   I   I   I   I   I   I   I  W aW a$  +  y B  t U  r 
  z    p   k ޓ  i   I   I   I   I   I   I   I   I   I  W aW aޓ  v      v G  Y  q e  o |  0    I   I   I   I   I   I   I   I   I  W W  0  G  v     4  q L    l   	  g   I   I   I   I   I   I   I   I   I     	    v 0  v C  v e  q w  l   j     h   I   I   I   I   I   I   I   I   I aW       v '  t ՙ  ܙ  r   m   k Z  a  i   I   I   I   I   I   I   I   I   I aW aW a  x  v   t   ǜ  r ݜ  m n  k 2  9  i   I   I   I   I   I   I   I   I   I aW aW 9  L  v   t   Y  k  o   j S  h T    I   I   I   I   I   I               I W  W T  l  v             t                                                     I W  ?   1  a G  a s  a   G   G                                                          !                !    a գ  G   -                                            !                !                !  	  a %  a A  a f  a   a                                       !                !      	           !    a   a   a   G   G                                       !      	           !                !  0  a :  G H  -                                            !                !                !H  Z  a r  a   G   G   G                                       !      	           !                !  ѥ  a   a   a   a   a '  a >  a U  a                                                       	           !U  m  a   a   a   a Φ  a   a   a   a                                                       	           !  $  a ?  G T  -                     a        	           !                !      	           !T  i  a |  a   a   a   a Ч  a   a   a                                                       	           !    a "  a 8  a R  G k  G                                               @           !      	           !k    a   a   G                                                                      !     @           !  Ш  a   a   G                                                                      !      	           !  	  a   a /  a D  a _  a w  a   a                                                     !      	           !    a ө  G   G   G   G                                                	           !                !  >  a Y  a {  a   a   a Ϫ  a   a                                                     !      	           !     a   G *  G ?  G R  G                                                	           !                !R  j  a z  G   G   G   G                                                	           !                !    a   G /  G @  G                                                      	           !                !@  a  a q  G   G   G   G                                                	           !                !  ¬  a Ӭ  a   a   G                                                                !      	           !    a +  G :  ;  <                                                           !                !!= -48$ ;     != -48$ ;      
     	    E      D%  -  5  :  B  QH  N  U  ^  e  o  .v  	~      =    >  ԟ  z  =  f           :    "   
   %    x   <      	 	  
 -                                    7    -    b    l        `                                        ԟ         "     * 6 7 A B G O W Multiplan 4 Toolbox API Kirk Glerum  Multiplan  1.00 03/24/8908/27/87  
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cwbak.doc ===
1             3 ; ; ; ; < C:\C#\DOC\C#.STY                                                    HPLASMS =                     		--	
	CW BAK Guide	
Kanji Character WindowsBinary Adaptation Kit : The Guide(CW 2.20)Scott RandellMicrosoft Applications Division
.c.1. Introduction
This document describes the Binary Adaptation Kit for Character Windows (CW) and it's Kanji variants.
.c.2. Files Provides
.c.:2.1 Documents
Above the standard CW development kit (including CW API documents etc.), the following documents are provided in the DRV/DOC directory:
DRV.DOC	Runtime installable driver interface specification.
CWBAK.DOC	this document.
NOTE: the DRV.DOC includes the interface for run-time loadable drivers.  This is not currently implemented, drivers are linked in with the CW library.  Feel free to ignore this information (it will be implemented in the near future).
.c.:2.2 Source Files
In the DRV/INC directory are the following headers:
CMACROS.INC	standard header.
INDRV.INC		installable driver header.
INSCREEN.INC	installable screen header.
INKBD.INC		installable keyboard header.
COW.INC, UEVENT.INC etc -- needed CW headers.
In the DRV/EXAMPLE driver directory are the files:
General:
MAKEFILE	a make file (Xenix MAKE) for the DRV.LIB library.
DRV.INC	header for link-time drivers.
Screen Driver:
SCR*.INC	Example screen driver headers.
SCR*.ASM	Example screen driver source.
Keyboard Driver:
KEY*.INC	Example keyboard driver headers.
KEY*.ASM	Example keyboard driver source.
In the COW35 directory is a pre-linked version of CW:
DKOW.LIB	Debugging Kanji version of CW.
KOW.LIB	(to be provided later) non-debugging version.
.c.:2.3 Tools
The following tools are needed (but not provided):
MASM (version 5.0 preferably) for assembling the example drivers.
MAKE (Xenix version of MAKE) for controlling make process.
.c.3. Building the Example Drivers
Simply running KMAKE in the example directory will make a new DRV.LIB (Kanji version).  Link this before the provided DKOW.LIB and this will replace the default drivers.
The example driver will work on the new OAX card (with hardware character generator).  It also will work on a standard IBM CGA/EGA showing the Kanji characters as their IBM character set equivalents (i.e. garbage).
.c.4. Example CW application
The HELLO application has been adapted to work with the KANJI version of CW.  Running KMAKE in the DRV/HELLO subdirectory will make this program.  Some additional tools will be required to make this program (CC the CMerge compiler, LINK the DOS linker, DE20.EXE the Dialog editor).
When linked the program can be run.  The supplies some trivial examples of the uses of Kanji CW.  Note: not all dialog have been converted to Kanji.  Look in the SCR.C source file and the KANJI.DES file for the KANJI examples.
I know no Japanese, so don't be surprised when the example program displays random Kanji character.
.c.5. Adaptation
.c.:5.1 Screen
To adapt to different machines requires changing all INT 10 BIOS calls to comparable functions on the target machine.
For the OAX driver, we can not draw 1/2 characters, therefore there is special code in the PrepareUpdateScr and DoUpdateScr to parse the output line and set the attribute for the second character of a double byte character to be zero.  That way the screen code can quickly check to see if the first or second byte of a double byte character is going to be over-written and replace the other half with a blank character.  For pull down menus and dialogs, CW always save 1 character before and after the rectangle which allows the rectangle to be fully restored.
For the NEC, this is much easier since 1/2 characters can be displayed.
Screen colors are stored in IBM format (upper nibble is background color, lower nibble is foreground).  For displays that do not support that color model (eg. the NEC) a translation table must be provided in the driver.
.c.:5.2 Adapting Window Keyboard Drivers
Adapting a Windows keyboard driver to function as a CW driver requires the following changes:
1) the CW driver must be linked in (not a separate dyna-link library).  This requires reformatting the code slightly, the segment definitions in the example keyboard driver should 
2) the EnableKeyboard() call maps to the Windows Enable/Disable procedures.
3) the callback function passed to the Window's Enable() function must perform the ToAscii() function before sending the key to CW via the KeyboardMessage() procedure and shift state information to UpdateShiftState().
4) for simplicity the fAbort, fPollKeyboard, fKeyIsUp, fKeyWasUp, fNormalKeyboard and fNonAltKeyHit flags can be ignored.
5) the SpecialAbort, and FTestKeyboardEmpty calls can also be ignored.
6) the PollKeyboard() call should just clear the fPollKeyboard flag and return.
7) the ChAlternateKeycap is something new that must be supplied by the driver.
.c.6. Driver Notes
The following notes should be kept in mind when writing installable drivers:
* you can not directly allocate driver data in the default data segment, you must allocate it in the runtime data structure (SDDATA or KDDATA).
* the names of structures in source files usually have the name of the structure added to the end of the field name.  For example the documentation will refer to fAbort in the INKB structure, but in the header this is represented as "fAbortInkb".
* example BATch files may have to be modified to suit your development environment.
Table Of Contents
.Begin Table C.
1. Introduction	1
2. Files Provides	1
2.1 Documents	1
2.2 Source Files	1
2.3 Tools	2
3. Building the Example Drivers	2
4. Example CW application	2
5. Adaptation	3
5.1 Screen	3
5.2 Adapting Window Keyboard Drivers	3
6. Driver Notes	3
.End Table C.
              
     P  2.3 Tools                                                                v       q      m   h     f     d     b     `   			 @@ @ @ @    y     w R  U  u     s     q {  ~  o     m o    k     i 							  l  p  y     w     u     s     q     o      m 
    k   		  $  y )  6  w U  a  u g  y  s     q     o     m 7  :  k     i 		      y     w     r     m   q     o     m 7  :  k     i 		 @ @      Y    7   5 $  0   +   &  =  A!H $                   p `'!H $                    `'    v =  q z  l   l   g   b   ]   X   X 8  X a  X   X   S   p= W =  = U =      v 
  q 1  q A  l j  g   g   b   ]   ] 0  X Y  S   S   N  U = W E W E W E     v   q R  q v  l !  g   g 	  b 2
  ]   ] {  ]   X   S   N =   =  =  E =   F  v   v l  v   q   l   g   g   g N  g   g   g 7  g K  b   *  ]  E  E =  = *  "  v w  v   q     W   W   =   =   =   g                 !                !? E 	    a 6  a G  a U  G }  G   -   =                  !                !                !    v   G  a U  G }  G   -   =                  !                !              =            
     ٹ   =!sPp    n    @^    ς .GLY  [       = ςd   Z/ E  ( , - . / 4 < D Binary Adaptation Kit SAR    1.00 2/3/88  1/27/88   ware cursor (size, shape, blinking rate, ...).
VOID MoveHwCursScr(ax, ay, fOn)BYTE	ax;BYTE	ay;BOOL	fOn;
Move the cursor to the specified screen position (ax, ay).  If fOn is not zero (check full WORD) then the cursor should be enabled (i.e. visible), otherwise the cursor should be disabled (i.e. invisible).
.c.:4.4 Screen Update / Drawing
.c.::4.4.1 UpdateScr
This routine handles the drawing of 1 line of output.
VOID UpdateScr(
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cwdrv.doc ===
1           t  @@ABCC:\EDITORS\C#.STY                                                   HPLASMS D                    
		--	
	CW API Guide : Installable Drivers	
Character WindowsAPI Guide : Installable Drivers (2.22.02)
Scott RandellMicrosoft Applications Division
.c.1. Introduction
This appendix describes the installable driver API to Character Windows.  All CW API routines that apply to installed drivers are described here.
Of interest directly to CW are the character screen (CSD) and keyboard (KBD) driver.  Other driver types can be loaded under control of the application (.GSD files for example).
  All versions of CW Applications must use the screen API to initialize and switch screen modes.  All CW applications should work with a general screen size (anything greater than 80x25 and less than 255x255).  The sample HELLO application has an example of a mode selection dialog (applications can do something simpler if desired).
.c.2. Loading Drivers
Each CW application has a default CSD and KBD driver installed (at link time).  By default this supports minimum functionality (CGA screen (text only), simple IBM compatible keyboard).
A separate driver file (usually called SCREEN.VID) can be optionally loaded at run time to replace the default driver functionality.  In the event that this file can not be found, the default drivers should be used (this may not work on some non-PC compatible machines).
After the loading the driver (or failing to find the file) the application is responsible for initializing the keyboard, mouse and screen mode (see below for specific API calls).  Mouse API calls may be found in the COWAPI.DOC document.
.c.:2.1 Application Supplied Memory Allocation
In order for the driver load and mode initialization to allocate memory, the application must provide an allocation and freeing function.
.c.::2.1.1 LpwAllocDriverMem
WORD FAR * LpwAllocDriverMem(cw, fmem)WORD	cw;WORD	fmem;
Application supplied procedure (passed to ??? and FAllocInstBuffers).  Allocate a memory buffer of size cw words with the attributes specified by fmem.  Return far pointer to buffer (or NULL if insufficient memory).
fmem may be one of:
fmemFixed	Allocate a fixed block, otherwise moveable.
fmemNear	Allocate in near space (default data segment).  Return pointer should be in default data segment.
NOTE: currently all allocations must be fixed !!!
For near allocations (in the default data segment), the returned address must be WORD aligned.  Note: near allocations are limited to 128 bytes per driver.
For far allocations, the returned address must be properly paragraph aligned (i.e. a far pointer with 0 offset).
.c.::2.1.2 FreeDriverMem
VOID FreeDriverMem(lpw)WORD	FAR * lpw;
Frees a memory buffer previously allocated with LpwAllocDriverMem().
.c.:2.2 Loading Standard CW Drivers
CW currently allows replacement of CSD (screen) and KBD (keyboard) drivers.  To load in optional drivers the following call is used:
.c.::2.2.1 RerrLoadCwDrv
WORD RerrLoadCwDrv(szFile)char *	szFile;
Attempts to load the drivers needed by CW from the specified driver file (szFile -- must be full path if driver is not in current directory).
Returns 0 if successful, or one of the following error codes:
rerrBadFile	szFile could not be opened.
rerrBadRead	An error was encountered while reading szFile.
rerrBadFormat	szFile does not have the correct format.
rerrNoMemory	LpwAllocDriverMem was not able to allocate the requested memory for a service.
rerrBadMemReq	A service tried to allocate too much near memory.  (The limit is cbNearMemServiceMax.)
rerrBadVersion	The version of a service was not compatible.
.c.:2.3 Loading Extra Driver Services
For non-CW drivers (GSD, PRD, GPD, ...) the INDV structure is used to specify which services are desired.  The RerrLoadDrv() routine is used to attempt to load in the desired services.
Please refer to the CW Installable Driver document (DRV.DOC) for more information on driver services.
.c.::2.3.1 INDV
This structure is used to communicate with the RerrLoadDrv routine for specifying the services desired.
The following fields of the INDV structure are set by the application before the call to RerrLoadDrv:
indt	The service type requested.
rglpfn	A near pointer to an array of FAR function pointers (of size cpfnNeedMac).  When loaded the jump vectors to standard services will be placed in this array.
cpfnNeedMin	The minimum number of function pointers needed from the service.
cpfnNeedMac	The maximum number of function pointers needed from the service.
The following fields of the INDV structure are set by the call to RerrLoadDrv and can be checked by the application after the call:
psLoaded	The physical segment where the service was loaded (or 0 if service not loaded).
cpfnLoaded	The number of function pointers loaded.
Note that cpfnLoaded >= cpfnNeedMin for a successful load.  cpfnLoaded can be > cpfnNeedMac (if the service has some new entries) but the extra function pointers will not be placed in rglpfn (only up to cpfnNeedMac will be).
.c.::2.3.2 RerrLoadDrv
WORD RerrLoadDrv(szFile, rgindv, cindv)char *	szFile;INDV *	rgindv;WORD	cindv;
Attempts to load driver services from the specified driver file.  The array rgindv contains the load requests, cindv indicates the size of the array.
Return value as in RerrLoadCwDrv (even in error conditions some services may have been successfully loaded (check the psLoaded field in the INDV structure for exact details).
.c.2.4 Freeing Services
These routines must be used with care as any calls to freed services are invalid until new services are loaded using RerrLoadDrv.
2.4.1 FreeDrv
VOID FreeDrv(rgindv, cindv)INDV *	rgindv;WORD	cindv;
Frees the memory allocated for the services described by the INDV structures in the rgindv array.  cindv indicates the size of the array.
No attempt is made to back-install a prior service.
3. Keyboard Input
The keyboard driver provides the following functionality (either directly or indirectly):
.c.:3.1 General Control
.c.::3.1.1 DisableExtendedKeyboard
VOID.i.DisableExtendedKeyboard();DisableExtendedKeyboard()
Optional: call this before call to EnableKeyboard(TRUE) to set the keyboard driver to not use extended BIOS calls (making it safer for TSRs (Word /K option)).
.c.::3.1.2 EnableKeyboard
VOID.i.EnableKeyboard();EnableKeyboard(fEnable)BOOL fEnable;
Indicates whether keyboard input should be enabled or not.  EnableKeyboard(TRUE) must be called after the appropriate service has been loaded with RerrLoadCwDrv.  If RerrLoadCwDrv is not used, EnableKeyboard(TRUE) can be called at any time before PollKeyboard.
.c.::3.1.3 PollKeyoard
VOID.i.PollKeyboard();PollKeyboard()
Called by application in idle loop for (see Message pump section for more info).
.c.:3.2 Shift States
.c.::3.2.1 UpdateShiftKk
In order for the application to update its status line with shift states, the application should provide a UpdateShiftKk routine of the following format :
VOID.i.UpdateShiftKk;UpdateShiftKk(kkNew, kkOld)WORD	kkNew, kkOld;
Supplied by application (optional) : called by CW when shift states change.  kkNew is the new shift state, kkOld is the old shift state.  The following KK_ values are used to represent the shift states (i.e. kkNew is the current set of key with the corresponding KK_ values ORed together):
KK_SHIFT, KK_CONTROL, KK_ALT, KK_NUMLOCK, KK_SCRLOCK, KK_CAPLOCK.
See the messages document (COWWM.DOC) for a complete description of KK_ values.
For swapped environments, UpdateShiftKk and all procedures called by it must be placed in FIXED segments.
.c.::3.2.2 SynthesizeShiftKeys
VOID.i.SynthesizeShiftKeys;SynthesizeShiftKeys(kkNew, kkOld)WORD	kkNew, kkOld;
If the application would like shift key transitions to generate WM_KEYDOWN and WM_KEYUP messages, this routine should be placed in the UpdateShiftKk callback routine.  It uses the transition of shift states to post keyboard messages into the message queue.
.c.::3.2.3 SetShiftKk
BOOL.i.SetShiftKk();SetShiftKk(kkNew)WORD	kkNew;
Sets the shift states of the keyboard to the values specified.
.c.:3.3 Key Event Hooking
.c.::3.3.1 InsertKeyboardMessage
VOID.i.SetShiftKk();InsertKeyboardMessage(message, wParam, lParam)WORD message, wParam;DWORD lParam;
Inserts a message into the keyboard message stream.  message should be either WM_CHAR or WM_KEYUP.  wParam is a virtual key (VK_xxx) and lParam specifies a shift state (combination of KK_xxx masks) in its upper word and a repeat count in its lower word.
.c.::3.3.2 HookKeyboardMessage
VOID.i.SetShiftKk();HookKeyboardMessage(fEnable, pfn)BOOL fEnable;VOID FAR PASCAL (*pfn)(WORD, WORD, DWORD);
Hooks (fEnable is true) or unhooks (fEnable is false) a keyboard message procedure, specified by pfn.  When keyboard messages are hooked, the driver calls the user specified procedure at every key event rather than sending a message to a window.  The keyboard message procedure can call InsertKeyboardMessage to pass the message on.
.c.::3.3.3 HookKeyboardPoll
VOID.i.SetShiftKk();HookKeyboardPoll(fEnable, pfn)BOOL fEnable;LPFN pfn;
Hooks (fEnable is true) or unhooks (fEnable is false) a key poll procedure (specified by pfn).  This procedure is called instead of the driver every time the application performs a PollKeyboard call.  InsertKeyboardMessage may be called to insert messages into the keyboard message stream.  PollKeyboard should not be called from a key poll procedure, since this would simply result in recursion.
.c.4. Screen Modes
Different screen drivers support different screen modes.  A given driver can support different screen modes depending on what hardware is available.  For example the general purpose IBM driver will work for CGAs as well as VGAs.  The driver will support many high resolution modes, only a few of them are available on a system equipped with a CGA.
The application is responsible for querying the available screen modes, and deciding (depending on the current mode, available modes, command line switches or .INI values) which mode it wants to start up in.  The application must then allocate space for that screen buffers and initialize the desired mode.
When running the screen mode may be changed by the application (freeing old buffers and allocating new ones for the new mode).
If the application wishes to save the old screen contents before starting (or re-starting) the CW application, it should perform the screen saving operations before changing to the new mode.
.c.:4.1 Querying Mode
The FQueryInst call returns information about the modes supported by the current driver.  The INST structure is used to contain information about specified modes.  The ImodeGuessCurrent() function returns the current mode of the screen.
.c.::4.1.1 ImodeGuessCurrent
WORD ImodeGuessCurrent()
Return the guess of what the current mode is.  This may fail (usually because the screen is currently in a mode that the driver does not support), in which case it will return imodeUnknown.  If the mode is unknown, it is probably best to start in the lowest IMODE that is available.  Due to the complexity of guessing the mode on some hardware, this function may return imodeUnknown after a successful FInitScreen call.
.c.::4.1.2 Ordering of IMODEs
IMODEs are ordered from simple to complicated.  Therefore the lowest IMODE available is usually the simplest mode, and the highest IMODE available is usually the most complicated.
When initializing from an unknown state (if ImodeGuessCurrent() returns imodeUnknown or that mode is not available), the best procedure is to call FQueryInst until the first available mode is found (incrementing the IMODE as you go).  If FQueryInst returns FALSE before an available mode is found, you are screwed.  This occurs if the driver is installed on the wrong hardware.  The safest thing to do in this event is to exit the program printing a message at the DOS prompt.
.c.::4.1.3 FQueryInst
BOOL FQueryInst(pinst, imode)INST *	pinst;WORD	imode;
Fill *pinst with information about the specified mode.  imode is the mode index (starting from 0).  Return TRUE (!= 0) if *pinst filled, FALSE (== 0) if imode is too high.
.c.::4.1.4 INST
The INST type is used to specify the installation options possible.  The main program queries the driver and the driver fills in the INST structure for the modes that are available.  The application should never directly modify the fields of the INST structure.
Fields of the INST structure:
imode	Imode of this mode.
finst	Flags for mode (see below).
axMac	Screen width in characters.
ayMac	Screen height in characters.
coMac, covMac, coiMac	Color information (for color palette, see below).
ffontSupported	Flag describing the font capabilities of the mode.  The value is an OR of the ffont values below.  ffontOrUnderlineSupport indicates that ffontOrUnderline is available.  This special check is necessary because ffontOrUnderline is the OR of ffontUnderline and ffontDoubleUnderline. 
inft	Current font info (see below).
Buffer information (not normally examined by application):
psPrim	(WORD) segment address of primary buffer.  If 0 then buffer must be allocated.
psSec	(WORD) segment address of secondary buffer.  If 0  then buffer must be allocated (if needed).
cwExtra	(WORD) # of extra words needed by driver.
psExtra	(WORD) segment address to driver extra data.   If 0 then buffer must be allocated (if cwExtra != 0).
wDriver1 ... wDriver3 (4 words) Driver specific use.

The finst field contains the following flags (OR'd together):
finstText	Screen mode is text mode
finstGraphics	Screen mode is graphics mode
finstMonochrome	Monochrome mode (different color values are different levels of grey-scale).
finstAlternate	Alternate display adapter (for 2nd screen).
finstFont	Supports multiple fonts + attributes (needs secondary buffer, see below).
finstAttrFont	Supports fonts, but by translating them to attributes.  Used in monochrome text modes only.
finstExtendedMono	Screen mode is monochrome text mode, with an EGA or VGA board.  This allows the use of one more attribute combination (hi-white on lo-white) that's not supported by the MDA.
finstDisableMouse	The mouse will be disabled in this mode.
finstFastScroll	Supports fast BltArc for graphics mode.
finstQuestionable	The mode is questionable (i.e. may not work).
finstAvailable	The mode is available on the current hardware.
Only modes with the finstAvailable attribute should be attempted.
The inft field for the INST mode is an INFT structure described below.  For text modes (finstText) the fields of the INFT structure may be 0 (indicating unknown, in particular dxChar and dyChar).  For graphics modes (finstGraphics) the dxChar and dyChar values must be known (the base line position or far pointers to fonts may still be 0).
.c.:4.2 Allocating Screen Buffers
.c.::4.2.1 FAllocInstBuffers
BOOL FAllocInstBuffers(pinst, pfnAlloc, fFonts)INST *	pinst;FARPROC	pfnAlloc;BOOL		fFonts;
Allocate the memory needed for the specified screen mode.  Return TRUE (!=0) if successful, FALSE if insufficient memory.
pinst is a near pointer to an INST structure that contains a mode from FQueryInst without buffers being allocated.  If FAllocInstBuffers succeeds then *pinst will have its buffer section allocated.
pfnAlloc is a pointer to an application supplied driver allocation function (LpwAllocDriverMem, see above).
fFonts specifies that the secondary buffer is desired (allows use of the FFONT feature (drawing on graphical screens with different font attributes, see below).
NOTE: if FAllocInstBuffers() fails to allocate sufficient memory, FreeInstBuffers() should be called to free up any partially allocated data.
.c.::4.2.2 FreeInstBuffers
VOID FreeInstBuffers(pinst, pfnFree)INST *	pinst;FARPROC	pfnFree;
Free the memory allocated for the specified mode.
pinst is a near pointer to an INST structure that contains a mode from FQueryInst and successfully allocated buffers with FAllocInstBuffers.
pfnFree is a pointer to an application supplied driver memory free function (FreeDriverMem, see above).
.c.:4.3 Setting Video Modes
After querying all available modes (with FQueryInst) and allocating buffers (with FAllocInstBuffers), the mode can be set with FInitScreen.  The availability of the FFONT feature can be detected after the init call with the global fFontAvailable.
.c.::4.3.1 FInitScreen
BOOL FInitScreen(pinst)INST *	pinst;
Initialize the specified mode.  Return TRUE (!= 0) if success.
.c.::4.3.2 fFontAvailable
BOOL fFontAvailable;
Set (!=0) if the FFONT feature is available in the currently initialized mode.  This flag will be set after a call to FInitScreen for a graphic screen mode (finst & finstGraphics) which has the secondary buffer allocated (FAllocInstBuffers(,,TRUE)).
.c.:4.3.3 SetCursorBlock
VOID SetCursorBlock(fBlock)BOOL	fBlock;
The cursor is set to a block cursor if fBlock is TRUE (!=0), otherwise the cursor is set to an underline cursor.
4.4 Ending Screen Access
The EndScreen call should be called after all screen I/O is finished by the application.
VOID EndScreen(fClearScreen)BOOL fClearScreen;
End the use of the screen in current mode.  The CSD driver will be called to terminate.  The screen will be cleared (filled with spaces) if fClearScreen is true.  The buffers allocated for this mode by FAllocInstBuffers can now be freed (by calling FreeInstBuffers).
.c.5. Font Display - FFONT
Display of different fonts is supported by some drivers in some modes (graphics modes).  The finstFont flag indicates that the option is available.  The fFonts flag to FAllocInstBuffers() determines whether you want the feature or not.  If enabled (i.e. (finst & finstFont) != 0 and you pass TRUE to FAllocInstBuffers()) then the extra font drawing capabilities are enabled.  When the FFONT feature is available, the global flag fFontAvailable is set.
The SetIsaFfont() CW API call can set the font attributes (ffont) for a given ISA.  When drawing with that ISA, the attribute will be applied to the character drawn.
Valid values for ffont are:
ffontUnderline	Draw character with a single underline.
ffontDoubleUnderline	Draw character with a double underline.
ffontOrUnderline	Draw character with a single broken underline.
ffontStrikeThrough	Draw character with a strike-through mark.
ffontBold	Draw character in bold face.
ffontSubscript	Draw character as a subscript.
ffontSuperscript	Draw character as a superscript.
ffontItalic	Draw character in italics.
ffontOrCharacter	Draw character with another special character super-imposed on top of it.
ffontGridUnderline,ffontVertline	Draw character with under-horizontal or(and) left-vertical grid lines (for Kanji AX machine only).
.c.:5.1 OR Character mode
The ffontOrCharacter mode is special in that it uses the 4 bits in ffontExtraMask (the upper 4 bits of the FFONT word) to encode one of 16 special drawing options.
The values that are currently defined are:
0	OR in a normal vertical line on top of the character.
1	OR in a bold vertical line on top of the character.
2..15	reserved.
.c.6. Misc Screen Features
.c.:6.1 Color Palette
The coMac, covMac and coiMac fields in the INST structure are used to set the color palette of the current screen mode.  There are three combinations of these variables specifying three different kinds of color palettes:
covMac == 0	No color palette (can not be gotten or changed).
covMac != 0, coiMac == 0	Simple color palette (EGA), covMac = maximum number of color combinations.
covMac !=0, coiMac != 0	RGB color palette (VGA).  coiMac = maximum intensity value for a given primary color (i.e. 6 bits => coiMac == 64 for the VGA).
In all cases coMac is the number of distinct colors that can be shown on the screen at a time (usually 2 or 16).
covMac is the number of fixed color combinations.
coiMac is the number of intensities for RGB palettes (# color combinations = coiMac ** 3).
.c.::6.1.1 FGetColorPalette
BOOLFGetColorPalette(co, pcov, rgcoi)WORD	co;WORD *	pcov;WORD	*	rgcoi;
Get the current palette setting for color co ( 0 <= co < coMac).
Return FALSE if no color palette available.
For a simple color palette, return in *pcov the color combination index ( 0 <= *pcov < covMac).
For an RGB color palette, return in *rgcoi the color values as follows (note values are 16 bit WORDs):
	rgcoi[0] = red value	rgcoi[1] = green value	rgcoi[2] = blue value
.c.::6.1.2 SetColorPalette
VOIDSetColorPalette(co, cov, rgcoi)WORD	co;WORD	cov;WORD	*	rgcoi;
Set the current palette color co ( 0 <= co < coMac) to value specified.
If no color palette available, do nothing.
For a simple color palette, pcoi == NULL.  Set to color combination cov ( 0 <= cov < covMac).
For an RGB color palette (pcoi != NULL), set to color in *rgcoi interpreted as follows (note values are 16 bit WORDs):
	rgcoi[0] = red value	rgcoi[1] = green value	rgcoi[2] = blue value
.c.:6.2 Getting Font Info
The CSD driver can also serve as the interface to any fonts that the system has lying around (or that the driver has loaded).  The INFT structure contains information about the font.  This information is available for the current screen mode in the INFT structure contained in the INST structure.
Additional available fonts (regardless of the current mode) may be queried with the FQueryInft() function.
.c.::6.2.1 INFT Structure
The INFT structure contains the information about a font.  The following fields are available:
dxChar	The width of a character in pixels (usually 8 or 9).
dyChar	The height of a character in pixels.
dyBaseLine	The base line for the character.  The number of pixels from the top of the character to the base line.
The format of a font is defined as an array of bytes, one per scan line that form the character.  If the system supplied font is not available in that format or does not exist, then the far pointers should be NULL (i.e. 0).
The dyBaseLine field is optional.  A value of 0 is used to indicate the value is unknown.
.c.::6.2.2 FQueryInft
BOOL FQueryInft(pinft, ifont)INFT *	pinft;WORD	ifont;
Get the font information.  Returns FALSE if no more fonts.  pinft is a near pointer where to place the font information.  ifont is an index to the requested font (start at 0, increment by 1 until the FQueryInft() call fails).
.c.:6.2.3 GetCharMap
VOID GetCharMap(pinft, ch, pbitmap)INFT	*	pinft;char	ch;BYTE	*	pbitmap;
Get the bitmap for the given character.  GetCharMap assumes that enough space has been allocated for pbitmap.  The required amount is the ceiling of (dxChar * dyChar) / 8, i.e. the next highest integer value.
6.3 Using safe screen character - INCH
The INCH type defines characters that are safe for output in the current screen mode.  There is one instance of this structure called inch.  The header defines the following globals as fields in the global structure inch.
chTopLeftCorner1	Top left corner of single line box.
chTopRightCorner1	Top right corner of single line box.
chBottomLeftCorner1	Bottom left corner of single line box.
chBottomRightCorner1	Bottom right corner of single line box.
chTopSide1		Top side of single line box.
chBottomSide1		Bottom side of single line box.
chLeftSide1		Left side of single line box.
chRightSide1		Right side of single line box.
chMiddleLeft1		Left side meeting middle of single line box.
chMiddleRight1		Right side meeting middle of single line box.

chTopLeftCorner2	Top left corner of double line box.
chTopRightCorner2	Top right corner of double line box.
chBottomLeftCorner2	Bottom left corner of double line box.
chBottomRightCorner2	Bottom right corner of double line box.
chTopSide2		Top side of double line box.
chBottomSide2		Bottom side of double line box.
chLeftSide2		Left side of double line box.
chRightSide2		Right side of double line box.

chUpArrow		Up arrow.  For scroll bars.
chDownArrow		Down arrow.  For scroll bars.
chLeftArrow		Left arrow.  For scroll bars.
chRightArrow		Right arrow.  For scroll bars.
chBullet		Bullet (circle in middle of character).  For checked menu items.
chMiddleDot		Small dot in middle of character.  For edit items.
chScrollbar		Character for the scroll bar (a hash character).
chElevator		Character for the elevator in a scroll bar.
chShadowInit		Initial shadow background character.
?????? characters that follow may change ????
chClose		Close icon character.
chZoomIn		Zoom in character.
chZoomOut		Zoom out character.
chUpDownArrow		Up and Down arrow.
chLeftRightArrow	Left and Right arrow.
.c.7. Screen Saving
The following routines allow for saving the screen contents to do a screen swap.  The interface is designed so that the driver need only save the minimum data necessary.
.c.:7.1 Saving Screen
The screen saving option is currently available only for switching into a text only screen (i.e. the *pinstNew passed to FSaveVids() must have (finst & finstText) set).
.c.::7.1.1 VIDS - Video Save State
The VIDS structure contains the commonly accessed portion of the video save state.  The only field that should be interpreted by the application is the cwVidData field.  Fields include:
mode	The BIOS screen mode.
page	The screen page #.
fvids	Informative flags about saved state.
cwVidData	# of words of screen data that must be saved.
cwExtra	# of extra words for mode info.
rgwExtra	array of extra words for mode info.
The fvids field is a ORing of the following possible states:
fvidsChAttr	The far saved buffer is a text buffer in the format of character, attribute (IBM standard).
.c.::7.1.2 CbSizeVids
WORD CbSizeVids()
Return the size (in bytes) that the VIDS structure must be.  Use this to allocate a buffer before calling FSaveVids().
This size is guaranteed to be less than 1024 bytes.
.c.::7.1.3 FSaveVids
BOOL FSaveVids(pvids, pinstNew)VIDS *	pvids;INST *	pinstNew;
Fill *pvids with information about the current mode and how much data must be saved.  Return TRUE (!=0) if successful.
pinstNew is an INST structure (from FQueryInst()) that specifies the mode we are going to go into.
This saves all mode, cursor and palette information (everything except the screen image -- the RGEN buffer).
.c.::7.1.4 SaveVidData
VOID SaveVidData(pvids, lpw)VIDS *		pvids;WORD FAR *	lpw;
Save video data (RGEN buffer).  *pvids must be filled by a previous successful FSaveVids call.  lpw is a far pointer to a buffer of at least pvids->cwVidData words in size.
.c.:7.2 Restoring Screen
.c.::7.2.1 FRestoreVids
BOOL FRestoreVids(pvids)VIDS *	pvids;
Restore video mode information from a previous FSaveVids() call.  *pvids is filled with mode information.  Return TRUE (!=0) if successful.
This restores all mode, cursor and palette information (everything except the screen image -- the RGEN buffer).
.c.::7.2.2 RestoreVidData
VOID RestoreVidData(pvids, lpw)VIDS *		pvids;WORD FAR *	lpw;
Restore video data (RGEN buffer).  *pvids must be filled by a previous successful FSaveVids call, and FRestoreVids() must be called.  lpw is a far pointer to a buffer that was saved by a previous SaveVidData call or NULL.
If lpw is null then the screen is restored to blank (for those cases where there is insufficient memory to save the entire screen).
.c.::7.2.3 EnableVidsMonitor
VOID EnableVidsMonitor(fEnable)BOOL	fEnable;
Enable (if fEnable != 0) or disable (if fEnable == 0) the monitor on the target screen to trap screen accesses.  This is used on the EGA to hook INT 10H calls to change the palette registers.
The application should call EnableVidsMonitor with fEnable == TRUE before executing any non-CW code that can change the screen, and call EnableVidsMonitor with fEnable == FALSE when returning to the CW application.
Document Revision History
Apr xx / 88 (<2.22)Evolution of driver interface.
Apr 29 / 88 (2.22)First stable version.
May 2 / 88 (2.22.02) [SAR]modified INSTfFontAvailableSave going into text mode only.Max size of VIDS is 1K now.
Jan 03 / 89 (2.22.??) [KAG]changed LpwAllocDriverMem(cw) from 64 bytes to 128 bytes.
Jan 17 /89 [MRD]Added FIXED restriction to UpdateShiftKk (called by PeekMessage during LszPromptSwapDisk).
Table Of Contents
.Begin Table C.
1. Introduction	1
2. Loading Drivers	1
2.1 Application Supplied Memory Allocation	1
2.1.1 LpwAllocDriverMem	1
2.1.2 FreeDriverMem	2
2.2 Loading Standard CW Drivers	2
2.2.1 RerrLoadCwDrv	2
2.3 Loading Extra Driver Services	3
2.3.1 INDV	3
2.3.2 RerrLoadDrv	3
2.4 Freeing Services	3
3.1 General Control	4
3.1.1 DisableExtendedKeyboard	4
3.1.2 EnableKeyboard	4
3.1.3 PollKeyoard	4
3.2 Shift States	4
3.2.1 UpdateShiftKk	4
3.2.2 SynthesizeShiftKeys	5
3.2.3 SetShiftKk	5
3.3 Key Event Hooking	5
3.3.1 InsertKeyboardMessage	5
3.3.2 HookKeyboardMessage	5
3.3.3 HookKeyboardPoll	6
4. Screen Modes	6
4.1 Querying Mode	6
4.1.1 ImodeGuessCurrent	6
4.1.2 Ordering of IMODEs	6
4.1.3 FQueryInst	7
4.1.4 INST	7
4.2 Allocating Screen Buffers	8
4.2.1 FAllocInstBuffers	8
4.2.2 FreeInstBuffers	9
4.3 Setting Video Modes	9
4.3.1 FInitScreen	9
4.3.2 fFontAvailable	9
4.3.3 SetCursorBlock	9
5. Font Display - FFONT	10
5.1 OR Character mode	10
6. Misc Screen Features	11
6.1 Color Palette	11
6.1.1 FGetColorPalette	11
6.1.2 SetColorPalette	11
6.2 Getting Font Info	12
6.2.1 INFT Structure	12
6.2.2 FQueryInft	12
6.2.3 GetCharMap	12
7. Screen Saving	14
7.1 Saving Screen	14
7.1.1 VIDS - Video Save State	14
7.1.2 CbSizeVids	15
7.1.3 FSaveVids	15
7.1.4 SaveVidData	15
7.2 Restoring Screen	15
7.2.1 FRestoreVids	15
7.2.2 RestoreVidData	15
7.2.3 EnableVidsMonitor	16
.End Table C.
.Begin Index.
DisableExtendedKeyboard()  4
EnableKeyboard()  4
PollKeyboard()  4
SetShiftKk()  5, 6
SynthesizeShiftKeys  5
UpdateShiftKk  4
.End Index.
                                                                      v       q      m   h !  $  f Y  ^  d     b     ` T  			 @@ @ @ @T  Y  y }    w     u     s @  D  q     o     m     k 
  
  i 			
  
  
  y 
    w 
    u     s     q D  J  o     m     k +  				+  :  y c  q  w r    u     s   $  q &  6  o c  e  m i  k     i   		    y     w     u C  G  s     q     o     m     k T  _  i 		_      y     w 2  =  u u  }  s     q     o   &  m ?  J  k S  	S  ^  y     w     u     s     q     o     m     k ]  e  i 		e      y %  0  w G  N  u     s     q     o     m     k   i 					  E  S  y     w     u   s Y  g  q     o     m     k      i 			   #  (  y @  R  w ^  u     s     q O  \  o     m   k     i 1  						1  6  y     w     u     s     q     o     m     k   )  i 	)      y     w   $  u 7  s     q \  a  o x    m   k     i    						      y )   9   w       u       s 
!  !  q E!  H!  o !  !  m !  !  k $"  +"  i 					+"  A"  H"  y ~"  "  w <#  Q#  u k#  p#  s #  #  q #  #  o #   $  m .$  1$  k $  			$  $  y $  $  w $  %  u c%  f%  s H)  L)  q c)  m)  o )  )  m *  *  k M*  R*  i 				R*  p*  *  y 5+  A+  w +  ,  u ,  ",  s *,  /,  q *-  ;-  o F-  R-  m -  -  k -  			-  -  y .  .  w .  /  u 2/  7/  s d/  i/  q /  /  o /  /  m /  /  k 1  1  i 			1  +1  01  y N1  S1  w q1  v1  u 1  1  s 1  1  q 1  1  o 1  1  m P2  g2  k w2  	w2  2  y 2  2  w 2  2  u 2  3  s 3  3  q i3  p3  o 3  3  m %4  ,4  k X4  `4  i 	`4  4  4  y 4  4  w 4  4  u 5  5  s =5  F5  q a5  n5  o 5  5  m 5  5  k '6  	'6  06  y |6  6  w 6  6  u 7  7  s 7  7  q 8  .8  o ^8  m8  m 8  8  k 8  8  i 	8  89  A9  y 9  9  w 9  9  u 9  9  s 9  9  q 9  9  o 6:  ::  m Y:  ^:  k |:  			|:  :  y Q;  V;  w ;  ;  u ;  ;  s ;  ;  q <  !<  o e<  v<  m <  <  k 0=  A=  i 	A=  i=  x=  y =  =  w =  =  u J>  O>  s >  >  q >  >  o >  >  m %?  2?  k A?  		A?  E?  y ?  ?  w ?  ?  u ?  ?  s E@  S@  q V@  [@  o s@  ~@  m @  @  k @  A  i 				A  |A  A  y A  A  w A  A  u A  A  s B  B  q B  .B  o B  B  m /C  9C  k &D  		&D  7D  y UD  dD  w hD  kD  u D  D  s E  #E  q E  E  o E  E  m 1F  ?F  k MF  XF  i 		XF  F  F  y G  G  w G  G  u EG  YG  s G  G  q G  G  o H  H  m +H  9H  k ZH  	ZH  jH  y H  H  w H  H  u I  I  s 1I  o I  I  m I  I  k I  J  i K  K  g K  		 BK  #K  y :K  ?K  w AK  GK  u LK  RK  s aK  eK  q L  L  o RL  XL  m _L  fL  k L  L  i 		L  L  L  y L  L  w L  L  u 4M  ;M  s ]M  bM  q M  M  o M  M  m BN  HN  k QN  	QN  VN  y sN  N  w N  N  u N  N  s N  N  q PO  TO  o yO  }O  m O  O  k O  O  i 		O  O  O  y 	P  P  w !P  &P  u 8P  =P  s YP  hP  q P  P  o P  P  m P  P  k ,Q  		,Q  0Q  y TQ  WQ  w _Q  bQ  u eQ  kQ  s Q  Q  q Q  Q  o Q  Q  m Q  R  k R  R  i 	R  -R  1R  y R  R  w AS  ES  u aS  eS  s S  S  q S  S  o S  T  m YT  _T  k T  			T  T  y T  T  w V  %V  u rV  wV  s V  V  q V  W  o <W  AW  m W  W  k W  W  i 			W  W  W  y Y  Y  w Y  Y  u Y  Y  q Z  'Z  m NZ  aZ  i Z  Z  e Z  Z  a  B B B B BZ  Z  Z  w "[  -[  s N[  Z[  o |[  [  k [  [  g [  
\  c 0\  A\  _ h\  Z  a B B B B B B Bh\  {\  w \  \  s \  \  o ]  ]  k <]  G]  g h]  t]  c ]  ]  _ ]  ]  [  B B B B B B B B]  ]  ]  w ^  $^  s F^  N^  o ^  ^  k ^  ^  g _  _  c K_  W_  _ _   B B B B B B B B_  _  w _  _  s _  _  o `  `  k /`  ?`  g W`  Z`  e a  a  c a  a  a a   		 B B B B Ba  a  y a  a  w a  a  u a  a  s  b  b  q b  b  o b  b  m b  b  k b  b  i 	 	b  c  "c  y Qc  Xc  w zc  c  u c  c  s c  c  q Od  Td  o kd  ud  m d  d  k d  	 	d  d  y &e  +e  w Ae  Je  u e  e  s e  e  q f  "f  o f  f  m f  f  k <g  Ag  i 	 		Ag  jg  sg  y {g  ~g  w g  g  u g  g  s g  g  q g  g  o h  h  m Sh  \h  k gh  	 		gh  lh  y "i  'i  w Bi  Pi  u i  i  s i  i  q i  i  o j  j  m Aj  Lj  k _j  bj  i 	 	bj  j  j  y k  k  w 9k  @k  u Vk  ^k  s l  l  q "l  )l  o xl  l  m l  l  k n  	 	n  n  v t  "t  q #t  2t  l t  t  g ^k  s l  l  q "l  )l  o xl  l  m l  l  k n  	 @ @ @ @      Y    Y    7    5 !  3 5  . t  g ^k   A?!H $                   p `'!H $                    `'5    v {  v   v   q   l   l   l   g T  b r  ]   X   S   S   p= W  =  =  =     v ?	  v r	  v 
  q 
  q 
  l 
  g 
  b /  ]   X   S   N   S W  =  = W  = U     v   v   q -  q e  q   q (  q e  q   l F  g   g   b '  ]   ]  = =  =  U =     v T  v   v   v u  q   l   l   g   b P  ]   X   X   S   ] = W  = U = U   3  v B  q z  l   g :  g M  b   ]   X   S "  N   I   X = W   =  = W  =     v   q #  l ;  g b  b   ]   X   S   N   I   D = W =   = W  = W    ,  v }  q   q   l Z  g \  b s  ]   X   S    N $   I =   = W  = W  = E $      v !  q !  l "  g k#  b #  ] #  X c%  S w%  N &  I (  I (  I =  = W  = W  = W (  H)  v _)  q M*  l k*  g *  b *,  ] I,  X ,  S .  S .  N ,/  I (  I W  =  = W  =  = ,/  /  v /  q 0  l 1  l +1  g N1  g q1  g 1  g 1  g 3  g -3  g i3  b 3  ] %4  ] X4  ]  U = U =  = X4  4  v 4  v 4  v =5  q a5  l 5  l 5  l '6  l |6  l 6  l 7  l 7  l 8  l ^8  l 8  l 8  g 6:  g = U = U 6:  Y:  v w:  q :  l Q;  g <  g <  g '=  g =  g =  b >  ] J>  X >  X A?  X ^8  l 8  = W  = W   A?  ^?  v V@  q n@  l @  g @  b @  ] A  X B  S B  N EB  I B  D >= W  = W  = W  =  B  B  v +C  q \C  l hD  g D  b IF  ] F  ] G  ] EG  X G  X G  X H  X +H  X ZH  X = U =  = W =  ZH  H  v H  v I  v I  v I  q VJ  l J  l J  g J  g K  g K  b 6K  ] L  X ZH  X = =   U =  U L  RL  v L  v PM  v M  q M  q QN  q nN  l N  g N  b )O  b O  b O  b 8P  ] TP  X =  W = W  = U TP  P  v P  q Q  q oQ  q Q  q -R  l HR  g rS  b S  b S  ] YT  X T  S T  S TP  XU =  =  W = W T  6U  v V  q rV  q V  l V  g W  b W  ] X  X X  S Y  N Y  I T  S =  = W  = W  = U Y  Z  v NZ  v Z  v Z  v Z  v "[  v N[  v |[  v [  v [  v [  v 0\  v h\  v \  v \  v ]  v <]  v h]  v ]  v = U ]  ]  v ]  v ]  v ^  v F^  v ^  v ^  v _  v K_  v _  v _  v _  v _  v `  v /`  v W`  v l`  q a  l =  U a  .a  v a  q a  l b  g b  b b  b c  b Qc  b zc  b c  b c  ] Od  X fd  S `  v U = U =  =  fd  yd  v d  q &e  q <e  l |e  g e  b Xf  b f  b f  ] g  X g  S g  N fd  S  = W  = W  = U g  g  v $h  q h  l "i  l =i  g }i  b \j  ] j  ] j  X .k  S k  N l  N fd  S = W  = W  = W  l  l  v m  q Am  q m  q n  q zn  q n  l n  n  R n  R k  N l  N fd  S =                 !? U ? 
n  n  a o  G (o  G Ko  - n  q zn  q n  l n                 !      	           !                !Ko  bo  a o  G o  - o  - n  q zn  q n  l n       	           !                !      	           !o  o  a o  G o  - p  - 'p  - zn  q n  l n       	           !                !                !'p  ;p  a Rp  G op  G p  G p  - zn  q n  l n                 !      	           !                !p  p  a p  a p  a q  G q  - zn  q n  l n                 !                !      	           !q  5q  a Qq  a eq  a sq  a q  G q  - q  - n       	           !                !      	           !q  q  a q  G r  G (r  - q  G q  - q  - n                 !      	           !                !(r  Dr  a ^r  G zr  - (r  - q  G q  - q  - n                 !                !                !zr  r  a r  G r  G r  - q  G q  - q  - n                 !      	           !                !r  r  a s  a "s  G 7s  - q  G q  - q  - n                 !                !      	           !7s  Ms  a os  G s  G s  G s  G s  - q  - n                 !      	           !                !s  s  a s  a t  a "t  \ #t  2t  Pt  Q et  Q xt  Q t  Q t  Q t  Q t   	
     @=       	           !t  t  s  a t  a "t  \ #t  2t  Pt  Q et  Q xt  Q t  Q t  Q t  Q t   	
     @=       	           !!= -48$ ;                                                                     HPLASMS                        s      Dt          
jDMC# Manual Division          
kDIC# Index Division           
PPC# Paragraph                
        .         F   "   -   4  	 <  
 B   J   P   YX   ^   c   i   Hl   m   s           
         (       3/24/89 1/17/89 Ct  g                  
^H7C# Heading                  
)HMC# Manual Header
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cwkanji.doc ===
1             = N N P P P C:\EDITORS\C#.STY                                                   HPLASMS Q @ >qN N   O 		--	
	CW API Guide : Kanji / DBCS Extensions	
Character WindowsAPI Guide : Kanji / DBCS Extensions (2.20)
Scott RandellMicrosoft Applications Division
.c.1. Introduction
This appendix describes the extensions to CW for a Double-Byte-Character-Set (DBCS, for example Kanji).
There are also Kanji specific additions for accelerators.
.c.2. DBCS Extensions
.c.:2.1 The CHAR type
Where characters are passed to CW API routines, the CHAR type is used.  "CHAR" is normally "char" (i.e. single byte character) for non-DBCS.  For DBCS "CHAR" is a double byte character.  The first byte of the double byte character is in the LOW byte of the char (LOBYTE(x)), the second byte (if applicable) is in the HIGH byte.
.c.:2.2 Keyboard Input
The keyboard input mechanism will read double byte characters as two bytes (two WM_CHAR messages, the first WM_CHAR message will respond true to FIsDbcsChar(wParam)).  It is the application's resposibility to coalesce these into a single DBCS character if desired.
Also it is the application's responsibility to interface to any Kana-Kanji converters.
The same rules apply to the Edit Wnd Proc.
.c.:2.3 Strings
All CW function calls that take strings can optionally take DBCS characters in the string.  For example the TextOut call can output a DBCS string.
Dialog item names and menus can contains DBCS characters.
.c.:2.4 Changes to Standard CW API Calls
.c.::2.4.1 TextOut
TextOut is the same for DBCS.  A point of note that the length passed to TextOut is the length of the string in bytes (this is strlen length as opposed to the length returned by CchLenDbcs).
.c.::2.4.2 CharOut / FillRrc
The CharOut and FillRrc routines take an optional DBCS character for their character parameter (i.e. a CHAR).  For CharOut this means that it could output two 2 screen columns.  For FillRrc, filling is done with the double wide characters.
.c.::2.4.3 WARNING
It is the application's responsibility to make sure it does not draw over 1/2 of a double byte character.  CW automatically handles the case of drop-down menus and dialogs.
.c.:2.5 DBCS Helper Routines
.c.::2.5.1 FIsDbcsChar
BOOL FIsDbcsChar(ch)CHAR	ch;
Returns True (!= 0) if low byte of ch is first byte of Double character.  Using Microsoft's Kanji Encoding Scheme.
.c.::2.5.2 CchLenDbcs
WORD CchLenDbcs(sz)char *	sz;
Returns the number of real characters in a DBCS string (the string sz must be zero terminated).  This will be less than or equal to the real length of the string (strlen(sz)).
.c.::2.5.3 PchNextDbcs
char * PchNextDbcs(sz)char *	sz;
Returns the next character from a zero terminated DBCS string.  This will skip 0 bytes if pointing to the terminating zero, 1 bytes if pointing to a single byte character, and 2 bytes if pointing to a double byte character.
.c.::2.5.4 PchPrevDbcs
char * PchNextDbcs(pch, szMin)char *	pch;char *	szMin;
Returns the previous character from a zero terminated DBCS string.  pch is the current position in the string.  szMin is the start of the string.  This will skip 0 bytes if pointing to the starting character (i.e. pch == szMin), or 1 or 2 bytes if the character before pch is a single or double character.
.c.:2.6 Warning about 1/2 characters
The application programmer is warned about the following problem:  it is illegal to output the first half or last half of a double byte character without the other half.
.c.3. Kanji Extensions
.c.:3.1 Accelerators
See the HELLO application for examples of Kana accelerators.
.c.::3.1.1 Dialog Accelerators
Dialog strings can contain Kana accelerators.  The format of dialog items with accelerators (as specified in DE) is:
~<R><K>/<text>
where:
~	is the tilde character.
<R>	is a single character Roman accelerator
<K>	is a single character Kana accelerator
/	is the slash that prefixes the real text
<text>	is the text of the item (may contain Roman, Kana or Kanji characters).
.c.::3.1.2 Menu Accelerators
Menu and menuitems can have Kana accelerators as well.
The MENU and MENUITEM structures have been modified to contain a single character Kana accelerator (along with the Roman accelerator and the rest of the text).
.c.::3.1.3 fKanaAccel
BOOL PASCAL fKanaAccel;
The global flag fKanaAccel is normally FALSE,  when turned on (!= 0) the Roman character accelerators will be replaced by the Kana equivalents.
The application must provide the user interface to toggle this flag.  After changing the flag RedisplayMenubar() should be called.
.c.:3.2 32-bits FFONT
Font attributes (ffont) for a given ISA is expanded to 32-bits:
VOID SetIsaFfont(isa,ffont)ISA isa;DWORD ffont;
The LOWORD has no change (see CWDRV.DOC, section 5). The HIWORD includes the following fields:
ffontGridType:2	indicates spreadsheet or word processor grid lines
ffontVgrid:4	Draw grid line at the left side of the character (spreadsheet)
ffontHgrid:4	Draw grid line on top of the character (spreadsheet)
ffontShadeType:2 	indicates normal, sparse or dense shade
ffontDoubleWidth:1 Draw character in double-widthed.
ffontDoubleHeight:1 Draw character in double-heighted. The character is expanded square double like when both bits are set.
ffontReserved:2	reserved for future.
.c.::3.1.2 Grid Lines Support
When ffontGridType is 0, it indicates to write for spreadsheet. ffontVgrid and ffontHgrid specify one of the following line patterns:
0	normal solid1	bold solid2	sparse dotted3	dense dotted 4	dashed 5	dot-dashed6	dot-dashed-dotted7	double solid8	bold dashed
When ffontGridType is 1, it indicates to write for word processor. ffontHgrid specifies one of the line patterns (see above) and ffontVgrid specifies one of the following box drawing grid lines:
0	top left corner1	top right corner2	bottom left corner3	bottom right corner4	top(bottom) side5	left(right) side6	left side meeting middle7	right side meeting middle8	top side meeting middle9	bottom side meeting middel10	cross

Table Of Contents
.Begin Table C.
1. Introduction	1
2. DBCS Extensions	1
2.1 The CHAR type	1
2.2 Keyboard Input	1
2.3 Strings	1
2.4 Changes to Standard CW API Calls	2
2.4.1 TextOut	2
2.4.2 CharOut / FillRrc	2
2.4.3 WARNING	2
2.5 DBCS Helper Routines	2
2.5.1 FIsDbcsChar	2
2.5.2 CchLenDbcs	2
2.5.3 PchNextDbcs	2
2.5.4 PchPrevDbcs	2
2.6 Warning about 1/2 characters	3
3. Kanji Extensions	3
3.1 Accelerators	3
3.1.1 Dialog Accelerators	3
3.1.2 Menu Accelerators	3
3.1.3 fKanaAccel	3
3.2 32-bits FFONT	3
3.2.1 Grid Lines Support	3
.End Table C.
܀         v       q   !  m "  h $  '  f     d     b S  W  `   				 @@ @ @ @    y v  }  w     u     s     q     o     m     k      i 					       y     w     u     s     q  	  "	  o q	  v	  m 	  	  k 	  						  	  y K
  Q
  w R
  T
  u Y
  ^
  s x
  
  q u  z  o     m     k 7  <  i 			<      y     w     u     s     q 7  <  o     m .  2  k 7  						7  ?  y     w     u     s     q     o 8  =  m m  x  k     i 			  ?  I  y     w     u     s 
  o   k @  Q  i     g     e   i	 B @      w   u B  q L  o Q  k [  i   e    c Q  _ [  ]   Y   W   g   @ @ @ @ @ @    w     r     m Q  k [  i   e    c Q  _ [  ]   Y   W   g   @ @ @  @ @ @      Y    7    5 $  3               I         A?!H $                   p `'!H $                    `'$  8  v   q   q   l 
  g S  b k  ]   I   I   I   I   I   I   I  `'!H $ =   =  k  u  v   v   v 
  q   l   l   g   b   I   I   I   I   I   I   I   I   =  =     v   q   l   g   b   ]   X   I   I   I   I   I   I   I   I  =  =  =     v q	  q 	  l 	  g Y
  b q
  ] 
  X   I   I   I   I   I   I   I   IW  = W  = W 
  u  v   q   l   g    b   ]   X   I   I   I   I   I   I   I   I =  = W  =     v 7  q W  l   g   g   g    b -  b   I   I   I   I   I   I   I   I U =  =  -  Y  v   v   v   q *  l   l   g   b   I   I   I   I   I   I   I   I W  =  U     v   f '  a h  \   W   R   I   I   I   I   I   I   I   I= W =  <        =   ?  v   v   v 
  v @  v   v   v   q   l   I   I   I   I   I   I   I             =  U 	    v   q   l   \   W                       I               I   I   ? Y      W = W     a   a %  G ;  G J  G   I   I   I   I   I                            !                !J  r  a   G   G   G   I   I   I   I   I   I                  	           !                !    a   G   G 	  G   G   I   I   I   I   I                  	           !                !  B  a Y  G m  -   I   I   I   I                   !                !                !m    a   a   a   G   I   I   I   I               !                !      	           !    a   \     I               I   I               !              =       	           ! 
     Y  z    C  y     >    &    3 	                  y     +  ) - . / 0 8 @ H Kanji Extensions to CW SAR    2.20.01 03/24/8901/27/88y  
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cwgraph.doc ===
1           ?Q        C:\EDITORS\C#.STY                                                   HPLASMS                      
		--	
	CW API Guide : Graphical Drawing	
Character WindowsAPI Guide : Graphical Drawing (2.22.03)
Scott RandellMicrosoft Applications Division
.c.1. Introduction
This appendix describes the graphic drawing primatives supported by Character Windows.  The actually drawing functionality is very tied to the GSD and GPD installable screen drivers (see the DRVGSD document for more info).
The CW header CGRAPHIC.H (and toolbox file CGRAPHIC.TXT) provide the structure definition and function prototypes for the graphic drawing routines.
Character Windows supports four levels of screen support:
Text modejust textscreen in text modeblock mouse cursorlimited to standard character set
Graphics mode, fonts disabled (pretty useless mode)just textscreen in graphics modegraphical mouse cursorlimited to standard character set
Graphics mode, fonts enabledjust textscreen in graphics modegraphical mouse cursorstandard character set + font attributes (FFONT, italics, bold, ...).
Graphics mode, fonts enabled, graphic drawingtext and graphicsscreen in graphics modegraphical mouse cursorstandard character set + font attributes (FFONT, italics, bold, ...)arbitrary drawing on the screen (pixel based).
The extra CW API calls provided with the last option (graphical drawing) are the topic of this appendix.
.c.2. Initialization - Screen or Printer
The graphical drawing functionality is available to the display screen, as well as to an external printer/plotter.  The API is almost identical between the two varieties -- differing only in the initialization and the behavior of some of the primatives (selecting pen colors for example).
.c.:2.1 Loading Drivers
.c.::2.1.1 FLoadGsd
BOOL FLoadGsd(szFile)char *	szFile;
Attempt to load GSD service from file specified.  szFile is the path/file name for the driver file (usually with extension .VID).
Returns !=0 if successful, or 0 (FALSE) if either a load error or the GSD service not found.
.c.::2.1.2 FLoadGpd
BOOL FLoadGpd(szFile)char *	szFile;
Attempt to load GPD service from file specified.  szFile is the path/file name for the driver file (usually with extension .PRD).
Returns !=0 if successful, or 0 (FALSE) if either a load error or the GPD service not found.
.c.:2.2 Initializing Modes
It is the application's responsibility for switching screen modes between text and graphics modes.  This switching is done via the CSD driver's FQueryInst() and FInitScreen() calls (see the document CWDRV.DOC for more details).
.c.::2.2.1 FInitGraphics for Screen
BOOL FInitGraphics(pinst, lpingd)INST *	pinst;INGD FAR *	lpingd;
Attempt to initialize the GSD driver (loaded with a previous FLoadGsd() call) with the current screen mode specified by *pinst (this will usually be &instCur -- the current screen mode).
Returns !=0 if successful (permitting graphical drawing onto the screen in the current screen mode) and will fill in *lpingd with the INGD structure for this mode.
Returns FALSE (0) if error, usually meaning that the driver does not support this mode (for example if the screen was in a text only mode).
.c.::2.2.2 FInitGraphics for Printer
API to be documented.
.c.::2.2.3 TermGraphics
VOID TermGraphics()
End the use of graphic drawing routines for the current mode and driver.  This will do any cleanup necessary.
A TermGraphics() call should be matched with a successful FInitGraphics() call.
.c.:2.3 Switch Screen/Printer Mode
VOID SetPrinting(fPrinting)BOOL	fPrinting;
Set the subsequent graphic drawing primatives to the printer (if fPrinting) or to the display adapter (if !fPrinting).  To enable printing, the GPD driver must be loaded (see FLoadGpd), to disable printing, the GSD driver must be loaded (see FLoadGsd).  The default drawing mode at initialization is to draw on the display (i.e. not printing).
This call has no effect on GSD or GPD driver interface, it just controls which driver gets called.
.c.::2.3.1 fPrinting
BOOL fPrinting;
Global variable (read only by the application).  Set (!=0) if currently in printing mode (graphic primatives go to printer), FALSE (==0) if not printing (graphic primatives go to screen).  The printing state 
.c.3. Data Structures
.c.:3.1 Terminology
This section contains definitions of several terms and conventions used in the graphic drawing interface.  The term "charting" refers to graphic drawing.
twip	Twentieth of a printer's point.  A printer's point is 1/72inches, so a twip is 1/1440 inches.  Twips are a device-independent unit of measure.
half-point	Half-point.  (See twip.) A half-point is 1/144inches.
RGB	Red-green-blue color system.  Any color can be defined as a quantity of red light, green light, and blue light.  For example, magenta is 100% red, 0% green, and 100% blue.  The applications represents RGB values in one 16-bit word, with the low 5 bits as the amount of blue, the next 5 bits as the amount of green, and the next 5 bits as the amount of red; the most significant bit is not used.  Thus the RGB value of red is 7C00 (hex), the RGB value of blue is 001F (hex), and the RGB value of magenta is 7C1F (hex).
coordinates	The graphics coordinate system has its origin at the top left of the chart.  The positive X axis points right; the positive Y axis points down.  The X direction is often called the horizontal direction and the Y direction the vertical direction.
rectangle	The top and left members of the graphics RECT structure define the top-left pixel of the rectangle; however, the bottom and right members are 1 more than the coordinates of the bottom-right pixel.  For example, a rectangle with top, left, bottom, and right coordinates of 0, 0, 2, 2 respectively would refer to the 4 pixels on the upper left corner of the display.
.c.:3.2 Drawing Structure
The following data structures are passed to the drawing routines as parameters.
.c.::3.2.1 GPOINT / GPT
A GPOINT (aka. GPT) is a graphical point, it has two fields:
x	X coordinate, in pixels.
y	Y coordinate, in pixels.
In the case of drawing to a printer, the coordinates are in some other unit.
NOTE: the order of fields for points and rectangles is consistent with CW and Windows.  It is not consistent with old format GSDs or old "MS-Chart" charting code.
.c.::3.2.2 RECT
A RECT is a rectangle, comprised of two end points with fields:
xLeft, yTop	Upper left point of rectangle.
xRight, yBottom	Lower right point of rectangle.
.c.::3.2.3 POLYGON
A POLYGON is a structure that represents many points that get drawn connected together.  It has the following fields:
cbPolygon	The total size of this POLYGON structure (in bytes).
rectBound	The bounding rectangle for the polygon.
rggpt	Array of GPTs (variable sized) containing the points for the vertices.
.c.::3.2.4 BITMAP
A BITMAP is a structure that represents a bitmap that gets drawn.  It has the following fields:
lrgb	Far pointer to array of bytes representing the bitmap.
cbRow	The number of bytes in a row.
rectBound	The bounding rectangle for the bitmap.
.c.:3.3 Driver Info Structure
.c.::3.3.1 INGD - Graphic Drawing Info
Note: formerly the DEV (or more accurately the VDEV) structure.
The INGD structure contains information about the current graphics mode of the output device.  This information is obtained by the FInitGraphics() procedure.
Fields of the INGD structure follow:
fingd	Graphic Device mode flags (see below).
fingpSupported	Flags for those procedures supported.
dimH, dimV	Size of screen (Horizontal, Vertical) in Twips.
dxScreen, dyScreen	Size of screen (horizontal, vertical) in Pixels.
dimPenH, dimPenV	Horizontal and vertical thickness of the pen in twips.  The thickness is usually the size of one pixel but may be any multiple of a pixel.
cpen	Number of pens the device holds.  This should be 1 for all devices except plotters.
icoAvailMac	Number of colors available.  This is the useable length of the array rgcoAvail.
icoPrefMac	Number of preferred colors.  This is the useable length of the array rgcoPref.
ipaLineMac	Number of line styles.  This is the useable length of the array rgpaLine.
ipaAreaMac	Number of area fill patterns.  This is the length of the array rgpaArea.
ccopln	Number of color planes or ribbons.
Followed by 4 arrays, allocated to their maximum sizes:
rgcoAvail	Available color list.  This is an array of RGB values which represent the colors that can be displayed on the device.  Black and White should be included.
rgcoPref	Preferred color list.  This is an array of RGB values which represent the default colors for data series (e.g. column bars, lines, and pie wedges).  Black should not be included in the preferred color list if several other colors are available.  The order of the list is important because colors will be selected and used in that order.  The following is the recommended order for color devices:  Blue, Green, Red, Cyan, Magenta, Yellow, Gray, Dark Blue, Dark Green, Dark Red, Dark Cyan, Dark Magenta, Brown, Dark Gray.  For monochromatic devices (gray scale), black should be included in the preferred color list (it must be included if the device only has black and white output).  Note that the preferred color list in no way limits either the list of colors from which the user can select or the number of colors which can be displayed simultaneously; it is simply a default set of colors.
rgpaLine	Line style list.  This is an array of line pattern indices.  The following line styles are available:		0	Clear		1	Solid		2	Dashed		3	Dotted		4	Dot-DashedThe order in which the styles are specified becomes the order in which styles are presented; the indices must be in ascending order.
rgpaArea	Area fill pattern list.  This is an array of area pattern indices.  The indices are 8-bit values representing the patterns listed below.  The first index must be 0 (clear) to allow outlining of areas.  Index 5 (white) exists for historical reasons and should not be used.  The order is the default order in which patterns are assigned to entries in data series (after skipping "clear").  No more than 16 styles are supported.  The area patterns are listed below:	Regular patterns:		0	Clear	1	Solid	2	Dense	3	Medium	4	Sparse	5	White	6	|| (vertical lines)		7	== (horizontal lines)		8	\\ (left diagonals)		9	// (right diagonals)		10	++ (square hatching)		11	XX (diagonal hatching)		12	Dark //		13	Light //		14	Dark \\		15	Light \\ 
Followed by:
szName	A zero terminated ASCII string describing this mode.

.c.::3.3.2 FINGD Field of INGD
The fingd field of the INGD structure is interpreted as a set of the following values (ORed together, all unused bits must be 0):
fingdRasterFonts	Supports Raster fonts.
fingdMultiColor	An infinite number of colors are available.
fingdFilm	Film device.
fingdVarPenSize	Variable pen size.
fingdNotAvailable	This mode is not available for the installed hardware.
The following two flags must be set for GSDs:
fingdRstrVctr	Must be set for GSDs.
fingdVirtualPen	Must be set for GSDs.
.c.::3.3.3 FINGP - fingpAvailable field
The fingpAvaliable field of the INGD structure is interpreted as a set of the following values (ORed together, all unused bits must be 0).  If the corresponding bit is set, then that routine is provided by the driver (otherwise the functionality must be synthesized by the application).
See the Driver Procedures section for a description of the procedures.
fingpSetAreaPat	SetAreaPat() provided.
fingpSetLinePat	SetLinePat() provided.
fingpSetLineWeight	SetLineWeight() provided.
fingpText	Text() provided.
fingpRectangle	Rectangle() provided.
fingpArc	Arc() provided.
fingpPolygon	Polygon() provided.
fingpBitBlt	BitBlt() provided.
fingpInitGraphics	InitGraphics(), TermGraphics(), Move() provided.
fingpDraw		Draw() provided.
fingpSnapShot		DrawXOR(), BitRead() provided.
Note: for GSD drivers, InitGraphics(), TermGraphics(), BitBlt() must be provided.
.c.4. GSD Procedures
.c.:4.1 Mouse Control
It is the Application's responsibility to disable the mouse when performing graphical drawing operations.  The CW call FEnableMouse() is provided for this functionality.
.c.:4.2 Very Primative Primatives
The Move() and Draw() primatives must be provided by the driver.  If necessary, higher level primatives can be constructed out of them (for example Rectangle() is just several Move() and Draw() calls).
.c.::4.2.1 Move
VOID Move(x, y)WORD	x,y;
Moves the current point to the coordinates specified.  The Move procedure can either save the coordinates or actually move the pen to the specified point.
This routine must be supported.
.c.::4.2.2 Draw
VOID Draw(x, y)WORD x, y;
Draws a line in the current color, line weight, and line pattern.  The line is drawn from the current point (as specified by the last command) to the specified point and leaves the pen (current point) at this new location.
This routine must be supported.
.c.:4.3 Drawing Attributes
The following routines modify the action of the drawing primatives:
.c.::4.3.1 SetAreaPat
VOID SetAreaPat(iPat)WORD iPat;				/* index into rgpaArea */
Sets the area pattern to be used in all future fill operations.  The integer is an index into the rgpaArea array.  A value of 0 indicates that the object should be outlined rather than filled.
This routine must be supported if any of the Rectangle, Arc, or Polygon routines are supported.
.c.::4.3.2 SetLinePat
VOID SetLinePat(iPat)WORD iPat;				/* index into rgpaLine */
Sets the line pattern to be used for all future lines.
.c.::4.3.3 SetLineWeight
VOID SetLineWeight(iWeight)WORD iWeight;			/* multiplier for line weight */
Sets the line weight to be used for all future lines.  The line weight is expressed as a multiplier to be multiplied by the pen size as specified in the INGD structure.
.c.::4.3.4 SetColor
VOID SetColor(ipen, rgb)WORD ipen;		/* pen number */WORD rgb;		/* rgb value of color */
Sets the pen color for all future operations.  For GSDs, iPen is an index into the rgcoAvail array.  For multicolor devices (fMultiColor set), iPen is meaningless.  In this case, and optionally for any other device, the rgb value should be used to set the pen color.  For GSDs, if iPen is -1 (rgb is undefined), the "color" is the complement of the current pixel color.  In other words, an iPen of -1 means to complement the pixel colors rather than setting them to a specified color.  All of the line drawing procedures (Rectangle, Arc, and Polygon when the area pattern is 0, and Draw) and BitBlt for the GSD must support this.
This routine must be supported.
.c.:4.4 Higher Level Primatives
The following higher level primatives are available.
.c.::4.4.1 Text
VOID Text(lpch, cch, hps, fo, wRotate)char far *lpch;			/* far pointer to string */WORD cch;				/* count of characters in string */WORD hps;				/* half-point size of font to use */WORD fo;				/* font number to use */int wRotate;			/* rotation in degrees */
This procedure is not currently used in the GSD drivers.
.c.::4.4.2 Rectangle
VOID Rectangle(lprect)RECT far *lprect;		/* far pointer to RECT */
Draws a rectangle in the current color, current line weight, and current line or area pattern.  The rectangle will be either outlined or filled as specified by SetAreaPat.
The application program assumes that the pen will draw inside the vertices of the rectangle.
.c.::4.4.3 Arc
VOID Arc(lprect, thStart, thLength)RECT far *lprect;		/* far pointer to bounding box of arc */int thStart;			/* start angle in degrees */int thLength;			/* arc length in degrees */
Draws an arc in the current color, current line weight, and current line or area pattern.  The bounding box pointed to by lprect defines the size of the arc.  The angles start at the 12:00 position and increase clockwise.  The arc will be either outlined or filled as specified by SetAreaPat.
The application program assumes that the pen will draw inside the arc as with the Rectangle procedure.
.c.::4.4.4 Polygon
VOID Polygon(lppolygon)POLYGON far *lppolygon;	/* far pointer to POLYGON structure */
Draws a polygon in the current color, current line weight, and current line or area pattern.  The polygon will be either outlined or filled as specified by SetAreaPat.
The size of the polygon structure (the cbPolygon field) depends on the number of points in the polygon.
num_pts = (cbPolygon - sizeof(POLYGON)) / sizeof(GPOINT) + 1
The array of POINTs which define the vertices of the polygon is in the variable length rggpt[] array.
.c.::4.4.5 BitBlt
VOID BitBlt(lprect, lpbitmap, cbRow, fColorPlanes)RECT far *lprect;		/* far pointer to source RECT */BITMAP far *lpbitmap;	/* far pointer to source bits */int cbRow;			/* count of bytes in each row of source bitmap */BOOL fColorPlanes;		/* if TRUE, modify specific color planes */
Copies a rectangle of bits from the source bitmap to the printer or screen.  The rectangle defines the bits in the source bitmap to be copied to the printer.  The current pen location defines the top-left corner of the destination rectangle on the printer.  A 1 bit in the source bitmap should cause the corresponding pixel on the printer to be modified.  A 0 bit in the source bitmap should leave the corresponding pixel unchanged.  If fColorPlanes is TRUE, the color planes corresponding to the bits set in the current color should be set to 1 and the color planes corresponding to the bits cleared in the current color should be unchanged.  If fColorPlanes is FALSE, a pixel should be modified by changing all color planes of that pixel to match the current color.  A special case of BitBlt handles markers.  If lprect==0L, the cbRow parameter should be interpreted as a marker index and the marker should be blted to the device centered about the current pen location.  The following is a list of the markers and their indices that must be supported:
0	None1	Filled circle2	Filled box3	Filled diamond4	Asterisk5	Hollow circle6	Hollow box7	Hollow diamond8	Dot9	Dash
.c.:4.5 Snap Shot Primatives
The following primatives are designed for applications that need to read portions of the graphic.  These are typically only available on screen devices.
.c.::4.5.1 DrawXOR
VOID DrawXOR(x, y)WORD x, y;
Draws a line in the current color, line weight, and line pattern by XORing the line with the current screen image.  The line is drawn from the current point (as specified by the last command) to the specified point and leaves the pen (current point) at this new location.
.c.::4.5.2 BitRead
VOID BitRead(lprect, lpbitmap, cbRow)RECT far *lprect;		/* far pointer to target RECT */BITMAP far *lpbitmap;	/* far pointer to target bits */int cbRow;			/* count of bytes in each row of bitmap */
Copies a rectangle of bits from the printer or screen to the target bitmap.  The rectangle defines the bits on the screen to be copied to the target bitmap.  The current pen location defines the top-left corner of the source rectangle on the screen.  The resulting bits in the target map correspond to an OR of the bits in the color planes specified by the current color.
Document Revision History
Apr 29 / 88 (2.22) [SAR]First CW version.Created from GSD document (from JohnG), rename, revise.
May 27 / 88 (2.22.02) [SAR]Added SetPrinting(), implemented printing support.
July 5 / 88 (2.22.03) [JWG]Modified SetColor() to support complementing of colors.  SetColor() is now required (fingpSetColor was deleted).  BitBlt() is now required for GSDs.
Nov 15 /88 (2.22.04) [MRD]Added fingpInitGraphics, fingpDraw.  InitGraphics, TermGraphics required for GSDs.
Nov 28 / 88 (2.22.04) [MRD]Added fingpSnapShot, DrawXOR, BitRead.
Table Of Contents
.Begin Table C.
1. Introduction	1
2. Initialization - Screen or Printer	2
2.1 Loading Drivers	2
2.1.1 FLoadGsd	2
2.1.2 FLoadGpd	2
2.2 Initializing Modes	2
2.2.1 FInitGraphics for Screen	2
2.2.2 FInitGraphics for Printer	2
2.2.3 TermGraphics	3
2.3 Switch Screen/Printer Mode	3
2.3.1 fPrinting	3
3. Data Structures	3
3.1 Terminology	3
3.2 Drawing Structure	4
3.2.1 GPOINT / GPT	4
3.2.2 RECT	4
3.2.3 POLYGON	4
3.2.4 BITMAP	4
3.3 Driver Info Structure	5
3.3.1 INGD - Graphic Drawing Info	5
3.3.2 FINGD Field of INGD	6
3.3.3 FINGP - fingpAvailable field	7
4. GSD Procedures	7
4.1 Mouse Control	7
4.2 Very Primative Primatives	7
4.2.1 Move	7
4.2.2 Draw	8
4.3 Drawing Attributes	8
4.3.1 SetAreaPat	8
4.3.2 SetLinePat	8
4.3.3 SetLineWeight	8
4.3.4 SetColor	8
4.4 Higher Level Primatives	9
4.4.1 Text	9
4.4.2 Rectangle	9
4.4.3 Arc	9
4.4.4 Polygon	9
4.4.5 BitBlt	10
4.5 Snap Shot Primatives	10
4.5.1 DrawXOR	10
4.5.2 BitRead	10
.End Table C.

 :
 ,:  1:[2JB9D&E+G/H!L4NOP[Q'TqV_%$< NOT         v       q      m   h      f   )  d <  H  b     `   		 @@ @ @ @  
  y   $  w 9  A  u     s     q ;  @  o U  ]  m     k     i 				  W	  [	  y 
  
  w 
  
  u :
  C
  s X
  ]
  q 
  
  o 
    m :  ?  k V  			V  ^  y     w     u     s     q 
    o     m     k     i 				      y l  u  w     u     s   %  q     o     m     k   				    y     w >  H  u     s     q     o     m s  x  k     i 				      y     w     u     s     q F  K  o M  Q  m r  x  k z  		z    y     w     u .  7  s n  w  q     o     m     k c  g  i 			g      y     w     u     s     q     o ,  0  m D  I  k r  			r    y     w     u     s     q )  9  o     m    +  k q  z  i 	z  }    y     w     u #   +   s .   8   q x      o       m       k !  	!  !  y ##  #  w %  %  u %  %  q E&  M&  o (  H)  k N)  i s)  )  e )  c )  ! 	 @ @ @)  )  y )  )  w **  :*  u S*  b*  s *  *  q *  *  o *  *  m E+  R+  k j+  y+  i  @y+  +  +  y +  +  w +  +  u "-  1-  s J-  Y-  q r-  -  o -  -  m -  -  k -   @	-  -  y -  .  w .  ).  u >.  O.  s .  .  q .  .  o .  .  m .  /  k /  /  i  @/  !/  $/  y 7/  ;/  w /  /  u /  /  s  0  $0  q +0  /0  o 0  0  m 0  0  k 0   @			0  0  y 0  0  w 0  1  s 1  N1  o R1  m 1  i 1  g 1  1  c 1  2  _ 3  ] 0 	 @ A	 @ @ A	3  3  _3  w d3  u {3  3  q 3  3  o 3  4  k 4  i 4  e 4  c 4  _ 4  ] 3  ] 0  @ @ @ A	 @4  4  w 4  u 4  q 4  o 4  4  k !5  )5  i .5  f5  e k5  c 5  5  _ 5  x6  [  @ A	 @ A	 @ @x6  }6  y 6  6  u 6  7  q !7  %7  o ;7  k D7  i e7  e p7  c w7  _ {7  ] 7  Y x6  [ @ @ @ @ @ A	7  7  y 8  u 8  s 8  o 8  m 9  i 9  g 9  9  c 9  a 9  9  ] :  );  Y x6  [ @ A	 @	 @ @ @);  .;  y D;  M;  u ;  $<  q .<  o <  k <  i <  <  e X=  =  a =  _ q>  [ x6  [  @ @ A	 @ @ A	q>  {>  y >  u >  s >  ?  o R?  ?  k ?  i "@  e +@  c 3@  o@  _ x@  ] @  Y x6  [ @ @ @ @ A	 @@  @  y A  	A  u A  s !A  'A  o :B  C  k C  C  i D  D  g iE  pE  e {E  E  c  @ @ A	 @E  F  F  y F  G  u G  s G  G  o G  H  k H  i H  H  e I  J  a pM  E  c   @ A	 @ A	 @	pM  M  v 0Q  ?Q  q G  u G  s G  G  o G  H  k H  i H  H  e I  J  a pM  E  c   @ A	 @  @ @      Y    Y    7    5   3 1  . G  o G   A?!H $                   p `'!H $                    `'1    v   v   v ?  q   q l  q P  q   l   g   b   ] 4  X Z  S   pW   =  = U = Z    v ;  v P  q v  l   g W	  g s	  b X
  ] }
  X 
  S }  N "  N   N = W  =  = W  =     v   q   l   g   b   b   ] +  X   S   S   N   I W  = W  = W  W      v   q   l   g >  b   b   b   b   b "  ] s  X   S   N =  =  U =   =     v   v P  q   q   l F  g r  b   b   ] .  X n  S   S   S = U =  U =  = U     v c  q   l   l   l   g >  b   ]   ] D  ] r  X   X   X )  X U U =   U =  )    v    v }  v   v .   v    v    v    q !  l %  l E&  l :)  l H)  g )  b )  ]  Y U = U = U )  )  v **  q S*  l *  l *  l *  l +  l E+  g j+  b +  b +  ] ,  X "-  X )  b )  =  U = U =  "-  J-  v r-  v -  v -  v -  v -  v .  v >.  v .  v .  v .  v !/  q 7/  l N/  g /  b   =   = U /  0  v 0  q 0  l 1  g 1  b 1  b 1  ] 1  X 2  S 2  S 3  N _3  I 7=  = W  = W  =  _3  v3  v 3  q w4  l 4  l 4  g .5  b f5  ] 5  X 5  S x6  N 6  I _3  I 7 = W  = W  = W  6  6  v _9  q 9  q 9  l 9  g 9  b :  ] );  X ?;  S ;  N 1<  I <  I 7= W  = W  =  = W <  <  v X=  q ~>  l >  l >  g R?  b ?  ] d@  ] @  ] 	A  ] A  X :B  S \F  N = W  = W  = W  \F  F  v F  q G  l G  g G  b H  ] H  X I  S 'K  N CK  I K  D :BU ? = W  = W  =  W K  K  v L  v M  v \M  v pM  q M  M  W M  W M  = CK  I                 !                !? U 	M  M  a M  a N  G 4N  - WN  - mN  - M  W M       	           !                !      	           !mN  N  a N  G N  - 4N  - WN  - mN  - M  W M                 !      	           !                !N  N  a N  a N  G O  G O  G )O  G FO  - M                 !      	           !                !FO  kO  a O  a O  a O  G O  - O  - FO  - M                 !                !      	           !O  P  a P  a /P  G CP  - WP  - nP  - P  - M       	           !                !      	           !P  P  a P  G P  G P  G P  G P  G Q  - M                 !      	           !                !Q  Q  a 0Q  a ?Q  \ @Q  P  G P  G Q  - M                 !      	         =       	           !        :   l      w   %   *   0  	 8  
 "@   2I   J   L  	5
3.3.1 INGD - Graphic Drawing Info	5
3.3.2         (       11/28/8811/28/88P  vailable field	7
4. GSD Procedures	7
4.1 Mouse Control	7
4.2 Very Primative Primatives	7
4.2.1 Move	7
4.2.2 Draw	8
4.3 Drawing Attributes	8
4.3.1 SetAreaPat	8
4.3.2 SetLinePat	8
4.3.3 SetLineWeight	8
4.3.4 SetColor	8
4.4 Higher Level Primatives	9
4.4.1 Text	9
4.4.2 Rectangle	9
4.4.3 Arc	9
4.4.4 Polygon	9
4.4.5 BitBlt	10
4
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cwover.doc ===
1             0 ; ; ; ; ; C:\EDITORS\C#.STY                                                   HPLASMS <                     		--	
	CW Main Overview	
Character WindowsMain Overview Document

Scott RandellMicrosoft Applications Division
.c.1. Introduction
This document describes the Character Windows system.
The audience is primarily for those who will be maintaining and enhancing the CW system, but consumers of CW (those who write CW applications) may find the contents of interest.
.c.2. History
Character Oriented Windows (COW) began in the summer of 1986 as a memory manager for PC-Works 1.0.  It then grew to envelop the screen, keyboard and user interface also of PC-Works.  The original COW code came from two sources.  The KERNEL (including global and local memory manager, code swapper and thunk mechanism) came from Microsoft Windows 1.0.  The keyboard, screen and user interface originally came from TWIN (Text Windows) written by Lee Acton for Quick Basic, and later used in Quick C 1.0.  Additional code (for loader and other new functionality) was added after this.  A character based version of SDM (the standard dialog manager) was ported.
Since then the kernel code has been optimized, the .EXE file format changed (to optimize load speed), the keyboard driver rewritten several times, most of the user interface code rewritten, SDM replaced with SDM 2.0 (with support of a dialog editor),  ported to OS/2, DBCS support for Kanji added, the Windows local memory manager replaced (with LMEM) and all the machine specific code isolated into installable drivers.
During this evolution of COW, many different programs began to use this interface (even the TWIN based applications began to convert over).  As a result of this increase in popularity (and the name leaking to the press) the derogatory name "COW" was changed to "CW" -- Character Windows.  The internal code and some of the interface routines still use the name "COW".
.c.3. Purpose
The purpose of CW is many fold.  It provides various services that are listed below:
* Installable screen and keyboard drivers.
* Global memory manager.
* Code swapper and thunk mechanism.
* Character based Windowing operating environment	including drop-down menus, dialogs, ...
* Graphical Drawing (to screen and printer).
.c.4. Consumers
The following is the current list of major consumers/users of the CW system.  The consumers are categorized in how they use CW.
For each CW App significant points for that application are described.
.c.:4.1 Full CW Environment
These CW Apps use most of the features of the CW environment.  They are large programs needing the swapped code option.  They also use the full extent of the windowing user interface.
.c.::4.1.1 PC-Works 1.0 (WORKS)
A Pcode application.
.c.::4.1.2 PC-Email (EMAIL)
A Cmerge application.
.c.::4.1.3 Quick C 2.0 (QC)
A Cmerge application.  Since it is a debugger it relies on the screen saving/swapping mechanism.  Special hack for multiple stacks -- not using the CRMGR for the compiler part.
Currently doing a half-assed VAP implementation.
.c.:4.2 User Interface Only
These CW Apps use CW for its user interface alone.  They are not swapped.
.c.::4.2.1 DOS Manager 1.0 (SHELL)
Nothing special here.  The Manager version 2.0 is more interesting since it will use overlapping windows and be swappable.
.c.::4.2.2 Quick Basic (QB)
Includes Kanji version.
.c.::4.2.3 CodeView (CV)
.c.:4.3 OS/2 Applications
PM problem...
.c.::4.3.1 OS/2 Net Interface (NIF)

.c.::4.3.2 CodeView (CVP)

.c.:4.4 Driver Only (CBOX)
explain this ....
.c.::4.4.1 PC-Multiplan 4.0 (PLAN)
Includes Kanji version.
.c.::4.4.2 PC-Word 4.0 (WORD)
Needs much more QINTER compatible CBOX support.
.c.:4.5 Misc CW Tools
.c.::4.5.1 VCR
A testing tool written by ByronB.
Saves test scripts and plays them back.  Swapped CMerge application.
.c.::4.5.2 DE20
Internal use dialog editor.
.c.::4.5.3 TESTDRV
Test program for installable drivers (given to OEMs).
.c.::4.5.4 C#
Evolving C# compiler and browser is currently CW based.
.c.:4.6 Future Consumers
The following future products will be consumers of CW:
* PC-Works 2.0 : Overlapped Windows + VAP support + Kanji
* Manager 2.0 : Overlapped Windows, swapped.
* CodeView 3.0 : Overlapped Windows ??
* PC-Word 6.0 : they may convert to a windowing user interface.
.c.5. General Organization
-- major components and interfaces.
.c.6. Components
-- purpose.
-- where sources.
.c.7. Coding Conventions/Practices
C: near/reg
ASM: space vs speed ...
.c.8. Building CW
-- NMAKE
-- CW / DRV / LIB
-- version control
.c.9. Documentation
-- external
-- internal
.c.10. Headers
-- external, generated, ..
-- private, "_foo.h" etc.
.c.11. Libraries
-- versions + ...
.c.12. Future
The future of CW:
-- many drivers.
-- Overlapping Windows.
-- VAP support.
-- User Defined Dialogs (QB) + DE.
VAP Issues:
-- MS-Key replacement.
Maybe:
-- size reduction.
-- port SDM 2.1 ??
-- move PRD/GPD into tools domain.
-- PM special support
-- TSR version of CW.
Table Of Contents
.Begin Table C.
1. Introduction	1
2. Files Provides	1
2.1 Documents	1
2.2 Source Files	1
2.3 Tools	2
3. Building the Example Drivers	2
4. Example CW application	2
5. Adaptation	3
5.1 Screen	3
5.2 Adapting Window Keyboard Drivers	3
6. Driver Notes	3
.End Table C.
                                                                                        P >                             v       q       m    h       f     d     b 	  	  ` 	  				 @@ @ @ @	  	  y 
  
  w 
  
  u )  .  s *  .  q     o 2  7  m h  m  k     i 										      y     w     u   $  s \  a  q     o     m <  A  k j  										j  o  y     w     u !  $  s b  e  q     o     m "  %  k Q  T  i 										T      y     w     r     m e  q     o     m "  %  k Q  T  i 			 @ @		      Y    7    5    5    3   .      A?!H $                   p `'!H $                    `'  H  v   v 
  q   l C  l   l   g   b E  ] _  ]   ]   ] 	  ] 	  X  `' E =  =  = 	  	  v 	  v 
  q 
  l 
  g 
  b   ] )  X F  S   N *  N G  I  =  =  =  =  = G    v   q 2  l O  g h  b   ]   X   S   N   I   D G =  =   =  =  =     v   q   l C  g \  b {  ]   X   S   N   I <  I G =   =  =  =  = <  M  v j  q ~  l   g   b   ]   X O  S   N   N   N !  N = E =  =  =  =  !  =  v b  q t  l   g   g   b   ]   ]   X   S   S "  S 7  N  =  =  =  =  7  D  v Q  v a  q }  l   l   g   b   ]   X   S 
  S   S ?  S  E =  =  =  = ?  L  v d  q l  l   g   g   g   g   g   b   ]   C                != ? E = E =   3  a D  G X  G e  G   -   -   -                 !               !               !    a   a   G   B     -   -               =                !               ! ' + , - . 3 ; C CW Overview Document SAR    1.00 5/3/88  5/3/88     7<            	EXX		;ELSE ROTATE CCW N	LD	A,E	;SUBT
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cwold.doc ===
1             3 9 9 9 : ; C:\C#\DOC\C#.STY                                                    HPLASMS <                     		--	
	CW OLD API Stuff		
Character WindowsOLD API Stuff
Scott RandellMicrosoft Applications Division
.c.1. Introduction
This document describes the things in the CW API that have been removed or significantly changed.
.c.2. Replaced by Installable Screen
The installable screen drivers in CW replace the following functionality.
.c.:1.1 FInitScreen
??? OLD INITIALIZATION ???
The FInitScreen must be called by the intitialization code of the application before any CW character output is performed.
BOOLFInitScreen()
Initialize the CW system for character output using the current screen mode set in the hardware.  (For Swapped CW only).
Returns TRUE if successful, FALSE if error (i.e. screen in non-character mode).
.c.:2.1 CGA Control
There are two special flags that are Read/Write by the application that allow compensation of the terrible CGA adapter.  Both flags must be used with caution, and should only be read or written after screen initialization (after FInitCow or FInitScreen).  These flags do not exist for the DOS5 version.
BYTE PASCAL fWaitRetrace;
If this flag is set, then screen i/o will wait until horizontal retrace to read/write video memory.  This will be set if the Init code detects a CGA adapter.  An install program can force snowy output by clearing this flag (never set this flag if it was not originally set since this may cause extra waiting when it is not necessary -- i.e. on an EGA or monochrome adapter).  Please note that not all CGA adapters will snow with this flag cleared by the application.
BYTE PASCAL fBlankScreen;
This flag only has meaning if the fWaitRetrace flag is set.  If fWaitRetrace and fBlankScreen are both set, then the video signal will be blanked when blt-ing areas on the screen.  This flag should not be set if fWaitRetrace is not set.
If the initialization code does not set fWaitRetrace, then the application can ignore these flags.  If it is originally set (i.e. a CGA adapter is found) then there are 3 configurations possible :
fWaitRetrace = FALSE, fBlankScreen = FALSEPotential snowy output: will generate snow on an IBM EGA, but not a Compaq.  This option will make a CGA run as fast as an EGA (ignoring wait states on the adapter memory).
fWaitRetrace = TRUE, fBlankScreen = TRUENo snow on text output, blank when scrolling.  This causes text to be displayed slowly, but scrolling the display is fast.  When scrolling, the video signal is blanked (so this is usually only useful with a black background).
fWaitRetrace = TRUE, fBlankScreen = TRUEVisually sound, real slow output.  No screen glitches are produced, but since all output and screen scrolling is done with waiting for retrace, this is really slow.
fWaitRetrace = TRUE, fBlankScreen = TRUEILLEGAL !!
.c.1. Replaced by LMEM
.c.:1.1 Local Memory Manager
The Local memory manager provides the following entries that are identical to their Windows counterparts.  These routines are different from all other CW routines in that it is up to the application to change the DS to the applicable Heap block before calling these routines (two exceptions : LocalInit, LocalShrink).
There are also some restrictions on the use of fixed blocks (they must be allocated first, and can not be freed).  In the future the C# local memory manager will be supported in CW  (see the C# LMEM document for details).
VOIDLocalInit(ps, pbMin, pbMac)WORD ps;char *pbMin, *pbMac;
Initializes a global memory block to be used as a local heap.  ps defines the physical segment address of the block to be initialized.  pbMin is the smallest address that can be used for the heap, pbMac is the largest + 1.  Never call this with ps=psDDS (the default heap is already setup for you).
The ps should be acquired from using CbAllocSb and dereferencing the sb (or calling LpbLockHp) to get the physical segment.
HANDLELocalAlloc(wFlags, cb)WORD wFlags;WORD cb;
Allocate a near pointer from the local heap.  wFlags define the mode of allocation.  cb is the number of bytes to allocate.
wFlags may be one of :
LMEM_FIXED : object fixed.
LMEM_MOVEABLE : object moveable.
either of which may be OR'd with :
LMEM_ZEROINIT : memory initialized to zero.
Allocations for fixed blocks will always be made in as low of memory as possible.  The returned value is a handle to near memory (or NULL if request failed).
HANDLELocalReAlloc(hn, cb, wFlags)HANDLE hn;WORD cb;WORD wFlags;
Reallocate a local memory block.  hn defines the local block (from a previous LocalAlloc) to reallocate.  wFlags define the mode of reallocation.  cb defines the new size.  Returns NULL if request failed, otherwise returns the new handle (which is identical to the old handle if LMEM_FIXED specified or block is not grown).
HANDLELocalFree(hn)HANDLE hn;
Free a local memory object.  hn defines the local block to free.  Returns NULL if successful, otherwise returns old handle.
WORDLocalSize(hn)HANDLE hn;
Returns the size (in bytes) of the specified local memory block.  Note : this size may be larger than you originally requested.

VOIDShrinkLocalHeap(ps)WORD ps;
Shrinks the local heap specified (makes as small as possible).  Shrinks the global block associated with local heap.
BOOLFCheckLocalHeap(lpckh);CKH FAR *lpckh;
Checks a local heap (identified by the current DS) for integrity.  Returns TRUE if local heap is ok.  If this function returns FALSE, then the integrity of the entire CW system is in question.  lpckh is a far pointer to a CKH structure to fill in with information (this may be NULL).
Document Revision History
Jan 27 / 88Installable screen and LMEM.

Table Of Contents
.Begin Table C.
1. Introduction	1
2. Installable Screen Replacements	1
2.1 CGA Control	1
.End Table C.
          v       q       m    h       f i  l  d     b     ` f  			 @@ @ @ @f  j  y R  U  w j  n  u     s %  '  q n  s  o     m     k     i 				      y     w A  G  u Y  c  s u    q     o     m     k 7  	7  =  y `  b  w   "  u P  R  s     q W  f  o     m     k     f  @      v     "  u P  R  s     q W  f  o     m     k     f  @ @      Y    7    5    3   . i  ) R  s=  A?!H $                   p `'!H $                    `'i    v   q   l   g   g   b   ] f  ] {  X   S   N   I = W =  = W =  =      v   q i  q B	  l N
  l   l R  l j  g   b   ]   ]   X   S W = W =   U = W     v   q A  l Y  l u  g   g   b   ]   X   S   N 3  I W = W = E = E = W = 3    v   q P  l R  l u  g   b   ] 6  X R  S |  N   I   I ? U ? = W = W = W =       a   a   G   B   B    6  X R  S |  N   I =                 !                !        ppy (global)	29
FTrapMouseRbutton()	31
FValidDrive()	29
GetClientRrc()	14
GetEditText()	27
GetScrol        C	        4
HANDLE (type)	4
Help()	25
InitMenu()	23
IntersectRect()	15
ISA (type)	4
isaUserMax	18
isaUs    ! " # $ , 4 CW old stuff      1/27/88 1/27/88   MENU (type)	8
MENUBAR (type)	8
MENUITEM	9
menuitem()	24
menuitemD()
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cwow.doc ===
1           QB        C:\EDITORS\C#.STY                                                   HPLASMS                      		--	
	CW on Windows 1.00.01		
Character Windowson WindowsAPI Guide 1.00.01
Scott RandellMicrosoft Applications Division
.c.1. Introduction
This document describes how the Character Windows on Windows (CWOW) environment differs from the standard Character Windows (CW) environment.  Please refer to the COWAPI.DOC document that describes the standard CW interface.
The CWOW system allows easy portability of CW based applications to a Windows framework.  The CWOW layer provides only a interface on top of Windows, and does not totally replace Windows.  In the cases where the CW interfaces are inadequate (in particular where pixel coordinates are needed instead of character) then the application should go directly to Windows.
This document does not concern itself with the differences between the CW versions of other standard packages (LMEM, SBMGR, ...) since they are minor and documented in their respective documents.
The term "Windows" (upper case 'W') refers to the Microsoft Windows environment.  The term "Application" refers to the CW application being ported to Windows -- i.e. Win Works.
.c.2. How it Works
The following briefly describes how the CWOW layer works in order to better understand its features and limitations.
.c.:2.1 Virtual Screen
The CWOW application will run in a single Window.  It will have a menu-bar but all internal windowing will be handled by CW and not Windows.  Therefore the client area of the one Windows' window will take the place of the entire screen.  This is the virtual screen model.  Inside the virtual screen we can have many (possibly overlapping) CW windows.  CW windows are much cheaper than Windows' windows.
Therefore for the spreadsheet in Works, the entire screen will be one Windows' window, but each of the formula bar, status bar, prompt line, scroll bars and sheet panes will be a CW window.
The virtual screen can also be re-sized by the user.  The virtual screen will have a standard (pixel) Windows border around it.  When the user resizes the virtual screen, the application will be notified allowing it to rearrange it's internal CW windows to make everything look good again.
NOTE: overlapping windows inside the virtual screen will have a character-wide border and will size and move via a slightly different interface.  Overlapping windows inside the virtual screen (i.e. CW windows) will not be fully MDI (multi-document interface) compatible since they will not have system menus of their own.
The virtual screen will be implemented as a standard CW screen driver (.CSD).  This will require a primary/secondary and overlapping window buffer.  Since we will provide our own buffers and windowing, bringing up a CW overlapping window will NOT use any of Windows' windowing code.  Drawing to the virtual screen will just be a sequence of WinTextOut() calls using the default system font.
ISSUE: the primary, secondary and overlapping window buffers are 16 bits per character cell.  This can lead to a lot of fixed memory needed for screen buffers.
The .GSD functionality of the screen can be easily be implemented with Windows GDI calls.  This may not be worth it depending on how much Windows special graphics is desired for Windows Works.
.c.:2.2 Menus
The CW Menu interface will be mapped onto the Windows menu manager.  Since the menu is outside the client area of the virtual screen's window, Windows will handle drawing and possible wrapping of the menu bar.  To mimic existing CW, we can pretend like the top line of the virtual screen does not exist (i.e. ayMenu = 0, and the Application's CW screen starts at ay=1).
Hopefully the menu integration should be pretty seemless.
.c.:2.3 Keyboard/Mouse Mapping
The events that come in from outside (in this case Windows) will be mapped into their equivalent CW messages.  Keyboard messages will translate the WM_KEYDOWN, WM_KEYUP and WM_CHAR messages into the WM_KEYUP and combined WM_CHAR messages of CW.  The mouse coordinates will also be converted from pixel coordinates to character coordinates.
The actual focus and mouse hit testing inside the virtual screen will be handled by CWOW.  As far as Windows is concerned the virtual screen will be one window that may have the input focus, receives mouse messages and may capture the mouse.  It is up to the CWOW layer to dispatch to proper translated messages to the appropriate CW window.
.c.:2.4 Swapping/Memory Management
The CW memory manager and code swapper is replaced by the Windows Kernel.  Since the CW kernel was based on the Windows kernel the transition is almost seamless.  The memory models (totally moveable) and integration with the SbMgr are the same on the two systems.
The only important difference is that the Application's data segment (DGROUP) will not be always FIXED (as in normal CW).  Like all Windows apps it will be locked when the application is running, but may move when the application is idle.
The CWOW layer will not make use of Windows resources.  The application is free to go directly to the Windows resource manager if it wishes (I would recommend against it due to the inefficiencies (space and speed) of Windows resources).
One point of note: we are replacing the character based CW with a much larger library (the Windows runtime).  This reduces the amount of memory available to the application by about 200K.  Hopefully this number will be smaller with Windows 3.0.
.c.3. How lame will it be ?
The CWOW layer will look almost identical to running a normal character based CW application as an Old-App under Windows.  Only the menus will look better.
This is a first pass, and after we get Windows Works running using the CWOW layer we can then determine the best approach to make things look better.
Dialogs are probably the area needing most work.  In particular, with the virtual screen model, pop-up dialogs will still be clipped to the limits of the virtual screen (and hence will not pop up).  Another area of possibility is Pcode-izing the CW user interface code for size reduction (since swap space is very critical in Windows).
In order to make characters look nicer, we can make special fonts that contain better looking graphics (eg: rounded buttons).  This way we can get a large portion of the visual equality with Windows (especially with Windows controls) without the cost of the full blown Windows window/control manager.  This also has the advantage that if we can get a great looking Works that relies on fixed pitch fonts (and not graphics), we can port that technology to non-Windows environments (in particular the EGA/VGA in text mode since it has downloadable fonts, or any adapter in 
.c.4. Changes in Build
The changes in the build process will be very minor.  A special library (DCWOW/CWOW.LIB) will be linked instead of [D]COWS.LIB.  The required .DEF file format will change slightly and the MUNGE and FIXSTUB steps will not be required.
The standard CW headers will be used, and a special CWOW.H header will be provided for access to renamed windows routines (see below, "Going Directly to Windows").
Since the APIs for the other standard packages (interpreter, SbMgr, LMEM, ...) are portable from CW to Windows, only changing the libraries that get linked will be needed.
.c.5. Changes in Application
The changes in application code will fall in one of three categories:
* things not supported in CWOW (but present in the non-Windows CW interface).
* changes to the CW interface 
* functionality above and beyond CW/CWOW.
Restrictions and changes in the CW API are described in the next major section.  The following describes the rules that must be followed when going directly to Windows.
.c.:5.1 Going Directly to Windows
When the application wants to go directly to Windows it differs from a standard Windows application in two important respects:
* Avoiding interference with CWOW glue.
* Name Conflicts.
Since CWOW will be interfacing to the Windows keyboard/mouse and event inputs, it will be providing its own WndProc.  When working as a CW application, this will be invisible.  The instant the application creates a real Windows window, then it must worry about interaction between the CWOW window and the application's windows.
The other problem is that the Windows API and CW API collide in various procedure names (the TYPE names are compatible, but the procedures differ in intent and parameters).  To avoid this problem, the CWOW.H header will be provided that prefixes all conflicting real Windows calls with "Win".  Also the CWOW.LIB library will have the renamed DynaLink entry points for Windows entry points (you will not link with the standard MLIBW.LIB library).  This will probably only apply to USER entry points (since KERNEL and GDI entries do not conflict).  This will make it more inconvenient to write Windows code in the framework of PC-Works (but since there are many more lines of code using the CW interface, this is the lesser of two evils).
.c.6. Additions to API
The following list the additions to the CW API for the CWOW system:
WM_SCREEN_SIZE	message sent to main (i.e. menu) window when the virtual screen has changed size.
.c.7. Deletions from API
The following CW API calls are not available in the Windows version (CWOW).  The functionality is not supported for several reasons.  The most common reasons are that the CW API calls don't make sense in Windows or that there is equivalent Windows functionality that provides the functionality.
.c.:7.1 ENVIRONMENT Functionality
The following environment (system, swapping, etc) functionality is not available in CWOW:
GetProgDir	no equivalent
fShellPresent	always false
AccessSwapFile	no equivalent
BindSegment	??? we can do this with GetCodeHandle() ???
RerrExec	MSDOS executive handles this.
FCheckGlobalHeap()	not supported by Windows KERNEL.
.c.:7.2 MOUSE Functionality
Since the MOUSE is part of the Windows environment, most mouse functions are not applicable for CWOW.  The mouse messages are the same as CW, but the following functions are not supported:
FEnableMouse	mouse should be always on
SetMouseCursor	replacable by Windows cursors.
SetMousePos	an evil thing to do.
SetMouseDoubleSpeed	replaced by control panel.
SetDoubleClickTime	replaced by control panel.
SwapMouseButton	replaced by control panel.
.c.:7.3 KEYBOARD Functionality
Due to the fact CW is no longer in control of the keyboard (and must rely on Windows keyboard drivers) we can't support the following functionality.  Please note that fPollKeyboard is also quite different (see below).
fKeyIsUp/fKeyWasUp	not possible -- fast key repeat must be done another way.
wRateKeyRepeat	key repeat is changable from the control panel.
DisableExtendedKeyboard	no equivalent.
.c.:7.4 SCREEN Functionality
Since we are running on a virtual screen the following CW routines/services will not be available.
No color palette	the screen driver will pretend that it can't change colors (that's the the job for the control panel).
GetCharMap()	no need since any code using fonts should be using the Windows Font manager.
SetCursorBlock()	this is replaced by the Windows Caret.
No shadows	Shadows, and hence chShadow and diShadow will not be available.
fMonochrome	App should replace it's color selection logic to be more consistent to the Windows color model.
.c.:7.5 Installable Drivers
The installable device driver interface is not supported in CWOW.  Since the Windows environment provides all this functionality nothing is loadable.  The following CW calls are not supported:
RerrLoadDrv, RerrLoadCwDrv	driver load
FLoadGsd, FLoadGpd, FreeGsd, FreeGpd	GSD/GPD driver load
The following drivers are replaced by their windows equivalents:
		CSD	->	Windows GDI (GDI.EXE and fonts)
		GSD	->	Windows GDI (GDI.EXE).
		KBD	->	Windows Keyboard driver (KEYBOARD.EXE)
		SYD	->	Windows System (SYSTEM.EXE)
		PRD/GPD	->	Windows printer driver (???.EXE)
		SCD	->	Windows COMM Driver (???.EXE)
.c.:7.6 Other Stuff
The following items are also not supported in CWOW:
KANJI	it is possible, but not for this version.
Screen and mouse swapping	(for QB/QC) no need.
Debugging output routines	(dprintf() etc) -- most people have their own CommSz() routine anyway.
.c.8. Modifications of API
The following API calls will change in some way shape or form.
.c.:8.1 Main Routine
The WinMain() entry point will be renamed to CwMain().
.c.:8.2 Message Pump
The main message pump (PeekMessage()/DispatchMessage()) and idling will change in some way I suspect in order to handle the incoming events from Windows.  As a first pass we could hide all this in PollKeyboard() and is a good idea for the first pass CWOW.  Future versions will probably see the Windows specific message pump (WinPeekMessage()/WinDispatchMessage()) being brought into the Application.
.c.:8.3 fMessage / fPollKeyboard
The Problem:
In CW we have control over all input events (keyboard and mouse).  Therefore we allow the application to run full speed when no input is anticipated.  If the user hits a key we set the fPollKeyboard flag.  The application will (when convenient) call PollKeyboard().  The application need not do a PeekMessage() call until an "important message" gets generated and the fMessage flag is set.  Non-captured mouse moves and key releases are considered as "un-important".
In Windows we do not have that luxury.  We must poll via WinPeekMessage in order to get any messages (keyboard or other).
First pass solution:
The following proposes a solution which will have the least impact on the application's code.
The fPollKeyboard flag remains set, and the PollKeyboard() routine polls the Windows event queue (WinPeekMessage()) and dispatches as needed.  The CW event queue is separate and hence fMessage works as it does now (only "important" messages).
This will be slower in CWOW (since WinPeekMessage() may yield to other applications) and since it may yield, the Application's data segment may move.
More involved solution:
I suspect the above solution will not survive long after the first pass CWOW system.  The best approach would be for the Application to move the Windows dispatch loop and event testing into their code and modify their idle and interrupt processing accordingly.  The area where this is most time critical, character entry in the word processor, should probably be re-coded for a more efficient Windows implementation anyway.
.c.:8.4 MOUSE Functionality
I expect some changes will be needed in the mouse capture functionality.  The programming API will be the same but the question is "should the CW mouse capture be limited to the virtual screen or cover all of Windows" ??
.c.:8.5 KEYBOARD Functionality
fAbort is no longer asynchronous.  The exact behavior of this flag is determined by how we solve the fMessage/fPollKeyboard problem.
.c.:8.6 SCREEN Functionality
The routines FInitScreen() and EndScreeen() will not be needed since the screen is already initialized.  There will only be one screen mode (returned by FQueryInst()) and mode switching will not be allowed (FInitScreen() will be a no-op anyway).  Any code in the application that handles screen mode switching or screen colors should probably be disabled for the Windows version.
The global variables axMac and ayMac are no longer constant and may be changed at any time (in response to an external WM_SIZE_SCREEN message).
SetIsaColor() will be modified in some way to specify more Windows-like colors.  Since the application's color preference code will be rewritten for Windows (to change from an IBM based color model to the Windows color model) then the form the color model takes is mostly driven by the application.
The hardware cursor (MoveCursor()/EnableCursor()) will be replaced by a Windows Caret (I-Beam) -- the exact interface here may change (allowing functionality like the current SetCursorBlock()).
.c.:8.7 Other Stuff
I suspect that the following areas may differ slightly:
Sound	Beep() and Click().

Document Revision History
Aug 25 / 88	[SAR]inception.
Aug 30 / 88	[SAR] (1.00.01)first release.

Table Of Contents
.Begin Table C.
1. Introduction	1
2. How it Works	1
2.1 Virtual Screen	1
2.2 Menus	2
2.3 Keyboard/Mouse Mapping	2
2.4 Swapping/Memory Management	2
3. How lame will it be ?	3
4. Changes in Build	3
5. Changes in Application	3
5.1 Going Directly to Windows	4
6. Additions to API	4
7. Deletions from API	4
7.1 ENVIRONMENT Functionality	4
7.2 MOUSE Functionality	5
7.3 KEYBOARD Functionality	5
7.4 SCREEN Functionality	5
7.5 Installable Drivers	5
7.6 Other Stuff	6
8. Modifications of API	6
8.1 Main Routine	6
8.2 Message Pump	6
8.3 fMessage / fPollKeyboard	6
8.4 MOUSE Functionality	7
8.5 KEYBOARD Functionality	7
8.6 SCREEN Functionality	7
8.7 Other Stuff	8
.End Table C.
 following areas may differ slightly:                  v       q      m   h   	  f     d     b     ` k  		 @@ @ @ @k  o  y     w '  +  u     s     q     o     m     k     i 									  #  #  y #  $  w W$  Z$  u %  %  s &  !&  q 1&  >&  o M&  [&  m k&  v&  k &  					&  &  y &  &  w '  '  u '  '  s (  (  q 3(  >(  o U(  h(  m (  (  k (  (  i 		(  (  (  y )  )  w )  )  u )  )  s )*  7*  q i*  *  o *  *  m +  +  k +  			+  +  y >,  F,  w K,  S,  u l,  w,  s ,  ,  q -  -  o -  -  m -  -  k -  -  i 		-  -  -  y -  .  w U/  Y/  u 0  "0  s b0  e0  q 0  0  o 0  0  m 1  1  k 1  				1  1  y 91  D1  w G1  V1  u 1  1  s h2  v2  q y2  2  o 2  2  m 3  3  k 3  3  i 			3  4  4  y T4  \4  w 4  4  u 5  5  s 5  5  q 
6  6  o `6  h6  m 6  6  k 8  	8  8  y 9  9  w u:  }:  u ~:  :  s :  :  q :  :  o :  :  m M;  W;  k ;  ;  i 				;  F<  K<  y P<  U<  w <  <  u >  >  s >  >  q >  >  o >  >  m ?  	?  k ?  		?  ?  y ?  ?  t BB  QB  o <  u >  >  s >  >  q >  >  o >  >  m ?  	?  k ?  		 @ @      Y    7    5   3   .   ) >  =  A?!H $                   p `'!H $                    `'  j  v /  v   v   q k  l   g   b   b   b <
  b   b e  b '  b 6  ]  `'!H $ =  =  = 6    v   v   q Y  l   l   g   b   b   b   b   ] k  X   X S  X  `'=  =  =  = S    v   q   l 8  l   l   g J  b   ]   ]   ]   X   S 1  N =  = E =  =  = 1  Z  v m  v    q #  q #  l #  g W$  b q$  ] %  X %  S &  N 1&  I 1U =  =  U =  = E 1&  M&  v k&  v &  v &  v '  v '  q '  l (  g 3(  g U(  g (  g (  g (  g  )  b )  ]  =  U =  U )  )*  v i*  v *  v *  q +  l +  g +  g  ,  g l,  g ,  g ,  b -  ] -  X .  X )  U =  U =  U .  \.  v .  q .  q .  q .  q -/  q U/  q j/  l /  g /  b  0  b b0  b ~0  ] 0  X )  =  U =  W = 0  0  v 1  q "1  l 2  g 2  b 2  ] 4  X 35  X I5  S 5  N 6  N 37  N ~0  ] K = K =  =  =  37  L7  v 8  q 9  l 9  g :  b :  ] :  X 1<  S <  S =  S >  S >  N ~0  ]  =  =  =  K = >  >  v ?  q ?  q 8?  l V?  g ?  g ?  b ?  b ?  ?  H ?  H >  N                 !? U ? U = ?  ?  a ?  a @  a 2@  a N@  G e@  G @  G ?  b ?  ?  H ?  H >  N                !                !@  @  a @  G @  G @  - A  - -A  - IA  - ?                 !                !                !IA  dA  a wA  a A  G A  - A  - A  - A  - ?                 !                !                !A  B  a /B  a BB  a QB  \ RB  A  - A  - ?                 !              =                 !
 
       y   ;      &   -   84   1>  	 >  
 ?  .
More involved solution:
I suspect the above solution will no ) - . / 0 8 @ H CW on Windows document SAR    3.00.00 8/30/88 8/25/88 A   for the Application to move the Windows dispatch loop and event testing into their code and modify their idle and interrupt processing accordingly.  The area where this is most time critical, character entry in the word processor, should probably be re-coded for a more efficient Windows implementation anyw
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\ideas.txt ===
Future Features / Ideas for CW:
===============================

-- Efficiency review
	* axMac optimize for 80
	* WORD / DWORD align data
	* CC 5.0
	* optimize screen drawing
	* optimize thunk scanning / global memory allocation
	* fix global realloc (fixed DGROUP etc).
	* split into a real library

-- Organization
	* Isolate the KERNEL stuff (separate project ?)

-- Pixel modes
	* more robust support (multiple code pages)

-- BIOS safe I/O variant (optimize)

-- DDE interface
	(a) Menu / Dialog interface
	(b) EMM control (paging control)
	(c) App specific control (like Lotus i/f) + context.

BUGS:
=====

Global Realloc (alloc & copy is bogus)
DOC: SetDialogCaption -- string must be static (for now).


Issues for DBCS Edit manager:
=============================

* WM_CHAR - double byte or 2 WM_CHAR messages ??

* Left->Right not top->bottom
* Weird wrapping rules at right hand side (not QB's prob).
* QB Text manager (255 chars or bytes ?)
* general DBCS support (cursor movement etc)

* 2 methods of K-K conversion
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\cwtwin.doc ===
1           	        C:\C#\DOC\C#.STY                                                    HPLASMS                      		--	
	CW TWIN Adaptations		
Character WindowsTWIN Adaptations (CW 2.20.01)
Scott RandellMicrosoft Applications Division
.c.1. Introduction
This appendix describes the variations of CW that exist to emulate TWIN (CW's predecessor) functionality.  These are of interest to the Microsoft Language products (QuickBasic and QuickC).
These variations are made at compile time (in the CW version file).
.c.2. Cosmetic features
The following cosmetic features exist in TWIN compatible versions of CW:
* Buttons are 3 chararacters high and look different.  The default button is drawn with a double wide border.
* There is no line at the bottom of dialogs.
.c.3. Functional Changes
.c.:3.1 Accelerators
Accelerators are possible without a corresponding menu item.
Accelerators in menus and dialog can be non-unique.
.c.4. One High Listboxes
Single character high listboxes (3 high including the border) are allowed (they do not have a scroll bar).  Please note that showing the listbox selection is visually different than real TWIN.
.c.:4.1 Horizontal Listboxes
Listboxes scroll horizontally (instead of the standard CW vertical listbox).  The user interface is significantly different.  The API has 1 additional call SetTmcListWidth() -- see below.
.c.5. API changes
.c.:5.1 SetTmcListWidth
For horizontally scrollable listboxes this sets the number of columns for the listbox.  This should be called for listboxes of more than 1 column in response to the dlmInit message to the dialog proc.  Listboxes that are more than 1 column wide must therefore have a dialog proc.
Listboxes that are 1 column wide do not need to call this procedure.  The Listbox handler automatically determines the width of each column.
VOID SetTmcListWidth(tmc, citem)TMC	tmc;WORD	citem;
tmc is the item code of the listbox.  citem is the number of items wide the listbox should be (i.e. the number of columns of items that are visible at 1 time).
Table Of Contents
.Begin Table C.
1. Introduction	1
2. Cosmetic features	1
3. Functional Changes	1
3.1 Accelerators	1
4. One High Listboxes	1
4.1 Horizontal Listboxes	1
5. API changes	2
5.1 SetTmcListWidth	2
.End Table C.
                      P                                                                                                v       q      m   h     f     d     b 6  :  `   				 @@ @ @ @    y     w U  d  u v  y  s     q G  N  o N  ]  m     k     i 					  5  F  v   	  q d  u v  y  s     q G  N  o N  ]  m     k     i 	 @ @      Y    7    5   3   .   ) y  s=  A?!H $                   p `'!H $                    `'    v 5  q   l   g   g 6  b L  ]   X   X   S   N   I  =  =   E =  =   v  v   q   l   g I  g   b !  ] 5  X F  Y  >                 !? = W =   = 
Y  q  a   a   G   - I  g   b !  ] 5                 !                !                !    a   G   - 	  ( 	    b !  =                 !                !                ! 
             either IDOK, IDYES, IDNO, IDCANCEL, IDRETRY or IDABORT.
.c.:12.2 Scroll Bar Functions
The current posit " & ' ( ) 1 9 A TWIN-isms in CW SAR    2.20.01 1/27/88 1/27/88   croll bar range.  Note: the window that gets specified in the following procedures is the scroll bar window itself.
short.i.SetScrollPos();SetScrollPos(pwnd, pos, fRedraw)PWND pwnd;short pos;BOOL fRedraw;
Set the scroll bar to the specified position (pos).  Re-draws the scroll bar if fRedraw is set.  Returns the old position of the scroll bar.
short.i.GetScrollPos();GetScrollPos(pwnd)PWND pwnd;
Returns the current scroll bar pos
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\sdmapi.doc ===
1             C:\EDITORS\C#.STY                                                   HPLASMS @   q  		--	
	SDM API 2.0		
Standard Dialog ManagerVersion 2.0API
Scott RandellMicrosoft Applications Division
.c.1. Introduction
This document describes the API (Application Programming Interface) for the Standard Dialog Manager. The system is mostly compatible with the older versions of SDM (old SDM). Benefits of the 2.0 system include : increased functionality, smaller dialog templates (50% old size possible), integration with a dialog editor, and greater control over the Application program interface (i.e. TMCs and CABs).
A familiarity with the old SDM is helpful.
Names are chosen to be compatible with old SDM name, except where names were improperly Hungarianized (in these cases the old names are also given in brackets []).
.c.2. Communication / Philosopy
SDM provides a filter of communication between the Application code and the User.
USER <---> SDM <---> Application
USER <---> SDMThe User interacts with several predefined controls (DialogItems) put together to make up a dialog. SDM filters these commands so that Application code need only respond to a small, well defined, set of messages.
SDM <---> ApplicationThe SDM<->Application interface has two paths of communication.
The first path involves communication of values. Values in SDM are stored in CABs. The initialization and termination of an SDM dialog usually involves parameter passing via a CAB.
The second path of communication involves communication of actions from the User. This form of communication takes place by SDM calling a DialogProc in the Application code. An item code (TMC) is assigned to all DialogItems, and this id is used by the Application code to identify DialogItems.
SDM should replace the normal dialog control of the destination environment. For the Windows and Mac environments it provides a refinement of the system supported dialog control. For the Character Windows (COW) environment, SDM is directly implemented as the only form of dialog control supported. Application code should not interface directly with the underlying dialog control of the environment but should restrict itself to the SDM interface (if extra facilities are needed by an Application that are not provided by SDM, SDM should be extended rather than the Application bypassing the defined interface).
The main advantage of using SDM is that it simplifies and standardizes the Application's interface to the operating environment (and utilimately the User). It does so by allowing several levels of defaults. Normally the User's interaction with the dialog will be performed at a simple level (for simple dialogs). This case requires very little Application code to support the dialog. For more complicated dialogs, Dialog and Item procedures are provided to allow Application code more explicit control over the dialog. The Application code need only be intelligent enough to handle exceptions to the normal processing of dialogs (and the normal case is handled as a default).
.c.3. Glossary
SDM	The Standard Dialog Manager.
Point	Two coordinates (x, y) in the system's coordinate system.
Rectangle	A point, and a (dx, dy) size in the system's coordinate system.
Application	The program that uses SDM.
DialogSession	The communication between the dialog and the User, whereby the user can receive and impart information from and to the Application.
Modal DialogSession	A DialogSession which prevents the User from doing anything else but respond to the dialog.
Modeless DialogSession	A DialogSession which allows the user to do other things before ending the dialog. A modeless DialogBox is in a window of its own and can be moved around by the User.
DialogProc	An Application procedure called by SDM to process events as a DialogSession is performed. DialogProcs are (usually) used to control non-standard interactions of many Dialog Items.
ItemProc	Like a DialogProc but attached to only one DialogItem. ItemProcs are (usually) used to control non-standard interactions of one or two Dialog Items. 
DialogBox	A rectangle with several parameters (i.e. style, title) that contains DialogItems. An optional DialogProc may be attached to the DialogBox.
DialogItem	An item contained in a DialogBox that either :a) outputs information to the userb) inputs information from the userc) both (a) & (b)d) provides some visual rendering that helps delimit/hilight information more clearly.
Passive DialogItem	A DialogItem that may inform the user, but does not directly receive user input (examples : static text, tracking text).
Active DialogItem	A DialogItem that may receive user input (examples : pushbuttons, ...).
ControlProc	An Application procedure called by SDM to control specific aspects of certain controls (i.e. ParseProcs, FormatProcs and ListBoxProcs).
ParseProc	A ControlProc controlling  the parsing of a parsed Edit item.
FormatProc	A ControlProc controlling the formatting of a text item. A FormatProc is very similar to a ParseProc.
ListboxProc	A ControlProc controlling the filling of a listbox DialogItem. 
NinchState	A state of some DialogItems that indicates that the user has not modified that DialogItem. Ninch stands for No Input, No Change.
StaticText	A Passive DialogItem that outputs textual information.
FormattedText	A Passive DialogItem that outputs a textual representation of a data item (i.e. a number value).
TrackingText	A Passive DialogItem that outputs textual information, and will change as the user activates some other Active DialogItem (example: the current directory in a directory combo listbox).
PushButton	An Active DialogItem that when "pushed" usually activates some application function. There is no state associated with a PushButton.
CheckBox	An Active DialogItem that when "pushed" toggles the state of the checkbox. When on the checkbox usually contains an "X". The state of a checkbox is a Boolean (on or off). There is an optional third (greyed) checkbox state that indicates a NinchState.
RadioButton	An Active DialogItem that when "pushed" selects one of many RadioButtons. The RadioGroup defines the grouping of the RadioButtons (i.e. at most one RadioButton of each RadioGroup can be on).
RadioGroup	A grouping of RadioButtons that imply mutual exclusion. A RadioGroup state is the index of the one selected RadioButton (or a NinchState if none are selected).
ToggleBox	An Active DialogItem that is very similar to a CheckBox except that the on state is indicated by the button text being highlighted in some manner (i.e. reverse video).
ToggleButton	An Active DialogItem that is very similar to a RadioButton with the one selected button in a ToggleGroup drawn with a highlight.
ToggleGroup	A grouping of ToggleButtons that imply mutual exclusion, much like RadioGroup but for ToggleButtons.
GroupBox	A Passive DialogItem that visually groups together other DialogItems.
Icon	A Passive DialogItem that provides icons to be added to DialogBoxes in graphical environments.
EditItem	An Active DialogItem that allows the user to input textual information. The value of an EditItem is usually a character string that the user has provided.
	ParsedEditItem	An EditItem that the application restricts in some way to provide a "valid" edit string (example : parsing a floating point number).
Character Validated EditItems	A variation on an edit item that allow the Application to validate each key before it reaches the edit item. This allows total Application control over the edit item.
ListBox	An Active DialogItem that allows the user to select one out of many items.
ComboListBox	A combination of an EditItem and a ListBox that allows the user to select from a list or type into an edit item.

----API Terms----
DialogEditor (DE)	A program that creates dialogs and maintains all the housekeeping chores of maintaining TMCs, CABs and DialogTemplates (aka DialogDescription).
DialogDescription	The description of a dialog in a machine readable format. The application builder will use the DialogEditor to modify this information and use the source files created by DE to link in with application code. This includes the DialogTemplate as well as other information that allows the DE to put together other attributes of the dialog.
DialogTemplate	A structure that contains, in a compressed format, the description of the dialog that the SDM code will process at run time. DialogTemplates are usually named dlgXXX.
SubDialog	A variation on a DialogTemplate that allows a subset of a larger dialog to be used to create a smaller dialog.
TMC	A TMC or ItemCode is a special code that is used to allow the Application to communicate with an SDM dialog ( each TMC usually specifies a DialogItem ). TMCs are the means by which individual DialogItems are controlled and specific user actions may be acted upon.
TMCs are usually defined by the DialogDescription and referenced in application code, but may also be defined by the application code and referenced in the DialogDescription.
CAB	A CAB or CommandArgumentBlock is another means of communication between the Application and an SDM dialog. The CAB is the means by which values (button states, current selections, ..) are controlled in a dialog (usually CABs are associated with the initial and final states of a dialog).
.c.4. Example
The following Save or Load example will be used throughout this document:
Problem : create a dialog that will allow the user to select a file from a directory. This dialog will have three variations. One will be a load option that will load in the specified file. The second will be a save dialog that will allow the user to save to a specified file with the option of saving as ascii or binary, and having the option of making a backup. The third variation is like the first, but has two parsed floating point numbers included.
The option of sub-dialogs allows the same dialog-template and CAB strucure to be used for three sub-dialogs.
.c.5. Argument Blocks
An Argument block (CAB) is a standard way to access arguments imported to and exported from a dialog.
Each dialog has its own format for an argument block, the example Save Or Load (Sol) dialog has a DialogTemplate named dlgSol and an argument block type of CABSOL. Sub-Dialogs share the same DialogTemplate and argument block structure.
Contained in a CAB are four types of information, the CAB header (CABH), an optional list of conditional flags (for sub-dialogs), the dialog arguments (handles or fixed length values) and any additional structure elements.
The CAB header will be fixed in size, and will contain information needed by SDM to manipulate the rest of the CAB (i.e. CAB size, # of handle entries). Additional debug information will be hidden here.
The conditional flags is a group of single-bit BOOL values will be used when creating the dialog. Each bit will selectively enable portions of the dialog (this allows one large DialogTemplate to contain many smaller SubDialogs). The conditional flags are unioned with a sub-argument block type (SAB).
The dialog arguments are sorted by the dialog editor so that dialog that require handles (as opposed to direct values) will be clustered together so that the old SDM method of keeping a rgfHandle array will not be required.
The additional structure elements will be defined by the Application with the only requirement that they be fixed in total size. This allows application code to attach extra information to a CAB that will not be lost with CAB duplication etc.
For the example :(the structure and #defines will be generated by the dialog editor).
typedef struct _cabSol{CABH          cabh;   /* the header info */
/* sub-dialog flags */union	{	struct		{		unsigned    fTitleSave:1;		unsigned    fTitleLoad:1;		unsigned    fButtons:1;		unsigned    fFloats:1;		};	WORD   sab;                      /* subtype */	};/* dialog info */char        **pszFile;	/* file name - from Combo Listbox  *//* if fButtons */WORD        stx;		/* radio group */BOOL        fBackup;	/* check box *//* if fFloats */NUM         numVal1;	/* a float */NUM         numVal2;	/* another one *//* Extra info - Application specific */char        szExtension[4];struct _cabSol **hcabsolNext;} CABSOL;
typedef CABSOL **HCABSOL;
This defines an argument block for a dialog with a directory combo listbox, a radio group, a checkbox, and two parsed floating point numbers.
The three versions of SubDialogs would yield the following :
#define sabSolLoad		2		/* load option */#define sabSolSave		5		/* save option */#define sabSolLoadF	10		/* load with floats */
The state of the radio button would yield the following #defines for the stx (a user type).
#define stxNinch	uNinchList#define stxAscii	0#define stxBinary	1
In addition, the user wishes to have tmc values for the pushbutton and checkbox (for more sophisticated control with the dialog procedure). As a result we get the following #defines :
#define tmcSolFile		....	/* for combo box */#define tmcSolTmx		....	/* for radio group */
Note that normally the dialog editor will define the TMC values for the Application builder (TMC values will be Exported from the dialog to the user code). Special TMCs will be permitted to be Imported to the dialog from user code (tmcOK for example).  See the example code to see the use of such a dialog.
.c.6. The Dialog Editor
The generalization of argument information as well as the increase in the complexity of dialogs, requires the use of a dialog editor.
The steps for using the DialogEditor will be something like the following :
1) specification of a dialog or dialogs with the DE.
2) generation of header files by DE (automatic).
3) generation of a DialogTemplate (also automatic).
4) including the header in with Application source code to handle the initializing of the dialog, controlling the dialog with a dialog procedure, and retrieving the results of the dialog.
5) Linking the source code with the dialog template producing a final executable.
Notes :The DialogTemplate will normally be contained in a .sdm file that will be included with a CS source file (this allows use of the csconst feature).
.c.7. Dialog Items
Most dialog items require a rectangle or a point to specify whre the item is to be drawn in the DialogBox.  All items that require some form of text (i.e. titles) have the option of having hard-coded text or text obtained from a CAB entry. In the case where text is taken from a CAB entry the structure name of the CAB entry must be specified.
Most Active items have the option of an action.  This option may take one of four forms. Either :
a) no action is performed,
b) one or more special item specific ItemProcs are called.
c) the DialogProc is called.
d) (b) optionally followed by (c)
Some Active items also have the option of terminating the DialogSession (i.e. "dismissing" the dialog). In this case it is an option if a CAB is to be returned to the Application.
Push Buttons also have the option of being a default control (i.e. the control activated when the User types the ENTER key), this is usually only used by the OK PushButton.
An additional option allows Active items to be initially "greyed" (i.e. disabled). This can reduce the number of calls to EnableTmc() in init code.
All items have a TMC. The DE will allow four different kinds of TMCs (an option for each DialogItem).
a) no exported TMC (a TMC will be defined, but the Application does not need to know about that item.
b) special TMCs (i.e. tmcOK) that are predefined by the system and usually specify exit codes.
c) exported TMCs that are needed by the Application and are defined by the DE.
d) imported TMCs that are defined by the Application and integrated with the DialogTemplate to provide a means of doing very tricky things where the order of TMCs is special for the application (this is rare).
All items have the option of being conditional. The conditional state is specified by one bit-sized BOOL values at the start of the CAB structure (currently a limit of 16 bits). If the corresponding bit is set, then the DialogItem[s] will exist, otherwise they will not. This allows creation of SubDialogs. Please note that the order of arguments (i.e. the CABxxx structure) for SubDialogs is the same for the full-sized dialog (just certain fields will not be active for the SubDialog).
Some items have the option of a word (wParam). The optional parameter is usually used to specify range values for parsed items, and special display modes for special listboxes. This parameter may either be a hard coded value, or a value obtained from the CAB (in which case a structure element name must be provided).
The next section is a list of DialogItems and the parameters that define them (the details of defining the dialog, and which are applicable to each item type will all be handled by the DialogEditor). The DialogEditor will also provide suggestions for names and default conditions.
.c.:7.1 Passive Dialog Items
Static Texta rectanglea title (either direct text or from CAB).left, right or centered
Formatted Texta rectanglesize of item to be formattedCAB structure name to store resultFormat Functionoptional WORD & LONG for application specific use
Tracking Texta rectangleTMC for the Combo Listbox this item is attached to
Group Boxa rectanglea title (either direct text or from CAB).
Icona point (upper left corner)icon resource name or ID number(either direct of from CAB).
.c.:7.2 Active Dialog Items - Buttons
Push Buttonsa rectanglea title (either direct text or from CAB).optional actionoptional dismiss
Check Boxa rectanglea title (either direct text or from CAB).optional actionoptional dismissCAB structure name to store BOOL result
Radio GroupCAB structure name to store WORD result	(the index of on button).
Radio Buttona rectanglea title (either direct text or from CAB).optional action(NOTE : TMC can not be imported or special).
Toggle Boxa rectanglea title (either direct text or from CAB).optional actionoptional dismissCAB structure name to store BOOL result
Toggle GroupCAB structure name to store WORD result	(the index of on button).
Toggle Buttona rectanglea title (either direct text or from CAB).optional actionoptional dismiss(NOTE : TMC can not be imported or special).
.c.:7.3 Active Dialog Items - Other
Edit Itema rectangleoptional actionleft, right or centerededit options : No scroll, validated,...Mulit-Line ?optional ParseFunction(parsed result may either be a fixed size object or a handle to an object).CAB structure name to store result (PSZ for non-parsed)optional WORD & LONG for application specific use
List Boxa rectangleoptional actionresult index or string ? (return value can either be an index or a real string)Combo ? (if yes combo with which edit item).Tracking ? (if yes with which tracking text).Listbox function (for filling).optional CAB structure name to store result(none for Combo, index or PSZ result).listbox options : (i.e. multi-column, horizontal scrolling, ...)Multi-selectoptional WORD & LONG for application specific use
.c.8. Dialog Procedures
DialogProcs are the means of communication between SDM and the Application code. In the DialogEditor, the creator of the dialog description selects which DialogItems will be action items. Action items will normally call the DialogProc for the given dialog template. Optionally a separate procedure can be called (with parameters identical to those passed to the DialogProc).
The parameters to the DialogProc are :
(dlm, tmc, wNew, wOld, wParam)
dlm : defines the dialog message type [old name msg]
tmc : the iTeMCode of the DialogItem acted upon by the user.
wNew : the new value (see below)
wOld : the old value (see below)
wParam : message specific WORD parameter  	(usually for ItemProcs)
All DialogProcs return a BOOL result. This is normally TRUE indicating success. If a FALSE value is returned, this indicates an exception to the normal dialog processing. If a DialogItem is a dismiss dialog item and the DialogProc returns FALSE, then the dialog will not dismiss. If the dialog item has a state associated with it (i.e. RadioGroups, CheckBoxes, ListBoxes, Validated EditItems) and the DialogProc returns FALSE, then the state is not changed.
If the DialogProc returns TRUE, or if it does not exist, then a user-supplied global dialog procedure, .i.FGlobalDlgProc();FGlobalDlgProc, is called with identical parameters.  This procedure facilitates the handling of global dialog characteristics specific to the application (such as non-dialog mouse hot spots).
.i.dlmInit;dlmInit			[msgInit]Initialize the dialog to the default / initial state. wParam contains the handle of the original cab (hcab).
 .i.dlmClick;dlmClick			[msgClick]indicates a button (PushButton, CheckBox, RadioButton, ToggleButton or ToggleRadio) has been activated by the user. The hcab parameter is not used. The wNew and wOld parameters contain the old and new state of the item (with the exception of PushButtons that have no state).  For listboxes, this message corresponds to a selection change and wNew contains the method by which the selection was made.  (wNew&lbrCause) takes on one of the values lbrMouse, lbrOther, lbrScroll, lbrKeys, or lbrSpace, and (wNew&flbrReselect) indicates that an item was reselected.
.i.dlmChange;dlmChange			[msgChange]indicates that an EditItem has changed its contents. For Validated EditItems wNew will be the new character, returning FALSE will ignore the character. For non-validated EditItems, wNew will be the (new) number of characters in the edit field.
.i.dlmTerm;dlmTerm		[msgTerm]indicates that the User requested the dialog to dismiss. This allows the Dialog Proc to validate everything. If returning FALSE then the dialog will not be dismissed. The tmc value indicates the DialogItem that requested the termination (means of trapping the ENTER and ESCAPE keys will be provided).
.i.dlmKey;dlmKey			[msgKey]indicates that the user hit some key not normally recognized by the dialog handler. wNew is the virtual key hit by the user.
.i.dlmDblClk;dlmDblClk		[msgDblClk]The user double clicked in the control.For Listboxes, return TRUE if you wish to end the dialog (i.e. double clicking is equivalent to hitting ENTER). Return FALSE will not dismiss it.For RadioButtons and ToggleRadios, this is like a dlmClick message but only if the User double-clicks on the button/toggle.The action of this message should not be unique since double-clicking is only possible with the mouse.
.i.dlmUnclick;dlmUnclickThe user released the mouse button after making a selection in a listbox. 
.i.dlmClientMouse;dlmClientMouseA mouse event occurred somewhere inside the dialog box, but not on a control item.  wNew is the mouse message identifier (WM_MOUSEMOVE, WM_LBUTTONDOWN, WM_RBUTTONDOWN, WM_LBUTTONDBLCLK, WM_RBUTTONDBLCLK, WM_LBUTTONUP, or WM_RBUTTONUP).  wOld is the wParam parameter of the mouse message (see COWWM.DOC for details).  LOBYTE(wParam) is the RX of the mouse event, relative to the dialog window; HIBYTE(wParam) is the RY.
 .i.dlmClientMouse;dlmClientMouseA mouse event occurred somewhere outside the dialog box.  The parameters are the same as in dlmClientMouse, except that wParam specifies the absolute position (AX,AY) of the mouse event.
Optional messages (system dependent)
.i.dlmIdle;dlmIdleThe dialog is idle.  The app may do idle processing.  This message is generated by the default RspAppIdle call-back.  Returning TRUE to this dlm returns rspSleep from RspAppIdle, FALSE corresponds to rspContinue.  If you do any processing during dlmIdle, return FALSE.
.i.dmlSetFocus;dlmSetFocus		[msgSetFocus]indicates that the User moved the input focus to the item specified by tmc. This allows extended control (especially for Edit items).
.i.dlmKillFocus;dlmKillFocusindicates that the User moved the input focus out of the item specified by tmc.
.i.dlmSysCommand;dlmSysCommand	[msgSysCommand]
.i.dlmActivate;dlmActivate		[msgActivate]
.i.dlmClose;dlmClose		[msgClose]
.i.dlmSize;dlmSize		[msgSize]
.i.dlmCommand;dlmCommand		[msgCommand]
.i.dlmInitMenu;dlmInitMenu		[msgInitMenu]indicates that a Windows message was sent to the DialogWindow (Windows specific). lParam is the parameter of the message. This allows a very detailed level of control for dialog boxes, especially for modeless dialogs.
.c.9. Item Procedures
An Item Procedure (ItemProc) is identical in form to a Dialog Procedure. A Dialog Procedure is called for all items in a dialog that are "Action" items. ItemProcs are only called by those items that they are specifically bound to. Each dialog can have at most one DialogProc. Each dialog item can have any number of ItemProcs.
ItemProcs are used to simplify the code of DialogProcs (i.e. everything that you can do with ItemProcs can be done with a more complicated DialogProc). The normal use of an ItemProc is to associate two dialog items with eachother.
Example:A PushButton (with tmc = tmcButton1) if a enabled if and only if a given parsed edit field is valid (tmc = tmcEdit1).
With a DialogProc :
.....if (dlm == dlmChange && tmc == tmcEdit1)	DisableTmc(tmcButton1, FValidEdit(tmc));
This code must be present in all DialogProcs that need this association of an edit item and a push button. With an ItemProc, a DialogProc is not needed and the ItemProc can be used many different dialogs that use the same association of two items.
In the ItemProc :
.....if (dlm == dlmChange)	DisableTmc(wParam, FValidEdit(tmc));
There are two dialog specific pieces of information, (1) the fact that the edit item has this extra function, and (2) the tmc of the button it controls are encoded in the DialogTemplate  ((1) is the definition of the ItemProc, (2) is an the optional wParam field).
Multiple ItemProcs are allowed, the additional ItemProcs being called only if all the previous ones return TRUE. If the DialogItem is also an "action" item, then the DialogProc will be called last if and only if all the ItemProcs have returned TRUE (programming with data structures - what a concept).
.c.10. ControlProcs - Control-specific Procedures
Special procedures are required by SDM to control complicated DialogItems. These procedures control the operation of one type of DialogItem and do not control how DialogItems interact (that is the job of ItemProcs and the DialogProc).
.c.:10.1 ParseProcs - Parsed Edit Items
There are two varieties of Parse Edit Items : fixed-size and variable-size. Fixed-size values are stored in the CAB directly. Variable-size values are stored in separate memory blocks (by themselves) and the corresponding handle is stored in the CAB.
The parameters to ParseProcs are :
(tmm, sz, hobj, tmc, wParam, bArg)
tmm : defines the DialogItem message type(tmmParse, tmmFormat, tmmCwVal)
sz : a zero-terminated string
hobj : is the handle of an object.
tmc : the iTeMCode of the EditItem acted upon.
bArg : is the byte offset where the result should be stored from the start of **hobj.   (This value will be 0 for variable-sized values).
wParam : a WORD parameter, application specific (will be 0 if not specified).

.i.tmmParse;tmmParse		[msgParse]Parse the string in "sz" and store the result in *(*hobj+bArg). If successful return TRUE. Otherwise optionally call Alert(), hilite the bad EditItem with TmcSetSel() and return FALSE.
.i.tmmFormat;tmmFormat		[msgFormat]Format the value in *(hobj+bArg) into "sz" (up to 255 characters).  Return value is ignored.
.i.tmmCwVal;tmmCwVal		[msgCwVal]Return the size of a variable-length values.  (implement this for message for fixed-length values for debugging assert only).
The wParam field is Application specific, but can be used to encode range limits.
.c.:10.2 ListboxProcs - ListBox Control
There are two varieties of ListBoxes : those that return indexes, and those that return strings. Normally the index method would be used to index to a fixed list of items (i.e. select background color). The string method would be used to select one of a dynamic list. Directory Listboxes always return strings.
Currently multiple selection in listboxes is not supported.
The parameters to ListboxProcs are :
(tmm, sz, isz, tmc, wParam, bArg)
tmm : defines the DialogItem message type(tmmCount, tmmTest, tmmEditTest)
sz : a string buffer
tmc : the iTeMCode of the EditItem acted upon.
bArg : used only for tmmText
wParam : a WORD parameter, application specific (0 if not specified)

.i.tmmCount;tmmCount		[msgCount]Return the number of items in the listbox (a value of -1 indicates an unknown size).
.i.tmmText;tmmText		[msgText]Copy into string buffer sz the string associated with string index isz.  bArg is a near pointer to the default ISA (pisa) for sz.  This may be changed if desired.  Return TRUE if successful, FALSE if no more.  tmmText messages will always be sent in a sequential manner (i.e. isz will start at 0, and always increment by 1).
.i.tmmEditText;tmmEditText		[msgEditText]Like tmmText except return a non-sequential element for editing (only for Combo-Listboxes).  If this returns TRUE, then *sz will contain the text to edit, if this returns FALSE, then the current value in the Listbox will be used.  Returning different values for tmmText and tmmEditText allow ComboListboxes to display more information in the listbox.
The wParam field is Application specific, but can be used to specify special variations of listboxes (i.e. horizontal scrolling ...).
.c.:10.3 FormatProcs - Formatted Text
FormattedText DialogItems have a formatting procedure that is identical to that of Parsed Edit Items with the exception that only the tmmFormat message will be sent.
.c.11. Procedures
The following procedures are provided by SDM. Most are direct replacements of the Old SDM functions.
.c.:11.1 CAB Procedures
HCAB .i.HcabAlloc();HcabAlloc(cabi)WORD cabi;
Allocates a CAB from the Local heap. Returns a local handle or NULL if insufficient memory. Normally this is cast to the cab of the correct type.
cabi is a special init value defined by the dialog editor that is used to tell how big the CAB is (and the number of handles it contains).
Example :	HCABX hcabx;	hcabx = (HCABX) HcabAlloc(cabiCABX);

VOID .i.InitCab();InitCab(hcab, cabi)HCAB hcab;WORD cabi;[InitLocalCab...]
Initializes a CAB for use. This is like HcabAlloc() except the handle is assumed to be valid (and large enough to contain cbCab bytes). This assumes the previous contents of the CAB are garbage. If you are using one static CAB, InitCab should only be used once.
Example :	foo()		{		CABX cabxT;		CABX *pcabxT = &cabxT;		HCABX hcabxT = &pcabxT;		InitCab(hcabxT, cabiCABX);		......		}

VOID .i.ReinitCab();ReinitCab(hcab, cabi)HCAB hcab;WORD cabi;[InitStaticCab...]
Re-Initialize a static CAB (i.e. either a static or automatic variable). This is like InitCab() except that the previous contents of the CAB are assumed to be valid (i.e. the old handles are freed first). This is identical to calling FreeCabData() followed by InitCab().

VOID .i.FreeCab();FreeCab(hcab)HCAB hcab;[FreeHcab]
Frees a CAB (and all associated data).  hcab is the handle to a CAB (acquired by a previous call to HcabAlloc).
Example :	FreeHcab(hcabx);

VOID .i.FreeCabData();FreeCabData(hcab)HCAB hcab;[FreeHcabHandles]
Frees the data associated with a CAB. Does not free the actual CAB (i.e. CAB could be a static or automatic variable).

CAB * .i.PcabLockCab();PcabLockCab(hcab)HCAB hcab;[PcabLockCab]
Optional.  Locks a CAB for use, returns a pointer to the locked CAB.
Example :	CABX *pcabx;	pcabx = PcabLockCab(hcabx);

VOID .i.UnlockCab();UnlockCab(hcab)HCAB hcab;[UnlockCab]
Optional.  Unlocks a CAB previously locked by PcabLockCab.

VOID .i.SzToCab();SzToCab(hcab, sz, iag)HCAB hcab;char *sz;WORD iag;
Places a zero-terminated string in the "iag'th entry in the CAB. Always use the Iag macro to find the value of iag.
Example:	SzToCab(hcabx, "*.*", Iag(HCABX, pszFileName));

VOID .i.StToCab();StToCab(hcab, st, iag)HCAB hcab;char *st;WORD iag;
Places a length-prefixed string in the "iag'th entry in the CAB. Always use the Iag macro to find the value of iag.
Example:	StToCab(hcabx, "*.*", Iag(HCABX, pstFileName));

VOID .i.RgbToCab();RgbToCab(hcab, rgb, cb, iag)HCAB hcab;char *rgb;WORD cb;WORD iag;
Places an array of bytes in the "iag'th entry in the CAB. Always use the Iag macro to find the value of iag. The length of the item (cb) is not stored in the CAB.
Example:	extern FOO foo;	RgbToCab(hcabx, &foo, sizeof(FOO), Iag(HCABX, hfoo));

char * .i.SzFromCab();SzFromCab(hcab, sz, cchMac, iag)HCAB hcab;char *sz;WORD cchMac;WORD iag;
Gets a zero-terminated string from the "iag'th entry in the CAB. Places up to cchMac characters of string data into buffer sz. Always use the Iag macro to find the value of iag. Returns a pointer to the start of the string. The resulting string will always be zero terminated.
Example:	char sz[255];	StFromCab(hcabx, sz, sizeof(sz), Iag(HCABX, pstFileName));

char * .i.StFromCab();StFromCab(hcab, st, cchMac, iag)HCAB hcab;char *st;WORD cchMac;WORD iag;
Gets a length-prefixed string from the "iag'th entry in the CAB. Places up to cchMac characters of string data into buffer st. Always use the Iag macro to find the value of iag. Returns a pointer to the start of the string.
Example:	char st[255];	StFromCab(hcabx, st, sizeof(st), Iag(HCABX, pszFileName));

char * .i.RgbFromCab();RgbFromCab(hcab, rgb, cb, iag)HCAB hcab;char *st;WORD cchMac;WORD iag;
Gets cb bytes from string from the "iag'th entry in the CAB. Places up to cchMac characters of string data into buffer st. Always use the Iag macro to find the value of iag.
Example:	FOO fooT;	RgbFromCab(hcabx, &fooT, sizeof(FOO), Iag(HCABX, hfoo));
.c.:11.2 Dialog Procedures
TMC .i.TmcDoDlg();TmcDoDlg(pdlg, hcab)DLG *pdlg;HCAB hcab;
Perform a DialogSession with DialogTemplate *pdlg on arguments from CAB **hcab. Return the resulting iTeMCode. This is a modal dialog.
Example:	if (TmcDoDlg(&dlgFoo, hcabfoo) == tmcOK)		....

HDLG .i.HdlgStartModeless();HdlgStartModeless(pdlg, hcab)DLG *pdlg;HCAB hcab;
Begin a modeless DialogSession with the User. *pdlg defines the DialogTemplate and **hcab the arguments. The value returned is a system specific "handle" to a modeless dialog (function not available in COW).

VOID .i.EndModeless();EndModeless(hdlg, tmc)HDLG hdlg;TMC tmc;
End a modeless DialogSession. h is the system specific "handle" to the modeless dialog (returned by StartModelessDlg). tmc is the iTeMCode that should decide the termination of the modeless dialog (i.e. usually tmcCancel or tmcOK).

BOOL .i.EndDlgTmc();EndDlgTmc(tmc)TMC tmc;
Ends the current dialog if the dialog proc returns TRUE to a dlmTerm message.  The dialog will not be terminated if the dialog proc returns FALSE.  The given tmc is returned by TmcDoDlg.
.c.:11.3 TMC Procedures
Note : using the tmc value to identify DialogItems limits you to access only the first item with non-unique TMCs. For example, if you have two PushButtons that have the same tmc value (i.e. tmcCancel), then the TMC procedures will operate only on the first DialogItem. This is a very rare occurance.
VOID .i.SetTmcVal();SetTmcVal(tmc, val)TMC tmc;WORD val;
Set the value of DialogItem specified by tmc.
CheckBoxes/ToggleButtons : val = button state	(TRUE/FALSE/Grey)
RadioGroups/ToggleGroups : val = index of button selected (or uNinchRadio).
Listboxes : val = index of listbox item selected (or uListNinch)
Parsed EditItems / FormattedText : val = word value that will get parsed.  (only WORD sized items allowed)

WORD .i.GetTmcVal();GetTmcVal(tmc)TMC tmc;
Get the value associated with DialogItem specified by tmc.
Checkboxes/ToggleButtons, RadioGroups/ToggleGroups, Listboxes all return the value as in SetTmcVal().
Parsed EditItems : parses string currently in edit field, returns WORD value.  (only WORD sized items allowed)

VOID .i.SetTmcText();SetTmcText(tmc, sz)TMC tmc;char *sz;
Set the text associated with DialogItem specified by tmc. sz is a zero-terminated string to replace the old contents.
StaticText : replace the contents of the text.
FormattedText/TrackingText : like StaticText (not normally used)
PushButtons/CheckBoxes/RadioButtons/ToggleButton/ToggleRadio : sets the text of the button.
EditItems : replace the edit test.

VOID .i.GetTmcText();GetTmcText(tmc, sz, cchMac)TMC tmc;char *sz;WORD cchMac;
Fill *sz with at most cchMac characters from DialogItem specified by tmc.  Text contents for DialogItems as in SetTmcText().

VOID .i.EnableTmc();EnableTmc(tmc, fEnable)TMC tmc;BOOL fEnable;
Enable / Disable the DialogItem specified by tmc. If fEnable is not FALSE, then the item is enabled.  Disabled DialogItems can not be tabbed to and are usually drawn in a different manner (i.e. greyed).  Enabling (or disabling) a RadioGroup or ToggleGroup enables (disables) all buttons in the group.

BOOL .i.FEnabledTmc();FEnabledTmc(tmc)TMC tmc;[!FTmcDisabled]
Returns TRUE if the DialogItem specified by tmc is currently enabled.  The state of RadioGroups and ToggleGroups can not be returned by this function.

VOID .i.SetFocusTmc();SetFocusTmc(tmc)TMC tmc;[TmcSetFocus]
Sets the current input focus to the DialogItem specified by tmc. This allows programs to change control of tabbing order and jump around the dialog.

VOID .i.SetTmcSel();SetTmcSel(tmc, ichFirst, ichLim)TMC tmc;WORD ichFirst, ichLim;[TmcSetSel]
Changes the selection for EditItem specified by tmc. ichFirst and ichLim specify the first and last+1 (i.e. lim) index of the character string to be selected. This also performs a SetFocusTmc().

VOID .i.SetTmcEditWidth();SetTmcEditWidth(tmc, cch)TMC tmc;WORD cch;
Turns the EditItem specified by tmc into a fixed length edit item of length cch.  Fixed length edit items do not scroll so cch must be <= the length of the edit space.  If cch < 0 then the edit item is returned to normal (scrolling non-fixed length).
VOID .i.SetDefaultTmc();SetDefaultTmc(tmc)TMC tmc;
Causes the pushbutton specified by tmc to become the default pushbutton.  If tmc == tmcNull, then there will be no default pushbutton.
VOID .i.RedisplayListbox();RedisplayListbox(tmc)TMC tmc;
Force re-display of the contents of ListBox specified by tmc.
VOID .i.GetTmcListBoxOrientation();GetTmcListBoxOrientation(tmc, pisz, pdisz)TMC tmc;WORD *pisz, *pdisz;
Gets the current orientation for the ListBox specified by tmc. *pisz is the current selection and *pdisz is the number of lines between the top of the box and the current selection.
VOID .i.RedisplayListBoxOriented();RedisplayListBoxOriented(tmc, pisz, pdisz)TMC tmc;WORD *pisz, *pdisz;
Dumps the contents of the listbox and redisplays it with the given orientation.  If the given orientation is illegal then the corrected values are returned.
VOID .i.TmcListBoxResetcontent();TmcListBoxResetContent(tmc)TMC tmc;
Empties the ListBox specified by tmc.
VOID .i.TmcListBoxAddstring();TmcListBoxAddstring(tmc, isa, sz, fRedraw)TMC tmc;ISA isa;char *sz;BOOL fRedraw;
Adds the string sz to the ListBox specified by tmc.  if (fRedraw) then display the change.  sz will be displayed with the given isa (isaNil is replaced with the default ISA for the listbox).
VOID .i.TmcListBoxInsertstring();TmcListBoxInsertstring(tmc, isa, sz, isz, fRedraw)TMC tmc;ISA isa;char *sz;WORD isz;BOOL fRedraw;
Adds the string sz to the ListBox specified by tmc at the position isz.  if (fRedraw) then display the change.  sz will be displayed with the given isa (isaNil is replaced with the default ISA for the listbox).
VOID .i.TmcListBoxDeletestring();TmcListBoxDeletestring(tmc, isz, fRedraw)TMC tmc;WORD isz;BOOL fRedraw;
Deletes the string from the ListBox specified by tmc at the position isz.  if (fRedraw) then display the change.
VOID .i.TmcListBoxReplacestring();TmcListBoxReplacestring(tmc, isa, sz, isz)TMC tmc;ISA isa;char *sz;WORD isz;
Replaces the string sz to the ListBox specified by tmc at the position isz.  The string MUST be the same length as the one that is already there.  If visible, the change is always displayed.  sz will be displayed with the given isa (isaNil is replaced with the ISA for the string being replaced).
VOID .i.TmcListBoxRepaint();TmcListBoxRepaint(tmc)TMC tmc;
Redraws the ListBox specified by tmc.
PWND .i.PwndOfTmc();PwndOfTmc(tmc)TMC tmc;
Returns the window of the given tmc.

.c.:11.4 System Specific Procedures
InitSDM(hinst, hwnd)HANDLE hinst;			handle to this instanceHWND hwnd;				handle to main window
Windows only.  Initializes SDM for Windows.

FDoDlgEvent(pevent)EVENT *pevent;
Mac only.  Check if event to be handled by SDM. If yes, process event and return TRUE.
Additional system specific procedures may be added depending on needs of the environment (and special applications).
.c.12. Application Supplied Procedures
The following procedures must be provided by the Application (most are supplied by the operating environment automatically). Heap management routines must define a HANDLE to be a double-indirect pointer.  For the COW environment, most of these services are supplied.
HANDLE .i.HeapAlloc();HeapAlloc(cb)WORD cb;
Allocate a heap object large enough to hold cb bytes. Return handle to object or NULL if insufficient memory.
VOID .i.HeapFree();HeapFree(h)HANDLE h;
Free an object acquired by a previous HeapAlloc().
char * .i.HeapLock();HeapLock(h)HANDLE h;
Optional.  Lock object with handle h, return pointer to locked object.
VOID .i.HeapUnlock();HeapUnlock(h)HANDLE h;
Optional.  Unlock object previously locked by HeapLock().
VOID .i.Alert();Alert(sz)char *sz;
Called by SDM to alert (via a MessageBox) the user. The string sz contains the alert text (used only for Parse Errors).
VOID .i.OutOfMemory();OutOfMemory()
Called by SDM to indicate an out-of-memory condition.
BOOL .i.FGlobalDialogProc();FGlobalDialogProc()
This global dialog proc is called if the current dialog proc has returned TRUE or no dialog proc exists.  The default proc simply returns TRUE.
.c.13. Transition from Old SDM

The transition from old SDM to the SDM 2.0 requires a four part conversion. Each part involves a cost to the Application builder. As a final result, the benefits of SDM 2.0 should decrease the size, increase the maintainability and simplify the underlying code.
.c.:13.1 Costs
1) Conversion of SDM dialogs to .DES format.This involves running the old SDM descriptions through the dialog editor and adding names to complete the dialog description. Other things such as replacing old hand-generated headers with headers generated by the DialogEditor and such will be done at this stage.
This is the largest step in the conversion (since it must be done for all existing dialogs in the old format).
2) Conversion of DialogProcs, and ControlProcs.This involves adjusting for the new change in parameters. This will probably be a minor effort in most cases due to the downward compatability built into the New SDM.
3) Conversion of SDM code.The application specific features that have been integrated into the sdm.c (or dlg.c) code must be retrofitted into the New SDM code (i.e. a common core). There will be one master set of sources with several well defined places where application specific enhancements will be inserted. For each application that has its own implementation of a customized SDM (i.e. old SDM), they will have to decide whether they should retrofit the New SDM changes into their code, or (preferably) integrate enhancements into New SDM as needed to make one common set of source code workable for everyone.
The main goal of this effort is to avoid the diverging sources problem that plagues old SDM.
4) Making use of new features.The task of using the new features of SDM to simplify existing code mostly comes into play with Costs 1 & 2. The new features help to simplify the Application interface to SDM and allow reduction in size of dialogs and the supporting Application code.
Note that this is an optional cost since much of the SDM API interface is downwardly compatable and the old way of implementing things will probably work with little change in the new system.
There is an additional one time cost of porting the New Sdm system to new environments (i.e. Windows, Mac). This assumes one core of source code (with additional code for each environment), if each application retrofits separately the problem of separate sources is still present.
.c.:13.2 Benefits
1) Better control of dialog elements.The Dialog Editor will enforce a strict mapping between the different elements of the DialogDescription. This is very helpful when creating new dialogs (and essential for the easy internationalization of existing dialogs).
2) Dialog Editor.The DialogEditor will support the DES format for SDM dialogs. This will not only greatly simplify the creation of new dialogs and help in the internationalization of existing dialogs, but it also simplifies the work required by the Application builder (along the same lines as Benefit 1).
3) Common sources.The new standard is a good starting point for a common set of sources for all versions of SDM (with possibly no private versions ??).
Hand coding for speed increase and size reduction, as well as a common point for enhancements and bug fixes are just some of the benefits of common sources.
4) Reduced dialog sizeThe format of new SDM DialogTemplates is much smaller than those of old SDM. This in the addition of the potential space savings by using SubDialogs, makes New SDM possible to reduce the size of both the templates as well as the supporting code.
5) EnhancementsThe SDM 2.0 API offers some useful features that are not available in the old SDM (although most were recognized as deficiencies since several separate efforts were made to add them).
6) The futureThe future option of making SDM a proper part of Windows is attainable with the new SDM API.
.c.:13.3 New Features
The following is a summary of some of the features to be found in SDM 2.0. Some implementations of Old SDM may already have incorporated these features into their code.  Some implementations of New SDM may not need their inclusion. Most extensions that required a large amount of code will be a compile option for the standard body of code.
New Dialog ItemsValidated EditItems, Toggles (Buttons & Groups).
SubDialogsWith code and DialogTemplate space savings.
New CAB FormatData > 1 word can be placed directly in CAB, extra fields can be tacked on the end.
Automatic CAB generation.
All string information optional from CAB.
Item Procedures(saving in code size and complexity).
Extended Parse FunctionalityParsing directly to CAB.
Extension to Standard DialogItems (i.e. listboxes)wParam to aid Application-specific customizations as well as future extensions.
Additional Proceduresfor using and re-using static CABs and so on.
.c.:13.4 API Differences
The following is a summary of the differences of the API of New SDM as compared to that of Old SDM. Some implementations which have implemented new features may have additional differences/incompatabilities.
RenamingSome of the New SDM procedures and all of the SDM message types have been renamed (a macro file defining the old names will be provided).
CAB usageNew SDM has a rigid interface between the use of a CAB and its DialogTemplate. Any games being played with the specifics of CAB implementation may cause problems.
DLG formatThe format of the DialogTemplate is internal to SDM. Any Application code that assumes this format may have problems (the TM format of New SDM is somewhat different, but still similar to Old SDM, Application code that needs to scan the DLG structure may be retrofited (but as a better solution the need to scan the DLG structure should be re-examined).
TMC usageLike CABs, New SDM has more rigid definitions of how TMC are used. This should cause few problems since most Applications use TMCs properly.
Dialog and Item ProcsNew SDM has additional parameters for Dialog and Item Procs. Most of the parameters and message types are backward compatible. The return value of DialogProcs is important for New SDM.
DialogItemsSome renaming and (minor) change in functionality was required in standardizing the DialogItems. This should not cause many problems in Application code (other than naming).
.c.14. Additional Topics
Dialog Accelerators will be handled as a system specific detail (i.e. Windows and COW will be Windows 1.5/2.0 like and the Mac will be Mac-like). Similarly the actual behaviour of DialogItems is also system specific.
The string implementation is handle based. A string implementation of fixed-length strings is a simple variant of New SDM. This has the simplicity of no needing the extra indirection (but of course the CAB structures can get bit if many strings are used).
Multi-selection listboxes will be provided as a system-specific option. The returning value will either be a count followed by a handle to an array of words (or handles to strings) or a count followed by a fixed number of words (this restricts the upper bound on the number of items selected).
Addititional topics not discussed in this document are listed below (i.e. if you have any desires to have them included, and how they are to be implemented, please say so).
User Drawn objects
Action Text Items (??)
Incorporating "OPUS" Combo listboxes as a standard
Document Revision History
Mar  3 / 87 [SAR]Conversion to C# style, add indexfine tuning of interface (removal of lParam and hcab from dialog & control procs).
Feb 13 / 89 [MRD]dlmIdle PwndOfTmc FGlobalDialogProc.
Feb 16 / 89 [CP]dlm[Non]ClientMouse, FGlobalDlgProc.
Mar 15 / 89 [MRD]Listbox proc may return FALSE to tmmText at any time to signal no more SZs.bArg == pisa for tmmText.ISA additions for TmcListBoxAddString, TmcListBoxInsertString, TmcListBoxReplaceStringEndDlgTmc
Table Of Contents
.Begin Table C.
1. Introduction	1
2. Communication / Philosopy	1
3. Glossary	2
4. Example	4
5. Argument Blocks	5
6. The Dialog Editor	6
7. Dialog Items	7
7.1 Passive Dialog Items	8
7.2 Active Dialog Items - Buttons	8
7.3 Active Dialog Items - Other	9
8. Dialog Procedures	9
9. Item Procedures	11
10. ControlProcs - Control-specific Procedures	12
10.1 ParseProcs - Parsed Edit Items	12
10.2 ListboxProcs - ListBox Control	13
10.3 FormatProcs - Formatted Text	14
11. Procedures	14
11.1 CAB Procedures	14
11.2 Dialog Procedures	17
11.3 TMC Procedures	18
11.4 System Specific Procedures	21
12. Application Supplied Procedures	21
13. Transition from Old SDM	22
13.1 Costs	22
13.2 Benefits	23
13.3 New Features	23
13.4 API Differences	24
14. Additional Topics	25
.End Table C.
Index
.Begin Index.
Alert()  22
DlmActivate  11
DlmChange  10
DlmClick  10
DlmClientMouse  11
DlmClose  11
DlmCommand  11
DlmDblClk  10
DlmIdle  11
DlmInit  10
DlmInitMenu  11
DlmKey  10
DlmKillFocus  11
DlmSize  11
DlmSysCommand  11
DlmTerm  10
DlmUnclick  11
DmlSetFocus  11
EnableTmc()  19
EndDlgTmc()  17
EndModeless()  17
FEnabledTmc()  19
FGlobalDialogProc()  22
FGlobalDlgProc()  10
FreeCab()  15
FreeCabData()  15
GetTmcListBoxOrientation()  20
GetTmcText()  19
GetTmcVal()  18
HcabAlloc()  14
HdlgStartModeless()  17
HeapAlloc()  21
HeapFree()  21
HeapLock()  22
HeapUnlock()  22
InitCab()  14
OutOfMemory()  22
PcabLockCab()  15
PwndOfTmc()  21
RedisplayListbox()  20
RedisplayListBoxOriented()  20
ReinitCab()  15
RgbFromCab()  17
RgbToCab()  16
SetDefaultTmc()  19
SetFocusTmc()  19
SetTmcEditWidth()  19
SetTmcSel()  19
SetTmcText()  18
SetTmcVal()  18
StFromCab()  16
StToCab()  16
SzFromCab()  16
SzToCab()  15
TmcDoDlg()  17
TmcListBoxAddstring()  20
TmcListBoxDeletestring()  20
TmcListBoxInsertstring()  20
TmcListBoxRepaint()  21
TmcListBoxReplacestring()  21
TmcListBoxResetcontent()  20
TmmCount  13
TmmCwVal  13
TmmEditText  14
TmmFormat  13
TmmParse  13
TmmText  13
UnlockCab()  15
.End Index.
܀         v       q       m    h       c 
  ` n  \ o  W q  R @ @ @ A@ @@ @ @ @q    w   s   o '  k *  f 7  c :  _ Y  [ ^  W   S   O   K q  @ B @ B @ B A@ @ A @ A    w   s   o   k   g   c '  _   [   W   S   O 0  K q  @ B @ B @ B @ B @ B @ B0  9  w   s   o   k   g @  c R  _   [   W .  S 9  O y  K q  @ B @ B @ B @ B @ B @ By    w   s   o 8  k B  g   c   _   [   W x  S   O ?  K q  @ B @ B @ B @ B @ B @ B?  I  w   s   o )  k +  g @  c A  _ x  [ {  W ~  S   O   K q  @ A @ A @ A @ A @ B @ B    w   s   o   k   g M  c V  _   [   W   S   O   K q  @ B @ A @ B @ B @ A @ B    w   s 	  o Q  k U  g   c   _ \  [ j  W   S   O   K q  @ B @ B @ B @ B @ B @ B    w   s   o   k   g   c B  _ S  [    W    S T!  O W!  K q  B @ B @ B @ B A @ B @ BW!  ]!  w f!  s !  o !  k #  g #  c $  _ $  Z $  W I'  S L'  N `'  K q  A@ @ A@ @ B @ B @ B @`'  >(  w A(  s c(  o i(  k (  g (  c +  _ +  [ 1  W 1  S u2  O x2  K q  B @ B @ B @ B @ B @ B @x2  4  w 4  r 4  o 7  k 7  g 7  c 7  ^ 7  [ ;  W ;  S @  O @  K q  B @ B @ A@ @ B @ A@ @@  B  w B  r B  p B  l D  h D  c D  a D  ] !F  Y #F  U ~G  Q G  M q   A @ A @ A	@ @ A	@ @G  H  w "H  r CH  n IK  j LK  e bK  b "M  ^ %M  Z RM  V UM  R XM  N [M  J q B @ B @ B @ A@ @ A@ @[M  M  w M  s M  o M  k M  g M  c N  _ N  [ PP  W dP  R &Q  N 1Q  I q@ @@ @ B @ B @ B @ B @1Q  8Q  w {Q  s Q  o Q  k Q  g Q  b Q  ^ NR  Z RR  V nR  R sR  N wR  J q @ B @ B @A@B @B @AwR  {R  w ,S  s 1S  o hS  k lS  g S  c S  _ T  [ T  V T  R yT  N }T  J q B @A@ @ B @ B @ B @ B}T  T  w T  s !U  o ,U  j 3U  f U  b U  ^ mV  Z wV  U }V  Q V  M V  I q B @A@ @ B @A@ @ B @V  W  w W  r W  n X  j X  e X  a .Y  ] @Y  X CY  T NY  R Y  N Y  L q B @A@ @A@ @A@ @Y  <Z  w @Z  u HZ  q NZ  o Z  k Z  i Z  e Z  c Z  _ [  Z 	[  V [  T [  P   @A@ @ @ @ @ @[  [  y [  u [  p \  k 	\  g i\  c s\  _ \  [ \  W ]  S ']  N 2]  J [A@ @A @A @A@ @ @2]  ]  w ]  s ]  o ]  j ]  f 1^  b 4^  ^ 7^  Z H^  U U^  Q g^  M v^  H @ @A@ @ B @A@ @ B @v^  ^  w ^  s ^  n ^  j ^  f ^  a ^  ] ^  Y ^  T ^  P ^  L v^  H @ @A@ @A@ @A@ @A^  
_  v _  r w_  n }_  j  `  f `  a `  ^ f  Z f  U f  R f  O g  K @ @ @ A@ @ A@ @ B @A@g  g  v g  t h  p Ji  l Mi  h i  d i  ` i  \ i  X i  T i  P j  L @ @ B @ B @ B @ B @ A	@j  j  w j  s j  o j  k j  f j  b k  ^ k  Y k  U Al  Q Ml  L Ul  H A@ @A@ @A@ @ B @ BUl  l  w l  s 2m  o 4m  k 8m  f ]m  b o  ^ o  Z go  V io  R }o  N o  J  B @ B @ B @ A@ B @ B @o  o  w o  s o  o o  k o  g o  c p  _ p  Z 'p  V p  R p  M p  I A@ @A@ @ B @A @ B @p  p  w p  s p  o p  k p  g p  c q  _  q  [ &q  W (q  S xq  O q  K  B @ B @ B @ B @ B @ B @q  q  w q  r r  n r  j $r  f r  b r  ^ |s  Z s  V s  R t  M &t  I  A@ @ B @ B @ B @A@ @&t  t  w t  s t  o t  j t  g Fu  c Ju  ^ ]u  Z du  V su  Q |u  M "v  I  @ A@ @ A@ @ A@ @ B @"v  #v  w &v  s v  o w  j w  f x  b x  ] x  Y -z  U /z  Q 4z  M Az  H @ @ A @ A@ @ A@ @B BAz  Hz  w z  s z  o z  k z  g z  c {  ^ {  Z {  V {  R {  N {  I @ @ A @ A@ @ A @ B @ A{  {  w u|  s w|  o ||  k |  f |  b |  ^ }  Y 
}  U b}  Q e}  M }  I  @ B @ A@ @ A@ @ A @ A}  }  w }  s }  n ~  j ]~  f `~  b ~  ^ ~  Z ~  V ~  R ~  N ~  I @ @ A @ B @ B @ A@ @ B~    w b  s e  o   k   g   c   _ @  [ O  V X  R ŀ  N Ȁ  J  B @ A@ @ B @ B @ B @ AȀ    w   s   o   k   g    b )  ^   Z   V   R   N   J  @ B @ B @ A@ @ B @ B @    w   s   n ǃ  j   f   b -  ^ 0  Z S  V Y  R   N   J  B @ B @ B @ B @ A@ @ B    w   s   n $  j (  f 6  a >  ]   Y   U   Q   M %  I  @ B @ B @ A@ @ A@ A @%  '  w ,  s C  n H  j T  f   b   ^ ͆  Z ц  V P  R a  M l  I  A@ @ B @ B @ AA@ @ Al    w   s   o   k }  g   b   ^ C  Z F  V a  R e  M z  I  A@ @ B @ A@ @ B @ B @z    w   s   o   j Ċ  f   b   ^ V  Z e  U n  Q   M   I  B @ A@ @ B @ A@ @ B @    w   r   n   j   f 
  b   ^ :  Z <  V A  R Q  M [  I  A@ @ A @ B @ B @ A@ @[    w   s   o   k ӏ  g ֏  c   _ "  Z +  V   R   N   J  @ B @ A@ @ B @ B @ B @    w   s   n   j   f   b [  ^ ]  Z b  V s  Q ~  M ؒ  I  @ A@ @ A @ B @ A@ @ Bؒ  ے  w 9  s H  n Q  j Ɠ  f ɓ  b ˓  ^ ӓ  Z ؓ  V ޓ  R a  N v  I @ @ B @ B @ B @ A@ @ Bv    w Ĕ  s ǔ  o   k   g   c "  _ P  [ S  W   S   N ŕ  J  A@ @ B @ B @ B @ B @ Aŕ    w   s "  o %  k b  g x  b   ^ і  Z Ԗ  V ܖ  R   M   I  A@ @ B @ A@ @ B @ B @  }  w   s   o   k   g   c   _   Z 5  V 	  R %  M ;  I  A@ @ A@ @ B @ B @ B @;  l  w o  s w  o   j   f   b   ^   Z   V   R &  N B  J  @ B @ B @ B @ A@ @ B @B  D  w f  s i  o   k ǚ  f ݚ  b ?  ^ A  Z ^  V a  R r  N u  J  B @ B @ B @ A@ @ B @ Bu  |  w   s   o   k Û  g ƛ  c   _ $  Z :  V   R   N   J  @ B @ A@ @ B @ B @ B @    w   s Ɯ  o   k   f   b j  ^ l  Z   V   R   N   J  B @ B @ B @ A@ @ B @ B    w   s :  o =  k   g   b   ^ ޞ  Z   V   R   M   I  A@ @ B @ A@ @ B @ B @    w 0  4  s 9  o =  j \  f ^  b e  ^   Z   V ߠ  R   N  A A @ A @ A @ A@ @ B @    v 	  s   o +  j 4  f o  b q  ^   Z Ţ  U ͢  Q   M %  H @ @ A@ @ B @ A@ @ A@%  -  w _  s `  o   k   f   b   ^   Y   U Q  Q S  M   I  @ B @ A@ @ A@ @ B @ A    v   r   n   i   e   a   \ ɥ  Y ˥  U Ҧ  Q ֦  L   H  A@ @ A A@ @ A@ @ A@    w Ʃ  s ʩ  o ϩ  k   g "  b 1  ^   Z   V   Q   M   I  @ A@ A @ A@ @ A @ A @    v ɸ  r l  n o  i   e   a   ]   Y     W   R    @ A @ @ A @ A@ @ A@    v     t   o     j     Y     W   R    @ A @ @ A @ A @ @ @      Y    7    5    3                          A?!H $                   p `'!H $                    `'   
  v     n    q     o   o @  o                                                          U  	@      	  '  7  v Y  t   t   t   t                                                          U U 	    y   y   y   y 0  y   y   y @  y   y 0  y                                                              U
0  y  y   y 8  y   y   y x  y ?  y   y   y   y                                                              U
  M  y    y   y   y Q  y   y [  y   y   y   y                                                              U
    y   w   u B  s    s ]!  s !  s "  s #  s                                                              U?YU	#  $  y $  t %  &  r I'  `'  m '  (  )                                                          K U	)  `*  +  o,  c-  -  y .  w E0  u `0  u 0                                                          KW<W	0  -1  1  y 2  P2  w 	3  e3  u 4  4  p 95                                                           WWW	95  5  5  y 5  y #6  y 6  y 37  y 7  y 7  t <9                                                            E	<9  9  9  y 9  y :  y 8:  y :  ;  0<  <                                                            E	<  <  y ^=  y =  y >  y j@  A  B  B  t <C  r                                                         E E	<C  C  y (D  y iD  y D  y D  t TE  r E  r .F  r F  r                                                         E E	F  :G  y G  y H  y CH  t I  r IK  r bK  m L  M                                                          E E	M  "M  y XM  w M  w M  w M  w N  w O  &Q  Q  u                                                         EEEW	Q  T  y !U  y mV  y W  y X  y .Y  y Z  y [  y [  w                                                         EE?E	[  ]  y ]  y 7^  y g^  y ^  y ^  y ^  y ^  y  `  y                                                         EE?E	 `  `  v _a  Gb  b  t b  t 6c  r /d  p Bd  n d  l                                                       WEKWE 	d  e  y f  f  t g  h  o i  &i  Ji  m                                                             W  KJi  i  y i  y i  y j  y j  y j  y j  w k  u Al  u                                                       W EYE	Al  l  y 4m  p ]m  k n  n  n  o  i go  g                                                        EW <    Ego  }o  y o  y o  y p  y p  w p  u q  u xs  u s  l                                                       <    EYE	s  &t  v t  t  q Fu  _u  l u  j "v  v  h                                                         WE   v  v  y v  w >w  u Ex  x  s x  q y  o -z  /z  m                                                       YEYWEYW	/z  fz  y z  z  w z  u <{  s {  {  q {  o ?|                                                        YEYEYWE	?|  u|  y w|  w |  u |  |  s :}  q }  }  o }  m                                                       YWEYEYW	}  5~  y ~  ~  w ~  u A  s   7  q 9  o   m                                                       EYWEYWE	      y 
  w n  u O    s   q 	  o                                                         EEYWEYW	    y $  t b  r   %  p '  n x  l I                                                              EYWE WI  K  y   w v  x    u a  z  p     n                                                       EE EEY	    T  y   y   y O  y Q  w ~  u   !  s                                                       EE WEYW	!    y   w Ѝ  u G  w  s   s   s :  s <  q                                                       EEYWEYW	<    y     w R  u     s Ñ  q [  ]  o                                                       EYEYEYE	]    y 2  4  w   u Z  \  s   q   Օ  o                                                       EEEYEYE	Օ  ]    y ז  C  w   f  u   K  s r                                                        EEEEEEE	r    y   /  w   p  u   V  s     q                                                       EEEEEEE	      y 7  9  ^  t   r     p   n                                                       EEYE E	  k    	  v   C  t   ܢ  r   <  p                                                       EEEEE 	<      y     w     u     s                                                         EEEEEEE	  ɥ  v ˥  t Ҧ    o   m   k `  i ɫ  i                                                          EWE < ɫ  '  y C  w   u   1  p 7  n k  n   n   l                                                       WE WEW	    y z  y   y   t S    r ζ  r 2  r M  r                                                       WEE E	M  x  y   y   y j  y   y ɸ  t   .  r ܺ  r                                                       WEE E	ܺ  I  y   y   y l  y   t `  a    6                                                        WEE E	6  J  y b  y   y     w :  u r  u   u   u                                                       WEEU?E	      y     _   _   _   _                                                                     !?    a (  a ;  a W  G |  G                                                         !               !|    a   G   G   G                                                               !               !  )  a Q  a w  a   G                                                               !               !    a   a   a   a !  G                                                         !               !!  A  a P  G b  G x  G   G                                                         !               !    a       _     T   T                                           
     @?               !    p   p    p .  p >  p M  p Z  p g  p x  p                                                          
     @	x    p   p   p   p   p   p   p   p   p                                                          
     @	    p ,  p E  p [  p j  p }  p   p   p   p                                                          
     @	    p   p   p   p   p -  p <  p O  p b  p                                                          
     @	b  s  p   p   p   p   p   p   p   p   p                                                          
     @	  .  p @  p Q  p b  p q  p   p   p   p   p                                                          
     @	    p   p   p 0  p N  p \  p j  p {  p   p                                                          
     @	    p   p   p                                                                                  
     @ 
     G    q  &  -  O7  CB  /F  L  IX  `  4i  nq  Gx  /}  ς  %    U  b  \    }  a      ;  D                     C      y      	 6   
 e        $           ;    U        R        t    4    i  V                  	             D              ;   D   E           (       03/24/8905/24/88D  
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\overlap.doc ===
1           C,  b z z | } } C:\EDITORS\C#.STY                                                   HPLASMS ~ @     z z     
		--	
	CW API Guide (x.xx) Overlapping Windows	
Character WindowsAPI Guide (x.xx : Overlapping Windows)
Stephen SmithJacques Carette
Microsoft Applications Division
.c.1. Introduction
This is an Appendix to the CW API Guide that details the optional support for overlapping windows.
.c.2. Clipping
With overlapping windows support it is possible for windows to partially or completely obscure other windows.  The display priority that a window has is determined by the window tree.  Child windows will obscure parent windows, and siblings closer to the tail of the sibling chain will obscure siblings closer to the head.  Output to all windows will be clipped to the client area as before.  Output to windows with the new style WS_CLIPOUT will also be clipped if obscured by a window of higher priority.  As well, since windows are no longer required to be contained within their parents, output is clipped to the client area of all the parent windows.
In order to implement the clipping, CW requires additional memory for an overlap table.  You should call the following routines in the same place you call FAllocInstBuffers:
 
.i.FAllocOverlapTable();FAllocOverlapTable(pinst,lpfn_drv_alloc)allocates space for the clipping table.  Returns false if it fails.
pinst is a pointer to the current inst.  This routine requires the screen sizes to allocate the table, so the inst should be filled before calling this routine.
lpfn_drv_alloc is the memory allocation routine you provide for driver memory allocation (LpwAllocDriverMem). Please refer to the API document for installable drivers (cwdrv.doc) for further information.

.i.FreeOverlapTable();FreeOverlapTable(lpfn_drv_free)frees the clipping table.
lpfn_drv_free is the corresponding far memory freeing routine.
An application using overlapping windows should have one main background window created with the style WS_CLIPOUT.  Any children added to this window will inherit this style automatically so any output performed in this region will be properly clipped.  In order to establish the priority of this windows children you should the use the functions: 
Note: The head of the child list is the window in the back, and the tail is on top.  Thus windows closer to the tail of the list will obscure windows that are before it (closer to the head of the list).

.i.AddChildHead();AddChildHead(pwndParent, pwndChild)similar to AddChild.  This child will be obscured by all its current siblings.
.i.AddChildTail();AddChildTail(pwndParent, pwndChild)similar to AddChild.  This child will obscure all of its current siblings.
To move, resize or close windows, the following functions should be used:
.i.MoveWindowOverlap():MoveWindowOverlap(pwnd, ax, ay)move window to position (ax,ay), and all its child windows by the same relative amount as the original window was moved.  Also keeps the clipping table up to date.
.i.SizeWindowOverlap():SizeWindowOverlap(pwnd, drx, dry)change size of current window by (drx, dry).  Keeps the clipping table up to date
.i.CloseWindowOverlap():CloseWindowOverlap(pwnd)closes the specified window.  Will call RemoveChild to actually remove the window and will kepp the clipping table up to date.
After performing one or more of the above operations, the following function should be called to redraw the damaged regions of the screen:
.i.RedrawDamagedRegions();RedrawDamagedRegions()repaints any windows that are effected by the changes in position.
Warning: use of MoveWindow, SetWindowSize, and RemoveChild cannot be used in conjunction with the previous calls and still use RedrawDamagedRegions.  They must be resolved with direct calls to DrawWindow.  Also if, for example, MoveWindowOverlap is called, RedrawDamagedRegions MUST be used before any calls to MoveWindow, SetWindowSize or RemoveChild, and vice-versa. If you do want tu use MoveWindow, SetWindowSize, or RemoveChild, then before drawing your windows, you must call the following function:
.i.RethinkDisplay():RethinkDisplay()recalculates the clipping table used by the drawing routines.
.c.3. Moveable windows
Typically children of the main window should have the style WS_OVERLAP.  Windows with this style are moveable and will interpret mouse actions as follows:  
Mouse click on window: CW will attempt to bring this window to the foreground before interpreting the click.
Mouse click on top left corner: The top left corner acts like a button and will send a WM_CLOSE to the window proc if the button is pressed.
Mouse click on top right corner: Also acts like a button but sends WM_ZOOM if pressed.
Mouse click on left side or top: displays a moveable outline of the window that the user can move around with the mouse.  When the button is released a WM_MOVE is sent.
Mouse click on right side or bottom: displays an outline that changes size as the mouse moves.  When the button is released a WM_SIZE is sent.
On a WM_MOVE or WM_SIZE message, the new location is given in absolute coordinates by ax = HIBYTE(HIWORD(lParam)), ay = LOBYTE(HIWORD(lParam)), and the size by dax = HIBYTE(LOWORD(lParam)), day = LOBYTE(LOWORD(lParam)).  CW will not actually move or size the window, that is up to the application. It is also up to the application to call RedrawDamagedRegions().
To bring a window to the top, CW sends the appropriate window a WM_ACTIVATE message with wParam == TRUE.  To keep things consistent for the application, it also sends a WM_ACTIVATE with wParam == FALSE to the previous foreground window.  The applications can then use the following function to actually bring the window to the foreground:
.i.WindowToTop();WindowToTop(pwnd)brings pwnd to the foreground.
So that the application may provide a keyboard interface for moving and sizing windows, the following routines have been provided:
.i.FMoveOverlapWithKeyboard();FMoveOverlapWithKeyboard(pwnd)draws and outline around the window pwnd and allows the user to move the outline with the cursor keys (control cursor jumps).  When the user hits enter, the WM_MOVE message is sent and TRUE is returned.  If the user hits escape, no message is sent and FALSE is returned.
.i.FSizeOverlapWithKeyboard();FSizeOverlapWithKeyboard(pwnd)similar to FMoveOverlapWithKeyboard.
In order to display these moveable windows, CW provides two new box types; boxActiveWnd, and boxInactiveWindowIn. Active windows have a double line at the top while inactive windows have a single line.  It is recommended that the application display the foremost window using boxActiveWnd, and the others as inactive windows.  In order to determine the top window, the following routines were provided:
.i.FIsTopWindow();FIsTopWindow(pwnd)returns true if pwnd is the foremost of its siblings.
.i.PwndGetTopWindow();PwndGetTopWindow(pwnd)returns the foremost sibling of pwnd.
As well, to make things pretty, the following routine was provided:
.i.DrawOverlapShadow();DrawOverlapShadow(pwnd)casts a shadow on pwnd. ONLY the topmost window can cast a shadow.
.c.4. Other Routines
.c.:4.1 Message Control
Control of overlapping windows, like that of menus, is done via some special message hooks.  This messaging controls the mouse hit detection of the overlapping window borders, as well as the close and zoom icon buttons.
.c.::4.1.1 EnableOverlap
VOID EnableOverlap(BOOL fEnable)
Enable or disable overlapping window messaging.  Usually used in conjunction with enabling/disabling the menu bar (FEnableMenuBar).
.c.::1.1.1 WM_NCLBUTTONDOWN
message .i.WM_NCLBUTTONDOWN;WM_NCLBUTTONDOWN
Special message sent to overlapping windows (windows with WS_CLIPOUT style) when a LBUTTONDOWN mouse would cause overlapped window processing to occur.  This allows the application to change the behavior of overlapped window processing (important to controls placed on borders such as split bars).
If the WndProc returns 0L, then the mouse message is interpreted as usual (overlap window processing occurs).  If the application WndProc returns 1L, then no overlapped window processing occurs (and the mouse event does not otherwise get sent to the window -- i.e. the WM_LBUTTONDOWN never gets sent).
.c.5. Example
Here is a typical window procedure for a moveable overlapping window:
#define axyLast	rgwExtra[0];	// ax,ay of Upper Left Corner
#define rxyLast  rgwExtra[1];	// rx,ry to Lower Right Corner
#define fZoomOut	rgwExtra[2];	// do we zoom out or zoom in

STATIC LONG FAR PASCAL
OverlapWndProc(pwnd, message, wParam, lParam)
/*
  -- Wnd proc for overlaping window
*/
PWND	   pwnd;
WORD      message;
WORD	   wParam;
DWORD	   lParam;
	{
	switch(message)
		{
	default:
		break;

	case WM_PAINT:
		{
		if (FIsTopWindow(pwnd))		// top window so draw 
			{					// as active
			DrawBorder(pwnd,&boxActiveWindowOut,isaUser,NULL);
			FillWindow(pwnd, isaUser);
			DrawOverlapShadow(pwnd);
			}
		else						// not the top window
			{
			DrawBorder(pwnd, &boxInactiveWindowOut,
				 isaUser + 1, NULL);
			FillWindow(pwnd, isaUser + 1);
			}
		}
				break;

	case WM_ACTIVATE:
		if (wParam)
			{
			// request to bring this window to foreground
			WindowToTop(pwnd);
			return((DWORD) TRUE);
			}
		else
			{
			// request to move this window to background
			return((DWORD) TRUE);
			}

	case WM_SIZE:
	case WM_MOVE:
		if (pwnd->fZoomOut)
			{
			// Save the position for zooming
			pwnd->axyLast = HIWORD(lParam);
			pwnd->rxyLast = LOWORD(lParam);
			}
		// The new position and size are given in lParam
		MoveWindowOverlap(pwnd, (AX) HIBYTE(HIWORD(lParam)),
				 (AY) LOBYTE(HIWORD(lParam)));
		SizeWindowOverlap(pwnd, (AX) HIBYTE(LOWORD(lParam)),
				    (AY) LOBYTE(LOWORD(lParam)));
		RedrawDamagedRegions();
		break;

	case WM_ZOOM:
		if (pwnd->fZoomOut)
			{
			// Zoom the window out to fill the main window
			RRC rrc;

			GetClientRrc(PwndParent(pwnd),&rrc);
			MoveWindowOverlap(pwnd,AxOfRx(pwnd->pwndParent,0),
					 AyOfRy(pwnd->pwndParent,0));
			SizeWindowOverlap(pwnd,rrc.rxRight, rrc.ryBottom);
			pwnd->fZoomOut = FALSE;
			}
		else
			{
			// Zoom back to where we were before zooming out
			MoveWindowOverlap(pwnd,(AX) HIBYTE(pwnd->axyLast),
					 (AY) LOBYTE(pwnd->axyLast));
			SizeWindowOverlap(pwnd,(AX) HIBYTE(pwnd->rxyLast),
					    (AY) LOBYTE(pwnd->rxyLast));
			pwnd->fZoomOut = TRUE;
			}
		RedrawDamagedRegions();	// we have moved a window
		break;

	case WM_CLOSE:
		// cleanup associated data
                   . . . 
		CloseWindowOverlap(pwnd);
		RedrawDamagedRegions();
		break;

		}

	return ((DWORD) TRUE);
	}


Revision History
88-8-4	created 
88-8-8	fixed after review of code
88-11-10	changed after optimized redraw implemented (JC)
Table Of Contents
.Begin Table C.
1. Introduction	1
2. Clipping	1
3. Moveable windows	2
4. Example	3
.End Table C.
Index
.Begin Index.
AddChildHead()			2
AddChildTail()			2
DrawOverlapShadow()			3
FAllocOverlapTable()			1
FIsTopWindow()			3
FMoveOverlapWithKeyboard()			2
FreeOverlapTable()			1
FSizeOverlapWithKeyboard()			3
FWindowToTop()			3
PwndGetTopWindow()			3
RedrawDamagedRegions()			2
RethinkDisplay()			2
.End Index.
܀         v       q   1  m 2  h 4  7  f     d j  t  b     ` 			 @@ @ @ @  (  y     w &  4  u     s   q F  S  o     m 	  	  k 	  i 8
  J
  g 			J
  V
  y     w -  u     s 	  q m    o   m     k     i   g   J
  g 				  .  y <  w ~    u     s     q s  z  o    '  m     k     i   		    y +  1  w H  N  u v  |  s     q n  y  o     m     k     i       y   w     u I  g  s   q     o #  *  m     k   i     g 				    y     w     u   s 6  :  q     o   m     k     i     g 				      y    -  w   u   s   q     o     m   k g   j   i *  *  d    @				*  *  *  v +  +  q 6,  C,  l   q     o     m   k g   j   i *  *  d    @	 @ @ @      Y    Y    7    5   Z               I   o?!H $                   p `'!H $                    `'     y 4  y H  t   o   j L  e   e   `   I         I   I   I   I   I   I Y =  =  A    v &  v   v   q F  l   l   g 	  g   I   I   I   I   I   I   I   I Y == E Y E 	  	  v 8
  q 
  q   l   g m  g   g   b   I   I   I   I   I   I   I   I Y= E = E Y     v   q ~  l   g 4  b   ] 0  ]   I   I   I   I   I   I   I   I   E =  E = E 0    v 2  v   v .  q   q   l I  g   b   I   I   I   I   I   I   I   I E = E = E     v   q   l =  l   g   b   ]   I   I   I   I   I   I   I   I    E = E = E   $  v   q   l =  g   b   ]   X   I   I   I   I   I   I   I   IE  = W  =    8  v g   v v   q    l    a 7!  a s!  a u!  a   I   I   I   I   I   I   I   I 
<    =  = u!  !  p !  p !  p !  p !  p !  p "  p "  p /"  p   I   I   I   I   I   I   I   I   I = 
<    	/"  3"  p E"  p J"  p U"  p _"  p a"  p r"  p w"  p "  p   I   I   I   I   I   I   I   I   I = 
<    	"  "  p "  p #  p 4#  p :#  p ]#  p c#  p #  p #  p   I   I   I   I   I   I   I   I   I = 
<    	#  #  p #  p #  p #  p #  p #  p $  p $  p @$  p   I   I   I   I   I   I   I   I   I = 
<    	@$  W$  p q$  p w$  p $  p $  p $  p $  p $  p $  p   I   I   I   I   I   I   I   I   I = 
<    	$  $  p $  p %  p %  p :%  p ^%  p %  p %  p %  p   I   I   I   I   I   I   I   I   I = 
<    	%  %  p &  p P&  p w&  p &  p &  p &  p &  p &  p   I   I   I   I   I   I   I   I   I = 
<    	&  &  p &  p '  p '  p 6'  p m'  p '  p '  p '  p   I   I   I   I   I   I   I   I   I = 
<    	'  '  p '  p '  p -(  p d(  p (  p (  p (  p )  p   I   I   I   I   I   I   I   I   I = 
<    	)  )  p <)  p F)  p H)  p Y)  p w)  p )  p )  p )  p   I   I   I   I   I   I   I   I   I = 
<    	)  )  p )  p )  p )  p )  p )  p )  k )  k   I   I   I   I   I   I   I   I   I   I= 
<    )  *  v "*  q E*  q *  q *  l *  g         I   I   I               I   I   I   I   I  = ? U ? *  *  a *  a *  a *  a *  \ *  \ +  W   I   I   I   I               I   ? =                !+  +  v %+  q 9+  q R+  q l+  q +  q +  q +  q +  q         I   I   I   I   I   I   I   I      = 	+  +  v ,  v  ,  v 6,  v C,  q D,  +  q +  q +  q         I   I   I   I   I   I   I   I     =  	 
         u  !  H'  )   *  {*  +      ^    X                                  	     {*   +           (       01/15/8904/07/88+  
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\size.txt ===
TWIN		CW
				====		====
MOUSE				337		307
EVENT				2586		1849
WINDOW				4050		4526
MENU				3662		3999
DIALOG				7784		9633
SDM				0		5331
KEYBOARD			1485		1477
MISC				674		832

Total less Edit:		22063		27954
				(including data CW 5.3K bigger)

EDIT				8216		2631


Total:				30189		30585

Data+BSS:			2082		1510

============================================================
========================= CW ===============================

---------- MISC ----------
STARTUP : 48
HELPSTUB : 60
UTIL : 772

---------- MOUSE ----------

MOUSE : 307

---------- EVENT ----------

ALARM : 106
EVENT : 1743

---------- WINDOW ----------

COLOR : 109
WINDOW : 2005
SCREEN : 1833
BOX : 579

---------- MENU ----------
MENU : 3867
MENU2 : 132

---------- DIALOG ----------

DIRLIST : 1337 (now in shell)
DLGCORE : 1398
DLGUTIL : 284
MSGBOX : 616
STATIC : 289
LISTBOX : 2969
GENERAL : 89
BUTTON : 1543
SCROLL : 1108

---------- SDM ----------

SDM : 4166 (with DIRLIST)
SDMCAB : 451
SDMTMC : 692
SDMASM : 22

---------- KEYBOARD ----------
KEYBD3 : 546
KEYPOLL : 931

---------- EDIT ----------
EDIT : 2631


============================================================
========================= TWIN ===============================

---------- MISC ----------
FSTRING : 142
STRINGC : 224
UTIL : 308
---------- MOUSE ----------
MOUSE : 337
---------- EVENT ----------
ALARMC : 166
EVENTC : 2420
---------- WINDOW ----------
BOXC : 246
SCREEN : 3000
WINDOWC : 804
---------- MENU ----------
MENUC : 3622
---------- DIALOG ----------
DIALOGC : 2218
BUTTONC : 1028
DIR : 96
LISTBOXC : 2382
MDIALOG : 514
MSGBOXC : 584
SCROLLC : 962
---------- KEYBOARD ----------
KB : 457
KBC : 1028
---------- EDIT ----------
EDIT : 80
EDIT1 : 4744
EDIT2 : 3393
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\keyusa.txt ===
VK -> ASCII Translation for USA keyboard driver :
=================================================
labelB	AsciiTable		;base,shift,control
VK			norm	shift	control
----------		----	-----	-------
VK_CANCEL		3	3	3
VK_BACK 		8	8	127
VK_TAB			9	9	--
VK_RETURN		13	13	10
VK_ESCAPE		27	27	27
VK_SPACE		' '	' '	' '
VK_EXECUTE		13	13	10
VK_0			'0'	')'	--
VK_1			'1'	'!'	--
VK_2			'2'	'@'	0 **
VK_3			'3'	'#'	--
VK_4			'4'	'$'	--
VK_5			'5'	'%'	--
VK_6			'6'	'^'	30 **
VK_7			'7'	'&'	--
VK_8			'8'	'*'	--
VK_9			'9'	'('	--
VK_A			'a'	'A'	1
VK_B			'b'	'B'	2
VK_C			'c'	'C'	3
VK_D			'd'	'D'	4
VK_E			'e'	'E'	5
VK_F			'f'	'F'	6
VK_G			'g'	'G'	7
VK_H			'h'	'H'	8
VK_I			'i'	'I'	9
VK_J			'j'	'J'	10
VK_K			'k'	'K'	11
VK_L			'l'	'L'	12
VK_M			'm'	'M'	13
VK_N			'n'	'N'	14
VK_O			'o'	'O'	15
VK_P			'p'	'P'	16
VK_Q			'q'	'Q'	17
VK_R			'r'	'R'	18
VK_S			's'	'S'	19
VK_T			't'	'T'	20
VK_U			'u'	'U'	21
VK_V			'v'	'V'	22
VK_W			'w'	'W'	23
VK_X			'x'	'X'	24
VK_Y			'y'	'Y'	25
VK_Z			'z'	'Z'	26
VK_NUMPAD0		'0'	'0'	--
VK_NUMPAD1		'1'	'1'	--
VK_NUMPAD2		'2'	'2'	--
VK_NUMPAD3		'3'	'3'	--
VK_NUMPAD4		'4'	'4'	--
VK_NUMPAD5		'5'	'5'	--
VK_NUMPAD6		'6'	'6'	--
VK_NUMPAD7		'7'	'7'	--
VK_NUMPAD8		'8'	'8'	--
VK_NUMPAD9		'9'	'9'	--
VK_DECIMAL		'.'	'.'	--
VK_OEM_PLUS		'='	'+'	--
VK_OEM_COMMA		','	'<'	--
VK_OEM_MINUS		'-'	'_'	31 **
VK_OEM_PERIOD		'.'	'>'	--
VK_OEM_1		';'	':'	--
VK_OEM_2		'/'	'?'	--
VK_OEM_3		'`'	'~'	--
VK_OEM_4		'['	'{'	27
VK_OEM_5		'\'	'|'	28
VK_OEM_6		']'	'}'	29
VK_OEM_7		"'"	'"'	--
VK_MULTIPLY		'*'	'*'	--
VK_SUBTRACT		'-'	'-'	--
VK_ADD			'+'	'+'	--
VK_DIVIDE		'/'	'/'	-- 
VK_DELETE		7fh	7fh	--


NOTES : -- => no character
	** => must be SHIFT + CTRL
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\mskey.doc ===
1           lR        C:\EDITORS\C#.STY                                                   HPLASMS                      --
		MSKEY Menus and Dialogs				
Character WindowsMSKEY VAPGeneral DescriptionPRELIMINARY
Chris PirihMicrosoft Applications Division
.c.1. Overview
The MSKEY VAP is a replacement of the MSKEY TSR (Version 1) for MS-Works.  It is intended to have all the features of the original MSKEY TSR, but to be more compatible with Works and CW apps in general.  Thus the menus and dialogs will be completely restructured to fit in better with Works' user interface, while the basic functionality and file format will be compatible with the MSKEY TSR.
.c.2. Dialogs and Menus
.c.:2.1. The MSKEY VAP menu
When the MSKEY VAP is active (as defined in the VAP specification), it takes over the VAP drop-down menu and fills it with one of two sets of items, depending upon what MSKEY is currently doing.  When idle (i.e., when not Recording), MSKEY presents the following items on the VAP menu:
Record		Commence key recording
Edit			Edit defined keys or define new ones
Open			Load the contents of a MSKEY macro file
Save			Save current key definitions [and settings?] in a macro file
Save As		Save in a user-specified file
Suspend		Turn off MSKEY without uninstalling it

While a key is being recorded, MSKEY presents a different VAP menu, with the following items:
Skip			The next key pressed will not be translated
Finish		Ends the Recording process, defining a key
Cancel		Aborts the Recording process
Special		Pops up the Macro Recording Special Effects dialog (to insert MSKEY commands into a recording)
.c.:2.2. Macro Editing
When the Edit command is chosen from the MSKEY VAP menu, it begins the Edit dialog: (it will be bigger on the screen, so ignore how stuff is all jammed together)
+----------------------------------------------------------------+| Key:           Title:                                          || [<altx>     ]  ['Twas brillig and the slithy toves did gyre a] ||                                                                || Keys defined:  Definition:                                     || +-----------+  [<ctrlend><enter>Enter text...<enter><vfld>_  ] || |<k->       ^                                                  || |<ctrlesc>  #  Commands:                                       || |<ctrlback> X  +-----------+   [ ] Translate now               || |<alt->     X  | <execute> ^                                   || |<alt=>     X  | <pause>   #   <Skip>  <Expand>                || |<altx>     X  | <vfld>    X                                   || |<altz>     X  | <ffld>    X                                   || |           X  | <nest>    X                                   || |           X  | <mskey>   X                                   || |           X  | <record>  X                                   || |           X  | <skip>    X                                   || |           X  | <finish>  X                                   || |           v  | <cancel>  v                                   || +-----------+  +-----------+                                   ||----------------------------------------------------------------||                   <Done>  <Cancel>  <Delete>  <New>    <Close> |+----------------------------------------------------------------+
Note:  <New>, and maybe <Delete> too, should have a confirmation dialog (i.e., "Really?  <Yes> <No>").
.c.:: 2.2.1. Explanation of dialog fields
Key:
When this field is selected, it accepts a single key from the keyboard, and translates it to its keyname.  If the key has already been defined (i.e., it appears in the 'Keys defined' list box) then the 'Title' and 'Definition' fields are filled with the current title and definition of the key, respectively.  All keys are literal in this field, i.e., <tab>, <enter>, edit keys, etc simply expand to their respective key names rather than moving the cursor around.  As soon as a key is pressed, the focus shifts to the 'Definition' field, and the user may enter/edit the key's definition.
Keys defined:
This list box contains the names of all the keys that currently have macros assigned to them.  When an item in this box is selected, it is copied to the 'Key' field, and its definition and title appear in the appropriate edit fields.  Note that if a currently unassigned key is selected in the 'Key' field, it is not added to the 'Keys defined' list box until its definition is completed.
Title:
This edit field contains the title text associated with the currently selected key.  This is a standard CW edit field.
Definition:
This edit field contains the keynames and macro commands assigned to the currently selected key.  This is a special edit field, in which most keys are expanded to their key names upon being pressed, which are treated as atomic tokens.  Certain keys are reserved for editing, including <home>, <end>, <left> <right>, <shifthome>, <shiftend>, <shiftleft>, <shiftright>, <del>.  In addition, <tab> and <shifttab> are used to shift focus away from the 'Definition' field (as in standard CW dialogs).  To enter any of these keys into the definition, the user must click the <Skip> button before pressing the key.
Key names can also be typed in as text.  For example, to add the <pgup> key to the definition, one can either press the <pgup> on the keypad, or actually type the text "<pgup>".  The actual text "<pgup>" can be entered into a definition by breaking up the token with the null pseudo-key, e.g. "<pgup<>>" or "<pg<>up>", etc.  (The null pseudo-key, <>, is an artificial key which does nothing on playback.)
Commands:
This list box contains a set of pseudo-keys that can be inserted into a definition to produce special macro effects upon playback. When the user selects one of these, it is added to the current definition (in the 'Definition' field), and is treated like a normal key.  Certain of the commands take parameters, which are solicited [in a command-specific pop-up dialog?] when the command item is selected.  The commands and their effects are:
<execute k>	Executes the macro assigned to the key whose name is k.
<pause n>		Pauses macro execution for n seconds.
<vfld>		Suspends macro execution while the user enters literal keys.  Macro execution is resumed when the user hits <enter>.  [Or maybe the key defined as <resume>?]
<ffld n>		Suspends macro execution while the user enters n literal keys.  Macro execution is then automatically resumed.
<nest k>		Suspends macro execution while the user enters literal keys, which are assigned as a macro to key k.  Macro execution resumes when the user hits <enter>.  [Or <resume>?]

The following commands/pseudo-keys are the definitions assigned to the MSKEY "hot keys":
<mskey>		Activates MSKEY as the current VAP, and opens the MSKEY VAP menu.
<record>		Calls up the Macro Record dialog to begin key macro recording.
<skip>		Suppresses translation of the next key pressed into its macro definition.
<finish>		Terminates key macro recording successfully.
<cancel>		Cancels key macro recording, leaving the key unchanged.

Translate now:
If this check box is enabled, keys are translated to their macro definitions (if any) before being entered into the 'Definition' edit field (i.e., if <ctrlx> is defined as '<alta> bc <tab> <left>', then '<alta> bc <tab> <left>' is inserted when <ctrlx> is pressed).  If it is disabled, literal keys are inserted, regardless of their definitions.
Buttons:
<Skip>		The next key pressed is entered into the key definition.  This allows the editing keys and the <tab> key to be entered into definitions. Note that this does NOT prevent macro translation when the 'Translate now' check box is enabled.
<Expand>		Expands the selected key(s) in the 'Definition' field to their macro definitions.  [Alternatively, it can expand the next key pressed into its macro definition.]
<Done>		Assigns the contents of the 'Definition' field as the macro definition of the key in the 'Key' field, and enters the key into the 'Keys defined' list box.
<Cancel>		Cancels the definition in progress, returning the previous definition and title, if any, in the appropriate edit fields.
<Delete>		Removes the macro definition of the currently selected key and removes it from the 'Keys defined' list box.
<New>		Removes all current definitions.
<Close>		Closes the Macro Edit dialog.  [Alternatively, this button can be removed and <Done>, <Cancel>, and <Delete> can close the dialog.]

.c.:2.3. Macro Recording
+-----------------------------------+| Press the key you wish to record. |+-----------------------------------+
Waits until a key is pressed.  If the key is the 'Cancel' hot-key (i.e., defined as <cancel>), recording is aborted immediately. Otherwise, recording commences: a status message (see the VAP spec) containing "RECORD k" is displayed, where k is the keyname of the key being recorded.  If the <mskey> hot key is pressed during recording, a smaller version of the Macro Edit dialog box pops up.
.c.::2.3.1. The Macro Record Special Effects dialog
+-----------------+| Commands:       || +-------------+ || | execute     ^ || | pause       # || | vfld        X || | ffld        X || | nest        X || | mskey       X || | record      X || | skip        X || | finish      v || +-------------+ ||-----------------||       <Cancel>  |+-----------------+
This is basically just the 'Commands' list box from the Macro Edit dialog.  An item is selected, its parameter (if any) is entered, and macro recording resumes.
Striking the 'Finish' hot key (the key defined as <finish>) completes the macro recording, removing the 'RECORD k' message from the status line and assigning the keys typed to the key recorded.
.c.:2.4. The Open dialog:
+-----------------------------------------------+| File:                   Drives / Dirs         || [BMACRO.MSK_      ]     +-----------------+   ||                         | ..              ^   || Choose:                 | BACKUP          #   || +-----------------+     | JUNK            X   || | BMACRO.MSK      ^     | [-A-]           X   || | KEY1.MSK        #     | [-B-]           X   || | OTHERS.MSK      X     | [-C-]           X   || |                 v     | [-D-]           v   || +-----------------+     +-----------------+   ||                                               ||                         D:\WORKS\WPFILES      |+-----------------------------------------------+|                               <OK>  <Cancel>  |+-----------------------------------------------+
If a macro file is opened while another is already in memory, the following dialog appears:
+--------------------------------------------------+|  There are already macro definitions in memory!  ||--------------------------------------------------||                    <Replace>  <Merge>  <Cancel>  |+--------------------------------------------------+
.c.:2.5. The Save As dialog:
+-----------------------------------------------+| File:                   Drives / Dirs         || [BMACRO.MSK_      ]     +-----------------+   ||                         | ..              ^   || Choose:                 | BACKUP          #   || +-----------------+     | JUNK            X   || | BMACRO.MSK      ^     | [-A-]           X   || | KEY1.MSK        #     | [-B-]           X   || | OTHERS.MSK      X     | [-C-]           X   || |                 X     | [-D-]           v   || |                 X     +-----------------+   || |                 v                           || +-----------------+     D:\WORKS\WPFILES      |+-----------------------------------------------+|                               <OK>  <Cancel>  |+-----------------------------------------------+
.c.3. Key Names
There are several classes of keys: text keys, control/function keys, pseudo-keys, and hot keys.
Text keys are keys which have ASCII values, and are represented by those ASCII characters.  For example, the spacebar is represented by the space character, ' ' (without the quotes, of course); the 'T' key is represented by 't' or 'T', depending upon shift states.  Text keys include upper- and lower-case alphabetic keys, numeric keys (main keyboard), punctuation keys, and the spacebar (unshifted).  Also included are all the extended ASCII keys (128 to 255).
Control/function keys are the remaining non-text keys that can be entered from the keyboard.  This includes alt- and ctrl-key combinations (e.g. Alt-A, Ctrl-7, etc), special function keys (e.g., Esc, F1, Enter, Home), and extended/numpad keys (e.g., numpad '3' (only available with NumLock on), grey '+', grey Enter).  The special function and numpad keys are represented by their name surrounded by angle brackets (e.g. <esc>, <enter>, <f1>, <k3>).  Alt, Ctrl, and Shift key combinations are represented by "alt", "ctrl", or "shift", repsectively, preceding the key's name, all surrounded in angle brackets (the brackets, if any, are omitted from the base key's name).  Examples: <shiftspace>, <ctrlx>, <alt3>, <shiftf1>, <ctrlesc>, <altk+> (Alt with keypad '+').
Pseudo-keys and hot keys are special functions that can be included in macro definitions, but cannot be entered via normal keystrokes.  They must be inserted into key macros by means of the special Edit dialog items, or by typing their names in the Edit dialog's Definition field.  Pseudo-keys are special functions provided by MSKEY which are generally useful in key macros.  Hot keys are [CW/VAPI supported?] functions that call up installed VAPs.
.c.:3.1. Control/Function keys:
<esc>		Escape (Esc)
<f1> to <f12>	Function keys
<back>		Backspace
<tab>		Tab
<enter>		Enter
<ins>		Ins
<del>		Del
<end>		End
<down>		Down arrow
<pgdn>		Pg Dn
<left>		Left arrow
<clear>		Middle numpad key (unshifted 5)
<right>		Right arrow
<home>		Home
<pgdn>		Pg Dn
<kX>			Numeric keypad key, where X is one of 0 to 9, '.', '/', '*', '-' or '+'.
<kenter>		Keypad Enter
<insert>		Extended keypad Insert
<chome>		Extended keypad Home
<pageup>		Extended keypad Page Up
<delete>		Extended keypad Delete
<cend>		Extended keypad End
<pagedown>	Extended keypad Page Down
<cup>		Extended keypad up arrow
<cleft>		Extended keypad left arrow
<cdown>		Extended keypad down arrow
<cright>		Extended keypad right arrow
<altX>		Alt-X, where X can be an ASCII character (for text keys) or a function key name (sans angle brackets)
<ctrlX>		Ctrl-X, where X is as above
<capsX>		Shift-X, where X is as above
.c.:3.2. Pseudo-keys
<vfld>		Pauses playback, allowing keys to by entered from the keyboard, until <enter> is pressed
<ffld N>		Pauses playback, allowing N keys to be entered from the keyboard (N is an integer)
<pause T>		Pauses playback for time T (hh:mm:ss.t)
<execute K>	Executes the macro assigned to key K
<nest K>		Pauses playback, allowing keys to be entered from the keyboard until <enter> is pressed, whereupon those keys are assigned as a macro to key K
.c.:3.3. Hot keys
<mskey>		Activates the MSKEY VAP and drops its menu
<record>		Begins key recording
<skip>		Supresses translation of the next key pressed
<finish>		Ends key recording
<cancel>		Aborts key recording
.c.4. File Format
A MSKEY macro definition file consists of zero or more key definitions, each of which has the following format:
* {TITLE}<begdef>{KEY_NAME}{MACRO_TEXT}<enddef>
Where: {TITLE} is any text at all, and is assigned as the title of the key about to be defined (this line is optional); {KEY_NAME} is the name of the key to be defined (see key names, above); {MACRO_TEXT} is the textual representation of the macro, i.e., the key names of the keys assigned to [KEY NAME].
.c.5. Internals
.c.:5.1. Interacting with CW
.c.:5.2. Dialogs.
.c.:5.3. Miscellaneous screen output.
.c.:5.4. Low-level keyboard control.
.c.:5.5. Hot keys?
.c.:5.6. Special edit fields (key definitions).
.c.:5.7. Memory management.
.c.:5.8. Interacting with the VAP Interface
All calls to CW will probably be routed through the VAPI somehow.
.c.:5.9. Hot keys?
.c.:5.10. Menus (File and Vap).
.c.:5.11. Macro storage format
Each macro must include: the key defined, the title text, the sequence of keys composing the definition.  The title text can be a regular sz.  The storage of each key should include a CH (byte), VK (byte, actually a VW), and a KK (word).  We also need some way to refer to pseudokeys.  Probably CH = VK = 0, and KK replaced by a pseudokey code (since shift-state transitions are not recorded, except Alt, which is special anyway).  [Or maybe CH = VK = KK = 0, followed by a pseudokey code of some sort?  Maybe a special KK field (since MSKEY probably won't need to deal with some fields, like KK_xLOCK), with the CH and VK replaced by a pseudokey code?]
A single macro can be stored as a single block of memory containing the key defined (4 bytes), the title (n+1 bytes), the definition (4 bytes/key), and a terminating sentinel pseudokey (4 bytes).  [Alternately, definition can be counted rather than sentinel-terminated.  Very alternately, the definition could be a linked list of keys, but I see no real advantage in this.  It all depends on how memory management is done in VAPs.]
The macros in memory should be linked into a list, even if they are treated as one block of memory, so that the entire collection can be scanned rapidly.  This is probably going to need some kind of optimization, since a lookup is performed each time a key is pressed, and is usually unsuccessful.  [Maybe some kind of flag array with CH or VK indices.]
.c.:5.12. Key matching
Some shift states are not significant; some are only significant in certain circumstances.  There's going to be a hairy formula determines whether an incoming key has a macro assigned to it, and another hairy formula that turns a key into text, etc. etc.
For example, alphabetic keys require attention to CapsLock as well as Shift, where other keys do not.  [Maybe we should just ignore the KK_xLOCK states, and use only CH, VK, KK_SHIFT/CONTROL/MENU/EXTENDED for comparison purposes?  I still think KK_SHIFT should be ignored for alphabetic keys.]
.c.6. Unresolved Questions:
.c.:6.1. Hot keys.
If hot keys are just key macros, what happens when we load in a macro file?  Are the hot keys wiped out with the rest of the old definitions?  Must all hot keys be defined in every macro file?
Perhaps we can have a 'hot-key' attribute that prevents these keys from being erased with other macros.  We might also have a 'hot-key' check box in the Macro Edit dialog that enforces certain restrictions on the key's definition (e.g., the key can only be defined as a single hot-key command), as well as setting the 'hot-key' attribute.
If the distinction between hot keys and macro keys turns out to be really clear (and necessary), we might even have an entirely separate "Hot key" dialog.  One advantage to this is that it allows the user to pop up a list of hot keys, and not have to hunt through the entire list of macro definitions just to find them.
.c.:6.2. Possible alternate Macro Edit dialog:
+------------------------------------------------------------------+| Key:           Title:                                            || [<altx>     ]  ['Twas brillig and the slithy toves did gyre and] ||                                                                  || Keys defined:  Definition:                                       || +-----------+  [<ctrlend><enter>Enter text...<enter><vfld>     ] || |<k->       ^                                                    || |<ctrlesc>  #  Hot keys:       MSKEY commands:                   || |<ctrlback> X  +------------+  +------------+     <Literal>      || |<alt->     X  | mskey      ^  | execute    ^                    || |<alt=>     X  | record     #  | pause      #       <Skip>       || |<altx>     X  | skip       X  | vfld       X                    || |<altz>     X  | finish     X  | ffld       X                    || |           X  | cancel     X  | nest       v                    || |           X  | calculator X  +------------+                    || |           X  | thesaurus  X                                    || |           X  | email      X  [ ] Translate now                 || |           X  |            X                                    || |           v  |            v  [ ] Hot key                       || +-----------+  +------------+                                    ||------------------------------------------------------------------||                     <Done>  <Cancel>  <Delete>  <New>    <Close> |+------------------------------------------------------------------+
.c.:6.3. File format:
The current file format is quasi-idiotic.  We might make a new one, but I haven't dreamed it up yet.  We'll have to support the old file format anyway, for compatibility with the MSKEY TSR.  File format is not really an important issue unless our macro editor is insufficient for power-user macros.
                             v       q       n   l   g   e   c     a     _    ^`			   @   @ @  	  x !  #  v '  s P  T  p     m     j     g     d     a 	               x     v v  z  t     r 0  5  p 7  >  n @  X  l ]  c  j e    		 e  j  y l  r  w s  z  u |    s     q     o     m     k     i        y y    w     u     s     q     o A  J  m s  y  k        y     w   "  u     s /  6  q =  E  o     m     k <  B  i  B      y     w     u     s     q     o     m     k        y     w     u     s     q     o t  |  m !  '  k     i    I   Q   y       v       t @!  F!  r H!  P!  p V!  ^!  n y!  }!  l Z"  b"  j )#   	 )#  0#  y #  #  w %  %  u j&  n&  s a)  e)  q *  *  n +  +  l .  .  j L.  O.  h 		 		O.  N5  R5  y 9  9  w :  :  u ;  ;  s =  =  q =  =  o =  =  m =  =  k >  									>  >  y 3>  7>  w G>  K>  u x>  |>  s >  >  q ?  	?  o ?  ?  m :?  >?  k ?  ?  h  								?  D  E  y <G  ?G  w YG  ]G  u J  J  s P  P  p (Q  ,Q  n lR  :?  >?  k ?  ?  h  		 				      i    W    U   S $  N   I   D   ?   : P  =   =  C?C             B!            	  #  p P  p   p   p   p   p    p   `   U   U   U v  U   P  
F#  @>       
F#  @  1  v 7  f   a   \   W   R -  M   H   C 3  > =  =  =   = B!  0   = 
3  @  v   q 7  q B  l   g A  \ s  \   \   \ I  \ K  W   R =  = < 
F#  @=  =      p <  p   p   p 
  p   p   k w  f   a t  V !  V   V I   V    V  
F#  @ =  
F#  @      p w!  p y!  p !  k "  [ #  V #  Q %  A %  < j&  < = B!  0    = B!  0    
F#  @
j&  &  v )  f *  a +  Q ++  L L.  < ].  7 .  2 %=  B!  0    B!  0   = B!  0    .  0  v 3  v N5  v o5  q 5  f 5  f 5  f 5  f 5  f 5  f 5  f 5  f 6  f 6  f +6  f U6  f k6  f 
F#  @ = k6  y6  p 6  p 6  p 6  p 7  p 27  p U7  p w7  p 7  p 7  p 7  p  8  p %8  p L8  p 8  p 8  p 9  p 
F#  @
F#  @9  9  v 9  k 9  k :  k D:  k :  k :  f &;  [ F;  [ };  [ ;  [ ;  [ ;  V L8  p 8 
F#  @ 
F#  @ ;  ?<  v r<  q =  l =  g =  b =  b >  b 3>  b G>  b x>  b >  b >  b ?  ] ?  X 8 =   = M = ?  :?  v Z?  v A  q C  q D  q E  l F  g <G  g YG  b mG  ] /H  X I  X J  X ?  X 8=   =  =  J  J  v (Q  f ?Q  a kR  \ lR  \ mR  F  g <G  g YG  b mG  ] /H  X I  X J  X ?  X 8= =  B!  0      Q   Q   check internal CW states as well as validating the interfaces to CW routines.
In additiage	28
12. Menu
                 #   *   h5   ;  	 C  
 DJ  r	28
12.1.3 EnableMenu	29
12.1.4 EnableMenuItem	29
12.1.5 Che ( 4 5 ? [ \ d l MSKEY VAP description Chris Pirih  MSKEY VAP rough outline at this point  9/13/88 8/22/88 Q  .2 Menu Creation Macros	30
13. Help	31
14. Miscellaneous	32
14.1 Misc System Routines	32
14.1.1 ClockTicks	32
14.1.2 Beep	32
14.1.3 Click	32
14.2 Dialog Boxes	32
14.2.1 MessageBox	32
14.3 Scroll Bar Functions	33
14.3.1 SetScrollPos	33
14.3.2 Get24
9.6 Coordina
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\tsr.txt ===
TSR interface of CW apps to Key macro packages (MSKEY)
======================================================

The following interface is applicable for version 1.0 of Works:
(compatibility with future versions is not guaranteed).


When a CW App is started, it attempts to communicate with any TSR applications
that may be present by issuing and interrupt 16H with the following parameters:

	AX = 55FEH
	DX = 0			-- version number
	ES:BX = far pointer to call-back function
	DS:CX = far pointer to repeat flags

If a keyboard TSR is present, it will return :

	AX = 4D4BH		-- ASCII "MK" -- NOT "MS" !!!
	(registers BX, CX and DX may be trashed)

When a TSR has returned this value, the CW app will not hook the INT 9 keyboard
BUT the TSR MUST process keyboard input as detailed below (the 5500H interface).
All other features (the call-back function, and termination) will be provided
regardless of the return code (i.e. a TSR may use the call-back if it does
not want to provide full keyboard support).

Requesting Polling:
===================

The TSR will request that the keyboard gets polled by calling the call-back
function with AH == 0.  This routine may trash AX, BX, CX and DX.
This call should be called at INT 9 time.

Repeat key support:
===================

If a TSR is present, the CW App will not hook INT 9.  Since we need some
knowledge of what the keyboard is doing in order to handle special key
repeat and such the following is required:

1) at initialization (55FE), the TSR must save the far pointer to the
	two repeat flags (DS:CX), i.e.

	mov	word ptr [lpRepeat],cx
	mov	word ptr [lpRepeat+2],ds

2) at INT 9 time (when the user types a key)

	assuming AL = value read from keyboard (bit 7 => break)

	mov	ah,al
	and	ah,80H			;* 80H if up, 00 if down
	cmp	al,0E0H
	je	dont_touch_fkey		;* skip for extended key
	mov	es:[bx],ah
	cmp	al,0F0H
	je	dont_touch_fkey		;* skip for break
	or	es:[bx+1],ah
dont_touch_fkey:



3) whenever a macro is activated (actually playing back), the first flag
	should get set:

	les	bx,lpRepeat
	mov	byte ptr es:[bx],1
	

Request ALTUP ignored:
======================

The TSR can request that the application ignore the next release of the
ALT key (to prevent from going into menu mode).  The call-back function
is called with AH == 1.
This call should NOT be called at INT 9 time.

Any time a shift state transition of ALT UP (bit 3 of shift states going
from on to off) occurs that the TSR does not want to go into menu mode,
the TSR should do the following:

	at INT 16 time, just before returning the new shift state with the
	ALT off, call the callback with AH == 1.


Special ESCAPE case:
====================

There are two different ESCAPE keys that the TSR can feed the application,
a keyboard ESCAPE and a macro ESCAPE.  A keyboard ESCAPE is an escape typed
from the keyboard in normal mode, this can serve as an abort.  A macro ESCAPE
is an escape either played back from a macro or while recording a macro.
A macro ESCAPE should not flush any keyboard buffer, a keyboard ESCAPE should.
To facilitate this, the TSR will send macro ESCAPE keys in the normal buffer,
but for keyboard ESCAPEs the following will be performed:

1) the TSR will call the application's call back function with AH == 2.
2) the TSR will flush it's internal buffer (including the ESCAPE).

This call should be called at INT 9 time.


Leaving:
========

When the App no longer wants to talk to the TSR it issues an interrupt 16H with:

	AX = 55FEH
	DX = -1				-- I'm leaving now

	BX = 0				=> leaving for all time
	BX = 1				=> leaving for a sub-shell


Getting Keys:
=============

The CW App will request keys from the TSR by performing an INT 16H with :
	AX = 5500H

and the TSR will respond with:
	Z flag => no character available
	AL = ascii character code
	AH = scan code
	BL = shift state
	BH = extended shift state

The TSR must maintain the shift states properly, including the extended
shift states (the space bar) and return valid shift states (in BX) regardless
of whether a character is available.

Backward Compatibility:
=======================

In order for a TSR package to work with both WORD and WORKS, it must respond
to both the 55FFH and 55FEH hooks (please note that the video functions of the
55FFH hook (WORD) are not applicable with the 55FEH hook (WORKS)).

For an application that supports the 55FEH interface, supporting the keyboard
extensions for the 55FFH interface is very easy.  The 5500H interface is
backwardly compatible, and the only difference is the call-back function
does not exist for the 55FFH interface.


Extended Shift States:
======================

The extended shift state is defined as follows :

bit 0		: 1 if SPACEBAR key was depressed when the key was depressed
				0 otherwise
bits 1 .. 7	: reserved


Proper TSR Operation:
=====================

The TSR must pass to the CW App certain cases of keys and shift states
that do not exist in the standard BIOS.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\keys.txt ===
OVERVIEW

A wide variety of key events are reported to CW by the keyboard
driver, including many not available through DOS or BIOS calls.  In
general, any key when pressed sends a WM_CHAR message, and continues
sending the same message at a rate specified by the wRateKeyRepeat
parameter.  The spacebar also sends a WM_KEYUP message when released.
Shift keys do not generally send a message; the exception to this is
the Alt (or Menu) key when sends a WM_CHAR on first press (no repeat)
and a WM_KEYUP upon release.  Shift key action (including Shift, Alt,
Ctrl, and the 'Lock' keys) is reflected immediately in the current
shift state, and CW is notified through the appropriate call-back
(DoShift, maybe????).

A key message includes the following information:

message = WM_CHAR or WM_KEYUP, as noted above
wParam = the ascii code for the key, or the VK if none exists
vk = LOWORD(lParam) = the VK code for the key
kk = HIWORD(lParam) = the shift state during the key event

***************************************************************************

		SHIFT STATES AND CORRESPONDING KEYS

Key		Shift state	Note
----		------------	-----
Shift		KK_SHIFT	while held
Ctrl		KK_CONTROL	while held
Alt		KK_MENU		while held
Caps Lock	KK_CAPLOCK	toggle
Scroll Lock	KK_SCRLOCK	toggle
Num Lock	KK_NUMLOCK	toggle
(extended keys)	KK_EXTENDED	only on keydown (not really a state)

***************************************************************************

			KEY EVENTS

Alt (menu) key:

Description		wParam		vk 		kk = HIWORD(lParam)
------------		-------		---		--------------------
Alt down		VK_MENU		VK_MENU		KK_MENU
Alt up			VK_MENU		VK_MENU
Alt + any other shifts	VK_MENU		VK_MENU		(other KK_'s)
(Note:	'Alt up' sends a WM_KEYUP message.
	All other keys send WM_CHAR message.)
------------------------

Function keys:

Description		wParam		vk 		kk = HIWORD(lParam)
------------		-------		---		--------------------
Fn (n = 1..12)		VK_Fn		VK_Fn
Fn + any shift key(s)	VK_Fn		VK_Fn		(current KK_'s)
(Note:	F11 and F12 appear only on RT and Tandy keyboards.)
------------------------

Main keyboard control keys:

Description		wParam		vk 		kk = HIWORD(lParam)
------------		-------		---		--------------------
Esc			27		VK_ESCAPE			
Esc + any shifts	27		VK_ESCAPE	(current KK_'s)
Backspace		8		VK_BACK
Backspace + any shifts	VK_BACK		VK_BACK		(current KK_'s)
Tab			9		VK_TAB
Tab + any shifts	VK_TAB		VK_TAB		(current KK_'s)
Enter (main)		13		VK_ENTER
Ctrl Enter		10		VK_ENTER	KK_CONTROL
Enter + other shifts	VK_ENTER	VK_ENTER	(current KK_'s)
Spacebar		32		VK_SPACE
Spacebar + any shifts	32		VK_SPACE	(current KK_'s)
Spacebar released	VK_SPACE	VK_SPACE	(current KK_'s)
------------------------

Main keyboard number keys:

Description		wParam		vk 		kk = HIWORD(lParam)
------------		-------		---		--------------------
0..9			'0'..'9'	VK_0..VK_9
Ctrl 0 .. Ctrl 9	VK_0 .. VK_9	VK_0..VK_9	KK_CONTROL
Alt 0 .. Alt 9		VK_0 .. VK_9	VK_0..VK_9	KK_MENU
!			'!'				KK_SHIFT
@			'@'				KK_SHIFT
#			'#'				KK_SHIFT
$			'$'				KK_SHIFT
%			'%'				KK_SHIFT
^			'^'				KK_SHIFT
&			'&'				KK_SHIFT
*			'*'				KK_SHIFT
(			'('				KK_SHIFT
)			')'				KK_SHIFT
------------------------

Punctuation:

Description		wParam		vk 		kk = HIWORD(lParam)
------------		-------		---		--------------------
`			'`'
~			'~'				KK_SHIFT
Ctrl `			'`'				KK_CONTROL
-			'-'
_			'_'				KK_SHIFT
Ctrl -			'-'				KK_CONTROL
Alt -			'-'				KK_MENU
=			'='
+			'+'				KK_SHIFT
Ctrl =			'='				KK_CONTROL
Alt =			'='				KK_MENU
[			'['
{			'{'				KK_SHIFT
Ctrl [			27				KK_CONTROL
]			']'
}			'}'				KK_SHIFT
Ctrl ]			29				KK_CONTROL
\			'\'
|			'|'				KK_SHIFT
Ctrl \			28				KK_CONTROL
;			';'
:			':'				KK_SHIFT
Ctrl ;			';'				KK_CONTROL
'			''' (39)
"			'"' (34)			KK_SHIFT
Ctrl '			''' (39)			KK_CONTROL
,			','
<			'<'				KK_SHIFT
Ctrl ,			','				KK_CONTROL
.			'.'
>			'>'				KK_SHIFT
Ctrl .			'.'				KK_CONTROL
/			'/'
?			'?'				KK_SHIFT
Ctrl /			'/'				KK_CONTROL
------------------------

Alpha keys:

Description		wParam		vk 		kk = HIWORD(lParam)
------------		-------		---		--------------------
A..Z			'a' .. 'z'	VK_A..VK_Z
Shift A..Z		'A' .. 'Z'	ditto		KK_SHIFT
CapLock A..Z		'A' .. 'Z'	ditto		KK_CAPLOCK
Shift CapLock A..Z	'a' .. 'z'	ditto		KK_SHIFT | KK_CAPLOCK
Ctrl A..Z		1 .. 26		ditto		KK_CONTROL
Alt A..Z		VK_A..VK_Z	ditto		KK_MENU
(Note:	Ctrl A..Z + any shifts other than Alt only changes kk.
	Alt A..Z + any shifts only changes kk.)
------------------------

Grey keypad (between main keyboard and numpad, on RT keyboards only):

Description		wParam		vk 		kk = HIWORD(lParam)
------------		-------		---		--------------------
Insert			VK_INSERT	VK_INSERT	KK_EXTENDED
Home			VK_HOME		VK_HOME		KK_EXTENDED
Page Up			VK_PRIOR	VK_PRIOR	KK_EXTENDED
Delete			VK_DELETE	VK_DELETE	KK_EXTENDED
End			VK_END		VK_END		KK_EXTENDED
Page Down		VK_NEXT		VK_NEXT		KK_EXTENDED
up			VK_UP		VK_UP		KK_EXTENDED
left			VK_LEFT		VK_LEFT		KK_EXTENDED
down			VK_DOWN		VK_DOWN		KK_EXTENDED
right			VK_RIGHT	VK_RIGHT	KK_EXTENDED
(Note:	Ctrl, Shift, and the Lock keys only affect kk.
	Alt is not supported.)
------------------------

Numeric pad (on the far right on most keyboards):

Description		wParam		vk 		kk = HIWORD(lParam)
------------		-------		---		--------------------
/			'/'		VK_DIVIDE	KK_EXTENDED
Shift /			'/'		VK_DIVIDE	KK_EXTENDED | KK_SHIFT
*			'*'		VK_MULTIPLY	KK_EXTENDED
-			'-'		VK_SUBTRACT	KK_EXTENDED
- and any shifts	'-'		VK_SUBTRACT	KK_EXTENDED | current KK_'s
+			'+'		VK_ADD		KK_EXTENDED
+ and any shifts	'+'		VK_ADD		KK_EXTENDED | current KK_'s
Enter			13		VK_ENTER	KK_EXTENDED
Shift Enter		13		VK_ENTER	KK_EXTENDED | KK_SHIFT
Ctrl Enter		10		VK_ENTER	KK_EXTENDED | KK_CONTROL
(Note:	The Lock keys only affect kk for the above.)

7/Home			VK_HOME		VK_HOME
8/up			VK_UP		VK_UP
9/PgUp			VK_PRIOR	VK_PRIOR
4/left			VK_LEFT		VK_LEFT
5			VK_CLEAR	VK_CLEAR
6/right			VK_RIGHT	VK_RIGHT
1/End			VK_END		VK_END
2/down			VK_DOWN		VK_DOWN
3/PgDn			VK_NEXT		VK_NEXT
0/Ins			VK_INSERT	VK_INSERT
./Del			VK_DELETE	VK_DELETE
(Note:	Shift and Ctrl only affect kk.
	If NumLock is on, Shift and Ctrl are as above, with appropriately
	altered KK_'s.
	If NumLock is on without Shift or Ctrl, events are as follows.)

NumLock 7/Home		'7'		VK_NUMPAD7	KK_EXTENDED
NumLock 8/up		'8'		VK_NUMPAD8	KK_EXTENDED
NumLock 9/PgUp		'9'		VK_NUMPAD9	KK_EXTENDED
NumLock 4/left		'4'		VK_NUMPAD4	KK_EXTENDED
NumLock 5		'5'		VK_NUMPAD5	KK_EXTENDED
NumLock 6/right		'6'		VK_NUMPAD6	KK_EXTENDED
NumLock 1/End		'1'		VK_NUMPAD1	KK_EXTENDED
NumLock 2/down		'2'		VK_NUMPAD2	KK_EXTENDED
NumLock 3/PgDn		'3'		VK_NUMPAD3	KK_EXTENDED
NumLock 0/Ins		'0'		VK_NUMPAD0	KK_EXTENDED
NumLock ./Del		'.'		VK_DECIMAL	KK_EXTENDED

(Note:	Alt 0-9 on the numeric pad are special.
	Alt . is not supported.)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\smm.doc ===
1           <        C:\EDITORS\C#.STY                                                   HPLASMS                      		--	
	SMM Feature Guide		
Character WindowsStandard Menu ManagerFeature GuideDRAFT
Bryan FeirMicrosoft Applications Division
.c.1. Introduction
This document describes the features of the new Standard Menu Manager interface to the Character Windows (CW) system.
This system replaces the old CW menu commands with a new API similar to that of Windows which isolates the application writer from the structure and allows menus to be modified dynamicly.
.c.2. General Features
The following is a list of the features of the Standard Menu Manager.  Please see the Interface section for detailed description of these features.
* Dynamic menu modification is simplified
* Multi-line menubars supported transparently
* Hierarchal and Pop-up menus supported
* Scrolling menus supported if menu is larger than screen
* Application definable data space within item structure
* Application definable string function for far strings or dynamic string changes
* Support for Kana accelerators in DBCS
* Menubar no longer has to be on top line of screen
* Previous menu system still available via #ifdef
.c.3. Implementation
.c.:3.1 C Structures Used
The menu system makes use of two basic structures to describe the menu tree.  They are as follows:
typedef struct	{	HMTM	hmtmNext;	BITS	fDisabled:1	BITS	fChecked:1	BITS	fSeparator:1;	BITS	fString:1;	BITS	fHelp:1;	BITS	fMenuBreak:1	BITS	filler:10;	union {		WORD	sid;		WORD	cwString;	}	WORD id;	HMTM	hmtmSub;	WORD	rgwExtra[];	} MTM;
typedef MTM **HMTM;
NOTE: these structures are for information only, and should not be accessed by the application.
hmtmNext: next item in linked list of items.
fDisabled: a flag which tells whether or not the item is enabled.  If the item is disabled and has an attached menu, the menu can still be pulled down, but all items on it will appear disabled.
fChecked: TRUE if the item has a check mark.
fSeparator: TRUE if the item is a menuitem separator.
fString: TRUE if the item contains the string within it.
fHelp: TRUE if the menu is a special help menu, which will be right justified on the menu bar.  Only one help menu should be on any line of the menubar, and the help menu should be the last item in the bar.
fMenuBreak: TRUE if this menu will force the start of a new line in the menubar.  This way the application can control the various lines on the menubar.
sid: the string ID number which is sent to SzFromSid to get the string; used if fString is FALSE.  The default interpretation is that this value is a near pointer to a string.
cwString: the number of words to skip before the string is found; used if fString is TRUE.
id: the item ID number passed to WM_COMMAND messages and used to locate the item.
hmtmSub: the menu attached to this item; NULL indicates no submenu.
rgwExtra: extra data for use by the application.
.c.:3.2 Setup
In memory, a menu consists of handle to an MTM with the menubar title and ID information, if wanted.  This item contains a handle to a linked list of MTM structures, which are the items of the menu.  Any one or all of these MTMs may either be a terminal item, or a menu in itself, with its own list of items.  Menubars, menus, hierarchal menus, and popup menus are all treated identically.  The only difference is that the topmost item is either set with InitMenu, part of a menubar, part of another menu, or just floating, respectively.
.c.:3.3 Item Strings
As shown above, there are two possible methods of storing strings:
In item: the string is physically copied into the structure after the reserved number of words.  This is marked by fString TRUE.  cwExtra is set to the reserved number of words so that the string can be found quickly.
String id#: sid contains a value which is passed to SzFromSid to get the string.  This is used if fString is FALSE.  The internal SzFromSid stub just returns sid, assuming it is a pointer to the string.
In both cases the string will be of the form "Cu~t\tDel", where the character after the tilde is hilighted as the menu accelerator, and the characters after the tab will be right-justified to designate the keyboard accelerator for the item.
In Kanji versions, the format is "~RK/Cut\tDel".  The character 'K' is the Kana accelerator, which will be displayed if the global fKanaAccel is TRUE; otherwise 'R', the Roman accelerator, is displayed.
.c.:3.4 Item ID#'s
The menu item ID 0xFFFF (idSysMenu) is reserved for system use.  It is used for VAP commands and other system work.  The application should never receive a message about a menuitem with an ID of 0xFFFF.
.c.4. Changes to CW API
.c.:4.1 New Commands
The following CW API calls will be added for the main application to interface to the SMM:
.c.::4.1.1 HmtmAddItem
HMTM HmtmAddItem(hmtmMenu, idBefore, sid, idNew, cwExtra, wFlags)HMTM hmtmMenu;WORD idBefore;WORD sid;WORD idNew;WORD cwExtra;WORD wFlags;
The hmtmMenu parameter is the handle to the menu to be edited.  The new item will go before the item with ID# idBefore; if idBefore is idNil, it goes at the end.  The values of sid, idNew, and cwExtra describe the new item.  They represent the string ID, the item ID#, and the number of extra words to allocate respectively.  The basic action MF_ values are as follows:
The values to specify the string ID are covered below:
* MF_STRING - this signifies that sid must be a near pointer to a string.  The string will be copied into the item handle.
* MF_SID - in this case sid is a value used by the application to get the string.  If the function SzFromSid is not supplied, the default function will assume that sid is a pointer to a string. (default)
And the initial state of the item can be specified with:
* MF_SEPARATOR - The item is a menu separator.
* MF_ENABLED - The item is enabled. (default)
* MF_DISABLED - The item is disabled and greyed.
* MF_UNCHECKED - The item is unchecked. (default)
* MF_CHECKED - The item has a check mark.
* MF_HELP - The menu will be right justified on the menubar.
* MF_MENUBREAK - The menu will be at the start of a new row on the menubar.
.c.::4.1.2 DeleteItem
VOID DeleteItem(hmtmMenu, id)HMTM hmtmMenu;WORD id;
This command takes an item and deletes it.  If the item is a menu, the menu will not be deleted; at present, all items must be deleted individually.
.c.::4.1.3 OpenPopupMenu
VOID OpenPopupMenu(hmtmMenu, axLeft, ayTop)HMTM hmtmMenu;AX axLeft;AY ayTop;
This routine takes the menu specified by hmtmMenu and puts it up on the screen.  The system will attempt to draw the menu with the top left corner at (axLeft,ayTop).  If this would cause the menu to fall off the right side of the screen, then the menu is placed flush to the right side.
.c.::4.1.4 CchGetMenuString
WORD CchGetMenuString(id, pch, cchMac)WORD id;CHAR *pch;WORD cchMac;
(NYI)
This function will copy up to cchMax bytes from the string in item id to the buffer pointed to by pchString.  The number of characters actually copied is returned by the function.
.c.::4.1.5 HmtmFindExternId
HMTM HmtmFindExternId(hmtm, id)HMTM hmtmMenubar;WORD id;
This extension of the standard HmtmFindId will search for items not in the present menubar.  It will do a recursive search of all submenus of hmtm.  This allows modification of items in popup menus.
.c.::4.1.6 HmtmFindFlatId
HMTM HmtmFindFlatId(hmtmMenubar, id)HMTM hmtmMenubar;WORD id;
This version of the standard HmtmFindId will search for items only in hmtmMenubar, and not in any of its submenus.
.c.:4.2 Modified Commands
The following commands are direct replacements of some of the commands in the old API.
.c.::4.2.1 InitMenubar
VOID InitMenubar(pwnd, hmtm, parc, daxSpace)PWND pwnd;HMTM hmtm;PARC parc;WORD daxSpace;
InitMenubar replaces the old InitMenu command, with added functionality.  The pwnd is the same as before, the hmtm is now a handle to the menubar, the parc contains the rectangle in which the menubar is to be drawn, and daxSpace contains a number (0 to 3) which represents the number of spaces between items on the bar.  On return from the function, parc is modified to contain the real rectangle the menubar fills.  This is to give the application knowledge about how may lines the bar takes up.
.c.::4.2.2 HmtmFindId
HMTM HmtmFindId(id)WORD id;
HmtmFindId replaces the old FindMenuItem, and is almost identical to it in function.  However, HmtmFindId could return a menu ID# as well as an item ID#.
.c.:4.3 Application Supplied Procedures
.c.::4.3.1 SzFromSid
CHAR *SzFromSid(sid)WORD sid;
This function is supplied by the application if it wants special treatment for String ID's.  Normally the SID is interpreted as a near pointer to a zero-terminated character string.  If the application supplies this command, it will be passed sid for every DrawItem command, and should return a pointer to a zero-terminated string which will be drawn in the menu item. (Optional)
.c.::4.3.2 QuickHelpSz
VOID QuickHelpSz(sz)CHAR *sz;
This function is used to implement the single-line help feature for system menu items.  If a item with idSysMenu is hilited, instead of the WM_MENUCOMMAND message coming up, this command will be called with a pointer to the text to be placed on the status line.
.c.5. Accelerator Tables
Since keyboard accelerators are no longer part of the menubar, they must be set up separately.  Two commands have been added to do this.  Also, a minor change in the format has been made to the accelerator table.  The first value is now a dummy value which contains two pieces of data: the vkey value contains a hash value equal to the negation of all the other vkey's in the list ORed together, and the idItem is interpreted as a handle to another accelerator table in a linked list.  A null link is the end of the list.  The vkey value is used to quickly determine whether the table in question could possibly contain the key.  Both of these pieces of data are calculated by AddAccelTable.
.c.:5.1 AddAccelTable
VOID AddAccelTable(prgmpvkeyid)MPVKEYID **prgmpvkeyid;
This will add a new accelerator table to the beginning of the present list.  The first entry is modified to contain the hashed vkey and the handle to the table that was in the front.  Note: since the new table is added to the front, the most recently added tables take precedence over the older ones.  If prgmpvkeyid is NULL, this will be ignored.
.c.:5.2 DeleteAccelTable
VOID DeleteAccelTable(prgmpvkeyid)MPVKEYID **prgmpvkeyid;
This removes a table from the list.  The handle is not deallocated, it is just disconnected from the list.  Any invalid value is ignored.
z.c.6. Changes to WndProcs
In the WM_INITMENUPOPUP, WM_COMMAND, and WM_MENUSELECT, in the LOWORD(lParam) value, any pointer to a menu item or menu is replaced with the handle to the item.  This replacement also occurs in the Help command.
.c.7. Menu Creation Example
To create the following menus:
File			Edit			TextNew			Undo			*HiliteOpen...			-------			 Color:	 BlackSave			Cut				 BlueSave As...		Copy				 Green----------			Paste				 CyanExit			Erase				 RedAbout Demo...						 Magenta							 Yellow							*White
The following set of commands should be used:
HMTM HmtmAddItem(hmtmMenu, wId, sid, wIdNew, cwExtra, wFlags)
hmtmMenubar = HmtmAddItem(NULL, NULL, NULL, midMenubar, 0, MF_ENABLED);
hmtmFileMenu = HmtmAddItem(hmtmMenubar, NULL, "~File", midFile, 0, MF_ENABLED);
HmtmAddItem(hmtmFileMenu, NULL, "~New", midNew,0, MF_ENABLED);HmtmAddItem(hmtmFileMenu, NULL, "~Open...", midOpen, 0, MF_DISABLED);HmtmAddItem(hmtmFileMenu, NULL, "~Save", midSave, 0, MF_DISABLED);HmtmAddItem(hmtmFileMenu, NULL, "Save ~As...", midSaveAs, 0, MF_DISABLED);HmtmAddItem(hmtmFileMenu, NULL, NULL, 0, 0, MF_SEPARATOR);HmtmAddItem(hmtmFileMenu, NULL, "E~xit", midExit, 0, MF_ENABLED);HmtmAddItem(hmtmFileMenu, NULL, "A~bout Demo...", midNew, 0, MF_ENABLED);
hmtmEditMenu = HmtmAddItem(hmtmMenubar, NULL, "~Edit", midEdit, 0, MF_DISABLED);
HmtmAddItem(hmtmEditMenu, NULL, "~Undo", midUndo, 0, MF_DISABLED);HmtmAddItem(hmtmEditMenu, NULL, NULL, 0, 0, MF_SEPARATOR);HmtmAddItem(hmtmEditMenu, NULL, "~Cut", midCut, 0, MF_DISABLED);HmtmAddItem(hmtmEditMenu, NULL, "C~opy", midCopy, 0, MF_DISABLED);HmtmAddItem(hmtmEditMenu, NULL, "~Paste", midPaste, 0, MF_ENABLED);HmtmAddItem(hmtmEditMenu, NULL, "~Erase", midErase, 0, MF_DISABLED);
hmtmTextMenu = HmtmAddItem(hmtmMenubar, NULL, "~Text", midText, 0, MF_ENABLED);
HmtmAddItem(hmtmTextMenu, NULL, "~Hilite", midHilite, 0, MF_ENABLED|MF_CHECKED);hmtmColorMenu = HmtmAddItem(hmtmTextMenu, NULL, "~Color", midColor, 0, MF_ENABLED);
HmtmAddItem(hmtmColorMenu, NULL, "~Black", midBlack, 0, MF_ENABLED);HmtmAddItem(hmtmColorMenu, NULL, "Bl~ue", midBlue, 0, MF_ENABLED);HmtmAddItem(hmtmColorMenu, NULL, "~Green", midGreen, 0, MF_ENABLED);HmtmAddItem(hmtmColorMenu, NULL, "~Cyan", midCyan, 0, MF_ENABLED);HmtmAddItem(hmtmColorMenu, NULL, "~Red", midRed, 0, MF_ENABLED);HmtmAddItem(hmtmColorMenu, NULL, "~Magenta", midMagenta, 0, MF_ENABLED);HmtmAddItem(hmtmColorMenu, NULL, "~Yellow", midYellow, 0, MF_ENABLED);HmtmAddItem(hmtmColorMenu, NULL, "~White", midWhite, 0, MF_ENABLED|MF_CHECKED);
arcMenubar.axLeft = arcWindow.axLeft + 1;arcMenubar.ayTop = arcWindow.ayTop + 1;arcMenubar.axRight = arcWindow.axRight - 1;arcMenubar.ayBottom = arcWindow.ayTop + 2;
InitMenu(pwndMain, hmtmMenubar, &arcMenubar, 2);
Note that unlike Windows, this system is built from the top down: the menubar first, then the menus, then the items on the menus.  Also, if the application uses the old wParamUser variable, then the cwExtra value (0 in this example) should be set to 1 to give one word of free space.  That word must be set by the application.
.c.8. Proposed Extensions to Menu Manager
The following additions will possibly be in a future version of the menu manager, but have not yet been written into the code:
Multi-column menus, using MF_MENUBREAK to go between columns.
Properly handled mouse action in scrolling menus.
Delay before submenu appears when in mouse mode.
Document Revision History
Oct 17 / 88 (1.10) [BKF]First Draft proposal
Oct 27 / 88 (1.11) [BKF]Structures simplified, menu ID#'s returned, API simplified, handles for accelerator tables,  Kana info moved into string, and example added.
Nov 15 / 88 (1.12) [BKF]Cleanup of AddItem description, addition of extensions section, fHelp added, fEnabled changed to fDisabled.
Dec 16 / 88 (1.20) [BKF]Hungarian names fixed, more parameters for InitMenu[bar], fSubMenu removed, scrolling menus added.
Table Of Contents
.Begin Table C.
1. Introduction	1
2. General Features	1
3. Implementation	2
3.1 C Structures Used	2
3.2 Setup	3
3.3 Item Strings	3
3.4 Item ID#'s	3
4. Changes to CW API	3
4.1 New Commands	3
4.1.1 HmtmAddItem	3
4.1.2 DeleteItem	4
4.1.3 OpenPopupMenu	4
4.1.4 CchGetMenuString	4
4.1.5 HmtmFindExternId	5
4.1.6 HmtmFindFlatId	5
4.2 Modified Commands	5
4.2.1 InitMenubar	5
4.2.2 HmtmFindId	5
4.3 Application Supplied Procedures	6
4.3.1 SzFromSid	6
4.3.2 QuickHelpSz	6
5. Accelerator Tables	6
5.1 AddAccelTable	6
5.2 DeleteAccelTable	6
6. Changes to WndProcs	7
7. Menu Creation Example	7
8. Proposed Extensions to Menu Manager	8
.End Table C.
t would set the project back a bit, 
recreating the work already done, it would buy Adams the time he needed.         v       q    
  m   h     f U  X  d     b     ` g  				 @@ @ @ @g  j  y {    w     u   s   q   o     m   k   i 9  g @  e s  c x  a x  C	  y M	  w 	  u 	  s 
  q 
  o -
  m /
  k 
  i 
  g 
  e 
  c 
  a 
  _ =  ] x =  D  y   w   u   s     q   o   m   k   i   g   e   c   a   _ x 		  "  y G  w P  u u  s |  q   o   m   k   i T  g ^  e   c   a     _ x 	    y }  w   u     s     q    %  o 0  m     k    i (  g -  e 5  c 				5  9  y >  w Y  u c  f  s h  q m  o s  m z  k   i %    g   e   c   a 5  c   <  y E  w }  u   s Z  q _  o v    m   k >  C  i ]  j  g     e   c 		      y     w   u T  Z  s y  {  q     o     m     k   i c  		c  m  y   w   u 
  s     q ,  :  o ;  m     k   i   g   e     c c 		  O  T  y l  w  w   u   s   q   o   m   k 3  i 7  g \  e `  c   a   c c	    y #   w '   u    s    q       o    m       k !  !  i K!  U!  g !  !  e c		!  !  y !  w !  u !  s !  q "  o "  m c#  k h#  i {#  #  g #  e $  c $  a $  _ !  e		$  $  y $  w %  u %  s &&  q *&  o P&  m V&  k &  i &  g a'  e n'  c q'  a u'  _ '  ] ! 		'  '  y '  w @(  u D(  s (  q (  o )  m ")  k 8)  i =)  g M)  e )  c *  a *  _ a*  ] ! 		a*  g*  y *  w *  u +  -+  s .+  q 4+  o 5+  m ;+  k <+  i A+  g B+  e G+  c H+  a O+  _ ! 	O+  P+  y V+  w W+  u k+  s l+  q r+  o t+  m y+  k z+  i +  g +  e +  c +  a +  _ +  ] ! +  +  y +  w +  u +  s +  q +  o +  m +  k +  i +  g +  e +  c +  a +  _ +  ] ! +  +  y +  w +  u +  s +  q ,  o ,  m G,  k R,  i ,  5  g 5  e 5  c 5  a !6  _ ! !6  $6  y L6  p7  w y9  9  r <  <  m G,  k R,  i ,  5  g 5  e 5  c 5  a !6  _ !  @ @	      Y    7    5   3 !  .   ) <  m=  A?!H $                   p `'!H $                    `'  U  v m  q   l -  g \  g   g   g   g M  g v  g   g   g   b   ]  `'!H $  E =  =   s  v m  q   q   l   g   g   g 9  g s  g C	  g 	  g 
  g 
  g =  g   g   g  E = W =     v   q   l 8  g   b   b   ]   ]   X }  S   N   I   =  = E =  =      v    q   l %  g ]  g   b   b   ]   X ?  X q  X   X   X   X = E = E = W  =   Z  v q  q   l >  g X  b   ]   X   S /  N 6  I   D = a W  = W  = W  E     v D  q   l '  g h  b   ]   X O  S g  N   I    D = W  =  = W  = W        v    q !  l !  g !  b !  ] c#  X {#  S #  N $  I $  D  = W  = W   = W  $  q'  v '  q '  l )  g 8)  b t)  ] )  X *  S *  N +  I -+  D =  =  = W  = W  = -+  ,  v B,  q ,  q ,  l -  l .  l H/  l 0  l %1  l 1  l 3  l 4  l 4  l !6  g L6  b  W  = W = W L6  6  v 7  q >7  q p7  q 7  l 7  g b8  g 8  g e9  g f9  b y9  ] 9  4  l !6  g L6  b  ? = U ? E = 9  9  a 9  a 9  a 9  G 9  G :  G :  G 8  g e9  g f9  b y9  ] 9                  !                !:  -:  a A:  G V:  - j:  - :  - :  - :  - 8       	           !                !                !:  :  a :  G :  - ;  - :  - :  - :  - 8       	           !                !      	           !;  6;  a I;  G ^;  G w;  - :  - :  - :  - 8                 !      	           !                !w;  ;  a ;  a ;  G ;  G <  G <  <  8                 !                !                !  8   ;                                                                                                           
 
       ^      2      !   )   K1  	 6  
 8                                                                   , 0 1 6 E M U ] New Standard Menu Manager BKF  Menu Still volatile 1.02.00 12/16/8810/18/88;                                 
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\users.doc ===
Products using CW:

Title (ver)	Group(liason)	Needs	Description
				V I

Shipped products:
=================
MANAGER 1.0	DOS(kurte)	3-S	MS-DOS replacement shell
MANAGER 1.0+	DOS(kurte)	3-S	ITL releases
WORKS 1.0	APPS(edr)	S-F	4 tools in 1
NIF (almost)	NET(beng)	5-U	Network interface for OS/2


Current products:
=================
WORKS 1.0x	APPS(edr)	S-F	OEM/ITL releases
QBJ		BL(jamieb)	3-K	Kanji version of Quick Basic

MULTIPLAN 4	APPS(tomhe)	CBOX	the last version !
WORD 4		APPS(jodig)	CBOX	next version, non-CW interface


Future products:
================

WORKS 2.0	APPS(edr)	S-FVI	next version (fall 88)
QC 2.0		SL(andyp)	S-UV	Quick C integrated with VAP/Platform
					(needs 2 dgroups).
QB 5		BL(??)		???

Z-SHELL		STOOLS(reubenb)	35-U	Integrated Development Environment.
SUMO		DOS(mikedr)	35-U	Toolkit (like Norton)

Speculating products:
=====================

EMAIL		APPS(bobm)	S-T	Electronic Mail TSR app.
BOOKSHELF	CDR(???)	S-T	CW version of bookshelf
CV		STOOLS(stever)	3-S	CodeView (Kanji ???)


Potential future products:
==========================

WORD 6.0	APPS(jodig)	S-FU	Word with CW user interface


Internal products:
==================
DE 1.0		APPS(davidfr)	3-U	Dialog Editor tool
VCR		APPS(byronb)	S-U	Testing script playback/record


Key: Version-Features:
======================
Version:
	S => swapped DOS 3
	3 => nonswapped DOS 3
	5 => OS/2
	CBOX => combination of "S" & "5", plus QINTER glue.
Features:
	U => windowing user interface
	S => small size
	F => full features
	V => VAP
	I => installable screen drivers
	K => Kanji
	T => TSR


Future of CW:
=============

For Sure:
	Kanji
	Installable drivers
	CBOX
	Size reduction
	VAP
	MS-Key replacement
	New SDM
	Pixel screen drivers
Potential:
	TSR
	QB/QC export dialogs (incl. DE).
	PM special support
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\vap05.txt ===
VAP Release 0.5 document

                                Bryan Feir


    This document lists the features of VAPs which have been implemented in
the present version: 0.5 (Oct 7,'88).

    At present, the application has all the commands in section 7 at its
disposal except for FSaveVapInfo and FLoadVapInfo.  Communication with VAPs
and installation of individual VAPs are supported.

    Generally, as far as the Notification and Request messages are concerned,
all messages are supported except those to do with menus, keys, or the Works
messages near the end.  Supported messages are:

	VN_			VR_

	Initialize		Beep
	Terminate		TmcDoDlg
	Idle			MessageBox
	Command			RePaint
				TextOut

	dialog Procs		TMC routines
	control Procs		MemAlloc/MemRealloc/MemFree/MemLock/MemUnlock

Command, at present, is only supported through direct application calls.

    No menu hooks or hot keys are supported.

    For edit Procs, there is one major limitation: only single word values can
be handled.  This means that in any dialog, all CAB arguments must be words;
no handles or fixed length allowed.  If more than a word is needed, the edit
Proc must handle its own memory, and store a handle or a pointer in the word
given.  The word can be accessed as normal, bArg offset into the block
represented by hobj, as long as no assumptions are made about anything other
than that word being valid.  Also, the tmmCwVal call should always return 1.
Edit Procs also cannot cause any other edit Procs to be called; they cannot
be recursive, since only a small buffer is allocated for edit Procs.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\doc\vap.doc ===
1           7S        C:\EDITORS\C#.STY                                                   HPLASMS                      		--	
	CW VAP Feature Guide		
Character WindowsValue Added ProgramsFeature GuideDRAFT
Scott RandellMicrosoft Applications Division
.c.1. Introduction
This document describes the features of the Value Added Program (VAP) interface to the Character Windows (CW) system.
VAPs enhance the usability of a master application (for example PC Works) by adding extra features.  These features may or may not be dependent upon the application.  Some VAPs will be general (eg: a calculator) while others will be specific to on master application (eg: a database addition for the PC-Works database).  All VAPs share the user interface and memory of the master application.
The replacement for MSKEY 1.0 will be the MSKEY VAP.  The user interface of this program will be a VAP, but there will be some special code in CW proper for supporting hotkeys etc (i.e. MSKEY will not be required to run other VAPs with hotkeys).  A complete specification of the MSKEY Vap will be provided by Chris later.
//REVIEW: is it reasonable to require MSKEY (sort of the VAP install program) all the time to arbitrate hot-keys ??
//REVIEW: the VAP install program could itself be a VAP.
A sub-set of this interface (without the menu interface) will probably be provided first to meet the needs of PC-Email.
.c.2. General Features
The following is a list of the features of VAPs.  Please see the VAP Interface section for detailed description of these features.
* Integrated Menus via File and VAP drop-downs.
* Vaps enregister their hotkeys with CW so that conflicts may be resolved (in conjunction with the MSKEY VAP).
* Vaps can reserve portions of the status/prompt line for status/mode messages.
* Dialogs serve as the principal user interface mechanism.  Very powerful dialogs can be created.
* Extension beyond standard dialog controls is available.
* VAPs can do background / idle processing.

* All interface is integrated with the windowing, keyboard and mouse interface of the master application.
* special development tools (eg: DE).
* MSKEY VAP controls keyboard macros along with the assigning/reassigning of hot-keys for all the VAPS.
* VAP (and hot-key) configurations can be saved to disk (in a .INI file).
.c.3. Limitations
VAPs (at least for version 1) can NOT do the following:
* take control of the entire screen.
* take control of the entire menu bar.
* use the SbMgr or EMM.
* live outside of CW applications (VAPs ARE NOT TSRs).
See the development and implementation sections for more restrictions/limitations on VAPs.
.c.4. What VAPs look like
.c.:4.1 File Menu
At the bottom of the File menu, the VAP installer will be listed (Install ...), followed by the list of the currently installed VAPs.
		  New ...		  Open ...		  ---------		  DOS ...		  ---------		  Exit		  ---------		  Install ...		  1 MSKey		* 2 Speller		  3 Calculator		  4 Check Book
NOTES:
* Vaps are numbered to avoid conflicts with accelerators.
* The currently "active" VAP is checked in the menu -- the currently active VAP is usually the VAP who is in control of the VAP menu dropdown.
//REVIEW: Shouldn't the VAPs stuff go before the "eXit" menu item ??
The Install dialog will present the user with a directory listbox of the VAPs to install, along with a list of the VAPs that are currently installed, with the option to install or remove selected VAPs (much like the Mac Installer).  Installing a VAP makes it's hotkeys instantly accessable.
.c.:4.2 VAP Menu
Since VAPs will want the option of having a menu drop-down of their own, there is one extra drop-down that is available to all VAPs.  This drop-down is called the VAP menu.  The name for this menu will be some prefix letter followed by the currently active VAP (if there is no currently active VAP then the VAP menu will disappear).  The single letter is localizable but fixed for a given application.  Using a single fixed letter to refer to the current VAP prevents VAP names from interfering from the accelerator uniqueness of the existing menus.  For now lets call that letter 'V' (for Vap).  For some crammed menubars, the 'V' letter may be all you can see, so a good mnemonic character will be needed for Italian and German.
Example VAP Menu:
		File Edit ... Window	V-MsKey							Record...							Playback...							DropDead...
.c.5. Developing a VAP
In order to develop a VAP the developer must use a C compiler or MASM.  Either the Microsoft C compiler or Quick C can be used.  In fact any language compiler that generates .OBJ files for small model programs can be used (but we only supply headers for C and MASM).
The standard VAP library (VAP.LIB) along with the build process handles most of the mechanics for building a VAP.
The example VAP (with complete source code) is the starting place for writing new VAPs since this contains all the features of the VAP interface in a simple example.
.c.:5.1 Restrictions
The following restrictions are imposed upon the writers of VAPs:
VAPs must be small model programs.
The must run with SS == DS.
The total size for code + default data + stack must be < 64K  (Note: extra data blocks can be allocated by VAPs to the limit of available memory).
They must not contain segment relocations (i.e. they must be like .COM files since they can be loaded at fixed addresses).
They must be generally moveable code (since the entire VAP may be moved around in memory).  Interrupt routines must take special precautions.
The VAP program must adhere to the VAP format when linked (the details for this are mainly controlled by the VAP library and build process).
.c.:5.2 Tools
The following standard Microsoft tools are suggested for building a VAP:
Microsoft C Compiler (5.1 and above suggested)For C compilation (Quick C is a suitable replacement).
Microsoft MASM Assembler (5.0 and above)For assembler work.
Microsoft LINK Linker and EXE2BIN utilityFor linking the final VAP.
VAP Dialog EditorFor defining SDM Dialogs for VAPs.
The VAP Development kit will contain those tools that are not available in the Microsoft C and MASM products (i.e. special VAP tools).
Header files for the VAP interface (constants and procedure templates) for the C language and MASM will be provided.  In addition, the VAP library will be provided to link with the developer's program for generating final VAP loadable programs.
Source code to the sample applications as well as the VAP glue code (equivalent to the Microsoft C runtime) will be provided.
.c.:5.3 Building Steps
//TO BE DEFINED:
Use DE to define dialogs.
Compile, link, debug.
.c.:5.4 Debugging
To support debugging, a special VAP test app will be provided.  This program serves as the shell for all non-application specific VAPs.  For application specific VAPs, a version of that application must be obtained (i.e. the PC-Works team will provide a VAP-compatible version of Works to VAP developers who need the special Works messages).
In order to debug VAPs a special version of SYMDEB will be provided with the VAP kit.  The VAP will have its own .SYM file and be debugged just like multiple Windows apps are debugged.
//REVIEW: can we get Windows CodeView to work (with minimal work) ??? I doubt it since VAPs are not real .EXE files.
.c.6. VAP Interface
.c.:6.1 Overview
The VAP interface is a message based communication between the application and the VAP.  A message consists of a 16 bit message number and a far pointer to a buffer whose format is determined by the message number.
//REVIEW: error codes, what if function not supported ??
//REVIEW: assume the buffer is 1K, is that safe ???
When the VAP is running, it's data (and code) will be fixed, allowing it to pass far pointer to it's data items (just like Windows).
The standard VAP interface consists of many primitve messages.  Each application can define extra sets of messages that are particular to that application.  For a VAP to be guaranteed to work with all CW applications it must not rely on non-primitive messages or features.
The messaging model between the application and the VAP has two directions.  When the application sends a message to the VAP, this is called notification.  When the VAP sends a message to the application, this is called a request.
Application -> VAP			NOTIFICATION
VAP -> Application			REQUEST
Since we recognize that message based systems can be hard for people to understand, the standard VAP development kit will contain glue routine that map the messages to proper procedure calls.  NOTIFICATION procedures will be supplied by the VAP and will be called by the Application.  REQUEST procedures will be provided by the Application (or CW) and be called by the VAP, in response to some NOTIFICATION message.
For example: when a VAP gets activated, it want's to take over the Vap Menu.
Message Model (BAD):
	VapProc(int vm, char far * lpb)		{		switch (vm)			{		....		case VM_ACTIVATE:			SendMessage(VR_ADDMENU, (char far *) "Speller");			break;
			}		}

With Glue routines (GOOD):

	Activate()		{		AddMenu("Speller");		}
The standard development kit will contain stubs for all the primitive notifications and requests.  Each application will be responsible for documenting and providing stubs for the features that it makes available to VAPs.
.c.:6.2 Message Nomenclature
Notification messages begin with the prefix "VN_" (Vap Notification), while request messages begin with the prefix "VR_" (Vap Request).  The primitive messages end in a name that describes the message (eg: VN_ACTIVATE for notification that a VAP is being activated).  For application specific messages, the applications name prefixes the description (eg: VR_WORKS_GETSTYLE gets the character style for the selection in the Works application).
Note: that these messages will be masked by procedures that look very much like their CW equivalents (SDM calls will be identical, memory and TextOut will be slightly different).
.c.:6.3 Primitive VAP Notification Messages
The following primitive VAP notification messages:
VN_INIT	Initialization, sent when the VAP is installed or at program startup if the VAP is to be loaded at startup.
VN_TERM	Termination, sent when the VAP is being removed from the system or the application is terminating.
VN_IDLE	Idle, the application is idle right now.  Application must specify whether VAP can do any screen I/O right now.
VN_ACTIVATE	The VAP was selected in the File menu to be the selected VAP.  The VAP will usually take over the VAP menu.
VN_DEACTIVATE	The VAP is no longer the selected VAP.  ??? what use ???
VN_DROPMENU	The VAP's menu has been dropped, Menu items are requested.
VN_COMMAND	A VAP command (envoked from a hotkey, a menu or a timer) has been selected by the user.
VN_DIALOGPROC	Call-Back for SDM Dialog Proc.
VN_ITEMPROC	Call-Back for SDM Item Proc.  Not yet implemented in CW.
VN_CONTROLPROC	Call-Back for SDM ListBoxProcs, EditProcs, and FormatProcs.
VN_KEYMESSAGE	Call-Back for MSKEY keyboard macros.
//REVIEW: how about the following:
VN_QUERYTERM	Can we quit now ???
.c.:6.4 VAP Primitive Requests
VR_BEEP	Beep.
VR_ADDHOTKEY	Add a hot key, with key name and command value.
VR_ADDMENU	Add a string to the menubar.  Since there is only 1 VAP menu dropdown this will replace any other VAP's dropdown.
VR_ADDITEM	Add a menu item to the VAP dropdown.  Only called in response to a VN_DROPMENU.  Each item has a text string, whether enabled or not, whether checked or not along with a command value.
VR_GETPROMPT	Get space on the status/prompt line.
VR_DRAWPROMPT	Special routine to draw on reserved status/prompt space.
VR_DODLG	Run a modal dialog, return completion TMC (TmcDoDlg).
VR_MSGBOX	Simple message box.
VR_ID	Identify the program.  Returns VAP version number (for primitive functions), the application name and the application version number.
VR_PASTE	Paste keys (with or without shift states) into the keyboard buffer.
VR_REPAINT	Repaint the entire screen (either now or later).
VR_SETTIMER	Set a timer to send a VN_COMMAND message at a given time.
VR_HOOKKEYS	Hook the keyboard message queue (for MSKEY only).
The following are very primitive messages for implementing drawing, Dialog Procs/Item Procs and memory allocation.
VR_TEXTOUT	Text out (no draw modes, must specify colors).
VR_SETTMCVAL/GETTMCVAL/SETTMCTEXT/GETTTMCTEXT/ENABLETMC/FENABLEDTMC/SETFOCUSTMC/SETTMCSEL/SETDEFAULTTMC/REDISPLAYLISTBOX : just the SDM routines.
VR_ALLOC/REALLOC/FREE/LOCK/UNLOCK:GlobalAlloc/Realloc/Free/Lock/Unlock.
//REVIEW: what about making some of Ed's Works specific messages primitive ?? Candidates include:
VR_WINDOW	Stats about the current window.
VR_SCREEN	Stats about the current screen.
VR_ACTIVATE	Activate a given window (or document ??)
VR_OPEN/CLOSE/SAVE	??? can we generalize this ???
VR_EXIT	Exit the application.
.c.:6.5 Dialogs
Since Dialogs are the primary user inteface object for VAPs, giving the VAP developer the power of SDM should solve the problem.  Pointers to DialogProcs and ControlProcs belonging to VAPs are marked by having a segment of 0, so that SDM can easily know whether to call directly or send a message to a VAP.  In order to simplify the SDM interface for the developer we make the following optimizations:
* all items are action items.
* sub-dialogs are not supported.
* nested VAP dialogs are not allowed (since we must allocate dialogs in the applications data segment).
* CABs will be allocated FIXED (PcabAlloc). // REVIEW: how about giving them LMEM instead of malloc ??
* CAB handles are not directly supported.  This is to avoid the problem of the application and the VAP having different data segments.  If variable length data is required, the edit Proc will have to do its own memory management.
.c.7. Extensions to CW API
The following CW API calls will be added for the main application to interface to the VAP.
.c.:7.1 Vap Init/Term
.c.::7.1.1 VadInstallVap
WORD VadInstallVap(szFile)char * szFile;
Load a VAP from a file and return the Vap identification number.  LpwAllocDriverMem is used to allocate memory (see cwdrv.doc).  Return "vadError" if an error occured.
.c.::7.1.2 VadInstallVapIndirect
WORD VadInstallVapIndirect(lpb, cb)BYTE FAR * lpb;WORD	cb;
Install a VAP at the given location and return the Vap identification number.  lpb must point to a paragraph aligned block of memory (16 byte boundary).  Return "vadError" if an error occured.
.c.::7.1.3 FDeinstallVap
BOOL FDeinstallVap(vad)WORD	vad;
Remove the specified VAP from the system.  Specifying "vadAll" will deinstall all vaps.
.c.::7.1.4 FSaveVapInfo
BOOL FSaveVapInfo()
Save VAP.INI file (if information changed since last Load).
.c.::7.1.5 FLoadVapInfo
BOOL FLoadVapInfo()
Load VAP.INI file and install VAPs.
.c.:7.2 Talking to VAPs
.c.::7.2.1 SendVapMessage
DWORD SendVapMessage(vad, vn, lpb)WORD	vad;WORD	vn;BYTE FAR * lpb;
Send a VAP notification message to a specified vap (or all VAPs if vad==vadAll).  vn is the VAP notification message, lpb is a pointer to the VAP message buffer (it must be 1K or larger).
//REVIEW: what about return values ??
//REVIEW: what about buffer arbitration ??
.c.::7.2.2 SendVapIdle
VOID SendVapIdle(fCanDraw)
Must be called by the application's main idle loop to inform VAPs that the application is idling right now.  If the screen is in a state where the vap cannot do I/O, fCanDraw should be FALSE.  Otherwise it should stay TRUE.
.c.:7.3 Event / Menu Hooks
all hidden in CW I think.
.c.:7.4 Status/Prompt Line Hooks
//DESCRIBE:
we need a call for the VAP to reserve a given number of characters on the status line.  In the case of most applications, the application's status line is already too full, therefore these may flow down to the prompt line.  The more VAPs need status/prompt space, the shorter the status/prompt line gets (that's why the prompt line is better since this is not critical information).
.c.:7.5 Application Message Hooks
The apps main window (actually the one bound to the current menu bar) will get WM_VAP_REQUEST messages in addition to the normal WM_COMMAND messages.  The wParam for this message is the request code (VR_) and the lParam is a far pointer to the message buffer.  CW will shield the application for all the primative request messages, but it is up to the application to respond to all other requests.  Note: when the application receives requests from the VAP, it is in the middle of a SendVapMessage() call originally started by the application.
.c.:7.6 Other Hooks
* The ability for the VAP to request the Application to free up a file handle for it's use.  This is essential for Works which implements virtual file handles and will normally have all the system file handles eaten.
* Getting the program name and version (for VR_ID).
* Getting near space from the work buffer for:	menus, dialogs, misc stuff.
.c.:7.7 Hidden Hooks
The following things in the VAP interface are hidden in the CW interface which relieves the application from having to worry about them:
* Keyboard record/playback.
* Key pasting from VAPs.
* Menu trapping for VAP items on File Menu.
* Menu trapping for VAP dropdown.
* All trapping of HotKeys for Vaps.
.c.8. VAP Implementation
The first version of the VAP interface is designed to be simple (both to implement as well as developers to write VAPs), but also be powerful enough
The following describes the implementation of the first version of VAPs for all swapped CW application (Works, QuickC, ...).  The VAP interface will be extended in the future to fit the needs of VAP developers.
.c.:8.1 Memory
A VAP has its own data segment and stack.  This is represented in CW global memory as one big memory block.  Header information is at the front, followed by code, followed by the data, followed by stack.  At the very start of the block is a VAP_HEADER structure that defines the VAP program (entry point, size of stack, name, ...).
The segment ordering is enforced by linking the VAPHEAD.OBJ as the first object linked.
When switching to a VAP the DS and stack switch to the VAP's (using the CRMGR).  This way the VAP does not impact the master application's stack or default data space.
All VAPs are loaded as FIXED segments.  The size of the VAP (code + data + stack) will be lost from the global data heap (reducing the amount of data available).  VAPs will not be placed in EMM, nor will VAPs have use of the EMM support in the SbMgr.
.c.:8.2 Protection
The following resources which are consumed or optionally consumed by a VAP must be recoved by the system when the VAP is de-installed or the program terminates:
* Global Memory.
* Status/Prompt Line space allocated.
* HotKeys in table.
* the one line in the file menu.
* the VAP menu dropdown (if this is the current VAP).
* timers
//REVIEW: why not make the VAP writer responsible for this ???
.c.:8.3 Other
I think it is reasonable to limit the number of installed VAPS to 16.
For review: doing everything as a Vap message simplifies the number of stack switching (via CRMGR) but the CRMGR is very good at switching stacks.
.c.9. Future Possibilities
The following lists the future possibilities for the VAP interface:
* Modeless Dialogs (with overlapping windows) -- great for calculators.  This makes VAPs more like DAs or Windows and much more powerful than TSRs.
* VAPs are still memory hogs (not much better than TSRs) -- swapped code and EMM for data would be nice for large VAPs (spell checkers needing big buffers).
* Hooking existing master application menus (and replacing or just filtering the commands).
* Adding things to the master application menus.
To simplify the job of VAP developers the following should be considered:
* providing more standard C library functions -- in particular sprintf, malloc and stdio.
* giving lots of examples for standard things (like form templates).  Email will be providing the necessary format for their server templates.
* give people source to a simple multi-line editor that works as a VAP dialog control.
* Quick Basic for development tool ???
Document Revision History
Aug 18 / 88 (1.00) [SAR]First Draft
Oct  7 / 88 (1.10) [BKF]Add ControlProc information, combine VN_IDLE commands, and minor mods.
Table Of Contents
.Begin Table C.
1. Introduction	1
2. General Features	1
3. Limitations	2
4. What VAPs look like	2
4.1 File Menu	2
4.2 VAP Menu	3
5. Developing a VAP	3
5.1 Restrictions	3
5.2 Tools	4
5.3 Building Steps	4
5.4 Debugging	4
6. VAP Interface	5
6.1 Overview	5
6.2 Message Nomenclature	6
6.3 Primitive VAP Notification Messages	6
6.4 VAP Primitive Requests	7
6.5 Dialogs	8
7. Extensions to CW API	8
7.1 Vap Init/Term	8
7.1.1 VadInstallVap	8
7.1.2 VadInstallVapIndirect	8
7.1.3 FDeinstallVap	9
7.1.4 FSaveVapInfo	9
7.1.5 FLoadVapInfo	9
7.2 Talking to VAPs	9
7.2.1 SendVapMessage	9
7.2.2 SendVapIdle	9
7.3 Event / Menu Hooks	9
7.4 Status/Prompt Line Hooks	9
7.5 Application Message Hooks	10
7.6 Other Hooks	10
7.7 Hidden Hooks	10
8. VAP Implementation	10
8.1 Memory	11
8.2 Protection	11
8.3 Other	11
9. Future Possibilities	11
.End Table C.
/3 /3 /3 03 04 0
4 04  04 004 50"4 >0  " ////         v       q      m   h     f     d 3	  6	  b z
  }
  ` 
  				 @@ @ @ @
  
  y     w i  l  u     s m  q  q     o @  D  m     k     i 										  $  $  y c'  g'  w +  +  u 2  2  s W6  Z6  q 6  6  o 6  6  m 7  7  k 7  									7  7  y 7  8  w 8  8  u 9  "9  s 9  9  q 9  9  o 9  9  m :  !:  k J:  N:  i 						N:  c:  h:  y :  :  w ;  ;  u ;  ;  s ;;  >;  q ;  ;  o ;  ;  m <  <  k !=  					!=  %=  y >  >  w A  A  u B  B  s C  C  q UE  YE  o H  H  m WJ  [J  k AK  DK  i 										DK  O  O  v (S  7S  q A  u B  B  s C  C  q UE  YE  o H  H  m WJ  [J  k AK  DK  i 					 @ @      Y    7    5   3 &  .   ) B  s=  A?!H $                   p `'!H $                    `'  '  v j  v   v   v   v   q .  l _  g   g    g   g   g   g   g X  g   g   g  E =  =   3	  v F	  q 	  l 	  g 	  g 	  g 
  g z
  b 
  ] 
  X /  S   N   g W =   = E =  E     v   q   q   l   l #  g   b   b i  ]   X   S    S   S W =  W =  = E =     v   q #  l @  l   l P  l   l m  l |  g   b -  ] k  ]   ]   ] =  U =  E =    o  v e  v   v   q   l )  l @  l S  g   b d  b   b   ]   X   ] =   =  =  =     v   v H  v   v   v    v    q 	!  q "  l "  l #  l #  g #  g #  g #  g #  g #  g W = W = #  $  v $  q &  l c'  l '  g '  b 9(  ] (  ] )  ] )  ] )  ] '*  ] *  ] *  ] *  ] # U =  =  = *  K+  v +  v +  v +  v +  q +  l 2,  l ,  l u-  l -  l -  l 0.  l O.  l .  l */  l g/  l /  l /  l U  U /  a0  v 0  q /1  q y1  q 1  l 2  g 22  g h2  g 2  g 2  g 2  b ^4  ] }4  X 4  X */  E =  U = U = 4  5  v p5  v W6  v s6  q 6  l 6  g  7  b +7  ] 7  X 7  S 48  N 8  I }= W  = W   =  E 8  9  v 39  q 9  l 9  g 9  b 9  ] :  X %:  S J:  N c:  I ~:  D 8  = W  = W  = W  ~:  :  v ;  q ;  l ;  l ;  g 	<  b <  ] =  X !=  S C=  N P=  I >  I =  =  = W  W = W >  >  v A  q )A  l B  g 8B  g B  g B  b %C  ] BC  X \C  X C  X C  X C  X  = E =  E  =  C  C  v D  q UE  q eE  l F  g G  g G  g H  g H  b fI  ] xI  X I  X I  X I  X = E =  =  =  I  J  v J  v WJ  q fJ  l J  g AK  g ]K  b K  ] 7L  X L  X 2M  X dM  X M  S I  X= E =  =  = E M  
N  v N  v N  v O  v 6O  q \O  l O  l O  g O  b O  O  H P  H                 !? = U ? E P  P  a 8P  a IP  G YP  G pP  - \O  l O  l O                 !                !                !pP  P  a P  a P  a P  a P  G P  - P  - O                 !                !                !P  #Q  a AQ  a PQ  a kQ  G Q  - P  - P  - O                 !                !                !Q  Q  a Q  a Q  a Q  a Q  a R  G (R  - O       	           !                !      	           !(R  =R  a WR  G wR  G R  G R  G R  G R  - O                 !                !      	           !R  R  a R  a S  a (S  G 7S  B 8S  R  - O               =                 !                !  >O   R   	>  u> t
P>  t
P>u
P>  t
P>  t
P +              T      +#   *   \1  	 v8  
 <   D   UL   N   >O  > t
P:>  t
P)>         (       3/11/89 3/11/89 R  >  u<>  u5P6\	P^B+P6(6PX F
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\peropcod.txt ===
########################################################################
#
#   QB Master Peropcod.Txt:
#
#	This file is machine read by tool OpTabler.
#	The format of this file is:
#	    - "#" in column 1 causes the line to be a comment.
#	    - blank lines are ignored.
#	    - "@" in column 1 followed immediately by 1-6 characters
#	      begins a new class of opcodes. These classes are used to
#	      produce a number of opcode .inc & .h files, so that the
#	      number of EQU/#define directives for opcodes is minimized
#	      in each source file.  the special class name "__END_COMMON"
#	      is reserved to indicate the end of the block of the common
#	      block.  all new opcodes should be added after this indicator.
#	    - each logical line describes 1 opcode and is terminated by ';'
#	    - fields within a line are separated by '|'s or any number of
#	      newlines
#	    - OpTabler will report if the wrong number of fields were
#	      found on a line.
#	    - the field definitions within a line are:
#		1. opcode name
#		2. level of opcode support if a product doesn't appear
#		   in this column, the opcode is fully supported, if it's
#		   prefixed by a "*" it is not supported or listable,
#		   otherwise its listable but not supported.
#		3. scan dispatch label
#		4. rule table index
#		5. executor address map for this opcode
#		6. opcode attribute count (in bytes)
#		7. opcode's LIST rule dispatch
#		8. offset into reserved word table for opcode (for LIST)
#
########################################################################

#
#	NOTE: Parser assumes opXXImp..opXXSD match ET_IMP..ET_SD
#
#	Start of contiguous block assumed by parser
#


########################################################################
#	Start of Minimal set of opcodes
########################################################################
@MIN

#
# prsmain.asm assumes next 2 opcodes are contiguous
#

opBol             |                       | Ss_Bol            | 0
                    exBol0                | OPA_fSsRude+OPA_fTxtFind
                    LrBol                 | 0;
opBolSp           |                       | Ss_BolEmit        | 0
                    exBolSp               | 2+OPA_fSsRude+OPA_fTxtFind
		    LrBolSp		  | 0;

#
# end of contiguous block assumed by prsmain.asm
#

#
# prsmain.asm assumes next 2 opcodes are contiguous
#

opBolInclude      |                       | Ss_BolEmit        | 0
                    exBolInclude          | 2+OPA_fSsRude+OPA_fTxtFind
                    LrBolInclude          | 0;
opBolIncludeSp    |                       | Ss_BolEmit        | 0
                    exBolIncludeSp        | 4+OPA_fSsRude+OPA_fTxtFind
		    LrBolIncludeSp	  | 0;

#
# end of contiguous block assumed by prsmain.asm
#

opBolLab          |                       | Ss_BolLabDef      | 0
                    exBolLab              | 4+OPA_fSsRude+OPA_fTxtFind
                    LrBolLab              | 0;
opBolLabSp        |                       | Ss_BolLabDef      | 0
                    exBolLabSp            | 6+OPA_fSsRude+OPA_fTxtFind
                    LrBolLabSp            | 0;
opBos             |                       | Ss_Bos            | 0
                    exBos                 | OPA_fSsRude+OPA_fTxtFind
                    LrBos                 | 0;
opBosSp           |                       | Ss_Bos            | 0
                    exBosSp               | 2+OPA_fSsRude+OPA_fTxtFind
                    LrBosSp               | 0;
opEot             |                       | Ss_Eot            | 0
                    exEot                 | OPA_fSsRude+OPA_fTxtFind
                    LrEot                 | 0;
opEndProg	  |			  | Ss_Bos	      | 0
                    exEndProg             | OPA_fTxtFind
                    LrEndProg             | 0;
opReParse         |                       | Ss_NotDefined     | 0
                    ExNotDefined          | OPA_CntMask+OPA_fTxtFind
                    LrReParse             | 0;


########################################################################
#	Start of ID related opcodes
########################################################################

@ID

opIdLd            |                       | ss_IdLd           | LOWUND
                    mpLdExpOpExe          | 2+OPA_fSsRude
                    LrIdLd                | 0;
opIdSt            |                       | Ss_IdSt           | LOWUND
                    mpStExpOpExe          | 2+OPA_fSsRude+OPA_fExecute
                    LrIdSt                | 0;
opVtRf            |                       | Ss_VtRf           | LOWUND
                    mpVtRfOpExe           | 2+OPA_fSsRude
                    LrVtRf                | 0;
opAIdLd           |                       | Ss_AIdLd          | LOWUND
                    mpALdExpOpExe         | 4+OPA_fSsRude
                    LrAIdLd               | 0;
opAIdSt           |                       | Ss_AIdSt          | LOWUND
                    mpAStExpOpExe         | 4+OPA_fSsRude+OPA_fExecute
                    LrAIdSt               | 0;
opAVtRf           |                       | Ss_AVtRf          | LOWUND
                    mpAVtRfOpExe          | 4+OPA_fSsRude
                    LrAVtRf               | 0;
opOffLd           |                       | Ss_OffLd          | LOWUND
                    mpOffLdExpOpExe       | 2+OPA_fSsRude
                    LrOffLd               | 0;
opOffSt           |                       | Ss_OffSt          | LOWUND
                    mpOffStExpOpExe       | 2+OPA_fSsRude+OPA_fExecute
		    LrOffSt		  | 0;

# opcodes needed for arrays in records currently not supported in any products

opOffALd	  | *qb 		   | Ss_OffLd	       | LOWUND
                    mpOffLdExpOpExe       | 4+OPA_fSsRude
                    LrOffALd              | 0;
opOffASt	  | *qb 		   | Ss_OffSt	       | LOWUND
                    mpOffStExpOpExe       | 4+OPA_fSsRude+OPA_fExecute
                    LrOffASt              | 0;
#
# end of contiguous block assumed by parser
#

opAsType          |                       | Ss_AsType         | 0
                    exAsType              | 4+OPA_fSsRude+OPA_fTxtFind
                    LrAsType              | ORW_As;
opAsTypeExp       |                       | Ss_AsType         | 0
                    exAsTypeExp           | 4+OPA_fSsRude+OPA_fTxtFind
                    LrAsTypeExp           | ORW_As;
opNoType	  |     		  | Ss_0_0	      | 0
                    exNoType              | 0+OPA_fTxtFind
                    LrNoType              | 0;
opDimOptionBase   |                       | Ss_Lit            | ET_I2+HIGH ST_LIT
                    exDimOptionBase       | 0
                    LrDimOptionBase       | 0;
opElemRef         |                       | Ss_ElemRef        | 0
                    exElemRef             | 2+OPA_fTxtFind
                    LrElemRef             | 0;
opShared	  |     		  | Ss_Shared	      | 0
                    exShared              | OPA_fSsRude+OPA_fTxtFind
                    LrShared              | ORW_Shared;
opStDefType       |                       | Ss_StDefType      | 0
                    exStDefType           | 6+OPA_fSsRude+OPA_fTxtFind
		    LrStDefType 	  | 0;
opStReDimTo	  |			  | Ss_ReDim	      | 0
		    exStReDimTo 	  | OPA_fTxtFind+OPA_fExecute
		    LrStReDimTo 	  | ORW_ReDim;
opStEndType       |                       | Ss_StEndType      | 0
                    exStEndType           | 2+OPA_fSsRude + OPA_fTxtFind
                    LrStEndType           | ORW_Type;
opStShared	  |     		  | Ss_StShared       | 0
                    exStShared            | 2+OPA_fSsRude+OPA_fTxtFind
                    LrStShared            | ORW_Shared;
opStStatic	  |     		  | Ss_StStatic       | 0
                    exStStatic            | 2+OPA_fSsRude+OPA_fTxtFind
                    LrStStatic            | ORW_Static;
opStType          |                       | Ss_StType         | 0
                    exStType              | 4+OPA_fSsRude + OPA_fTxtFind
                    LrStType              | ORW_Type;
op_Static	  |     		  | Ss_Static	      | 0
                    ex_Static             | OPA_CntMask+OPA_fTxtFind
                    Lr_Static             | 0;
op_Dynamic	  |     		  | Ss_Dynamic	      | 0
                    ex_Dynamic            | OPA_CntMask+OPA_fTxtFind
                    Lr_Dynamic            | 0;
opStConst         |                       | Ss_StConst        | 0
                    exStConst             | OPA_fSsRude+OPA_fTxtFind
                    LrStConst             | ORW_CONST;


########################################################################
#	Start of Control-related opcodes
########################################################################

@CONTRL

opBreakPoint	  |			  | Ss_Bos	      | 0
                    exBreakPoint          | OPA_fTxtFind
                    LrNoList              | 0;
opByVal 	  |			  | Ss_ByVal_Seg      | ByValMarker
                    exByVal               | 0
                    LrRwExp1              | ORW_Byval;
opEndSingleDef	  |     		  | Ss_EndSingleDef   | 0
                    ExEndSingleDef        | 4+OPA_fSsRude+OPA_fTxtFind
		    LrEndSingleDef	  | 0;

#
# NOTE:
# For scan purposes, opEv<On|Off|Stop> do not take arguments.
#  Therefore, each opEvxxx event handler is considered to not emit an argument.
#  This is not actually the case.  It is handled this way for speed since:
#	1.  the argument counts are always one
#	2.  the argument type is always I2
#	3.  the parser ensures that no syntax can intervene
#

opEvCom 	  |     		  | Ss_4ET_ET	      | SSR_I2_None
                    exEvCom               | OPA_fExecute
                    LrFunc1Arg            | ORW_Com;
opEvGosub	  |     		  | Ss_MrsLabelRef    | SSR_1LabMain0Arg
                    exEvGosub             | 2+OPA_fTxtFind+OPA_fExecute
                    LrEvGosub             | ORW_Gosub;
opEvKey 	  |     		  | Ss_4ET_ET	      | SSR_I2_None
                    exEvKey               | OPA_fExecute
                    LrFunc1Arg            | ORW_Key;
opEvOff 	  |     		  | Ss_0_0	      | 0
                    exEvOff               | OPA_fTxtFind+OPA_fExecute
                    LrEvOff               | ORW_Off;
opEvOn		  |     		  | Ss_0_0	      | 0
                    exEvOn                | OPA_fTxtFind+OPA_fExecute
                    LrEvOn                | ORW_On;
opEvStop	  |     		  | Ss_0_0	      | 0
                    exEvStop              | OPA_fTxtFind+OPA_fExecute
                    LrEvStop              | ORW_Stop;
opEvPen 	  |     		  | Ss_0_0	      | 0
                    exEvPen               | OPA_fExecute
                    LrRw                  | ORW_Pen;
opEvPlay0	  |     		  | Ss_0_0	      | 0
                    exEvPlay0             | OPA_fExecute
                    LrRw                  | ORW_Play;
opEvPlay1	  |     		  | Ss_4ET_ET	      | SSR_I2_None
                    exEvPlay1             | OPA_fExecute
                    LrFunc1Arg            | ORW_Play;
opEvSignal	  |     		  | Ss_4ET_ET	      | SSR_I2_None
                    exEvSignal            | OPA_fExecute
                    LrFunc1Arg            | ORW_Signal;
opEvStrig	  |     		  | Ss_4ET_ET	      | SSR_I2_None
                    exEvStrig             | OPA_fExecute
                    LrFunc1Arg            | ORW_Strig;
opEvTimer0	  |     		  | Ss_0_0	      | 0
                    exEvTimer0            | OPA_fExecute
                    LrRw                  | ORW_Timer;
opEvTimer1	  |     		  | Ss_4ET_ET	      | SSR_I4_None
                    exEvTimer1            | OPA_fExecute
                    LrFunc1Arg            | ORW_Timer;
opLab             |                       | Ss_LabDef         | 0
                    exLab                 | 4+OPA_fTxtFind
                    LrLab                 | 0;
opLabSp           |                       | Ss_LabDef         | 0
                    exLabSp               | 6+OPA_fTxtFind
                    LrLabSp               | 0;
opSeg		  |     		  | Ss_ByVal_Seg      | SegMarker
                    exSeg                 | 0
                    LrRwExp1              | ORW_Seg;
opStCall          |                       | Ss_StCall         | 0
                    exStCall              | 4+OPA_fTxtFind+OPA_fExecute
                    LrStCall              | ORW_Call;
opStCallLess      |                       | Ss_StCallLess     | 0
                    exStCallLess          | 4+OPA_fTxtFind+OPA_fExecute
                    LrStCallLess          | 0;
opStCallS	  |     		  | Ss_StCallS	      | 0
                    exStCallS             | 4+OPA_fTxtFind+OPA_fExecute
                    LrStCallS             | ORW_CallS;
opStCaseElse      |                       | Ss_CaseElse       | 0
                    mStCaseElse           | OPA_fExecute
                    LrStCaseElse          | ORW_Case;
opStCase          |                       | Ss_Case           | 0
                    mStCase               | OPA_fExecute
                    LrStCase              | ORW_Case;
opStCaseTo        |                       | Ss_CaseTo         | 0
                    mStCaseTo             | OPA_fExecute
                    LrStCaseTo            | ORW_To;

#
# start of contiguous block assumed by NtCaseRelation() in parser
#

opStCaseEq        |                       | Ss_Case           | 0
                    mStCaseEq             | 0+OPA_fExecute
                    LrStCaseRel           | '=';
opStCaseLt        |                       | Ss_Case           | 0
                    mStCaseLt             | 0+OPA_fExecute
                    LrStCaseRel           | '<';
opStCaseGt        |                       | Ss_Case           | 0
                    mStCaseGt             | 0+OPA_fExecute
                    LrStCaseRel           | '>';
opStCaseLe        |                       | Ss_Case           | 0
                    mStCaseLe             | 0+OPA_fExecute
                    LrStCaseRel           | "=<";
opStCaseGe        |                       | Ss_Case           | 0
                    mStCaseGe             | 0+OPA_fExecute
                    LrStCaseRel           | "=>";
opStCaseNe        |                       | Ss_Case           | 0
                    mStCaseNe             | 0+OPA_fExecute
		    LrStCaseRel 	  | "><";

#
# end of contiguous block assumed by NtCaseRelation() in parser
#

opStChain	  |     		  | Ss_4ET_ET	      | SSR_SD_None
                    exStChain             | 0+OPA_fExecute
                    LrRwExp1              | ORW_Chain;
opStDeclare       |                       | Ss_StDeclare      | 0
                    exStDeclare           | OPA_CntMask+OPA_fSsRude+OPA_fTxtFind
                    LrStDeclare           | ORW_Declare;
opStDefFn	  |     		  | Ss_StDefFn	      | 0
                    exStDefFn             | OPA_CntMask+OPA_fSsRude+OPA_fTxtFind+OPA_fExecute
                    LrStDefFn             | ORW_Def;
opStDo            |                       | Ss_Do             | 0
                    ExStDo                | 0+OPA_fExecute
                    LrRw                  | ORW_Do;
opStDoUntil       |                       | Ss_DoLoop         | low STYP_DoUntil
                    mStDoUntilOpExe       | 2+OPA_fExecute
                    LrStDoUntil           | ORW_Until;
opStDoWhile       |                       | Ss_DoLoop         | low STYP_DoWhile
                    mStDoWhileOpExe       | 2+OPA_fExecute
                    LrStDoWhile           | ORW_While;

#
# start of contiguous block assumed by NtIfStmt() in parser
#

opStElse          |                       | Ss_Else           | 0
                    exStElse              | 2+OPA_fTxtFind
                    LrStElse              | ORW_Else;
opStElseLab       |                       | Ss_LabelRef       | SSR_1Lab0Arg
                    exStElseLab           | 2+OPA_fTxtFind
                    LrStElseLab           | ORW_Else;
opStElseLabDirect |                       | Ss_LabelRef       | SSR_1Lab0Arg
                    exStElseLabDirect     | 2
		    LrStElseLabDirect	  | ORW_Else;

#
# end of contiguous block assumed by NtIfStmt() in parser
#

opStElseNop       |                       | Ss_ElseNop        | 0
                    exStElseNop           | 0
                    LrStElseNop           | ORW_Else;
opStElseIf        |                       | Ss_ElseIf         | 0
                    mStElseIfOpExe        | 2
                    LrStElseIf            | ORW_ElseIf;
opStEnd           |                       | Ss_0_0            | 0
                    exStEnd               | 0
                    LrRw                  | ORW_End;
opStEndDef	  |     		  | Ss_StEndDef       | 0
                    ExStEndDef            | 4+OPA_fSsRude+OPA_fTxtFind
                    LrStEndDef            | ORW_Def;
opStEndIfBlock    |                       | Ss_EndIf          | 0
                    exStEndIfBlock        | 0
                    LrStEndIfBlock        | ORW_If;
opStEndProc       |                       | Ss_StEndProc      | 0
                    ExStEndProc           | OPA_fTxtFind
                    LrStEndProc           | ORW_End;
opStEndSelect     |                       | Ss_EndSelect      | 0
                    mStEndSelect          | 0
                    LrStEndSelect         | ORW_Select;
opStExitDo        |                       | Ss_Exit           | high STYP_Do
                    ExStExitDo            | 2
                    LrStExitDo            | ORW_Do;
opStExitFor       |                       | Ss_Exit           | high STYP_For
                    exStExitFor           | 2
                    LrStExitFor           | ORW_For;
opStExitProc      |                       | Ss_StExitProc     | 0
                    ExStExitProc          | 2
                    LrStExitProc          | ORW_Exit;
opStFor           |                       | Ss_For            | 0
                    mStForOpExe           | 4+OPA_fSsRude+OPA_fTxtFind+OPA_fExecute
                    LrStFor               | ORW_For;
opStForStep       |                       | Ss_For            | low STYP_Step
                    mStForStepOpExe       | 4+OPA_fSsRude+OPA_fTxtFind+OPA_fExecute
                    LrStForStep           | ORW_For;
opStFunction      |                       | Ss_StFunction     | 0
                    exStFunction          | OPA_CntMask+OPA_fSsRude+OPA_fTxtFind
                    LrStFunction          | ORW_FUNCTION;
opStGosub         |                       | Ss_LabelRef       | SSR_1Lab0Arg
                    exStGosub             | 2+OPA_fTxtFind+OPA_fExecute
                    LrStGosub             | ORW_Gosub;
opStGosubDirect   |                       | Ss_LabelRef       | SSR_1Lab0Arg
                    exStGosubDirect       | 2+OPA_fTxtFind
                    LrStGosubDirect       | ORW_Gosub;
opStGoto          |                       | Ss_LabelRef       | SSR_1Lab0Arg
                    exStGoto              | 2+OPA_fTxtFind+OPA_fExecute
                    LrStGoto              | ORW_Goto;
opStGotoDirect    |                       | Ss_LabelRef       | SSR_1Lab0Arg
                    exStGotoDirect        | 2+OPA_fTxtFind
                    LrStGotoDirect        | ORW_Goto;

#
# start of contiguous block assumed by NtIfStmt() in parser
#

opStIf            |                       | Ss_If             | 0
                    mStIfOpExe            | 2+OPA_fTxtFind+OPA_fExecute
                    LrStIf                | ORW_If;
opStIfLab         |                       | Ss_IfLab          | SSR_1Lab0Arg
                    mStIfLabOpExe         | 2+OPA_fTxtFind+OPA_fExecute
                    LrStIfLab             | ORW_If;
opStIfLabDirect   |                       | Ss_IfLab          | SSR_1Lab0Arg
                    mStIfLabDirectOpExe   | 2+OPA_fTxtFind
                    LrStIfLabDirect       | ORW_If;
opStIfGotoLab     |                       | Ss_IfLab          | SSR_1Lab0Arg
                    mStIfGotoLabOpExe     | 2+OPA_fTxtFind+OPA_fExecute
		    LrStIfGotoLab	  | ORW_If;

#
# end of contiguous block assumed by NtIfStmt() in parser
#

opStIfBlock       |                       | Ss_IfBlock        | 0
                    mStIfBlockOpExe       | 2+OPA_fExecute
                    LrStIfBlock           | ORW_If;
opStLoop          |                       | Ss_Loop           | 0
                    ExStLoop              | 2+OPA_fExecute
                    LrStLoop              | ORW_Loop;
opStLoopUntil     |                       | Ss_LoopWhile      | low STYP_DoUntil
                    mStLoopUntilOpExe     | 2+OPA_fExecute
                    LrStLoopUntil         | ORW_Until;
opStLoopWhile     |                       | Ss_LoopWhile      | low STYP_DoWhile
                    mStLoopWhileOpExe     | 2+OPA_fExecute
                    LrStLoopWhile         | ORW_While;
opStNext          |                       | Ss_Next           | 0
                    mStNextOpExe          | 4+OPA_fSsRude
                    LrStNext              | ORW_Next;
opStNextId        |                       | Ss_NextId         | 0
                    mStNextIdOpExe        | 4+OPA_fSsRude
                    LrStNextId            | ORW_Next;

opStOnError       |                       | Ss_MrsLabelRef    | SSR_1LabMain0Arg
                    exStOnError           | 2+OPA_fTxtFind+OPA_fExecute
                    LrStOnError           | ORW_Error;

opStOnGosub       |                       | Ss_nLabelRef      | SSR_nLab1Arg
                    exStOnGosub           | OPA_CntMask+OPA_fTxtFind+OPA_fExecute
                    LrStOnGosub           | ORW_Gosub;
opStOnGoto        |                       | Ss_nLabelRef      | SSR_nLab1Arg
                    exStOnGoto            | OPA_CntMask+OPA_fTxtFind+OPA_fExecute
                    LrStOnGoto            | ORW_Goto;

#
# start of prscg.c assumed contiguous block
#

opStRestore0      |                       | Ss_0_0            | 0
                    exStRestore0          | 0+OPA_fExecute
                    LrRw                  | ORW_Restore;
opStRestore1      |                       | Ss_MrsLabelRef    | SSR_1LabMain0Arg
                    exStRestore1          | 2+OPA_fTxtFind+OPA_fExecute
                    LrStRestore1          | ORW_Restore;

opStResume0       |                       | Ss_NotInProc      | 0
                    exStResume0           | OPA_fTxtFind+OPA_fExecute
                    LrRw                  | ORW_Resume;
opStResume        |                       | Ss_MrsMrsLabRef   | SSR_1LabMain0Arg
                    exStResume            | 2+OPA_fTxtFind+OPA_fExecute
                    LrStResume            | ORW_Resume;
opStResumeNext    |                       | Ss_NotInProc      | 0
                    exStResumeNext        | OPA_fTxtFind+OPA_fExecute
                    LrStResumeNext        | ORW_Resume;

opStReturn0       |                       | Ss_0_0            | 0
                    exStReturn0           | 0+OPA_fExecute
                    LrRw                  | ORW_Return;
opStReturn1	  |     		  | Ss_MrsMrsLabRef   | SSR_1LabMain0Arg
                    exStReturn1           | 2+OPA_fTxtFind+OPA_fExecute
                    LrStReturn1           | ORW_Return;
#
# end of prscg.c assumed contiguous block
#

opStRunFile       |                       | Ss_4ET_ET         | SSR_SD_None
                    exStRunFile           | 0+OPA_fExecute
		    LrRwExp1		  | ORW_Run;

#
# Note: the following label is always an oName.
#

opStRunLabel	  |     		  | Ss_MrsLabelRef    | SSR_1LabMain0Arg
                    exStRunLabel          | 2+ OPA_fTxtFind+OPA_fExecute
                    LrStRunLabel          | ORW_Run;
opStRunMain	  |     		  | Ss_0_0	      | 0
                    exStRunMain           | OPA_fTxtFind+OPA_fExecute
                    LrRw                  | ORW_Run;
opStSelectCase    |                       | Ss_Select         | 0
                    mStSelect             | 2+OPA_fExecute
                    LrStSelectCase        | ORW_Select;
opStStop          |                       | Ss_0_0            | 0
                    exStStop              | 0+OPA_fExecute
                    LrRw                  | ORW_Stop;
opStSub           |                       | Ss_StSub          | 0
                    exStSub               | OPA_CntMask+OPA_fSsRude+OPA_fTxtFind
                    LrStSub               | ORW_SUB;
opStWait2	  |     		  | Ss_4ET_ET	      | SSR_I4I2_None
                    exStWait2             | 0+OPA_fExecute
                    LrRwExp2              | ORW_Wait;
opStWait3	  |     		  | Ss_4ET_ET	      | SSR_I42I2_None
                    exStWait3             | 0+OPA_fExecute
                    LrRwExp3              | ORW_Wait;
opStWend          |                       | Ss_Wend           | 0
                    ExStWend              | 2
                    LrStWend              | ORW_Wend;
opStWhile         |                       | Ss_While          | 0
                    mStWhileOpExe         | 2+OPA_fExecute
                    LrStWhile             | ORW_While;
opWatchExp        |                       | Ss_1FnPExe        | SSR_1Any_None
		    mptyppexWatchExp	  | OPA_fTxtFind
                    LrWatchExp            | 0;
opWatchStop       |                       | Ss_4ET_ET         | SSR_I4_None
                    exWatchStop           | OPA_fTxtFind
                    LrWatchStop           | 0;


########################################################################
#	Start of general statement-related opcodes
########################################################################

@STMT

opChanOut	  |			  | Ss_4ET_ET	      | SSR_I2_None
                    exChanOut             | OPA_fExecute
                    LrChanOut             | 0;
opCircleAspect	  |     		  | Ss_4ET_ET	      | SSR_R4_None
                    exCircleAspect        | OPA_fExecute
                    LrCircleAspect        | 0;
opCircleEnd	  |     		  | Ss_4ET_ET	      | SSR_R4_None
                    exCircleEnd           | OPA_fExecute
                    LrCircleEnd           | 0;
opCircleStart	  |     		  | Ss_4ET_ET	      | SSR_R4_None
                    exCircleStart         | OPA_fExecute
                    LrCircleStart         | ORW_Circle;
opCoord 	  |     		  | Ss_2FnSamePExe    | SSR_2I2R4_None
		    mptyppexCoord	  | OPA_fExecute
                    LrCoord               | 0;
opCoordStep	  |     		  | Ss_2FnSamePExe    | SSR_2I2R4_None
		    mptyppexCoordStep	  | OPA_fExecute
                    LrCoordStep           | 0;
opCoordSecond	  |     		  | Ss_2FnSamePExe    | SSR_2I2R4_None
		    mptyppexCoordSecond   | OPA_fExecute
                    LrCoordSecond         | 0;
opCoordStepSecond |     		  | Ss_2FnSamePExe    | SSR_2I2R4_None
		    mptyppexCoordStepSecond | OPA_fExecute
                    LrCoordStepSecond     | 0;
opFieldInit	  |     		  | Ss_4ET_ET	      | SSR_I2_None
                    exFieldInit           | OPA_fExecute
                    LrFieldInit           | ORW_Field;
opFieldItem	  |     		  | Ss_FieldItem      | SSR_I2SD_None
                    exFieldItem           | OPA_fExecute
                    LrFieldItem           | ORW_AS;
opInputChan       |                       | Ss_4ET_ET         | SSR_I2_None
                    exInputChan           | OPA_fExecute
                    LrInputChan           | 0;
opInputEos        |                       | Ss_0_0            | 0
                    exInputEos            | OPA_fExecute
                    LrNoList              | ORW_Input;
opInputPrompt     |                       | Ss_InputPrompt    | 0
                    exInputPrompt         | OPA_fExecute+OPA_CntMask
                    LrInputPrompt         | ORW_Input;
opLbs             |                       | Ss_0_0            | 0
                    exLbs                 | 0
                    LrUnaryChar           | '#';
opNoList0         |                       | Ss_NoList0        | 0
                    ExNoList1             | 0
                    LrNoList              | 0;
opNoList1         |                       | Ss_NoList1        | 0
                    ExNoList1             | 2+OPA_fTxtFind
                    LrNoList1             | 0;
opNoList2         |                       | Ss_NoList2        | 0
                    ExNotDefined          | 4
                    LrNoList2             | 0;
opNoList3         |                       | Ss_NoList3        | 0
                    ExNotDefined          | 6
                    LrNoList3             | 0;
opPrintSpc        |                       | Ss_4ET_ET         | SSR_I2_None
                    exPrintSpc            | OPA_fExecute
                    LrPrintSpc            | ORW_Spc;
opPrintTab        |                       | Ss_4ET_ET         | SSR_I2_None
                    exPrintTab            | OPA_fExecute
                    LrPrintTab            | ORW_Tab;
opPrintComma      |                       | Ss_0_0            | 0
                    exPrintComma          | OPA_fExecute
                    LrPrintComma          | ',';
opPrintSemi       |                       | Ss_0_0            | 0
                    exPrintSemi           | OPA_fExecute
                    LrPrintSemi           | 59;
opPrintEos        |                       | Ss_0_0            | 0
                    exPrintEos            | OPA_fExecute
                    LrPrintEos            | 0;
opPrintItemComma  |                       | Ss_1FnPExe        | SSR_1Any_None
		    mptyppexPrintItemComma | OPA_fExecute
                    LrPrintItemComma      | ',';
opPrintItemSemi   |                       | Ss_1FnPExe        | SSR_1Any_None
		    mptyppexPrintItemSemi | OPA_fExecute
                    LrPrintItemSemi       | 59;
opPrintItemEos    |                       | Ss_1FnPExe        | SSR_1Any_None
		    mptyppexPrintItemEos  | OPA_fExecute
                    LrPrintItemEos        | 0;
opQuoteRem        |                       | Ss_0_0            | 0
                    exQuoteRem            | OPA_CntMask+OPA_fTxtFind
                    LrQuoteRem            | 0;
opNop             |                       | Ss_0_0            | 0
                    exNop                 | 0
                    LrNoList              | 0;
op_Include	  |     		  | Ss_0_0	      | 0
                    ex_Include            | OPA_CntMask+OPA_fTxtFind
                    Lr_Include            | 0;

#
# beginning of statement executors
#

opStBeep	  |			  | Ss_0_0	      | 0
		    exStBeep0		  | 0+OPA_fExecute
                    LrRw                  | ORW_Beep;
opStBLoad1	  |     		  | Ss_4ET_ET	      | SSR_SD_None
		    exStBLoad1		  | 0+OPA_fExecute
		    LrRwExp1		  | ORW_BLoad;
opStBLoad2	  |     		  | Ss_4ET_ET	      | SSR_SDI4_None
		    exStBLoad2		  | 0+OPA_fExecute
		    LrRwExp2		  | ORW_BLoad;
opStBSave	  |     		  | Ss_4ET_ET	      | SSR_SD2I4_None
		    exStBSave		  | 0+OPA_fExecute
		    LrRwExp3		  | ORW_BSave;
opStChDir	  |			  | Ss_4ET_ET	      | SSR_SD_None
		    exStChDir		  | 0+OPA_fExecute
		    LrRwExp1		  | ORW_ChDir;
opStCircle	  |     		  | Ss_4ET_ET	      | SSR_R4_None
                    exStCircle            | 0+OPA_fExecute
                    LrStCircle            | ORW_Circle;
opStCircleColor   |     		  | Ss_4ET_ET	      | SSR_R4I2_None
                    exStCircleColor       | 0+OPA_fExecute
                    LrStCircleColor       | ORW_Circle;
opStClear	  |     		  | Ss_StCnt	      | ET_I4
                    exStClear             | 2+OPA_fExecute
                    LrStClear             | ORW_Clear;
opStClose	  |			  | Ss_StCnt	      | ET_I2
                    exStClose             | 2+OPA_fExecute
                    LrStClose             | ORW_Close;
opStCls 	  |     		  | Ss_4ET_ET	      | SSR_I2_None
                    exStCls               | 0+OPA_fExecute
                    LrRwExp1              | ORW_Cls;
opStColor	  |     		  | Ss_StCnt	      | ET_I2
                    exStColor             | 2+OPA_fExecute
                    LrStColor             | ORW_Color;
opStCommon	  |     		  | Ss_StCommon       | 0
                    exStCommon            | 4+OPA_fSsRude+OPA_fTxtFind
                    LrStCommon            | ORW_Common;
opStData          |                       | Ss_StData         | 0
                    exStData              | OPA_CntMask+OPA_fTxtFind
                    LrStData              | ORW_Data;
opStDate_         |                       | Ss_4ET_ET         | SSR_SD_None
                    exStDate_             | 0+OPA_fExecute
                    LrStDate_             | ORW_Date_;
opStDefSeg0	  |     		  | Ss_0_0	      | 0
                    exStDefSeg0           | 0+OPA_fExecute
                    LrStDefSeg0           | ORW_DEF;
opStDefSeg1	  |     		  | Ss_4ET_ET	      | SSR_I4_None
                    exStDefSeg1           | 0+OPA_fExecute
                    LrStDefSeg1           | ORW_DEF;
opStDraw	  |     		  | Ss_4ET_ET	      | SSR_SD_None
                    exStDraw              | 0+OPA_fExecute
                    LrRwExp1              | ORW_Draw;
opStEnviron       |                       | Ss_4ET_ET         | SSR_SD_None
                    exStEnviron           | 0+OPA_fExecute
                    LrRwExp1              | ORW_Environ;
opStErase         |                       | Ss_Erase          | 0
                    exStErase             | 2+OPA_fExecute
                    LrStErase             | ORW_Erase;
opStError         |                       | Ss_4ET_ET         | SSR_I2_None
                    exStError             | 0+OPA_fExecute
                    LrRwExp1              | ORW_Error;
opStFiles0	  |     		  | Ss_0_0	      | 0
                    exStFiles0            | 0+OPA_fExecute
                    LrRw                  | ORW_Files;
opStFiles1	  |     		  | Ss_4ET_ET	      | SSR_SD_None
                    exStFiles1            | 0+OPA_fExecute
                    LrRwExp1              | ORW_Files;
opStGet1          |                       | Ss_4ET_ET         | SSR_I2_None
                    exStGet1              | 0+OPA_fExecute
                    LrRwExp1              | ORW_Get;
opStGet2          |                       | Ss_4ET_ET         | SSR_I2I4_None
                    exStGet2              | 0+OPA_fExecute
                    LrRwExp2              | ORW_Get;
opStGetRec2       |                       | Ss_FPutGet2       | 0
                    exStGetRec2           | 2+OPA_fExecute
                    LrStGetRec2           | ORW_Get;
opStGetRec3       |                       | Ss_FPutGet3       | 0
                    exStGetRec3           | 2+OPA_fExecute
                    LrStGetRec3           | ORW_Get;
opStGraphicsGet   |     		  | Ss_GPutGet	      | 0
                    exStGraphicsGet       | 0+OPA_fExecute
                    LrStGraphicsGet       | ORW_Get;
opStGraphicsPut   |     		  | Ss_GPutGet	      | 0
                    exStGraphicsPut       | 2+OPA_fExecute
                    LrStGraphicsPut       | ORW_Put;
opStInput         |                       | Ss_Input          | 0
                    mStInputOpExe         | 0+OPA_fExecute
                    LrStInput             | ORW_Input;
opStIoctl	  |     		  | Ss_4ET_ET	      | SSR_I2SD_None
                    exStIoctl             | 0+OPA_fExecute
                    LrRwExp2              | ORW_Ioctl;
opStKey 	  |     		  | Ss_0_0	      | 0
                    exStKey               | 2+OPA_fExecute
                    LrStKey               | ORW_Key;
opStKeyMap	  |     		  | Ss_4ET_ET	      | SSR_I2SD_None
                    exStKeyMap            | 0+OPA_fExecute
                    LrRwExp2              | ORW_Key;
opStKill          |                       | Ss_4ET_ET         | SSR_SD_None
                    exStKill              | 0+OPA_fExecute
                    LrRwExp1              | ORW_Kill;

#
# start of contiguous block assumed by parser
#

opStLine	  |     		  | Ss_0_0	      | 0
                    exStLine              | 2+OPA_fExecute
                    LrStLine              | ORW_Line;
opStLineColor	  |     		  | Ss_4ET_ET	      | SSR_I2_None
                    exStLineColor         | 2+OPA_fExecute
                    LrStLineColor         | ORW_Line;
opStLineStyle	  |     		  | Ss_4ET_ET	      | SSR_I2_None
                    exStLineStyle         | 2+OPA_fExecute
                    LrStLineStyle         | ORW_Line;
opStLineStyleColor|     		  | Ss_4ET_ET	      | SSR_2I2_None
                    exStLineStyleColor    | 2+OPA_fExecute
                    LrStLineStyleColor    | ORW_Line;
#
# end of contiguous block assumed by parser
#

opStLet           |                       | Ss_0_0            | 0
                    exStLet               | 0+OPA_fExecute
                    LrRwSpc               | ORW_Let;
opStLineInput     |                       | Ss_LineInput      | 0
                    exStLineInput         | 2+OPA_fExecute
                    LrStLineInput         | ORW_Input;
opStLocate	  |     		  | Ss_StCnt	      | ET_I2
                    exStLocate            | 2+OPA_fExecute
                    LrStLocate            | ORW_Locate;
opStLock          |                       | Ss_StLock         | 0
                    exStLock              | 2+OPA_fExecute
                    LrStLock              | ORW_Lock;
opStLPrint	  |     		  | Ss_0_0	      | 0
		    exStLPrint		  | 0+OPA_fExecute
		    LrStLPrint		  | ORW_LPrint;
opStLSet	  |			  | Ss_LSet	      | 0
		    mStLSetOpExe	  | 0+OPA_fExecute
		    LrStLSet		  | ORW_LSet;
opStMid_2         |                       | Ss_LRSetMid       | 1
                    mStMid_2OpExe         | 0+OPA_fExecute
                    LrStMid_2             | ORW_Mid_;
opStMid_3         |                       | Ss_LRSetMid       | 2
                    mStMid_3OpExe         | 0+OPA_fExecute
                    LrStMid_3             | ORW_Mid_;
opStMkDir	  |			  | Ss_4ET_ET	      | SSR_SD_None
		    exStMkDir		  | 0+OPA_fExecute
		    LrRwExp1		  | ORW_MkDir;
opStName          |                       | Ss_4ET_ET         | SSR_2SD_None
                    exStName              | 0+OPA_fExecute
                    LrStName              | ORW_Name;
opStOpen2         |                       | Ss_4ET_ET         | SSR_SDI2_None
                    exStOpen2             | 2+OPA_fExecute
                    LrStOpen2             | ORW_Open;
opStOpen3         |                       | Ss_4ET_ET         | SSR_SD2I2_None
                    exStOpen3             | 2+OPA_fExecute
                    LrStOpen3             | ORW_Open;
opStOpenOld3      |                       | Ss_4ET_ET         | SSR_SDI2SD_None
                    exStOpenOld3          | 0+OPA_fExecute
                    LrStOpenOld3          | ORW_Open;
opStOpenOld4      |                       | Ss_4ET_ET         | SSR_SDI2SDI2_None
                    exStOpenOld4          | 0+OPA_fExecute
                    LrStOpenOld4          | ORW_Open;
opStOptionBase0   |                       | Ss_OptionBase0    | 0
                    exStOptionBase0       | 0
                    LrStOptionBase0       | '0';
opStOptionBase1   |                       | Ss_OptionBase1    | 0
                    exStOptionBase1       | 0
                    LrStOptionBase1       | '1';
opStOut           |                       | Ss_4ET_ET         | SSR_I4I2_None
                    exStOut               | 0+OPA_fExecute
                    LrRwExp2              | ORW_Out;
opStPaint2	  |     		  | Ss_PaintWidth     | SSR_1I2SD_None
		    mptyppexStPaint	  | 0+OPA_fExecute
                    LrStPaint2            | ORW_Paint;
opStPaint3	  |     		  | Ss_4ET_ET	      | SSR_SDI2SD_None
                    exStPaint3            | 0+OPA_fExecute
                    LrStPaint3            | ORW_Paint;
opStPalette0	  |     		  | Ss_0_0	      | 0
                    exStPalette0          | 0+OPA_fExecute
                    LrRw                  | ORW_Palette;
opStPalette2	  |     		  | Ss_4ET_ET	      | SSR_I2I4_None
                    exStPalette2          | 0+OPA_fExecute
                    LrRwExp2              | ORW_Palette;
opStPaletteUsing  |     		  | Ss_PaletteUsing   | 0
                    exStPaletteUsing      | 0+OPA_fExecute
                    LrStPaletteUsing      | ORW_Palette;
opStPCopy	  |     		  | Ss_4ET_ET	      | SSR_2I2_None
                    exStPCopy             | 0+OPA_fExecute
                    LrRwExp2              | ORW_PCopy;
opStPlay	  |     		  | Ss_4ET_ET	      | SSR_SD_None
                    exStPlay              | 0+OPA_fExecute
                    LrRwExp1              | ORW_Play;
opStPoke          |                       | Ss_4ET_ET         | SSR_I4I2_None
                    exStPoke              | 0+OPA_fExecute
                    LrRwExp2              | ORW_Poke;
opStPreset	  |     		  | Ss_0_0	      | 0
                    exStPreset            | 0+OPA_fExecute
                    LrStPreset            | ORW_Preset;
opStPresetColor   |     		  | Ss_4ET_ET	      | SSR_I2_None
                    exStPresetColor       | 0+OPA_fExecute
                    LrStPresetColor       | ORW_Preset;
opStPset	  |     		  | Ss_0_0	      | 0
                    exStPset              | 0+OPA_fExecute
                    LrStPset              | ORW_Pset;
opStPsetColor	  |     		  | Ss_4ET_ET	      | SSR_I2_None
                    exStPsetColor         | 0+OPA_fExecute
                    LrStPsetColor         | ORW_Pset;
opStPut1          |                       | Ss_4ET_ET         | SSR_I2_None
                    exStPut1              | 0+OPA_fExecute
                    LrRwExp1              | ORW_Put;
opStPut2          |                       | Ss_4ET_ET         | SSR_I2I4_None
                    exStPut2              | 0+OPA_fExecute
                    LrRwExp2              | ORW_Put;
opStPutRec2       |                       | Ss_FPutGet2       | 0
                    exStPutRec2           | 2+OPA_fExecute
                    LrStPutRec2           | ORW_Put;
opStPutRec3       |                       | Ss_FPutGet3       | 0
                    exStPutRec3           | 2+OPA_fExecute
                    LrStPutRec3           | ORW_Put;
opStRandomize0    |                       | Ss_0_0            | 0
                    exStRandomize0        | 0+OPA_fExecute
                    LrRw                  | ORW_Randomize;
opStRandomize1    |                       | Ss_4ET_ET         | SSR_R8_None
                    exStRandomize1        | 0+OPA_fExecute
                    LrRwExp1              | ORW_Randomize;
opStRead          |                       | Ss_Input          | 0
                    mStReadOpExe          | 0+OPA_fExecute
                    LrStRead              | ORW_Read;
opStRem           |                       | Ss_0_0            | 0
                    exStRem               | OPA_CntMask+OPA_fTxtFind
                    LrStRem               | ORW_Rem;
opStReset         |                       | Ss_0_0            | 0
                    exStReset             | 0+OPA_fExecute
                    LrRw                  | ORW_Reset;
opStRmDir	  |			  | Ss_4ET_ET	      | SSR_SD_None
		    exStRmDir		  | 0+OPA_fExecute
		    LrRwExp1		  | ORW_RmDir;
opStRSet	  |			  | Ss_LRSetMid       | 0
		    mStRSetOpExe	  | 0+OPA_fExecute
		    LrStRSet		  | ORW_RSet;
opStScreen	  |     		  | Ss_StCnt	      | ET_I2
                    exStScreen            | 2+OPA_fExecute
                    LrStScreen            | ORW_Screen;
opStSeek          |                       | Ss_4ET_ET         | SSR_I2I4_None
                    exStSeek              | OPA_fExecute
                    LrRwExp2              | ORW_Seek;
opStShell0	  |    			  | Ss_0_0	      | 0
                    exStShell0            | 0+OPA_fExecute
                    LrRw                  | ORW_Shell;
opStShell1	  |    			  | Ss_4ET_ET	      | SSR_SD_None
                    exStShell1            | 0+OPA_fExecute
                    LrRwExp1              | ORW_Shell;

opStSleep0        |                       | Ss_0_0            | 0
                    exStSleep0            | 0+OPA_fExecute
                    LrRw                  | ORW_Sleep;

opStSound	  |     		  | Ss_4ET_ET	      | SSR_I2R4_None
                    exStSound             | 0+OPA_fExecute
                    LrRwExp2              | ORW_Sound;
opStSwap	  |     		  | Ss_Swap	      | 0
                    mStSwapOpExe          | 2+OPA_fExecute
                    LrStSwap              | ORW_Swap;
opStSystem        |                       | Ss_0_0            | 0
                    exStSystem            | 0+OPA_fExecute
                    LrRw                  | ORW_System;
opStTime_         |                       | Ss_4ET_ET         | SSR_SD_None
                    exStTime_             | 0+OPA_fExecute
                    LrStTime_             | ORW_Time_;
opStTroff	  |     		  | Ss_0_0	      | 0
                    exStTroff             | OPA_fExecute
                    LrRw                  | ORW_Troff;
opStTron	  |     		  | Ss_0_0	      | 0
                    exStTron              | OPA_fExecute
                    LrRw                  | ORW_Tron;
opStUnLock        |                       | Ss_StLock         | 0
                    exStUnLock            | 2+OPA_fExecute
                    LrStUnLock            | ORW_UnLock;
opStView	  |     		  | Ss_StView	      | ET_I2
                    exStView              | 0+OPA_fExecute
                    LrStView              | ORW_View;
opStView0	  |     		  | Ss_0_0	      | 0
                    exStView0             | 0+OPA_fExecute
                    LrRw                  | ORW_View;
opStViewPrint0	  |     		  | Ss_0_0	      | 0
                    exStViewPrint0        | 0+OPA_fExecute
                    LrStViewPrint0        | ORW_View;
opStViewPrint2	  |     		  | Ss_4ET_ET	      | SSR_2I2_None
                    exStViewPrint2        | 0+OPA_fExecute
                    LrStViewPrint2        | ORW_View;
opStViewScreen	  |     		  | Ss_StView	      | ET_I2
                    exStViewScreen        | 0+OPA_fExecute
		    LrStViewScreen	  | ORW_View;

opStWidth2        |                       | Ss_PaintWidth     | SSR_1I2SD_None
		    mptyppexStWidth2	  | 0+OPA_fExecute
                    LrStWidth2            | ORW_Width;

opStWidthLPrint   |     		  | Ss_4ET_ET	      | SSR_I2_None
		    exStWidthLPrint	  | 0+OPA_fExecute
		    LrStWidthLPrint	  | ORW_Width;
opStWidthFile	  |			  | Ss_4ET_ET	      | SSR_2I2_None
		    exStWidthFile	  | 0+OPA_fExecute
		    LrStWidthFile	  | ORW_Width;
opStWindow	  |     		  | Ss_4ET_ET	      | SSR_4R4_None
                    exStWindow            | 0+OPA_fExecute
                    LrStWindow            | ORW_Window;
opStWindow0	  |     		  | Ss_0_0	      | 0
                    exStWindow0           | 0+OPA_fExecute
                    LrRw                  | ORW_Window;
opStWindowScreen  |     		  | Ss_4ET_ET	      | SSR_4R4_None
                    exStWindowScreen      | 0+OPA_fExecute
                    LrStWindowScreen      | ORW_Window;
opStWrite         |                       | Ss_0_0            | 0
                    exStWrite             | 0+OPA_fExecute
                    LrStWrite             | ORW_Write;

opUsing           |                       | Ss_4ET_ET         | SSR_SD_None
                    exUsing               | 0
                    LrUsing               | ORW_Using;


########################################################################
#	Start of opcodes related to Intrinsic functions
########################################################################

@INTRSC

opAdd             |                       | Ss_2FnSamePExe    | SSR_2Any_Same
                    mAddOpExe             | 0
                    LrBinaryOp            | '+';
opAnd             |                       | Ss_2FnSamePExe    | SSR_2I2I4_Same
                    mAndOpExe             | 0
                    LrBinaryRw            | ORW_And;
opDiv		  |			  | Ss_2FnSamePExe    | SSR_Div
                    mDivOpExe             | 0
                    LrBinaryOp            | '/';
opEQ              |                       | Ss_2FnSamePExe    | SSR_2Any_I2
                    mEQOpExe              | 0
                    LrBinaryOp            | '=';
opEqv             |                       | Ss_2FnSamePExe    | SSR_2I2I4_Same
                    mEqvOpExe             | 0
                    LrBinaryRw            | ORW_Eqv;

#
# beginning of functions
#

opFnAbs           |                       | Ss_1FnPExe        | SSR_1NotSd_Same
                    mFnAbsOpExe           | 0
                    LrFunc1Arg            | ORW_Abs;
opFnAsc           |                       | Ss_4ET_ET         | SSR_SD_I2
                    exFnAsc               | 0
                    LrFunc1Arg            | ORW_Asc;

opFnAtn 	  |			  | Ss_1FnPExeR8      | 0
		    exFnAtn		  | 0
		    LrFunc1Arg		  | ORW_Atn;

opCoerce	  |			  | Ss_Coerce	      | 0
		    mptyppexCoerce	  | 0
		    LrCoerce		  | 0;
opFnChr_          |                       | Ss_4ET_ET         | SSR_I2_SD
                    exFnChr_              | OPA_fHeapMove
                    LrFunc1Arg            | ORW_Chr_;
opFnCommand_      |                       | Ss_0FnETExe       | ET_SD
                    exFnCommand_          | 0
                    LrRw                  | ORW_Command_;

opFnCos 	  |			  | Ss_1FnPExeR8      | 0
		    exFnCos		  | 0
                    LrFunc1Arg            | ORW_Cos;

opFnCsrlin	  |     		  | Ss_0FnETExe       | ET_I2
                    exFnCsrlin            | 0
                    LrRw                  | ORW_Csrlin;
opFnCvd 	  |     		  | Ss_4ET_ET	      | SSR_SD_R8
                    exFnCvd               | 0
                    LrFunc1Arg            | ORW_Cvd;
opFnCvdmbf	  |     		  | Ss_4ET_ET	      | SSR_SD_R8
                    exFnCvdmbf            | 0
                    LrFunc1Arg            | ORW_Cvdmbf;
opFnCvi 	  |     		  | Ss_4ET_ET	      | SSR_SD_I2
                    exFnCvi               | 0
                    LrFunc1Arg            | ORW_Cvi;
opFnCvl 	  |     		  | Ss_4ET_ET	      | SSR_SD_I4
                    exFnCvl               | 0
                    LrFunc1Arg            | ORW_Cvl;
opFnCvs 	  |     		  | Ss_4ET_ET	      | SSR_SD_R4
                    exFnCvs               | 0
                    LrFunc1Arg            | ORW_Cvs;
opFnCvsmbf	  |     		  | Ss_4ET_ET	      | SSR_SD_R4
                    exFnCvsmbf            | 0
                    LrFunc1Arg            | ORW_Cvsmbf;
opFnDate_         |                       | Ss_0FnETExe       | ET_SD
                    exFnDate_             | 0
                    LrRw                  | ORW_Date_;
opFnEnviron_      |                       | Ss_1FnPExe        | SSR_1I2SD_SD
		    mptyppexFnEnviron_	  | 0
                    LrFunc1Arg            | ORW_Environ_;
opFnEof           |                       | Ss_4ET_ET         | SSR_I2_I2
                    exFnEof               | 0
                    LrFunc1Arg            | ORW_Eof;
opFnErdev         |                       | Ss_0FnETExe       | ET_I2
                    exFnErdev             | 0
                    LrRw                  | ORW_Erdev;
opFnErdev_        |                       | Ss_0FnETExe       | ET_SD
                    exFnErdev_            | 0
                    LrRw                  | ORW_Erdev_;
opFnErl           |                       | Ss_0FnETExe       | ET_I4
                    exFnErl               | 0
                    LrRw                  | ORW_Erl;
opFnErr           |                       | Ss_0FnETExe       | ET_I2
                    exFnErr               | 0
                    LrRw                  | ORW_Err;

opFnExp 	  |			  | Ss_1FnPExeR8      | 0
		    exFnExp		  | 0
		    LrFunc1Arg		  | ORW_Exp;

opFnFileAttr	  |			  | Ss_4ET_ET	      | SSR_I2I2_I4
		    exFnFileAttr	  | 0
		    LrFunc2Args 	  | ORW_FileAttr;
opFnFix           |                       | Ss_1FnPExe        | SSR_1NotSd_Same
                    mFnFixOpExe           | 0
		    LrFunc1Arg		  | ORW_Fix;

opFnFre           |                       | Ss_1FnPExe        | SSR_1I2SD_I4
		    mptyppexFnFre	  | 0
		    LrFunc1Arg		  | ORW_Fre;

opFnFreeFile	  |			  | Ss_0FnETExe       | ET_I2
		    exFnFreeFile	  | 0
		    LrRw		  | ORW_FreeFile;
opFnHex_          |                       | Ss_1FnPExe        | SSR_1I2I4_SD
		    mptyppexFnHex_	  | 0
                    LrFunc1Arg            | ORW_Hex_;
opFnInkey_	  |     		  | Ss_0FnETExe       | ET_SD
                    exFnInkey_            | 0
                    LrRw                  | ORW_Inkey_;
opFnInp           |                       | Ss_4ET_ET         | SSR_I4_I2
                    exFnInp               | 0
                    LrFunc1Arg            | ORW_Inp;
opFnInput_1       |                       | Ss_4ET_ET         | SSR_I2_SD
                    exFnInput_1           | 0
                    LrFunc1Arg            | ORW_Input_;
opFnInput_2       |                       | Ss_4ET_ET         | SSR_I2I2_SD
                    exFnInput_2           | 0
                    LrFunc2Args           | ORW_Input_;

opFnInstr2        |                       | Ss_4ET_ET         | SSR_SDSD_I2
                    exFnInstr2            | 0
                    LrFunc2Args           | ORW_Instr;
opFnInstr3        |                       | Ss_4ET_ET         | SSR_I2SDSD_I2
                    exFnInstr3            | 0
                    LrFunc3Args           | ORW_Instr;

opFnInt           |                       | Ss_1FnPExe        | SSR_1NotSD_Same
                    mFnIntOpExe           | 0
                    LrFunc1Arg            | ORW_Int;
opFnIoctl_	  |     		  | Ss_4ET_ET	      | SSR_I2_SD
                    exFnIoctl_            | OPA_fHeapMove
                    LrFunc1Arg            | ORW_Ioctl_;
opFnLBound1	  |			  | Ss_LUBound1       | 0
		    exFnLBound1 	  | 0
		    LrFunc1Arg		  | ORW_LBound;
opFnLBound2	  |			  | Ss_LUBound2       | 0
		    exFnLBound2 	  | 0
		    LrFunc2Args 	  | ORW_LBound;
opFnLCase_	  |			  | Ss_4ET_ET	      | SSR_SD_SD
		    exFnLCase_		  | OPA_fHeapMove
		    LrFunc1Arg		  | ORW_LCase_;

opFnLTrim_	  |			  | Ss_4ET_ET	      | SSR_SD_SD
		    exFnLTrim_		  | OPA_fHeapMove
		    LrFunc1Arg		  | ORW_LTrim_;
opFnLeft_         |                       | Ss_4ET_ET         | SSR_SDI2_SD
                    exFnLeft_             | OPA_fHeapMove
		    LrFunc2Args 	  | ORW_Left_;

opFnLen           |                       | Ss_FnLen          | 0
                    exFnLen               | 2
                    LrFnLen               | ORW_Len;
opFnLoc           |                       | Ss_4ET_ET         | SSR_I2_I4
                    exFnLoc               | 0
                    LrFunc1Arg            | ORW_Loc;
opFnLof           |                       | Ss_4ET_ET         | SSR_I2_I4
                    exFnLof               | 0
		    LrFunc1Arg		  | ORW_Lof;

opFnLog 	  |			  | Ss_1FnPExeR8      | 0
		    exFnLog		  | 0
		    LrFunc1Arg		  | ORW_Log;

opFnLPos	  |     		  | Ss_4ET_ET	      | SSR_I2_I2
		    exFnLPos		  | 0
		    LrFunc1Arg		  | ORW_LPos;

opFnMid_2         |                       | Ss_4ET_ET         | SSR_SDI2_SD
                    exFnMid_2             | 0
                    LrFunc2Args           | ORW_Mid_;
opFnMid_3         |                       | Ss_4ET_ET         | SSR_SD2I2_SD
                    exFnMid_3             | 0
		    LrFunc3Args 	  | ORW_Mid_;

opFnMkd_	  |     		  | Ss_4ET_ET	      | SSR_R8_SD
                    exFnMkd_              | OPA_fHeapMove
                    LrFunc1Arg            | ORW_Mkd_;
opFnMkdmbf_	  |     		  | Ss_4ET_ET	      | SSR_R8_SD
                    exFnMkdMbf_           | OPA_fHeapMove
                    LrFunc1Arg            | ORW_Mkdmbf_;
opFnMki_	  |     		  | Ss_4ET_ET	      | SSR_I2_SD
                    exFnMki_              | OPA_fHeapMove
                    LrFunc1Arg            | ORW_Mki_;
opFnMkl_	  |     		  | Ss_4ET_ET	      | SSR_I4_SD
                    exFnMkl_              | OPA_fHeapMove
                    LrFunc1Arg            | ORW_Mkl_;
opFnMks_	  |     		  | Ss_4ET_ET	      | SSR_R4_SD
                    exFnMks_              | OPA_fHeapMove
                    LrFunc1Arg            | ORW_Mks_;
opFnMksmbf_	  |     		  | Ss_4ET_ET	      | SSR_R4_SD
                    exFnMksmbf_           | OPA_fHeapMove
                    LrFunc1Arg            | ORW_Mksmbf_;
opFnOct_          |                       | Ss_1FnPExe        | SSR_1I2I4_SD
		    mptyppexFnOct_	  | 0
                    LrFunc1Arg            | ORW_Oct_;
opFnPeek          |                       | Ss_4ET_ET         | SSR_I4_I2
                    exFnPeek              | 0
                    LrFunc1Arg            | ORW_Peek;
opFnPen 	  |     		  | Ss_4ET_ET	      | SSR_I2_I2
                    exFnPen               | 0
                    LrFunc1Arg            | ORW_Pen;
opFnPlay	  |     		  | Ss_4ET_ET	      | SSR_I2_I2
                    exFnPlay              | 0
                    LrFunc1Arg            | ORW_Play;
opFnPmap	  |     		  | Ss_4ET_ET	      | SSR_R4I2_R4
                    exFnPmap              | 0
                    LrFunc2Args           | ORW_Pmap;
opFnPoint1	  |     		  | Ss_4ET_ET	      | SSR_I2_R4
                    exFnPoint1            | 0
                    LrFunc1Arg            | ORW_Point;
opFnPoint2	  |     		  | Ss_2FnSamePExe    | SSR_2I2R4_I2
		    mptyppexFnPoint2	  | 0
                    LrFunc2Args           | ORW_Point;
opFnPos 	  |     		  | Ss_4ET_ET	      | SSR_I2_I2
                    exFnPos               | 0
                    LrFunc1Arg            | ORW_Pos;

opFnRight_	  |			  | Ss_4ET_ET	      | SSR_SDI2_SD
                    exFnRight_            | OPA_fHeapMove
		    LrFunc2Args 	  | ORW_Right_;
opFnRnd           |                       | Ss_0FnETExe       | ET_R4
                    exFnRnd               | 0
		    LrRw		  | ORW_Rnd;

opFnRnd1          |                       | Ss_4ET_ET         | SSR_R4_R4
                    exFnRnd1              | 0
		    LrFunc1Arg		  | ORW_Rnd;

opFnRTrim_	  |			  | Ss_4ET_ET	      | SSR_SD_SD
		    exFnRTrim_		  | OPA_fHeapMove
		    LrFunc1Arg		  | ORW_RTrim_;

opFnSAdd	  |     		  | Ss_SAdd	      | 0
		    exFnSAdd		  | 0
		    LrFunc1Arg		  | ORW_SAdd;
opFnScreen2	  |     		  | Ss_4ET_ET	      | SSR_I2I2_I2
                    exFnScreen2           | 0
                    LrFunc2Args           | ORW_Screen;
opFnScreen3	  |     		  | Ss_4ET_ET	      | SSR_3I2_I2
                    exFnScreen3           | 0
                    LrFunc3Args           | ORW_Screen;
opFnSeek          |                       | Ss_4ET_ET         | SSR_I2_I4
                    exFnSeek              | 0
                    LrFunc1Arg            | ORW_Seek;
opFnSetMem	  |     		  | Ss_4ET_ET	      | SSR_I4_I4
		    exFnSetMem		  | OPA_fHeapMove
		    LrFunc1Arg		  | ORW_SetMem;
opFnSgn           |                       | Ss_1FnPExe        | SSR_1NotSD_I2
                    mFnSgnOpExe           | 0
                    LrFunc1Arg            | ORW_Sgn;
opFnShell	  |			  | Ss_4ET_ET	      | SSR_SD_I2
		    exFnShell		  | 0
                    LrFunc1Arg            | ORW_Shell;

opFnSin 	  |			  | Ss_1FnPExeR8      | 0
		    exFnSin		  | 0
		    LrFunc1Arg		  | ORW_Sin;

opFnSpace_        |                       | Ss_4ET_ET         | SSR_I2_SD
                    exFnSpace_            | OPA_fHeapMove
		    LrFunc1Arg		  | ORW_Space_;

opFnSqr 	  |			  | Ss_1FnPExeR8      | 0
		    exFnSqr		  | 0
                    LrFunc1Arg            | ORW_Sqr;

opFnStick	  |     		  | Ss_4ET_ET	      | SSR_I2_I2
                    exFnStick             | 0
                    LrFunc1Arg            | ORW_Stick;
opFnStr_          |                       | Ss_1FnPExe        | SSR_1NotSD_SD
		    mptyppexFnStr_	  | 0
                    LrFunc1Arg            | ORW_Str_;
opFnStrig	  |     		  | Ss_4ET_ET	      | SSR_I2_I2
                    exFnStrig             | 0
                    LrFunc1Arg            | ORW_Strig;
opFnString_	  |			  | Ss_FnString       | SSR_1I2SD_SD
                    ExNotDefined          | OPA_fHeapMove
                    LrFunc2Args           | ORW_String_;
opFnTan 	  |			  | Ss_1FnPExeR8      | 0
		    exFnTan		  | 0
                    LrFunc1Arg            | ORW_Tan;

opFnTime_         |                       | Ss_0FnETExe       | ET_SD
                    exFnTime_             | 0
		    LrRw		  | ORW_Time_;

opFnTimer         |                       | Ss_0FnETExe       | ET_R4
                    exFnTimer             | 0
		    LrRw		  | ORW_Timer;

opFnUBound1	  |			  | Ss_LUBound1       | 0
		    exFnUBound1 	  | 0
		    LrFunc1Arg		  | ORW_UBound;
opFnUBound2	  |			  | Ss_LUBound2       | 0
		    exFnUBound2 	  | 0
		    LrFunc2Args 	  | ORW_UBound;

opFnUCase_	  |			  | Ss_4ET_ET	      | SSR_SD_SD
		    exFnUCase_		  | OPA_fHeapMove
		    LrFunc1Arg		  | ORW_UCase_;

opFnVal           |                       | Ss_4ET_ET         | SSR_SD_R8
                    exFnVal               | 0
                    LrFunc1Arg            | ORW_Val;
opFnVarPtr	  |     		  | Ss_VarPtr	      | 0
		    exFnVarPtr		  | 0
		    LrFunc1Arg		  | ORW_VarPtr;
opFnVarPtr_	  |     		  | Ss_VarPtr$	      | 0
		    exFnVarPtr_ 	  | 2+OPA_fHeapMove
		    LrFnVarPtr_ 	  | ORW_VarPtr_;
opFnVarSeg	  |     		  | Ss_VarPtr	      | 0
		    exFnVarSeg		  | 0
		    LrFunc1Arg		  | ORW_VarSeg;
opGE              |                       | Ss_2FnSamePExe    | SSR_2Any_I2
                    mGEOpExe              | 0
                    LrBinaryOp            | "=>";
opGT              |                       | Ss_2FnSamePExe    | SSR_2Any_I2
                    mGTOpExe              | 0
                    LrBinaryOp            | '>';
opIDv             |                       | Ss_2FnSamePExe    | SSR_2I2I4_Same
                    mIDvOpExe             | 0
                    LrBinaryOp            | 05CH;
opImp             |                       | Ss_2FnSamePExe    | SSR_2I2I4_Same
                    mImpOpExe             | 0
                    LrBinaryRw            | ORW_Imp;
opLE              |                       | Ss_2FnSamePExe    | SSR_2Any_I2
                    mLEOpExe              | 0
                    LrBinaryOp            | "=<";
opLT              |                       | Ss_2FnSamePExe    | SSR_2Any_I2
                    mLTOpExe              | 0
                    LrBinaryOp            | '<';
opLitI2 	  |			  | Ss_LitI2	      | ET_I2+HIGH ST_Lit
		    exLitDI2		  | 0
		    LrLitI2		  | LIT_I2;
opLitDI2          |                       | Ss_Lit            | ET_I2+HIGH ST_LitX
                    exLitDI2              | 2
                    LrLitNum              | 200H + LIT_I2;
opLitDI4          |                       | Ss_Lit            | ET_I4+HIGH ST_LitX
                    exLitDI4              | 4
                    LrLitNum              | 400H + LIT_I4;
opLitHI2          |                       | Ss_Lit            | ET_I2+HIGH ST_LitX
                    exLitHI2              | 2
                    LrLitNum              | 200H + LIT_H2;
opLitHI4          |                       | Ss_Lit            | ET_I4+HIGH ST_LitX
                    exLitHI4              | 4
                    LrLitNum              | 400H + LIT_H4;
opLitOI2          |                       | Ss_Lit            | ET_I2+HIGH ST_LitX
                    exLitOI2              | 2
                    LrLitNum              | 200H + LIT_O2;
opLitOI4          |                       | Ss_Lit            | ET_I4+HIGH ST_LitX
                    exLitOI4              | 4
                    LrLitNum              | 400H + LIT_O4;
opLitR4 	  |     		  | Ss_Lit	      | ET_R4+HIGH ST_LitX
                    exLitR4               | 4
                    LrLitNum              | 400H + LIT_R4;
opLitR8           |                       | Ss_Lit            | ET_R8+HIGH ST_LitX
                    exLitR8               | 8
                    LrLitNum              | 800H + LIT_R8;
opLitSD           |                       | Ss_Lit            | ET_SD
                    exLitSD               | OPA_fHeapMove+OPA_CntMask
                    LrLitSD               | 0;
opLParen          |                       | Ss_LParen         | 0
                    exLParen              | 0
                    LrLParen              | 0;

opMod             |                       | Ss_2FnSamePExe    | SSR_2I2I4_Same
                    mModOpExe             | 0
                    LrBinaryRw            | ORW_Mod;
opMul             |                       | Ss_2FnSamePExe    | SSR_2NotSD_Same
                    mMulOpExe             | 0
                    LrBinaryOp            | '*';
opNE              |                       | Ss_2FnSamePExe    | SSR_2Any_I2
                    mNEOpExe              | 0
                    LrBinaryOp            | "><";
opNull            |                       | Ss_Lit            | ET_I2+HIGH ST_LitX
                    ExNull                | 0
                    LrNull                | 0;
opUndef           |                       | Ss_Lit            | ET_I2+HIGH ST_LitX
                    ExUndef               | 0
                    LrUndef               | 0;
opNot             |                       | Ss_1FnPExe        | SSR_1I2I4_Same
                    mNotOpExe             | 0
                    LrRwExp1              | ORW_Not;
opOr              |                       | Ss_2FnSamePExe    | SSR_2I2I4_Same
                    mOrOpExe              | 0
                    LrBinaryRw            | ORW_Or;
opPwr             |                       | Ss_2FnSamePExe    | SSR_2R4R8_Same
                    mPwrOpExe             | 0
                    LrBinaryOp            | '^';
opSub             |                       | Ss_2FnSamePExe    | SSR_2NotSD_Same
                    mSubOpExe             | 0
                    LrBinaryOp            | '-';
opUMi             |                       | Ss_UMi            | 0
                    mUMiOpExe             | 0
                    LrUnaryChar           | '-';
opXor             |                       | Ss_2FnSamePExe    | SSR_2I2I4_Same
                    mXorOpExe             | 0
                    LrBinaryRw            | ORW_Xor;

@AFTQB4

# The next two opcodes were added for QB4b (BC6's QB), so for binary load
# compatibility they need to immediately follow the QB4 opcodes.

opEvUEvent	  |			  | Ss_0_0	      | 0
                    exEvUEvent            | OPA_fExecute
                    LrRw                  | ORW_UEvent;
opStSleep1        |                       | Ss_4ET_ET         | SSR_I4_None
                    exStSleep1            | 0+OPA_fExecute
                    LrRwExp1              | ORW_Sleep;

# End of QB4b specific opcodes.

opAsTypeFixed     |                       | Ss_AsType         | 0
                    exAsTypeFixed         | 6+OPA_fSsRude+OPA_fTxtFind
                    LrAsTypeFixed         | ORW_As;
opStDim           |                       | Ss_StDim          | 0
                    exStDim               | 2+OPA_fSsRude+OPA_fTxtFind
                    LrStoClassDecl        | ORW_Dim;
opAElemRef	  |           *qb     	   | Ss_ElemRef        | 0
                    exElemRef             | 4+OPA_fTxtFind
		    LrAElemRef		  | 0;


opFnFormat_	  | *qb           	   | Ss_Format	       | 0
		    mptyppexFnFormat_	  | 0
		    LrFuncHighArgs	  | ORW_Format_;


opFnError_	  | *qb           	   | Ss_0FnETExe       | ET_SD
                    exFnError_ 	          | 0
                    LrRw                  | ORW_Error_;
opFnError_1	  | *qb           	   | Ss_4ET_ET	       | SSR_I2_SD
                    exFnError_1           | 0
                    LrFunc1Arg            | ORW_Error_;

#
# End of common block of opcodes
#
@__END_COMMON


########################################################################
#
#  To maintain binary compatability with QB4 all new opcodes must be added
#  at the end of the sequence of opcodes.
#
########################################################################

opStInclude       | *qb                   | Ss_0_0            | 0
                    exStInclude           | OPA_CntMask+OPA_fTxtFind
                    LrStInclude           | ORW_Include;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\ir\qbasmsgs.txt ===
; QBasic Standard Error Messages.
; This file is read by the tool makemsgs, which produces the files:
;      qbimsgs.asm, qbimsgs.inc, and qbimsgs.h
;
; Entries in this file have the form:
;  [<symbol's name>,[<msg index/error code>],"<ASCII msg>"] [;<comment>]
;
; If <msg index/error code> is not specified, the next available one
;    is assigned.
;
;Section 1:  Runtime Errors - symbol names are kept small to decrease
;            the size of the runtime library.
;            Names begin with ER_ to distinguish them from non-runtime
;            errors, which begin with MSG_.
;
;NOTE: A *BLANK* line terminates MAKEMSG.  Do not add blank lines!
;
;
ER_NF,1,"NEXT without FOR"
ER_SN,2,"Syntax error"
ER_RG,3,"RETURN without GOSUB"
ER_OD,4,"Out of DATA"
ER_FC,5,"Illegal function call"
ER_OV,6,"Overflow"
ER_OM,7,"Out of memory"
ER_UL,8,"Label not defined"
ER_SOR,9,"Subscript out of range"
ER_DD,10,"Duplicate definition"
ER_DV0,11,"Division by zero"
ER_ID,12,"Illegal in direct mode"
ER_TM,13,"Type mismatch"
ER_OS,14,"Out of string space"
;15 is unused
ER_BS,16,"String formula too complex"
ER_CN,17,"Cannot continue"
ER_UF,18,"Function not defined"
ER_NR,19,"No RESUME"
ER_RE,20,"RESUME without error"
;21 is unused
;22 is unused
;23 is unused
ER_DTO,24,"Device timeout"
ER_DF,25,"Device fault"
ER_FN,26,"FOR without NEXT"
ER_OP,27,"Out of paper"
;28 is unused
ER_WH,29,"WHILE without WEND"
ER_WE,30,"WEND without WHILE"
;31 is unused
;32 is unused
ER_DL,33,"Duplicate label"
;34 is unused
ER_US,35,"Subprogram not defined"
;; ER_SIU,36,"Subprogram already in use"  ;dead after recursion added
ER_AC,37,"Argument-count mismatch"
ER_UA,38,"Array not defined"
ER_CaseElse,39,"CASE ELSE expected"
ER_VarReq,40,"Variable required"
;41 is unused
;42 is unused
;43 is unused
;44 is unused
;45 is unused
;46 is unused
;47 is unused
;48 is unused
;49 is unused
ER_FOV,50,"FIELD overflow"
ER_IER,51,"Internal error"
ER_BFN,52,"Bad file name or number"
ER_FNF,53,"File not found"
ER_BFM,54,"Bad file mode"
ER_FAO,55,"File already open"
ER_FSA,56,"FIELD statement active"
ER_IOE,57,"Device I/O error"
ER_FAE,58,"File already exists"
ER_BRL,59,"Bad record length"
;60 is unused
ER_DFL,61,"Disk full"
ER_RPE,62,"Input past end of file"
ER_BRN,63,"Bad record number"
ER_IFN,64,"Bad file name"
;65 is unused
;66 is unused	- used to be ER_FDR - Direct statement in file
ER_TMF,67,"Too many files"
ER_DNA,68,"Device unavailable"
ER_CBO,69,"Communication-buffer overflow"
ER_PRM,70,"Permission denied"
ER_DNR,71,"Disk not ready"
ER_DME,72,"Disk-media error"
ER_ADF,73,"Advanced feature unavailable"
ER_RAD,74,"Rename across disks"
ER_PAE,75,"Path/File access error"
ER_PNF,76,"Path not found"
;;;ER_DLK,77,"Deadlock" ;not needed until OS/2 version
;
; The following ER_UE marks the last trappable Runtime Error Code
;
ER_UE,,"Unprintable error"
;
;=========================================================================
; Subsequent ER_ messages are special, and are intimately tied in with
; the runtime message file, messages.inc.
; Some of these errors are considered "very fatal", and cause termination;
; others are not errors at all - - we just supply the text for some runtime
; messages here.
; These messages must remain contiguous and in the same order, unless
; a matching change is made in messages.inc.
;
; First group of internal errors - - these are actually runtime messages,
; not errors
; Any message that begins ER_UL is used in constructing a message
; as follows:
;  Error in loading (file) - Internal error
;
ER_RFS,,"Redo from start"
ER_BFC,,"Bytes free",CR		;'CR' means terminate with a Carriage Return
ER_ULP,,"Cannot find file ("	;preamble for user file path prompt
ER_ULT,,"). Input path: "	;postamble for user file path prompt
ER_ULE,,"Error in loading file (" ;preamble for loader errors
ER_ULG,,") - "			;postamble for loader errors
ER_RNS,,"Random-number seed (-32768 to 32767)"
ER_HRS,,"Press any key to continue" ;Displayed when errors occurr in QBC exec.
;
; Second group of internal errors - these are "very fatal"
ER_SSC,,"String space corrupt"	;string space or local heap trashed somehow
ER_ULD,,"Disk I/O error"	;problem in loading U.L. from disk
ER_ULI,,"Invalid format"	;attempt to load a U.L. with incorrect format
ER_ULF,,"Cannot find file"	;redirected IO and cannot find file in path
;
; Third group of internal errors - these are also "very fatal"
ER_D21,,"Requires DOS 2.10 or later"
ER_INI,,"Error during QBasic initialization" ;error in initializing runtime
ER_ULO,,"Out of memory"		;out of memory loading U.L.
ER_DMA,,"DOS memory-arena error" ;someone walked on DOS-owned memory
ER_FHC,,"Far heap corrupt"	;similar to string space corrupt
ER_ULM,,"Internal error"	;U.L. loading found a bad segment address
;
; QB-specific internal errors - these are "very fatal"
; NOTE: These must come after other internal errors (no equivalent in
;	messages.inc)
;
;Both groups of the command line help message must remain contiguous.
;They must start with the label ER_ISWEDIT/ER_ISWHELP/ER_ISWINTERP and end
;with the label ER_ISWEDITEND/ER_ISWHELPEND/ERISWINTERPEND.  The labels of the
;intermediate lines does not matter.
;
ER_ISWEDIT,,"Starts the MS-DOS Editor, which creates and changes ASCII files."
ER_ISWEDIT1,," "
ER_ISWEDIT2,,"EDIT [[drive:][path]filename] [/B] [/G] [/H] [/NOHI]"
ER_ISWEDIT3,," "
ER_ISWEDIT4,,"  [drive:][path]filename  Specifies the ASCII file to edit."
ER_ISWEDIT5,,"  /B          Allows use of a monochrome monitor with a color graphics card."
ER_ISWEDIT6,,"  /G          Provides the fastest update of a CGA screen."
ER_ISWEDIT7,,"  /H          Displays the maximum number of lines possible for your hardware."
ER_ISWEDITEND,,"  /NOHI       Allows the use of a monitor without high-intensity support."
;
ER_ISWQHELP,,"Starts MS-DOS Help on MS-DOS commands."
ER_ISWQHELP1,," "
ER_ISWQHELP2,,"HELP [/B] [/G] [/H] [/NOHI] [topic]"
ER_ISWQHELP3,," "
ER_ISWQHELP4,,"  /B          Allows use of a monochrome monitor with a color graphics card."
ER_ISWQHELP5,,"  /G          Provides the fastest update of a CGA screen."
ER_ISWQHELP6,,"  /H          Displays the maximum number of lines possible for your hardware."
ER_ISWQHELP7,,"  /NOHI       Allows the use of a monitor without high-intensity support."
ER_ISWQHELPEND,,"  [topic]     Specifies the help topic to view."
;
ER_ISWINTERP,,"Starts the MS-DOS QBasic programming environment."
ER_ISWINTERP1,," "
ER_ISWINTERP2,,"QBASIC [/B] [/EDITOR] [/G] [/H] [/MBF] [/NOHI] [[/RUN] [drive:][path]filename]"
ER_ISWINTERP3,," "
ER_ISWINTERP4,,"  /B          Allows use of a monochrome monitor with a color graphics card."
ER_ISWINTERP5,,"  /EDITOR     Starts the MS-DOS Editor."
ER_ISWINTERP6,,"  /G          Provides the fastest update of a CGA screen."
ER_ISWINTERP7,,"  /H          Displays the maximum number of lines possible for your hardware."
ER_ISWINTERP8,,"  /MBF        Converts the built-in functions MKS$, MKD$, CVS, and CVD to"
ER_ISWINTERP9,,"              MKSMBF$, MKDMBF$, CVSMBF, and CVDMBF, respectively."
ER_ISWINTERPA,,"  /NOHI       Allows the use of a monitor without high-intensity support."
ER_ISWINTERPB,,"  /RUN        Runs the specified Basic program before displaying it."
ER_ISWINTERPEND,,"  [[drive:][path]filename] Specifies the program file to load or run."
;
;=========================================================================
;
;-------------------------------------------------------------------------
;MSG_GoDirect is non-trappable interpreter-specific
; error which allow us to back out of what we're doing and escape back
; to direct mode.
;
MSG_GoDirect,,""
MSG_OutOfStack,,"Out of stack space"
MSG_DocTooLarge,,"Document too large"
MSG_InclTooLarge,,"Include file too large"
;
;-------------------------------------------------------------------------
; End of runtime errors.  Messages beyond this point can be re-arranged
; in any order.
;-------------------------------------------------------------------------
;
;Section 2: QBI Parser Related Messages
;
MSG_IdTooLong,,"Identifier too long"
MSG_BadId,,"Invalid identifier"
MSG_IdImp,,"Identifier cannot end with %, &, !, #, or $"
MSG_BadElemRef,,"Identifier cannot include period"
MSG_ExpTooComplex,,"Expression too complex"
MSG_IllegalNumber,,"Illegal number"
MSG_InvConst,,"Invalid constant"
MSG_expected,,"Expected: "
MSG_or,," or "
;
; Parser errors which are preceded by "Expected: "
;
MSG_ExpAssignment,,"variable=expression"
MSG_ExpExp,,"expression"
MSG_ExpVar,,"variable"
MSG_ExpId,,"identifier"
MSG_ExpStatement,,"statement"
MSG_ExpLabel,,"label"
MSG_ExpLn,,"line number"
MSG_Letter,,"letter"
MSG_eos,,"end-of-statement"
MSG_RightParen,,")"
MSG_ExpIdCallArg,,"expression"
MSG_ExpIdParm,,"variable"
MSG_ExpFNId,,"identifier that begins with FN"
MSG_ExpIfClause,,"label or statement"
MSG_ExpLabLn,,"label or line number"
MSG_ExpLitString,,"string constant"
MSG_ExpLit0,,"0"
MSG_ExpLit1,,"1"
MSG_ExpNArgs,,"[expression],..."
MSG_ExpRwB,,"B"
MSG_ExpRwF,,"F"
MSG_ExpRwBF,,"BF"
MSG_ExpRel,,"<, <=, >, >=, =, or <>"
;
;Section 3:  TextMgr/ReParse errors
;
MSG_InvModLev,,"Illegal outside of SUB, FUNCTION or DEF FN"
MSG_InvMain,,"Illegal outside of SUB/FUNCTION"
MSG_InvProc,,"Illegal in procedure or DEF FN"
MSG_InvBeforeProcDef,,"Statement cannot precede SUB/FUNCTION definition"
MSG_ProcNoEnd,,"SUB/FUNCTION without END SUB/FUNCTION"
MSG_EndNoProc,,"END SUB/FUNCTION without SUB/FUNCTION"
MSG_EndNoDef,,"END DEF without DEF"
MSG_UndElem,,"Element not defined"
MSG_UndType,,"Type not defined"
MSG_1stStmt,,"Must be first statement on the line"
MSG_EndProc,,"END SUB or END FUNCTION must be last line in window"
MSG_NoEndType,,"TYPE without END TYPE"
MSG_NoType,,"END TYPE without TYPE"
MSG_InvInTypeBlk,,"Statement illegal in TYPE block"
MSG_InvIncl,,"Statement cannot occur within INCLUDE file"
MSG_InvDecl,,"Invalid DECLARE for Basic procedure"
MSG_FNstart,,"Cannot start with 'FN'"
MSG_NotBlock,,"Operation requires disk"
MSG_BadMeta,,"$Metacommand error"
MSG_NoBpCase,,"Breakpoints not allowed on CASE clauses or END SELECT"
;
;Section 4:  Scan-time errors
;
MSG_OBA,,"Array already dimensioned"
MSG_COM,,"COMMON and DECLARE must precede executable statements"
MSG_EWI,,"END IF without block IF"
MSG_IWE,,"Block IF without END IF"
MSG_ElseWI,,"ELSE without IF"
MSG_ExitScope,,"EXIT not within FOR...NEXT"
MSG_ExitDo,,"EXIT DO not within DO...LOOP"
MSG_Do,,"DO without LOOP"
MSG_Loop,,"LOOP without DO"
MSG_Select,,"SELECT without END SELECT"
MSG_Case,,"CASE without SELECT"
MSG_EndSelect,,"END SELECT without SELECT"
MSG_InvFixStr,,"Fixed-length string illegal"
MSG_InvTypedVar,,"Typed variable not allowed in expression"
MSG_DefNoEnd,,"DEF without END DEF"
MSG_ParmTM,,"Parameter type mismatch"
MSG_DupLibPrs,,"Procedure already defined in Quick library"
MSG_ASRqd1st,,"AS clause required on first declaration"
MSG_ASRqd,,"AS clause required"
MSG_ExpectedCase,,"Statements/labels illegal between SELECT CASE and CASE"
MSG_NoNumArr,,"Numeric array illegal"
MSG_InType,,"Illegal outside of TYPE block"
MSG_ULCom,,"COMMON in Quick library too small"
MSG_SubCnt,,"Wrong number of dimensions"
MSG_DefFnCtrl,,"DEF FN not allowed in control statements"
MSG_Unsupported,,"This feature is unavailable"
;
;Section 5.1: User Interface Related Messages that could be described in
;	      user guide's error message appendix
;
MSG_CantCont,,"You will have to restart your program after this edit. Proceed anyway?"
MSG_NoMainProg,,"No main module. Choose Set Main Module from Run menu to select one"
MSG_HelpOOM,,"Insufficient memory to display Help"
;
;Section 5.2: Messages that require special handling in ReportError()
;
;Note: The next 2 messages must have numbers < 256 for because they can be
;      passed to RtError_Ini by exStRunFile during command-line load.
;
MSG_DupMrs,,"File previously loaded"
MSG_DupPrs,,"Tried to load file with duplicate procedure definition"
MSG_MrsNotFound,,"Module not found. Unload module from program?"
;
;Section 5.3: General User Interface messages
;
MSG_Overwrite,,"File already exists. Overwrite?"
MSG_DelProc,,"Delete procedure from module?"
MSG_MakeRem,,"Blank lines not allowed before SUB/FUNCTION line.  Is remark OK?"
MSG_NotSaved,,"File has been modified since last saved. Save it now?"
MSG_NotSavedAll,,"Loaded file is not saved. Save it now?"
MSG_NotSavedInc,,"Modified INCLUDE files must be saved before running. Save them now?"
MSG_NotSavedIncSav,,"Save modified INCLUDE files first?"
MSG_BadNextStmt,,"Cannot cross procedure/module boundary"
MSG_Prt1,,"Waiting for printer"
MSG_Prt2,,"Printing - press Esc to cancel"
MSG_Immediate,,"Immediate"
MSG_Untitled,,"Untitled"
MSG_FALSE,,"<FALSE>"
MSG_TRUE,,"<TRUE>"
MSG_Black,,"Black"
MSG_Blue,,"Blue"
MSG_Green,,"Green"
MSG_Cyan,,"Cyan"
MSG_Red,,"Red"
MSG_Magenta,,"Magenta"
MSG_Brown,,"Brown"
MSG_White,,"White"
MSG_Gray,,"Gray"
MSG_BrBlue,,"BrBlue"
MSG_BrGreen,,"BrGreen"
MSG_BrCyan,,"BrCyan"
MSG_BrRed,,"BrRed"
MSG_Pink,,"Pink"
MSG_Yellow,,"Yellow"
MSG_BrWhite,,"BrWhite"
MSG_MustSpecifyName,,"Must specify name"
MSG_DataMoved,,"DATA statements were moved from SUB to module level"
MSG_ModuleExists,,"Module with that name is already loaded"
MSG_NoHelp,,"File "
MSG_NoHelp1,," not found."
MSG_NoHelp2,,"Put the floppy disk with this file into the drive and"
MSG_NoHelp3,,"Retry, or change your Help path in Options+Help Path."
MSG_NoQHelp2,,"Choose OK, and then make sure the"
MSG_NoQHelp3,,"file is in your PATH."
MSG_NoSearchString,,"Must specify search string"
MSG_MatchNotFound,,"Match not found"
MSG_ChangeComplete,,"Change complete"
MSG_Is,," is "
MSG_MainModule,,"the Main Module"
MSG_Module,,"a Module"
MSG_IncludeFile,,"an Include File"
MSG_Document,,"a Document"
MSG_Sub,,"a SUB in "
MSG_Function,,"a FUNCTION in "
MSG_ReqSub,,"Operation requires selection of a SUB or FUNCTION"
;If text of MSG_SwitchDisks changes, ref code in uifile.c must change as well.
MSG_SwitchDisks,,"Insert Diskette for drive A:"
MSG_Loading,,"Loading and parsing"
MSG_Saving,,"Saving"
MSG_Compiling,,"Binding"
MSG_Searching,,"Searching - press Esc to cancel"
MSG_CantSetTabs,,"Cannot change tab stops while file is loaded"
MSG_OutNearMem,,"Out of data space"
MSG_ModTooLarge,,"Module level code too large"
MSG_ProcTooLarge,,"Procedure too large"
MSG_ExitToRet,,CR,"Type EXIT to return to QBasic"
MSG_QeditText1,," Set colors for the "
MSG_QeditText2,," text editor window:"
MSG_NormalText,," Normal Text       "
MSG_Breakpoint,," Breakpoint Lines  "
MSG_CurStmt,," Current Statement "
MSG_HelpTitle,,"HELP: "
MSG_HelpTitleQH,,"MS-DOS Help: "
MSG_FirstContextStr,,"h.pg1"
MSG_HelpAboutEditor,,"MS-DOS Editor"
MSG_HelpAboutQHelp,,"MS-DOS Help"
MSG_HelpAboutInterp,,"MS-DOS QBasic"
MSG_HelpAbout2,,"Version 1.1"
MSG_HelpAbout3,,"Copyright (C) Microsoft Corporation, 1987-1992."
;
;Section 5.4: HELP messages for menu items <THESE MUST REMAIN CONTIGUOUS>
;
; NOTE: These must match the EXACT order of the midFileNew...midHelpHowToUse
;	definitions in ..\ir\qbasmsgs.txt, because ..\uq\uictl.c (MainWndProc)
;	does a direct mapping from midXxx to MSG_HelpXxx assuming this
;	ordering exists.
;
MSG_HelpFileNew,,"Removes currently loaded file from memory"
MSG_HelpFileOpen,,"Loads new file into memory"
MSG_HelpFileMerge,,""
MSG_HelpFileSave,,"Saves current file"
MSG_HelpFileSaveAs,,"Saves current file with specified name"
MSG_HelpFileSaveAll,,""
MSG_HelpFileCreate,,""
MSG_HelpFileLoad,,""
MSG_HelpFileUnload,,""
MSG_HelpFilePrint,,"Prints specified text"
MSG_HelpFileShell,,""
MSG_HelpFileExit,,"Exits editor and returns to DOS"
MSG_HelpFileExitQH,,"Exits MS-DOS Help and returns to DOS"
MSG_HelpEditUndo,,""
MSG_HelpEditCut,,"Deletes selected text and copies it to buffer"
MSG_HelpEditCopy,,"Copies selected text to buffer"
MSG_HelpEditClear,,"Deletes selected text without copying it to buffer"
MSG_HelpEditPaste,,"Inserts buffer contents at current location"
MSG_HelpEditNewSub,,"Opens a window for a new subprogram"
MSG_HelpEditNewFunc,,"Opens a window for a new FUNCTION procedure"
MSG_HelpViewSubs,,"Displays a loaded SUB or FUNCTION"
MSG_HelpViewNextProc,,""
MSG_HelpViewSplit,,"Divides screen into two View windows"
MSG_HelpViewNextStatement,,""
MSG_HelpViewOutputScreen,,"Displays output screen"
MSG_HelpViewIncludes,,""
MSG_HelpViewEditIncl,,""
MSG_HelpSearchFind,,"Finds specified text"
MSG_HelpSearchSelected,,""
MSG_HelpSearchNext,,"Finds next occurrence of text specified in previous search"
MSG_HelpSearchChange,,"Finds and changes specified text"
MSG_HelpSearchLabel,,""
MSG_HelpRunStart,,"Runs current program"
MSG_HelpRunRestart,,"Clears variables in preparation for restarting single stepping"
MSG_HelpRunContinue,,"Continues execution after a break"
MSG_HelpRunSetCommand,,""
MSG_HelpRunMakeExe,,""
MSG_HelpRunMakeLib,,""
MSG_HelpRunSetMain,,""
MSG_HelpDebugStep,,"Executes next program statement"
MSG_HelpDebugPStep,,"Executes next program statement, tracing over procedure calls"
MSG_HelpDebugAddWatch,,""
MSG_HelpDebugInstantWatch,,""
MSG_HelpDebugWatchPoint,,""
MSG_HelpDebugDelWatch,,""
MSG_HelpDebugDelAllWatch,,""
MSG_HelpDebugTraceOn,,"Highlights statement currently executing"
MSG_HelpDebugHistoryOn,,""
MSG_HelpDebugToggleBp,,"Sets/clears breakpoint at cursor location"
MSG_HelpDebugClearAllBp,,"Removes all breakpoints"
MSG_HelpDebugBreakOnErr,,""
MSG_HelpDebugSetNextStmt,,"Makes the statement at the cursor the next statement to execute"
MSG_HelpOptionsDisplay,,"Changes display attributes"
MSG_HelpOptionsPaths,,"Sets search path for Help files"
MSG_HelpOptionsMouse,,""
MSG_HelpOptionsSyntax,,"Turns editor's syntax checking on or off."
MSG_HelpOptionsFullMenu,,""
MSG_HelpHelpIndex,,"Displays help index"
MSG_HelpHelpContents,,"Displays help table of contents"
MSG_HelpHelpSyntax,,"Displays information about the Basic keyword the cursor is on"
MSG_HelpHelpHelp,,"Displays information about how to use online Help"
MSG_HelpHelpStarted,,"Displays information on loading and using the MS-DOS Editor"
MSG_HelpHelpKeyboard,,"Displays navigation and editing keystrokes"
MSG_HelpHelpAbout,,"Displays product version and copyright information"
MSG_HelpHowToUse,,"Displays information on using MS-DOS Help"
;
;Section 5.5: Status line HELP messages <THESE MUST REMAIN CONTIGUOUS>
;
; IMPORTANT:  If the text of ANY of the following messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
; IMPORTANT:  See UINHELP.ASM for a description of how to change the text of
; IMPORTANT:  MSG_Status[Edit, Running, Immediate, Help, ShiftF1].
;
MSG_StatusMenu,,"Enter=Display Menu   Esc=Cancel   Arrow=Next Item"
MSG_StatusDialog,,"Enter=Execute   Esc=Cancel   Tab=Next Field   Arrow=Next Item"
MSG_StatusEdit,,"<F6=Window> <F2=Subs> <F5=Run> <F8=Step>"
MSG_StatusRunning,,"<F5=Continue> <F9=Toggle Bkpt> <F8=Step>"
MSG_StatusImmediate,,"<F6=Window> <Enter=Execute Line>"
MSG_StatusHelp,,"<F6=Window> <Esc=Cancel> <Ctrl+F1=Next> <Alt+F1=Back>"
MSG_StatusQEdit,,"MS-DOS Editor  <F1=Help> Press ALT to activate menus"
MSG_StatusQHelp,,"<F1=Help> <F6=Window> <Esc=Cancel> <Ctrl+F1=Next> <Alt+F1=Back>"
MSG_StatusQHStart,,"MS-DOS Help         <F1=Help> Press ALT to activate menus"
;
;
MSG_StatusQHhelp,,"<Alt+C=Contents> <Alt+N=Next> <Alt+B=Back>"
;
; LOCALIZATION - To change the accelerator chars in the above line, change the
;       the values in rgmpvkeyidQhelp[], in UIRSRCC.C (At about line #460).
;
;
MSG_StatusF1Help,,"F1=Help   "
MSG_StatusShiftF1,,"<Shift+F1=Help> "
;
; IMPORTANT:  If the text of ANY of the previous messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
;
;Section 5.6: Variable HELP messages <Some of these must remain contiguous>
;Ripped these out for LQB
;
;Section 5.7: misc messages
;
MSG_SearchPathEdit,,"Location (path) of EDIT.HLP file:"
MSG_SearchPathHelp,,"Location (path) of HELP.HLP file:"
MSG_SearchPathInterp,,"Location (path) of QBASIC.HLP file:"
;
;Section touch: Messages can be added to the bottom of the file
; and all objects except uiutil.obj and qbimsgs.obj can be touched.
; Also touch qbimsgs.rpl, then *.hlp!
; Later, these messages should be moved into their appropriate sections.

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb5\qbas\cow\hold.txt ===
holder
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbdut\strings\qbasmsgs.txt ===
; QBasic Standard Error Messages.
; This file is read by the tool makemsgs, which produces the files:
;      qbimsgs.asm, qbimsgs.inc, and qbimsgs.h
;
; Entries in this file have the form:
;  [<symbol's name>,[<msg index/error code>],"<ASCII msg>"] [;<comment>]
;
; If <msg index/error code> is not specified, the next available one
;    is assigned.
;
;Section 1:  Runtime Errors - symbol names are kept small to decrease
;            the size of the runtime library.
;            Names begin with ER_ to distinguish them from non-runtime
;            errors, which begin with MSG_.
;
;NOTE: A *BLANK* line terminates MAKEMSG.  Do not add blank lines!
;
;
ER_NF,1,"NEXT zonder FOR"
ER_SN,2,"Syntaxisfout"
ER_RG,3,"RETURN zonder GOSUB"
ER_OD,4,"Geen verdere DATA"
ER_FC,5,"Ongeldige functie-aanroep"
ER_OV,6,"Overloop"
ER_OM,7,"Onvoldoende geheugen"
ER_UL,8,"Label niet gedefinieerd"
ER_SOR,9,"Subscript buiten bereik"
ER_DD,10,"Dubbele definitie"
ER_DV0,11,"Delen door nul"
ER_ID,12,"Ongeldig in directe modus"
ER_TM,13,"Typen komen niet overeen"
ER_OS,14,"Onvoldoende tekenreeksruimte"
;15 is unused
ER_BS,16,"Tekenreeks te lang"
ER_CN,17,"Doorgaan niet mogelijk"
ER_UF,18,"Functie niet gedefinieerd"
ER_NR,19,"Geen RESUME"
ER_RE,20,"RESUME zonder fout"
;21 is unused
;22 is unused
;23 is unused
ER_DTO,24,"'time-out' van apparaat"
ER_DF,25,"Apparaatfout"
ER_FN,26,"FOR zonder NEXT"
ER_OP,27,"Geen papier in printer"
;28 is unused
ER_WH,29,"WHILE zonder WEND"
ER_WE,30,"WEND zonder WHILE"
;31 is unused
;32 is unused
ER_DL,33,"Dubbel label"
;34 is unused
ER_US,35,"Subprogramma niet gedefinieerd"
;; ER_SIU,36,"Subprogramma reeds in gebruik"    ;dead after recursion added
ER_AC,37,"Onjuist aantal argumenten"
ER_UA,38,"Array niet gedefinieerd"
ER_CaseElse,39,"CASE ELSE verwacht"
ER_VarReq,40,"Variabele vereist"
;41 is unused
;42 is unused
;43 is unused
;44 is unused
;45 is unused
;46 is unused
;47 is unused
;48 is unused
;49 is unused
ER_FOV,50,"FIELD-overloop"
ER_IER,51,"Interne fout"
ER_BFN,52,"Onjuiste bestandsnaam/nummer"
ER_FNF,53,"Bestand niet gevonden"
ER_BFM,54,"Verkeerde bestandsmodus"
ER_FAO,55,"Bestand reeds geopend"
ER_FSA,56,"FIELD-statement actief"
ER_IOE,57,"I/O-fout voor apparaat"
ER_FAE,58,"Bestand bestaat reeds"
ER_BRL,59,"Onjuiste record-lengte"
;60 is unused
ER_DFL,61,"Schijf is vol"
ER_RPE,62,"Invoer na bestandseinde"
ER_BRN,63,"Onjuist record-nummer"
ER_IFN,64,"Onjuiste bestandsnaam"
;65 is unused
;66 is unused   - used to be ER_FDR - Direct statement in file
ER_TMF,67,"Te veel bestanden"
ER_DNA,68,"Apparaat niet beschikbaar"
ER_CBO,69,"Overloop communicatiebuffer"
ER_PRM,70,"Permissie geweigerd"
ER_DNR,71,"Schijf niet gereed"
ER_DME,72,"Fout bij schijfmedia"
ER_ADF,73,"Voorziening niet beschikbaar"
ER_RAD,74,"Hernoemen op meerdere schijven"
ER_PAE,75,"Fout bij toegang pad/bestand"
ER_PNF,76,"Pad niet gevonden"
;;;ER_DLK,77,"Deadlock" ;not needed until OS/2 version
;
; The following ER_UE marks the last trappable Runtime Error Code
;
ER_UE,,"Niet-afdrukbare fout"
;
;=========================================================================
; Subsequent ER_ messages are special, and are intimately tied in with
; the runtime message file, messages.inc.
; Some of these errors are considered "very fatal", and cause termination;
; others are not errors at all - - we just supply the text for some runtime
; messages here.
; These messages must remain contiguous and in the same order, unless
; a matching change is made in messages.inc.
;
; First group of internal errors - - these are actually runtime messages,
; not errors
; Any message that begins ER_UL is used in constructing a message
; as follows:
;  Error in loading (file) - Internal error
;
ER_RFS,,"Herhalen vanaf begin"
ER_BFC,,"Bytes vrij",CR         ;'CR' means terminate with a Carriage Return
ER_ULP,,"Bestand onvindbaar ("  ;preamble for user file path prompt
ER_ULT,,"). Invoerpad: "        ;postamble for user file path prompt
ER_ULE,,"Fout bij laden bestand (" ;preamble for loader errors
ER_ULG,,") - "                  ;postamble for loader errors
ER_RNS,,"Random-begingetal (-32768 tot en met 32767)"
ER_HRS,,"Druk op een toets om verder te gaan" ;Displayed when errors occurr in QBC exec.
;
; Second group of internal errors - these are "very fatal"
ER_SSC,,"Tekenreeksruimte corrupt"  ;string space or local heap trashed somehow
ER_ULD,,"Schijf I/O-fout"        ;problem in loading U.L. from disk
ER_ULI,,"Ongeldige formattering"        ;attempt to load a U.L. with incorrect format
ER_ULF,,"Bestand niet gevonden"      ;redirected IO and cannot find file in path
;
; Third group of internal errors - these are also "very fatal"
ER_D21,,"DOS 2.10 of later vereist"
ER_INI,,"Fout tijdens initialisering QBasic" ;error in initializing runtime
ER_ULO,,"Onvoldoende geheugen"          ;out of memory loading U.L.
ER_DMA,,"DOS-geheugenfout" ;someone walked on DOS-owned memory
ER_FHC,,"'Far heap' corrupt"      ;similar to string space corrupt
ER_ULM,,"Interne fout"  ;U.L. loading found a bad segment address
;
; QB-specific internal errors - these are "very fatal"
; NOTE: These must come after other internal errors (no equivalent in
;       messages.inc)
;
;Both groups of the command line help message must remain contiguous.
;They must start with the label ER_ISWEDIT/ER_ISWHELP/ER_ISWINTERP and end
;with the label ER_ISWEDITEND/ER_ISWHELPEND/ERISWINTERPEND.  The labels of the
;intermediate lines does not matter.
;
ER_ISWEDIT,,"Start de MS-DOS Editor."
ER_ISWEDIT1,," "
ER_ISWEDIT2,,"EDIT [[station:][pad]bestandsnaam] [/B] [/G] [/H] [/NOHI]"
ER_ISWEDIT3,," "
ER_ISWEDIT4,,"  [station:][pad]bestandsnaam  Specificeert het te bewerken ASCII-bestand."
ER_ISWEDIT5,,"  /B            Maakt gebruik van monochrome monitor met CGA-kaart mogelijk."
ER_ISWEDIT6,,"  /G            Specificeert de maximale beeldschermresolutie."
ER_ISWEDIT7,,"  /H            Gebruikt maximum aantal regels dat uw apparatuur kan weergeven."
ER_ISWEDITEND,,"  /NOHI         Voor monitor die geen hoge intensiteit ondersteunt."
;
ER_ISWQHELP,,"Start MS-DOS Help en geeft MS-DOS-opdrachten weer."
ER_ISWQHELP1,," "
ER_ISWQHELP2,,"HELP [/B] [/G] [/H] [/NOHI] [onderwerp]"
ER_ISWQHELP3,," "
ER_ISWQHELP4,,"  /B           Maakt gebruik van monochrome monitor met CGA-kaart mogelijk."
ER_ISWQHELP5,,"  /G           Specificeert de snelste CGA-beeldschermuitvoer."
ER_ISWQHELP6,,"  /H           Gebruikt maximum aantal regels dat uw apparatuur kan weergeven."
ER_ISWQHELP7,,"  /NOHI        Voor monitor die geen hoge intensiteit ondersteunt."
ER_ISWQHELPEND,,"  [onderwerp]  Specificeert het gewenste help-onderwerp."
;
ER_ISWINTERP,,"Start de MS-DOS QBasic-programmeeromgeving."
ER_ISWINTERP1,," "
ER_ISWINTERP2,,"QBASIC [/B] [/EDITOR] [/G] [/H] [/MBF] [/NOHI] [[/RUN] bronbestand]"
ER_ISWINTERP3,," "
ER_ISWINTERP4,," /B           Maakt gebruik monochrome monitor met CGA-kaart mogelijk."
ER_ISWINTERP5,," /EDITOR      Roept de MS-DOS Editor aan."
ER_ISWINTERP6,," /G           Specificeert een snellere CGA-beeldschermuitvoer."
ER_ISWINTERP7,," /H           Specificeert de maximale beeldschermresolutie."
ER_ISWINTERP8,," /MBF         Converteert de intrinsieke functies MKS$, MKD$, CVS en CVD"
ER_ISWINTERP9,,"              naar respectievelijk MKSMBF$, MKDMBF$, CVSMBF en CVDMBF."
ER_ISWINTERPA,," /NOHI        Voor monitor die geen hoge intensiteit ondersteunt."
ER_ISWINTERPB,," /RUN         Voert een programma in QBasic uit alvorens het weer te geven."
ER_ISWINTERPEND,," bronbestand  Het uit te voeren of te laden programmabestand."
;
;=========================================================================
;
;-------------------------------------------------------------------------
;MSG_GoDirect is non-trappable interpreter-specific
; error which allow us to back out of what we're doing and escape back
; to direct mode.
;
MSG_GoDirect,,""
MSG_OutOfStack,,"Onvoldoende stack-ruimte"
MSG_DocTooLarge,,"Document te groot"
MSG_InclTooLarge,,"Op te nemen bestand te groot"
;
;-------------------------------------------------------------------------
; End of runtime errors.  Messages beyond this point can be re-arranged
; in any order.
;-------------------------------------------------------------------------
;
;Section 2: QBI Parser Related Messages
;
MSG_IdTooLong,,"Aanduider te lang"
MSG_BadId,,"Ongeldige aanduider"
MSG_IdImp,,"Aanduider kan niet eindigen op %, &, !, # of $"
MSG_BadElemRef,,"Aanduider kan geen punt bevatten"
MSG_ExpTooComplex,,"Uitdrukking te lang"
MSG_IllegalNumber,,"Ongeldig getal"
MSG_InvConst,,"Ongeldige constante"
MSG_expected,,"Verwacht: "
MSG_or,," of "
;
; Parser errors which are preceded by "Expected: "
;
MSG_ExpAssignment,,"variabele=uitdrukking"
MSG_ExpExp,,"uitdrukking"
MSG_ExpVar,,"variabele"
MSG_ExpId,,"aanduider"
MSG_ExpStatement,,"statement"
MSG_ExpLabel,,"label"
MSG_ExpLn,,"regelnummer"
MSG_Letter,,"letter"
MSG_eos,,"statement-einde"
MSG_RightParen,,")"
MSG_ExpIdCallArg,,"uitdrukking"
MSG_ExpIdParm,,"variabele"
MSG_ExpFNId,,"aanduider die begint met FN"
MSG_ExpIfClause,,"label of statement"
MSG_ExpLabLn,,"label of regelnummer"
MSG_ExpLitString,,"tekenreeksconstante"
MSG_ExpLit0,,"0"
MSG_ExpLit1,,"1"
MSG_ExpNArgs,,"[uitdrukking],..."
MSG_ExpRwB,,"B"
MSG_ExpRwF,,"F"
MSG_ExpRwBF,,"BF"
MSG_ExpRel,,"<, <=, >, >=, =, or <>"
;
;Section 3:  TextMgr/ReParse errors
;
MSG_InvModLev,,"Ongeldige waarde buiten SUB, FUNCTION of DEF FN"
MSG_InvMain,,"Ongeldige waarde buiten SUB/FUNCTION"
MSG_InvProc,,"Ongeldige waarde in procedure of DEF FN"
MSG_InvBeforeProcDef,,"Statement kan niet voorafgaan aan SUB/FUNC.-def."
MSG_ProcNoEnd,,"SUB/FUNCTION zonder END SUB/FUNCTION"
MSG_EndNoProc,,"END SUB/FUNCTION zonder SUB/FUNCTION"
MSG_EndNoDef,,"END DEF zonder DEF"
MSG_UndElem,,"Element niet gedefinieerd"
MSG_UndType,,"Type niet gedefinieerd"
MSG_1stStmt,,"Moet eerste statement op de regel zijn"
MSG_EndProc,,"END SUB of END FUNCTION moet laatste regel zijn in venster"
MSG_NoEndType,,"TYPE zonder END TYPE"
MSG_NoType,,"END TYPE zonder TYPE"
MSG_InvInTypeBlk,,"Statement ongeldig in TYPE-blok"
MSG_InvIncl,,"Statement mag niet voorkomen in INCLUDE-bestand"
MSG_InvDecl,,"Ongeldige DECLARE voor Basic-procedure"
MSG_FNstart,,"Kan niet beginnen met 'FN'"
MSG_NotBlock,,"Bewerking vereist schijf"
MSG_BadMeta,,"$Meta-opdrachtfout"
MSG_NoBpCase,,"Breekpunten niet toegestaan bij CASE-clausules of END SELECT"
;
;Section 4:  Scan-time errors
;
MSG_OBA,,"Dimensies van array al opgegeven"
MSG_COM,,"COMMON en DECLARE moeten voorafgaan aan uitvoerbare statements"
MSG_EWI,,"END IF zonder IF-blok"
MSG_IWE,,"IF-blok zonder END IF"
MSG_ElseWI,,"ELSE zonder IF"
MSG_ExitScope,,"EXIT niet binnen FOR...NEXT"
MSG_ExitDo,,"EXIT DO niet binnen DO...LOOP"
MSG_Do,,"DO zonder LOOP"
MSG_Loop,,"LOOP zonder DO"
MSG_Select,,"SELECT zonder END SELECT"
MSG_Case,,"CASE zonder SELECT"
MSG_EndSelect,,"END SELECT zonder SELECT"
MSG_InvFixStr,,"Tekenreeks met vaste lengte ongeldig"
MSG_InvTypedVar,,"Opgegeven variabele niet toegestaan in uitdrukking"
MSG_DefNoEnd,,"DEF zonder END DEF"
MSG_ParmTM,,"Parametertypen komen niet overeen"
MSG_DupLibPrs,,"Procedure reeds gedefinieerd in Quick-bibliotheek"
MSG_ASRqd1st,,"AS-clausule vereist bij eerste declaratie"
MSG_ASRqd,,"AS-clausule vereist"
MSG_ExpectedCase,,"Statements/labels ongeldig tussen SELECT CASE en CASE"
MSG_NoNumArr,,"Numerieke array ongeldig"
MSG_InType,,"Ongeldige waarde buiten TYPE-blok"
MSG_ULCom,,"COMMON in Quick-bibliotheek te klein"
MSG_SubCnt,,"Verkeerd aantal dimensies"
MSG_DefFnCtrl,,"DEF FN niet toegestaan in besturingsstatements"
MSG_Unsupported,,"Deze functie is niet beschikbaar"
;
;Section 5.1: User Interface Related Messages that could be described in
;             user guide's error message appendix
;
MSG_CantCont,,"U moet uw programma opnieuw starten na deze bewerking. Toch verder gaan?"
MSG_NoMainProg,,"Geen hoofdmodule. Kies Hoofdmodule instellen in het menu Uitvoeren voor selectie."
MSG_HelpOOM,,"Onvoldoende geheugen voor weergeven Help"
;
;Section 5.2: Messages that require special handling in ReportError()
;
;Note: The next 2 messages must have numbers < 256 for because they can be
;      passed to RtError_Ini by exStRunFile during command-line load.
;
MSG_DupMrs,,"Bestand eerder geladen"
MSG_DupPrs,,"Poging tot laden bestand met dubbele proceduredefinitie"
MSG_MrsNotFound,,"Module niet gevonden. Module uit programma verwijderen?"
;
;Section 5.3: General User Interface messages
;
MSG_Overwrite,,"Bestand bestaat reeds. Overschrijven?"
MSG_DelProc,,"Procedure uit module verwijderen?"
MSG_MakeRem,,"Geen witregels toegestaan voor SUB/FUNCTION-regel. Opmerking OK?"
MSG_NotSaved,,"Bestand is gewijzigd en nog niet opgeslagen. Nu opslaan?"
MSG_NotSavedAll,,"Geladen bestand is niet opgeslagen. Nu opslaan?"
MSG_NotSavedInc,,"U moet gewijzigde INCLUDE-bestanden opslaan voor uitvoering. Nu opslaan?"
MSG_NotSavedIncSav,,"Gewijzigde INCLUDE-bestanden eerst opslaan?"
MSG_BadNextStmt,,"Procedure/module-grens kan niet worden overschreden"
MSG_Prt1,,"Bezig met wachten op de printer"
MSG_Prt2,,"Bezig met afdrukken - Druk op Esc voor annuleren"
MSG_Immediate,,"Direct"
MSG_Untitled,,"Geennaam"
MSG_FALSE,,"<NIET WAAR>"
MSG_TRUE,,"<WAAR>"
MSG_Black,,"Zwart"
MSG_Blue,,"Blauw"
MSG_Green,,"Groen"
MSG_Cyan,,"Cyaan"
MSG_Red,,"Rood"
MSG_Magenta,,"Magenta"
MSG_Brown,,"Bruin"
MSG_White,,"Wit"
MSG_Gray,,"Grijs"
MSG_BrBlue,,"Helblauw"
MSG_BrGreen,,"Helgroen"
MSG_BrCyan,,"Helcyaan"
MSG_BrRed,,"Helrood"
MSG_Pink,,"Roze"
MSG_Yellow,,"Geel"
MSG_BrWhite,,"Helwit"
MSG_MustSpecifyName,,"Naam moet worden opgegeven"
MSG_DataMoved,,"DATA-statements verplaatst van SUB naar moduleniveau"
MSG_ModuleExists,,"Module met die naam al geladen"
MSG_NoHelp,,"Bestand "
MSG_NoHelp1,," niet gevonden."
MSG_NoHelp2,,"Plaats diskette met dit bestand in het station en"
MSG_NoHelp3,,"herhaal opdracht, of wijzig het Help-pad in Opties+Help-pad."
MSG_NoQHelp2,,"Kies OK en zorg ervoor dat het bestand"
MSG_NoQHelp3,,"zich in uw PATH bevindt."
MSG_NoSearchString,,"Zoektekst moet worden opgegeven"
MSG_MatchNotFound,,"Zoektekst niet gevonden"
MSG_ChangeComplete,,"Wijzigen voltooid"
MSG_Is,," is "
MSG_MainModule,,"de hoofdmodule"
MSG_Module,,"een module"
MSG_IncludeFile,,"een INCLUDE-bestand"
MSG_Document,,"een document"
MSG_Sub,,"een SUB in "
MSG_Function,,"een FUNCTION in "
MSG_ReqSub,,"Bewerking vereist een keuze uit een SUB of FUNCTION"
;If text of MSG_SwitchDisks changes, ref code in uifile.c must change as well.
MSG_SwitchDisks,,"Plaats diskette voor station A:"
MSG_Loading,,"Bezig met laden en parsing"
MSG_Saving,,"Bezig met opslaan"
MSG_Compiling,,"Bezig met compileren"
MSG_Searching,,"Bezig met zoeken - Druk op Esc voor annuleren"
MSG_CantSetTabs,,"Tabs kunnen niet worden gewijzigd terwijl bestand is geladen"
MSG_OutNearMem,,"Onvoldoende gegevensruimte"
MSG_ModTooLarge,,"Moduleniveau-code te groot"
MSG_ProcTooLarge,,"Procedure te lang"
MSG_ExitToRet,,CR,"Typ EXIT om terug te keren naar QBasic"
MSG_QeditText1,," Kleuren instellen "
MSG_QeditText2,," voor editor-venster:"
MSG_NormalText,," Gewone tekst      "
MSG_Breakpoint,," Breekpuntregels   "
MSG_CurStmt,," Huidig statement  "
MSG_HelpTitle,,"HELP: "
MSG_HelpTitleQH,,"MS-DOS Help: "
MSG_FirstContextStr,,"h.pg1"
MSG_HelpAboutEditor,,"MS-DOS Editor"
MSG_HelpAboutQHelp,,"MS-DOS Help"
MSG_HelpAboutInterp,,"MS-DOS QBasic"
MSG_HelpAbout2,,"Versie 1.1"
MSG_HelpAbout3,,"Copyright (C) Microsoft Corporation, 1987-1993."
;
;Section 5.4: HELP messages for menu items <THESE MUST REMAIN CONTIGUOUS>
;
; NOTE: These must match the EXACT order of the midFileNew...midHelpHowToUse
;       definitions in ..\ir\qbasmsgs.txt, because ..\uq\uictl.c (MainWndProc)
;       does a direct mapping from midXxx to MSG_HelpXxx assuming this
;       ordering exists.
;
MSG_HelpFileNew,,"Verwijdert geladen bestand uit geheugen"
MSG_HelpFileOpen,,"Laadt nieuw bestand in geheugen"
MSG_HelpFileMerge,,""
MSG_HelpFileSave,,"Slaat huidig bestand op"
MSG_HelpFileSaveAs,,"Slaat bestand op onder opgegeven naam"
MSG_HelpFileSaveAll,,""
MSG_HelpFileCreate,,""
MSG_HelpFileLoad,,""
MSG_HelpFileUnload,,""
MSG_HelpFilePrint,,"Drukt opgegeven tekst af"
MSG_HelpFileShell,,""
MSG_HelpFileExit,,"Sluit programma af en keert terug naar DOS"
MSG_HelpFileExitQH,,"Sluit MS-DOS Help af en keert terug naar DOS"
MSG_HelpEditUndo,,""
MSG_HelpEditCut,,"Verwijdert selectie en kopieert deze naar buffer"
MSG_HelpEditCopy,,"Kopieert selectie naar buffer"
MSG_HelpEditClear,,"Verwijdert selectie maar kopieert niet naar buffer"
MSG_HelpEditPaste,,"Voegt inhoud buffer in op huidige locatie"
MSG_HelpEditNewSub,,"Opent venster voor nieuw subprogramma"
MSG_HelpEditNewFunc,,"Opent venster voor nieuwe FUNCTION-procedure"
MSG_HelpViewSubs,,"Geeft geladen SUB of FUNCTION weer"
MSG_HelpViewNextProc,,""
MSG_HelpViewSplit,,"Verdeelt scherm in twee vensters"
MSG_HelpViewNextStatement,,""
MSG_HelpViewOutputScreen,,"Geeft uitvoerscherm weer"
MSG_HelpViewIncludes,,""
MSG_HelpViewEditIncl,,""
MSG_HelpSearchFind,,"Zoekt opgegeven tekst"
MSG_HelpSearchSelected,,""
MSG_HelpSearchNext,,"Herhaalt zoekactie naar opgegeven tekst"
MSG_HelpSearchChange,,"Zoekt en wijzigt opgegeven tekst"
MSG_HelpSearchLabel,,""
MSG_HelpRunStart,,"Voert huidig programma uit"
MSG_HelpRunRestart,,"Wist variabelen vr opnieuw stapsgewijs testen"
MSG_HelpRunContinue,,"Zet uitvoering voort na onderbreking"
MSG_HelpRunSetCommand,,""
MSG_HelpRunMakeExe,,""
MSG_HelpRunMakeLib,,""
MSG_HelpRunSetMain,,""
MSG_HelpDebugStep,,"Voert volgend programma-statement uit"
MSG_HelpDebugPStep,,"Spoort procedure-aanroepen in volgend statement op"
MSG_HelpDebugAddWatch,,""
MSG_HelpDebugInstantWatch,,""
MSG_HelpDebugWatchPoint,,""
MSG_HelpDebugDelWatch,,""
MSG_HelpDebugDelAllWatch,,""
MSG_HelpDebugTraceOn,,"Markeert statement dat wordt uitgevoerd"
MSG_HelpDebugHistoryOn,,""
MSG_HelpDebugToggleBp,,"Schakelt breekpunt bij cursorpositie in of uit"
MSG_HelpDebugClearAllBp,,"Verwijdert alle breekpunten"
MSG_HelpDebugBreakOnErr,,""
MSG_HelpDebugSetNextStmt,,"Maakt statement bij cursor tot volgend statement"
MSG_HelpOptionsDisplay,,"Wijzigt schermweergave"
MSG_HelpOptionsPaths,,"Stelt zoekpad voor Help-bestanden in"
MSG_HelpOptionsMouse,,""
MSG_HelpOptionsSyntax,,"Schakelt syntaxiscontrole in of uit"
MSG_HelpOptionsFullMenu,,""
MSG_HelpHelpIndex,,"Geeft Help-index weer"
MSG_HelpHelpContents,,"Geeft inhoudsopgave Help weer"
MSG_HelpHelpSyntax,,"Geeft informatie over Basic-trefwoord bij cursor"
MSG_HelpHelpHelp,,"Geeft informatie over gebruik van online Help"
MSG_HelpHelpStarted,,"Geeft informatie over laden/gebruik MS-DOS Editor"
MSG_HelpHelpKeyboard,,"Geeft toetsencombinaties voor bewerken/verplaatsen"
MSG_HelpHelpAbout,,"Geeft informatie over copyright en versienummer"
MSG_HelpHowToUse,,"Geeft informatie over gebruik MS-DOS Help"
;
;Section 5.5: Status line HELP messages <THESE MUST REMAIN CONTIGUOUS>
;
; IMPORTANT:  If the text of ANY of the following messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
; IMPORTANT:  See UINHELP.ASM for a description of how to change the text of
; IMPORTANT:  MSG_Status[Edit, Running, Immediate, Help, ShiftF1].
;
MSG_StatusMenu,,"Enter=Menu tonen  Esc=Annuleren  Pijl=Volgend item"
MSG_StatusDialog,,"Enter=Uitvoeren  Esc=Annuleren  Tab=Volgend veld  Pijl=Volgend item"
MSG_StatusEdit,,"<F6=Venster> <F2=Sub's> <F5=Uitvoeren> <F8=Stap>"
MSG_StatusRunning,,"<F5=Doorgaan> <F9=Breekpunt a/u> <F8=Stap>"
MSG_StatusImmediate,,"<F6=Venster> <Enter=Regel uitvoeren>"
MSG_StatusHelp,,"<F6=Venster> <Esc=Annul.> <Ctrl+F1=Volgend> <Alt+F1=Vorig>"
MSG_StatusQEdit,,"MS-DOS Editor  <F1=Help> Druk op Alt om menu's te activeren"
MSG_StatusQHelp,,"<F1=Help> <F6=Venster> <Esc=Annuleren> <Ctrl+F1=Volgend> <Alt+F1=Vorig>"
MSG_StatusQHStart,,"MS-DOS Help         <F1=Help> Press ALT to activate menus"
;
;
MSG_StatusQHhelp,,"<Alt+I=Inhoudsopgave> <Alt+L=Volgende> <Alt+R=Vorige>"
;
; LOCALIZATION - To change the accelerator chars in the above line, change the
;       the values in rgmpvkeyidQhelp[], in UIRSRCC.C (At about line #460).
;
;
MSG_StatusF1Help,,"F1=Help   "
MSG_StatusShiftF1,,"<Shift+F1=Help> "
;
; IMPORTANT:  If the text of ANY of the previous messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
;
;Section 5.6: Variable HELP messages <Some of these must remain contiguous>
;Ripped these out for LQB
;
;Section 5.7: misc messages
;
MSG_SearchPathEdit,,"Locatie (pad) van bestand EDIT.HLP:"
MSG_SearchPathHelp,,"Location (path) of HELP.HLP file:"
MSG_SearchPathInterp,,"Locatie (pad) van bestand QBASIC.HLP:"
;
;Section touch: Messages can be added to the bottom of the file
; and all objects except uiutil.obj and qbimsgs.obj can be touched.
; Also touch qbimsgs.rpl, then *.hlp!
; Later, these messages should be moved into their appropriate sections.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbfrn\strings\qbasmsgs.txt ===
; QBasic Standard Error Messages.
; This file is read by the tool makemsgs, which produces the files:
;      qbimsgs.asm, qbimsgs.inc, and qbimsgs.h
;
; Entries in this file have the form:
;  [<symbol's name>,[<msg index/error code>],"<ASCII msg>"] [;<comment>]
;
; If <msg index/error code> is not specified, the next available one
;    is assigned.
;
;Section 1:  Runtime Errors - symbol names are kept small to decrease
;            the size of the runtime library.
;            Names begin with ER_ to distinguish them from non-runtime
;            errors, which begin with MSG_.
;
ER_NF,1,"NEXT sans FOR"
ER_SN,2,"Erreur de syntaxe"
ER_RG,3,"RETURN sans GOSUB"
ER_OD,4,"Donnes puises"
ER_FC,5,"Appel de fonction non permis"
ER_OV,6,"Dpassement de capacit"
ER_OM,7,"Mmoire insuffisante"
ER_UL,8,"Etiquette non dfinie"
ER_SOR,9,"Indice en dehors des limites"
ER_DD,10,"Cette dfinition existe dj"
ER_DV0,11,"Division par zro"
ER_ID,12,"Instruction non permise en mode direct"
ER_TM,13,"Types incompatibles"
ER_OS,14,"Espace pour chanes satur"
;15 is unused
ER_BS,16,"Formule de chane trop complexe"
ER_CN,17,"Inpossible de continuer"
ER_UF,18,"Fonction non dfinie"
ER_NR,19,"RESUME absent"
ER_RE,20,"RESUME sans erreur"
;21 is unused
;22 is unused
;23 is unused
ER_DTO,24,"Dlai d'attente du priphrique coul"
ER_DF,25,"Erreur priphrique"
ER_FN,26,"FOR sans NEXT"
ER_OP,27,"Attente papier"
;28 is unused
ER_WH,29,"WHILE sans WEND"
ER_WE,30,"WEND sans WHILE"
;31 is unused
;32 is unused
ER_DL,33,"Cette tiquette est dj dfinie"
;34 is unused
ER_US,35,"Sous-programme non dfini"
;; ER_SIU,36,"Subprogram already in use"  ;dead after recursion added
ER_AC,37,"Le nombre d'arguments ne concorde pas"
ER_UA,38,"Tableau non dfini"
ER_CaseElse,39,"CASE ELSE attendu"
ER_VarReq,40,"Variable requise"
;41 is unused
;42 is unused
;43 is unused
;44 is unused
;45 is unused
;46 is unused
;47 is unused
;48 is unused
;49 is unused
ER_FOV,50,"Dbordement de champ avec FIELD"
ER_IER,51,"Erreur interne"
ER_BFN,52,"Nom ou numro de fichier incorrect"
ER_FNF,53,"Fichier non trouv"
ER_BFM,54,"Mode d'accs au fichier incorrect"
ER_FAO,55,"Fichier dj ouvert"
ER_FSA,56,"Instruction FIELD active"
ER_IOE,57,"Erreur E/S sur priphrique"
ER_FAE,58,"Ce fichier existe dj"
ER_BRL,59,"Longueur d'enregistrement incorrecte"
;60 is unused
ER_DFL,61,"Disque satur"
ER_RPE,62,"Lecture hors des limites du fichier"
ER_BRN,63,"Numro d'enregistrement incorrect"
ER_IFN,64,"Nom de fichier incorrect"
;65 is unused
;66 is unused   - used to be ER_FDR - Direct statement in file
ER_TMF,67,"Trop de fichiers"
ER_DNA,68,"Priphrique non disponible"
ER_CBO,69,"Dpassement de capacit du tampon"
ER_PRM,70,"Accs refus"
ER_DNR,71,"Disque non prt"
ER_DME,72,"Disque dfectueux"
ER_ADF,73,"Caractristique non disponible"
ER_RAD,74,"RENAME sur lecteur diffrent"
ER_PAE,75,"Erreur de chemin d'accs / d'accs au fichier"
ER_PNF,76,"Chemin d'accs non trouv"
;;;ER_DLK,77,"Deadlock" ;not needed until OS/2 version
;
; The following ER_UE marks the last trappable Runtime Error Code
;
ER_UE,,"Erreur non imprimable"
;
;=========================================================================
; Subsequent ER_ messages are special, and are intimately tied in with
; the runtime message file, messages.inc.
; Some of these errors are considered "very fatal", and cause termination;
; others are not errors at all - - we just supply the text for some runtime
; messages here.
; These messages must remain contiguous and in the same order, unless
; a matching change is made in messages.inc.
;
; First group of internal errors - - these are actually runtime messages,
; not errors
; Any message that begins ER_UL is used in constructing a message
; as follows:
;  Error in loading (file) - Internal error
;
ER_RFS,,"Recommencer depuis le dbut"
ER_BFC,,"octets libres",CR         ;'CR' means terminate with a Carriage Return
ER_ULP,,"Fichier introuvable ("    ;preamble for user file path prompt
ER_ULT,,"). Entrez le chemin : "       ;postamble for user file path prompt
ER_ULE,,"Erreur lors du chargement du fichier (" ;preamble for loader errors
ER_ULG,,") - "                  ;postamble for loader errors
ER_RNS,,"Valeur d'init. du gnrateur de nombres alatoires (de -32 768  32 767)"
ER_HRS,,"Appuyez sur une touche pour continuer" ;Displayed when errors occurr in QBC exec.
;
; Second group of internal errors - these are "very fatal"
ER_SSC,,"Espace pour chanes altr"  ;string space or local heap trashed somehow
ER_ULD,,"Erreur E/S disque"        ;problem in loading U.L. from disk
ER_ULI,,"Format non valide"        ;attempt to load a U.L. with incorrect format
ER_ULF,,"Fichier introuvable"      ;redirected IO and cannot find file in path
;
; Third group of internal errors - these are also "very fatal"
ER_D21,,"Version de DOS 2.10 ou ultrieure requise"
ER_INI,,"Erreur lors de l'initialisation de QBasic" ;error in initializing runtime
ER_ULO,,"Mmoire insuffisante"         ;out of memory loading U.L.
ER_DMA,,"Erreur dans la zone mmoire alloue  DOS" ;someone walked on DOS-owned memory
ER_FHC,,"Tas mmoire lointain altr"      ;similar to string space corrupt
ER_ULM,,"Erreur interne"        ;U.L. loading found a bad segment address
;
; QB-specific internal errors - these are "very fatal"
; NOTE: These must come after other internal errors (no equivalent in
;       messages.inc)
;
;Both groups of the command line help message must remain contiguous.
;They must start with the label ER_ISWEDIT/ER_ISWHELP/ER_ISWINTERP and end
;with the label ER_ISWEDITEND/ER_ISWHELPEND/ERISWINTERPEND. The labels of the
;intermediate lines does not matter.
;
ER_ISWEDIT,,"Lance l'Editeur MS-DOS qui cre et change les fichiers ASCII."
ER_ISWEDIT1,," "
ER_ISWEDIT2,,"EDIT [lecteur][chemin][fichier] [/B] [/G] [/H] [/NOHI]"
ER_ISWEDIT3,," "
ER_ISWEDIT4,,"  [lecteur][chemin]fichier   Fichier  diter."
ER_ISWEDIT5,,"  /B        Permet d'utiliser un cran monochrome avec adaptateur couleur."
ER_ISWEDIT6,,"  /G        Active une mise  jour la plus rapide d'un cran CGA."
ER_ISWEDIT7,,"  /H        Choisit la rsolution la plus haute possible pour votre matriel."
ER_ISWEDITEND,,"  /NOHI     Permet d'utiliser un cran qui ne gre pas la double intensit."
;
ER_ISWQHELP,,"Lance l'Aide des commandes MS-DOS."
ER_ISWQHELP1,," "
ER_ISWQHELP2,,"HELP [/B] [/G] [/H] [/NOHI] [rubrique]"
ER_ISWQHELP3,," "
ER_ISWQHELP4,," /B         Permet l'utilisation d'un cran monochrome avec un carte" 
ER_ISWQHELP5,,"            graphique couleur."
ER_ISWQHELP6,," /G         Fournit la mise  jour la plus rapide  un cran CGA."
ER_ISWQHELP7,," /H         Affiche le nombre maximum de lignes possible pour votre matriel."
ER_ISWQHELP8,," /NOHI      Permet l'utilisation d'un cran sans le support de la" 
ER_ISWQHELP9,,"            haute-intensit."
ER_ISWQHELPEND,," [rubrique] Prcise la rubrique de l'Aide  afficher.";
;
ER_ISWINTERP,,"Lance l'environnement de programmation MS-DOS QBasic."
ER_ISWINTERP1,," "
ER_ISWINTERP2,,"QBASIC [/B] [/EDITOR] [/G] [/H] [/MBF] [/NOHI] [[/RUN] [lecteur][chem]fichier]"
ER_ISWINTERP3,," "
ER_ISWINTERP4,," /B         Permet d'utiliser un cran monochrome avec adaptateur couleur."
ER_ISWINTERP5,," /EDITOR    Lance l'Editeur MS-DOS."
ER_ISWINTERP6,," /G         Active une mise  jour plus rapide d'un cran CGA."
ER_ISWINTERP7,," /H         Choisit la rsolution la plus haute possible pour votre matriel."
ER_ISWINTERP8,," /MBF       Convertit les fonctions intrinsques MKS$, MKD$, CVS et CVD"
ER_ISWINTERP9,,"            en MKSMBF$, MKDMBF$, CVSMBF et CVDMBF, respectivement."
ER_ISWINTERPA,," /NOHI      Permet l'utilisation d'un cran qui ne gre pas la double intensit"
ER_ISWINTERPB,," /RUN       Excute un fichier programme QBasic avant de l'afficher."
ER_ISWINTERPEND,," [[lecteur][chem]fichier] Spcifie le fichier programme  charger ou  excuter."
;
;=========================================================================
;
;-------------------------------------------------------------------------
;MSG_GoDirect is non-trappable interpreter-specific
; error which allow us to back out of what we're doing and escape back
; to direct mode.
;
MSG_GoDirect,,""
MSG_OutOfStack,,"Espace pour la pile insuffisant"
MSG_DocTooLarge,,"Document trop long"
MSG_InclTooLarge,,"Fichier inclus trop long"
;
;-------------------------------------------------------------------------
; End of runtime errors.  Messages beyond this point can be re-arranged
; in any order.
;-------------------------------------------------------------------------
;
;Section 2: QBI Parser Related Messages
;
MSG_IdTooLong,,"Identificateur trop long"
MSG_BadId,,"Identificateur non valide"
MSG_IdImp,,"Un identificateur ne peut se terminer par %, &, !, #, ou $"
MSG_BadElemRef,,"Un identificateur ne peut comprendre un point"
MSG_ExpTooComplex,,"Expression trop complexe"
MSG_IllegalNumber,,"Nombre non permis"
MSG_InvConst,,"Constante non valide"
MSG_expected,,"Attendu : "
MSG_or,," ou "
;
; Parser errors which are preceded by "Expected: "
;
MSG_ExpAssignment,,"variable=expression"
MSG_ExpExp,,"expression"
MSG_ExpVar,,"variable"
MSG_ExpId,,"identificateur"
MSG_ExpStatement,,"instruction"
MSG_ExpLabel,,"tiquette"
MSG_ExpLn,,"numro de ligne"
MSG_Letter,,"lettre"
MSG_eos,,"fin d'instruction"
MSG_RightParen,,")"
MSG_ExpIdCallArg,,"expression"
MSG_ExpIdParm,,"variable"
MSG_ExpFNId,,"identificateur commenant par FN"
MSG_ExpIfClause,,"tiquette ou instruction"
MSG_ExpLabLn,,"tiquette ou numro de ligne"
MSG_ExpLitString,,"constante de chane"
MSG_ExpLit0,,"0"
MSG_ExpLit1,,"1"
MSG_ExpNArgs,,"[expression],..."
MSG_ExpRwB,,"B"
MSG_ExpRwF,,"F"
MSG_ExpRwBF,,"BF"
MSG_ExpRel,,"< ou <= ou > ou >= ou = ou <>"
;
;Section 3:  TextMgr/ReParse errors
;
MSG_InvModLev,,"Instruction non permise hors de SUB, FUNCTION ou DEF FN"
MSG_InvMain,,"Instruction non permise hors de SUB/FUNCTION"
MSG_InvProc,,"Instruction non permise dans une procdure ou fonction DEF FN"
MSG_InvBeforeProcDef,,"Cette instruction ne peut prcder une dfinition de SUB/FUNCTION"
MSG_ProcNoEnd,,"SUB/FUNCTION sans END SUB/FUNCTION"
MSG_EndNoProc,,"END SUB/FUNCTION sans SUB/FUNCTION"
MSG_EndNoDef,,"END DEF sans DEF"
MSG_UndElem,,"Elment non dfini"
MSG_UndType,,"Type non dfini"
MSG_1stStmt,,"Doit tre la premire instruction sur la ligne"
MSG_EndProc,,"END SUB ou END FUNCTION doit tre la dernire ligne"
MSG_NoEndType,,"TYPE sans END TYPE"
MSG_NoType,,"END TYPE sans TYPE"
MSG_InvInTypeBlk,,"Instruction non permise dans bloc TYPE"
MSG_InvIncl,,"Instruction non valide dans fichier INCLUDE"
MSG_InvDecl,,"DECLARE non valide dans procdure QBasic"
MSG_FNstart,,"Ne peut commencer par 'FN'"
MSG_NotBlock,,"Opration ncessitant disque"
MSG_BadMeta,,"Erreur Directive"
MSG_NoBpCase,,"Points d'arrt non permis dans clauses CASE ou END SELECT"
;
;Section 4:  Scan-time errors
;
MSG_OBA,,"Tableau dj dimensionn"
MSG_COM,,"COMMON et DECLARE doivent prcder les instructions excutables"
MSG_EWI,,"END IF sans bloc IF"
MSG_IWE,,"Bloc IF sans END IF"
MSG_ElseWI,,"ELSE sans IF"
MSG_ExitScope,,"EXIT non compris dans FOR...NEXT"
MSG_ExitDo,,"EXIT DO non compris dans DO...LOOP"
MSG_Do,,"DO sans LOOP"
MSG_Loop,,"LOOP sans DO"
MSG_Select,,"SELECT sans END SELECT"
MSG_Case,,"CASE sans SELECT"
MSG_EndSelect,,"END SELECT sans SELECT"
MSG_InvFixStr,,"Chane de longueur fixe non permise"
MSG_InvTypedVar,,"Variable de type dfini par l'utilisateur non permise dans expression"
MSG_DefNoEnd,,"DEF sans END DEF"
MSG_ParmTM,,"Type de paramtre non concordant"
MSG_DupLibPrs,,"Procdure dj dfinie dans bibliothque Quick"
MSG_ASRqd1st,,"Clause AS requise dans la premire dclaration"
MSG_ASRqd,,"Clause AS requise"
MSG_ExpectedCase,,"Instructions/tiquettes non permises entre SELECT CASE et CASE"
MSG_NoNumArr,,"Tableau numrique non permis"
MSG_InType,,"Non permis hors d'un bloc TYPE"
MSG_ULCom,,"COMMON trop petit dans bibliothque Quick"
MSG_SubCnt,,"Nombre de dimensions incorrect"
MSG_DefFnCtrl,,"DEF FN non permis dans les instructions de contrle"
MSG_Unsupported,,"Caractristique non disponible"
;
;Section 5.1: User Interface Related Messages that could be described in
;             user guide's error message appendix
;
MSG_CantCont,,"Vous devrez redmarrer le programme aprs cette modification. Continuer ?"
MSG_NoMainProg,,"Pas de module principal. Choisissez Dfinir le module principal."
MSG_HelpOOM,,"Mmoire insuffisante pour afficher l'aide"
;
;Section 5.2: Messages that require special handling in ReportError()
;
;Note: The next 2 messages must have numbers < 256 for because they can be
;      passed to RtError_Ini by exStRunFile during command-line load.
;
MSG_DupMrs,,"Fichier charg prcdemment"
MSG_DupPrs,,"Module contenant une dfinition de procdure en double"
MSG_MrsNotFound,,"Module non trouv. Dcharger le module du programme ?"
;
;Section 5.3: General User Interface messages
;
MSG_Overwrite,,"Le fichier existe dj. Rcrire ?"
MSG_DelProc,,"Supprimer procdure du module ?"
MSG_MakeRem,,"Lignes vierges non permises avant SUB/FUNCTION. Convertir en commentaires ?"
MSG_NotSaved,,"Fichier modifi depuis le dernier enregistrement. Enregistrer maintenant ?"
MSG_NotSavedAll,,"Le fichier charg n'a pas t enregistr. Enregistrer maintenant ?"
MSG_NotSavedInc,,"Les fichiers INCLUDE doivent tre enregistrs avent excution. Enregistrer ?"
MSG_NotSavedIncSav,,"Enregistrer d'abord les fichiers INCLUDE modifis ?"
MSG_BadNextStmt,,"Passage hors du module/procdure interdit"
MSG_Prt1,,"Attente pour imprimante"
MSG_Prt2,,"Impression en cours - Appuyez sur ECHAP pour abandonner"
MSG_Immediate,,"Immdiate"
MSG_Untitled,,"Sans_nom"
MSG_FALSE,,"<FAUX>"
MSG_TRUE,,"<VRAI>"
MSG_Black,,"Noir"
MSG_Blue,,"Bleu"
MSG_Green,,"Vert"
MSG_Cyan,,"Cyan"
MSG_Red,,"Rouge"
MSG_Magenta,,"Magenta"
MSG_Brown,,"Brun"
MSG_White,,"Blanc"
MSG_Gray,,"Gris"
MSG_BrBlue,,"Bleu br."
MSG_BrGreen,,"Vert br."
MSG_BrCyan,,"Cyan br."
MSG_BrRed,,"Rouge br."
MSG_Pink,,"Rose"
MSG_Yellow,,"Jaune"
MSG_BrWhite,,"Blanc br."
MSG_MustSpecifyName,,"Le nom doit tre spcifi"
MSG_DataMoved,,"Instructions DATA dplaces du niveau SUB au niveau module"
MSG_ModuleExists,,"Un module portant ce nom a dj t charg"
MSG_NoHelp,,"Fichier "
MSG_NoHelp1,," non trouv."
MSG_NoHelp2,,"Insrez une disquette contenant ce fichier dans le lecteur et"
MSG_NoHelp3,,"ressayez, ou changez le chemin d'aide dans Options-Chemin de l'aide."
MSG_NoQHelp2,,"Choisissez OK et vrifiez que le"
MSG_NoQHelp3,,"fichier se trouve dans votre chemin."
MSG_NoSearchString,,"Vous devez spcifier une chane  rechercher"
MSG_MatchNotFound,,"Concordance non trouve"
MSG_ChangeComplete,,"Remplacement termin"
MSG_Is,," est "
MSG_MainModule,,"le module principal "
MSG_Module,,"un module "
MSG_IncludeFile,,"un fichier INCLUDE "
MSG_Document,,"un document "
MSG_Sub,,"une procdure SUB dans "
MSG_Function,,"une procdure FUNCTION dans "
MSG_ReqSub,,"Cette opration ncessite la slection d'une procdure SUB ou FUNCTION"
;If text of MSG_SwitchDisks changes, ref code in uifile.c must change as well.
MSG_SwitchDisks,,"Insrez la disquette dans le lecteur A:"
MSG_Loading,,"Chargement et analyse en cours"
MSG_Saving,,"Enregistrement en cours"
MSG_Compiling,,"Edition des liens"
MSG_Searching,,"Recherche en cours - appuyez sur ECHAP pour abandonner"
MSG_CantSetTabs,,"Impossible de changer les tabulations"
MSG_OutNearMem,,"Espace pour donnes satur"
MSG_ModTooLarge,,"Code trop long au niveau module"
MSG_ProcTooLarge,,"Procdure trop longue"
MSG_ExitToRet,,CR,"Tapez EXIT pour revenir  QBasic"
MSG_QeditText1,,"Dfinissez les couleurs pour  "
MSG_QeditText2,,"la fentre d'dition de texte."
MSG_NormalText,,"Texte normal        "
MSG_Breakpoint,,"Points d'arrt      "
MSG_CurStmt,,   "Instruction courante"
MSG_HelpTitle,,"AIDE : "
MSG_HelpTitleQH,,"Aide MS-DOS : "
MSG_FirstContextStr,,"h.pg1"
MSG_HelpAboutEditor,,"Editeur MS-DOS"
MSG_HelpAboutQHelp,,"Aide MS-DOS"
MSG_HelpAboutInterp,,"MS-DOS QBasic"
MSG_HelpAbout2,,"Version 1.1"
MSG_HelpAbout3,,"Copyright (C) Microsoft Corporation, 1987-1993."
;
;Section 5.4: HELP messages for menu items <THESE MUST REMAIN CONTIGUOUS>
;
MSG_HelpFileNew,,"Supprime le programme charg de la mmoire"
MSG_HelpFileOpen,,"Charge un nouveau fichier en mmoire"
MSG_HelpFileMerge,,""
MSG_HelpFileSave,,"Enregistre le fichier courant sur disque"
MSG_HelpFileSaveAs,,"Enregistre le fichier courant sous un nom spcifi"
MSG_HelpFileSaveAll,,""
MSG_HelpFileCreate,,""
MSG_HelpFileLoad,,""
MSG_HelpFileUnload,,""
MSG_HelpFilePrint,,"Imprime le texte spcifi"
MSG_HelpFileShell,,""
MSG_HelpFileExit,,"Quitte l'Editeur et retourne au DOS"
MSG_HelpFileExitQH,,"Quitte l'Aide MS-DOS et retourne au DOS"
MSG_HelpEditUndo,,""
MSG_HelpEditCut,,"Supprime le texte slectionn et le copie dans le tampon"
MSG_HelpEditCopy,,"Copie le texte slectionn dans le tampon"
MSG_HelpEditClear,,"Supprime texte slectionn sans le copier dans le tampon"
MSG_HelpEditPaste,,"Insre le contenu du tampon  l'emplacement courant"
MSG_HelpEditNewSub,,"Ouvre une fentre pour un nouveau sous-programme"
MSG_HelpEditNewFunc,,"Ouvre une fentre pour une nouvelle procdure FUNCTION"
MSG_HelpViewSubs,,"Affiche la procdure SUB ou FUNCTION charge"
MSG_HelpViewNextProc,,""
MSG_HelpViewSplit,,"Divise l'cran en deux fentres d'affichage"
MSG_HelpViewNextStatement,,""
MSG_HelpViewOutputScreen,,"Affiche l'cran de sortie du programme"
MSG_HelpViewIncludes,,""
MSG_HelpViewEditIncl,,""
MSG_HelpSearchFind,,"Cherche le texte spcifi"
MSG_HelpSearchSelected,,""
MSG_HelpSearchNext,,"Cherche l'occurence suivante du texte spcifi prcdemment"
MSG_HelpSearchChange,,"Cherche et remplace le texte spcifi"
MSG_HelpSearchLabel,,""
MSG_HelpRunStart,,"Excute le programme courant"
MSG_HelpRunRestart,,"Efface les variables en vue d'une excution pas  pas"
MSG_HelpRunContinue,,"Continue l'excution aprs un point d'arrt"
MSG_HelpRunSetCommand,,""
MSG_HelpRunMakeExe,,""
MSG_HelpRunMakeLib,,""
MSG_HelpRunSetMain,,""
MSG_HelpDebugStep,,"Excute l'instruction suivante"
MSG_HelpDebugPStep,,"Excute l'instruction suivante, en mode trace raccourcie"
MSG_HelpDebugAddWatch,,""
MSG_HelpDebugInstantWatch,,""
MSG_HelpDebugWatchPoint,,""
MSG_HelpDebugDelWatch,,""
MSG_HelpDebugDelAllWatch,,""
MSG_HelpDebugTraceOn,,"Contraste l'instruction en cours d'excution"
MSG_HelpDebugHistoryOn,,""
MSG_HelpDebugToggleBp,,"Dfinit/supprime un point d'arrt  l'emplacement du curseur"
MSG_HelpDebugClearAllBp,,"Supprime tous les points d'arrt"
MSG_HelpDebugBreakOnErr,,""
MSG_HelpDebugSetNextStmt,,"Dfinit la prochaine instruction  excuter"
MSG_HelpOptionsDisplay,,"Modifie l'attributs d'affichage"
MSG_HelpOptionsPaths,,"Dfinit le chemin d'accs aux fichiers d'aide"
MSG_HelpOptionsMouse,,""
MSG_HelpOptionsSyntax,,"Active/dsactive la vrification de syntaxe."
MSG_HelpOptionsFullMenu,,""
MSG_HelpHelpIndex,,"Affiche l'index de l'aide"
MSG_HelpHelpContents,,"Affiche la table des matires de l'aide"
MSG_HelpHelpSyntax,,"Affiche les informations sur le mot-cl situ sous le curseur"
MSG_HelpHelpHelp,,"Affiche le guide d'utilisation de l'aide"
MSG_HelpHelpStarted,,"Affiche l'aide sur l'utilisation de l'Editeur MS-DOS"
MSG_HelpHelpKeyboard,,"Affiche les touches de dplacement et d'dition"
MSG_HelpHelpAbout,,"Affiche le numro de version et l'information de copyright"
MSG_HelpHowToUse,,"Affiche des informations sur l'utilisation de l'Aide MS-DOS"
;
;Section 5.5: Status line HELP messages <THESE MUST REMAIN CONTIGUOUS>
;
; IMPORTANT:  If the text of ANY of the following messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
; IMPORTANT:  See UINHELP.ASM for a description of how to change the text of
; IMPORTANT:  MSG_Status[Edit, Running, Immediate, Help, ShiftF1].
;
MSG_StatusMenu,,"ENTREE=Menu  ECHAP=Annuler FLECHE=Elment suiv."
MSG_StatusDialog,,"ENTREE=Excuter ECHAP=Annuler TAB=Champ suiv.  FLECHE=Elm. suiv."
MSG_StatusEdit,,"F6=Fentre F2=Subs F5=Excution F8=Pas  pas"
MSG_StatusRunning,,"F5=Continuer F9=Point d'arrt F8=Pas  pas"
MSG_StatusImmediate,,"F6=Fentre ENTREE=Excuter ligne"
MSG_StatusHelp,,"F6=Fentre ECHAP=Annuler CTRL+F1=Suivant ALT+F1=Prcdent"
MSG_StatusQEdit,,"Editeur MS-DOS  F1=Aide  ALT=Activer le menu"
MSG_StatusQHelp,,"F1=Aide F6=Fentre ECHAP=Annuler CTRL+F1=Suivant ALT+F1=Prcdent"
MSG_StatusQHStart,,"Aide MS-DOS <F1=Aide> Appuyez sur ALT pour activer les menus"
;
;
MSG_StatusQHhelp,,"<ALT+C=Contenus> <ALT+S=Suivant> <ALT+P=Prcdent>"
;
;
MSG_StatusF1Help,,"F1=Aide  "
MSG_StatusShiftF1,,"MAJ+F1=Aide  "
;
; IMPORTANT:  If the text of ANY of the previous messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
;
;Section 5.6: Variable HELP messages <Some of these must remain contiguous>
;Ripped these out for LQB
;
;Section 5.7: misc messages
;
MSG_SearchPathEdit,,"Emplacement du fichier EDIT.HLP :"
MSG_SearchPathHelp,,"Emplacement du fichier HELP.HLP :"
MSG_SearchPathInterp,,"Emplacement du fichier QBASIC.HLP :"
;
;Section touch: Messages can be added to the bottom of the file
; and all objects except uiutil.obj and qbimsgs.obj can be touched.
; Also touch qbimsgs.rpl, then *.hlp!
; Later, these messages should be moved into their appropriate sections.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbger\strings\qbasmsgs.txt ===
; QBasic Standard Error Messages.
; This file is read by the tool makemsgs, which produces the files:
;      qbimsgs.asm, qbimsgs.inc, and qbimsgs.h
;
; Entries in this file have the form:
;  [<symbol's name>,[<msg index/error code>],"<ASCII msg>"] [;<comment>]
;
; If <msg index/error code> is not specified, the next available one
;    is assigned.
;
;Section 1:  Runtime Errors - symbol names are kept small to decrease
;            the size of the runtime library.
;            Names begin with ER_ to distinguish them from non-runtime
;            errors, which begin with MSG_.
;
;  NOTE: A *BLANK* line terminates MAKEMSG. Do not add blank lines!
;
;
ER_NF,1,"NEXT ohne FOR"
ER_SN,2,"Syntaxfehler"
ER_RG,3,"RETURN ohne GOSUB"
ER_OD,4,"READ jenseits von DATA"
ER_FC,5,"Unzulssiger Funktionsaufruf"
ER_OV,6,"berlauf"
ER_OM,7,"Zu wenig Speicher"
ER_UL,8,"Marke nicht definiert"
ER_SOR,9,"Index auerhalb des zulssigen Bereichs"
ER_DD,10,"Doppelte Definition"
ER_DV0,11,"Division durch Null"
ER_ID,12,"Unzulssig im Direkt-Modus"
ER_TM,13,"Falscher Datentyp"
ER_OS,14,"Zu wenig Zeichenketten-Speicherplatz"
;15 is unused
ER_BS,16,"String-Formel zu umfangreich"
ER_CN,17,"QBasic kann nicht fortsetzen"
ER_UF,18,"QBasic-Funktion nicht definiert"
ER_NR,19,"RESUME fehlt"
ER_RE,20,"RESUME ohne Fehler"
;21 is unused
;22 is unused
;23 is unused
ER_DTO,24,"Zeitberschreitung am Gert"
ER_DF,25,"Gertefehler"
ER_FN,26,"FOR ohne NEXT"
ER_OP,27,"Papier zu Ende"
;28 is unused
ER_WH,29,"WHILE ohne WEND"
ER_WE,30,"WEND ohne WHILE"
;31 is unused
;32 is unused
ER_DL,33,"Doppelt definierte Marke"
;34 is unused
ER_US,35,"QBasic-Unterprogramm nicht definiert"
;; ER_SIU,36,"Subprogramm wird bereits ausgefhrt"  ;dead after recursion added
ER_AC,37,"Falsche Anzahl von Argumenten"
ER_UA,38,"Feld nicht definiert"
ER_CaseElse,39,"CASE ELSE erwartet"
ER_VarReq,40,"Variable erforderlich"
;41 is unused
;42 is unused
;43 is unused
;44 is unused
;45 is unused
;46 is unused
;47 is unused
;48 is unused
;49 is unused
ER_FOV,50,"FIELD-berlauf"
ER_IER,51,"Interner Fehler"
ER_BFN,52,"Dateiname oder -nummer unzulssig"
ER_FNF,53,"Datei nicht gefunden"
ER_BFM,54,"Ungltiger Dateimodus"
ER_FAO,55,"Datei bereits geffnet"
ER_FSA,56,"FIELD-Anweisung aktiv"
ER_IOE,57,"Gertefehler bei Ein/Ausgabe"
ER_FAE,58,"Datei existiert bereits"
ER_BRL,59,"Ungltige Datensatzlnge"
;60 is unused
ER_DFL,61,"Festplatte/Diskette voll"
ER_RPE,62,"Eingabe nach Dateiende"
ER_BRN,63,"Unzulssige Datensatznummer"
ER_IFN,64,"Unzulssiger Dateiname"
;65 is unused
;66 is unused   - used to be ER_FDR - Direct statement in file
ER_TMF,67,"Zu viele Dateien"
ER_DNA,68,"Gert nicht verfgbar"
ER_CBO,69,"Kommunikationspuffer-berlauf"
ER_PRM,70,"Zugriff verweigert"
ER_DNR,71,"Festplatte/Diskette nicht bereit"
ER_DME,72,"Datentrger-Fehler"
ER_ADF,73,"Erweiterte Funktionen nicht verfgbar"
ER_RAD,74,"Umbenennen zwischen Datentrgern"
ER_PAE,75,"Pfad/Datei-Zugriffsfehler"
ER_PNF,76,"Pfad nicht gefunden"
;;;ER_DLK,77,"Verklemmung" ;not needed until OS/2 version
;
; The following ER_UE marks the last trappable Runtime Error Code
;
ER_UE,,"Nicht druckbarer Fehler"
;
;=========================================================================
; Subsequent ER_ messages are special, and are intimately tied in with
; the runtime message file, messages.inc.
; Some of these errors are considered "very fatal", and cause termination;
; others are not errors at all - - we just supply the text for some runtime
; messages here.
; These messages must remain contiguous and in the same order, unless
; a matching change is made in messages.inc.
;
; First group of internal errors - - these are actually runtime messages,
; not errors
; Any message that begins ER_UL is used in constructing a message
; as follows:
;  Error in loading (file) - Internal error
;
ER_RFS,,"Nochmal von vorn beginnen"
ER_BFC,,"Bytes frei",CR         ;'CR' means terminate with a Carriage Return
ER_ULP,,"Kann Datei nicht finden ("    ;preamble for user file path prompt
ER_ULT,,"). Geben Sie einen Pfad an: "       ;postamble for user file path prompt
ER_ULE,,"Fehler beim Laden der Datei (" ;preamble for loader errors
ER_ULG,,") - "                  ;postamble for loader errors
ER_RNS,,"Zufallszahlen-Startwert (-32768 bis 32767)"
ER_HRS,,"Eine beliebige Taste drcken, um fortzusetzen" ;Displayed when errors occurr in QBC exec.
;
; Second group of internal errors - these are "very fatal"
ER_SSC,,"String-Bereich verndert/ungltig"  ;string space or local heap trashed somehow
ER_ULD,,"Datentrger Ein/Ausgabe-Fehler"        ;problem in loading U.L. from disk
ER_ULI,,"Ungltiges Format"        ;attempt to load a U.L. with incorrect format
ER_ULF,,"Kann Datei nicht finden"      ;redirected IO and cannot find file in path
;
; Third group of internal errors - these are also "very fatal"
ER_D21,,"Erfordert DOS, Version 2.10, oder hher"
ER_INI,,"Fehler whrend QBasic-Initialisierung" ;error in initializing runtime
ER_ULO,,"Unzureichender Speicher"         ;out of memory loading U.L.
ER_DMA,,"DOS-Speicherbereich-Fehler" ;someone walked on DOS-owned memory
ER_FHC,,"Stapelbereich verndert/ungltig"      ;similar to string space corrupt
ER_ULM,,"Interner Fehler"        ;U.L. loading found a bad segment address
;
; QB-specific internal errors - these are "very fatal"
; NOTE: These must come after other internal errors (no equivalent in
;       messages.inc)
;
;Both groups of the command line help message must remain contiguous.
;They must start with the label ER_ISWEDIT/ER_ISWINTERP and end
;with the label ER_ISWEDITEND/ERISWINTERPEND.  The labels of the
;intermediate lines does not matter.
;
ER_ISWEDIT,,"Startet den MS-DOS-Editor, der ASCII-Dateien erzeugt und verndert."
ER_ISWEDIT1,," "
ER_ISWEDIT2,,"EDIT [[Laufwerk:][Pfad]Dateiname] [/B] [/G] [/H] [/NOHI]"
ER_ISWEDIT3,," "
ER_ISWEDIT4,,"  [Laufwerk:][Pfad]Dateiname  Spefiziert die zu bearbeitende ASCII-Datei."
ER_ISWEDIT5,,"  /B         Erlaubt Verwendung eines Monochrom-Bildschirms mit CGA-Karte."
ER_ISWEDIT6,,"  /G         Liefert die schnellste Anpassung eines CGA-Bildschirms."
ER_ISWEDIT7,,"  /H         Zeigt die bei Ihrer Hardware maximale Anzahl von Zeilen an."
ER_ISWEDITEND,,"  /NOHI      Verwendung eines Bildschirms ohne zwei Helligkeitsstufen."
;
ER_ISWQHELP,,"Startet den MS-DOS-Hilfe fr MS-DOS Befehle."
ER_ISWQHELP1,," "
ER_ISWQHELP2,,"HELP [/B] [/G] [/H] [/NOHI] [Thema]"
ER_ISWQHELP3,," "
ER_ISWQHELP4,,"  /B        Erlaubt Verwendung eines Monochrom-Bildschirms mit CGA-Karte."
ER_ISWQHELP5,,"  /G        Liefert die schnellste Anpassung eines CGA-Bildschirms."
ER_ISWQHELP6,,"  /H        Zeigt bei Ihrer Hardware die maximale Anzahl von Zeilen an."
ER_ISWQHELP7,,"  /NOHI     Verwendung eines Bilschirms ohne zwei Helligkeitsstufen."
ER_ISWQHELPEND,,"  [Thema]   Angabe des Hilfe-Themas zum Ansehen.."
;
;
ER_ISWINTERP,,"Startet die MS-DOS QBasic-Programmierumgebung."
ER_ISWINTERP1,,"QBASIC [/B] [/EDITOR] [/G] [/H] [/MBF] [/NOHI] [[/RUN]"
ER_ISWINTERP2,,"       [Laufwerk:][Pfad]Dateiname]"
ER_ISWINTERP3,,"  /B          Erlaubt Verwendung eines Monochrom-Bildschirms mit CGA-Karte."
ER_ISWINTERP4,,"  /EDITOR     Startet den MS-DOS-Editor."
ER_ISWINTERP5,,"  /G          Liefert schellstes Anpassen eines CGA-Bildschirms."
ER_ISWINTERP6,,"  /H          Zeigt die bei Ihrer Hardware maximale Anzahl von Zeilen an."
ER_ISWINTERP7,,"  /MBF        Konvertiert die eingebauten Funktionen MKS$, MKD$, CVS und CVD"
ER_ISWINTERP8,,"              in MKSMBF$, MKDMBF$, CVSMBF bzw. CVDMBF."
ER_ISWINTERP9,,"  /NOHI       Verwendung eines Bildschirms ohne zwei Helligkeitsstufen."
ER_ISWINTERPA,,"  /RUN        Fhrt eine Programmdatei vor dem Anzeigen in QBasic aus."
ER_ISWINTERPB,,"  [[Laufwerk:][Pfad]Dateiname] Spezifiziert die zu ladende oder auszufhrende"
ER_ISWINTERPEND,,"                               Programmdatei."
;
;=========================================================================
;
;-------------------------------------------------------------------------
;MSG_GoDirect is non-trappable interpreter-specific
; error which allow us to back out of what we're doing and escape back
; to direct mode.
;
MSG_GoDirect,,""
MSG_OutOfStack,,"Stapelplatz reicht nicht"
MSG_DocTooLarge,,"Dokument zu gro"
MSG_InclTooLarge,,"Include-Datei zu gro"
;
;-------------------------------------------------------------------------
; End of runtime errors.  Messages beyond this point can be re-arranged
; in any order.
;-------------------------------------------------------------------------
;
;Section 2: QBI Parser Related Messages
;
MSG_IdTooLong,,"Identifikator zu lang"
MSG_BadId,,"Ungltiger Identifikator"
MSG_IdImp,,"Identifikator darf nicht mit %, &, !, # oder $ enden"
MSG_BadElemRef,,"Identifikator darf keinen Punkt enthalten"
MSG_ExpTooComplex,,"Ausdruck ist zu komplex"
MSG_IllegalNumber,,"Unzulssige Zahl"
MSG_InvConst,,"Ungltige Konstante"
MSG_expected,,"Erwartet: "
MSG_or,," oder "
;
; Parser errors which are preceded by "Expected: "
;
MSG_ExpAssignment,,"Variable=Ausdruck"
MSG_ExpExp,,"Ausdruck"
MSG_ExpVar,,"Variable"
MSG_ExpId,,"Identifikator"
MSG_ExpStatement,,"Anweisung"
MSG_ExpLabel,,"Marke"
MSG_ExpLn,,"Zeilennummer"
MSG_Letter,,"Buchstabe"
MSG_eos,,"Ende-der-Anweisung"
MSG_RightParen,,")"
MSG_ExpIdCallArg,,"Ausdruck"
MSG_ExpIdParm,,"Variable"
MSG_ExpFNId,,"Identifikator, der mit FN beginnt"
MSG_ExpIfClause,,"Marke oder Anweisung"
MSG_ExpLabLn,,"Marke oder Zeilennummer"
MSG_ExpLitString,,"String-Konstante"
MSG_ExpLit0,,"0"
MSG_ExpLit1,,"1"
MSG_ExpNArgs,,"[Ausdruck],..."
MSG_ExpRwB,,"B"
MSG_ExpRwF,,"F"
MSG_ExpRwBF,,"BF"
MSG_ExpRel,,"<, <=, >, >=, = oder <>"
;
;Section 3:  TextMgr/ReParse errors
;
MSG_InvModLev,,"Unzulssig auerhalb von SUB, FUNCTION oder DEF FN"
MSG_InvMain,,"Unzulssig auerhalb von SUB/FUNCTION"
MSG_InvProc,,"Unzulssig in Prozedur oder DEF FN"
MSG_InvBeforeProcDef,,"Keine Anweisung vor SUB/FUNCTION-Definition"
MSG_ProcNoEnd,,"SUB/FUNCTION ohne END SUB/FUNCTION"
MSG_EndNoProc,,"END SUB/FUNCTION ohne SUB/FUNCTION"
MSG_EndNoDef,,"END DEF ohne DEF"
MSG_UndElem,,"Element nicht definiert"
MSG_UndType,,"Typ nicht definiert"
MSG_1stStmt,,"Anweisung mu am Zeilenanfang stehen"
MSG_EndProc,,"END SUB oder END FUNCTION mu letzte Zeile sein"
MSG_NoEndType,,"TYPE ohne END TYPE"
MSG_NoType,,"END TYPE ohne TYPE"
MSG_InvInTypeBlk,,"Ungltige Anweisung im TYPE-Block"
MSG_InvIncl,,"Anweisung kann nicht in INCLUDE-Datei vorkommen"
MSG_InvDecl,,"DECLARE unzulssig fr Basic-Prozedur"
MSG_FNstart,,"'FN' am Beginn nicht mglich"
MSG_NotBlock,,"Operation erfordert Festplatte/Diskette"
MSG_BadMeta,,"Metabefehl-Fehler"
MSG_NoBpCase,,"Haltepunkte unzulssig in CASE-Klausel"
;
;Section 4:  Scan-time errors
;
MSG_OBA,,"Datenfeld bereits dimensioniert"
MSG_COM,,"COMMON und DECLARE mssen ausfhrbarer Anweisung vorangehen"
MSG_EWI,,"END IF ohne Block IF"
MSG_IWE,,"Block IF ohne END IF"
MSG_ElseWI,,"ELSE ohne IF"
MSG_ExitScope,,"EXIT FOR nicht in FOR...NEXT"
MSG_ExitDo,,"EXIT DO nicht in DO...LOOP"
MSG_Do,,"DO ohne LOOP"
MSG_Loop,,"LOOP ohne DO"
MSG_Select,,"SELECT ohne END SELECT"
MSG_Case,,"CASE ohne SELECT"
MSG_EndSelect,,"END SELECT ohne SELECT"
MSG_InvFixStr,,"Festlngen-String unzulssig"
MSG_InvTypedVar,,"Angegebene Variable in Ausdruck unzulssig"
MSG_DefNoEnd,,"DEF ohne END DEF"
MSG_ParmTM,,"Parametertyp pat nicht"
MSG_DupLibPrs,,"Prozedur ist bereits in Quick-Bibliothek definiert"
MSG_ASRqd1st,,"AS-Klausel bei erster Deklaration erforderlich"
MSG_ASRqd,,"AS-Klausel erforderlich"
MSG_ExpectedCase,,"Anweisungen/Marken unzulssig zwischen SELECT CASE und CASE"
MSG_NoNumArr,,"Numerisches Datenfeld unzulssig"
MSG_InType,,"Unzulssig auerhalb von TYPE-Block"
MSG_ULCom,,"COMMON in Quick-Bibliothek zu klein"
MSG_SubCnt,,"Falsche Dimensionsanzahl"
MSG_DefFnCtrl,,"DEF FN nicht erlaubt in Kontrollanweisungen"
MSG_Unsupported,,"Diese Funktion ist nicht verfgbar"
;
;Section 5.1: User Interface Related Messages that could be described in
;             user guide's error message appendix
;
MSG_CantCont,,"Programm mu nach dieser Editorsitzung neu gestartet werden. Fortsetzen?"
MSG_NoMainProg,,"Kein Hauptmodul. Whlen Sie 'Hauptmodul festlegen' aus Men 'Ausfhren'."
MSG_HelpOOM,,"Speicher reicht nicht zum Anzeigen von  Hilfe"
;
;Section 5.2: Messages that require special handling in ReportError()
;
;Note: The next 2 messages must have numbers < 256 for because they can be
;      passed to RtError_Ini by exStRunFile during command-line load.
;
MSG_DupMrs,,"Datei wurde gerade geladen"
MSG_DupPrs,,"Doppelter Prozedurname in der Datei"
MSG_MrsNotFound,,"Modul nicht gefunden. Modul aus Programm entfernen?"
;
;Section 5.3: General User Interface messages
;
MSG_Overwrite,,"Datei existiert bereits. berschreiben?"
MSG_DelProc,,"Prozedur aus Modul lschen?"
MSG_MakeRem,,"Leerzeilen vor SUB/FUNCTION-Zeile nicht erlaubt. Auskommentieren?"
MSG_NotSaved,,"Datei wurde seit dem letzten Speichern verndert. Jetzt speichern?"
MSG_NotSavedAll,,"Geladene Datei ist nicht gespeichert. Jetzt speichern?"
MSG_NotSavedInc,,"Vernderte INCLUDE-Dateien vor Ausfhrung speichern. Jetzt speichern?"
MSG_NotSavedIncSav,,"Vernderte INCLUDE-Dateien zuerst speichern?"
MSG_BadNextStmt,,"berschreiten der Prozedurgrenze nicht mglich"
MSG_Prt1,,"Warten auf Drucker"
MSG_Prt2,,"Datei wird gedruckt - drcken Sie ESC, um abzubrechen"
MSG_Immediate,,"Direkt"
MSG_Untitled,,"Unbenannt"
MSG_FALSE,,"<FALSCH>"
MSG_TRUE,,"<WAHR>"
MSG_Black,,"Schwarz"
MSG_Blue,,"Blau"
MSG_Green,,"Grn"
MSG_Cyan,,"Cyanblau"
MSG_Red,,"Rot"
MSG_Magenta,,"Magenta"
MSG_Brown,,"Braun"
MSG_White,,"Hellgrau"
MSG_Gray,,"Grau"
MSG_BrBlue,,"Hellblau"
MSG_BrGreen,,"Hellgrn"
MSG_BrCyan,,"Hellcyan"
MSG_BrRed,,"Hellrot"
MSG_Pink,,"Pink"
MSG_Yellow,,"Gelb"
MSG_BrWhite,,"Wei"
MSG_MustSpecifyName,,"Name mu angegeben werden"
MSG_DataMoved,,"DATA-Anweisungen wurden von SUB zu MODUL verschoben "
MSG_ModuleExists,,"Modul mit diesem Namen ist bereits geladen"
MSG_NoHelp,,"Datei "
MSG_NoHelp1,," nicht gefunden."
MSG_NoHelp2,,"Legen Sie eine Diskette mit dieser Datei ein oder ndern Sie"
MSG_NoHelp3,,"den Suchpfad der Hilfedatei in Men Optionen-Pfad fr Hilfe"
MSG_NoQHelp2,,"Whlen Sie OK. Stellen Sie sicher,"
MSG_NoQHelp3,,"da diese Datei in Ihrem PATH ist."
MSG_NoSearchString,,"Suchbegriff mu angegeben werden"
MSG_MatchNotFound,,"Suchbegriff nicht gefunden"
MSG_ChangeComplete,,"ndern beendet"
MSG_Is,," ist "
MSG_MainModule,,"das Hauptmodul"
MSG_Module,,"ein Modul"
MSG_IncludeFile,,"eine Include-Datei"
MSG_Document,,"ein Dokument"
MSG_Sub,,"eine SUB in "
MSG_Function,,"eine FUNCTION in "
MSG_ReqSub,,"Operation erfordert Auswahl einer SUB oder FUNCTION"
;If text of MSG_SwitchDisks changes, ref code in uifile.c must change as well.
MSG_SwitchDisks,,"Legen Sie Diskette in Laufwerk A: ein"
MSG_Loading,,"Laden und Analysieren"
MSG_Saving,,"Speichern"
MSG_Compiling,,"Binden"
MSG_Searching,,"Suchen - drcken Sie ESC, um abzubrechen"
MSG_CantSetTabs,,"Kann Tabulatorstopps nicht ndern, solange Datei geladen ist"
MSG_OutNearMem,,"Ungengender Datenspeicher"
MSG_ModTooLarge,,"Module-Level-Code zu gro"
MSG_ProcTooLarge,,"Prozedur zu gro"
MSG_ExitToRet,,CR,"Geben Sie EXIT ein, um zu QBasic zurckzukehren."
MSG_QeditText1,," Farben einstellen fr"
MSG_QeditText2,," Text-Editor-Fenster: "
MSG_NormalText,," Normaler Text     "
MSG_Breakpoint,," Haltepunkt Zeilen "
MSG_CurStmt,," Aktuelle Anweisung "
MSG_HelpTitle,,"HILFE: "
MSG_HelpTitleQH,,"MS-DOS-Hilfe: "
MSG_FirstContextStr,,"h.pg1"
MSG_HelpAboutEditor,,"MS-DOS-Editor"
MSG_HelpAboutQHelp,,"MS-DOS-Hilfe"
MSG_HelpAboutInterp,,"MS-DOS QBasic"
MSG_HelpAbout2,,"Version 1.1"
MSG_HelpAbout3,,"Copyright (C) Microsoft Corporation, 1987-1992."
;
;Section 5.4: HELP messages for menu items <THESE MUST REMAIN CONTIGUOUS>
;
;
;
;
;
;
MSG_HelpFileNew,,"Entfernt momentan geladene Datei aus Speicher"
MSG_HelpFileOpen,,"Ldt neue Datei in Speicher"
MSG_HelpFileMerge,,""
MSG_HelpFileSave,,"Speichert die aktuelle Datei"
MSG_HelpFileSaveAs,,"Speichert die aktuelle Datei unter dem angebenen Namen"
MSG_HelpFileSaveAll,,""
MSG_HelpFileCreate,,""
MSG_HelpFileLoad,,""
MSG_HelpFileUnload,,""
MSG_HelpFilePrint,,"Druckt angegebenen Text"
MSG_HelpFileShell,,""
MSG_HelpFileExit,,"Beendet Editor und kehrt zu MS-DOS zurck"
MSG_HelpFileExitQH,,"Beendet MS-DOS-Hilfe und kehrt zu MS-DOS zurck"
MSG_HelpEditUndo,,""
MSG_HelpEditCut,,"Lscht markierten Text und kopiert ihn in Zwischenspeicher"
MSG_HelpEditCopy,,"Kopiert markierten Text in Zwischenspeicher"
MSG_HelpEditClear,,"Lscht markierten Text, ohne ihn in Zwischenspeicher zu kopieren"
MSG_HelpEditPaste,,"Fgt Inhalt des Zwischenspeichers an aktueller Position ein"
MSG_HelpEditNewSub,,"ffnet ein Fenster fr neues Subprogramm"
MSG_HelpEditNewFunc,,"ffnet ein Fenster fr neue FUNCTION-Prozedur"
MSG_HelpViewSubs,,"Zeigt geladene SUB oder FUNCTION an"
MSG_HelpViewNextProc,,""
MSG_HelpViewSplit,,"Teilt Bilschirm in zwei Ansicht-Fenster auf"
MSG_HelpViewNextStatement,,""
MSG_HelpViewOutputScreen,,"Zeigt Ausgabebildschirm an"
MSG_HelpViewIncludes,,""
MSG_HelpViewEditIncl,,""
MSG_HelpSearchFind,,"Findet angegebenen Text"
MSG_HelpSearchSelected,,""
MSG_HelpSearchNext,,"Findet nchstes Vorkommen des im letzten Suchen angegebenen Texts"
MSG_HelpSearchChange,,"Findet und ndert angegebenen Text"
MSG_HelpSearchLabel,,""
MSG_HelpRunStart,,"Fhrt das aktuelle Programm aus"
MSG_HelpRunRestart,,"Beginnt Ausfhrung neu-lscht Variableninhalte"
MSG_HelpRunContinue,,"Setzt Ausfhrung nach Unterbrechung fort"
MSG_HelpRunSetCommand,,""
MSG_HelpRunMakeExe,,""
MSG_HelpRunMakeLib,,""
MSG_HelpRunSetMain,,""
MSG_HelpDebugStep,,"Fhrt nchste Programm-Anweisung aus"
MSG_HelpDebugPStep,,"Fhrt nchste Programm-Anweisung aus, verfolgt Prozeduraufrufe"
MSG_HelpDebugAddWatch,,""
MSG_HelpDebugInstantWatch,,""
MSG_HelpDebugWatchPoint,,""
MSG_HelpDebugDelWatch,,""
MSG_HelpDebugDelAllWatch,,""
MSG_HelpDebugTraceOn,,"Hebt die gerade ausgefhrte Anweisung hervor"
MSG_HelpDebugHistoryOn,,""
MSG_HelpDebugToggleBp,,"Setzt/lscht Haltepunkt an Cursorposition"
MSG_HelpDebugClearAllBp,,"Entfernt alle Haltepunkte"
MSG_HelpDebugBreakOnErr,,""
MSG_HelpDebugSetNextStmt,,"Fhrt die Anweisung an Cursorposition als nchste aus"
MSG_HelpOptionsDisplay,,"ndert die Anzeige-Attribute"
MSG_HelpOptionsPaths,,"Setzt Suchpfad fr Hilfe-Dateien"
MSG_HelpOptionsMouse,,""
MSG_HelpOptionsSyntax,,"Schaltet die Syntax-berprfung des Editors ein/aus."
MSG_HelpOptionsFullMenu,,""
MSG_HelpHelpIndex,,"Zeigt Index der Hilfe an"
MSG_HelpHelpContents,,"Zeigt Inhaltsverzeichnis der Hilfe an"
MSG_HelpHelpSyntax,,"Information ber Basic-Schlsselwort an Cursorposition"
MSG_HelpHelpHelp,,"Gibt Information zum Verwenden der Online-Hilfe"
MSG_HelpHelpStarted,,"Information zum Laden und Verwenden des MS-DOS-Editors"
MSG_HelpHelpKeyboard,,"Zeigt Tasten zum Bewegen in Text und Bearbeiten"
MSG_HelpHelpAbout,,"Zeigt Version und Copyright-Information des Produkts an"
MSG_HelpHowToUse,,"Gibt informationen zum Verwenden der MS-DOS-Hilfe"
;
;Section 5.5: Status line HELP messages <THESE MUST REMAIN CONTIGUOUS>
;
; IMPORTANT:  If the text of ANY of the following messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
; IMPORTANT:  See SIZES.TOK for a description of how to change the text of
; IMPORTANT:  MSG_Status[Edit, Running, Immediate, Help, ShiftF1].
;
MSG_StatusMenu,,"EINGB=Men anzeigen  ESC=Abbr  Pfeil=Nchster Menpunkt"
MSG_StatusDialog,,"EINGB=Ausfhren  ESC=Abbr  TAB=Nchstes Feld  Pfeil=Auswhlen"
MSG_StatusEdit,,"F6=Fenster  F2=SUBs  F5=Ausf  F8=Schritt"
MSG_StatusRunning,,"F5=Weiter  F9=Haltepunkt ein/aus  F8=Schritt"
MSG_StatusImmediate,,"F6=Fenster  EINGB=Befehl ausfhren"
MSG_StatusHelp,,"F6=Fenster  ESC=Abbr  STRG+F1=n.Thema  ALT+F1=Zurck"
MSG_StatusQEdit,,"MS-DOS-Editor   F1=Hilfe  ALT=Men aktivieren"
MSG_StatusQHelp,,"F1=Hilfe  F6=Fenster  ESC=Abbr  STRG+F1=n.Thema  ALT+F1=Zurck"
MSG_StatusQHStart,,"MS-DOS-Hilfe  F1=Hilfe  ALT=Men aktivieren"
;
;
MSG_StatusQHhelp,,"ALT+I=Inhalt  ALT+W=Weiter  ALT+Z=Zurck"
;
; LOCALIZATION - To change the accelerator chars in the above line, change the
;       the values in rgmpvkeyidQhelp[], in UIRSRCC.C (At about line #460).
;
;
MSG_StatusF1Help,,"F1=Hilfe  "
MSG_StatusShiftF1,,"UMSCH+F1=Hilfe  "
;
; IMPORTANT:  If the text of ANY of the previous messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
;
;Section 5.6: Variable HELP messages <Some of these must remain contiguous>
;Ripped these out for LQB
;
;Section 5.7: misc messages
;
MSG_SearchPathEdit,,"Datei EDIT.HLP befindet sich (Pfad):"
MSG_SearchPathHelp,,"Datei HELP.HLP befindet sich (Pfad):"
MSG_SearchPathInterp,,"Datei QBASIC.HLP befindet sich (Pfad):"
;
;Section touch: Messages can be added to the bottom of the file
; and all objects except uiutil.obj and qbimsgs.obj can be touched.
; Also touch qbimsgs.rpl, then *.hlp!
; Later, these messages should be moved into their appropriate sections.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbitn\strings\qbasmsgs.txt ===
; QBasic Standard Error Messages.
; This file is read by the tool makemsgs, which produces the files:
;      qbimsgs.asm, qbimsgs.inc, and qbimsgs.h
;
; Entries in this file have the form:
;  [<symbol's name>,[<msg index/error code>],"<ASCII msg>"] [;<comment>]
;
; If <msg index/error code> is not specified, the next available one
;    is assigned.
;
;Section 1:  Runtime Errors - symbol names are kept small to decrease
;            the size of the runtime library.
;            Names begin with ER_ to distinguish them from non-runtime
;            errors, which begin with MSG_.
;
ER_NF,1,"NEXT senza FOR"
ER_SN,2,"Errore di sintassi"
ER_RG,3,"RETURN senza GOSUB"
ER_OD,4,"Valori dell'istruzione DATA esauriti"
ER_FC,5,"Chiamata di funzione non valida"
ER_OV,6,"Overflow"
ER_OM,7,"Memoria esaurita"
ER_UL,8,"Etichetta non definita"
ER_SOR,9,"Indice inferiore fuori limite"
ER_DD,10,"Definizione doppia"
ER_DV0,11,"Divisione per zero"
ER_ID,12,"Non ammesso in modalit diretta"
ER_TM,13,"Tipo di dati non corrispondente"
ER_OS,14,"Spazio stringa esaurito"
;15 is unused
ER_BS,16,"Formula a stringa troppo complessa"
ER_CN,17,"Impossibile continuare"
ER_UF,18,"Funzione non definita"
ER_NR,19,"Manca RESUME"
ER_RE,20,"RESUME senza errore"
;21 is unused
;22 is unused
;23 is unused
ER_DTO,24,"Timeout sulla periferica"
ER_DF,25,"Errore sulla periferica"
ER_FN,26,"FOR senza NEXT"
ER_OP,27,"Carta esaurita"
;28 is unused
ER_WH,29,"WHILE senza WEND"
ER_WE,30,"WEND senza WHILE"
;31 is unused
;32 is unused
ER_DL,33,"Etichetta doppia"
;34 is unused
ER_US,35,"Sottoprogramma non definito"
;; ER_SIU,36,"Sottoprogramma gi in uso"  ;dead after recursion added
ER_AC,37,"Numero degli argomenti non corrispondente"
ER_UA,38,"Matrice non definita"
ER_CaseElse,39,"Era previsto CASE ELSE"
ER_VarReq,40,"E' necessaria una variabile"
;41 is unused
;42 is unused
;43 is unused
;44 is unused
;45 is unused
;46 is unused
;47 is unused
;48 is unused
;49 is unused
ER_FOV,50,"Overflow dell'istruzione FIELD"
ER_IER,51,"Errore interno"
ER_BFN,52,"Numero o nome del file errato"
ER_FNF,53,"File non trovato"
ER_BFM,54,"Modalit di accesso al file errata"
ER_FAO,55,"File gi aperto"
ER_FSA,56,"Istruzione FIELD attiva"
ER_IOE,57,"Errore di I/O sulla periferica"
ER_FAE,58,"Il file esiste gi"
ER_BRL,59,"Lunghezza del record errata"
;60 is unused
ER_DFL,61,"Disco pieno"
ER_RPE,62,"Input oltre la fine del file"
ER_BRN,63,"Numero del record errato"
ER_IFN,64,"Nome del file errato"
;65 is unused
;66 is unused   - used to be ER_FDR - Direct statement in file
ER_TMF,67,"Troppi file"
ER_DNA,68,"Periferica non disponibile"
ER_CBO,69,"Overflow del buffer comunicazioni"
ER_PRM,70,"Permesso negato"
ER_DNR,71,"Disco non pronto"
ER_DME,72,"Errore di supporto del disco"
ER_ADF,73,"Caratteristica avanzata non disponibile"
ER_RAD,74,"Tentativo di rinominare su altro disco"
ER_PAE,75,"Errore di accesso al percorso/file"
ER_PNF,76,"Percorso non trovato"
;;;ER_DLK,77,"Deadlock" ;not needed until OS/2 version
;
; The following ER_UE marks the last trappable Runtime Error Code
;
ER_UE,,"Errore non visualizzabile"
;
;=========================================================================
; Subsequent ER_ messages are special, and are intimately tied in with
; the runtime message file, messages.inc.
; Some of these errors are considered "very fatal", and cause termination;
; others are not errors at all - - we just supply the text for some runtime
; messages here.
; These messages must remain contiguous and in the same order, unless
; a matching change is made in messages.inc.
;
; UNDONE: validate that these are all still matching messages.inc strings
; UNDONE: prior to release
;
; First group of internal errors - - these are actually runtime messages,
; not errors
; Any message that begins ER_UL is used in constructing a message
; as follows:
;  Error in loading (file) - Internal error
;
ER_RFS,,"Ricominciare da capo"
ER_BFC,,"Byte liberi",CR         ;'CR' means terminate with a Carriage Return
ER_ULP,,"Impossibile trovare il file ("    ;preamble for user file path prompt
ER_ULT,,"). Percorso: "       ;postamble for user file path prompt
ER_ULE,,"Errore di installazione del file (" ;preamble for loader errors
ER_ULG,,") - "                  ;postamble for loader errors
ER_RNS,,"Seme numeri casuali (da -32768 a 32767)"
ER_HRS,,"Premere un tasto per continuare" ;Displayed when errors occurr in QBC exec.
;
; Second group of internal errors - these are "very fatal"
ER_SSC,,"Spazio stringa alterato"  ;string space or local heap trashed somehow
ER_ULD,,"Errore di I/O del disco"        ;problem in loading U.L. from disk
ER_ULI,,"Formato non valido"        ;attempt to load a U.L. with incorrect format
ER_ULF,,"Impossibile trovare il file"      ;redirected IO and cannot find file in path
;
; Third group of internal errors - these are also "very fatal"
ER_D21,,"E' richiesta la versione DOS 2.10 o superiore"
ER_INI,,"Errore durante l'inizializzazione di QBASIC" ;error in initializing runtime
ER_ULO,,"Memoria esaurita"         ;out of memory loading U.L.
ER_DMA,,"Errore dell'area di memoria di DOS" ;someone walked on DOS-owned memory
ER_FHC,,"Heap di tipo FAR alterato"      ;similar to string space corrupt
ER_ULM,,"Errore interno"        ;U.L. loading found a bad segment address
;
; QB-specific internal errors - these are "very fatal"
; NOTE: These must come after other internal errors (no equivalent in
;       messages.inc)
;
;Both groups of the command line help message must remain contiguous.
;They must start with the label ER_ISWEDIT/ER_ISWHELP/ER_ISWINTERP and end
;with the label ER_ISWEDITEND/ER_ISWHELPEND/ERISWINTERPEND.  The labels of the
;intermediate lines does not matter.
;
ER_ISWEDIT,,"Avvia MS-DOS Editor per creare e modificare i file ASCII."
ER_ISWEDIT1,," "
ER_ISWEDIT2,,"EDIT [[unit:][percorso]nomefile] [/B] [/G] [/H] [/NOHI]"
ER_ISWEDIT3,," "
ER_ISWEDIT4,," [unit:][percorso]nomefile  Specifica il file ASCII da modificare."
ER_ISWEDIT5,," /B    Consente l'uso di un monitor mono con una scheda grafica a colori."
ER_ISWEDIT6,," /G    Imposta la pi veloce modalit di aggiornamento per uno schermo CGA."
ER_ISWEDIT7,," /H    Visualizza il numero massimo di righe consentito dall'hardware."
ER_ISWEDITEND,," /NOHI Consente l'uso di un monitor sprovvisto di supporto per alta intensit."
;
ER_ISWQHELP,,"Avvia la Guida di MS-DOS sui comandi di MS-DOS."
ER_ISWQHELP1,," "
ER_ISWQHELP2,,"HELP [/B] [/G] [/H] [/NOHI] [argomento]"
ER_ISWQHELP3,," "
ER_ISWQHELP4,,"  /B          Consente l'uso di un monitor mono con una scheda a colori."
ER_ISWQHELP5,,"  /G          Modalit di aggiornamento veloce per uno schermo CGA."
ER_ISWQHELP6,,"  /H          Mostra il numero massimo di righe consentito dall'hardware."
ER_ISWQHELP7,,"  /NOHI       Consente l'uso di un monitor che non supporta l'alta intensit."
ER_ISWQHELPEND,,"  [argomento]  Specifica l'argomento della Guida da visualizzare."
;
;
ER_ISWINTERP,,"Avvia l'ambiente di programmazione QBASIC."
ER_ISWINTERP1,," "
ER_ISWINTERP2,,"QBASIC [/B] [/EDITOR] [/G] [/H] [/MBF] [/NOHI] [[/RUN] [unit:perc.]nomefile]"
ER_ISWINTERP3,," "
ER_ISWINTERP4,," /B       Consente l'uso di un monitor mono con una scheda grafica a colori."
ER_ISWINTERP5,," /EDITOR  Avvia MS-DOS Editor."
ER_ISWINTERP6,," /G       Imposta la pi veloce modalit di aggiornamento per uno schermo CGA."
ER_ISWINTERP7,," /H       Visualizza il numero massimo di righe consentito dall'hardware."
ER_ISWINTERP8,," /MBF     Converte le funzioni incorporate MKS$, MKD$, CVS e CVD"
ER_ISWINTERP9,,"          rispettivamente in MKSMBF$, MKDMBF$, CVSMBF e CVDMBF."
ER_ISWINTERPA,," /NOHI    Consente l'uso di un monitor sprovvisto di supporto per alta densit."
ER_ISWINTERPB,," /RUN     Esegue il programma Basic specificato prima di visualizzarlo."
ER_ISWINTERPEND,," [[unit:percorso]nomefile]  File di programma da caricare o eseguire."
;
;=========================================================================
;
;-------------------------------------------------------------------------
;MSG_GoDirect is non-trappable interpreter-specific
; error which allow us to back out of what we're doing and escape back
; to direct mode.
;
MSG_GoDirect,,""
MSG_OutOfStack,,"Spazio stack esaurito"
MSG_DocTooLarge,,"Documento troppo grande"
MSG_InclTooLarge,,"File INCLUDE troppo grande"
;
;-------------------------------------------------------------------------
; End of runtime errors.  Messages beyond this point can be re-arranged
; in any order.
;-------------------------------------------------------------------------
;
;Section 2: QBI Parser Related Messages
;
MSG_IdTooLong,,"Identificatore troppo lungo"
MSG_BadId,,"Identificatore non valido"
MSG_IdImp,,"Un identificatore non pu finire per %, &, !, #, o $"
MSG_BadElemRef,,"Un identificatore non pu includere un punto"
MSG_ExpTooComplex,,"Espressione troppo complessa"
MSG_IllegalNumber,,"Numero non ammesso"
MSG_InvConst,,"Costante non valida"
MSG_expected,,"Era atteso: "
MSG_or,," o "
;
; Parser errors which are preceded by "Expected: "
;
MSG_ExpAssignment,,"variabile=espressione"
MSG_ExpExp,,"espressione"
MSG_ExpVar,,"variabile"
MSG_ExpId,,"identificatore"
MSG_ExpStatement,,"istruzione"
MSG_ExpLabel,,"etichetta"
MSG_ExpLn,,"numero di riga"
MSG_Letter,,"lettera"
MSG_eos,,"fine istruzione"
MSG_RightParen,,")"
MSG_ExpIdCallArg,,"espressione"
MSG_ExpIdParm,,"variabile"
MSG_ExpFNId,,"identificatore che inizi con FN"
MSG_ExpIfClause,,"etichetta o istruzione"
MSG_ExpLabLn,,"numero di etichetta o di riga"
MSG_ExpLitString,,"costante di stringa"
MSG_ExpLit0,,"0"
MSG_ExpLit1,,"1"
MSG_ExpNArgs,,"[espressione],..."
MSG_ExpRwB,,"B"
MSG_ExpRwF,,"F"
MSG_ExpRwBF,,"BF"
MSG_ExpRel,,"<, <=, >, >=, =, o <>"
;
;Section 3:  TextMgr/ReParse errors
;
MSG_InvModLev,,"Istruzione ammessa solo all'interno di SUB, FUNCTION o DEF FN"
MSG_InvMain,,"Istruzione ammessa solo all'interno di SUB/FUNCTION"
MSG_InvProc,,"Istruzione non ammessa in una SUB, FUNCTION o DEF FN"
MSG_InvBeforeProcDef,,"L'istruzione non pu precedere le def. SUB/FUNCTION"
MSG_ProcNoEnd,,"SUB/FUNCTION senza END SUB/FUNCTION"
MSG_EndNoProc,,"END SUB/FUNCTION senza SUB/FUNCTION"
MSG_EndNoDef,,"END DEF senza DEF"
MSG_UndElem,,"Elemento non definito"
MSG_UndType,,"Tipo non definito"
MSG_1stStmt,,"L'istruzione deve essere la prima istruzione della riga"
MSG_EndProc,,"END SUB o END FUNCTION dev'essere l'ultima riga della finestra"
MSG_NoEndType,,"TYPE senza END TYPE"
MSG_NoType,,"END TYPE senza TYPE"
MSG_InvInTypeBlk,,"Istruzione non ammessa in un blocco TYPE"
MSG_InvIncl,,"L'istruzione non pu trovarsi entro un file INCLUDE"
MSG_InvDecl,,"Istruzione DECLARE non valida per le procedure Basic"
MSG_FNstart,,"Non pu iniziare per 'FN'"
MSG_NotBlock,,"L'operazione richiede un disco"
MSG_BadMeta,,"Errore di $metacomando"
MSG_NoBpCase,,"Punti di interruzione non consentiti in clausole CASE o END SELECT"
;
;Section 4:  Scan-time errors
;
MSG_OBA,,"Matrice gi dimensionata"
MSG_COM,,"COMMON e DECLARE devono precedere le istruzioni eseguibili"
MSG_EWI,,"END IF senza un blocco IF"
MSG_IWE,,"Blocco IF senza END IF"
MSG_ElseWI,,"ELSE senza IF"
MSG_ExitScope,,"EXIT esterno ad un ciclo FOR...NEXT"
MSG_ExitDo,,"EXIT DO esterno ad un ciclo DO...LOOP"
MSG_Do,,"DO senza LOOP"
MSG_Loop,,"LOOP senza DO"
MSG_Select,,"SELECT senza END SELECT"
MSG_Case,,"CASE senza SELECT"
MSG_EndSelect,,"END SELECT senza SELECT"
MSG_InvFixStr,,"Stringa a lunghezza fissa non ammessa"
MSG_InvTypedVar,,"La variabile digitata non  consentita nell'espressione"
MSG_DefNoEnd,,"DEF senza END DEF"
MSG_ParmTM,,"Tipo di parametro non corrispondente"
MSG_DupLibPrs,,"Procedura gi definita nella libreria Quick"
MSG_ASRqd1st,,"Clausola AS richiesta alla prima dichiarazione"
MSG_ASRqd,,"Clausola AS richiesta"
MSG_ExpectedCase,,"Istruzioni/etichette non ammesse tra SELECT CASE e CASE"
MSG_NoNumArr,,"Matrice numerica non ammessa"
MSG_InType,,"Istruzione ammessa solo entro un blocco TYPE"
MSG_ULCom,,"COMMON troppo piccolo nella libreria Quick"
MSG_SubCnt,,"Numero di dimensioni errato"
MSG_DefFnCtrl,,"DEF FN non ammessa nelle istruzioni di controllo"
MSG_Unsupported,,"Questa caratteristica non  disponibile"
;
;Section 5.1: User Interface Related Messages that could be described in
;             user guide's error message appendix
;
MSG_CantCont,,"Dopo questa modifica occorrer riavviare il programma. Continuare?"
MSG_NoMainProg,,"Manca un modulo principale. Sceglierne l'impostazione dal menu Esegui"
MSG_HelpOOM,,"Memoria insufficiente per la visualizzazione della Guida"
;
;Section 5.2: Messages that require special handling in ReportError()
;
;Note: The next 2 messages must have numbers < 256 for because they can be
;      passed to RtError_Ini by exStRunFile during command-line load.
;
MSG_DupMrs,,"File gi caricato"
MSG_DupPrs,,"Si  cercato di caricare un file con una definizione di procedura doppia"
MSG_MrsNotFound,,"Modulo non trovato. Eliminare il modulo dal programma?"
;
;Section 5.3: General User Interface messages
;
MSG_Overwrite,,"Il file esiste gi. Sostituire?"
MSG_DelProc,,"Conferma dell'annullamento della procedura"
MSG_MakeRem,,"Non sono ammesse righe vuote prima di una SUB/FUNCTION. E' un'annotazione?"
MSG_NotSaved,,"Il file  stato modificato. Salvare il file in memoria?"
MSG_NotSavedAll,,"Il file non  stato salvato. Salvare?"
MSG_NotSavedInc,,"Occorre salvare i file INCLUDE modificati prima di eseguirli. Salvarli?"
MSG_NotSavedIncSav,,"Salvare prima i file INCLUDE?"
MSG_BadNextStmt,,"Impossibile superare i limiti del modulo/della procedura"
MSG_Prt1,,"Attesa per la stampante"
MSG_Prt2,,"Stampa in corso - premere Esc per annullare"
MSG_Immediate,,"Immediato"
MSG_Untitled,,"Senza titolo"
MSG_FALSE,,"<FALSO>"
MSG_TRUE,,"<VERO>"
MSG_Black,,"Nero"
MSG_Blue,,"Blu"
MSG_Green,,"Verde"
MSG_Cyan,,"Celeste"
MSG_Red,,"Rosso"
MSG_Magenta,,"Magenta"
MSG_Brown,,"Marrone"
MSG_White,,"Grigio chiaro"
MSG_Gray,,"Grigio"
MSG_BrBlue,,"Blu chiaro"
MSG_BrGreen,,"Verde chiaro"
MSG_BrCyan,,"Azzurro"
MSG_BrRed,,"Rosso chiaro"
MSG_Pink,,"Rosa"
MSG_Yellow,,"Giallo"
MSG_BrWhite,,"Bianco"
MSG_MustSpecifyName,,"Occorre specificare un nome"
MSG_DataMoved,,"Le istruzioni DATA sono state spostate da SUB al livello modulo"
MSG_ModuleExists,,"Un modulo con lo stesso nome  gi stato caricato"
MSG_NoHelp,,"File "
MSG_NoHelp1,," non trovato."
MSG_NoHelp2,,"Inserire il disco floppy contenente il file nell'unit e Riprovare,"
MSG_NoHelp3,,"oppure cambiare il percorso della Guida in Opzioni+Percorso Guida."
MSG_NoQHelp2,,"Scegliere OK, e quindi accertarsi"
MSG_NoQHelp3,,"che il file sia nel vostro percorso."
MSG_NoSearchString,,"Manca la stringa da cercare"
MSG_MatchNotFound,,"Corrispondenza non trovata"
MSG_ChangeComplete,,"Sostituzione compiuta"
MSG_Is,,"  "
MSG_MainModule,,"il Modulo principale"
MSG_Module,,"un Modulo"
MSG_IncludeFile,,"un File INCLUDE"
MSG_Document,,"un Documento"
MSG_Sub,,"un'istruzione SUB in "
MSG_Function,,"un'istruzione FUNCTION in "
MSG_ReqSub,,"Questa operazione richiede la scelta di un'istruzione SUB o FUNCTION"
;If text of MSG_SwitchDisks changes, ref code in uifile.c must change as well.
MSG_SwitchDisks,,"Inserire un disco floppy nell'unit A:"
MSG_Loading,,"Installazione e analisi in corso"
MSG_Saving,,"Salvataggio in corso"
MSG_Compiling,,"Legatura"
MSG_Searching,,"Ricerca in corso - premere Esc per annullare"
MSG_CantSetTabs,,"Impossibile impostare le tabulazioni quando il file  gi stato caricato"
MSG_OutNearMem,,"Spazio dati esaurito"
MSG_ModTooLarge,,"Codice del modulo troppo esteso"
MSG_ProcTooLarge,,"Procedura troppo estesa"
MSG_ExitToRet,,CR,"Digitare EXIT per tornare a QBASIC"
MSG_QeditText1,," Impostazione dei colori per la"
MSG_QeditText2,," finestra dell'editor di testo:"
MSG_NormalText,," Testo normale        "
MSG_Breakpoint,," Righe punto interruz."
MSG_CurStmt,,   " Istruzione corrente  "
MSG_HelpTitle,,"GUIDA: "
MSG_HelpTitleQH,,"Guida di MS-DOS: "
MSG_FirstContextStr,,"h.pg1"
MSG_HelpAboutEditor,,"MS-DOS Editor"
MSG_HelpAboutQHelp,,"Guida di MS-DOS"
MSG_HelpAboutInterp,,"MS-DOS QBASIC"
MSG_HelpAbout2,,"Versione 1.1"
MSG_HelpAbout3,,"Copyright (C) Microsoft Corporation, 1987-1993."
;
;Section 5.4: HELP messages for menu items <THESE MUST REMAIN CONTIGUOUS>
;
MSG_HelpFileNew,,"Cancella il file corrente dalla memoria"
MSG_HelpFileOpen,,"Carica un nuovo file in memoria"
MSG_HelpFileMerge,,""
MSG_HelpFileSave,,"Salva il file corrente"
MSG_HelpFileSaveAs,,"Salva il file corrente con il nome specificato"
MSG_HelpFileSaveAll,,""
MSG_HelpFileCreate,,""
MSG_HelpFileLoad,,""
MSG_HelpFileUnload,,""
MSG_HelpFilePrint,,"Stampa il testo specificato"
MSG_HelpFileShell,,""
MSG_HelpFileExit,,"Esce dall'editor e ritorna a DOS"
MSG_HelpFileExitQH,,"Esce dalla Guida di MS-DOS Help e torna a DOS"
MSG_HelpEditUndo,,""
MSG_HelpEditCut,,"Elimina il testo selezionato e lo copia nel buffer"
MSG_HelpEditCopy,,"Copia il testo selezionato nel buffer"
MSG_HelpEditClear,,"Elimina il testo selezionato senza copiarlo nel buffer"
MSG_HelpEditPaste,,"Inserisce il contenuto del buffer nella posizione corrente"
MSG_HelpEditNewSub,,"Apre una finestra per un nuovo sottoprogramma"
MSG_HelpEditNewFunc,,"Apre una finestra per una nuova procedura FUNCTION"
MSG_HelpViewSubs,,"Visualizza un'istruzione SUB o FUNCTION caricata"
MSG_HelpViewNextProc,,""
MSG_HelpViewSplit,,"Divide lo schermo in due finestre di visualizzazione"
MSG_HelpViewNextStatement,,""
MSG_HelpViewOutputScreen,,"Visualizza lo schermo di output"
MSG_HelpViewIncludes,,""
MSG_HelpViewEditIncl,,""
MSG_HelpSearchFind,,"Trova il testo specificato"
MSG_HelpSearchSelected,,""
MSG_HelpSearchNext,,"Trova l'occorrenza successiva del testo specificato in precedenza"
MSG_HelpSearchChange,,"Trova e sostituisce il testo specificato"
MSG_HelpSearchLabel,,""
MSG_HelpRunStart,,"Esegue il programma corrente"
MSG_HelpRunRestart,,"Azzera le variabili prima di reiniziare l'esecuzione passo a passo"
MSG_HelpRunContinue,,"Riprende l'esecuzione dopo un'interruzione"
MSG_HelpRunSetCommand,,""
MSG_HelpRunMakeExe,,""
MSG_HelpRunMakeLib,,""
MSG_HelpRunSetMain,,""
MSG_HelpDebugStep,,"Esegue l'istruzione successiva del programma"
MSG_HelpDebugPStep,,"Esegue l'istruzione successiva o le procedure intere"
MSG_HelpDebugAddWatch,,""
MSG_HelpDebugInstantWatch,,""
MSG_HelpDebugWatchPoint,,""
MSG_HelpDebugDelWatch,,""
MSG_HelpDebugDelAllWatch,,""
MSG_HelpDebugTraceOn,,"Evidenzia l'istruzione correntemente in esecuzione"
MSG_HelpDebugHistoryOn,,""
MSG_HelpDebugToggleBp,,"Imposta/rimuove il punto di interruzione alla posizione del cursore"
MSG_HelpDebugClearAllBp,,"Rimuove tutti i punti di interruzione"
MSG_HelpDebugBreakOnErr,,""
MSG_HelpDebugSetNextStmt,,"Indica che l'istruzione successiva  quella indicata dal cursore"
MSG_HelpOptionsDisplay,,"Cambia gli attributi dello schermo"
MSG_HelpOptionsPaths,,"Imposta il percorso di ricerca per i file della Guida"
MSG_HelpOptionsMouse,,""
MSG_HelpOptionsSyntax,,"Attiva e disattiva il controllo della sintassi dell'editor"
MSG_HelpOptionsFullMenu,,""
MSG_HelpHelpIndex,,"Visualizza l'indice della guida"
MSG_HelpHelpContents,,"Visualizza il sommario della guida"
MSG_HelpHelpSyntax,,"Visualizza informazioni sulla parola chiave indicata dal cursore"
MSG_HelpHelpHelp,,"Visualizza delle informazioni su come usare la Guida in linea"
MSG_HelpHelpStarted,,"Visualizza informazioni sull'installazione e l'uso di MS-DOS Editor"
MSG_HelpHelpKeyboard,,"Visualizza i tasti di movimento e modifica all'interno di un testo"
MSG_HelpHelpAbout,,"Visualizza la versione del prodotto e le informazioni sul copyright"
MSG_HelpHowToUse,,"Visualizza le informazioni sull'uso della Guida di MS-DOS"
;
;Section 5.5: Status line HELP messages <THESE MUST REMAIN CONTIGUOUS>
;
; IMPORTANT:  If the text of ANY of the following messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
; IMPORTANT:  See UINHELP.ASM for a description of how to change the text of
; IMPORTANT:  MSG_Status[Edit, Running, Immediate, Help, ShiftF1].
;
MSG_StatusMenu,,"Invio=Visualizza menu   Esc=Annulla   Freccia=Voce seg."
MSG_StatusDialog,,"Invio=Esegui   Esc=Annulla   Tab=Campo seg.    Freccia=Voce seg."
MSG_StatusEdit,,"<F6=Finestra><F2=Subs><F5=Esegui><F8=Passo>"
MSG_StatusRunning,,"<F5=Continua><F9=Punto inter.><F8=Passo>"
MSG_StatusImmediate,,"<F6=Finestra><Invio=Esegui riga>"
MSG_StatusHelp,,"<F6=Finestra><Esc=Annulla><Ctrl+F1=Seg.><Alt+F1=Prec.>"
MSG_StatusQEdit,,"MS-DOS Editor  <F1=?> Premere ALT per attivare i menu"
MSG_StatusQHelp,,"<F1=?> <F6=Finestra> <Esc=Annulla> <Ctrl+F1=Seg.> <Alt+F1=Prec.>"
MSG_StatusQHStart,,"Guida di MS-DOS      <F1=?> Premere ALT per attivare i menu"
;
;
MSG_StatusQHhelp,,"<Alt+S=Sommario> <Alt+A=Avanti> <Alt+I=Indietro>"
;
; LOCALIZATION - To change the accelerator chars in the above line, change the
;       the values in rgmpvkeyidQhelp[], in UIRSRCC.C (At about line #460).
;
;
MSG_StatusF1Help,,"F1=?   "
MSG_StatusShiftF1,,"<Maiusc+F1=?>"
;
; IMPORTANT:  If the text of ANY of the previous messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
;
;Section 5.6: Variable HELP messages <Some of these must remain contiguous>
;Ripped these out for LQB
;
;Section 5.7: misc messages
;
MSG_SearchPathEdit,,"Percorso del file EDIT.HLP:"
MSG_SearchPathHelp,,"Percorso del file HELP.HLP:"
MSG_SearchPathInterp,,"Percorso del file QBASIC.HLP:"
;
;Section touch: Messages can be added to the bottom of the file
; and all objects except uiutil.obj and qbimsgs.obj can be touched.
; Also touch qbimsgs.rpl, then *.hlp!
; Later, these messages should be moved into their appropriate sections.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbkit\files\holder.txt ===
This is just a placeholder to save the directory until
the files get copied in during the build.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbkit\build\readme.txt ===
Notes on Building the Help Files for QBASIC and EDIT.

This build is set up for OS2.

To build microsoft version help files go into qbkit\build and type
build.  To build IBM versions, you must first build the microsoft
versions and then go to qbkit\build and type makeibm.
The output files for the microsoft version are QBASIC.HLP and EDIT.HLP,
for IBM version they are called IBMQB.HLP and IBMEDIT.HLP

The build is set up to expect the following directory structure




QBKIT
	FILES - the files for QBlang are copied in here for the build.
		no files are enlisted in this directory.
		You can delete it after a build if you wish.

	BUILD - Contains the files needed to build the help files.
		The most important ones are BUILD.CMD, MAKEIBM.CMD and
		GOODBLD.CMD.
		BUILD.CMD will produce ordinary help files.
		MAKEIBM.CMD will produce IBM versions of help files.
		GOODBLD.CMD is used to check in the files when the
		build was successful.

	BLD -	The build help files will be copied to this directory.
		It would be a good idea to keep copies of QBASIC.EXE 
		and EDIT.COM in this directory to test the files.

QBusa		The language files.  The files will be copied from here
		into QBKIT\FILES when the help files are being built.
		The directory HELPBLD is where the latest help files for
		the language will be maintained on SLM.
	
QBswe, QBdut, QBitn, QBfrn, QBger - These are the translated versions of
QBusa.  Remember that the STRINGS subdirectory within these directories
is for the EXE files and that all other files are for help alone.

You should enlist in the QBUSA and QBKIT directories.

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbkit\bld\holder.txt ===
This is just a placeholder to save the directory until
the files get copied in during the build.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbpor\strings\qbasmsgs.txt ===
; QBasic Standard Error Messages.
; This file is read by the tool makemsgs, which produces the files:
;      qbimsgs.asm, qbimsgs.inc, and qbimsgs.h
;
; Entries in this file have the form:
;  [<symbol's name>,[<msg index/error code>],"<ASCII msg>"] [;<comment>]
;
; If <msg index/error code> is not specified, the next available one
;    is assigned.
;
;Section 1:  Runtime Errors - symbol names are kept small to decrease
;            the size of the runtime library.
;            Names begin with ER_ to distinguish them from non-runtime
;            errors, which begin with MSG_.
;
ER_NF,1,"Instruao NEXT sem instruao FOR"
ER_SN,2,"Erro de sintaxe"
ER_RG,3,"Instruao RETURN sem instruao GOSUB"
ER_OD,4,"Nao h mais instruao DATA"
ER_FC,5,"Chamada de funao invlida "
ER_OV,6,"Estouro de divisao"
ER_OM,7,"Memria insuficiente"
ER_UL,8,"Nome nao definido"
ER_SOR,9,"Indice fora do intervalo"
ER_DD,10,"Definiao duplicada"
ER_DV0,11,"Divisao por zero"
ER_ID,12,"Invlido no modo direto"
ER_TM,13,"Tipo incompatvel"
ER_OS,14,"Espao insuficiente para a sequncia"
;15 is unused
ER_BS,16,"Frmula da sequncia muito grande"
ER_CN,17,"Nao  possvel continuar"
ER_UF,18,"Funao QBasic nao definida"
ER_NR,19,"Falta a instruao RESUME"
ER_RE,20,"Instruao RESUME sem erro"
;21 is unused
;22 is unused
;23 is unused
ER_DTO,24,"Tempo de espera do dispositivo"
ER_DF,25,"Falha no dispositivo"
ER_FN,26,"Instruao FOR sem instruao NEXT"
ER_OP,27,"Falta papel na impressora"
;28 is unused
ER_WH,29,"Instruao WHILE sem instruao WEND"
ER_WE,30,"Instruao WEND sem instruao WHILE"
;31 is unused
;32 is unused
ER_DL,33,"Nome duplicado"
;34 is unused
ER_US,35,"Subprograma QBasic nao definido"
;; ER_SIU,36,"Subprograma j est em uso"	;dead after recursion added
ER_AC,37,"Contador de parmetros incompatvel"
ER_UA,38,"Matriz nao definida"
ER_CaseElse,39,"CASE ELSE esperado"
ER_VarReq,40,"Varivel requerida"
;41 is unused
;42 is unused
;43 is unused
;44 is unused
;45 is unused
;46 is unused
;47 is unused
;48 is unused
;49 is unused
ER_FOV,50,"Estouro de divisao em FIELD"
ER_IER,51,"Erro interno"
ER_BFN,52,"Nome ou nmero de arquivo invlido"
ER_FNF,53,"Arquivo nao encontrado"
ER_BFM,54,"Modo de arquivo invlido"
ER_FAO,55,"Arquivo j foi aberto"
ER_FSA,56,"Instruao FIELD ativa"
ER_IOE,57,"Erro no dispositivo de E/S"
ER_FAE,58,"Arquivo j existente"
ER_BRL,59,"Tamanho de registro invlido"
;60 is unused
ER_DFL,61,"Disco est cheio"
ER_RPE,62,"Instruao Input ultrapassou fim de arquivo"
ER_BRN,63,"Nmero de registro invlido"
ER_IFN,64,"Nome de arquivo invlido"
;65 is unused
;66 is unused	- used to be ER_FDR - Direct statement in file
ER_TMF,67,"Excesso de arquivos"
ER_DNA,68,"Dispositivo nao disponvel"
ER_CBO,69,"Estouro na memria intermediria"
ER_PRM,70,"Acesso nao permitido"
ER_DNR,71,"Disco nao est preparado"
ER_DME,72,"Erro no disco"
ER_ADF,73,"Funao nao disponvel"
ER_RAD,74,"Renomear entre discos"
ER_PAE,75,"Erro de acesso ao arquivo/caminho"
ER_PNF,76,"Caminho do QBasic nao encontrado"
;;;ER_DLK,77,"Conflito" ;not needed until OS/2 version
;
; The following ER_UE marks the last trappable Runtime Error Code
;
ER_UE,,"Erro que nao pode ser impresso"
;
;=========================================================================
; Subsequent ER_ messages are special, and are intimately tied in with
; the runtime message file, messages.inc.
; Some of these errors are considered "very fatal", and cause termination;
; others are not errors at all - - we just supply the text for some runtime
; messages here.
; These messages must remain contiguous and in the same order, unless
; a matching change is made in messages.inc.
;
; UNDONE: validate that these are all still matching messages.inc strings
; UNDONE: prior to release
;
; First group of internal errors - - these are actually runtime messages,
; not errors
; Any message that begins ER_UL is used in constructing a message
; as follows:
;  Error in loading (file) - Internal error
;
ER_RFS,,"Refazer do incio"
ER_BFC,,"Bytes livres",CR		;'CR' means terminate with a Carriage Return
ER_ULP,,"Nao  possvel encontrar o arquivo ("	;preamble for user file path prompt
ER_ULT,,"). Caminho de entrada: "	;postamble for user file path prompt
ER_ULE,,"Erro ao carregar o arquivo (" ;preamble for loader errors
ER_ULG,,") - "			;postamble for loader errors
ER_RNS,,"Nmero aleatrio (-32768 a 32767)"
ER_HRS,,"Pressione qualquer tecla para continuar" ;Displayed when errors occurr in QBC exec.
;
; Second group of internal errors - these are "very fatal"
ER_SSC,,"Espao de texto danificado"  ;string space or local heap trashed somehow
ER_ULD,,"Erro no disco de E/S"     ;problem in loading U.L. from disk
ER_ULI,,"Formato invlido"	;attempt to load a U.L. with incorrect format
ER_ULF,,"Nao  possvel encontrar o arquivo"	;redirected IO and cannot find file in path
;
; Third group of internal errors - these are also "very fatal"
ER_D21,,"Requer DOS 2.10 ou posterior"
ER_INI,,"Erro durante a inicializaao do QBasic" ;error in initializing runtime
ER_ULO,,"Sem memria"		;out of memory loading U.L.
ER_DMA,,"Erro na rea de memria do DOS" ;someone walked on DOS-owned memory
ER_FHC,,"Espao danificado"      ;similar to string space corrupt
ER_ULM,,"Erro interno"	;U.L. loading found a bad segment address
;
; QB-specific internal errors - these are "very fatal"
; NOTE: These must come after other internal errors (no equivalent in
;	messages.inc)
;
;Both groups of the command line help message must remain contiguous.
;They must start with the label ER_ISWEDIT/ER_ISWINTERP and end
;with the label ER_ISWEDITEND/ERISWINTERPEND.  The labels of the
;intermediate lines does not matter.
;
ER_ISWEDIT,,"Inicia o Editor do MS-DOS, o qual cria e altera arquivos ASCII."
ER_ISWEDIT1,," "
ER_ISWEDIT2,,"EDIT [[unidade:][caminho]nome-de-arquivo] [/B] [/G] [/H] [/NOHI]"
ER_ISWEDIT3,," "
ER_ISWEDIT4,,"  [unidade:][caminho]nome-de-arquivo  Define o arquivo ASCII a ser editado."
ER_ISWEDIT5,,"  /B       Usa um monitor monocromtico com placa grfica colorida."
ER_ISWEDIT6,,"  /G       Fornece a atualizaao mais rpida de uma tela CGA."
ER_ISWEDIT7,,"  /H       Exibe o nmero mximo de linhas possvel para o seu hardware."
ER_ISWEDITEND,,"  /NOHI    Permite usar um monitor sem suporte de alta intensidade."
;
ER_ISWINTERP,,"Inicia o ambiente de programaao MS-DOS QBasic."
ER_ISWINTERP1,," "
ER_ISWINTERP2,,"QBASIC [/B] [/EDITOR] [/G] [/H] [/MBF] [/NOHI] [[/RUN]"
ER_ISWINTERP3,,"       [unidade:][caminho]nome-de-arquivo]"
ER_ISWINTERP4,," "
ER_ISWINTERP5,," /B         Usa um monitor monocromtico com placa grfica colorida."
ER_ISWINTERP6,," /EDITOR    Inicia o Editor do MS-DOS."
ER_ISWINTERP7,," /G         Fornece a atualizaao mais rpida de uma tela CGA."
ER_ISWINTERP8,," /H         Exibe o nmero mximo de linhas para o seu hardware."
ER_ISWINTERP9,," /MBF       Converte as funoes embutidas MKS$, MKD$, CVS e CVD para"
ER_ISWINTERPA,,"            MKSMBF$, MKDMBF$, CVSMBF, and CVDMBF, respectivamente."
ER_ISWINTERPB,," /NOHI      Permite o uso de um monitor sem suporte de alta densidade."
ER_ISWINTERPC,," /RUN       Executa o programa Basic especificado antes de exib-lo."
ER_ISWINTERPEND,,"  [[unidade:][caminho]nome-de-arquivo] Arquivo a ser carregado/executado."
;
;=========================================================================
;
;-------------------------------------------------------------------------
;MSG_GoDirect is non-trappable interpreter-specific
; error which allow us to back out of what we're doing and escape back
; to direct mode.
;
MSG_GoDirect,,""
MSG_OutOfStack,,"Falta de espao para chamadas"
MSG_DocTooLarge,,"Documento muito extenso"
MSG_InclTooLarge,,"Arquivo muito extenso"
;
;-------------------------------------------------------------------------
; End of runtime errors.  Messages beyond this point can be re-arranged
; in any order.
;-------------------------------------------------------------------------
;
;Section 2: QBI Parser Related Messages
;
MSG_IdTooLong,,"Identificador muito grande"
MSG_BadId,,"Identificador invlido"
MSG_IdImp,,"O identificador nao pode terminar com %, &, !, # ou $"
MSG_BadElemRef,,"O identificador nao pode conter um ponto"
MSG_ExpTooComplex,,"Expressao muito grande"
MSG_IllegalNumber,,"Nmero invlido"
MSG_InvConst,,"Constante invlida"
MSG_expected,,"Esperado: "
MSG_or,," ou "
;
; Parser errors which are preceded by "Expected: "
;
MSG_ExpAssignment,,"varivel=expressao"
MSG_ExpExp,,"expressao"
MSG_ExpVar,,"varivel"
MSG_ExpId,,"identificador"
MSG_ExpStatement,,"instruao"
MSG_ExpLabel,,"nome"
MSG_ExpLn,,"nmero da linha"
MSG_Letter,,"carta"
MSG_eos,,"fim-de-instruao"
MSG_RightParen,,")"
MSG_ExpIdCallArg,,"expressao"
MSG_ExpIdParm,,"varivel"
MSG_ExpFNId,,"identificador que comea por FN"
MSG_ExpIfClause,,"nome ou instruao"
MSG_ExpLabLn,,"nome ou nmero da linha"
MSG_ExpLitString,,"constante de sequncia"
MSG_ExpLit0,,"0"
MSG_ExpLit1,,"1"
MSG_ExpNArgs,,"[expressao],..."
MSG_ExpRwB,,"B"
MSG_ExpRwF,,"F"
MSG_ExpRwBF,,"BF"
MSG_ExpRel,,"<, <=, >, >=, = ou <>"
;
;Section 3:  TextMgr/ReParse errors
;
MSG_InvModLev,,"Invlido fora de SUB, FUNCTION ou DEF FN"
MSG_InvMain,,"Invlido fora de SUB/FUNCTION"
MSG_InvProc,,"Invlido no procedimento ou DEF FN"
MSG_InvBeforeProcDef,,"Instruao nao pode preceder a definiao SUB/FUNCTION"
MSG_ProcNoEnd,,"SUB/FUNCTION sem END SUB/FUNCTION"
MSG_EndNoProc,,"END SUB/FUNCTION sem SUB/FUNCTION"
MSG_EndNoDef,,"END DEF sem DEF"
MSG_UndElem,,"Elemento nao definido"
MSG_UndType,,"Tipo nao definido"
MSG_1stStmt,,"Deve ser a primeira instruao na linha"
MSG_EndProc,,"END SUB ou END FUNCTION deve estar na ltima linha"
MSG_NoEndType,,"TYPE sem END TYPE"
MSG_NoType,,"END TYPE sem TYPE"
MSG_InvInTypeBlk,,"Instruao invlida no bloco TYPE"
MSG_InvIncl,,"A instruao nao pode ocorrer dentro do arquivo INCLUDE"
MSG_InvDecl,,"DECLARE invlido para o procedimento Basic"
MSG_FNstart,,"Nao  possvel comear por 'FN'"
MSG_NotBlock,,"Operaao requer disco"
MSG_BadMeta,,"Erro no $Metacomando"
MSG_NoBpCase,,"Ponto de interrupao nao permitido na clusula CASE ou END SELECT"
;
;Section 4:  Scan-time errors
;
MSG_OBA,,"Matriz j foi dimensionada"
MSG_COM,,"COMMON e DECLARE devem preceder instruoes executveis"
MSG_EWI,,"END IF sem block IF"
MSG_IWE,,"Block IF sem END IF"
MSG_ElseWI,,"ELSE sem IF"
MSG_ExitScope,,"EXIT fora de FOR...NEXT"
MSG_ExitDo,,"EXIT DO fora de DO...LOOP"
MSG_Do,,"DO sem LOOP"
MSG_Loop,,"LOOP sem DO"
MSG_Select,,"SELECT sem END SELECT"
MSG_Case,,"CASE sem SELECT"
MSG_EndSelect,,"END SELECT sem SELECT"
MSG_InvFixStr,,"Sequncia de tamanho fixo invlida"
MSG_InvTypedVar,,"Varivel digitada nao permitida na expressao"
MSG_DefNoEnd,,"DEF sem END DEF"
MSG_ParmTM,,"Tipo de parmetro incompatvel"
MSG_DupLibPrs,,"Procedimento j definido em Quick library"
MSG_ASRqd1st,,"Clusula AS requerida na primeira declaraao"
MSG_ASRqd,,"Clusula AS requerida"
MSG_ExpectedCase,,"Instruoes/nomes invlidos entre SELECT CASE e CASE"
MSG_NoNumArr,,"Matriz numrica invlida"
MSG_InType,,"Invlido fora do bloco TYPE"
MSG_ULCom,,"COMMON na biblioteca do Quick muito pequeno"
MSG_SubCnt,,"Nmero invlido de dimensoes"
MSG_DefFnCtrl,,"DEF FN nao  permitido em instruoes de controle"
MSG_Unsupported,,"Esta caracterstica nao est disponvel"
;
;Section 5.1: User Interface Related Messages that could be described in
;	      user guide's error message appendix
;
MSG_CantCont,,"Voc ter que reinicializar seu programa aps esta ediao. Continuar?"
MSG_NoMainProg,,"Sem mdulo principal. Selecione em Definir Mdulo Principal no menu Executar"
MSG_HelpOOM,,"Memria insuficiente para exibir o Socorro"
;
;Section 5.2: Messages that require special handling in ReportError()
;
;Note: The next 2 messages must have numbers < 256 for because they can be
;      passed to RtError_Ini by exStRunFile during command-line load.
;
MSG_DupMrs,,"Arquivo carregado anteriormente"
MSG_DupPrs,,"Tentativa de carregar arquivo com definiao de procedimento duplicada"
MSG_MrsNotFound,,"Mdulo nao encontrado. Descarregar mdulo a partir do programa?"
;
;Section 5.3: General User Interface messages
;
MSG_Overwrite,,"Arquivo j existente. Sobregravar?"
MSG_DelProc,,"Excluir procedimentos do mdulo?"
MSG_MakeRem,,"Nao permitido linhas em branco antes da linha SUB/FUNCTION. Comentrios OK?"
MSG_NotSaved,,"O arquivo foi modificado desde a ltima gravaao. Salvar agora?"
MSG_NotSavedAll,,"Arquivo carregado nao est salvo. Salvar agora?"
MSG_NotSavedInc,,"Arquivos INCLUDE modificados devem ser salvos antes da execuao. Salvar?"
MSG_NotSavedIncSav,,"Salvar arquivos INCLUDE modificados primeiramente?"
MSG_BadNextStmt,,"Nao  possvel ultrapassar limites de procedimento/mdulo"
MSG_Prt1,,"Esperando pela impressora"
MSG_Prt2,,"Imprimindo - pressione Esc para cancelar"
MSG_Immediate,,"Imediato"
MSG_Untitled,,"Sem Ttulo"
MSG_FALSE,,"<FALSE>"
MSG_TRUE,,"<TRUE>"
MSG_Black,,"Preto"
MSG_Blue,,"Azul"
MSG_Green,,"Verde"
MSG_Cyan,,"Ciano"
MSG_Red,,"Vermelho"
MSG_Magenta,,"Magenta"
MSG_Brown,,"Marrom"
MSG_White,,"Branco"
MSG_Gray,,"Cinza"
MSG_BrBlue,,"Azul lum"
MSG_BrGreen,,"Verde lum"
MSG_BrCyan,,"Ciano lum"
MSG_BrRed,,"Vermelho lum"
MSG_Pink,,"Rosa"
MSG_Yellow,,"Amarelo"
MSG_BrWhite,,"Branco lum"
MSG_MustSpecifyName,,"Especifique o nome"
MSG_DataMoved,,"Definioes DATA foram tranferidas de SUB para o nvel de mdulo"
MSG_ModuleExists,,"O mdulo com aquele nome j est carregado"
MSG_NoHelp,,"Arquivo "
MSG_NoHelp1,," nao encontrado."
MSG_NoHelp2,,"Coloque o disquete contendo este arquivo na unidade e"
MSG_NoHelp3,,"Repita, ou altere o caminho do Socorro no caminho Opoes+Socorro."
MSG_NoSearchString,,"Deve ser especificado o texto para pesquisa"
MSG_MatchNotFound,,"Ocorrncia nao encontrada"
MSG_ChangeComplete,,"Alteraao concluda"
MSG_Is,,"  "
MSG_MainModule,,"o Mdulo Principal"
MSG_Module,,"um Mdulo"
MSG_IncludeFile,,"um arquivo Include"
MSG_Document,,"um Documento"
MSG_Sub,,"um SUB em "
MSG_Function,,"um FUNCTION em "
MSG_ReqSub,,"Operaao exige seleao de um SUB ou FUNCTION"
;If text of MSG_SwitchDisks changes, ref code in uifile.c must change as well.
MSG_SwitchDisks,,"Insira disquete na unidade A:"
MSG_Loading,,"Carregando e analisando"
MSG_Saving,,"Salvando"
MSG_Compiling,,"Conectando"
MSG_Searching,,"Procurando - pressione Esc para cancelar"
MSG_CantSetTabs,,"Nao  possvel alterar paradas de tabulaao em arquivo carregado"
MSG_OutNearMem,,"Sem espao de dados"
MSG_ModTooLarge,,"Cdigo de nvel de mdulo muito extenso"
MSG_ProcTooLarge,,"Procedimento muito extenso"
MSG_ExitToRet,,CR,"Digite EXIT para retornar ao QBasic"
MSG_QeditText1,," Definir as cores para a"
MSG_QeditText2,," janela do editor:      "
MSG_NormalText,," Texto Normal           "
MSG_Breakpoint,," Linha de Interrupao   "
MSG_CurStmt,," Instruao atual "
MSG_HelpTitle,,"SOCORRO: "
MSG_FirstContextStr,,"h.pg1"
MSG_HelpAboutEditor,,"Editor do MS-DOS"
MSG_HelpAboutInterp,,"MS-DOS QBasic"
MSG_HelpAbout2,,"Versao 1.0"
MSG_HelpAbout3,,"Copyright (C) Microsoft Corporation, 1987-1991."
;
;Section 5.4: HELP messages for menu items <THESE MUST REMAIN CONTIGUOUS>
;
MSG_HelpFileNew,,"Retirar arquivo atualmente carregado da memria"
MSG_HelpFileOpen,,"Carrega o arquivo novo na memria"
MSG_HelpFileMerge,,""
MSG_HelpFileSave,,"Grava o arquivo atual"
MSG_HelpFileSaveAs,,"Grava o arquivo atual com o nome especificado"
MSG_HelpFileSaveAll,,""
MSG_HelpFileCreate,,""
MSG_HelpFileLoad,,""
MSG_HelpFileUnload,,""
MSG_HelpFilePrint,,"Imprime o texto especificado"
MSG_HelpFileShell,,""
MSG_HelpFileExit,,"Sai do editor e retorna ao DOS"
MSG_HelpEditUndo,,""
MSG_HelpEditCut,,"Exclui o texto selecionado e copia na memria intermediria"
MSG_HelpEditCopy,,"Copia o texto selecionado para a memria intermediria"
MSG_HelpEditClear,,"Exclui o texto selecionado sem copi-lo na memria intermediria"
MSG_HelpEditPaste,,"Inserir contedo da memria intermediria na posiao atual"
MSG_HelpEditNewSub,,"Abre uma janela para um novo subprograma"
MSG_HelpEditNewFunc,,"Abre uma janela para um novo procedimento FUNCTION"
MSG_HelpViewSubs,,"Exibe uma SUB ou FUNCTION carregada"
MSG_HelpViewNextProc,,""
MSG_HelpViewSplit,,"Divide a tela em duas janelas de visualizaao"
MSG_HelpViewNextStatement,,""
MSG_HelpViewOutputScreen,,"Exibe a tela de sada"
MSG_HelpViewIncludes,,""
MSG_HelpViewEditIncl,,""
MSG_HelpSearchFind,,"Procura o texto especificado"
MSG_HelpSearchSelected,,""
MSG_HelpSearchNext,,"Localiza a prxima ocorrncia do texto pesquisado"
MSG_HelpSearchChange,,"Localiza e altera o texto especificado"
MSG_HelpSearchLabel,,""
MSG_HelpRunStart,,"Executa o programa atual"
MSG_HelpRunRestart,,"Limpa variveis na preparaao para reiniciar em um nico passo"
MSG_HelpRunContinue,,"Continua a execuao aps uma interrupao"
MSG_HelpRunSetCommand,,""
MSG_HelpRunMakeExe,,""
MSG_HelpRunMakeLib,,""
MSG_HelpRunSetMain,,""
MSG_HelpDebugStep,,"Executa a prxima instruao de programa"
MSG_HelpDebugPStep,,"Executa a prxima instruao, seguindo chamadas de procedimentos"
MSG_HelpDebugAddWatch,,""
MSG_HelpDebugInstantWatch,,""
MSG_HelpDebugWatchPoint,,""
MSG_HelpDebugDelWatch,,""
MSG_HelpDebugDelAllWatch,,""
MSG_HelpDebugTraceOn,,"Comandos realados atualmente executados"
MSG_HelpDebugHistoryOn,,""
MSG_HelpDebugToggleBp,,"Define/Limpa ponto de interrupao na posiao do cursor"
MSG_HelpDebugClearAllBp,,"Remove todos os pontos de interrupao"
MSG_HelpDebugBreakOnErr,,""
MSG_HelpDebugSetNextStmt,,"Executa o comando na posiao do cursor em seguida"
MSG_HelpOptionsDisplay,,"Altera os atributos de exibiao"
MSG_HelpOptionsPaths,,"Define o caminho de pesquisa para os arquivos de socorro"
MSG_HelpOptionsMouse,,""
MSG_HelpOptionsSyntax,,"Ativa/Desativa verificaao de sintaxe do editor."
MSG_HelpOptionsFullMenu,,""
MSG_HelpHelpIndex,,"Exibe o ndice de socorro"
MSG_HelpHelpContents,,"Exibe a tabela de contedo de socorro"
MSG_HelpHelpSyntax,,"Exibe as informaoes sobre a palavra-chave na posiao do cursor"
MSG_HelpHelpHelp,,"Exibe informaoes sobre como utilizar o Socorro em linha"
MSG_HelpHelpStarted,,"Exibe informaoes sobre como carregar e usar Editor do MS-DOS"
MSG_HelpHelpKeyboard,,"Exibe teclas de ediao e navegaao"
MSG_HelpHelpAbout,,"Exibe informaoes sobre a versao e copyright do produto"
;
;Section 5.5: Status line HELP messages <THESE MUST REMAIN CONTIGUOUS>
;
; IMPORTANT:  If the text of ANY of the following messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
; IMPORTANT:  See UINHELP.ASM for a description of how to change the text of
; IMPORTANT:  MSG_Status[Edit, Running, Immediate, Help, ShiftF1].
;
MSG_StatusMenu,,"Enter=Exibe o menu   Esc=Cancelar   Arrow=Prximo item"
MSG_StatusDialog,,"Enter=Executar  Esc=Canc.  Tab=Prx. campo  Seta=Prx. item"
MSG_StatusEdit,,"<F6=Jan.> <F2=Subs> <F5=Exec.> <F8=Etapa>"
MSG_StatusRunning,,"<F5=Continuar> <F9=Alterna> <F8=Etapa>"
MSG_StatusImmediate,,"<F6=Janela> <Enter=Executar linha>"
MSG_StatusHelp,,"<F6=Jan.> <Esc=Canc.> <Ctrl+F1=Prx.> <Alt+F1=Voltar>"
MSG_StatusQEdit,,"MS-DOS Editor  <F1=Socor.> ALT = Ativar menus"
MSG_StatusQHelp,,"<F1=Socor.> <F6=Jan.> <Esc=Canc.> <Ctrl+F1=Prx.> <Alt+F1=Voltar>"
MSG_StatusF1Help,,"F1=Soc.   "
MSG_StatusShiftF1,,"<Shift+F1=Socor.> "
;
; IMPORTANT:  If the text of ANY of the previous messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
;
;Section 5.6: Variable HELP messages <Some of these must remain contiguous>
;Ripped these out for LQB
;
;Section 5.7: misc messages
;
MSG_SearchPathEdit,,"Localizaao (caminho) do arquivo EDIT.HLP:"
MSG_SearchPathInterp,,"Localizaao (caminho) do arquivo QBASIC.HLP:"
;
;Section touch: Messages can be added to the bottom of the file
; and all objects except uiutil.obj and qbimsgs.obj can be touched.
; Also touch qbimsgs.rpl, then *.hlp!
; Later, these messages should be moved into their appropriate sections.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbspa\strings\qbasmsgs.txt ===
; QBasic Standard Error Messages.
; This file is read by the tool makemsgs, which produces the files:
;      qbimsgs.asm, qbimsgs.inc, and qbimsgs.h
;
; Entries in this file have the form:
;  [<symbol's name>,[<msg index/error code>],"<ASCII msg>"] [;<comment>]
;
; If <msg index/error code> is not specified, the next available one
;    is assigned.
;
;Section 1:  Runtime Errors - symbol names are kept small to decrease
;            the size of the runtime library.
;            Names begin with ER_ to distinguish them from non-runtime
;            errors, which begin with MSG_.
;
;NOTE: A *BLANK* line terminates MAKEMSG.  Do not add blank lines!
;
;
ER_NF,1,"NEXT sin FOR"
ER_SN,2,"Error de sintaxis"
ER_RG,3,"RETURN sin GOSUB"
ER_OD,4,"Datos DATA agotados"
ER_FC,5,"Llamado de funcin no vlido"
ER_OV,6,"Desbordamiento"
ER_OM,7,"Memoria agotada"
ER_UL,8,"Etiqueta no definida"
ER_SOR,9,"Subndice fuera de alcance"
ER_DD,10,"Definicin duplicada"
ER_DV0,11,"Divisin entre cero"
ER_ID,12,"No vlida en modo directo"
ER_TM,13,"Tipos no coinciden"
ER_OS,14,"Espacio insuficiente para cadenas"
;15 is unused
ER_BS,16,"Formula de cadena muy compleja"
ER_CN,17,"No se puede continuar"
ER_UF,18,"Funcin no definida"
ER_NR,19,"Falta RESUME"
ER_RE,20,"RESUME sin error"
;21 is unused
;22 is unused
;23 is unused
ER_DTO,24,"Lmite de tiempo para dispositivo"
ER_DF,25,"Fallo en dispositivo"
ER_FN,26,"FOR sin NEXT"
ER_OP,27,"Falta papel"
;28 is unused
ER_WH,29,"WHILE sin WEND"
ER_WE,30,"WEND sin WHILE"
;31 is unused
;32 is unused
ER_DL,33,"Etiqueta duplicada"
;34 is unused
ER_US,35,"Subprograma no definido"
;; ER_SIU,36,"Subprograma ya est en uso"  ;dead after recursion added
ER_AC,37,"resultado-argumento no coincide"
ER_UA,38,"Matriz no definida"
ER_CaseElse,39,"CASE ELSE se requera"
ER_VarReq,40,"Variable requerida"
;41 is unused
;42 is unused
;43 is unused
;44 is unused
;45 is unused
;46 is unused
;47 is unused
;48 is unused
;49 is unused
ER_FOV,50,"Desbordamiento de FIELD"
ER_IER,51,"Error interno"
ER_BFN,52,"Nombre de archivo o nmero incorrecto"
ER_FNF,53,"No se encontr archivo"
ER_BFM,54,"Modo de archivo incorrecto"
ER_FAO,55,"Archivo ya est abierto"
ER_FSA,56,"Instruccin FIELD activa"
ER_IOE,57,"Error en dispositivo E/S"
ER_FAE,58,"Archivo ya existe"
ER_BRL,59,"Longitud de registro incorrecta"
;60 is unused
ER_DFL,61,"Disco lleno"
ER_RPE,62,"Input excedi fin de archivo"
ER_BRN,63,"Nmero de registro incorrecto"
ER_IFN,64,"Nombre de archivo incorrecto"
;65 is unused
;66 is unused	- used to be ER_FDR - Direct statement in file
ER_TMF,67,"Demasiados archivos"
ER_DNA,68,"Dispositivo no disponible"
ER_CBO,69,"Desbordamiento en bfer de comunicacin"
ER_PRM,70,"Permiso denegado"
ER_DNR,71,"Disco no est listo"
ER_DME,72,"Error fsico en disco"
ER_ADF,73,"Caraterstica avanzada no disponible"
ER_RAD,74,"Cambiar nombre a travs de discos"
ER_PAE,75,"Error de acceso en Ruta/Archivo"
ER_PNF,76,"Ruta no se encontr"
;;;ER_DLK,77,"Deadlock" ;not needed until OS/2 version
;
; The following ER_UE marks the last trappable Runtime Error Code
;
ER_UE,,"Error no imprimible"
;
;=========================================================================
; Subsequent ER_ messages are special, and are intimately tied in with
; the runtime message file, messages.inc.
; Some of these errors are considered "very fatal", and cause termination;
; others are not errors at all - - we just supply the text for some runtime
; messages here.
; These messages must remain contiguous and in the same order, unless
; a matching change is made in messages.inc.
;
; First group of internal errors - - these are actually runtime messages,
; not errors
; Any message that begins ER_UL is used in constructing a message
; as follows:
;  Error in loading (file) - Internal error
;
ER_RFS,,"Empezar nuevamente"
ER_BFC,,"Bytes libres",CR         ;'CR' means terminate with a Carriage Return
ER_ULP,,"No se puede encontrar archivo ("    ;preamble for user file path prompt
ER_ULT,,"). Ruta de entrada: "       ;postamble for user file path prompt
ER_ULE,,"Error al cargar archivo (" ;preamble for loader errors
ER_ULG,,") - "			;postamble for loader errors
ER_RNS,,"Nmero aleatorio inicial (-32768 a 32767)"
ER_HRS,,"Presione cualquier tecla y continue" ;Displayed when errors occurr in QBC exec.
;
; Second group of internal errors - these are "very fatal"
ER_SSC,,"Espacio en cadena alterado"  ;string space or local heap trashed somehow
ER_ULD,,"Error en disco E/S"        ;problem in loading U.L. from disk
ER_ULI,,"Formato no vlido"        ;attempt to load a U.L. with incorrect format
ER_ULF,,"No puede encontrar archivo"      ;redirected IO and cannot find file in path
;
; Third group of internal errors - these are also "very fatal"
ER_D21,,"Se requiere DOS 2.10 o ltimo"
ER_INI,,"Error durante inicializacin de QBasic" ;error in initializing runtime
ER_ULO,,"Memoria agotada"         ;out of memory loading U.L.
ER_DMA,,"Error en territorio DOS" ;someone walked on DOS-owned memory
ER_FHC,,"Espacio en cadena alterado"      ;similar to string space corrupt
ER_ULM,,"Error interno"        ;U.L. loading found a bad segment address
;
; QB-specific internal errors - these are "very fatal"
; NOTE: These must come after other internal errors (no equivalent in
;	messages.inc)
;
;Both groups of the command line help message must remain contiguous.
;They must start with the label ER_ISWEDIT/ER_ISWHELP/ER_ISWINTERP and end
;with the label ER_ISWEDITEND/ER_ISWHELPEND/ERISWINTERPEND.  The labels of the
;intermediate lines does not matter.
;
ER_ISWEDIT,,"Inicia el Editor MS-DOS que sirve para crear y modificar archivos ASCII."
ER_ISWEDIT1,," "
ER_ISWEDIT2,,"EDIT [[unidad:][ruta]archivo] [/B] [/G] [/H] [/NOHI]"
ER_ISWEDIT3,," "
ER_ISWEDIT4,,"  [unidad:][ruta]archivo   Especifica el archivo ASCII que desea editar"
ER_ISWEDIT5,,"  /B        Permite usar monitor monocromo con tarjeta de grficos a color."
ER_ISWEDIT6,,"  /G        Ofrece la actualizacin rpida de una pantalla CGA."
ER_ISWEDIT7,,"  /H        Presenta el nmero mximo de lneas posibles para su hardware."
ER_ISWEDITEND,,"  /NOHI     Permite usar un monitor que no acepta alta intensidad."
;
ER_ISWQHELP,,"Inicia el visor de Ayuda MS-DOS para los archivos de Ayuda MS-DOS."
ER_ISWQHELP1,," "
ER_ISWQHELP2,,"QHELP [tema] [/B] [/G] [/H] [/NOHI]"
ER_ISWQHELP3,," "
ER_ISWQHELP4,,"  [tema]  Especifica el tema de ayuda que desee ver."
ER_ISWQHELP5,,"  /B          Permite usar monitor monocromo con tarjeta de grficos a color."
ER_ISWQHELP6,,"  /G          Ofrece una actualizacin rpida de una pantalla CGA."
ER_ISWQHELP7,,"  /H          Presenta el nmero mximo de lneas posible para su hardware."
ER_ISWQHELPEND,,"  /NOHI       Permite usar un monitor que no acepta alta intensidad."
;
ER_ISWINTERP,,"Inicia el entorno de programacin MS-DOS QBasic."
ER_ISWINTERP1,," "
ER_ISWINTERP2,,"QBASIC [/B] [/EDITOR] [/G] [/H] [/MBF] [/NOHI] [[/RUN] [unidad:][ruta]archivo]"
ER_ISWINTERP3,," "
ER_ISWINTERP4,," /B            Permite usar monitor monocromo con tarjeta de grficos a color."
ER_ISWINTERP5,," /EDITOR       Inicia el Editor MS-DOS."
ER_ISWINTERP6,," /G            Ofrece una actualizacin rpida de una pantalla CGA."
ER_ISWINTERP7,," /H            Presenta el nmero mximo de lneas posible para su hardware."
ER_ISWINTERP8,," /MBF          Convierte las funciones incorporadas MKS$, MKD$, CVS, y CVD a"
ER_ISWINTERP9,,"               MKSMBF$, MKDMBF$, CVSMBF, y CVDMBF, respectivamente."
ER_ISWINTERPA,," /NOHI         Permite usar un monitor que no acepta alta intensidad."
ER_ISWINTERPB,," /RUN          Ejecuta un archivo de programa en Basic antes de presentarlo."
ER_ISWINTERPEND,," [[unidad:][ruta]archivo] Especifica archivo de programa a cargar o ejecutar."
;
;=========================================================================
;
;-------------------------------------------------------------------------
;MSG_GoDirect is non-trappable interpreter-specific
; error which allow us to back out of what we're doing and escape back
; to direct mode.
;
MSG_GoDirect,,""
MSG_OutOfStack,,"Sin espacio en la pila"
MSG_DocTooLarge,,"Documento demasiado grande"
MSG_InclTooLarge,,"Archivo includo demasiado grande"
;
;-------------------------------------------------------------------------
; End of runtime errors.  Messages beyond this point can be re-arranged
; in any order.
;-------------------------------------------------------------------------
;
;Section 2: QBI Parser Related Messages
;
MSG_IdTooLong,,"Identificador demasiado extenso"
MSG_BadId,,"Identificador no vlido"
MSG_IdImp,,"Identificador no se puede cerrar con %, &, !, #, o $"
MSG_BadElemRef,,"Identificador no puede incluir punto final"
MSG_ExpTooComplex,,"Expresin muy compleja"
MSG_IllegalNumber,,"nmero no aceptable"
MSG_InvConst,,"Constante no vlida"
MSG_expected,,"Se cuenta con: "
MSG_or,," o "
;
; Parser errors which are preceded by "Expected: "
;
MSG_ExpAssignment,,"variable=expresin"
MSG_ExpExp,,"expresin"
MSG_ExpVar,,"variable"
MSG_ExpId,,"identificador"
MSG_ExpStatement,,"instruccin"
MSG_ExpLabel,,"etiqueta"
MSG_ExpLn,,"nmero de lnea"
MSG_Letter,,"letra"
MSG_eos,,"fin-de-instruccin"
MSG_RightParen,,")"
MSG_ExpIdCallArg,,"expresin"
MSG_ExpIdParm,,"variable"
MSG_ExpFNId,,"identificador que empieza con FN"
MSG_ExpIfClause,,"etiqueta o instruccin"
MSG_ExpLabLn,,"etiqueta o nmero de lnea"
MSG_ExpLitString,,"constante de cadena"
MSG_ExpLit0,,"0"
MSG_ExpLit1,,"1"
MSG_ExpNArgs,,"[expresin],..."
MSG_ExpRwB,,"B"
MSG_ExpRwF,,"F"
MSG_ExpRwBF,,"BF"
MSG_ExpRel,,"<, <=, >, >=, =, o <>"
;
;Section 3:  TextMgr/ReParse errors
;
MSG_InvModLev,,"No vlido fuera de SUB, FUNCTION o DEF FN"
MSG_InvMain,,"No vlido fuera de SUB/FUNCTION"
MSG_InvProc,,"No vlido dentro de procedimiento o DEF FN"
MSG_InvBeforeProcDef,,"Instruccin no puede preceder definicin SUB/FUNCTION"
MSG_ProcNoEnd,,"SUB/FUNCTION sin END SUB/FUNCTION"
MSG_EndNoProc,,"END SUB/FUNCTION sin SUB/FUNCTION"
MSG_EndNoDef,,"END DEF sin DEF"
MSG_UndElem,,"Elemento no definido"
MSG_UndType,,"Tipo no definido"
MSG_1stStmt,,"Debe ser la primera instruccin en la lnea"
MSG_EndProc,,"END SUB o END FUNCTION debe ser la ltima lnea en ventana"
MSG_NoEndType,,"TYPE sin END TYPE"
MSG_NoType,,"END TYPE sin TYPE"
MSG_InvInTypeBlk,,"Instruccin no vlida en bloque TYPE"
MSG_InvIncl,,"Instruccin no debe aparecer dentro del archivo INCLUDE"
MSG_InvDecl,,"DECLARE no vlido para procedimiento Basic"
MSG_FNstart,,"No se puede iniciar con 'FN'"
MSG_NotBlock,,"Operacin requiere un disquete"
MSG_BadMeta,,"Error $Metacomando"
MSG_NoBpCase,,"Ptos/interrup. no permitidos en clasulas CASE o END SELECT"
;
;Section 4:  Scan-time errors
;
MSG_OBA,,"Matriz ya est en dimensin"
MSG_COM,,"COMMON y DECLARE debe preceder instrucciones ejecutables"
MSG_EWI,,"END IF sin bloque IF"
MSG_IWE,,"Bloque IF sin END IF"
MSG_ElseWI,,"ELSE sin IF"
MSG_ExitScope,,"EXIT no est dentro de FOR...NEXT"
MSG_ExitDo,,"EXIT DO no est dentro DO...LOOP"
MSG_Do,,"DO sin LOOP"
MSG_Loop,,"LOOP sin DO"
MSG_Select,,"SELECT sin END SELECT"
MSG_Case,,"CASE sin SELECT"
MSG_EndSelect,,"END SELECT sin SELECT"
MSG_InvFixStr,,"Tamao fijo de cadena no vlido"
MSG_InvTypedVar,,"Tipo de variable no permitida en expresin"
MSG_DefNoEnd,,"DEF sin END DEF"
MSG_ParmTM,,"Tipo de parmetro incongruente"
MSG_DupLibPrs,,"Procedimiento ya definido en Quick library"
MSG_ASRqd1st,,"AS clasula requerida en primera declaracin"
MSG_ASRqd,,"AS clasula requerida"
MSG_ExpectedCase,,"Nombres/Instruccin no vlidos entre SELECT CASE y CASE"
MSG_NoNumArr,,"Matriz numrica no vlida"
MSG_InType,,"No vlida fuera del bloque TYPE"
MSG_ULCom,,"COMMON en Quick library demasiado pequeo"
MSG_SubCnt,,"Nmero equivocado de dimensiones"
MSG_DefFnCtrl,,"DEF FN no permitido en instrucciones de control"
MSG_Unsupported,,"Esta caracterstica no est disponible"
;
;Section 5.1: User Interface Related Messages that could be described in
;	      user guide's error message appendix
;
MSG_CantCont,,"Deber reiniciar su sistema despus de esta modificacin. Continuar?"
MSG_NoMainProg,,"No hay mdulo principal. En men Ejecutar elija Fijar Mdulo Principal"
MSG_HelpOOM,,"No hay memoria suficiente para presentar Ayuda"
;
;Section 5.2: Messages that require special handling in ReportError()
;
;Note: The next 2 messages must have numbers < 256 for because they can be
;      passed to RtError_Ini by exStRunFile during command-line load.
;
MSG_DupMrs,,"Archivo previamente cargado"
MSG_DupPrs,,"Intent cargar archivo con definicin de procedimiento definido"
MSG_MrsNotFound,,"Mdulo no se encontr. Descargar mdulo del programa?"
;
;Section 5.3: General User Interface messages
;
MSG_Overwrite,,"Archivo existe. Sobrescribirlo?"
MSG_DelProc,,"Eliminar procedimiento del mdulo?"
MSG_MakeRem,,"No lneas en blanco antes de lnea SUB/FUNCTION. SI, como comentario?"
MSG_NotSaved,,"Se modific arch. desde que se guard por ltima vez. Guardar ahora?"
MSG_NotSavedAll,,"Archivo cargado no fue guardado. Guardar ahora?"
MSG_NotSavedInc,,"Guardar archs. INCLUDE modificados antes de ejecutar. Guardar ahora?"
MSG_NotSavedIncSav,,"Guardar primero los archivos INCLUDE modificados?"
MSG_BadNextStmt,,"No se puede exceder barrera de procedimiento en mdulo "
MSG_Prt1,,"Esperando impresora"
MSG_Prt2,,"Imprimiendo - presione Esc para cancelar"
MSG_Immediate,,"Inmediata"
MSG_Untitled,,"Sin_Nombre"
MSG_FALSE,,"<FALSO>"
MSG_TRUE,,"<VERDADERO>"
MSG_Black,,"Negro"
MSG_Blue,,"Azul"
MSG_Green,,"Verde"
MSG_Cyan,,"Cyan"
MSG_Red,,"Rojo"
MSG_Magenta,,"Granate"
MSG_Brown,,"Marrn"
MSG_White,,"Blanco"
MSG_Gray,,"Gris"
MSG_BrBlue,,"AzulIn"
MSG_BrGreen,,"VerdeIn"
MSG_BrCyan,,"CyanIn"
MSG_BrRed,,"RojoIn"
MSG_Pink,,"Rosado"
MSG_Yellow,,"Amarillo"
MSG_BrWhite,,"BlancoIn"
MSG_MustSpecifyName,,"Debe especificar nombre"
MSG_DataMoved,,"Instrucciones DATA fueron movidos de SUB a nivel de mdulo"
MSG_ModuleExists,,"Mdulo con ese nombre ya est cargado"
MSG_NoHelp,,"Archivo "
MSG_NoHelp1,," no se encontr."
MSG_NoHelp2,,"Insertar disquete con este archivo en unidad y"
MSG_NoHelp3,,"Reintentar, o cambiar la ruta de Ayuda en Ruta Opciones+Ayuda."
MSG_NoQHelp2,,"Inserte el disquete que contiene este archivo en la unidad y"
MSG_NoQHelp3,,"Reintente, o salga y coloque este archivo en directorio de la RUTA."
MSG_NoSearchString,,"Debe especificar cadena de bsqueda"
MSG_MatchNotFound,,"No se encontr equivalencia"
MSG_ChangeComplete,,"Cambio completo"
MSG_Is,," es "
MSG_MainModule,,"el Mdulo Principal"
MSG_Module,,"un Mdulo"
MSG_IncludeFile,,"Archivo Includo"
MSG_Document,,"un Documento"
MSG_Sub,,"un SUB en "
MSG_Function,,"una FUNCTION en "
MSG_ReqSub,,"Operacin requiere seleccin de SUB o FUNCTION"
;If text of MSG_SwitchDisks changes, ref code in uifile.c must change as well.
MSG_SwitchDisks,,"Insertar Disquete en unidad A:"
MSG_Loading,,"Cargando y analizando"
MSG_Saving,,"Guardando"
MSG_Compiling,,"Atando o ligando"
MSG_Searching,,"Buscando - presione Esc para cancelar"
MSG_CantSetTabs,,"No se puede cambiar altos de tab mientras hay archivo cargado"
MSG_OutNearMem,,"Espacio para datos agotado"
MSG_ModTooLarge,,"Nivel de cdigo para Mdulo demasiado extenso"
MSG_ProcTooLarge,,"Procedimiento demasiado extenso"
MSG_ExitToRet,,CR,"Escriba EXIT para regresar a QBasic"
MSG_QeditText1,," Fijar colores para "
MSG_QeditText2,," ventana del editor texto:"
MSG_NormalText,," Texto Normal       "
MSG_Breakpoint,," Lneas de Ptos/ruptura  "
MSG_CurStmt,," Instruccin Actual "
MSG_HelpTitle,,"AYUDA: "
MSG_HelpTitleQH,,"MS-DOS Ayuda: "
MSG_FirstContextStr,,"h.pg1"
MSG_HelpAboutEditor,,"MS-DOS Editor"
MSG_HelpAboutQHelp,,"MS-DOS Visor de Ayuda"
MSG_HelpAboutInterp,,"MS-DOS QBasic"
MSG_HelpAbout2,,"Versin 1.1"
MSG_HelpAbout3,,"Copyright (C) Microsoft Corporation, 1987-1993."
;
;Section 5.4: HELP messages for menu items <THESE MUST REMAIN CONTIGUOUS>
;
; NOTE: These must match the EXACT order of the midFileNew...midHelpHowToUse
;	definitions in ..\ir\qbasmsgs.txt, because ..\uq\uictl.c (MainWndProc)
;	does a direct mapping from midXxx to MSG_HelpXxx assuming this
;	ordering exists.
;
MSG_HelpFileNew,,"Elimina de la memoria el archivo actualmente cargado"
MSG_HelpFileOpen,,"Carga un nuevo archivo a memoria"
MSG_HelpFileMerge,,""
MSG_HelpFileSave,,"Guarda archivo actual"
MSG_HelpFileSaveAs,,"Guarda archivo actual con nombre especificado"
MSG_HelpFileSaveAll,,""
MSG_HelpFileCreate,,""
MSG_HelpFileLoad,,""
MSG_HelpFileUnload,,""
MSG_HelpFilePrint,,"Imprime el texto especificado"
MSG_HelpFileShell,,""
MSG_HelpFileExit,,"Sale del editor y regresa a DOS"
MSG_HelpFileExitQH,,"Sale del Visor de Ayuda y regresa a DOS"
MSG_HelpEditUndo,,""
MSG_HelpEditCut,,"Elimina texto seleccionado y lo copia al bfer"
MSG_HelpEditCopy,,"Copia texto seleccionado al bfer"
MSG_HelpEditClear,,"Elimina texto seleccionado sin copiarlo al bfer"
MSG_HelpEditPaste,,"Inserta contenido del bfer a un lugar ahora especificado"
MSG_HelpEditNewSub,,"Abre una ventana para un nuevo subprograma"
MSG_HelpEditNewFunc,,"Abre una ventana para un procedimiento FUNCTION nuevo"
MSG_HelpViewSubs,,"Presenta SUB o FUNCTION cargada"
MSG_HelpViewNextProc,,""
MSG_HelpViewSplit,,"Divide la pantalla para presentacin doble"
MSG_HelpViewNextStatement,,""
MSG_HelpViewOutputScreen,,"Presenta la informacin en pantalla"
MSG_HelpViewIncludes,,""
MSG_HelpViewEditIncl,,""
MSG_HelpSearchFind,,"Busca texto especificado"
MSG_HelpSearchSelected,,""
MSG_HelpSearchNext,,"Repite bsqueda del texto anterior especificado"
MSG_HelpSearchChange,,"Busca y cambia el texto especificado"
MSG_HelpSearchLabel,,""
MSG_HelpRunStart,,"Ejecuta el programa actual"
MSG_HelpRunRestart,,"Borra variables en preparacin para reiniciar paso simple"
MSG_HelpRunContinue,,"Continua ejecucin despus de una ruptura"
MSG_HelpRunSetCommand,,""
MSG_HelpRunMakeExe,,""
MSG_HelpRunMakeLib,,""
MSG_HelpRunSetMain,,""
MSG_HelpDebugStep,,"Ejecuta siguiente instruccin de programa"
MSG_HelpDebugPStep,,"Ejecuta sgte instruc/prog., rastreando llamados/procedimiento"
MSG_HelpDebugAddWatch,,""
MSG_HelpDebugInstantWatch,,""
MSG_HelpDebugWatchPoint,,""
MSG_HelpDebugDelWatch,,""
MSG_HelpDebugDelAllWatch,,""
MSG_HelpDebugTraceOn,,"Resalta instrucciones en ejecucin"
MSG_HelpDebugHistoryOn,,""
MSG_HelpDebugToggleBp,,"Activa/desactiva puntos de interrupcin en el cursor"
MSG_HelpDebugClearAllBp,,"Borra puntos de interrupcin"
MSG_HelpDebugBreakOnErr,,""
MSG_HelpDebugSetNextStmt,,"La instruccin en el cursor es la siguiente a ejecutar"
MSG_HelpOptionsDisplay,,"Cambia los atributos presentables"
MSG_HelpOptionsPaths,,"Establece la ruta de bsqueda para archivos de Ayuda"
MSG_HelpOptionsMouse,,""
MSG_HelpOptionsSyntax,,"Activa o desactiva la verificacin de sintaxis del editor."
MSG_HelpOptionsFullMenu,,""
MSG_HelpHelpIndex,,"Presenta el indice de ayuda"
MSG_HelpHelpContents,,"Presenta la tabla de contenido de la ayuda"
MSG_HelpHelpSyntax,,"Presenta info. de palabra clave Basic sealada por el cursor"
MSG_HelpHelpHelp,,"Presenta info. sobre el pedido de Ayuda en pantalla"
MSG_HelpHelpStarted,,"Presenta info. de cmo cargar y usar el Editor MS-DOS"
MSG_HelpHelpKeyboard,,"Presenta ayuda para el uso de la combinacin de teclas"
MSG_HelpHelpAbout,,"Presenta la versin del producto e informacin de copyright"
MSG_HelpHowToUse,,"Presenta informacin para el uso del Visor de Ayuda para MS-DOS"
;
;Section 5.5: Status line HELP messages <THESE MUST REMAIN CONTIGUOUS>
;
; IMPORTANT:  If the text of ANY of the following messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
; IMPORTANT:  See UINHELP.ASM for a description of how to change the text of
; IMPORTANT:  MSG_Status[Edit, Running, Immediate, Help, ShiftF1].
;
MSG_StatusMenu,,"Entrar=Presentar men  Esc=Cancelar  Flecha=Sgte elemento"
MSG_StatusDialog,,"Entrar=Ejecutar  Esc=Cancelar  Tab=Sgte campo  Flecha=Sgte elemento"
MSG_StatusEdit,,"F6=Ventana  F2=Subs  F5=Ejecutar  F8=Paso"
MSG_StatusRunning,,"F5=Continuar  F9=Des/Activar PtoInt  F8=Paso"
MSG_StatusImmediate,,"F6=Ventana  Entrar=Ejecutar lnea"
MSG_StatusHelp,,"F6=Ventana  Esc=Cancelar  Ctrl+F1=Sgte  Alt+F1=Regresar"
MSG_StatusQEdit,,"MS-DOS Editor  F1=Ayuda  Presione ALT para activar mens"
MSG_StatusQHelp,,"F1=Ayuda  F6=Ventana  Esc=Cancelar  Ctrl+F1=Sgte  Alt+F1=Regresar"
MSG_StatusQHStart,,"Visor de Ayuda MS-DOS  <F1=Ayuda> Presione ALT para activar mens"
;
;
MSG_StatusQHhelp,,"<Alt+C=Contenido> <Alt+S=Sgte> <Alt+R=Regresar>"
;
; LOCALIZATION - To change the accelerator chars in the above line, change the
;       the values in rgmpvkeyidQhelp[], in UIRSRCC.C (At about line #460).
;
;
MSG_StatusF1Help,,"F1=Ayuda  "
MSG_StatusShiftF1,,"Mays+F1=Ayuda  "
;
; IMPORTANT:  If the text of ANY of the previous messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
;
;Section 5.6: Variable HELP messages <Some of these must remain contiguous>
;Ripped these out for LQB
;
;Section 5.7: misc messages
;
MSG_SearchPathEdit,,"Lugar (ruta) del archivo EDIT.HLP:"
MSG_SearchPathHelp,,"Lugar (ruta) del archivo DOSVIEW.HLP:"
MSG_SearchPathInterp,,"Lugar (ruta) del archivo QBASIC.HLP:"
;
;Section touch: Messages can be added to the bottom of the file
; and all objects except uiutil.obj and qbimsgs.obj can be touched.
; Also touch qbimsgs.rpl, then *.hlp!
; Later, these messages should be moved into their appropriate sections.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbswe\strings\qbasmsgs.txt ===
; QBasic Standard Error Messages.
; This file is read by the tool makemsgs, which produces the files:
;      qbimsgs.asm, qbimsgs.inc, and qbimsgs.h
;
; Entries in this file have the form:
;  [<symbol's name>,[<msg index/error code>],"<ASCII msg>"] [;<comment>]
;
; If <msg index/error code> is not specified, the next available one
;    is assigned.
;
;Section 1:  Runtime Errors - symbol names are kept small to decrease
;            the size of the runtime library.
;            Names begin with ER_ to distinguish them from non-runtime
;            errors, which begin with MSG_.
;
;NOTE: A *BLANK* line terminates MAKEMSG.  Do not add blank lines!
;
;
ER_NF,1,"NEXT utan FOR"
ER_SN,2,"Syntaxfel"
ER_RG,3,"RETURN utan GOSUB"
ER_OD,4,"Slut p DATA"
ER_FC,5,"Ogiltigt funktionsanrop"
ER_OV,6,"verskridning"
ER_OM,7,"Slut p minnet"
ER_UL,8,"Etiketten r inte definierad"
ER_SOR,9,"Index utanfr intervallet"
ER_DD,10,"Definitionen finns redan"
ER_DV0,11,"Division med noll"
ER_ID,12,"Ogiltigt i direktlget"
ER_TM,13,"Olika typer"
ER_OS,14,"Slut p strngutrymme"
;15 is unused
ER_BS,16,"Strngformeln fr komplex"
ER_CN,17,"Kan inte fortstta"
ER_UF,18,"Funktionen inte definierad"
ER_NR,19,"RESUME finns inte"
ER_RE,20,"RESUME utan fel"
;21 is unused
;22 is unused
;23 is unused
ER_DTO,24,"Tiden ute fr enheten"
ER_DF,25,"Enhetsfel"
ER_FN,26,"FOR utan NEXT"
ER_OP,27,"Slut p papper"
;28 is unused
ER_WH,29,"WHILE utan WEND"
ER_WE,30,"WEND utan WHILE"
;31 is unused
;32 is unused
ER_DL,33,"Etiketten finns redan"
;34 is unused
ER_US,35,"Delprogrammet inte definierat"
;; ER_SIU,36,"Subprogram already in use"  ;dead after recursion added
ER_AC,37,"Felaktigt antal argument"
ER_UA,38,"Matrisen inte definierad"
ER_CaseElse,39,"CASE ELSE vntades"
ER_VarReq,40,"Variabel krvs"
;41 is unused
;42 is unused
;43 is unused
;44 is unused
;45 is unused
;46 is unused
;47 is unused
;48 is unused
;49 is unused
ER_FOV,50,"verskridning i FIELD-satsen"
ER_IER,51,"Internt fel"
ER_BFN,52,"Felaktigt filnamn eller nummer"
ER_FNF,53,"Fil saknas"
ER_BFM,54,"Felaktigt fillge"
ER_FAO,55,"Filen redan ppen"
ER_FSA,56,"FIELD-sats aktiv"
ER_IOE,57,"Enhetsfel (I/O)"
ER_FAE,58,"Filen finns redan"
ER_BRL,59,"Felaktig postlngd"
;60 is unused
ER_DFL,61,"Disken r full"
ER_RPE,62,"Inmatning efter filslut"
ER_BRN,63,"Felaktigt postnummer"
ER_IFN,64,"Felaktigt filnamn"
;65 is unused
;66 is unused   - used to be ER_FDR - Direct statement in file
ER_TMF,67,"Fr mnga filer"
ER_DNA,68,"Enhet ej tillgnglig"
ER_CBO,69,"Kommunikationsbufferten full"
ER_PRM,70,"Behrighet saknas"
ER_DNR,71,"Disken r inte klar"
ER_DME,72,"Fel p disken"
ER_ADF,73,"Egenskapen ej tillgnglig"
ER_RAD,74,"Namnbyte till annan disk"
ER_PAE,75,"tkomstfel fr skvg/fil"
ER_PNF,76,"Kan inte hitta skvgen"
;;;ER_DLK,77,"Deadlock" ;not needed until OS/2 version
;
; The following ER_UE marks the last trappable Runtime Error Code
;
ER_UE,,"Oskrivbart fel"
;
;=========================================================================
; Subsequent ER_ messages are special, and are intimately tied in with
; the runtime message file, messages.inc.
; Some of these errors are considered "very fatal", and cause termination;
; others are not errors at all - - we just supply the text for some runtime
; messages here.
; These messages must remain contiguous and in the same order, unless
; a matching change is made in messages.inc.
;
; First group of internal errors - - these are actually runtime messages,
; not errors
; Any message that begins ER_UL is used in constructing a message
; as follows:
;  Error in loading (file) - Internal error
;
ER_RFS,,"Brja om frn brjan"
ER_BFC,,"Byte ledigt",CR         ;'CR' means terminate with a Carriage Return
ER_ULP,,"Kan inte hitta filen ("    ;preamble for user file path prompt
ER_ULT,,"). Skriv in skvg: "       ;postamble for user file path prompt
ER_ULE,,"Fel vid laddning av filen (" ;preamble for loader errors
ER_ULG,,") - "                  ;postamble for loader errors
ER_RNS,,"Startvrde fr slumptal (-32768 till 32767)"
ER_HRS,,"Tryck p valfri tangent fr att fortstta" ;Displayed when errors occurr in QBC exec.
;
; Second group of internal errors - these are "very fatal"
ER_SSC,,"Strngutrymmet frstrt"  ;string space or local heap trashed somehow
ER_ULD,,"Diskfel (I/O)"        ;problem in loading U.L. from disk
ER_ULI,,"Ogiltigt format"        ;attempt to load a U.L. with incorrect format
ER_ULF,,"Kan inte hitta filen"      ;redirected IO and cannot find file in path
;
; Third group of internal errors - these are also "very fatal"
ER_D21,,"Krver DOS 2.10 eller senare"
ER_INI,,"Fel vid QBasic initiering" ;error in initializing runtime
ER_ULO,,"Slut p minnet"         ;out of memory loading U.L.
ER_DMA,,"DOS minesomrdesfel" ;someone walked on DOS-owned memory
ER_FHC,,"Fjrrstacken frstrd"      ;similar to string space corrupt
ER_ULM,,"Internt fel"        ;U.L. loading found a bad segment address
;
; QB-specific internal errors - these are "very fatal"
; NOTE: These must come after other internal errors (no equivalent in
;       messages.inc)
;
;Both groups of the command line help message must remain contiguous.
;They must start with the label ER_ISWEDIT/ER_ISWHELP/ER_ISWINTERP and end
;with the label ER_ISWEDITEND/ER_ISWHELPEND/ERISWINTERPEND.  The labels of the
;intermediate lines does not matter.
;
ER_ISWEDIT,,"Startar MS-DOS Editor, som skapar och ndrar ASCII-filer."
ER_ISWEDIT1,," "
ER_ISWEDIT2,,"EDIT [[enhet:][skvg]filnamn] [/B] [/G] [/H] [/NOHI]"
ER_ISWEDIT3,,"  [enhet:][skvg]filnamn  ASCII-filen som ska redigeras."
ER_ISWEDIT4,,"  /B        Fr anvndning av en monokrom skrm med frggrafikkort."
ER_ISWEDIT5,,"  /G        Uppdaterar en CGA-skrm s fort som mjligt."
ER_ISWEDIT6,,"  /H        Visar det maximala antalet rader som din maskinvara kan klara av."
ER_ISWEDITEND,,"  /NOHI     Fr anvndning av skrmar som inte stder hg intensitet."
;
ER_ISWQHELP,,"Startar MS-DOS Hjlp om MS-DOS-kommandon."
ER_ISWQHELP1,," "
ER_ISWQHELP2,,"HELP [mne] [/B] [/G] [/H] [/NOHI] [mne]"
ER_ISWQHELP3,," "
ER_ISWQHELP4,,"  /B          Mjliggr anvndning av monokrom bildskrm med ett frggrafikkort."
ER_ISWQHELP5,,"  /G          Ger den snabbaste uppdateringen av en CGA-bildskrm."
ER_ISWQHELP6,,"  /H          Visar maximalt antal linjer p datorn."
ER_ISWQHELP7,,"  /NOHI       Mjliggr anvndning av bildskrm utan hgintensitetsstd."
ER_ISWQHELPEND,,"  [mne]      Anger det mne som ska visas."
;
ER_ISWINTERP,,"Startar QBasic programmeringsmilj."
ER_ISWINTERP1,," "
ER_ISWINTERP2,,"QBASIC [/B] [/EDITOR] [/G] [/H] [/MBF] [/NOHI] [[/RUN] [enhet:][skvg]filnamn]"
ER_ISWINTERP3,," /B          Fr anvndning av en monokrom skrm med frggrafikkort."
ER_ISWINTERP4,," /EDITOR     Startar MS-DOS Editor."
ER_ISWINTERP5,," /G          Uppdaterar en CGA-skrm s fort som mjligt."
ER_ISWINTERP6,," /H          Visar det maximala antalet rader som din maskinvara kan klara av."
ER_ISWINTERP7,," /MBF        Konverterar funktionerna MKS$, MKD$, CVS och CVD till"
ER_ISWINTERP8,,"             MKSMBF$, MKDMBF$, CVSMBF respektive CVDMBF."
ER_ISWINTERP9,," /NOHI       Fr anvndning av skrmar som inte stder hg intensitet."
ER_ISWINTERPA,," /RUN        Gr att QBasic laddar och kr en programfil innan den visas."
ER_ISWINTERPEND,,"  [[enhet:][skvg]filnamn] Programmet som ska laddas eller kras."
;
;=========================================================================
;
;-------------------------------------------------------------------------
;MSG_GoDirect is non-trappable interpreter-specific
; error which allow us to back out of what we're doing and escape back
; to direct mode.
;
MSG_GoDirect,,""
MSG_OutOfStack,,"Slut p stackutrymmet"
MSG_DocTooLarge,,"Dokumentet fr stort"
MSG_InclTooLarge,,"Inkluderad fil fr stor"
;
;-------------------------------------------------------------------------
; End of runtime errors.  Messages beyond this point can be re-arranged
; in any order.
;-------------------------------------------------------------------------
;
;Section 2: QBI Parser Related Messages
;
MSG_IdTooLong,,"Identifieraren r fr lng"
MSG_BadId,,"Ogiltig identifierare"
MSG_IdImp,,"Identifierare kan inte sluta med %, &, !, #, $"
MSG_BadElemRef,,"Identifierare kan inte innehlla punkt"
MSG_ExpTooComplex,,"Uttrycket fr komplext"
MSG_IllegalNumber,,"Ogiltigt tal"
MSG_InvConst,,"Ogiltig konstant"
MSG_expected,,"Vntade: "
MSG_or,," eller "
;
; Parser errors which are preceded by "Expected: "
;
MSG_ExpAssignment,,"variabel=uttryck"
MSG_ExpExp,,"uttryck"
MSG_ExpVar,,"variabel"
MSG_ExpId,,"identifierare"
MSG_ExpStatement,,"sats"
MSG_ExpLabel,,"etikett"
MSG_ExpLn,,"radnummer"
MSG_Letter,,"bokstav"
MSG_eos,,"slut p satsen"
MSG_RightParen,,")"
MSG_ExpIdCallArg,,"uttryck"
MSG_ExpIdParm,,"variabel"
MSG_ExpFNId,,"identifierare som brjar med FN"
MSG_ExpIfClause,,"etikett eller sats"
MSG_ExpLabLn,,"etikett eller radnummer"
MSG_ExpLitString,,"strngkonstant"
MSG_ExpLit0,,"0"
MSG_ExpLit1,,"1"
MSG_ExpNArgs,,"[uttryck],..."
MSG_ExpRwB,,"B"
MSG_ExpRwF,,"F"
MSG_ExpRwBF,,"BF"
MSG_ExpRel,,"<, <=, >, >=, = eller <>"
;
;Section 3:  TextMgr/ReParse errors
;
MSG_InvModLev,,"Ogiltigt utanfr SUB, FUNCTION eller DEF FN"
MSG_InvMain,,"Ogiltigt utanfr SUB/FUNCTION"
MSG_InvProc,,"Ogiltigt i SUB, FUNCTION eller DEF FN"
MSG_InvBeforeProcDef,,"Sats kan inte freg SUB/FUNCTION-definition"
MSG_ProcNoEnd,,"SUB/FUNCTION utan END SUB/FUNCTION"
MSG_EndNoProc,,"END SUB/FUNCTION utan SUB/FUNCTION"
MSG_EndNoDef,,"END DEF utan DEF"
MSG_UndElem,,"Elementet inte definierat"
MSG_UndType,,"Typen inte definierad"
MSG_1stStmt,,"Mste vara frsta satsen p raden"
MSG_EndProc,,"END SUB eller END FUNCTION mste vara p sista raden"
MSG_NoEndType,,"TYPE utan END TYPE"
MSG_NoType,,"END TYPE utan TYPE"
MSG_InvInTypeBlk,,"Sats ej tilltet i TYPE-block"
MSG_InvIncl,,"Sats fr ej frekomma inom INCLUDE-fil"
MSG_InvDecl,,"Ogiltig DECLARE fr Basic-procedur"
MSG_FNstart,,"Kan inte brja med 'FN'"
MSG_NotBlock,,"Operationen krver en disk"
MSG_BadMeta,,"$Metakommandofel"
MSG_NoBpCase,,"Brytpunkt ej tillten i CASE-sats eller END SELECT-sats"
;
;Section 4:  Scan-time errors
;
MSG_OBA,,"Matrisen redan dimensionerad"
MSG_COM,,"COMMON och DECLARE mste freg exekverbara satser"
MSG_EWI,,"END IF utan IF-block"
MSG_IWE,,"IF-block utan END IF"
MSG_ElseWI,,"ELSE utan IF"
MSG_ExitScope,,"EXIT FOR inte inom FOR...NEXT"
MSG_ExitDo,,"EXIT DO inte inom DO...LOOP"
MSG_Do,,"DO utan LOOP"
MSG_Loop,,"LOOP utan DO"
MSG_Select,,"SELECT utan END SELECT"
MSG_Case,,"CASE utan SELECT"
MSG_EndSelect,,"END SELECT utan SELECT"
MSG_InvFixStr,,"Strng med fast lngd ej tillten"
MSG_InvTypedVar,,"Typad variabel ej tillten i uttryck"
MSG_DefNoEnd,,"DEF utan END DEF"
MSG_ParmTM,,"Olika parametertyper"
MSG_DupLibPrs,,"Proceduren redan definierad i Quick-biblioteket"
MSG_ASRqd1st,,"AS-sats krvs vid frsta deklaration"
MSG_ASRqd,,"AS-sats krvs"
MSG_ExpectedCase,,"Ej tillten placering av satser"
MSG_NoNumArr,,"Numerisk matris ej tillten"
MSG_InType,,"Ogiltigt utanfr TYPE-block"
MSG_ULCom,,"COMMON i Quick-biblioteket fr liten"
MSG_SubCnt,,"Fel antal dimensioner"
MSG_DefFnCtrl,,"DEF FN ej tilltet i kontrollsatser"
MSG_Unsupported,,"Egenskapen ej tillgnglig"
;
;Section 5.1: User Interface Related Messages that could be described in
;             user guide's error message appendix
;
;MSG_CantCont,,"Du kommer att f starta om programmet. Vill du fortstta?"
MSG_CantCont,,"Du kommer att f starta om programmet efter redigering.Vill du fortstta?"
MSG_NoMainProg,,"Ingen huvudmodul. Vlj Set Main Module from Run menu to select one"
MSG_HelpOOM,,"Otillrckligt minne fr att visa Hjlp"
;
;Section 5.2: Messages that require special handling in ReportError()
;
;Note: The next 2 messages must have numbers < 256 for because they can be
;      passed to RtError_Ini by exStRunFile during command-line load.
;
MSG_DupMrs,,"Filen redan laddad"
MSG_DupPrs,,"Frskte ladda fil med procedurdefinition som redan finns"
MSG_MrsNotFound,,"Modulen ej funnen. Ska modulen inte laddas in i programmet?"
;
;Section 5.3: General User Interface messages
;
MSG_Overwrite,,"Filen finns redan. Ska den skrivas ver?"
MSG_DelProc,,"Ta bort proceduren frn modulen?"
MSG_MakeRem,,"Blankrader inte tilltna innan SUB/FUNCTION-rad. r kommentar OK?"
MSG_NotSaved,,"Filen ndrad sedan den sist sparades. Ska den sparas nu?"
MSG_NotSavedAll,,"Den aktuella filen har inte sparats. Ska den sparas nu?"
MSG_NotSavedInc,,"Modifierade INCLUDE-filer mste sparas innan krning. Ska de sparas nu?"
MSG_NotSavedIncSav,,"Spara modifierade INCLUDE-filer frst?"
MSG_BadNextStmt,,"Kan inte korsa procedur/modul-grnsen"
MSG_Prt1,,"Vntar p skrivaren"
MSG_Prt2,,"Skriver ut - tryck p ESC om du vill avbryta"
MSG_Immediate,,"Direkt"
MSG_Untitled,,"Namnls"
MSG_FALSE,,"<FALSE>"
MSG_TRUE,,"<TRUE>"
MSG_Black,,"Svart"
MSG_Blue,,"Bl"
MSG_Green,,"Grn"
MSG_Cyan,,"Cyan"
MSG_Red,,"Rd"
MSG_Magenta,,"Magenta"
MSG_Brown,,"Brun"
MSG_White,,"Vit"
MSG_Gray,,"Gr"
MSG_BrBlue,,"LjBl"
MSG_BrGreen,,"LjGrn"
MSG_BrCyan,,"LjCyan"
MSG_BrRed,,"LjRd"
MSG_Pink,,"Skr"
MSG_Yellow,,"Gul"
MSG_BrWhite,,"LjVit"
MSG_MustSpecifyName,,"Mste ange namn"
MSG_DataMoved,,"DATA-satser flyttades frn SUB- till modulniv"
MSG_ModuleExists,,"Modul med det namnet har redan laddats"
MSG_NoHelp,,"Filen "
MSG_NoHelp1,," ej funnen."
MSG_NoHelp2,,"Stt in disketten med denna fil i diskettenheten och frsk igen,"
MSG_NoHelp3,,"eller ndra skvgen med Alternativ+Skvg till Hjlp."
MSG_NoQHelp2,,"Vlj OK och kontrollera att"
MSG_NoQHelp3,,"filen finns i din skvg."
MSG_NoSearchString,,"Mste ange skstrng"
MSG_MatchNotFound,,"Strngen ej funnen"
MSG_ChangeComplete,,"Ersttning klar"
MSG_Is,," r "
MSG_MainModule,,"huvudmodul"
MSG_Module,,"en modul"
MSG_IncludeFile,,"en inkluderad fil"
MSG_Document,,"ett dokument"
MSG_Sub,,"ett delprogram i "
MSG_Function,,"en funktion i "
MSG_ReqSub,,"Operationen krver SUB eller FUNCTION"
;If text of MSG_SwitchDisks changes, ref code in uifile.c must change as well.
MSG_SwitchDisks,,"Stt in disketten i enhet A:"
MSG_Loading,,"Laddar och analyserar"
MSG_Saving,,"Sparar"
MSG_Compiling,,"Binder"
MSG_Searching,,"Sker - tryck p ESC om du vill avbryta"
MSG_CantSetTabs,,"Kan inte stlla in tabblgen medan filen r laddad"
MSG_OutNearMem,,"Slut p datautrymme"
MSG_ModTooLarge,,"Koden fr modulnivn r fr stor"
MSG_ProcTooLarge,,"Proceduren r fr stor"
MSG_ExitToRet,,CR,"Skriv EXIT nr du vill tervnda till QBasic"
MSG_QeditText1,," Stll in frger fr     "
MSG_QeditText2,," textredigeringsfnstret:"
MSG_NormalText,," Normal text       "
MSG_Breakpoint,," Brytpunktsrader   "
MSG_CurStmt,," Aktuell sats      "
MSG_HelpTitle,,"HJLP: "
MSG_HelpTitleQH,,"MS-DOS Hjlp: "
MSG_FirstContextStr,,"h.pg1"
MSG_HelpAboutEditor,,"MS-DOS Editor"
MSG_HelpAboutQHelp,,"MS-DOS Hjlp"
MSG_HelpAboutInterp,,"MS-DOS QBasic"
MSG_HelpAbout2,,"Version 1.1"
MSG_HelpAbout3,,"Copyright (C) Microsoft Corporation, 1987-1993."
;
;Section 5.4: HELP messages for menu items <THESE MUST REMAIN CONTIGUOUS>
;
; NOTE: These must match the EXACT order of the midFileNew...midHelpHowToUse
;       definitions in ..\ir\qbasmsgs.txt, because ..\uq\uictl.c (MainWndProc)
;       does a direct mapping from midXxx to MSG_HelpXxx assuming this
;       ordering exists.
;
MSG_HelpFileNew,,"Tar bort aktuell fil frn minnet"
MSG_HelpFileOpen,,"Laddar in en ny fil i minnet"
MSG_HelpFileMerge,,""
MSG_HelpFileSave,,"Sparar aktuell fil"
MSG_HelpFileSaveAs,,"Sparar aktuell fil med angivet namn"
MSG_HelpFileSaveAll,,""
MSG_HelpFileCreate,,""
MSG_HelpFileLoad,,""
MSG_HelpFileUnload,,""
MSG_HelpFilePrint,,"Skriver ut angiven text"
MSG_HelpFileShell,,""
MSG_HelpFileExit,,"Avslutar Qbasic/Editor och tervnder till DOS"
MSG_HelpFileExitQH,,"Avslutar Hjlp och tervnder till DOS"
MSG_HelpEditUndo,,""
MSG_HelpEditCut,,"Tar bort markerad text och lgger den i Urklipp"
MSG_HelpEditCopy,,"Kopierar markerad text och lgger den i Urklipp"
MSG_HelpEditClear,,"Raderar markerad text utan att lgga den i Urklipp"
MSG_HelpEditPaste,,"Infogar texten i Urklipp dr markren str"
MSG_HelpEditNewSub,,"ppnar ett fnster fr ett nytt delprogram"
MSG_HelpEditNewFunc,,"ppnar ett fnster fr en ny funktion"
MSG_HelpViewSubs,,"Visar laddade funktioner eller delprogram"
MSG_HelpViewNextProc,,""
MSG_HelpViewSplit,,"Vxlar mellan enkelt och dubbelt skrmbildslge"
MSG_HelpViewNextStatement,,""
MSG_HelpViewOutputScreen,,"Visar utdataskrmen"
MSG_HelpViewIncludes,,""
MSG_HelpViewEditIncl,,""
MSG_HelpSearchFind,,"Sker efter text"
MSG_HelpSearchSelected,,""
MSG_HelpSearchNext,,"Sker efter nsta text i tidigare skning"
MSG_HelpSearchChange,,"Sker och erstter text"
MSG_HelpSearchLabel,,""
MSG_HelpRunStart,,"Kr aktuellt program"
MSG_HelpRunRestart,,"Rensar variabler som frberedelse fr stegning"
MSG_HelpRunContinue,,"Fortstter exekveringen efter ett avbrott"
MSG_HelpRunSetCommand,,""
MSG_HelpRunMakeExe,,""
MSG_HelpRunMakeLib,,""
MSG_HelpRunSetMain,,""
MSG_HelpDebugStep,,"Stegar igenom huvudprogram och procedurer"
MSG_HelpDebugPStep,,"Stegar enbart igenom huvudprogram"
MSG_HelpDebugAddWatch,,""
MSG_HelpDebugInstantWatch,,""
MSG_HelpDebugWatchPoint,,""
MSG_HelpDebugDelWatch,,""
MSG_HelpDebugDelAllWatch,,""
MSG_HelpDebugTraceOn,,"Ljusmarkerar den sats som exekveras fr nrvarande"
MSG_HelpDebugHistoryOn,,""
MSG_HelpDebugToggleBp,,"Stter/tar bort en brytpunkt vid markren"
MSG_HelpDebugClearAllBp,,"Tar bort alla brytpunkter"
MSG_HelpDebugBreakOnErr,,""
MSG_HelpDebugSetNextStmt,,"Gr satsen till nsta sats fr exekvering"
MSG_HelpOptionsDisplay,,"ndrar skrmattribut"
MSG_HelpOptionsPaths,,"Stller in skvgen fr hjlpfiler"
MSG_HelpOptionsMouse,,""
MSG_HelpOptionsSyntax,,"Stnger av/stter p syntaxkontroll"
MSG_HelpOptionsFullMenu,,""
MSG_HelpHelpIndex,,"Visar hjlpindex"
MSG_HelpHelpContents,,"Visar innehllsfrteckningen i Hjlp"
MSG_HelpHelpSyntax,,"Visar information om det markerade nyckelordet"
MSG_HelpHelpHelp,,"Visar information om hur man anvnder Hjlp"
MSG_HelpHelpStarted,,"Visar hur man anvnder MS-DOS Editor"
MSG_HelpHelpKeyboard,,"Visar frflyttnings- och redigeringstangenter"
MSG_HelpHelpAbout,,"Visar produktversion och information om copyright"
MSG_HelpHowToUse,,"Visar information om hur man anvnder MS-DOS Hjlp"
;
;Section 5.5: Status line HELP messages <THESE MUST REMAIN CONTIGUOUS>
;
; IMPORTANT:  If the text of ANY of the following messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
; IMPORTANT:  See UINHELP.ASM for a description of how to change the text of
; IMPORTANT:  MSG_Status[Edit, Running, Immediate, Help, ShiftF1].
;
MSG_StatusMenu,,"RETUR=Visa meny   ESC=Avbryt   PIL=Nsta"
MSG_StatusDialog,,"RETUR=Utfr   ESC=Avbryt   TAB=Nsta flt   PIL=Nsta"
MSG_StatusEdit,,"<F6=Fnster><F2=Fnr dlprg><F5=Kr><F8=Stega>"
MSG_StatusRunning,,"<F5=Fortstt><F9=Brytpunkt><F8=Stega>"
MSG_StatusImmediate,,"<F6=Fnster><RETUR=Exekvera rad>"
MSG_StatusHelp,,"<F6=Fnster><ESC=Avbryt><CTRL+F1=Nsta><ALT+F1=Bakt>"
MSG_StatusQEdit,,"MS-DOS Editor <F1=Hjlp> Aktivera menyer med ALT"
MSG_StatusQHelp,,"<F1=Hjlp><F6=Fnster><ESC=Avbryt><CTRL+F1=Nsta><ALT+F1=Bakt>"
MSG_StatusQHStart,,"MS-DOS Hjlp          <F1=Hjlp> Aktivera menyer med ALT"
;
;
MSG_StatusQHhelp,,"<ALT+I=Innehll> <ALT+N=Nsta> <ALT+B=Bakt>"
;
; LOCALIZATION - To change the accelerator chars in the above line, change the
;       the values in rgmpvkeyidQhelp[], in UIRSRCC.C (At about line #460).
;
;
MSG_StatusF1Help,,"F1=Hjlp   "
MSG_StatusShiftF1,,"<SKIFT+F1=Hjlp>"
;
; IMPORTANT:  If the text of ANY of the previous messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
;
;Section 5.6: Variable HELP messages <Some of these must remain contiguous>
;Ripped these out for LQB
;
;Section 5.7: misc messages
;
MSG_SearchPathEdit,,"Skvg fr filen EDIT.HLP:"
MSG_SearchPathHelp,,"Skvg fr filen HELP.HLP:"
MSG_SearchPathInterp,,"Skvg fr filen QBASIC.HLP:"
;
;Section touch: Messages can be added to the bottom of the file
; and all objects except uiutil.obj and qbimsgs.obj can be touched.
; Also touch qbimsgs.rpl, then *.hlp!
; Later, these messages should be moved into their appropriate sections.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qbusa\strings\qbasmsgs.txt ===
; QBasic Standard Error Messages.
; This file is read by the tool makemsgs, which produces the files:
;      qbimsgs.asm, qbimsgs.inc, and qbimsgs.h
;
; Entries in this file have the form:
;  [<symbol's name>,[<msg index/error code>],"<ASCII msg>"] [;<comment>]
;
; If <msg index/error code> is not specified, the next available one
;    is assigned.
;
;Section 1:  Runtime Errors - symbol names are kept small to decrease
;            the size of the runtime library.
;            Names begin with ER_ to distinguish them from non-runtime
;            errors, which begin with MSG_.
;
;NOTE: A *BLANK* line terminates MAKEMSG.  Do not add blank lines!
;
;
ER_NF,1,"NEXT without FOR"
ER_SN,2,"Syntax error"
ER_RG,3,"RETURN without GOSUB"
ER_OD,4,"Out of DATA"
ER_FC,5,"Illegal function call"
ER_OV,6,"Overflow"
ER_OM,7,"Out of memory"
ER_UL,8,"Label not defined"
ER_SOR,9,"Subscript out of range"
ER_DD,10,"Duplicate definition"
ER_DV0,11,"Division by zero"
ER_ID,12,"Illegal in direct mode"
ER_TM,13,"Type mismatch"
ER_OS,14,"Out of string space"
;15 is unused
ER_BS,16,"String formula too complex"
ER_CN,17,"Cannot continue"
ER_UF,18,"Function not defined"
ER_NR,19,"No RESUME"
ER_RE,20,"RESUME without error"
;21 is unused
;22 is unused
;23 is unused
ER_DTO,24,"Device timeout"
ER_DF,25,"Device fault"
ER_FN,26,"FOR without NEXT"
ER_OP,27,"Out of paper"
;28 is unused
ER_WH,29,"WHILE without WEND"
ER_WE,30,"WEND without WHILE"
;31 is unused
;32 is unused
ER_DL,33,"Duplicate label"
;34 is unused
ER_US,35,"Subprogram not defined"
;; ER_SIU,36,"Subprogram already in use"  ;dead after recursion added
ER_AC,37,"Argument-count mismatch"
ER_UA,38,"Array not defined"
ER_CaseElse,39,"CASE ELSE expected"
ER_VarReq,40,"Variable required"
;41 is unused
;42 is unused
;43 is unused
;44 is unused
;45 is unused
;46 is unused
;47 is unused
;48 is unused
;49 is unused
ER_FOV,50,"FIELD overflow"
ER_IER,51,"Internal error"
ER_BFN,52,"Bad file name or number"
ER_FNF,53,"File not found"
ER_BFM,54,"Bad file mode"
ER_FAO,55,"File already open"
ER_FSA,56,"FIELD statement active"
ER_IOE,57,"Device I/O error"
ER_FAE,58,"File already exists"
ER_BRL,59,"Bad record length"
;60 is unused
ER_DFL,61,"Disk full"
ER_RPE,62,"Input past end of file"
ER_BRN,63,"Bad record number"
ER_IFN,64,"Bad file name"
;65 is unused
;66 is unused	- used to be ER_FDR - Direct statement in file
ER_TMF,67,"Too many files"
ER_DNA,68,"Device unavailable"
ER_CBO,69,"Communication-buffer overflow"
ER_PRM,70,"Permission denied"
ER_DNR,71,"Disk not ready"
ER_DME,72,"Disk-media error"
ER_ADF,73,"Advanced feature unavailable"
ER_RAD,74,"Rename across disks"
ER_PAE,75,"Path/File access error"
ER_PNF,76,"Path not found"
;;;ER_DLK,77,"Deadlock" ;not needed until OS/2 version
;
; The following ER_UE marks the last trappable Runtime Error Code
;
ER_UE,,"Unprintable error"
;
;=========================================================================
; Subsequent ER_ messages are special, and are intimately tied in with
; the runtime message file, messages.inc.
; Some of these errors are considered "very fatal", and cause termination;
; others are not errors at all - - we just supply the text for some runtime
; messages here.
; These messages must remain contiguous and in the same order, unless
; a matching change is made in messages.inc.
;
; First group of internal errors - - these are actually runtime messages,
; not errors
; Any message that begins ER_UL is used in constructing a message
; as follows:
;  Error in loading (file) - Internal error
;
ER_RFS,,"Redo from start"
ER_BFC,,"Bytes free",CR		;'CR' means terminate with a Carriage Return
ER_ULP,,"Cannot find file ("	;preamble for user file path prompt
ER_ULT,,"). Input path: "	;postamble for user file path prompt
ER_ULE,,"Error in loading file (" ;preamble for loader errors
ER_ULG,,") - "			;postamble for loader errors
ER_RNS,,"Random-number seed (-32768 to 32767)"
ER_HRS,,"Press any key to continue" ;Displayed when errors occurr in QBC exec.
;
; Second group of internal errors - these are "very fatal"
ER_SSC,,"String space corrupt"	;string space or local heap trashed somehow
ER_ULD,,"Disk I/O error"	;problem in loading U.L. from disk
ER_ULI,,"Invalid format"	;attempt to load a U.L. with incorrect format
ER_ULF,,"Cannot find file"	;redirected IO and cannot find file in path
;
; Third group of internal errors - these are also "very fatal"
ER_D21,,"Requires DOS 2.10 or later"
ER_INI,,"Error during QBasic initialization" ;error in initializing runtime
ER_ULO,,"Out of memory"		;out of memory loading U.L.
ER_DMA,,"DOS memory-arena error" ;someone walked on DOS-owned memory
ER_FHC,,"Far heap corrupt"	;similar to string space corrupt
ER_ULM,,"Internal error"	;U.L. loading found a bad segment address
;
; QB-specific internal errors - these are "very fatal"
; NOTE: These must come after other internal errors (no equivalent in
;	messages.inc)
;
;Both groups of the command line help message must remain contiguous.
;They must start with the label ER_ISWEDIT/ER_ISWHELP/ER_ISWINTERP and end
;with the label ER_ISWEDITEND/ER_ISWHELPEND/ERISWINTERPEND.  The labels of the
;intermediate lines does not matter.
;
ER_ISWEDIT,,"Starts the MS-DOS Editor, which creates and changes ASCII files."
ER_ISWEDIT1,," "
ER_ISWEDIT2,,"EDIT [[drive:][path]filename] [/B] [/G] [/H] [/NOHI]"
ER_ISWEDIT3,," "
ER_ISWEDIT4,,"  [drive:][path]filename  Specifies the ASCII file to edit."
ER_ISWEDIT5,,"  /B          Allows use of a monochrome monitor with a color graphics card."
ER_ISWEDIT6,,"  /G          Provides the fastest update of a CGA screen."
ER_ISWEDIT7,,"  /H          Displays the maximum number of lines possible for your hardware."
ER_ISWEDITEND,,"  /NOHI       Allows the use of a monitor without high-intensity support."
;
ER_ISWQHELP,,"Starts MS-DOS Help on MS-DOS commands."
ER_ISWQHELP1,," "
ER_ISWQHELP2,,"HELP [/B] [/G] [/H] [/NOHI] [topic]"
ER_ISWQHELP3,," "
ER_ISWQHELP4,,"  /B          Allows use of a monochrome monitor with a color graphics card."
ER_ISWQHELP5,,"  /G          Provides the fastest update of a CGA screen."
ER_ISWQHELP6,,"  /H          Displays the maximum number of lines possible for your hardware."
ER_ISWQHELP7,,"  /NOHI       Allows the use of a monitor without high-intensity support."
ER_ISWQHELPEND,,"  [topic]     Specifies the help topic to view."
;
ER_ISWINTERP,,"Starts the MS-DOS QBasic programming environment."
ER_ISWINTERP1,," "
ER_ISWINTERP2,,"QBASIC [/B] [/EDITOR] [/G] [/H] [/MBF] [/NOHI] [[/RUN] [drive:][path]filename]"
ER_ISWINTERP3,," "
ER_ISWINTERP4,,"  /B          Allows use of a monochrome monitor with a color graphics card."
ER_ISWINTERP5,,"  /EDITOR     Starts the MS-DOS Editor."
ER_ISWINTERP6,,"  /G          Provides the fastest update of a CGA screen."
ER_ISWINTERP7,,"  /H          Displays the maximum number of lines possible for your hardware."
ER_ISWINTERP8,,"  /MBF        Converts the built-in functions MKS$, MKD$, CVS, and CVD to"
ER_ISWINTERP9,,"              MKSMBF$, MKDMBF$, CVSMBF, and CVDMBF, respectively."
ER_ISWINTERPA,,"  /NOHI       Allows the use of a monitor without high-intensity support."
ER_ISWINTERPB,,"  /RUN        Runs the specified Basic program before displaying it."
ER_ISWINTERPEND,,"  [[drive:][path]filename] Specifies the program file to load or run."
;
;=========================================================================
;
;-------------------------------------------------------------------------
;MSG_GoDirect is non-trappable interpreter-specific
; error which allow us to back out of what we're doing and escape back
; to direct mode.
;
MSG_GoDirect,,""
MSG_OutOfStack,,"Out of stack space"
MSG_DocTooLarge,,"Document too large"
MSG_InclTooLarge,,"Include file too large"
;
;-------------------------------------------------------------------------
; End of runtime errors.  Messages beyond this point can be re-arranged
; in any order.
;-------------------------------------------------------------------------
;
;Section 2: QBI Parser Related Messages
;
MSG_IdTooLong,,"Identifier too long"
MSG_BadId,,"Invalid identifier"
MSG_IdImp,,"Identifier cannot end with %, &, !, #, or $"
MSG_BadElemRef,,"Identifier cannot include period"
MSG_ExpTooComplex,,"Expression too complex"
MSG_IllegalNumber,,"Illegal number"
MSG_InvConst,,"Invalid constant"
MSG_expected,,"Expected: "
MSG_or,," or "
;
; Parser errors which are preceded by "Expected: "
;
MSG_ExpAssignment,,"variable=expression"
MSG_ExpExp,,"expression"
MSG_ExpVar,,"variable"
MSG_ExpId,,"identifier"
MSG_ExpStatement,,"statement"
MSG_ExpLabel,,"label"
MSG_ExpLn,,"line number"
MSG_Letter,,"letter"
MSG_eos,,"end-of-statement"
MSG_RightParen,,")"
MSG_ExpIdCallArg,,"expression"
MSG_ExpIdParm,,"variable"
MSG_ExpFNId,,"identifier that begins with FN"
MSG_ExpIfClause,,"label or statement"
MSG_ExpLabLn,,"label or line number"
MSG_ExpLitString,,"string constant"
MSG_ExpLit0,,"0"
MSG_ExpLit1,,"1"
MSG_ExpNArgs,,"[expression],..."
MSG_ExpRwB,,"B"
MSG_ExpRwF,,"F"
MSG_ExpRwBF,,"BF"
MSG_ExpRel,,"<, <=, >, >=, =, or <>"
;
;Section 3:  TextMgr/ReParse errors
;
MSG_InvModLev,,"Illegal outside of SUB, FUNCTION or DEF FN"
MSG_InvMain,,"Illegal outside of SUB/FUNCTION"
MSG_InvProc,,"Illegal in procedure or DEF FN"
MSG_InvBeforeProcDef,,"Statement cannot precede SUB/FUNCTION definition"
MSG_ProcNoEnd,,"SUB/FUNCTION without END SUB/FUNCTION"
MSG_EndNoProc,,"END SUB/FUNCTION without SUB/FUNCTION"
MSG_EndNoDef,,"END DEF without DEF"
MSG_UndElem,,"Element not defined"
MSG_UndType,,"Type not defined"
MSG_1stStmt,,"Must be first statement on the line"
MSG_EndProc,,"END SUB or END FUNCTION must be last line in window"
MSG_NoEndType,,"TYPE without END TYPE"
MSG_NoType,,"END TYPE without TYPE"
MSG_InvInTypeBlk,,"Statement illegal in TYPE block"
MSG_InvIncl,,"Statement cannot occur within INCLUDE file"
MSG_InvDecl,,"Invalid DECLARE for Basic procedure"
MSG_FNstart,,"Cannot start with 'FN'"
MSG_NotBlock,,"Operation requires disk"
MSG_BadMeta,,"$Metacommand error"
MSG_NoBpCase,,"Breakpoints not allowed on CASE clauses or END SELECT"
;
;Section 4:  Scan-time errors
;
MSG_OBA,,"Array already dimensioned"
MSG_COM,,"COMMON and DECLARE must precede executable statements"
MSG_EWI,,"END IF without block IF"
MSG_IWE,,"Block IF without END IF"
MSG_ElseWI,,"ELSE without IF"
MSG_ExitScope,,"EXIT not within FOR...NEXT"
MSG_ExitDo,,"EXIT DO not within DO...LOOP"
MSG_Do,,"DO without LOOP"
MSG_Loop,,"LOOP without DO"
MSG_Select,,"SELECT without END SELECT"
MSG_Case,,"CASE without SELECT"
MSG_EndSelect,,"END SELECT without SELECT"
MSG_InvFixStr,,"Fixed-length string illegal"
MSG_InvTypedVar,,"Typed variable not allowed in expression"
MSG_DefNoEnd,,"DEF without END DEF"
MSG_ParmTM,,"Parameter type mismatch"
MSG_DupLibPrs,,"Procedure already defined in Quick library"
MSG_ASRqd1st,,"AS clause required on first declaration"
MSG_ASRqd,,"AS clause required"
MSG_ExpectedCase,,"Statements/labels illegal between SELECT CASE and CASE"
MSG_NoNumArr,,"Numeric array illegal"
MSG_InType,,"Illegal outside of TYPE block"
MSG_ULCom,,"COMMON in Quick library too small"
MSG_SubCnt,,"Wrong number of dimensions"
MSG_DefFnCtrl,,"DEF FN not allowed in control statements"
MSG_Unsupported,,"This feature is unavailable"
;
;Section 5.1: User Interface Related Messages that could be described in
;	      user guide's error message appendix
;
MSG_CantCont,,"You will have to restart your program after this edit. Proceed anyway?"
MSG_NoMainProg,,"No main module. Choose Set Main Module from Run menu to select one"
MSG_HelpOOM,,"Insufficient memory to display Help"
;
;Section 5.2: Messages that require special handling in ReportError()
;
;Note: The next 2 messages must have numbers < 256 for because they can be
;      passed to RtError_Ini by exStRunFile during command-line load.
;
MSG_DupMrs,,"File previously loaded"
MSG_DupPrs,,"Tried to load file with duplicate procedure definition"
MSG_MrsNotFound,,"Module not found. Unload module from program?"
;
;Section 5.3: General User Interface messages
;
MSG_Overwrite,,"File already exists. Overwrite?"
MSG_DelProc,,"Delete procedure from module?"
MSG_MakeRem,,"Blank lines not allowed before SUB/FUNCTION line.  Is remark OK?"
MSG_NotSaved,,"File has been modified since last saved. Save it now?"
MSG_NotSavedAll,,"Loaded file is not saved. Save it now?"
MSG_NotSavedInc,,"Modified INCLUDE files must be saved before running. Save them now?"
MSG_NotSavedIncSav,,"Save modified INCLUDE files first?"
MSG_BadNextStmt,,"Cannot cross procedure/module boundary"
MSG_Prt1,,"Waiting for printer"
MSG_Prt2,,"Printing - press Esc to cancel"
MSG_Immediate,,"Immediate"
MSG_Untitled,,"Untitled"
MSG_FALSE,,"<FALSE>"
MSG_TRUE,,"<TRUE>"
MSG_Black,,"Black"
MSG_Blue,,"Blue"
MSG_Green,,"Green"
MSG_Cyan,,"Cyan"
MSG_Red,,"Red"
MSG_Magenta,,"Magenta"
MSG_Brown,,"Brown"
MSG_White,,"White"
MSG_Gray,,"Gray"
MSG_BrBlue,,"BrBlue"
MSG_BrGreen,,"BrGreen"
MSG_BrCyan,,"BrCyan"
MSG_BrRed,,"BrRed"
MSG_Pink,,"Pink"
MSG_Yellow,,"Yellow"
MSG_BrWhite,,"BrWhite"
MSG_MustSpecifyName,,"Must specify name"
MSG_DataMoved,,"DATA statements were moved from SUB to module level"
MSG_ModuleExists,,"Module with that name is already loaded"
MSG_NoHelp,,"File "
MSG_NoHelp1,," not found."
MSG_NoHelp2,,"Put the floppy disk with this file into the drive and"
MSG_NoHelp3,,"Retry, or change your Help path in Options+Help Path."
MSG_NoQHelp2,,"Choose OK, and then make sure the"
MSG_NoQHelp3,,"file is in your PATH."
MSG_NoSearchString,,"Must specify search string"
MSG_MatchNotFound,,"Match not found"
MSG_ChangeComplete,,"Change complete"
MSG_Is,," is "
MSG_MainModule,,"the Main Module"
MSG_Module,,"a Module"
MSG_IncludeFile,,"an Include File"
MSG_Document,,"a Document"
MSG_Sub,,"a SUB in "
MSG_Function,,"a FUNCTION in "
MSG_ReqSub,,"Operation requires selection of a SUB or FUNCTION"
;If text of MSG_SwitchDisks changes, ref code in uifile.c must change as well.
MSG_SwitchDisks,,"Insert Diskette for drive A:"
MSG_Loading,,"Loading and parsing"
MSG_Saving,,"Saving"
MSG_Compiling,,"Binding"
MSG_Searching,,"Searching - press Esc to cancel"
MSG_CantSetTabs,,"Cannot change tab stops while file is loaded"
MSG_OutNearMem,,"Out of data space"
MSG_ModTooLarge,,"Module level code too large"
MSG_ProcTooLarge,,"Procedure too large"
MSG_ExitToRet,,CR,"Type EXIT to return to QBasic"
MSG_QeditText1,," Set colors for the "
MSG_QeditText2,," text editor window:"
MSG_NormalText,," Normal Text       "
MSG_Breakpoint,," Breakpoint Lines  "
MSG_CurStmt,," Current Statement "
MSG_HelpTitle,,"HELP: "
MSG_HelpTitleQH,,"MS-DOS Help: "
MSG_FirstContextStr,,"h.pg1"
MSG_HelpAboutEditor,,"MS-DOS Editor"
MSG_HelpAboutQHelp,,"MS-DOS Help"
MSG_HelpAboutInterp,,"MS-DOS QBasic"
MSG_HelpAbout2,,"Version 1.1"
MSG_HelpAbout3,,"Copyright (C) Microsoft Corporation, 1987-1992."
;
;Section 5.4: HELP messages for menu items <THESE MUST REMAIN CONTIGUOUS>
;
; NOTE: These must match the EXACT order of the midFileNew...midHelpHowToUse
;	definitions in ..\ir\qbasmsgs.txt, because ..\uq\uictl.c (MainWndProc)
;	does a direct mapping from midXxx to MSG_HelpXxx assuming this
;	ordering exists.
;
MSG_HelpFileNew,,"Removes currently loaded file from memory"
MSG_HelpFileOpen,,"Loads new file into memory"
MSG_HelpFileMerge,,""
MSG_HelpFileSave,,"Saves current file"
MSG_HelpFileSaveAs,,"Saves current file with specified name"
MSG_HelpFileSaveAll,,""
MSG_HelpFileCreate,,""
MSG_HelpFileLoad,,""
MSG_HelpFileUnload,,""
MSG_HelpFilePrint,,"Prints specified text"
MSG_HelpFileShell,,""
MSG_HelpFileExit,,"Exits editor and returns to DOS"
MSG_HelpFileExitQH,,"Exits MS-DOS Help and returns to DOS"
MSG_HelpEditUndo,,""
MSG_HelpEditCut,,"Deletes selected text and copies it to buffer"
MSG_HelpEditCopy,,"Copies selected text to buffer"
MSG_HelpEditClear,,"Deletes selected text without copying it to buffer"
MSG_HelpEditPaste,,"Inserts buffer contents at current location"
MSG_HelpEditNewSub,,"Opens a window for a new subprogram"
MSG_HelpEditNewFunc,,"Opens a window for a new FUNCTION procedure"
MSG_HelpViewSubs,,"Displays a loaded SUB or FUNCTION"
MSG_HelpViewNextProc,,""
MSG_HelpViewSplit,,"Divides screen into two View windows"
MSG_HelpViewNextStatement,,""
MSG_HelpViewOutputScreen,,"Displays output screen"
MSG_HelpViewIncludes,,""
MSG_HelpViewEditIncl,,""
MSG_HelpSearchFind,,"Finds specified text"
MSG_HelpSearchSelected,,""
MSG_HelpSearchNext,,"Finds next occurrence of text specified in previous search"
MSG_HelpSearchChange,,"Finds and changes specified text"
MSG_HelpSearchLabel,,""
MSG_HelpRunStart,,"Runs current program"
MSG_HelpRunRestart,,"Clears variables in preparation for restarting single stepping"
MSG_HelpRunContinue,,"Continues execution after a break"
MSG_HelpRunSetCommand,,""
MSG_HelpRunMakeExe,,""
MSG_HelpRunMakeLib,,""
MSG_HelpRunSetMain,,""
MSG_HelpDebugStep,,"Executes next program statement"
MSG_HelpDebugPStep,,"Executes next program statement, tracing over procedure calls"
MSG_HelpDebugAddWatch,,""
MSG_HelpDebugInstantWatch,,""
MSG_HelpDebugWatchPoint,,""
MSG_HelpDebugDelWatch,,""
MSG_HelpDebugDelAllWatch,,""
MSG_HelpDebugTraceOn,,"Highlights statement currently executing"
MSG_HelpDebugHistoryOn,,""
MSG_HelpDebugToggleBp,,"Sets/clears breakpoint at cursor location"
MSG_HelpDebugClearAllBp,,"Removes all breakpoints"
MSG_HelpDebugBreakOnErr,,""
MSG_HelpDebugSetNextStmt,,"Makes the statement at the cursor the next statement to execute"
MSG_HelpOptionsDisplay,,"Changes display attributes"
MSG_HelpOptionsPaths,,"Sets search path for Help files"
MSG_HelpOptionsMouse,,""
MSG_HelpOptionsSyntax,,"Turns editor's syntax checking on or off."
MSG_HelpOptionsFullMenu,,""
MSG_HelpHelpIndex,,"Displays help index"
MSG_HelpHelpContents,,"Displays help table of contents"
MSG_HelpHelpSyntax,,"Displays information about the Basic keyword the cursor is on"
MSG_HelpHelpHelp,,"Displays information about how to use online Help"
MSG_HelpHelpStarted,,"Displays information on loading and using the MS-DOS Editor"
MSG_HelpHelpKeyboard,,"Displays navigation and editing keystrokes"
MSG_HelpHelpAbout,,"Displays product version and copyright information"
MSG_HelpHowToUse,,"Displays information on using MS-DOS Help"
;
;Section 5.5: Status line HELP messages <THESE MUST REMAIN CONTIGUOUS>
;
; IMPORTANT:  If the text of ANY of the following messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
; IMPORTANT:  See UINHELP.ASM for a description of how to change the text of
; IMPORTANT:  MSG_Status[Edit, Running, Immediate, Help, ShiftF1].
;
MSG_StatusMenu,,"Enter=Display Menu   Esc=Cancel   Arrow=Next Item"
MSG_StatusDialog,,"Enter=Execute   Esc=Cancel   Tab=Next Field   Arrow=Next Item"
MSG_StatusEdit,,"<F6=Window> <F2=Subs> <F5=Run> <F8=Step>"
MSG_StatusRunning,,"<F5=Continue> <F9=Toggle Bkpt> <F8=Step>"
MSG_StatusImmediate,,"<F6=Window> <Enter=Execute Line>"
MSG_StatusHelp,,"<F6=Window> <Esc=Cancel> <Ctrl+F1=Next> <Alt+F1=Back>"
MSG_StatusQEdit,,"MS-DOS Editor  <F1=Help> Press ALT to activate menus"
MSG_StatusQHelp,,"<F1=Help> <F6=Window> <Esc=Cancel> <Ctrl+F1=Next> <Alt+F1=Back>"
MSG_StatusQHStart,,"MS-DOS Help         <F1=Help> Press ALT to activate menus"
;
;
MSG_StatusQHhelp,,"<Alt+C=Contents> <Alt+N=Next> <Alt+B=Back>"
;
; LOCALIZATION - To change the accelerator chars in the above line, change the
;       the values in rgmpvkeyidQhelp[], in UIRSRCC.C (At about line #460).
;
;
MSG_StatusF1Help,,"F1=Help   "
MSG_StatusShiftF1,,"<Shift+F1=Help> "
;
; IMPORTANT:  If the text of ANY of the previous messages changes, the
; IMPORTANT:  constants used by DoStatusButton() in UINHELP.ASM must be updated!
;
;Section 5.6: Variable HELP messages <Some of these must remain contiguous>
;Ripped these out for LQB
;
;Section 5.7: misc messages
;
MSG_SearchPathEdit,,"Location (path) of EDIT.HLP file:"
MSG_SearchPathHelp,,"Location (path) of HELP.HLP file:"
MSG_SearchPathInterp,,"Location (path) of QBASIC.HLP file:"
;
;Section touch: Messages can be added to the bottom of the file
; and all objects except uiutil.obj and qbimsgs.obj can be touched.
; Also touch qbimsgs.rpl, then *.hlp!
; Later, these messages should be moved into their appropriate sections.

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\bin\c1.err ===
/* SCCSWHAT( "@(#)c1.err	2.29 88/02/25 18:18:00	" ) */
						/* fatals */

1001	"Internal Compiler Error\n\t\t(compiler file '%s', line %d)\n\t\tContact Microsoft Technical Support"
1002	"out of heap space"
1003	"error count exceeds %d; stopping compilation"
1004	"unexpected EOF"
1005	"string too big for buffer"
1006	"write error on compiler intermediate file"
1007	"unrecognized flag '%s' in '%s'"
1008	"no input file specified"
1009	"compiler limit : macros too deeply nested"
1010	"compiler limit : macro expansion too big"
1012	"bad parenthesis nesting - missing '%c'"
1013	"cannot open source file '%s'"
1014	"too many include files"
1015	"cannot open include file '%s'"
1016	"#if[n]def expected an identifier"
1017	"invalid integer constant expression"
1018	"unexpected '#elif'"
1019	"unexpected '#else'"
1020	"unexpected '#endif'"
1021	"bad preprocessor command '%s'"
1022	"expected '#endif'"
1023	"no int size specified"
1024	"no ptr size specified"
1025	"no function size specified"
1026	"parser stack overflow, please simplify your program"
1027	"DGROUP data allocation exceeds 64K"	/* QC, c23 */
1028	"%s segment allocation exceeds 64K"	/* QC */
1031	"compiler limit : function calls too deeply nested"	/* QC, c23 */
1032	"cannot open object listing file '%s'"			/* QC, c23 */
1035	"expression too complex, please simplify"		/* QC, c23 */
1037	"cannot open object file '%s'"					/* QC, c23 */
1041	"cannot open compiler intermediate file - no more files"
1042	"cannot open compiler intermediate file - no such file or directory"
1043	"cannot open compiler intermediate file"
1044	"out of disk space for compiler intermediate file"
1045	"floating point overflow"
1047	"too many %s flags, '%s'"
1048	"unknown option '%c' in '%s'"
1049	"invalid numerical argument '%s'"
1052	"too many #if/#ifdef's"
1053	"compiler limit : struct/union nesting"
1054	"compiler limit : initializers too deeply nested"
1055	"compiler limit : out of keys"
1056	"compiler limit : out of macro expansion space"
1057	"unexpected EOF in macro expansion (missing ')'?)"
1059	"out of near heap space"
1060	"out of far heap space"
1061	"compiler limit : blocks too deeply nested"	/* QC */
1062	"error writing to preprocessor output file"
1063	"compiler limit : compiler stack overflow"	/* QC */
1064	"compiler limit : identifier overflowed internal buffer"
1065	"compiler limit : declarator too complex"
1000	"UNKNOWN FATAL ERROR\n\t\tContact Microsoft Technical Support"

						/* errors */
	
2001	"newline in constant"
2002	"out of macro actual parameter space"
2003	"expected 'defined id'"
2004	"expected 'defined(id)'"
2005	"#line expected a line number, found '%s'"
2006	"#include expected a file name, found '%s'"
2007	"#define syntax"
2008	"'%c' : unexpected in macro definition"
2009	"reuse of macro formal '%s'"
2010	"'%c' : unexpected in formal list"
2011	"'%s' : definition too big"
2012	"missing name following '<'"
2013	"missing '>'"
2014	"preprocessor command must start as first non-whitespace"
2015	"too many chars in constant"
2016	"no closing single quote"
2017	"illegal escape sequence"
2018	"unknown character '0x%x'"
2019	"expected preprocessor command, found '%c'"
2020	"bad octal number '%c'"
2021	"expected exponent value, not '%c'"
2022	"'%ld' : too big for char"
2023	"divide by 0"
2024	"mod by 0"
2025	"'%s' : enum/struct/union type redefinition"
2026	"'%s' : member of enum redefinition"
2028	"struct/union member needs to be inside a struct/union"
2029	"'%Fs' : bit-fields only allowed in structs"
2030	"'%Fs' : struct/union member redefinition"
2031	"'%Fs' : function cannot be struct/union member"
2032	"'%Fs' : base type with near/far/huge not allowed"
2033	"'%Fs' : bit-field cannot have indirection"
2034	"'%Fs' : bit-field type too small for number of bits"
2035	"enum/struct/union '%Fs' : unknown size"
2036	"left of '%s%s' must have a struct/union type"
2037	"left of '%s' specifies undefined struct/union '%Fs'"
2038	"'%s' : not struct/union member"
2039	"'->' requires struct/union pointer"
2040	"'.' requires struct/union name"
2042	"signed/unsigned keywords mutually exclusive"
2043	"illegal break"
2044	"illegal continue"
2045	"'%s' : label redefined"
2046	"illegal case"
2047	"illegal default"
2048	"more than one default"
2050	"non-integral switch expression"
2051	"case expression not constant"
2052	"case expression not integral"
2053	"case value %d already used"
2054	"expected '(' to follow '%Fs'"
2055	"expected formal parameter list, not a type list"
2056	"illegal expression"
2057	"expected constant expression"
2058	"constant expression is not integral"
2059	"syntax error : '%s'"
2060	"syntax error : EOF"
2061	"syntax error : identifier '%s'"
2062	"type '%s' unexpected"
2063	"'%s' : not a function"
2064	"term does not evaluate to a function"
2065	"'%s' : undefined"
2066	"cast to function returning . . . is illegal"
2067	"cast to array type is illegal"
2068	"illegal cast"
2069	"cast of 'void' term to non-void"
2070	"illegal sizeof operand"
2071	"'%Fs' : bad storage class"
2072	"'%Fs' : initialization of a function"
2073	"'%Fs' : cannot initialize array in function"
2074	"'%Fs' : cannot initialize struct/union in function"
2075	"'%Fs' : array initialization needs curly braces"
2076	"'%Fs' : struct/union initialization needs curly braces"
2077	"non-integral field initializer '%Fs'"
2078	"too many initializers"
2079	"'%Fs' uses undefined struct/union '%Fs'"
2082	"redefinition of formal parameter '%Fs'"
2083	"array '%Fs' already has a size"
2084	"function '%Fs' already has a body"
2085	"'%Fs' : not in formal parameter list"
2086	"'%Fs' : redefinition"
2087	"'%Fs' : missing subscript"
2088	"use of undefined enum/struct/union '%s'"
2089	"typedef specifies a near/far function"
2090	"function returns array"
2091	"function returns function"
2092	"array element type cannot be function"
2093	"cannot initialize a static or struct with address of automatic vars"
2094	"label '%Fs' was undefined"
2095	"'%Fs' : actual has type void : parameter %d"
2096	"struct/union comparison illegal"
2097	"illegal initialization"
2098	"non-address expression"
2099	"non-constant offset"
2100	"illegal indirection"
2101	"'&' on constant"
2102	"'&' requires lvalue"
2103	"'&' on register variable"
2104	"'&' on bit-field ignored"
2105	"'%s' needs lvalue"
2106	"'%s' : left operand must be lvalue"
2107	"illegal index, indirection not allowed"
2108	"non-integral index"
2109	"subscript on non-array"
2110	"'+' : 2 pointers"
2111	"pointer + non-integral value"
2112	"illegal pointer subtraction"
2113	"'-' : right operand pointer"
2114	"'%s' : pointer on left; needs integral right"
2115	"'%s' : incompatible types"
2116	"'%s' : bad %s operand"
2117	"'%s' : illegal for struct/union"
2118	"negative subscript"
2119	"'typedefs' both define indirection"
2120	"'void' illegal with all types"
2121	"typedef specifies different enum"
2122	"typedef specifies different struct"
2123	"typedef specifies different union"
2125	"%Fs : allocation exceeds 64K"		/* QC, c23 */
2126	"%Fs : auto allocation exceeds %s"	/* QC, c23 */
2127	"parameter allocation exceeds 32K"	/* QC, c23 */
2130	"#line expected a string containing the file name, found '%s'"
2131	"attributes specify more than one near/far/huge"
2132	"syntax error : unexpected identifier"
2133	"array '%Fs' : unknown size"
2134	"'%Fs' : struct/union too large"
2135	"missing ')' in macro expansion"
2137	"empty character constant"
2138	"unmatched close comment '*/'"
2139	"type following '%s' is illegal"
2140	"argument type cannot be function returning . . ."
2141	"value out of range for enum constant"
2142	"ellipsis requires three periods"
2143	"syntax error : missing '%s' before '%s'"
2144	"syntax error : missing '%s' before type '%Fs'"
2145	"syntax error : missing '%s' before identifier"
2146	"syntax error : missing '%s' before identifier '%s'"
2147	"unknown size"
2148	"array too large"
2149	"'%Fs' : named bit-field cannot have 0 width"
2150	"'%Fs' : bit-field must have type int, signed int, or unsigned int"
2151	"more than one cdecl/fortran/pascal attribute specified"
2152	"'%s' : pointers to functions with different attributes"
2153	"hex constants must have at least 1 hex digit"
2154	"'%s' : does not refer to a segment"
2155	"'%s' : already in a segment"
2156	"pragma must be at outer level"
2157	"'%s' : must be declared before use in pragma list"
2158	"'%s' : is a function"
2159	"more than one storage class specified"
2160	"## cannot occur at the beginning of a macro definition"
2161	"## cannot occur at the end of a macro definition"
2162	"expected macro formal parameter"
2163	"'%s' : not available as an intrinsic"
2164	"'%s' : intrinsic was not declared"
2165	"'%s' : cannot modify pointers to data"
2166	"lval specifies 'const' object"
2167	"'%Fs' : too many actual parameters for intrinsic"
2168	"'%Fs' : too few actual parameters for intrinsic"
2169	"'%Fs' : is an intrinsic, it cannot be defined"
2170	"'%s' : intrinsic not declared as a function"
2171	"'%s' : bad operand"
2172	"'%Fs' : actual is not a pointer : parameter %d"
2173	"'%Fs' : actual is not a pointer : parameter %d, parameter list %d"
2174	"'%Fs' : actual has type void : parameter %d, parameter list %d"
2175	"'%Fs' : unresolved external"	/* QC */
2176	"static far data not supported"	/* QC */
2177	"constant too big"
2178	"'%s' : storage class for same_seg variables must be 'extern'"
2179	"'%Fs' : was used in same_seg, but storage class is no longer 'extern'"
2180	"controlling expression has type 'void'"
2181	"pragma requires command line option '%s'"	/* QC */
2182	"'%Fs' : 'void' on variable"
2183	"'%Fs' : 'interrupt' function must be 'far'"
2184	"'%Fs' : '%s' function cannot be 'pascal/fortran'"
2186	"'%Fs' : 'saveregs/interrupt' modifiers mutually exclusive"
2187	"cast of near function pointer to far function pointer"
2188	"#error : %s"
2190	"'%s' : is a text segment"
2191	"'%s' : is a data segment"
2192	"'%s' : function has already been defined"
2000	"UNKNOWN ERROR\n\t\tContact Microsoft Technical Support"

						/* warnings */
	
4001	"macro '%s' requires parameters"
4002	"too many actual parameters for macro '%s'"
4003	"not enough actual parameters for macro '%s'"
4004	"missing close parenthesis after 'defined'"
4005	"'%s' : redefinition"
4006	"#undef expected an identifier"
4009	"string too big, trailing chars truncated"
4011	"identifier truncated to '%s'"
4012	"float constant in a cross compilation"
4013	"constant too big"
4014	"'%Fs' : bit-field type must be unsigned"
4015	"'%Fs' : bit-field type must be integral"
4016	"'%s' : no function return type, using 'int' as default"
4017	"cast of int expression to far pointer"
4020	"'%Fs' : too many actual parameters"
4021	"'%Fs' : too few actual parameters"
4022	"'%Fs' : pointer mismatch : parameter %d"
4024	"'%Fs' : different types : parameter %d"
4025	"function declaration specified variable argument list"
4026	"function was declared with formal argument list"
4027	"function was declared without formal argument list"
4028	"parameter %d declaration different"
4029	"declared parameter list different from definition"
4030	"first parameter list is longer than the second"
4031	"second parameter list is longer than the first"
4032	"unnamed struct/union as parameter"
4033	"function must return a value"
4034	"sizeof returns 0"
4035	"'%Fs' : no return value"
4036	"unexpected formal parameter list"
4037	"'%Fs' : formal parameters ignored"
4038	"'%Fs' : formal parameter has bad storage class"
4039	"'%Fs' : function used as an argument"
4040	"near/far/huge on '%Fs' ignored"
4041	"formal parameter '%s' is redefined"
4042	"'%Fs' : has bad storage class"
4044	"huge on '%Fs' ignored, must be an array"
4045	"'%s' : array bounds overflow"
4046	"'&' on function/array, ignored"
4047	"'%s' : different levels of indirection"
4048	"array's declared subscripts different"
4049	"'%s' : indirection to different types"
4051	"data conversion"
4052	"different enum types"
4053	"at least one void operand"
4060	"conversion of long address to short address"	/* QC, c23 */
4061	"long/short mismatch in argument : conversion supplied"	/* QC, c23 */
4062	"near/far mismatch in argument : conversion supplied"	/* QC, c23 */
4067	"unexpected characters following '%s' directive - newline expected"
4068	"unknown pragma"
4071	"'%Fs' : no function prototype given"
4074	"non standard extension used - '%s'"
4075	"size of switch expression or case constant too large - converted to int"
4076	"'%s' : may be used on integral types only"
4077	"unknown check_stack option"
4079	"unexpected token '%s'"
4080	"expected 'identifier' for segment name, found '%s'"
4081	"expected a comma, found '%s'"
4082	"expected an identifier, found '%s'"
4083	"expected '(', found '%s'"
4084	"expected a pragma keyword, found '%s'"
4085	"expected [on | off]"
4086	"expected [1 | 2 | 4]"
4087	"'%Fs' : declared with 'void' parameter list"
4088	"'%Fs' : pointer mismatch : parameter %d, parameter list %d"
4089	"'%Fs' : different types : parameter %d, parameter list %d"
4090	"different 'const' attributes"
4091	"no symbols were declared"
4092	"untagged enum/struct/union declared no symbols"
4093	"unescaped newline in character constant in non-active code"
4094	"unexpected newline"
4095	"expected ')', found '%s'"
4096	"huge treated as far"		/* QC */
4098	"void function returning a value"
4099	"expected ')', (too many arguments?)"
4100	"'%Fs' : unreferenced formal parameter"
4101	"'%Fs' : unreferenced local variable"
4102	"'%Fs' : unreferenced label"
4103	"'%Fs' : function definition used as prototype"
4104	"'%s' : near data in same_seg pragma, ignored"
4105	"'%Fs' : code modifiers only on function or pointer to function"
4106	"pragma requires integer between 1 and 127"
4107	"pragma requires integer between 15 and 255"
4108	"pragma requires integer between 79 and 132"
4109	"unexpected identifier '%s'"
4110	"unexpected token 'int constant'"
4111	"unexpected token 'string'"
4112	"macro name '%s' is reserved, %s ignored"
4113	"function parameter lists differed"
4000	"UNKNOWN WARNING\n\t\tContact Microsoft Technical Support"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\bin\cl.err ===
/* fatal messages */

1001	"could not execute '%s'"
1002	"too many open files, cannot redirect '%s'"
1000	"UNKNOWN COMMAND LINE FATAL ERROR\n\t\tContact Microsoft Technical Support"

				/* error messages */

2001	"too many symbols predefined with -D"
2002	"a previously defined model specification has been overridden"
2003	"missing source file name"
2007	"bad %s flag, would overwrite '%s' with '%s'"
2008	"too many %s flags, '%s'"
2009	"unknown option '%c' in '%s'"
2010	"unknown floating point option"
2011	"only one floating point model allowed"
2012	"too many linker flags on command line"
2013	"incomplete model specification"
/* 2014	"-ND not allowed with -Ad" */
2015	"assembly files are not handled"
2016	"-Gw and -ND %s are incompatible"
2017	"-Gw and -Au flags are incompatible"
2018	"cannot open linker cmd file"
2019	"cannot overwrite the source file, '%s'"
2020	"-Gc option requires extended keywords to be enabled (-Ze)"
2021	"invalid numerical argument '%s'"
2022	"cannot open help file, '%s'"
2023	"invalid model specification - small model only"
2024	"-Gm and -ND %s are incompatible"
2025	"missing argument"
2000	"UNKNOWN COMMAND LINE ERROR\n\t\tContact Microsoft Technical Support"

				/* warning messages */

4001	"listing has precedence over assembly output"
4002	"ignoring unknown flag '%s'"
4003	"80186/286 selected over 8086 for code generation"
4004	"optimizing for time over space"
4005	"could not execute '%s';\nPlease enter new file name (full path) or Ctrl-C to quit: "
4006	"only one of -P/-E/-EP allowed, -P selected"
4007	"-C ignored (must also specify -P or -E or -EP)"
4008	"non-standard model -- defaulting to large model libraries"
4009	"threshold only for far/huge data, ignored"
4010	"-Gp not implemented, ignored"
4011	"preprocessing overrides source listing"
4012	"function declarations override source listing"
4013	"combined listing has precedence over object listing"
4014	"invalid value %d for '%s'. Default %d is used"
4015	"different default models - defaulting to %s model"
4017	"conflicting stack checking options - stack checking disabled"
4019	"string too long. Truncated to %d characters"
4000	"UNKNOWN COMMAND LINE WARNING\n\t\tContact Microsoft Technical Support"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\tl\bin\c23.err ===
/* fatals */

1001	"Internal Compiler Error\n\t\t(compiler file '%s', line %d)\n\t\tContact Microsoft Technical Support"
1002	"out of heap space"
1003	"error count exceeds %d; stopping compilation"
1004	"unexpected EOF"
1005	"string too big for buffer"
1006	"write error on compiler intermediate file"
1007	"unrecognized flag '%s' in '%s'"
1027	"DGROUP data allocation exceeds 64K"
1028	"infinite recursion in cnstrpush"
1029	"there are > 512 bytes of arguments"
1030	"there are > 512 bytes of local variables"
1031	"limit exceeded for nesting function calls"
1032	"cannot open object listing file '%s'"
1033	"cannot open assembly language output file '%s'"
1034	"cannot open source file '%s'"
1035	"expression too complex, please simplify"
1036	"cannot open source listing file '%s'"
1037	"cannot open object file '%s'"
1038	"unexpected end of file in Pass 3"
1039	"unrecoverable heap overflow in Pass 3"
1040	"unexpected EOF in source file '%s'"
1041	"cannot open compiler intermediate file - no more files"
1042	"cannot open compiler intermediate file - no such file or directory"
1043	"cannot open compiler intermediate file"
1044	"out of disk space for compiler intermediate file"
1045	"floating-point overflow"
1046	"bad %s flag, would overwrite '%s' with '%s'"
1047	"too many %s flags, '%s'"
1048	"unknown option '%c' in '%s'"
1049	"invalid numerical argument '%s'"
1050	"%s : code segment too large"
1051	"program too complex"
1058	"floating point expression too complex - would overflow NDP stack"
1064	"too many text segments"
1000	"UNKNOWN FATAL ERROR\n\t\tContact Microsoft Technical Support"

						/* errors */
	
2023	"divide by 0"
2024	"mod by 0"
2125	"%s : allocation exceeds 64K"
2126	"%s : automatic allocation exceeds %s"
2127	"parameter allocation exceeds 32K"
2128	"%s : huge array cannot be aligned to segment boundary"
2129	"static function '%s' not found"
2189	"constant item, -Gm, and data_seg pragma are incompatible"
2000	"UNKNOWN ERROR\n\t\tContact Microsoft Technical Support"

						/* warnings */
	
4054	"insufficient memory may affect optimization"
4055	"constant moved out of CONST even though -Gm specified"
4056	"overflow in constant arithmetic"
4057	"overflow in constant multiplication"
4058	"address of frame variable taken, DS != SS"
4059	"segment lost in conversion"
4060	"conversion of long address to short address"
4061	"long/short mismatch in argument : conversion supplied"
4062	"near/far mismatch in argument : conversion supplied"
4063	"%s : function too large for post-optimizer"
4064	"procedure too large, skipping %s optimization and continuing"
4065	"recoverable heap overflow in post-optimizer - some optimizations may be missed"
4066	"local symbol table overflow - some local symbols may be missing in listings"
4069	"conversion of near pointer to long integer"
4070	"function called as procedure"
4072	"Insufficient memory to process debugging information"
4073	"scoping too deep, deepest scoping merged when debugging"
4078	"loss of debugging information caused by optimization"
4185	"near call to %s in different segment"
4186	"string too long. Truncated to %d characters"
4000	"UNKNOWN WARNING\n\t\tContact Microsoft Technical Support"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\dvorak\readme.txt ===
This directory has all files for compiling DVORAK.SYS file.

Run NMAKE (or XMSMAKE). After this rename keyboard.sys to DVORAK.SYS.

DVORAK.SYS includes following keyboard layouts:

1. Swiss-German
2. German
3. Italian
4. UK English
5. Polish
6. Czech
7. Slovak
8. Yugoslavian (Latin)
9. Hungarian
10. Romanian
11. US Dvorak
12. US right single-handed key
13. US left single-handed key

Notes:

1. Layouts 5-9 have some changes from US DOS 5.0.
2. Layouts 10-13 are new for US DOS 5.0

You should use standard KEYB.COM from US DOS 5.0.

All notes, bugs send to  Yuri Starikov (email: yst).
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\multconf.txt ===
Multiple Configuration Boot
---------------------------

We are trying to solve following problems with multiple configuration
processing:

 1. Ability to boot without processing CONFIG.SYS and AUTOEXEC.BAT

 2. Ability to conditionally process different lines/sections of
    CONFIG.SYS and AUTOEXEC.BAT based on a user-specified configuration,
    and to set environment variables based on that configuration

 3. Ability to interactively execute or skip any line in CONFIG.SYS,
    in order to speed up system tuning and problem determination

NOTE:  This feature does not address dual or a multi-boot option.
Dual/multi boot normally refers to an ability to boot from different
partitions or an ability to boot different operating systems.  The proposed
multi-configuration architecture is compatible with the existing dual-boot
and multi-boot software (OS/2 1.2/2.0, ROMDOS, etc).
 
Configuration blocks are defined in CONFIG.SYS through the use bracketed
headings, similar to those found in Windows INI files.  The headings are
called block names, and are single words used both to define the blocks and
to refer to them in a special block called the MENU block.  Examples of
block names are MINIMUM, NETWORK, CDROM, DATABASE, etc.

The block name MENU is a pre-defined block name used to define the menu
that is displayed at boot-time.  A MENU block can only contain certain
MENU-related commands;  all other lines are ignored.  These commands are:

    Commands        Syntax and definition

    MENUITEM        MENUITEM=blockname[,description]

                    Each MENUITEM entry for which blockname is a valid
                    block name will create a selection on the boot-time
                    menu.  The first selection is number 1, and so on,
                    up to the maximum of 9.  The description field is what
                    will be displayed on the screen;  if it is omitted,
                    then the block name itself is used.

    MENUDEFAULT     MENUDEFAULT=blockname[,timeout]

                    This establishes which of the MENUITEMs displayed will
                    be highlighted on the screen as the default selection
                    (ie, the selection that will be chosen if the user
                    presses Enter or if a timeout occurs).  When no default
                    is explicitly set, the default is selection 0 (NONE).
                    The timeout, if present, is a number from 0 to 90.
                    This establishes the number of seconds to wait before
                    automatically selecting the default configuration.  If
                    it is 0, this forces automatic selection of the default,
                    bypassing menu display.  If, however, the INTERACTIVE
                    BOOT attention key (Enter) has been pressed prior to
                    booting, the menu, if any, is displayed regardless.
                    Pressing any key while the time-out counter is counting
                    down disables time-out.

    MENUCOLOR       MENUCOLOR=x[,y]

                    x and y are numbers that define text and screen color.
                    The numbers must be one of the following:

                            0   Black       8   Gray
                            1   Blue        9   Bright Blue
                            2   Green      10   Bright Green
                            3   Cyan       11   Bright Cyan
                            4   Red        12   Bright Red
                            5   Magenta    13   Bright Magenta
                            6   Brown      14   Yellow
                            7   White      15   Bright White

                    Choose differing values for x and y, otherwise the text
                    may not be readable.  Also, on most systems, screen
                    colors 8-15 are identical to 0-7; the only difference
                    being that the text flashes.

    NUMLOCK         NUMLOCK={ON|OFF}

                    Because the menu makes use of arrow keys, this allows
                    users to configure the Num-Lock setting of the numeric
                    keypad.  Because the menu is displayed before any drivers
                    or programs are run, there is no other way to configure
                    the keyboard programatically.


The MENU block is typically placed at the top of CONFIG.SYS, but neither it
nor any other block is required to be in any particular position or order.

Here is an example of a block-structured CONFIG.SYS:

    [menu]
    menudefault=normal,30
    menuitem=normal,My normal configuration
    menuitem=database,Drivers required for my SQL database
    menuitem=reference,Drivers for my information retrieval system

    [common]
    files=20
    buffers=20
    shell=c:\dos\command.com /p c:\dos

    [reference]
    include dataBase
    device=c:\dos\ansi.sys
    device=c:\cdrom\scsi.sys

    [normal]
    device=c:\dos\setver.exe

    [database]
    device=c:\net\pcxmod.sys
    device=c:\net\pcxmoda.sys

    [common]

Any lines occuring before the first block heading will be considered
common to all configurations, and will always be executed first.  This
provides backward compatibility with setup/installation programs that simply
add lines to the top of CONFIG.SYS.  Common lines can also be explicitly
inserted at any point by using the predefined COMMON block heading.
A COMMON block should always be placed at the end of CONFIG.SYS as well,
again to provide better backward compatibility (reducing the need to
manually edit CONFIG.SYS just to make newly installed changes effective).

The INCLUDE command has been added to allow commands to be grouped into
logical sub-blocks and then included by larger configuration blocks.  The
primary goal is to allow any CONFIG.SYS to be structured in such a way that
each unique line appears only once in the file, simplifying upgradability
and maintainability of the file.

All lines are processed in the order they appear.  The only exception to
this ordering is when the INCLUDE command is used to include a block from
within another block.

If the boot-time menu is enabled (meaning: if a MENU block exists and a
default has not been enforced through a timeout of 0), then the following
boot menu is displayed for the specified time during DOS initialization.
Based on the above example, this menu would look like:

MS-DOS boot options:

  0. NONE
  1. MY NORMAL CONFIGURATION
  2. DRIVERS REQUIRED FOR MY SQL DATABASE
  3. DRIVERS FOR MY INFORMATION RETRIEVAL SYSTEM

Select an option (ESC for clean boot):         [30]  [Interactive mode: OFF ]

with selection #1 highlighted.  The user can change the highlighted selection
with up/down cursor keys, and can choose the highlighted selection by
pressing Enter.  He can also choose any selection directly by pressing the
associated number (0, 1, 2 or 3 in the above example).  If no key is pressed
within the specified time, then the system will boot as if the user chose the
highlighted (default) selection.

Option 0 (NONE) boots without executing any blocks in CONFIG.SYS.  Only
common lines (and any explicit COMMON blocks) are processed;  AUTOEXEC.BAT
is still processed normally, and the environment variable BOOT will be
set to COMMON.  All the remaining numbered options (1,2 or 3 in this example)
will set the BOOT environment variable to the associated block name (NORMAL,
DATABASE or REFERENCE in the above example).

Other keys function as follows:

    Escape selects "clean boot", which disables all CONFIG.SYS and
    AUTOEXEC.BAT processing;  the same feature is supported by pressing the
    CLEAN BOOT attention key (Escape) prior to the display of the DOS
    boot-time menu (but after the machine has reset the disk drives, keyboard,
    LEDs, etc).  Note: for this to be useful, you will have to have a copy of
    COMMAND.COM in your root directory.

    Enter selects the currently highlighted (default) selection

    The right/left cursor keys toggle the current INTERACTIVE boot setting,
    which can either be:

        ON      Prompt before processing every line in CONFIG.SYS
        OFF     Do not prompt on every line (except for lines containing '?')
        NONE    Do not prompt on any line (even lines containing '?')

The default INTERACTIVE setting is OFF, unless the INTERACTIVE BOOT attention
key (Enter) is pressed prior to the display of the configuration menu, in
which case the default is ON.

To force interactive prompting for inidividual lines, place a '?' immediately
after the command;  eg:

    device?=c:\dos\ansi.sys

which results in the following prompt:

    DEVICE=C:\DOS\ANSI.SYS? (Yes,No,All):

Pressing Y executes the command normally, N skips the command, and A answers
Y to this and all subsequent prompts (in other words, it forces INTERACTIVE
mode to NONE).

The SET command can now be used in CONFIG.SYS to set environment variables
for the shell.  You can use SET to change the value of a previously defined
variable (only the final setting is effective), even the predefined BOOT
variable.

Like the shell's SET command, the '=' is required, and the whitespace
surrounding the '=' is significant.  So all of the following commands

    SET FOO=BAR
    SET FOO = BAR
    SET FOO= BAR

have different effects.

"SET variable=" removes variable, if any, from the environment.

"%variable%" substitution is not supported in CONFIG.SYS.

There is also no imposed limit of 128 characters per environment variable
when set from CONFIG.SYS.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\doc\api.doc ===
1           P+  i u u v v v                                                                     HPLASMS w @ >  u u   v 

API for Character Setup Toolkit Compression Routines

Ruth Adlhoch, Robert Bunney and Bill Hunter
APPS-DS

November 21, 1989
Pre-Distribution Version 1


The function prototypes can be found in the include file API.H in the release directory.  Include the file RETCODES.H to get the definitions of return values for these procedures and of the algorithm types.


SHORT  WReadHeaderInfo(int fhSrc)

Which Library: SUDECOMP.LIB only.
Arguments:  fhSrc, the file handle of the file to read the header from.
Description:  Determines whether the given file has a header in our format, and if so, extracts the information from it into the global header variables defined in API.H.  If the magic bytes at the beginning of the file are correct, we assume it is a compressed file.  We generate errors if something is wrong with the remainder of the header.  (For instance the algorithm is not a known type, or something is wrong with the format of the rest of the header.)  If the magic bytes do not match, we assume the file is not compressed.  (Notice that the file could also be uncompressed but still have a header.  The wAlgType in the header would be wAlgTypeNoCompress.)  Reaching EOF while reading the magic bytes in the header is not an error, but rather indicates there is no header on the file.  Reaching EOF while reading the rest of the header is an error.
Returns:  Returns the algorithm type used to compress the file, or a return code indicating an error.
Side Effects:  If the header is read successfully, the procedure will allocate memory to store some of the header information if present (e.g. compression arguments and header text).  FFreeHeaderInfo() should be called to free this memory after the caller has finished working with the source file.  WReadHeaderInfo() calls FFreeHeaderInfo() before reading and on errors, so the headers of any number of files can be read sequentially without calling FFreeHeaderInfo().  FFreeHeaderInfo() need only be explicitly called after work on the last file is completed.  This routine seeks fhSrc to the byte after the header, if there was a header.  If there was no header, it resets fhSrc to its original state.


SHORT  CbWriteFileHeader(int fhDest)

Which Library:  SUCOMP.LIB only
Arguments:  fhDest, the file handle to the opened output file (usually truncated or newly created).
Description:  Writes the information contained in the header globals (see API.H for the list of global variables) to fhDest, in the proper header format.  Assumes that fhDest is positioned to where the file header should be written (the beginning, in most cases).
Returns:  Returns the length of the header written, or a return code if there was an error.
Side Effects:  fhDest is left positioned at the byte after the header.  If there is an error during writing, the file position is reset to its original value (effectively removing the changes).  If the source file length or checksum need to be included in the header, space is left for them and the global variables vlibSrcLength and vlibChecksum are set to the positions to patch those values later when they are known.



BOOL  FFreeHeaderInfo(void)

Which Library:  SUCOMP.LIB and SUDECOMP.LIB
Arguments:  None.
Description:  Frees any allocated global header structures (e.g. compression arguments and header text), and resets all header variables to their default values.
Returns:  Always returns TRUE.
Side Effects:  This procedure is called at the beginning of WReadHeaderInfo(), so the user only needs to explicitly call this procedure after finishing with the last file.



LONG  LcbCompressToFile(SHORT wAlgType, int fhSrc, int fhDest, LONG lcbDestMax)

Which Library:  SUCOMP.LIB only.
Arguments:  wAlgType, the algorithm type to compress with;  fhSrc, the file handle of the input file, positioned to the byte from which to start compressing (need not be the beginning of the file);  fhDest, the file handle of the output file; lcbDestMax, the maximum number of bytes to be written to the output file.
Description:  Calls CbWriteFileHeader() then calls the appropriate compression routine to compress the input file into the output file.  These must be different files -- a file cannot be compressed onto itself.  If lcbDestMax is NIL, then there is no limit on the size of the output file, and this routine will run until it reaches an EOF in the source file.
Returns:  Returns the number of bytes written to fhDest, or an error return code if something went wrong.
Side Effects:  If the compression was successful, fhSrc is positioned at either EOF or at the next source byte to start compression at if a split occurred because lcbDestMax was reached.  If an error occurred, the output file fhDest is reset to its original length, but fhSrc is not reset.  For the Zeck algorithm, calling this procedure will require about 40KB of near memory.  When splitting occurs with the Zeck algorithm, this routine calls LcbCalculateDecompressedLength() to reset fhSrc, so the decompression object files have been included in the compression library.



LONG  LcbCalculateCompressedLength(SHORT wAlgType, int fhSrc, LONG lcbDestMax)

Which Library:  SUCOMP.LIB only.
Arguments:  wAlgType, the algorithm type to compress with;  fhSrc, the file handle of the input file, positioned to the byte at which to start the compression calculation;  lcbDestMax, the maximum number of bytes that should be written to an output file (if there was one).
Description:  Calls the appropriate compression routine to compress the file, but does not write any output.  If lcbDestMax is NIL, then it calculates the size as if there were no limit on the output size.
Returns:  Returns the number of bytes that would have been written (including the size of the header) if this had been a call to LcbCompressToFile().  Returns an error code if it was not successful.
Side Effects:  If there were no errors, the file position of fhSrc is reset to its original value.  This procedure needs as much near memory to run as does LcbCompressToFile().



LONG  LcbDecompressToFile(int fhSrc, int fhDest, LONG lcbDestMax, LONG libStart, BOOL fHeaderAlreadyRead)

Which Library:  SUDECOMP.LIB only.
Arguments:  fhSrc, the file handle to the input file, positioned to the byte at which to start reading; fhDest, the file handle to the output file, positioned at the byte at which to start writing; lcbDestMax, the maximum size in bytes that may be written to the output file; libStart, the offset in the decompressed bytes at which to start writing to the output file; fHeaderAlreadyRead, a flag indicating whether the header has already been read from the input file.
Description:  If fHeaderAlreadyRead is TRUE, assumes the header has been successfully read and the proper global variables have been set; otherwise this procedure calls WReadHeaderInfo() directly.  Depending on the setting of the global algorithm type variable (vwAlgType), the appropriate decompression routine is called.  Decompression starts at the current position of fhSrc and output is written at the current position of fhDest.  It is possible for the file handles to not point at the first byte of each file.  The source file handle will point after the header bytes if fHeaderAlreadyRead is TRUE; theoretically it could start in the middle of the compressed data, but the Zeck algorithm will produce garbage unless decompression is started at the first data byte.  The destination file handle will point to the end of a previously decompressed piece when split files are recombined.  If libStart is not NIL, then that many decompressed output bytes are skipped before writing to the file.  If the global variable vlcbSrcLength has been set to a size other than NIL (usually by WReadHeaderInfo()), this procedure checks the decompressed file's length and returns an error if there is a mismatch.  The file length of fhDest is reset on an error.
Returns:  Returns the number of bytes written to fhDest, or an error return code if something went wrong.
Side Effects:  For the Zeck algorithm, this procedure allocates about 6KB of required near buffers, and attempts to allocate as large a buffer as possible for buffered reading and writing.  Speed can be substantially faster if there is enough memory to allocate the maximum size (32KB) read/write buffer.



LONG  LcbDecompressToBuffer(int fhSrc, BYTE far * fpbBuf, LONG lcbBuf, LONG libStart, BOOL fHeaderAlreadyRead)

Which Library:  SUDECOMP.LIB only.
Arguments:  fhSrc, the file handle to the input file, positioned to the byte at which to start reading; fpbBuf, a far pointer to the buffer for the decompressed output; lcbBuf, the maximum size in bytes that may be written to the output buffer; libStart, the offset in the decompressed bytes at which to start writing to the output buffer; fHeaderAlreadyRead, a flag indicating whether the header has already been read from the input file.
Description:  If fHeaderAlreadyRead is TRUE, assumes the header has been successfully read and the proper global variables have been set; otherwise this procedure calls WReadHeaderInfo() directly.  Depending on the setting of the global algorithm type variable, the appropriate decompression routine is called.  Decompression starts at the current position of fhSrc.  If libStart is not NIL, then that many decompressed output bytes are skipped before writing to the buffer.
Returns:  Returns the number of bytes written to fpbBuf, or an error return code if something went wrong.  If lcbBuf is NIL, no decompression is done.  It is an error for fpbBuf to be NULL.
Side Effects:  For the Zeck algorithm, this procedure causes the allocation of about 6KB of required near buffers.



LONG  LcbCalculateDecompressedLength(int fhSrc, BOOL fHeaderAlreadyRead)

Which Library:  SUDECOMP.LIB only.
Arguments:  fhSrc, the file handle of the input file, positioned to the byte at which to start the decompression calculation;  fHeaderAlreadyRead, a flag indicating whether the header has been read from the file (and the global header variables set).
Description:  If fHeaderAlreadyRead is FALSE, it calls WReadHeaderInfo() to read the header from the input file.  Then, if necessary, it calls the appropriate decompression routine to decompress the file, but does not write any output.  Since the decompressed length may be stored in the header information, the file may not actually be decompressed in order to return the size of the decompressed file.
Returns:  Returns the number of bytes that would have been written if this had been a call to LcbDecompressToFile().  Returns an error code if it was not successful.
Side Effects:  The file position of fhSrc is reset to its original value if this routine is successful.  This procedure may need as much memory to run as does LcbDecompressToFile(), or it may need none at all (depending on if the length is stored in the header).

܀      w    t    q    n    k #  h %  e   a   ^    Z -  V C  R L  N  A @ A @ A @ @ B @ B @ A @L  O  w T  s   o   k   g   c   _ "  [   W   S M  O Y  K L  A @ A @ B @ B @ A @ B @Y    w   s   o   k 	  g 9	  d ;	  ` H	  \ \	  X e	  T h	  P n	  L L  B @ A @ A @ A @ B @ B @n	  	  w 	  s 6
  o <
  k i
  g o
  c 
  _ 
  [ '  W 3  S 6  O <  K L  B @ A @ A @ B @ B @ A @<  c  w p  s u  o   k   g   d   `   \   X (  T 2  P =  L L  A @ A @ A @ A @ B @ B @=    w   s   o   k   g   d   `   \   X &  T )  P 1  L L  B @ A @ A @ A @ A @ A @1  Y  w ^  s   o   k   g   c [  _ f  [ 2  W <  S   O   K L  A @ B @ A @ B @ B @ B @    w   s .  o :  k `  g e  c   _   [   W   S <  O A  K L  B @ B @ B @ B @ A @ B @A    w   s t  o   l   h   d   `   \   X   T $  P )  L L  B @ B @ A @ A @ A @ B @)    w   s   o   k l  g v  c   _   [   W   S   O   K L  B @ A @ A @ B @ A @ B @  J  w   t   p   l   h   d   `   \ C  X I  T   P   L L  B @ B @ B @ A @ A @ A @    w   s L  o ^  k   g   c   _   [   W   S %  O *  K L  B @ B @ B @ A @ B @ B @*  \  w b  s   o   k 1  g 9  c   _   [ y  W   S   O   K L  A @ B @ B @ B @ B @ B @    w   s    o    k :!  g !  d !  ` !  \ !  X !  T !  P 8"  L L  @ B @ A @ A A @ A @ B @8"  >"  w y"  s "  o "  k "  g $#  c 6#  _ #  [ #  W #  S #  O $  K L  @ B @ A @ B @ B @ B @ B$  $  w $  s %  o c%  k l%  g %  c %  _ %  [ %  W &  S &  O $&  K L  @ B @ B @ B @ A @ B @ B$&  0&  w &  s &  p &  l &  h '  d '  ` '  \ '  X '  T '  P 
(  L L  @ B @ B @ A @ A @ A @ A
(  (  w (  s -(  o )  k )  g F*  c R*  _ j*  [ o*  W P+  S '  P 
(  L L  @ B @ B @ A @ A @ B @ A
      x    x    u    r    o    o    l   i  C  C  C  C  C  C  C  C  A @ <<<<<<  #  x %  u '  u   u   u   u   u    u  C  C  C  C  C  C  C  C  A @ <<<<<<   C  p   p   p M  p 	  p 	  	  9	  ;	   C  C  
C  C  	C  C  C  C  C <
<   0	;	  \	  p 	  p 
  p '  p   p   e   b   b  C  C  C  C        C  C  C  <
<   0
<    0    x   m   m 2  m   m   m   m   m   m  C  C  C  C  C  C  C  C  C 
<   0<	    x   m   b   b [  b   b .  b n  b  C  C  C  C  C  C  C  C  
<   0
<   0<n  p  p r  p t    e   Z   Z   Z  C  C  C  C  C  C  C  C 
<    0
<    0
<    0    p   p D  p F  e H  b J  b   W  C  C  C  C  C  C  C  
<   0<
<   0
<    0    p   p   p   p    p 4!  p 6!  e 8!   C  C  C  C  C  C  C  C 0<
<    0
<   08!  :!  !  p !  e !  e #  e e%  e $&  e &  e  C  C  C  C  C  C  C  C 0<
<    0
<    0&  &  x &  x &  x &  m &  b '  b 
(  b )  b  C  C  C  C  C  C  C  C 0
<   0
<   0<)  F*  p N+  p P+  e Q+   C  C  C        C  C  C  C  C  C  C  C 0
<
<    0
<   0 
       J  #  *  	         j     3             ' / api.doc      11/29/8910/18/89*  
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\doc\header.doc ===
ۥ- x@	    -               v                         Z                              j    j j    j    j    j    j   x                               	                                                            4 7   ?      j                      
                                                              

Format Proposal for Compressed File Headers

Ruth Adlhoch-Lipscomb and Bill Hunter
APPS-AS

February 4, 1992
Version 1.0


Assumptions

1)  All semantic information is contained in the header (eg it doesn't depend on particular file extensions, etc).
2)  Format is extensible for future demands placed on it.  In particular, new compression algorithms and long filenames.
3)  Size impact of the header is kept to a minimum.  Only a very small number of header fields are required, and fields that are not used may be omitted to save space.


Proposal for File Header

*** Required Components ***
rgbMagic	8 bytes	 - an array of magic bytes that identifies the file as being compressed.
wAlgType	2 bytes	 - specifies the type of compression and/or encryption algorithm used in the file.  Initially supported types are 0 for no modification of the data, 1 for XORing  each byte (used mostly for testing), 2 for the Steven Zeck compression algorithm, and 3 for the Jeff Johnson compression algorithm.  (New algorithms may be added in the future.)
cbHeader	2 bytes	 - number of bytes in this file's header, including all optional parts.  This is an offset from the beginning of the header to the actual data.
rgfsFlags	2+ bytes - group of bits for flagging what further optional structures are present.  At least one word is always used; if the high bit of a flag word is set, it indicates there is at least one more flag word following; the final flag word has the high bit cleared.  If a bit is set, then the optional header component that corresponds to that bit is present; if the bit is not set, then the data for that component is omitted.

*** Optional Components ***
lcbSrc		4 bytes	 - length of uncompressed source.
usChecksum	2 bytes	 - checksum of the uncompressed source file.
cbArgs		1 byte	 - count of bytes in following rgbArgs.
rgbArgs		variable	 - compression algorithm arguments - cbArgs bytes long.
szBaseName	variable	 - zero-terminated character string.
szExtension	variable	 - zero-terminated character string.
stText		variable	 - length-prefixed character string for storing arbitrary text in the header.


Notes on the Header Format

rgbMagic is used to recognize if a file is compressed.  Its value should be easily recognized when the file is dumped.  The magic bytes are "KWAJ\x88\xf0\x27\xd1".

wAlgType should be incremented for each new algorithm or variation used.  Code to decompress files could possibly recognize more than one algorithm type.

rgfsFlags flags the existence of further optional components.  When new components are added, the new flag must always be added at the end of the chain of flags (for backwards compatibility), and there should never be any data for the component included in the header unless the flag bit is set.  Initially defined flags include fSrcLength, fChecksum, fArgs, fBaseName, fExtension, and fText.

lcbSrc is useful to determine whether the decompressed file will fit on the destination disk.  This is also used as a gross check of the decompression algorithm.

usChecksum is useful for checking more subtle errors in the decompression routine, or for checking that the source file was not corrupted during the compression/decompression cycle.  This field is currently not supported by the existing compression algorithms.

cbArgs and rgbArgs are supplied only if the wAlgType routine needs parameters to run, and depend on the algorithm being used.  (These fields are not currently being used with any of the existing algorithms.)  cbArgs gives the size in bytes of the following rgbArgs.

szBaseName and szExtension are zero-terminated strings that tell what the filename was before compression.  This allows the compressed source files to be given a different name indicating compression (COMPRS01.DRV, COMPRS02.DRV, etc.) and allows the caller of the decompression routine to recreate the original filename from the names in the header.  The base and extension are stored separately to save space when only one of them is included.  The extension can be equal to " " (a space) to indicate that the source had no extension.

stText is a string that is prefixed by a word containing the length of the string.  (The length does not include the 2 bytes necessary for the length word.)  This field is used to store arbitrary text in the header; it will most often be used for copyright notices since any notices embedded in the original file will not be readable once the file is compressed.

Compression File Header Description - 1.0    Microsoft Confidential    page PAGE1



 @Proposal for Compressed File Headers

Ruth Adlhoch-Lipscomb and Bill Hunter
APPS-AS

February 4, 1992
Version 1                            F  V      O  a    %  4  X  j          	  /	  V	  j	  	  	  	  
  
  
  
  
  
  
  W  `                                              a  g                  &  r  s  w  x  y  z  |                                                  V                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  F    O      %  X      	  V	  	  	  	  	  
  
  
  
  U  W          э}                  !     !     !  p@       	!  p@       !  p@       !  p@       !  p@       !     ! 0   !    ! .              $  &  |  ~                                                                                                                                                                                                                                                                                                                                                                                       !     !     !     !    !         F        	                                        q    
              X   ^         
          	
 Tms Rmn 	Symbol " Helv 
1 Courier 0 elite 0 prestige   lettergothic 0 gothicPS 1 LinePrinter " Helv 0 AvantGarde   Helvetica-Narrow 0 metro 0 presentation 0 APL 0 OCRA 0 OCRB 
 Bookman  emperorPS  madaleine  zapf humanist 
 classic 
 roman f 
 roman g 
 roman h 
 Tms Rmn  NewCenturySchlbk  palatino  souvenir  garamond  caledonia 	 bodini  university 	BScript @ scriptPS @ script c @ script d @ commercial script @ park avenue 
@ coronet @ script h @ greek  kana 	 hebrew 
 roman s 
 russian 
 roman u 
 roman v 
 roman w P narrator P emphasis P ZapfChancery 
P decor d P old english 
P decor f 
P decor g P cooper black 0 linedraw   math7   math8 P ZapfDingbats   EAN 	  pcline 	  tech h 1MS LineDraw L   Q   S   ^   !                             "       h     ew"E                   ?   
header.doc   William C. HunterWilliam C. Hunter         
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\doc\jj_descr.doc ===
ۥ- x@	    -               d                        V                              j    j j    j    j    j    j   x                     
   
       	                                                          4 /  5     j                    	 
                                                             
Description of Johnson Compression/Decompression Algorithm

Bill Hunter
APPS-AS

February 4, 1992
Version 1.0


The Johnson compression/decompression algorithm was written by Jeff Johnson from the Excel group.   They needed an algorithm which would work better than the Zeck algorithm (see separate document) on binary files (e.g. EXCEL.EXE).


Compression Algorithm and File Format

The header portion of the file consists of a specific sequence of bytes followed by some optional fields such as the uncompressed file name and length.  The sequence of bytes is needed so that our tools can recognize the file as compressed.  This is the same header as is used with the Zeck algorithm and all future algorithms.

On the first pass, it works much like the Zeck algorithm - checking if the input stream matches a previously seen phrase of 3 to 16 bytes from the last 4096 bytes seen.  If it does, then the (length - 2) as a 4 bit number is output and then a 12 bit offset to the beginning of the previously seen phrase is output.  If the new byte does not match then 0 as a 4 bit number is output, then the number of unmatched bytes upto 31 as a 5 bit number is output, and then the literals as 8 bit bytes are output.  If at End Of File then 15 as a 4 bit field is output.

End Of File'15' as 4 bitsLiterals'0' as 4 bits, count of literal as 5 bits, n literals as 8 bits eachPhraselength-2 (in range 1 to 14) as 4 bits, offset to start of phrase as 12 bits
Throughout the first pass, these outputs are divided into 6 streams and counts are kept of the number of times each pattern is found in 5 of them, so that later frequencies and Huffman encoding tables can be calculated.  The first stream is of 4 bit initial fields seen either at the beginning of the file, or after a previous phrase has been seen and processed, or a run of 31 (the max) literal bytes has been seen and processed.  (This stream is for initial fields which are usually literal byte runs.)  The second stream is of 4 bit initial fields seen after a run of literals of fewer than 31 bytes has been seen and processed.  (This stream is for initial fields which are usually phrase matches.)  The third stream is of the 5 bit literal run count fields.  The fourth stream is of the 6 high bits of the phrase offsets.  The fifth stream is of the 8 bit literal bytes.  The sixth stream is of the  6 low bits of the phrase offsets which will not be compressed by Huffman in the second pass.

At the beginning of the second pass, a Huffman table for each stream is computed, encoded into a compact form and written to the output file.  Then the work of pass 1 is repeated but this time, as fields are found, they are passed into the appropriate Huffman table (except for the sixth stream which is written as is), and the Huffman code is written to the output file.

The Decompression Algorithm

The decompression algorithm starts with an empty 4kb byte buffer.  The five Huffman decoding tables are constructing using the information that follows the standard compression header.  Each field, as it is read from the input stream, is decoded in the appropriate Huffman table which is determined by previous context.  Each time a literal 'unit' is found on the input stream, the literal byte is written to the output stream as well as inserted into the byte buffer.  When the end of the buffer is reached, the insertion wraps to the beginning of the buffer and starts overwriting previously inserted bytes.  When a run-encoding 'unit' is found on the input stream, the index and length of the run are calculated and bytes from the byte buffer are written to the output stream as well as being inserted into the byte buffer.  This process repeats until an EOF byte is found on the input stream.

Johnson Algorithm Description - 1.0     Microsoft Confidential     Page PAGE1



 @v~t~t~u +MM]M   R                                                                                                                                      
Description of Johnson Compression/Decompression Algorithm

Bill Hunter
APPS-AS

February 4, 1992
Version 1.0


The J                  Y  [          a                                                                                                                                                                                                                                                                                                                                                                                                                       Y  [                           Y  [  ]  D  F          _  a          ʼʼʼ                                                                        !     !     	!             !    
!         l 
 db"       {        !    !     !    !    ! ,       F        	                               9  	       >  9                T   Z       	     
 	
 Tms Rmn 	Symbol " Helv 
1 Courier 0 elite 0 prestige   lettergothic 0 gothicPS 1 LinePrinter " Helv 0 AvantGarde   Helvetica-Narrow 0 metro 0 presentation 0 APL 0 OCRA 0 OCRB 
 Bookman  emperorPS  madaleine  zapf humanist 
 classic 
 roman f 
 roman g 
 roman h 
 Tms Rmn  NewCenturySchlbk  palatino  souvenir  garamond  caledonia 	 bodini  university 	BScript @ scriptPS @ script c @ script d @ commercial script @ park avenue 
@ coronet @ script h @ greek  kana 	 hebrew 
 roman s 
 russian 
 roman u 
 roman v 
 roman w P narrator P emphasis P ZapfChancery 
P decor d P old english 
P decor f 
P decor g P cooper black 0 linedraw   math7   math8 P ZapfDingbats   EAN 	  pcline 	  tech h 1MS LineDraw 9  H   M   O   Z   !                             "       h     v"E                  5       William C. HunterWilliam C. Hunter         
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\doc\zk_descr.doc ===
ۥ- x@	    -             ,  _                  Y
      Q                              j    j j    j    j    j    j   x                    
   
                                                                 4 *  5     j                                                                                  
Description of Zeck Compression/Decompression Algorithm

Bill Hunter
APPS-AS

February 4, 1992
Version 1.0


The Zeck compression/decompression algorithm was originally written by Steven Zeck in the Systems-Languages group.  We modified his code and file header to fit our API, but the method and data formats remain unchanged.


Compressed File Format

The header portion of the file consists of a specific sequence of bytes followed by some optional fields such as the uncompressed file name and length.  The sequence of bytes is needed so that our tools can recognize the file as compressed.  The data portion of the file consists of a number of 'segments' ranging in size from nine to seventeen bytes.  The leading byte of each 'segment' is eight bit flags followed by eight 'units'.  Each bit flag determines whether the corresponding 'unit' is a single byte representing a literal unencoded byte or a two byte encoding that specifies a previously seen run of bytes.  The corresponding bit flag in the leading byte is set to one for a literal byte 'unit' and set to zero for a run-encoding 'unit'.  The first 12 bits of a run-encoding 'unit' specify an index into a 4096 byte buffer.  The value of the final 4 bits plus 3 specifies the number of bytes in the run.  (Note - the final 'segment' may contain less than 8 'units'.)


The Decompression Algorithm

The decompression algorithm starts with an empty 4096 byte buffer.  Each time a literal 'unit' is found on the input stream, the byte is written to the output stream as well as inserted into the byte buffer.  When the end of the buffer is reached, the insertion wraps to the beginning of the buffer and starts overwriting previously inserted bytes.  When a run-encoding 'unit' is found on the input stream, the index and length of the run are calculated and bytes from the byte buffer are written to the output stream as well as being  inserted into the byte buffer.  This process repeats until an EOF byte is found on the input stream.


The Compression Algorithm

The compression algorithm starts with an empty 4096 byte buffer.  It peeks at the input stream and searches the byte buffer for the longest matching prefix of the input stream.  If this match is 3 bytes or more, then a run-encoded 'unit' is written to the output stream and this number of bytes (upto 18) is removed from the input stream.  If the match is less than 3 bytes, then the first byte is read from the input stream and written to the output stream as a literal 'unit' and inserted into the byte buffer.  The process is then repeated until an EOF byte is found on the input stream.

Zeck Algorithm Description - 1.0    Microsoft Confidential    Page PAGE1



 @specifies a previously seen run of bytes.  The corresponding bit flag in the leading byte is set to one for a literal character 'unit' and set to zero for a run-encoding 'unit'.  The first 12 bits of a run-encoding 'unit' specify an index into a 4kb character buffer.  The value of the final 4 bits plus 3 specifies the number of c
Description of Zeck Compression/Decompression Algorithm

Bill Hunter
APPS-AS

February 4, 1992
Version 1.0


The Zeck                            f	  j	  	  	        !  "  #  $  &  *  ,  5                                                                                                                                                                                                                                                                                                                                                                                              f	  h	  j	  	  	      &  (  *  ,                                                                                                                                                                                                                                             !     !     !     !     
!     !     !    !        F        	                               
   ,      
           O   U     5     ,    Times New Roman 	Symbol & Arial 
1 Courier 0 elite 0 prestige   lettergothic 0 gothicPS 1 LinePrinter " Helv 0 AvantGarde   Helvetica-Narrow 0 metro 0 presentation 0 APL 0 OCRA 0 OCRB 
 Bookman  emperorPS  madaleine  zapf humanist 
 classic 
 roman f 
 roman g 
 roman h 
 Tms Rmn  NewCenturySchlbk  palatino  souvenir  garamond  caledonia 	 bodini  university 	BScript @ scriptPS @ script c @ script d @ commercial script @ park avenue 
@ coronet @ script h @ greek  kana 	 hebrew 
 roman s 
 russian 
 roman u 
 roman v 
 roman w P narrator P emphasis P ZapfChancery 
P decor d P old english 
P decor f 
P decor g P cooper black 0 linedraw   math7   math8 P ZapfDingbats   EAN 	  pcline 	  tech h 1MS LineDraw 
  C   H   J   U   !   W
  W
    0 W
      Y
  "       h     u"E                   5       William C. HunterWilliam C. Hunter         
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\doc\using.doc ===
1           )  \ i i j j j                                                                     HPLASMS k @ >  i i   j 

Using Character-Setup Toolkit Compression

Ruth Adlhoch, Robert Bunney and Bill Hunter
APPS-DS

February 23, 1990
Version 2


Background
The Character-Setup Toolkit is a set of routines and utilities, maintained by DS, that help programmers build Setup programs.  This Toolkit has existed for several years and is currently being used by several of the Setup programs in the Application's Division.  The newest addition to this Toolkit is a set of routines and utilities that allow compression of files.  The compression functionality is available within Setup programs, or as a library that can be used by other non-Setup applications.
The toolkit API and header format has been designed to allow easy addition of new compression algorithms, while maintaining backwards compatibility with older formats.

Currently Available Algorithms
There are currently three available "compression" algorithms, although only one of them actually saves space.  One algorithm doesn't modify the file at all -- it just adds a header and does a straight copy.  A second algorithm does an XOR of each byte with 0xFF, which encrypts the file but does not compress it.  The third (and most useful) algorithm was developed by Steven Zeck for the Languages group in the Systems Division, and it actually compresses files, sometimes with up to 88% savings.  The version included in the Toolkit was derived from Steven's code with minor modifications; the compressed files are identical to those compressed with his utilities except that the header format has been expanded.

What Is Included For Compression?
- COMPRESS.EXE:  a utility to compress files, and optionally to split them into pieces, with switches to include various optional information into the header of the compressed file.
- DECOMP.EXE:  a utility to decompress files while utilizing the optional fields of the header.  This tool does not re-combine split files.
- SUCOMP.LIB:  a library of routines to allow compression to be incorporated into other applications (this will probably not be commonly used).
- SUDECOMP.LIB:  a library of routines to allow decompression to be incorporated into other applications (used by Setup Toolkit).

Where Can These Tools Be Found?
The current release is found in \\lsd\release!compress.  This release directory contains the utilities, libraries, and include files necessary to use the existing algorithms as well as copies of this and related documents.
Contact the MAUI group in DS for information on where to get the code for these libraries and utilities or on how to add another compression algorithm.

How It Impacts The Users
There are four users of the Compression Toolkit:  the Setup Author, the Setup Programmer, the Setup Client, and the non-Setup Programmer.
The Setup Author (presumed in this discussion to be a non-programmer) uses COMPRESS.EXE to compress and split some or all of the files on his product's source diskettes and then makes the necessary rearrangements in the INF file to eliminate disks and possibly rename files (see the section on Naming Conventions below).  With the newest version of COMPRESS.EXE, the author can compress entire directory trees by just specifying directory paths for both the source and destination arguments.  Wildcards are also supported.  Some files should not be compressed -- the Setup executable, the Setup information file and any other files that Setup will be using directly like readme files or a WIN.INI.  The Author also uses DECOMP.EXE to test that the algorithm correctly decompresses each compressed file on the source disks.  This tool should be shipped with the product in case Setup fails and the client needs to decompress files manually.
The Setup Programmer has the easiest job, in most cases.  By defining the COMPRESS compiler flag in the Setup Toolkit build, code will be included in the CopyFile() routine that handles decompression of compressed files.  Non-compressed files are copied in the usual manner.  The Setup routines already handle recombining split files.  The SUDECOMP.LIB library will need to be available at build time either in the Setup directory or a directory in the Library path.  If the Setup Programmer is not using the CopyFile Toolkit routine, he becomes a "Non-Setup Programmer" described below.
The Setup Client, the end-user on the street who just purchased our product that contains compressed files, should not notice any difference other than a slight speed degradation (+20% with Windows 2.11 Runtime Setup with disk savings of 50% on 3.6MBs of sources).  If Setup fails, he is able to use the decompress utility supplied with Setup to decompress files using the syntax "decomp  src-file  dest-dir".  As well, with the newest version, the user can specify wildcards for the source argument.  Things get a bit trickier if Setup fails to install a file that is both compressed and split into multiple pieces; the client will need to decompress the first piece using the above syntax, and then decompress subsequent pieces with the -a flag set to cause appending to the first piece.
The Non-Setup Programmer who wants to use compression can include either or both of the two libraries (SUCOMP.LIB or SUDECOMP.LIB), and can use the API described in the document "API for Character Setup Toolkit Compression Routines" to compress and decompress files.  The library routines deal only with file handles, so the programmer must handle naming, opening, and closing files.  Programmers who wish to add their own compression algorithms should contact MAUI for more information.

Naming Conventions
Files that are compressed should be renamed so that the user will immediately recognize them as 'special' and not attempt to manually copy them from the source diskette.  We encourage programmers to use the following convention:
If the original file name does not contain an extension or the extension is less than three characters, then add a dollar sign character to the end of the extension; if the extension is three (or more) characters, then replace the last character in the extension with a dollar sign character.
Examples:  NOEXT --> NOEXT.$, SMALLEXT.AB --> SMALLEXT.AB$, LARGEEXT.EXE --> LARGEEXT.EX$.
  Since file name information can be lost, the original extension should normally be stored in the header at Compression time by specifying the /e flag (see the Compress Tool Usage Message section below).
The Compress Tool will automatically modify the destination extension to conform to this convention unless a specific destination name is supplied or the -$ switch is issued.  The decompression library does not rename files as they are decompressed.  The Decomp Tool will use information from the header of the compressed file and/or the convention explained above to rename files if the user does not supply a destination name in the command line.  The Decomp Tool automatically will search for a dollar sign convention modified name if the source name supplied does not exist.  The Setup Toolkit will do the same search meaning that the file names in the information file (the INF file) do not need to be changed when files are compressed.  Since the INF entry is used for the destination name, the files will automatically be renamed when they are decompressed.  (See the Character-Setup Toolkit document for exceptions.)    

Information on Splitting Files
It is important to the Char-Setup Toolkit that if a file is split, each of the pieces is independent of the pieces that will preceed or follow it.  This means that if a state table is generated during the decompression then each piece of the file starts with a clean table.  It must appear to the Toolkit as if the source file was split and each piece was compressed independently, not that the file was compressed and then split.  (This distinction is needed because the compression utility specifies the maximum size of the compressed result, not of the uncompressed source, so it may not be possible to determine how to split the source file until the compression has started on the whole file.)
Each portion of a split file must contain a separate header.  If a size is included in the header it will be the uncompressed size of this piece only, not of the entire unsplit file.  These issues should be kept in mind by anyone adding a new compression algorithm; a Setup author or programmer using the existing libraries and utilities need not be concerned with how splitting works.

Compress Tool Usage Message
Usage: compress [-aAlg -bceflq -sSize -tText -zSize] srcArg [destArg]
-a -- Choices for Alg are:  [default = 2]
2 - the Steven Zeck algorithm.
-b will include each file basename in the header.
-c will include a checksum of the srcFile in the header.  Not implemented yet.
-e will include each file extension in the header.
-f will force overwriting and recompression of files.  (Files cannot be compressed in place.)
-l will include each file length in the header.
-q will compute compressed file lengths (no output) (ignores -sz flags).
-s will split output into Size x 512 byte pieces naming each piece with a sequentially higher numerical basename.
-t will include following Text in the header.  Text that includes spaces should be double-quoted.
-z will split off and compress just one piece, and leave the remainder uncompressed in a second file.

srcArg can be a filename, q wildcard pattern, or a directory.  The latter will cause a tree walk operation.  destArg can be a directory, a specific filebase, or omitted in which case digits are appended to the source filename.

Decomp Tool Usage Message
Usage: decomp [-afq] srcFile [destFile | destPath]
-a will append to the destination file, if it exists.
-f will force overwriting if destination file exists.  (Files cannot be decompressed in place.)
-q will calculate size of uncompressed file (no output).

srcArg can be a specific file or a wildcard pattern.  Either can be preceeded by a path.  destArg can be a specific file, a directory, or omitted.  In the last two cases, decomp will try to create a destination filename using information in the src file header or the source filename itself if the header information is incomplete.

Future Features
When other compression algorithms have been added, we should create a tool that takes a given file and tries to maximize compression results using all of the known algorithms.  Right now this does not make sense since we have only one algorithm.
܀      x    u    r    o    l   i   f   c   `   \   Y   U   R  A @ A @ @ A @ B @ B @ A @    x "	  t C	  q 
  m 
  j   f   b &  ^ \  Z _  V q  S   O   R  @ A @ B @ B @ A @ A @ @    w |  s   o M  k m  h !  d !  a !  ] "  Y "  U "  Q $"  M   R @ B @ B @ A @ A @ B @ B$"  '"  w 9"  s :"  o ="  k >"  g ]"  c _"  _ "  [ "  W "  S "  O "  K   @ B @ B @ B @ B @ B @ B"  "  w #  s #  o s#  k u#  g #  c #  _ #  [ #  W #  S #  O $  K   @ B @ B @ B @ B @ B @ B$  $  w a$  s c$  o {$  k $  g $  c $  _ -%  [ 3%  W %  S %  O &  K   @ B @ B @ B @ B @ B @ B&  ,&  x 5&  t `&  p b&  l d&  h &  d &  ` &  \ &  X 6'  T <'  P '  L   @ B @ B @ B @ B @ B @ A'  '  w (  s (  p )  l d&  h &  d &  ` &  \ &  X 6'  T <'  P '  L   @ B @ B @ B @ B @ A @ B            x       u    u       r   r  C  C  C  C  C  C  C  C  C  @ <<<	  	      m   _   Q  C  C  C  C  C  C  C  C  <      <      <            m   _   Q   C  C  C  C  C  C  C  C  <       <      <        <           m   _   _   _  	  Q  C  C  C  C  C  C  <       <   0 <   0 <         	  "	  m C	  _ #
  Q 
  C  C  C  C  C  C  C  C  <      <      <        <      
  
  m 
  _ c  Q   C ]  C  C  C  C  
C  C  C  <      <      <        <       ]  t  m ]  m _  _ s  _ Y  Q        C  C  C  C  C  <      <      <        <      Y    m   _   Q K  C  C  C  C  
C  C  C  C  <      <      <        <   h   K  M  m m  _ )   Q !  C  C  C  C  C  C  C  C  <      <      <        <      !  !  m !  m "  m ="  b ]"  W "  L  C  C  C  C  C  C     
<   0
<   p0
<   0<        "  "  p #  p s#  p #  p #  p a$  p $  p +%  p -%  p  C  C  C  C  C  C  C  C  C <
<   0	-%  &  r &  d .&  d b&  d &  Y &  Y 4'  Y  C  C  C  C  C  C  C  C
<   0<        <   4'  6'  p (  g (  Y (  Y )  K )   C  C  C  C  C        <      <        <   
<   0 
         ,!  )                              ! ) 1 using.doc      04/14/9010/18/89)  
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\msd200a\msd.ini ===
[Commands]

VirtualHDIrq=off,[386enh],SYSTEM.INI
EmmExclude=C000-C7FF,[386enh],SYSTEM.INI
EmmExclude=C000-CBFF,[386enh],SYSTEM.INI
EmmExclude=A000-EFFF,[386enh],SYSTEM.INI
EmmExclude=,[386enh],SYSTEM.INI
EmmPageFrame=,[386enh],SYSTEM.INI
Mouse=,[386enh],SYSTEM.INI
commdrv30=true,[386enh],SYSTEM.INI

Programs=com exe bat pif,[windows],WIN.INI
FILE:=,[ports],WIN.INI

FILES=40, , CONFIG.SYS
BUFFERS=20, , CONFIG.SYS
DEVICEHIGH=, , CONFIG.SYS
DEVICE=, , CONFIG.SYS

LOADHIGH MOUSE, , AUTOEXEC.BAT
MOUSE, , AUTOEXEC.BAT
SET TEMP=C:\WINDOWS\TEMP, , AUTOEXEC.BAT
SET TMP=C:\WINDOWS\TEMP, , AUTOEXEC.BAT
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\case.txt ===
SUMMARY lower upper MakeStr

#include <tools.h>

char *lower(pstr)
char *pstr;

char *upper(pstr)
char *pstr;

DESCRIPTION

lower and upper convert the string to lower and upper case.

RETURN VALUE

Return a pointer to converted string.

IMPLEMENTATION

Calls strlwr and strupr from C library.

SEE ALSO


NOTE


EXAMPLE

#include <tools.h>

char str[] = "Mixed Case String";

main(c, argv)
int c;
char *argv[];
{
    char *pstrLower = lower(MakeStr(str));
    char *pstrUpper = upper(MakeStr(str));

    printf("%s\n%s\n%s\n", str, pstrLower, pstrUpper);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\blank.txt ===
SUMMARY  Blank a region of the screen

#include <tools.h>

; blank (x1, y1, x2, y2, a) blanks a region of the screen


ifdef  OS2
cProc	blank,<PUBLIC>
parmW	x1
parmW	y1
parmW	x2
parmW	y2
parmB	a
localW	cell
else
cProc	blank,<PUBLIC>,<si,di>
parmB	x1
parmB	y1
parmB	x2
parmB	y2
parmB	a


DESCRIPTION

the x and y coordinate values are character columns and rows

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\connect.txt ===
SUMMARY  Connect  fDisconnect		DOS only

#include <tools.h>

int Connect (path, con, sub)
char *path;
char *con;
char *sub;

flagType fDisconnect (drive)
int drive;

DESCRIPTION

Connect takes a name in the form \\mach\path and attempts to connect to
the named machine.	Since DOS 3.x has problems with connections, we
attach the connection to a drive.

fDisconnect will delete a connection to a particular drive given
the token returned by Connect.

RETURN VALUE

Connect returns -1 if connection was not successful, otherwise
returns drive token.

fDisconnect returns TRUE if disconnection was successful

IMPLEMENTATION

Connect parameters:
path	network name of the form 
	    \\machine\path  -or- 
	    \\machine\shortname\path
con 	buffer to place the successful connection
sub 	buffer to place the remainder of the path

fDisocnnect parameters:
drive 	drive token

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\readme.txt ===
From: BenS
Subj: New commands for MS-DOS 6, lifted from SYSTOOLS!
Date: 07-Nov-1992 bens Initial version
      14-Nov-1992 bens Modified comments to reflect original source location,
                         and importance of SETARGV.OBJ.

HOW TO BUILD
============
1) Edit SETENV.BAT to set the correct value for ROOT.
2) Run SETENV.BAT
3) NMAKE

   NOTE: These tools build with C6!


LOCALIZATION NOTES
==================
1) The *.MSG files are meant to be translated.  I assume johnhic will
   move these to the appropriate LANG directory tree and fix the makefile.

2) These commands use some C run-time library error message strings,
   so you need to be sure to link with the translated SLIBCE.LIB!


HISTORY
=======
The files in the NEWCMDS directory were copied from:
    \\TOOLSVR\SOURCES\SLM\SRC\SYSTOOLS\CMDS
and then trimmed down to remove OS/2, bound, and NT build options.

The files in the TOOLIB directory tree were copied from:
    \\TOOLSVR\SOURCES\SLM\SRC\TLIBS\TOOLS
and then trimmed down to remove OS/2, bound, and NT build options.

Note that MarkZ is the creator of this, but as of 07-Nov-1992
ErichSt is responsible for maintenance.


General Notes
=============
Tools are linked with SETARGV.OBJ from the standard C run-time library
to get automatic expansion of wild cards in arguments.
This is IMPORTANT!


Files to Localize
=================
DELTREE.MSG
MOVE.MSG
TOOLIB\SRC\MESSAGES.MSG


DELTREE (formerly DELNODE) NOTES
================================
In the \\TOOLSVR project, it linked with LIBH.LIB and RE.MI
libraries.  These did not seemed to be used, so I stopped linking
with them.


MOVE (formerly MV) NOTES
========================
In the \\TOOLSVR project, it linked with LIBH.LIB and RE.MI
libraries.  These did not seemed to be used, so I stopped linking
with them.

<<< the end >>>
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\args.txt ===
SUMMARY Access runtime options as names and values.

KEYWORDS argConfig argSeqn argOpen argName argValu

USAGE

#include <args.h>

// basic loockup structure
typedef char *ArgName;

typedef int *ArgOrder;

typedef int (*ArgTestFunc) ( char *, char ** );

ArgTestFunc argIsName;

void argConfig (
    MapItemPtr pNames,
    ArgOrder piSeqn,
    int cSeqn,
    char *szMrk,
    char *szSep
    );

void argSeqn (
    ArgOrder piSeqn,
    int cSeqn
    );

void argOpen (
    char **argv
    );

char **argShut ( void );

int argName (
    int bad,
    ArgName *pszText
    );

int argPeek (
    int bad,
    ArgName *pszText
    );

char *argValu (
    void
    );

DESCRIPTION

The arg library provides convenient access to a program's command
line options.  The library supports multi-letter argument names
(e.g. "/delete"), case insensitive name matches, positional
arguments and flexible argument formats ("/domain:nbu" vs.
"/domain nbu").

The options on a command line are treated differently depending
on their initial character.  Options that begin with a mark
character (normally "/" or "-") are argument names.  Other options
are argument values, and are associated with the preceeding
argument name.

Once the caller provides several small parsing tables and the
address of the argv structure, argument names and values are
retrieved in sequential order.

argConfig() is used to establish the parsing tables.  The pNames
    argument provides a mapping from strings to integers.
    Normally, the integers are defined as an enumerated type.
    One of these integers will be returned by argName when the
    current command line option matches an argument name.  piSeqn
    implements positional arguments.  It defines the sequence of
    integers to be returned if an argument value is found without
    a preceeding argument name.	cSeqn is the number of entries
    in piSeqn.	szMrk is a string of the characters that mark an
    argument.  If NULL, "-/" is used.  szSep is a similar string
    of characters that separate a name from a value.  If NULL,
    the characters ":=" are used.

argOpen() provides the argument vector to the arg library.  It
    need only be called once, with the argv received by main().

argName() determines the name for the next argument.  If positional
    argument values are not being used, the next option must start
    with a mark character.  Otherwise argName returns with the value of
    of the "bad" argument.  If the next option is a positional
    argument values, the next entry from the piSeqn array is returned.
    If the option starts with a mark charater, the remaining text
    is checked for a match in the table of argument names.  The
    actual text of the argument name is assigned to pszText on output.

argValu() returns the next argument value string.  If the next
    unread option in argv starts with a mark character (an
    argument name, not an option), it returns NULL.

argSeqn() allows the positional argument sequence to be changed.
    This is generally used when one option changes the
    potential meaning of later options.

argPeek() allows you to "peek" at the next argument name in argv
    without actually reading past it. So it functions in much the same
    way as argName() except that it doesn't cause the advancement past the
    next argument name.

argIsName This pointer may be setup to point to one's own argument name
    detection function. This is particularly useful for parsing arguments
    that do not have the mark characters (like '-' or '/') preceeding the
    argument names as in the case of services started up by Lan Manager.

NOTES

Argument name matching is performed with mapAbbrStr and striprefix,
and the argument names table must conform to mapAbbrStr restrictions.

SEE ALSO

striprefix

mapAbbrStr

EXAMPLE

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "args.h"

char *fnSrc;
char *fnDst;

typedef enum {
    MODE_ASCII, MODE_BINARY }
    ModeSet;

ModeSet fMode;

/////////////////////////
// ARGUMENT DEFINITION //
/////////////////////////

typedef enum {
    ARG_UNK,
    ARG_SRC, ARG_DST, ARG_BINARY, ARG_ASCII,
    ARG_BAD }
    ArgSet;

MapItemRec allow[] = {

    // "standard" strings
    { "SRC",	ARG_SRC },
    { "DST",	ARG_DST	},
    { "BINARY", ARG_BINARY },
    { "ASCII",	ARG_ASCII },

    // "alias" strings
    { "SOURCE",      ARG_SRC },
    { "DESTINATION", ARG_DST },

    // must be last
    { NULL,	     ARG_UNK }
    };

ArgSet seqTbl [] = { ARG_SRC, ARG_DST };
int seqLen = ( sizeof ( seqTbl ) / sizeof ( ArgSet ));

///////////////////////
// ARGUMENT ROUTINES //
///////////////////////

// establish neutral configuration
void
setConfig ()
{
    fnSrc = NULL;
    fnDst = NULL;
    fMode = MODE_ASCII;
    }

// read command line configuration
void
getConfig (
    char** argv
    )
{
    ArgSet arg;
    ArgName text;

    // set up argument parser
    argConfig ( allow, seqTbl, seqLen, NULL, NULL );
    argOpen ( argv );

    // process each argument
    for(;;) {
	switch ( arg = argNext ( ARG_BAD, &text )) {
	case ARG_SRC:
	    fnSrc = argOptn ();
	    break;

	case ARG_DST:
	    fnDst = argOptn ();
	    break;

	case ARG_ASCII:
	    fMode = MODE_ASCII;
	    break;

	case ARG_BINARY:
	    fMode = MODE_BINARY;
	    break;

	default:
	    if ( text == NULL ) return;

	    // bad argument - fail
	    fprintf ( stderr, "unknown argument %s.\n", text );
	    exit (1);
	    }
	}
   }

void
main (
    int argc,
    char **argv
    )
{

    setConfig ();
    getConfig ( argv + 1 );	// skip program name

    printf ( "source is %s.\n",
	      ( fnSrc ? fnSrc : "standard input" ));

    printf ( "destination is %s.\n",
	      ( fnDst ? fnDst : "standard output" ));

    printf ( "mode is %s.\n",
	      ( fMode == MODE_ASCII ? "ascii" : "binary" ));

    exit (0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\curdir.txt ===
SUMMARY curdir

#include <tools.h>

int curdir(pstrBuf, chDrive)
char *pstrBuf;
char chDrive;

DESCRIPTION

curdir constructs a string at pstrBuf that is the current directory of the
specified drive.  If chDrive is zero, then the current drive is used.
pstrBuf is assumed to be large enough to hold the path, e.g. MAXPATHLEN from
tools.h.

RETURN VALUE

Returns non-zero if invalid drive else zero.

IMPLEMENTATION

Uses dos function 19h if no drive specified and 47h to get current directory.

SEE ALSO   rootpath

NOTE


EXAMPLE

#include <tools.h>

main(c, argv)
int c;
char *argv[];
{
    char str[MAXPATHLEN];

    curdir(str, 0); printf("current directory %s\n", str);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\ctime2l.txt ===
SUMMARY ctime2l ctime2tm date2l

#include <time.h>
#include <tools.h>

long ctime2l(p)
char * p;

struct tm *ctime2tm(p)
char *p;

long date2l(year, month, day, hour, min, sec)
int year, month, day, hour, min, sec;


DESCRIPTION

These functions provide the "inverse" of the C library time routines.


ctime2l takes a strings in the formats

        Mon Jan 12 10:03:55 1986\n\0
        Mon Jan 12 10:03:55 1986\0

representing a local time and and returns a long that is the number of
seconds elapsed since 00:00:00 Jan 1, 1970, Greenwich Mean Time.  This is
the inverse of the C library function ctime.

ctime2tm takes a string in the above format, and returns a structure tm.


date2l takes a date and returns a long that is the number of seconds elapsed
since 00:00:00 Jan 1, 1970, Greenwich Mean Time.  year is the actual year,
e.g. 1986, NOT 86.  month is 1 to 12, NOT 0 to 11.

The string format may end with '\0' or '\n' '\0'.


RETURN VALUE


IMPLEMENTATION


SEE ALSO

C library time functions


NOTE


EXAMPLE

#include <time.h>
#include <tools.h>


main(c, v)
int c;
char **v;
{
    long ltime;
    struct tm *ptm;
    char *p;

    printf("ltime = time(NULL): %ld\n", (ltime = time(NULL)));
    printf("p = ctime(ltime): %s", (p = ctime(&ltime)));

    ptm = localtime(&ltime);
    printf("ptm = localtime(&ltime)\n");
    printf("wday:%d year:%d mon:%d mday:%d yday:%d ",
        ptm->tm_wday, ptm->tm_year, ptm->tm_mon, ptm->tm_mday, ptm->tm_yday);
    printf("hour:%d min:%d sec:%d isdst:%d\n",
        ptm->tm_hour, ptm->tm_min, ptm->tm_sec, ptm->tm_isdst);


    printf("ctime2l(p): %ld\n", ctime2l(p));


    ptm = ctime2tm(p);
    printf("ptm = ctime2tm(p)\n");
    printf("wday:%d year:%d mon:%d mday:%d yday:%d ",
        ptm->tm_wday, ptm->tm_year, ptm->tm_mon, ptm->tm_mday, ptm->tm_yday);
    printf("hour:%d min:%d sec:%d isdst:%d\n",
        ptm->tm_hour, ptm->tm_min, ptm->tm_sec, ptm->tm_isdst);

    printf("date2l(%d, %d, %d, %d, %d, %d): %ld\n",
        ptm->tm_year + 1900, ptm->tm_mon + 1, ptm->tm_mday,
        ptm->tm_hour, ptm->tm_min, ptm->tm_sec,
        date2l(ptm->tm_year + 1900, ptm->tm_mon + 1, ptm->tm_mday,
        ptm->tm_hour, ptm->tm_min, ptm->tm_sec));
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\delnode.txt ===
SUMMARY delnode

#include <tools.h>

int delnode(pstr)
char *pstr;

DESCRIPTION

delnode deletes files and directories, and its subdirectories, specified
by the string.

RETURN VALUE

delnode returns TRUE if one or more files/directories were deleted else
FALSE.

IMPLEMENTATION

forfile is used to enumerate the files/directories matching pstr.

SEE ALSO


NOTE

Hidden and system are deleted if they match the pattern.

EXAMPLE

#include <tools.h>

main(c, argv)
int c;
char *argv[];
{
    printf("%d\n", delnode("deleted"));
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\enfile.txt ===
SUMMARY  EnFile 

#include <tools.h>

int EnFile (pat, attr, rtn, args)
char *pat;
int attr;
void (*rtn)();
unsigned args;

DESCRIPTION

EnFile - apply a procedure to all files that match the input pattern

	pat 	pattern of file to enumerate
	attr	attribute to see
	rtn 	routine to call
	args	arguments to pass to routine

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\cursor.txt ===
SUMMARY   cursor (x, y) sets the current cursor

#include <tools.h>

cProc	cursor,<PUBLIC>
ifdef OS2
parmW	x
parmW	y
else
parmB	x
parmB	y
endif
cBegin


DESCRIPTION

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\error.txt ===
SUMMARY error

#include <tools.h>

char *error();

DESCRIPTION


RETURN VALUE

Returns text of error corresponding to the most recent DOS error.  If
error is <0 or >sys_nerr returns "unknown error".

IMPLEMENTATION


SEE ALSO


NOTE


EXAMPLE

#include <tools.h>

main(c, argv)
int c;
char *argv[];
{
    /* ... dos operation returning error ... */
    printf("%s\n", error);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\envorini.txt ===
SUMMARY getenvini

#include <tools.h>

char *getenvini(pstrEnv, pstrSection)
char *pstrEnv;
char *pstrSection;


DESCRIPTION

getenvini looks for an environment variable pstrSection_pstrEnv, e.g.
if pstrEnv is "mysrc" and pstrSection is "to", getenvini looks for the
environment variable "TO_MYSRC".  (The strings are converted to upper case
because environment variables are upper case'd even though their value is
mixed case.)

If found and the value has non-white space characters, then a copy of the
value is returned.

If found and the value has only white space characters, then NULL is returned.

If the combined string is not found in the environment then the file
$USER:\TOOLS.INI and getenvini tries to find a section [pstrSection] and
an entry "pstrEnv=".  The value of the entry is the string to the right of the
=.

If found and the value has non-white space characters, then a copy of the
value is returned.

If found and the value has only white space characters, then NULL is returned.

If not found then NULL is returned.


If the return value is non-NULL you must free the returned string when you
are done with it.


RETURN VALUE


IMPLEMENTATION

Calls getenv(pstrEnv) from C library and swfind from Tools.lib.

SEE ALSO


NOTE


EXAMPLE

Env contains

    set mysrc=c:\MYSRC

or TOOLS.INI contains

[to]
    mysrc=c:\MYSRC



#include <tools.h>

main(c, argv)
int c;
char *argv[];
{
    printf("%s\n", getenvini ("mysrc", "to"));
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\fastcopy.txt ===
SUMMARY  fastcopy

#include <tools.h>
char * fastcopy (hfSrcParm, hfDstParm)
HFILE hfSrcParm, hfDstParm;

DESCRIPTION

fastcopy - copy data quickly from one handle to another
parameters:
	hfSrcParm	    file handle to read from
	hfDstParm	    file handle to write to


RETURN VALUE

NULL if successful otherwise pointer to error string 

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\fappend.txt ===
SUMMARY fappend

#include <tools.h>

char *fappend(pstrSrc, fhDest)
char *pstrSrc;
int fhDest;

DESCRIPTION

fappend does a fast append of source to destination.

RETURN VALUE

If successful returns NULL else returns a char pointer to the corresponding
test of the error.  Also sets errno (see C library).

IMPLEMENTATION


SEE ALSO   fcopy fdelete fexpunge 

NOTE


EXAMPLE

#include <fcntl.h>  /* to get O_RDWR */
#include <tools.h>

main(c, argv)
int c;
char *argv[];
{
    int fhDest;
    char *pstr;

    /* use open from C library, stdio.h included by tools.h */
    if ((fhDest = open("temp.hlp", O_RDWR)) != -1) {
        if ((pstr = fappend("temp.xpl", fhDest)))
            printf("Error: %s\n");
        }
    else
        printf("Error: can't open destination\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\fcopy.txt ===
SUMMARY fcopy

#include <tools.h>

char *fcopy(pstrSrc, pstrDest)
char *pstrSrc;
char *pstrDest;

DESCRIPTION

fcopy copies the source to the destination preserving attributes and filetimes.

RETURN VALUE

Returns NULL if OK or a char point to the corresponding text of the error.

IMPLEMENTATION


SEE ALSO  fappend fdelete 

NOTE


EXAMPLE

#include <tools.h>

main(c, argv)
int c;
char *argv[];
{
    char *pstr;

    if ((pstr = fcopy("temp.xpl", "temp.hlp")))
            printf("Error: %s\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\fdelete.txt ===
SUMMARY  fdelete

#include <tools.h>

int fdelete(pstrFile)
char *pstrFile;

DESCRIPTION

fdelete deletes a file by indexing it into a separate directory, DELETED,
and then renaming the file into that directory.

RETURN VALUE

0 if successful.
1 if source file did not exist.
2 if source was read-only or if the rename failed.
3 if the index was not accessible.

IMPLEMENTATION


SEE ALSO  Commands: rm exp undel

NOTE


EXAMPLE

#include <tools.h>

main(c, argv)
int c;
char *argv[];
{
    int i;

    if ((i = fdelete("temp.hlp")))
	printf("Error: %d\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\exetype.txt ===
SUMMARY  exeType

#include <tools.h>

exeType( filename ) 
char *filename;

DESCRIPTION
 *  exeType( filename ) -   Return the type of .EXE, based on a quick
 *			    examination of the header.	If it is a new .EXE
 *			    and the OS ( Windows, DOS 4.X, 286DOS ) cannot
 *			    be guessed accurately, just return "new exe".
 *
 *  The algorithm is:
 *
 *	if ( File is too short for old-style header )	==> NOT AN EXE
 *	if ( MZ signature not found )			==> NOT AN EXE
 *	if ( Offset of relocation table != 0x40 )	==> Old-style .EXE
 *	if ( File is too short for new-style header )	==> NOT AN EXE
 *	if ( New Magic number is wrong )		==> Old-stype .EXE
 *	if ( Dynalink flag set )			==> Dyna-link lib
 *	if ( minalloc in old header is 0xFFFF ) 	==> 286DOS .EXE
 *	if ( Import table is empty )			==> DOS 4 .EXE
 *	if ( Resource Table is not empty )		==> Windows .EXE
 *	if ( Stub loader is present )
 *	   if ( "This" is at 0x4E )			==> 286DOS .EXE
	   else 					==> Bound .EXE
 *	else						==> New-style .EXE

RETURN VALUE

IMPLEMENTATION

Pull in the #defined values from tools.h

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\forfile.txt ===
SUMMARY forfile

#include <tools.h>

int forfile(pstrPattern, attr, pProc, args)
char *pstrPattern;      /* search pattern */
int attr;               /* file attributes to match */
void (*pProc)();        /* proc called for each file found */
unsigned args;          /* extra args for call back proc */

Proc(pstrName, pFindBuf, pArgs)  /* routine called for each enumerated file */
char *pstrName;
struct findType *pFindBuf;
unsigned *pArgs;

DESCRIPTION

For all files matching with a file name matching pstrPattern and having
a subset of the attributes attr, the routine pProc is called and passed
the a completed pattern for the file, a pointer to the find buffer for
the file and a pointer to args.

RETURN VALUE

Control is returned from forfile after all files, if any, have been
enumerated and pProc called for each.  forfile returns FALSE if no files
were enumerated and returns TRUE if one or more were enumerated.

IMPLEMENTATION

char *pstrBuf = alloc buffer size MAXPATHLEN;
char *p;
struct findType *pFindBuf;

drive(pstrPattern, pstrBuf);        /* copy drive part of pattern */
path(pstrPattern, strend(pstrBuf);  /* copy path  part of pattern */
p = strend(pstrBuf);                /* remember end of current pattern */

do {
    strcpy(p, pFindBuf->name);  /* add on completed file name */
    lower(p);
    (*pProc)(pstrBuf, pFindBuf, pArgs);
    } while (fnext(fFindBuf));


SEE ALSO  ffirst fnext 


NOTE

Patterns and attributes are described separately.

EXAMPLE

#include <tools.h>

DoPrint(pstrName, pFindBuf, pArgs)
char *pstrName;
struct findType *pFindBuf;
unsigned *pArgs;
{
    printf("File found %s\n", pstrName);
}

main(c, argv)
int c;
char *argv[];
{
    /* print names of C files in current directory w/ archive bit set */
    if (!forfile("*.c", A_A, DoPrint))
        printf("No files found\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\find.txt ===
SUMMARY ffirst fnext

#include <tools.h>

int ffirst(pstrPattern, attr, pFindBuf)
char *pstrPattern;
int attr;
struct findType *pFindBuf;

int fnext(pFindBuf)
struct findType *pFindBuf;

DESCRIPTION

Uses the DOS functions 4E, ffirst, and 4F, fnext, to enumerate files
matching the pattern pstrPattern and having the attributes attr.  The find
buffer is filled in.

Call ffirst to find the first file.  Call fnext for each subsequent file.

	int ffirst(pstrPattern, attr, pFindBuf)

	file	char pointer to name string with pattern in last component.
	attr	inclusive attributes for search
	fbuf	pointer to buffer for find stuff

	int fnext(pFindBuf)

	fbuf	pointer to find buffer

RETURN VALUE

Returns zero if no error, i.e. file found returns zero.  Returns non-zero
on error, i.e. file NOT found returns non-zero.

	returns	(DOS) TRUE if error, FALSE if success
	(OS2) error code or NO_ERROR


IMPLEMENTATION

ffirst:
    pass address of find buffer to dos using function 1a
    call function 4e with pattern and attribute

fnext:
    pass address of find buffer to dos using function 1a
    call function 4f

SEE ALSO  forfile 

NOTE

Patterns and attributes are described separately.

EXAMPLE

#include <tools.h>

main(c, argv)
int c;
char *argv[];
{
    struct findType findBuf;
    char str[MAXPATHLEN];

    if (ffirst ("*.c", A_A, &findBuf))
	printf("No files found\n");
    else {
	printf("File found %s\n", findBuf.name);
	while (!fnext(&findBuf))
	    printf("File found %s\n", findBuf.name);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\forsemi.txt ===
SUMMARY forsemi

#include <tools.h>

int forsemi(pstr, pProc, args)
char *pstr;
flagType (*pProc)();
unsigned args;

flagType Proc(pstrSub, pArgs); /* routine called for each enumerated file */
char *pstrSub;
unsigned *pArgs;

DESCRIPTION

pstr is a pointer to a string containing zero or more semicolons.  The
callback routine is called one or more times with a pointer to a substring
delimited by semicolons.  The substring does NOT contain semicolons.  The
first time the routine is called, pstrSub is equal to pstr.  If pstr
contains no semicolons, the routine is called only once.

The callback routine can terminate enumeration by returning non-zero or
continue the enumeration by returning zero.

RETURN VALUE

forsemi returns TRUE if enumeration is terminated at the request of the
callback routine otherwise FALSE is returned.

IMPLEMENTATION

char *p1, p;
p = pstr;
do {
    p1 = pointer to next ";" after p
    save char at p1
    *p1 = 0, i.e. modify source string
    f = (*pProc)(p, &args)
    p = p1
    *p++ = saved char
    if (f)
	return TRUE, callback routine terminated loop
    } while saved char not equal to '\0'
return FALSE

SEE ALSO


NOTE

WARNING: The source string is modified by forsemi but is restored when
forsemi returns.

EXAMPLE

#include <tools.h>

flagType DoPrint(pstrSub, pArgs)
char *pstrSub;
unsigned *pArgs;
{
    printf("Substring \"%s\"\n", pstrSub);
    return (strcmp(pstrSub, "stop") == 0);
}

main(c, argv)
int c;
char *argv[];
{
    forsemi("no semicolons here", DoPrint);    /* no args */
    forsemi("msc forsemi.c;msc find.c;stop;msc help.c", DoPrint);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\freespac.txt ===
SUMMARY return amount of freespace on a drive

#include <tools.h>

long freespac (d)
int d;

DESCRIPTION

	Return free space on current drive ...

RETURN VALUE

	Free space or -1 if error.... ?

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\fexpunge.txt ===
SUMMARY fexpunge

#include <tools.h>

long fexpunge(pstrDir, pfileList)
char *pstrDir;
FILE *pfileList;

DESCRIPTION

fexpunge opens the index file in the indicated directory's deleted directory,
releases all the deleted files present, removes the index file and then
removes the directory.	If pfileList is not NULL, then a log of the files
deleted is written using the C library fprintf(pfileList, ...).

pstrDir is the name of the directory that has DELETED as a subdirectory.

RETURN VALUE

Returns the number of bytes freed.

IMPLEMENTATION


SEE ALSO  Commands: exp undel rm

Library routine: fdelete

NOTE


EXAMPLE

#include <tools.h>

main(c, argv)
int c;
char *argv[];
{
    char strCurDir[MAXPATHLEN];

    rootpath (".", strCurDir);
    printf("Bytes freed: %ld\n", (long)fexpunge(strCurDir, stdout));
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\exec.txt ===
An EXEC function with memory swap
              =================================

        Thomas Wagner
        Ferrari electronic GmbH
        Beusselstrasse 27
        D-1000 Berlin 21
        West Germany

Version 2.2, released 90-08-16.

This archive contains the sources for an 'EXEC' function that
optionally swaps out the memory image of the calling program to a
temporary file or to EMS, and shrinks down to a minimal core before
executing the program.

This allows chaining or spawning to memory-hungry programs, and it
eases building of DOS menu-systems. The memory used when swapping is
less than 1k, plus the memory needed for a copy of the environment. If
you pass a new environment to the spawned program, space for two
copies of the environment are needed.

EMS (LIM 3.0 or above) is used automatically if there is enough space
left, otherwise a temporary file is created. If the "TEMP=" or "TMP="
environment variable is present, the temporary file is created in the
directory specified by this variable, otherwise it is created in the
current directory.


                        CHANGES
                        =======

Changes from version 1.0 to 2.0:

1) Problem fixes

- Problems with EMS drivers that return handles above 255 have been
  fixed.

- Bug that prevented deletion of temporary file has been fixed.

- The Division by Zero interrupt vector is patched to an IRET and
  restored when swapping back in.


2) Enhancements

- The TMP/TEMP environment string is checked for validity, and
  is ignored if it points to a non-existent directory.

- For DOS versions 3.0 and above, the temporary file is created using
  the special DOS function. This eliminates the extra overhead for
  generating a unique filename.

- Now compatible with Microsoft C 5.x.

- Non-contiguous memory blocks can be swapped.

- The 'spwn' parameter to the do_exec function has been changed to
  allow EMS usage to be controlled. It can now have the values -1, 0,
  and 1. The internal assembler routine takes an additional method
  parameter, it no longer uses the first byte of the swap-filename
  to determine swapping method.


Changes from version 2.0 to 2.2:

  Several bugs in spawn.asm were fixed, no other changes.


                        INTERFACE
                        =========

        extern int do_exec (char *xfn, char *pars, int spwn,
                            unsigned needed, char **envp);


Parameters:
            xfn         is a string containing the name of the file
                        to be executed. If the string is empty,
                        the COMSPEC environment variable is used to
                        load a copy of COMMAND.COM or its equivalent.
                        If the filename does not include a path, the
                        current PATH is searched after the default.
                        If the filename does not include an extension,
                        the path is scanned for a COM or EXE file in
                        that order.

            pars        The program parameters.

            spwn        If 1, the function will return, if necessary
                        after swapping the memory image.
                        If -1, EMS will not be used when swapping.
                        If 0, the function will terminate after the
                        EXECed program returns.
                        NOTE: If the program file is not found,
                        the function will always return
                        with the appropriate error code, even if
                        'spwn' is 0.

            needed      The memory needed for the program in
                        paragraphs. If not enough memory is free, the
                        program will be swapped out. Use 0 to never
                        swap, $ffff to always swap. If 'spwn' is false,
                        this parameter is irrelevant.

            envp        The environment to be passed to the spawned
                        program. If this parameter is NULL, a copy
                        of the parent's environment is used (i.e.
                        'putenv' calls have no effect). If non-NULL,
                        envp must point to an array of pointers to
                        strings, terminated by a NULL pointer (the
                        standard variable 'environ' may be used).


Return value:

            0000..00FF: The EXECed Program's return code
            (0..255 decimal)
            0100:       Error writing swap file
            (256 decimal)
            0200:       Program file not found
            (512 decimal)
            03xx:       DOS-error-code xx calling EXEC
            (768..1023 decimal)
            0400:       Error allocating environment buffer
            (1024 decimal)



                        RESTRICTIONS
                        ============

The calling program may not have interrupt handlers installed when
calling the do_exec function. This includes handlers for Control C
and critical errors.

All open files will stay open during the EXEC call. This reduces the
number of handles available to the child process. The "C_FILE_INFO"
environment variable created by the standard C spawn is not supported.

BAT-files and internal commands are not automatically processed. You
can execute those by calling the do_exec function twice, for example:

     retcode = do_exec ("dir", "*.*", 1, 0xffff, environ);
     if (retcode == 0x200)
        retcode = do_exec ("", "/c dir *.*", 1, 0xffff, environ);


                        CAUTIONS
                        ========

The functions should be compatible with DOS versions down to DOS
2.21, but they have been tested under DOS 3.3 and DOS 4.0 only.

Spawning a command that exits and stays resident (TSR), like PRINT or
Sidekick, will fragment memory and prevent a return to the calling
program. This should, however, not crash the system. Allocated EMS
pages are released, but a swap file is not deleted.

The memory image of the calling program should be contiguous. This
is always guaranteed if you use the standard Turbo C allocation
routines only. The swapper is able to swap non-contiguous blocks such
as those created by the Microsoft far allocation routines. However,
to do this, the swapper has to use undocumented fields in the memory
control blocks, and modify DOS memory control blocks directly. This
may lead to incompatibilities in later versions of DOS, or in DOS
substitutes or emulators.

When debugging the assembler module, take care not to set breakpoints
in the code while it is being swapped out. Those breakpoints (INT 3
instructions) will be swapped back in later without the debugger
knowing about it, and cause quite strange results when you run through
the code for the second time.

                           ACKNOWLEDGEMENTS
                           ================

Thanks to H. Qualls, H. Gubler, J. Clinton, and M. Adler for pointing
out bugs and suggesting enhancements.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\fgetl.txt ===
SUMMARY fgetl fputl

#include <tools.h>

int fgetl(pbuf, len, pFile);
char *pbuf;
int len;
FILE *pFile;

int fputl(pbuf, len, pFile);
char *pbuf;
int len;
FILE *pFile;

DESCRIPTION

fgetl gets the next line from the specified file.  CR and LF are removed
and line is terminated with '\0'.  len is the max number of characters
that may be stored into pbuf.  Returns zero if EOF and no characters written
else returns non-zero.  Tabs, \t, are replaced by appropriate number of
blanks to reach the next tab stop.  Tabs tops are at n*8 for n greater
than or equal to zero.

fputl writes a line to the specified file from pbuf and appends "\r\n" to
indicate end of line.  If EOF on output returns EOF else returns 0.
Tabs are not expanded on output.

RETURN VALUE

See above.

IMPLEMENTATION


SEE ALSO  getl putl pathopen mgetl 

NOTE


EXAMPLE

#include <tools.h>

#define BUFLEN 256
char strPath[MAXPATHLEN];
char bufInput[BUFLEN];
char strLine[BUFLEN];

main(c, argv)
int c;
char *argv[];
{
    FILE *pFile;

    if ((pFile = pathopen("$USER:\\tools.ini", strPath, "r"))) {
        printf("Expanded pathname: %s\n", strPath);
        while (fgetl(strLine, BUFLEN, pFile))
            printf("%s\n", strLine);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\fmove.txt ===
SUMMARY 

#include <tools.h>

fmove (source file, destination file) copies the source to the destination

char *fmove (src,dst)
char *src, *dst;

DESCRIPTION

fmove does the copy and preserves file attributes

RETURN VALUE

preserving attributes and filetimes.  Returns NULL if OK or a char pointer
to the corresponding text of the error

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\getattr.txt ===
SUMMARY getattr - return attribute for a directory entry

#include <tools.h>

int getattr (pname)
char *pname;

DESCRIPTION

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\getl.txt ===
SUMMARY getlinit getl getlpos

#include <tools.h>

void getlinit(pbuf, len, fh)
char far *pbuf;
int len;
int fh;     /* file handle NOT a pointer to FILE */

int getl(pstrDest, len)
char *pstrDest;
int len;

long getlpos();

DESCRIPTION

getlinit, getl and getlpos are very fast routines for reading a file.

getlinit stores its input for later use by getl.  pbuf is a long pointer to
an area of size len that will be used as an input buffer when reading from
the specified file.

getl gets the next line of input and stores the '\0' terminated string at
pstrDest; len is maximum number of characters that should be returned.
returns zero if EOF else returns non-zero.  Tabs are expanded.  \n are removed.
\r are NOT removed.  If returned line contains \r, the non-zero return
value is 1.

getlpos returns the current stream postion of the input.

RETURN VALUE

See above.

IMPLEMENTATION


SEE ALSO  fgetl fputl open (from C library)

NOTE

These routines use a file handle, an int, not a pointer to FILE as to
fgetl and fputl.  Hence do NOT use pathopen to open the file (see example
below).

EXAMPLE

#include <fcntl.h>      /* needed for access to open */
#include <sys\types.h>  /* needed for access to open */
#include <sys\stat.h>   /* needed for access to open */
#include <io.h>         /* needed for access to open */
#include <tools.h>

#define BUFLEN 256
char strPath[MAXPATHLEN];
char bufInput[BUFLEN];
char strLine[BUFLEN];
long lPos;

mygetl(p, len)
char *p;
int len;
{
    lPos = getlpos();
    return getl(p, len);
}

main(c, argv)
int c;
char *argv[];
{
    int fh;

    /*  use open not pathopen because getlinit needs int not pointer to FILE
     *  use findpath to expand USER environment variable
     */
    if (findpath("$USER:\\tools.ini", strPath, TRUE) &&
        (fh = open(strPath, O_RDONLY | O_BINARY)) != -1) {
        printf("Expanded pathname: %s\n", strPath);
        getlinit((char far *)bufInput, BUFLEN, fh);
        while (mygetl(strLine, BUFLEN) != NULL)
            printf("%08ld %s\n", lPos, strLine);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\int.txt ===
SUMMARY  Perform MSDOS absolute disk read/write

#include <tools.h>

cProc	int25,<PUBLIC>,<SI,DI>
parmB	drive
parmD	dst
parmW	count
parmW	sector

cProc	int26,<PUBLIC>,<si,di>
parmB	drive
parmD	src
parmW	count
parmW	sector

DESCRIPTION


RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\heapchk.txt ===
SUMMARY heapchk heapset heapinfo

#include <tools.h>

long lHeapSize;
long lHeapFree;
long lHeapLargest;

int heapchk ( );

int heapset ( fillchar )
int fillchar;

int heapinfo ( );

long heapsize ( );

long heapfree ( );

DESCRIPTION

heapchk checks the heap for consistency.

heapset sets free nodes in the heap to the fillchar.

heapinfo set the values of lHeapSize, lHeapFree, lHeapLargest. lHeapSize is
the size of the heap in bytes (including headers), lHeapFree is free space
(including headers), lHeapLargest is size in bytes of the largest free node
(doesn't include 2 bytes needed for the header).

heapsize calls heapinfo and if HEAPOK returns lHeapSize else returns
error code.

heapfree, same as heapsize, except returns number of free bytes (including
headers) in heap.


RETURN VALUE

heapchk, heapset and heapinfo return HEALPOK if operation successful.

All return HEAPCANTFIND or HEAPBADNODE if there are problems with the heap.
Since heapsize and heapfree return longs, you must do appropriate casting.

    HEAPOK          - completed okay, or not initialized yet
    HEAPCANTFIND    - can't find heap, initial node trashed
    HEAPBADNODE     - malformed node somewhere in heap


IMPLEMENTATION



EXAMPLE

#include <tools.h>

extern long lHeapSize;
extern long lHeapFree;

main(c, argv)
int c;
char *argv[];
{
    flagType fHeapChk;

    if ( ( fHeapChk = heapchk ( ) ) != HEAPOK )
        fprintf ( stderr, "%s\n", ( fHeapChk == HEAPCANTFIND ?
            "Can't find heap" : "Damaged heap" ) );

    if ( ( fHeapChk = heapset ( '?') ) != HEAPOK )
        fprintf ( stderr, "%s\n", ( fHeapChk == HEAPCANTFIND ?
            "Can't find heap" : "Damaged heap" ) );

    if ( heapinfo ( ) == HEAPOK )
        fprintf ( stderr, "Heap size:%5ld  used:%5ld\n", lHeapSize,
            lHeapSize - lHeapFree );
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\kbhit.txt ===
SUMMARY  kbhit zgetch

#include <tools.h>

int kbhit();

char zgetch();

DESCRIPTION

kbhit returns 0 if a character from the keyboard is available otherwise
non-zero is returned.

zgetch returns the next character typed.  Input is NOT automatically echoed.

RETURN VALUE


IMPLEMENTATION


SEE ALSO


NOTE


EXAMPLE

#include <tools.h>

/*  #include <stdio.h> is NOT needed for access to putchar from C library
 *  because including tools.h automatically includes <stdio.h>
 */

main(c, argv)
int c;
char *argv[];
{
    char ch;

    while (ch != 's') {
	ch = '.';
	 if (!kbhit())
	    ch = zgetch();
	 putchar(ch);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\init.txt ===
SUMMARY swopen swclose swread swfind swparse swmatch

#include <tools.h>

FILE *swopen(pstrFile, pstrSection)
char *pstrFile;
char *pstrSection;

int swclose(pFile)
FILE *pFile;

int swread(pstrBuf, len, pFile)
char * pstrBuf;
int len;
FILE *pFile;

char *swfind(pstrEntry, pFile, pstrSection)
char * pstrEntry;
FILE *pFile;
char * pstrSection;

flagType swgoto(pFile, pstrSection)
FILE *pFile;
char *pstrSection;

int swparse(pstrBuf, seps, lhs, rhs, sep)
char *pstrBuf;
char *seps[];
char **plhs;
char **prhs;
char **psep;

char *swmatch(fh, pstrSection)
FILE *fh;
char *pstrSection;


DESCRIPTION

swopen, swread and swclose are used to locate and read a particular
switch section of a file, e.g. the [make] section of TOOLS.INI.
pathopen is used to open the file, i.e. environment variable expansion
is done.

swopen returns a pointer to FILE if the specified file has a line that
has the specified section.  The file is left open.  If it does not contain
a section, the file is closed and NULL is returned.  A line contains the
specified section if its first non-white space characters are [section],
e.g. [make].  The file is left positioned after the section line.

swclose does fclose(pFile) and returns the return value of fclose.

swread reads lines from the switch file.  It returns NULL if it reaches
end of file or another section line otherwise non-NULL is returned.  Lines
beginning with a semicolon are NOT returned.

swfind reads lines from the switch file looking for a line containing
    lhs=rhs
If a line is found where the lhs is the string pstrEntry, then rhs is
returned.  The returned string is allocated via strdup and should be free'd
when you are done.  If pFile is non-NULL, then the file is assumed to have
been opened by a prior call to swopen and the pstrSection is ignored; the call
to swopen specified the section of interest.  If pFile is NULL then an swopen
is called with $USER:\TOOLS.INI and pstrSection.  NULL is returned if a 
matching lsh could not be found or if the rhs is does not contain a non-white 
space char, i.e. if rhs contains only white space char, then NULL is returned.
White space characters are space and tab.

    p = swfind("mysrc", NULL, "to");    /* if file not opened */
    p = swfind("mysrc", pFile, NULL);   /* if file opened     */

swgoto reads lines from the already opened file pFile looking for a start
of section with label pstrSection.  Returns zero if section not found else
returns non-zero and file is left positioned to read first line of section,
i.e. read for a call to swfind.  This interface allows you to open the
file with an interface other than swopen or swfind and yet get the file
postioned so that you can use swfind.

swparse parses the given line and returns pointers to lhs, rhs and the
separator. seps is a null-terminated list of valid separators. This interface
makes it real easy to process the lines as you read them in one after the
other without having to look for a specific lhs or in a specified order. If
any of lhs, rhs or sep are missing, the pointers returned for them will be
NULL. Note that the buffer contents may be modified (pass in a copy if the
line is required for further processing).

   char *seps[] = {":", "=", ":=", NULL};  /* possible set of separators */

swmatch is a variation of swgoto that looks for the start of a section with
a label that has the prefix (case insensitive) pstrSection. If successful it 
returns the actual label found otherwise NULL is returned. This interface is 
helpful if you do not know the label you are looking for or if all sections 
are of interest (in this case set pstrSection = "").


RETURN VALUE


IMPLEMENTATION


SEE ALSO  pathopen 

NOTE


EXAMPLE

#include <malloc.h>
#include <tools.h>

#define BUFLEN 256

main(c, argv)
int c;
char *argv[];
{
    FILE *pFile;
    char strLine[BUFLEN];
    char *p;

    if ((pFile = swopen ("$USER:\\tools.ini", "to") )) {
        printf ("Contents of $USER:\\tools.ini section [to]\n");
        while (swread (strLine, BUFLEN, pFile) )
            printf ("\"%s\"\n", strLine);
        swclose (pFile);
        }
    p = swfind ("mysrc", NULL, "to");
    printf ("\n%s\n", p);
    free (p);
    if ((pFile = swopen ("$USER:\\tools.ini", "to") )) {
        p = swfind ("mysrc", pFile, NULL);
        printf ("\n%s\n", p);
        free (p);
        swclose (pFile);
        }
    if ((p = swfind ("mysrc", NULL, "to"))) {
        printf ("\n%s\n", p);
        free (p);
	}
    if ((pFile = fopen ("my.ini", "rt") )) {
	p = swmatch (pFile, "TOOL")
	printf ("\n%s\n", p);
	free (p);
	swclose (pFile);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\ftw.txt ===
SUMMARY   walk a file tree (OS2 1.2 only)

#include <ftw.h>

int ftw( char *path, int (*fn)(char *, struct stat *, int), int depth)

DESCRIPTION

  The ftw() function recursively  descends the directory hierarchy rooted in 
path.  For each object in the hierarchy, ftw() calls fn(), passing it a 
pointer to a null-terminated character string containing the name of the 
object, a pointer to a STAT structure containing information about the object, 
and an integer.  Possible values of the integer, defined in the <ftw.h> 
header file, areFTW_F for a file, FTW_D for a directory, FTW_DNR for a 
directory that cannot be read, and FTW_NS for an object for which STAT 
could not successfully be executed.  If the integer is FTW_DNR, descendants 
of that directory will not be processed.  If the integer is FTW_NS, the STAT
structure will contain garbage.  An example of an object that would cause
FTW_NS to be passed to fn() would be a file in a directory with read but
without execute (search) permission.

The ftw() function visits a directory before visiting any of its descendants.

RETURN VALUE

The tree traversal continues until the tree is exhausted, an invocation of
fn() returns a nonzero value, or some error is detected within ftw() 
(such as an I/O error).  If the tree is exhausted, ftw() returns zero.
If fn() returns a nonzero value, ftw() stops its tree traversal and returns
whatever value was returned by fn().  If ftw() detects an error, it returns
-1 and sets the error type in errno.

IMPLEMENTATION

The ftw() function uses one file descriptor for each level in the tree.
The depth argument limits the number of file descriptors so used.  If depth
is zero or negative, the effect is the same as if it were 1.  Depth must
not be greater than the number of file descriptors currently available for 
use.  ftw() will run more quickly if depth is at least as large as the 
number of levels in the tree.

SEE ALSO   

NOTE

  Since ftw() is recursive, it is possible for it to terminate 
with a memory fault when applied to very deep file structures.

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\heapdump.txt ===
SUMMARY   heapdump - dump  heap info to fp

#include <tools.h>

int     heapdump ( fp, iFormat )
FILE    *fp;
int     iFormat;


DESCRIPTION

       output to fp:
           _asegds      unsigned
           _asizds      unsigned
           lHeapSize    long        if == -1 then heap error
           lHeapFree    long        if lHeapSize == -1 then this is heap
                                       error code
           lHeapLargest long        if lHeapSize == -1 then zero
  

RETURN VALUE

       returns
           zero    - info written to fp
           nonzero - error writing to fp

IMPLEMENTATION

SEE ALSO   

NOTE
       Note: APPENDS to fp

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\ntoi.txt ===
SUMMARY convert an arbitrary based number to an integer 

#include <tools.h>

int ntoi (p, base)
char *p;
int base;


DESCRIPTION

p points to characters, return -1 if no good characters found
and base is 2 <= base <= 16


RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\mapenv.txt ===
SUMMARY mapenv

#include <tools.h>

void mapenv(pstrSrc, pstrDest)
char *pstrSrc;
char *pstrDest;

DESCRIPTION

mapenv will scan the source string for $(name) and attempt to replace it
with text from the environment.

RETURN VALUE

none

IMPLEMENTATION


SEE ALSO


NOTE


EXAMPLE

#include <tools.h>

char strSrc[] = "Me:$(user) and my $(shadow)";

main(c, argv)
int c;
char *argv[];
{
    char strDest[256];

    mapenv(strSrc, strDest);
    printf("%s\n%s\n", strSrc, strDest);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\maxmin.txt ===
SUMMARY  maximum and minimum routines.

#include <tools.h>

cProc	max,<PUBLIC>
parmW	a
parmW	b

cProc	min,<PUBLIC>
parmW	a
parmW	b

cProc	lmax,<PUBLIC>
parmD	a
parmD	b

cProc	lmin,<PUBLIC>
parmD	a
parmD	b



DESCRIPTION

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\mgetl.txt ===
SUMMARY mgetl

#include <tools.h>

char *mgetl(pbuf, len, pSrc);
char *pbuf;
int len;
char *pSrc;

DESCRIPTION

mgetl gets the next line from the memory at pSrc.  CR and LF are removed
and line is terminated with '\0'.  len is the max number of characters
that may be stored into pbuf.  Returns NULL if *pSrc == NULL at entry else
returns pointer to next char in pSrc to be processed.

Tabs, \t, are replaced by appropriate number of blanks to reach the next
tab stop.  Tabs tops are at n*8 for n greater than or equal to zero.


RETURN VALUE

See above.

IMPLEMENTATION


SEE ALSO  fgetl 

NOTE


EXAMPLE

#include <tools.h>

#define BUFLEN 256
char *strSRC = "firt line\n\ttabbed line\n";
char strLine[BUFLEN];

char *mgetl(char *, int, char *);

main(c, argv)
int c;
char *argv[];
{

    char *p = strSRC;

    while ( ( p = mgetl ( strLine, BUFLEN, p ) ) )
        printf("%s\n", strLine);
}
f
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\move.txt ===
SUMMARY   memory routines

#include <tools.h>

cProc	Move,<PUBLIC>,<DS,SI,DI>
parmD	src
parmD	dst
parmW	count

cProc	Fill,<PUBLIC>,<DI>
parmD	dst
parmB	value
parmW	count

DESCRIPTION

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\match.txt ===
SUMMARY  match a DOS wildcard pattern against given text

flagType fMatch (pat, text)
char *pat, *text;

#include <tools.h>

DESCRIPTION

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\mapstr.txt ===
SUMMARY Translate abbreviated strings to integers.

KEYWORDS mapAbbrStr

USAGE

#include <mapstr.h>


// basic lookup structure
typedef char *MapTxt;
typedef int MapVal;
typedef char* (*MapTst) ( char*, char* );

typedef struct {
    MapTxt label;
    MapVal value;	// use your favorite enum here
    } MapItemRec, *MapItemPtr;

MapItemPtr mapAbbrStr (
    MapTxt szArg,
    MapItemPtr pTable,
    MapTst pTest
    );

DESCRIPTION

The mapAbbrStr routine maps a string to an integer, especially in
the face of multiple string matches.  It uses an array of
label and value pairs to define the mapping function, and calls
a user supplied test routine to actually preform comparisons.

The table argument defines the mapping from labels to values.
It is terminated with an element having a NULL label.  A pointer
to this element is returned if no match is found.

If the arg parameter is a perfect match for any of the labels,
a pointer to the corresponding MapItemRec is returned.	If arg
is a partial match of any of the labels, a pointer to the first
MapItemRec is returned unless there are ambiguous matches.  If
there are ambiguous matches, NULL is returned.

The test routine will be called with the arg parameter as the
first parameter and one of the labels as the second parameter.
The test routine must determine if the two strings don't match,
partially match, or perfectly match.

If the two strings do not match, test must return NULL.  If
the two string match "perfectly", test must return a the address
of the terminating null character of its second argument.  This
indicates a "full" match.  If the two strings partially match,
any non-NULL pointer can be returned.

SEE ALSO

strprefix

striprefix


EXAMPLE

#include <stdlib.h>
#include <stdio.h>

#include "strpfx.h"
#include "mapstr.h"

typedef enum {
    ARG_UNK,
    ARG_SRC, ARG_DST, ARG_BINARY, ARG_ASCII,
    ARG_AMBIGUOUS, ARG_DEMO,
    ARG_BAD }
    ArgSet;

MapItemRec allow[] = {
    // "standard" strings
    { "SRC",	ARG_SRC },
    { "DST",	ARG_DST	},
    { "BINARY", ARG_BINARY },
    { "ASCII",	ARG_ASCII },

    { "AMBIGUOUS", ARG_AMBIGUOUS },
    { "DEMO",	   ARG_DEMO },

    // "alias" strings
    { "SOURCE",      ARG_SRC },
    { "DESTINATION", ARG_DST },
    { "D",	     ARG_DST },     // exact match on "d" is not ambiguous

    // must be last
    { NULL,	     ARG_UNK }
    };

void
main (
    int argc,
    char **argv
    )
{
    MapItemPtr arg;

    for ( ; *argv; argv++ ) {

	arg = mapAbbrStr ( *argv, allow, striprefix );

	if ( arg == NULL )
	    printf ( "argument %s had multiple ambiguous matches.\n", *argv );
	else if ( arg->label == NULL )
	    printf ( "argument %s not in table.\n", *argv );
	else
	    printf ( "argument %s matched %s (%d).\n",
		     *argv, arg->label, arg->value );
	}
    }
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\opendir.txt ===
SUMMARY   methods to gain access to file system directories (OS2 1.2 only)

#include <dirent.h>

DIR *opendir(char *szDirName)

struct dirent *readdir(DIR *pd)

int closedir(DIR *pd)

void rewinddir(DIR *pd)

DESCRIPTION

  The type DIR which is defined in the header file <dirent.h> represents a 
directory stream, which is an ordered sequence of all the directory entries
in a particular directory.  Directory entries represent files; files may be 
removed from a directory or added to a directory asynchronously to the 
operations described in this section.

The opendir() function opens a directory stream corresponding to the 
directory named by the dirname argumnet.  The directory stream is positioned
at the first entry.

The readdir() function returns a pointer to a structure representing the 
directory entry at the current position in the directory stream to which dirp
refers and positions the irectory stream at the next entry.  It returns a
NULL pointer upon reaching the end of the directory stream.  The dot and
dot-dot directory entries are included in the search and returned to the 
caller.

The rewinddir() function resets the position of the directory stream to
which dirp refers to the begining of the directory.  

The closedir() function closes the directory stream referred to by dirp.

RETURN VALUE

  Upon successful completion, the readdir() function returns a pointer 
to an object of type struct dirent that includes the member: 
char[] d_name (a null terminated filename).  Otherwise, a value of NULL
is returned and errno is set to indicate the error.

  The readdir() function returns a pointer to an object of type struct dirent.
When an error is encountered, a value of NULL is returned and errno is set
to indicate the error.  When the end of the directory is encountered,
a value of NULL is returned and errno is not changed by this function call.

  Upon successfull completion, closedir() returns a value of zero.  
Otherwise a value of -1 is returned and errno is set to indicate the error.


IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\pipe.txt ===
SUMMARY create a Xenix stile pipe

#include <tools.h>

pipe( pd )
int pd[2];

DESCRIPTION

    pipe()
  	Xenix pipe using 286DOS call.  Try to make a 16K pipe, then halve
  	request until success.	Minimum pipe is 512 bytes.
  	    If not enough core for pipe, set errno to ENOMEM.
  	    If not enough file handles,  set errno to EMFILE.
  
  

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\pname.txt ===
SUMMARY  pname() form a "pretty" version of a user file name
 */

#include <tools.h>

char *pname (char *pszName)

DESCRIPTION
  
  	OS/2 v1.2 and later will allow filenames to retain the case
  	when created while still being case insensitive for all operations.
  	This allows the user to create more visually appealing file names.
  
  	All runtime routines should, therefore, preserve the case that was
  	input.	Since the user may not have input in the case that the entries
  	were created, we provide a service whereby a pathname is adjusted
  	to be more visually appealing.	The rules are:
  
  	if (real mode)
  	    lowercase the sucker
  	else
  	if (version is <= 1.1)
  	    lowercase the sucker
  	else
  	if (filesystem is FAT)
  	    lowercase the sucker
  	else
  	    for each component starting at the root, use DosFindFirst
  		to retrieve the original case of the name.
  

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\root.txt ===
SUMMARY rootpath

#include <tools.h>

int rootpath(pstrSrc, pstrDest)
char *pstrSrc, *pstrDest;


DESCRIPTION

rootpath generates a path to a file from the root.  *pstrDest is assumed to
be large enough to hold the result.  The source may specify a drive other
than the current drive.

RETURN VALUE

Returns zero if it succeeds else non-zero.

IMPLEMENTATION


SEE ALSO


NOTE


EXAMPLE

#include <tools.h>

main(c, argv)
int c;
char *argv[];
{
    char str[MAXPATHLEN];

    rootpath("temp.txt",     str); printf("%s\n", str);
    rootpath("..\\temp.txt", str); printf("%s\n", str);
    rootpath("b:temp.txt",   str); printf("%s\n", str);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\pathopen.txt ===
SUMMARY pathopen findpath

#include <tools.h>

flagType findpath(pstrFile, pbuf, fNew)
char *pstrFile;
char *pbuf;
flagType fNew;

FILE *pathopen(pstrName, pbuf, pmode)
char *pstrName;
char *pbuf;
char *pmode;

DESCRIPTION

findpath tries to find the file specified by pstrFile.  If pstrFile is of
the form $FOO:BAR where FOO is an environment variable each directory in the
environment variable is searched else the current directory is searched.

If the file is found and pbuf is filled in with the expanded path name and
nonzero is returned.

If the file is not found and fnew is FALSE, zero is returned

If the file is not found and fnew is TRUE pbuf is filled in with the filename
suitable for creating a new file and nonzero is returned, i.e. if pstrFile
is of the form $FOO:BAR, the first directory in the environment variable FOO
is used to create the filename.

E.g.

    PATH:C:\BIN;C:\MYBIN;

if

    findpath("$PATH:BAR", buf, TRUE);

returns nonzero if BAR exists in C:\BIN or C:\MYBIN and buf contains either
C:\BIN\BAR or C:\BIN\BAR; returns zero if BAR does not exist in either and
contents of bar are undefined.

    findpath("$PATH:BAR", buf, FALSE);

always returns nonzero, buf is equal to C:\BIN\BAR or C:\BIN\BAR if it exists
or C:\BIN\BAR if it doesn't exist in both.  (Note: stat(buf, pstatBuf) can
be used to determine if the file exists.)

pathopen expands pstrName to pbuf using findpath with fnew == TRUE and if
it succeeds calls the C library routine fopen with pbuf and mode and returns
the value returned by fopen.  If the call to findpath fails NULL is returned
by pathopen.

RETURN VALUE

See above.

IMPLEMENTATION


SEE ALSO   fopen (C runtime)

NOTE

In findpath, pbuf must point to a buffer large enough to hold the expanded
pathname, e.g. buf[MAXPATHLEN].

EXAMPLE

#include <tools.h>

main(c, argv)
int c;
char *argv[];
{
    char str[MAXPATHLEN];
    flagType f;

    f = findpath("$USER:\\tools.ini", str, TRUE ); printf("%d %s\n", f, str);
    f = findpath("$USER:\\tools.tmp", str, TRUE ); printf("%d %s\n", f, str);
    f = findpath("$USER:\\tools.tmp", str, FALSE); printf("%d %s\n", f, str);
    f = findpath("test.c", str, TRUE ); printf("%d %s\n", f, str);
}


give the output assuming SET USER=C:\DANL and TOOLS.INI does exist, TOOLS.TMP
does not exist in C:\DANL and TEST.C exists in current directory.

	-1 c:\danl\tools.ini
	-1 c:\danl\tools.tmp
	 0 c:\danl\tools.tmp
	-1 test.c
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\pathcat.txt ===
SUMMARY 

#include <tools.h>

char *pathcat (char *pDst, char *pSrc)

DESCRIPTION

   pathcat - handle concatenation of path strings
    
   Care must be take to handle:
       ""	    XXX     =>	XXX
       A	    B	    =>	A\B
       A\           B	    =>	A\B
       A	    \B	    =>	A\B
       A\           \B	    =>	A\B

       pDst	char pointer to location of 'A' above
       pSrc	char pointer to location of 'B' above

RETURN VALUE

returns pDst

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\pgetl.txt ===
SUMMARY  pgetl - do fgetl() from a pipe without blocking. 

#include <tools.h>

pgetl ( buf, max, fh )
char *buf;
int max;
int fh;

DESCRIPTION

  
  	    If ( Buffer is empty )
  		Fill Buffer
  	    If ( 0 length request ) return ( there is more data )?
  	    { - 1 allows for '\0' byte in target }
  	    set max to min(max - 1, count of valid bytes);
  	    If ( "full line" is buffered )
  		Transfer Full line.
  		Clean up and go
  	    Move partial line to base of buffer
  	    Fill rest of buffer
  	    If ( we have a "full line" now ) transfer it
  	    Else
  		return	FALSE
  
  	A "full line" is either LF terminated or len bytes long, whichever
  	comes first.
  

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\pathchr.txt ===
SUMMARY fPathChr fSwitChr

#include <tools.h>

flagType fPathChr(ch)
char ch;

flagType fSwitChr(ch)
char ch;

DESCRIPTION

fPathChr and fSwitChr test whether the character is a path separator or
a command line switch character.

RETURN VALUE

fPathChr returns non-zero for \ and / otherwise zero.

fSwitChr uses DOS function 37h to determine whether non-zero should be
returned for / or for -.  Otherwise zero is returned.

IMPLEMENTATION


SEE ALSO


NOTE


EXAMPLE

#include <tools.h>

main(c, argv)
int c;
char *argv[];
{
    printf("\\ %d\n", fPathChr('\\'));
    printf("/ %d\n", fPathChr('/'));
    printf("/ %d\n", fSwitChr('/'));
    printf("- %d\n", fSwitChr('-'));
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\strcmps.txt ===
SUMMARY 

#include <tools.h>

strcmps (p1, p2)
register char *p1, *p2;

strcmpis (p1, p2)
register char *p1, *p2;

DESCRIPTION

   strcmps - compare strings and ignore spaces 
   compare two strings, ignoring white space, case is significant, return
   0 if identical, <>0 otherwise

   compare two strings, ignoring white space, case is not significant, return
   0 if identical, <>0 otherwise

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\rspawn.txt ===
SUMMARY rspawnl rspawnv

#include <tools.h>

int rspawnl(fin, fout, pstrPathName, args)
char *fin, *fout, *pstrPathName;
char *args;

int rspawnv(fin, fout, pstrPathName, pargs)
char *fin, *fout, *pstrPathName;
char *pargs[];

DESCRIPTION

rspawnl and rpawnv start a child task with stdin/stdout redirected to fin/fout
if fin/fout are non-zero else stdin/stdout are not redirected.  It is
assumed that by duping fd 0 and 1, the child process will not attempt to
access handles other than 0, 1 and those that it has opened.  The child
is spawned using the C library spawnp interface with mode P_WAIT.
pstrPathName specifies the file to be executed.

RETURN VALUE

If fin/fout can not be redirected -1 is returned else both return the
same value as spawnp.

IMPLEMENTATION

rspawnl:
    return rspawnv(fin, fout, pstrPathName, &args);

rspawnv:
    do redirection
    ret = spawnvp(P_WAIT, pstrPathName, parg);
    undo redirection
    return ret

SEE ALSO


NOTE


EXAMPLE

#include <tools.h>

main(c, argv)
int c;
char *argv[];
{
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\setattr.txt ===
SUMMARY   setattr()  set attribute for a directory entry 

#include <tools.h>

int setattr (pname, attr)
char *pname;
int attr;

DESCRIPTION

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\swchng.txt ===
SUMMARY search and replace lines in tools.ini or similar file

#include <tools.h>

swchnglhs (strSwFile, strTag, strLHS, strRHS)
char *strSwFile;
char *strTag;
char *strLHS;
char *strRHS;

flagType swchng (strSwFile, strTag, strLHS, strRHS, fNoUndel)
char *strSwFile;
char *strTag;
char *strLHS;
char *strRHS;
flagType fNoUndel;

flagType swchange ( char *strSwFile,
		    char *strTag,
		    char *strLHS,
		    char *strRHS,
		    flagType fNoUndel,
		    flagType *pfError	)

DESCRIPTION

   Searchs the file strSwFile for
       [strTag]
           LHS=
 
   and if strRHS is non-empty changes the right hand side to strRHS
   else deletes the line LHS=
 
   swchnglhs: The original file is fdeleted for recovery via UNDEL.
   swchng   : if fNoUndel, then original file is deleted, no UNDEL possible
              else fdeleted for recovery via UNDEL.
 
   LHS=RHS is output right after the start of section and any later
   instances of LHS are removed.  N.B. if RHS is "", no LHS= is output
 
   If section doesn't exist in file, it is appended at end
 
 

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE
    swchng used to delete the .ini file if there was no space available.
    This error status is returned by swchange in the pfError parameter,
    and no change is made if the necessary disk space is not available.

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\string.txt ===
SUMMARY strbscan strbskip strcmpis strcmps strend strpre

#include <tools.h>

char *strbscan(pstr, pstrSet)
char *pstr;
char *pstrSet;

char *strbskip(pstr, pstrSet)
char *pstr;
char *pstrSet;

int strcmps(pstr1, pstr2)
char *pstr1;
char *pstr2;

int strcmpis(pstr1, pstr2)
char *pstr1;
char *pstr2;

char *strend(pstr)
char *pstr;

int strpre(pstr1, pstr2)
char *pstr1;
char *pstr2;

DESCRIPTION

strbscan returns a pointer to first character in string matching a character
in the set else pointer to end of string.

strbskip returns a pointer to first character in string NOT matching a
character in the set else pointer to end of string.

strcmps compares two strings, ignoring white space, case is significant,
returns 0 if identical else non-zero.

strcmpis compares two strings, ignoring white space, case is NOT significant,
returns 0 if identical else non-zero.

strend returns char pointer to end of string.

strpre returns -1 if string1 is a prefix of string 2 else returns zero.
Ignores case.

RETURN VALUE


IMPLEMENTATION


SEE ALSO


NOTE


EXAMPLE

#include <tools.h>

main(c, argv)
int c;
char *argv[];
{
    printf("%s\n", strbscan("abcdefg", "cd"));
    printf("%s\n", strbskip("abcdefg", "ba"));
    printf("%d\n", strcmps ("  hello  ", "Hello"));
    printf("%d\n", strcmpis("  hello  ", "Hello"));
    printf("%d\n", strpre("pre", "prefix"));
    printf("%d\n", strpre("fix", "prefix"));
}

cdefg
cdefg
32
0
-1
0
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\scrollup.txt ===
SUMMARY   Scroll a region of the screen up

#include <tools.h>

; ScrollUp (x1, y1, x2, y2, n, a) scrolls a region up with attribute
;
ifdef OS2
cProc	ScrollUp,<PUBLIC>
parmW	x1
parmW	y1
parmW	x2
parmW	y2
parmW	n
parmW	a
else
cProc	ScrollUp,<PUBLIC>,<si,di>
parmB	x1
parmB	y1
parmB	x2
parmB	y2
parmB	n
parmB	a

DESCRIPTION

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\scrolldn.txt ===
SUMMARY   Scroll a region of the screen down

#include <tools.h>

; ScrollDn (x1, y1, x2, y2, n, a) scrolls a region down with attribute
;
ifdef  OS2
cProc	ScrollDn,<PUBLIC>
parmW	x1
parmW	y1
parmW	x2
parmW	y2
parmW	n
parmW	a
else
cProc	ScrollDn,<PUBLIC>,<si,di>
parmB	x1
parmB	y1
parmB	x2

DESCRIPTION

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\strpfx.txt ===
SUMMARY Determine if one string is a prefix of another.

KEYWORDS strprefix striprefix

USAGE

#include <strpfx.h>

char* strprefix (
    char* szTest,
    char* szFull
    );

char* striprefix (
    char* szTest,
    char* szFull
    );

DESCRIPTION

strprefix and striprefix determine if the szTest argument is
a prefix of the szFull argument.  Strprefix is case sensitive,
while striprefix is case insensitive.

RETURN VALUE

Both routines return NULL if szTest is not a prefix of szFull.

If szTest is a prefix of szFull, the returned pointer identifies
the first character of szFull beyond the match.	 Thus, if the
return is a pointer to a zero byte ('\0'), the szTest is an exact
match of szFull, not just a prefix.

EXAMPLE

strprefix ( "a", "arg" );	// pointer to "rg" returned
strprefix ( "a", "ARG" );	// NULL returned

striprefix ( "a", "ARG" );	// pointer to "RG" returned
striprefix ( "Arg", "ARG" );	// pointer to "" returned
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\zalloc.txt ===
SUMMARY  cover name for standard memory allocator

#include <tools.h>

char * (*tools_alloc) (unsigned) = malloc;

DESCRIPTION

RETURN VALUE

IMPLEMENTATION

SEE ALSO   

NOTE

EXAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\update.txt ===
SUMMARY upd drive extention filename fileext path

[N.B. the spelling is extenTion not extenSion for hysterical reasons.]

#include <tools.h>

int upd(pstrDef, pstrUpd, pstrDst)
char *pstrDef;
char *pstrUpd;
char *pstrDst;

int drive(pstrSrc, pstrDst)
char *pstrSrc;
char *pstrDst;

int extention(pstrSrc, pstrDst)
char *pstrSrc;
char *pstrDst;

int filename(pstrSrc, pstrDst)
char *pstrSrc;
char *pstrDst;

int fileext(pstrSrc, pstrDst)
char *pstrSrc;
char *pstrDst;

int path(pstrSrc, pstrDst)
char *pstrSrc;
char *pstrDst;

DESCRIPTION

upd constructs a destination string from parts supplied by the definition and
update strings.  The parts are DRIVE, PATH, FILENAME and EXTENTION.  The
update has priority over the definition as a source of parts.  The return
value indicates which parts, if any, were copied.

drive, path, filename, extension, fileext copy the corresponding parts, if
any from the source to the destination and return non-zero if a part was
copied and zero if no part copied.

DRIVE is the initial string part upto and including the first colon.  If
there is no colon, then there is no DRIVE part.

PATH starts after the DRIVE part, if any, and goes up to and include last
backslash character.

FILENAME starts after PATH and goes up to but does NOT include a period.

EXTENTION starts after filename with the period.

FILEEXT is FILENAME and EXTENSION

The following is the output from the example below.  The definition
is c:\tools\h\tools.h.

drive	  c:
path	  \tools\h\
filename  tools
extention .h
fileext   tools.h
upd	  c:\temp\test.h

RETURN VALUE

upd returns the OR of the flags U_DRIVE, U_PATH, U_NAME, U_EXT, indicating
which parts were returned.  TESTFLAG can be used to test the return value
for the flags.

drive, path, filename, extension, fileext return non-zero if a part was
copied and zero if no part copied.

IMPLEMENTATION


SEE ALSO


NOTE


EXAMPLE
#include <tools.h>

/* N.B. in string constants \\ represents a single \ */
char str[] = "c:\\tools\\h\\tools.h";

DoPrint(pstr1, pstr2)
char *pstr1, *pstr2;
{
    printf("%s%s\n", pstr1, pstr2);
}

main(c, argv)
int c;
char *argv[];
{
    char buf[MAXPATHLEN];

    drive(str, buf);		    DoPrint("drive     ", buf);
    path(str, buf);		    DoPrint("path      ", buf);
    filename(str, buf); 	    DoPrint("filename  ", buf);
    extention(str, buf);	    DoPrint("extention ", buf);
    fileext(str, buf);		    DoPrint("fileext   ", buf);
    upd(str, "\\temp\\test", buf);  DoPrint("upd       ", buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\headers\line.txt ===
[TEXT: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\untab.txt ===
SUMMARY UnTab

#include <tools.h>

void UnTab(pstrSrc, pstrDest)
char *pstrSrc;
char *pstrDest;

DESCRIPTION

UnTab copies the source string to the destination expanding '\t' tabs.

RETURN VALUE


IMPLEMENTATION


SEE ALSO


NOTE


EXAMPLE

#include <tools.h>

char bufS[] = "oh\thello\tthere";
char bufD[256];

main(c, argv)
int c;
char *argv[];
{
    UnTab(bufS, bufD);
    printf("123456781234567812345678\n%s\n", bufD);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\newcmds\toolib\doc\vector.txt ===
SUMMARY VectorAlloc fAppendVector

#include <tools.h>

struct vectorType {
    int max;                            /* max the vector can hold           */
    int count;                          /* count of elements in vector       */
    unsigned elem[1];                   /* elements in vector                */
};

struct vectorType *VectorAlloc(cElem)
int cElem;

flagType fAppendVector(ppVec, uElem)
struct vectorType **ppVec;
unsigned int uElem;

DESCRIPTION

VectorAlloc allocates a vector large enough to hold cElem elements.

fAppendVector adds an element to a vector.  If the vector is full, a new
larger vector is allocated, the old vector elements are copied, new appended
and old vector deallocated.  If ppVec is NULL a vector of default length
is allocated.

RETURN VALUE

VectorAlloc returns NULL if the vector could not be allocated else returns
pointer to vector.

fAppendVector zero if the element was not appended otherwise non-zero.
*ppVec is updated of a new vector is allocated.

IMPLEMENTATION


SEE ALSO


NOTE


EXAMPLE

#include <tools.h>

#define BUFLEN 256

main(c, argv)
int c;
char *argv[];
{
    FILE *pFile;
    struct vectorType *pVec;
    char strLine[BUFLEN];
    int i;

    pVec = VectorAlloc(1);
    if ((pFile = swopen("$USER:\\tools.ini", "to"))) {
        while (swread(strLine, BUFLEN, pFile) &&
             fAppendVector(&pVec, MakeStr(strLine)))
            ;
        swclose(pFile);
        printf("Contents of $USER:\\tools.ini section [to]\n");
        for (i=0; i< pVec->count; i++)
            printf("%3d \"%s\"\n", i, (char *) pVec->elem[i]);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\bin\c1.err ===
/* SCCSWHAT( "@(#)c1.err	3.69 90/02/01 12:58:41	" ) */
						/* warnings */
	
4001	"nonstandard extension used - '%Fs'"
4002	"too many actual parameters for macro '%s'"
4003	"not enough actual parameters for macro '%s'"
4004	"missing ')' after 'defined'"
4005	"'%s' : macro redefinition"
4006	"#undef expected an identifier"
4007	"'%Fs' : must be '%Fs'"
4008	"'%Fs' : '%Fs' attribute on data ignored"
4009	"string too big, trailing characters truncated"
4011	"identifier truncated to '%Fs'"
4012	"float constant in a cross compilation" /* XC */
4014	"'%Fs' : type of bit field must be unsigned"	/* QC2 */
4015	"'%Fs' : type of bit field must be integral"
4016	"'%s' : no function return type, using int as default"
4017	"cast of int expression to far pointer"
4018	"'%Fs' : signed/unsigned mismatch"
4020	"'%Fs' : too many actual parameters"
4021	"'%Fs' : too few actual parameters"
4022	"'%Fs' : pointer mismatch : parameter %d"
4023	"'%Fs' : _based pointer passed to unprototyped function : parameter %d"
4024	"'%Fs' : different types : parameter %d"
4026	"function declared with formal argument list"
4027	"function declared without formal argument list"
4028	"parameter %d declaration different"
4029	"declared parameter list different from definition"
4030	"first parameter list longer than the second"
4031	"second parameter list longer than the first"
4032	"unnamed struct/union as parameter"
4033	"function must return a value"
4034	"sizeof returns 0"
4035	"'%Fs' : no return value"
4037	"'%Fs' : formal parameters ignored" /* QC2 */
4038	"'%Fs' : formal parameter has bad storage class"	/* QC2 */
4040	"memory attribute on '%Fs' ignored"
4042	"'%Fs' : has bad storage class"
4044	"_huge on '%Fs' ignored, must be an array"
4045	"'%s' : array bounds overflow"
4046	"'&' on function/array, ignored"	/* QC2 */
4047	"'%s' : different levels of indirection"
4048	"array's declared subscripts different"
4049	"'%s' : indirection to different types"
4050	"'%s' : different code attributes"
4051	"type conversion - possible loss of data"
4053	"at least one void operand"
4056	"overflow in constant arithmetic"	/* QC2, c1, c23 */
4058	"address of automatic (local) variable taken, DS != SS" /* QC, c23 */
4059	"segment lost in conversion"	/* QC, c23 */
4060	"conversion of long address to short address"	/* QC2 */
4061	"long/short mismatch in argument : conversion supplied"	/* QC, c23 */
4062	"near/far mismatch in argument : conversion supplied"	/* QC, c23 */
4067	"unexpected characters following '%s' directive - newline expected"
4068	"unknown pragma"
4069	"conversion of near pointer to long integer"	/* QC, c23 */
4071	"'%Fs' : no function prototype given"
4072	"'%Fs' : no function prototype on _fastcall function"
4074	"nonstandard extension used - '%s'" /* QC2 */
4075	"size of switch expression or case constant too large - converted to int" /* QC2 */
4076	"'%s' : may be used on integral types only"
4077	"unknown check_stack option"
4078	"case constant '%ld' too big for the type of switch expression"
4079	"unexpected token '%s'"
4080	"expected identifier for segment name, found '%s'"
4081	"expected a comma, found '%s'"
4082	"expected an identifier, found '%s'"
4083	"expected '(', found '%s'"
4084	"expected a pragma directive, found '%s'"
4085	"expected [on | off]"
4086	"expected [1 | 2 | 4]"
4087	"'%Fs' : declared with void parameter list"
4088	"'%Fs' : pointer mismatch : parameter %d, parameter list %d"
4089	"'%Fs' : different types : parameter %d, parameter list %d"
4090	"different 'const/volatile' qualifiers"
4091	"no symbols were declared"
4092	"untagged enum/struct/union declared no symbols"
4093	"unescaped newline in character constant in inactive code"
4095	"expected ')', found '%s'"
4096	"'%Fs' must be used with '%Fs'"
4098	"void function returning a value"
4100	"'%Fs' : unreferenced formal parameter"
4101	"'%Fs' : unreferenced local variable"
4102	"'%Fs' : unreferenced label"
4104	"'%s' : near data in same_seg pragma, ignored"
4105	"'%Fs' : code modifiers only on function or pointer to function"
4106	"pragma requires integer between 1 and 127"
4107	"pragma requires integer between 15 and 255"
4108	"pragma requires integer between 79 and 132"
4109	"unexpected identifier '%s'"
4110	"unexpected token 'int constant'"
4111	"unexpected token 'string'"
4112	"macro name '%s' is reserved, '%s' ignored"
4113	"function parameter lists differed"
4114	"same type qualifier used more than once"
4115	"'%Fs' : type definition in formal parameter list"
4116	"(no tag) : type definition in formal parameter list"
4118	"pragma not supported"
4119	"different bases '%Fs' and '%Fs' specified"
4120	"_based/unbased mismatch"
4123	"different base expressions specified"
4124	"_fastcall with stack checking is inefficient"
4125	"decimal digit terminates octal escape sequence"
4126	"'%c' : unknown memory model flag"
4127	"conditional expression is constant"
4128	"storage-class specifier after type"
4129	"'%c' : unrecognized character escape sequence"
4130	"'%Fs' : logical operation on address of string constant"
4131	"'%Fs' : uses old-style declarator"
4132	"'%Fs' : const object should be initialized"
4135	"conversion between different integral types"
4136	"conversion between different floating types"
4137	"'%Fs' : no return value from floating-point function"
4138	"'*/' found outside of comment"
4139	"'0x%x' : hex escape sequence is out of range"
4140	"'%Fs' : redefined, preceding references may be invalid"  /* QC */
4185	"near call to '%Fs' in different segment" /* QC, c23 */
4206	"assignment within conditional expression" /* QC, c23 */
4401	"'%s' : member is bit field"
4402	"must use PTR operator"
4403	"illegal PTR operator"
4404	"period on directive ignored"
4405	"'%s' : identifier is reserved word"
4406	"operand on directive ignored"
4407	"operand size conflict"
4408	"'%s' : ambiguous label"	/* QC2 */
4409	"illegal instruction size"
4410	"illegal size for operand"
4411	"'%s' : symbol resolves to displacement register"
4412	"'%s' : identifier is also assembler mnemonic"
4413	"'%Fs' : redefined, preceding references may be invalid"  /* QC2 */
4414	"'%Fs' : short jump to function converted to near"
4000	"UNKNOWN WARNING\n\t\tContact Microsoft Product Support Services"
						/* errors */
	
2001	"newline in constant"
2003	"expected 'defined id'"
2004	"expected 'defined(id)'"
2005	"#line expected a line number, found '%s'"
2006	"#include expected a file name, found '%s'"
2007	"#define syntax"
2008	"'%c' : unexpected in macro definition"
2009	"reuse of macro formal '%Fs'"
2010	"'%c' : unexpected in macro formal-parameter list"
2012	"missing name following '<'"
2013	"missing '>'"
2014	"preprocessor command must start as first non-white-space"
2015	"too many characters in constant"
2016	"no closing single quotation mark"
2017	"illegal escape sequence"
2018	"unknown character '0x%x'"
2019	"expected preprocessor directive, found '%c'"
2021	"expected exponent value, not '%c'"
2022	"'%ld' : too big for character"
2023	"divide by 0"
2024	"mod by 0"
2025	"'%s' : enum/struct/union type redefinition"
2026	"'%s' : member of enum redefinition"
2027	"use of undefined enum/struct/union '%Fs'"
2028	"struct/union member needs to be inside a struct/union"
2030	"'%Fs' : struct/union member redefinition"
2031	"'%Fs' : function cannot be struct/union member"
2033	"'%Fs' : bit field cannot have indirection"
2034	"'%Fs' : type of bit field too small for number of bits"
2035	"struct/union '%Fs' : unknown size"
2036	"left of '%s%s' must have a struct/union base type"	/* QC2 */
2037	"left of '%s' specifies undefined struct/union '%Fs'"
2038	"'%s' : not struct/union member"
2039	"'->' : left operand must point to struct/union"	/* QC2 */
2040	"'.' : left operand must have struct/union type"	/* QC2 */
2041	"illegal digit '%c' for base %d"
2042	"signed/unsigned keywords mutually exclusive"
2043	"illegal break"
2044	"illegal continue"
2045	"'%s' : label redefined"
2046	"illegal case"
2047	"illegal default"
2048	"more than one default"
2049	"case value '%ld' already used"
2050	"nonintegral switch expression"
2051	"case expression not constant"
2052	"case expression not integral"
2053	"case value %d already used"	/* QC2 */
2054	"expected '(' to follow '%Fs'"
2055	"expected formal-parameter list, not a type list"
2056	"illegal expression"
2057	"expected constant expression"
2058	"constant expression is not integral"
2059	"syntax error : '%s'"
2060	"syntax error : end-of-file found"
2061	"syntax error : identifier '%s'"
2062	"type '%s' unexpected"
2063	"'%s' : not a function"
2064	"term does not evaluate to a function"
2065	"'%s' : undefined"
2066	"cast to function type is illegal"
2067	"cast to array type is illegal"
2068	"illegal cast"
2069	"cast of void term to nonvoid"
2070	"illegal sizeof operand"
2071	"'%Fs' : illegal storage class"
2072	"'%Fs' : initialization of a function"
2075	"'%Fs' : array initialization needs curly braces"
2076	"'%Fs' : struct/union initialization needs curly braces"
2077	"nonscalar field initializer '%Fs'"
2078	"too many initializers"
2079	"'%Fs' uses undefined struct/union '%Fs'"
2080	"illegal far _fastcall function"
2081	"'%Fs' : illegal memory attribute"	/* QC2 */
2082	"redefinition of formal parameter '%Fs'"
2084	"function '%Fs' already has a body"
2085	"'%Fs' : not in formal-parameter list"
2086	"'%Fs' : redefinition"
2087	"'%Fs' : missing subscript"
2090	"function returns array"
2091	"function returns function"
2092	"array element type cannot be function"
2093	"cannot use address of automatic variable as static initializer"
2094	"label '%Fs' was undefined"
2095	"'%Fs' : actual has type void : parameter %d"
2096	"struct/union comparison illegal"
2097	"illegal initialization"
2098	"nonaddress expression"
2099	"nonconstant initializer"
2100	"illegal indirection"
2101	"'&' on constant"
2102	"'&' requires lvalue"
2103	"'&' on register variable"
2104	"'&' on bit field ignored"
2105	"'%s' needs lvalue"
2106	"'%s' : left operand must be lvalue"
2107	"illegal index, indirection not allowed"
2108	"nonintegral index"
2109	"subscript on nonarray"
2110	"pointer + pointer"
2111	"pointer + nonintegral value"
2112	"illegal pointer subtraction"
2113	"pointer subtracted from nonpointer"
2114	"'%s' : pointer on left; needs integral right"
2115	"'%s' : incompatible types"
2116	"'%s' : illegal %s operand" /* QC2 */
2117	"'%s' : illegal for struct/union"
2118	"negative subscript"
2119	"typedef types both define indirection"
2120	"void illegal with all types"
2121	"'%s' : bad %Fs operand"
2124	"divide or mod by zero"
2125	"'%Fs' : allocation exceeds 64K"	  /* QC, c23 */
2127	"parameter allocation exceeds 32K"	/* QC, c23 */
2130	"#line expected a string containing the file name, found '%s'"
2131	"more than one memory attribute"
2132	"syntax error : unexpected identifier"
2133	"'%Fs' : unknown size"
2134	"'%Fs' : struct/union too large"
2136	"'%Fs' : prototype must have parameter types"
2137	"empty character constant"
2138	"unmatched close comment '*/'"	/* QC2 */
2139	"type following '%s' is illegal"
2140	"argument cannot be function type"
2141	"value out of range for enum constant"
2142	"ellipsis requires three periods"	/* QC2 */
2143	"syntax error : missing '%s' before '%s'"
2144	"syntax error : missing '%s' before type '%Fs'"
2145	"syntax error : missing '%s' before identifier"
2146	"syntax error : missing '%s' before identifier '%s'"
2147	"unknown size"
2148	"array too large"
2149	"'%Fs' : named bit field cannot have 0 width"
2150	"'%Fs' : bit field must have type int, signed int, or unsigned int"
2151	"more than one language attribute"
2152	"'%s' : pointers to functions with different attributes"
2153	"hex constants must have at least 1 hex digit"
2154	"'%Fs' : does not refer to a segment name"
2156	"pragma must be outside function"
2157	"'%s' : must be declared before use in pragma list"
2158	"'%s' : is a function"
2159	"more than one storage class specified"
2160	"## cannot occur at the beginning of a macro definition"
2161	"## cannot occur at the end of a macro definition"
2162	"expected macro formal parameter"
2163	"'%s' : not available as an intrinsic function"
2164	"'%s' : intrinsic function not declared"
2165	"'%s' : cannot modify pointers to data"
2166	"lvalue specifies const object"
2167	"'%Fs' : too many actual parameters for intrinsic"
2168	"'%Fs' : too few actual parameters for intrinsic"
2169	"'%Fs' : intrinsic function, cannot be defined"
2170	"'%s' : not declared as a function, cannot be intrinsic"
2171	"'%s' : illegal operand"
2172	"'%Fs' : actual is not a pointer : parameter %d"
2173	"'%Fs' : actual is not a pointer : parameter %d, parameter list %d"
2174	"'%Fs' : actual has type void : parameter %d, parameter list %d"
2175	"'%Fs' : unresolved external"	/* QC */
2176	"static huge data not supported by /qc"	/* QC */
2177	"constant too big"
2178	"'%s' : storage class for same_seg variables must be extern"
2179	"'%Fs' : was used in same_seg, but storage class is no longer extern"
2180	"controlling expression has type void"
2181	"pragma requires command line option '%s'"	/* QC2 */
2182	"'%Fs' : has type void"
2183	"pragma requires command line option '%Fs'"	/* QC */
2185	"'%Fs' : illegal _based allocation"
2187	"cast of near function pointer to far function pointer"
2188	"#error : %s"	/* QC2 */
2189	"#error : %Fs"
2193	"'%Fs' : already in a segment"
2194	"'%Fs' : is a text segment"
2195	"'%Fs' : is a data segment"
2196	"/ML cannot be used with floating point"	/* QC */
2198	"'%Fs' : tried to be allocated in code segment '%Fs'"	/* QC2 */
2199	"'%Fs' : tried to be allocated in data segment '%Fs'"	/* QC2 */
2200	"'%Fs' : function has already been defined"
2201	"'%Fs' : storage class must be extern"
2202	"'interrupt' function must be 'far'"	/* QC2 */
2203	"'%s' function must be 'cdecl'"	/* QC2 */
2204	"'saveregs/interrupt' modifiers mutually exclusive"	/* QC2 */
2205	"'%Fs' : cannot initialize extern block-scoped variables"
2206	"'%Fs' : typedef cannot be used for function definition"
2207	"'%Fs' in struct/union '%Fs' has a zero-sized array"
2208	"no members defined using this type"
2209	"type cast in _based construct must be (_segment)"
2210	"'%Fs' : must be near/far data pointer"
2211	"(_segment) applied to function identifier '%s'"
2212	"'%Fs' : _based not available for functions/pointers to functions"
2213	"'%s' : illegal argument to _based"
2214	"pointers based on void require the use of :>"
2215	":> operator only for objects based on void"
2216	"'%Fs' may not be used with '%Fs'"
2217	"'%Fs' must be used with '%Fs'"
2218	"type in _based construct must be void"
2219	"syntax error : type qualifier must be after '*'"
2220	"warning treated as error - no object file generated"
2221	"'.' : left operand points to struct/union, use '->'"
2222	"'->' : left operand has struct/union type, use '.'"
2223	"left of '->%Fs' must point to struct/union"
2224	"left of '.%Fs' must have struct/union type"
2225	"'%Fs' : first member of struct is unnamed"
2400	"in-line syntax error in '%s', found '%Fs'"
2401	"'%s' : register must be base in '%s'"
2402	"'%s' : register must be index in '%s'"
2403	"'%s' : register must be base/index in '%s'"
2404	"'%s' : illegal register in '%s'"
2405	"illegal short forward reference with offset"
2406	"'%s' : name undefined in '%s'"
2407	"illegal float register in '%s'"
2408	"illegal type on PTR operator in '%s'"
2409	"illegal type used as operator in '%s'"
2410	"'%s' : ambiguous member name in '%s'"
2411	"'%s' : illegal struct/union member in '%s'"
2412	"'%Fs' : case insensitive label redefined"
2413	"'%s' : illegal align size"
2414	"illegal number of operands"
2415	"improper operand type"
2416	"'%s' : illegal opcode for processor"
2417	"divide by zero in '%s'"
2418	"'%Fs' : not in a register"
2419	"mod by zero in '%s'"
2420	"'%s' : illegal symbol in %s"
2421	"PTR operator used with register in '%s'"
2422	"illegal segment override in '%s'"
2424	"'%Fs' : improper expression in '%s'"
2425	"'%Fs' : nonconstant expression in '%s'"
2426	"'%Fs' : illegal operator in '%s'"
2427	"'%Fs' : jump referencing label is out of range"			/* QC */
2428	"'%Fs' : segment redefinition"	/* QC2 */
2429	"'%Fs' : illegal far label reference"
2000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"

						/* fatals */

1001	"Internal Compiler Error\n\t\t(compiler file '%s', line %d)\n\t\tContact Microsoft Product Support Services"
1003	"error count exceeds %d; stopping compilation"
1004	"unexpected end-of-file found"
1005	"string too big for buffer"
1006	"write error on compiler-generated file"
1007	"unrecognized flag '%s' in '%s'"
1008	"no input file specified"
1009	"compiler limit : macros nested too deeply"
1010	"compiler limit : macro expansion too big"
1011	"compiler limit : '%s': macro definition too big"
1012	"unmatched parenthesis - missing '%c'"
1013	"cannot open source file '%s'"	/* QC2 */
1014	"too many include files"
1015	"cannot open include file '%s'"	/* QC2 */
1016	"#if[n]def expected an identifier"
1017	"invalid integer constant expression"
1018	"unexpected '#elif'"
1019	"unexpected '#else'"
1020	"unexpected '#endif'"
1021	"invalid preprocessor command '%s'"
1022	"expected '#endif'"
1023	"cannot open source file '%Fs'"
1024	"cannot open include file '%Fs'"
1025	"compiler terminated by user"	/* QC */
1026	"parser stack overflow, please simplify your program"
1027	"DGROUP data allocation exceeds 64K"	/* QC, c23 */
1028	"'%s' : segment allocation exceeds 64K" /* QC */
1031	"compiler limit : function calls nested too deeply"	/* QC, c23 */
1032	"cannot open object listing file '%s'"	/* QC, c23 */
1035	"expression too complex, please simplify"	/* QC, c23 */
1037	"cannot open object file '%s'"	/* QC, c23 */
1041	"cannot open compiler intermediate file - no more files"
1042	"cannot open compiler intermediate file - no such file or directory"
1043	"cannot open compiler intermediate file"
1044	"out of disk space for compiler intermediate file"
1045	"floating-point overflow"	/* QC2 */
1047	"limit of %s exceeded at '%s'"
1048	"unknown option '%c' in '%s'"
1049	"invalid numerical argument '%s'"
1052	"compiler limit : #if/#ifdef blocks nested too deeply"
1053	"compiler limit : struct/union nested too deeply"
1054	"compiler limit : initializers nested too deeply"
1055	"compiler limit : out of keys"
1056	"compiler limit : out of macro expansion space"
1057	"unexpected end-of-file in macro expansion (missing ')'?)"
1059	"compiler is out of near heap space"
1060	"compiler is out of far heap space"
1061	"compiler limit : blocks nested too deeply"	/* QC */
1062	"error writing to preprocessor output file"
1063	"compiler limit : compiler stack overflow"	/* QC */
1064	"compiler limit : token overflowed internal buffer"
1068	"cannot open file '%s'"
1069	"write error on file '%s'"	/* QC */
1070	"mismatched #if/#endif pair in file '%Fs'"
1071	"unexpected end-of-file found in comment"
1072	"'%Fs' : cannot read file"
1126	"'%Fs' : automatic allocation exceeds %s" /* QC, c23 */
1127	"'%Fs' : segment redefinition"
1000	"UNKNOWN FATAL ERROR\n\t\tContact Microsoft Product Support Services"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\bin\cl.err ===
/* error messages */

2001	"too many symbols predefined with /D"
2002	"conflict in memory-model specification"
2003	"missing source file name"
2008	"limit of %s exceeded at '%s'"
2011	"only one floating-point option allowed"
2012	"too many linker flags on command line"
2013	"incomplete model specification"
2016	"'%s' and '%s' are incompatible"
2018	"cannot open linker response file"
2019	"cannot overwrite the source/object file, '%s'"
2020	"%s option requires extended keywords to be enabled (/Ze)"
2021	"invalid numerical argument '%s'"
2022	"cannot open help file, '%s'"
2027	"could not execute '%s'"
2028	"too many open files, cannot redirect '%s'"
2030	"INTERNAL COMPILER ERROR in '%s'\n\t\tContact Microsoft Product Support Services"
2031	"too many flags/files on command line"
2000	"UNKNOWN COMMAND LINE ERROR\n\t\tContact Microsoft Product Support Services"

				/* warning messages */

4001	"listing overrides assembly output"
4002	"ignoring unknown flag '%s'"
4003	"different processors selected for code generation"
4005	"could not locate '%s';\nPlease enter new file name (full path) or Ctrl-C to quit: "
4007	"/C ignored (must also specify /P or /E or /EP)"
4009	"threshold only for far/huge data, ignored"
4011	"preprocessing overrides source listing"
4012	"function declarations override source listing"
4013	"combined listing overrides object listing"
4014	"invalid value '%d' for '%s'; default '%d' is used"
4018	".DEF files supported in protected mode only"
4019	"string too long; truncated to '%d' characters"
4000	"UNKNOWN COMMAND LINE WARNING\n\t\tContact Microsoft Product Support Services"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\bin\c23.err ===
/* fatals */

1001	"Internal Compiler Error\n\t\t(compiler file '%s', line %d)\n\t\tContact Microsoft Product Support Services"
1002	"compiler is out of heap space in Pass 2"
1003	"error count exceeds %d; stopping compilation"
1004	"unexpected end-of-file found"
1005	"string too big for buffer"
1006	"write error on compiler intermediate file"
1007	"unrecognized flag '%s' in '%s'"
1013	"cannot open source file '%s'"
1027	"DGROUP data allocation exceeds 64K"
1029	"there are > 512 bytes of arguments"
1030	"there are > 512 bytes of local variables"
1032	"cannot open object listing file '%s'"
1033	"cannot open assembly language output file '%s'"
1035	"expression too complex, please simplify"
1036	"cannot open source listing file '%s'"
1037	"cannot open object file '%s'"
1039	"unrecoverable heap overflow in Pass 3"
1040	"unexpected end-of-file in source file '%s'"
1041	"cannot open compiler intermediate file - no more files"
1042	"cannot open compiler intermediate file - no such file or directory"
1043	"cannot open compiler intermediate file"
1044	"out of disk space for compiler intermediate file"
1045	"floating-point overflow"
1046	"bad '%s' flag, would overwrite '%s' with '%s'"
1047	"too many '%s' flags, '%s'"
1048	"unknown option '%c' in '%s'"
1049	"invalid numerical argument '%s'"
1050	"'%s' : code segment too large"
1066	"intrinsic not implemented"
1090	"'%s' data allocation exceeds 64K"
1126	"'%s' : automatic allocation exceeds %s"
1127	"'%s': segment redefinition"
1000	"UNKNOWN FATAL ERROR\n\t\tContact Microsoft Product Support Services"
						/* errors */
	
2125	"'%s' : allocation exceeds 64K"
2127	"parameter allocation exceeds 32K"
2128	"'%s' : huge array cannot be aligned to segment boundary"
2129	"static function '%s' not found"
2418	"'%s' : not in a register"
2220	"warning treated as error - no object file generated"
2427	"'%s' : jump referencing label is out of range"
2000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"

						/* warnings */
	
4056	"overflow in constant arithmetic"
4057	"overflow in constant multiplication"
4058	"address of automatic (local) variable taken, DS != SS"
4059	"segment lost in conversion"
4061	"long/short mismatch in argument : conversion supplied"
4062	"near/far mismatch in argument : conversion supplied"
4063	"'%s' : function too large for post-optimizer"
4065	"recoverable heap overflow in post-optimizer - some optimizations may be missed"
4066	"local symbol table overflow - some local symbols may be missing in listings"
4069	"conversion of near pointer to long integer"
4073	"scoping too deep, deepest scoping merged when debugging"
4127	"conditional expression is constant"
4185	"near call to '%s' in different segment"
4186	"string too long - truncated to %d characters"
4200	"local variable '%s' used without having been initialized"
4201	"local variable '%s' may be used without having been initialized"
4202	"unreachable code"
4203	"'%s' : function too large for global optimizations"
4204	"'%s' : in-line assembler precludes global optimizations"
4205	"statement has no effect"
4206	"assignment within conditional expression"
4207	"'%s' : function too large for global optimizations (%s)"  /*
internal use */
4208    "Ran out of heap at: %s"  /* internal use */
4209	"comma operator within array index expression"
4300	"insufficient memory to process debugging information"
4301	"loss of debugging information caused by optimization"
4323	"potential divide by 0"
4324	"potential mod by 0"
4000	"UNKNOWN WARNING\n\t\tContact Microsoft Product Support Services"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\bin\ml.err ===
FATAL
cannot open file
I/O error closing file
I/O error writing file
I/O error reading file
out of far memory
assembler limit : macro parameter name table full
invalid command-line option
nesting level too deep
unmatched macro nesting
line too long
unmatched block nesting
directive must be in control block
error count exceeds 100; stopping assembly
invalid numerical command-line argument
too many arguments
statement too complex
out of virtual memory
out of near memory
missing source filename
invocation failed : retry command line with /VM option
SEVERE
memory operand not allowed in context
immediate operand not allowed
cannot have more than one ELSE clause per IF block
extra characters after statement
symbol type conflict
symbol redefinition
undefined symbol
non-benign record redefinition
syntax error
syntax error in expression
invalid type expression
distance invalid for word size of current segment
PROC, MACRO, or macro repeat directive must precede LOCAL
.MODEL must precede this directive
cannot define as public or external
segment attributes cannot change
expression expected
operator expected
invalid use of external symbol
operand must be RECORD type or field
identifier not a record
record constants may not span line breaks
instruction operands must be the same size
instruction operand must have size
invalid operand size for instruction
operands must be in same segment
constant expected
operand must be a memory expression
expression must be a code address
multiple base registers not allowed
multiple index registers not allowed
must be index or base register
invalid use of register
invalid INVOKE argument
must be in segment block
DUP too complex
too many initial values for structure
statement not allowed inside structure definition
missing operand for macro operator
line too long
segment register not allowed in context
string or text literal too long
statement too complex
identifier too long
invalid character in file
missing angle bracket or brace in literal
missing single or double quotation mark in string
empty (null) string
nondigit in number
syntax error in floating-point constant
real or BCD number not allowed
text item required
forced error
forced error : value equal to 0
forced error : value not equal to 0
forced error : symbol not defined
forced error : symbol defined
forced error : string blank
forced error : string not blank
forced error : strings equal
forced error : strings not equal
[ELSE]IF2/.ERR2 not allowed : single-pass assembler
expression too complex for .UNTILCXZ
can ALIGN only to power of 2
structure alignment must be 1, 2, or 4
expected
incompatable CPU mode and segment size
LOCK must be followed by a memory operation
instruction prefix not allowed
no operands allowed for this instruction
invalid instruction operands
initializer magnitude too large for specified size
cannot access symbol in given segment or group
operands have different frames
cannot access label through segment registers
jump destination too far
jump destination must specify a label
instruction does not allow NEAR indirect addressing
instruction does not allow FAR indirect addressing
instruction does not allow FAR direct addressing
jump distance not possible in current CPU mode
missing operand after unary operator
cannot mix 16- and 32-bit registers
invalid scale value
constant value too large
instruction or register not accepted in current CPU mode
reserved word expected
instruction form requires 80386/486
END directive required at end of file
too many bits in RECORD
positive value expected
index value past end of string
count must be positive or zero
count value too large
operand must be relocatable
constant or relocatable label expected
segment, group, or segment register expected
segment expected
invalid operand for OFFSET
invalid use of external absolute
segment or group not allowed
cannot add two relocatable labels
cannot add memory expression and code label
segment exceeds 64K limit
invalid type for a data declaration
HIGH and LOW require immediate operands
N/A
cannot have implicit far jump or call to near label
use of register assumed to ERROR
only white space or comment can follow backslash
COMMENT delimiter expected
conflicting parameter definition
PROC and prototype calling conventions conflict
invalid radix tag
INVOKE argument type mismatch : argument
invalid coprocessor register
instructions and initialized data not allowed in AT segments
/AT switch requires the TINY memory model
cannot have segment address references with TINY model
language type must be specified
PROLOGUE must be macro function
EPILOGUE must be macro procedure
alternate identifier not allowed with EXTERNDEF
text macro nesting level too deep
N/A
missing macro argument
EXITM used inconsistently
macro function argument list too long
N/A
VARARG parameter must be last parameter
VARARG parameter not allowed with LOCAL
VARARG parameter requires C calling convention
ORG needs a constant or local offset
register value overwritten by INVOKE
structure too large to pass with INVOKE : argument
N/A
too many arguments to INVOKE
too few arguments to INVOKE
invalid data initializer
N/A
RET operand too large
too many operands to instruction
cannot have more than one .ELSE clause per .IF block
expected data label
cannot nest procedures
EXPORT must be FAR
procedure declared with two visibility attributes
macro label not defined
invalid symbol type in expression
byte register cannot be first operand
word register cannot be first operand
special register cannot be first operand
coprocessor register cannot be first operand
cannot change size of expression computations
syntax error in control-flow directive
cannot use 16-bit register with a 32-bit address
constant value out of range
missing right parenthesis
type is wrong size for register
structure cannot be instanced
non-benign structure redefinition: label incorrect
non-benign structure redefinition: too few labels
OLDSTRUCTS/NOOLDSTRUCTS state cannot be changed
non-benign structure redefinition: incorrect initializers
non-benign structure redefinition: too few initializers
non-benign structure redefinition: label has incorrect offset
structure field expected
unexpected literal found in expression
N/A
divide by zero in expression
directive must appear inside a macro
cannot expand macro function
too few bits in RECORD
macro function cannot redefine itself
N/A
invalid qualified type
floating-point initializer on an integer variable
nested structure improperly initialized
invalid use of FLAT
structure improperly initialized
improper list initialization
initializer must be a string or single item
initializer must be a single item
initializer must be a single byte
improper use of list initializer
improper literal initialization
extra characters in literal initialization
must use floating-point initializer
cannot use .EXIT for OS_OS2 with .8086
invalid combination with segment alignment
INVOKE requires prototype for procedure
cannot include structure in self
symbol language attribute conflict
non-benign COMM redefinition
COMM variable exceeds 64K
parameter or local cannot have void type
cannot use TINY model with OS_OS2
expression size must be 32 bits
.EXIT does not work with 32-bit segments
.STARTUP does not work with 32-bit segments
ORG directive not allowed in unions
D/T
illegal use of segment register
cannot declare scoped code label as PUBLIC
.MSFLOAT directive is obsolete : .MSFLOAT ignored
ESC instruction is obsolete : ESC ignored
LEVEL 1
cannot modify READONLY segment
N/A
non-unique STRUCT/UNION field used without qualification
start address on END directive ignored with .STARTUP
cannot ASSUME CS
unknown default prologue argument
too many arguments in macro call
option untranslated, directive required
invalid command-line option value, default is used
virtual memory not available : /VM ignored
insufficent memory for /EP : /EP ignored
expected '>' on text literal
multiple .MODEL directives found : .MODEL ignored
line number information for segment without class 'CODE'
instructions and initialized data not supported in AT segments
LEVEL 2
@@: label defined but not referenced
expression expected, assume value 0
EXTERNDEF previously assumed to be external
length of symbol previously assumed to be different
symbol previously assumed to not be in a group
types are different
LEVEL 3
N/A
no return from procedure
N/A
conditional jump lengthened
procedure argument or local not referenced
IF condition may be pass-dependent
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\bin\rcpp.err ===
/* SCCSWHAT( "@(#)c1.err	2.29 88/02/25 18:18:00	" ) */
						/* fatals */

1001	"Internal Compiler Error\n\t\t(compiler file '%s', line %d)\n\t\tContact Microsoft Technical Support"
1002	"out of heap space"
1003	"error count exceeds %d; stopping compilation"
1004	"unexpected EOF"
1005	"string too big for buffer"
1006	"write error on compiler intermediate file"
1007	"unrecognized flag '%s' in '%s'"
1008	"no input file specified"
1009	"compiler limit : macros too deeply nested"
1010	"compiler limit : macro expansion too big"
1012	"bad parenthesis nesting - missing '%c'"
1013	"cannot open source file '%s'"
1014	"too many include files"
1015	"cannot open include file '%s'"
1016	"#if[n]def expected an identifier"
1017	"invalid integer constant expression"
1018	"unexpected '#elif'"
1019	"unexpected '#else'"
1020	"unexpected '#endif'"
1021	"bad preprocessor command '%s'"
1022	"expected '#endif'"
1023	"no int size specified"
1024	"no ptr size specified"
1025	"no function size specified"
1026	"parser stack overflow, please simplify your program"
1027	"DGROUP data allocation exceeds 64K"	/* QC, c23 */
1028	"%s segment allocation exceeds 64K"	/* QC */
1031	"compiler limit : function calls too deeply nested"	/* QC, c23 */
1032	"cannot open object listing file '%s'"			/* QC, c23 */
1035	"expression too complex, please simplify"		/* QC, c23 */
1037	"cannot open object file '%s'"					/* QC, c23 */
1041	"cannot open compiler intermediate file - no more files"
1042	"cannot open compiler intermediate file - no such file or directory"
1043	"cannot open compiler intermediate file"
1044	"out of disk space for compiler intermediate file"
1045	"floating point overflow"
1047	"too many %s flags, '%s'"
1048	"unknown option '%c' in '%s'"
1049	"invalid numerical argument '%s'"
1052	"too many #if/#ifdef's"
1053	"compiler limit : struct/union nesting"
1054	"compiler limit : initializers too deeply nested"
1055	"compiler limit : out of keys"
1056	"compiler limit : out of macro expansion space"
1057	"unexpected EOF in macro expansion (missing ')'?)"
1059	"out of near heap space"
1060	"out of far heap space"
1061	"compiler limit : blocks too deeply nested"	/* QC */
1062	"error writing to preprocessor output file"
1063	"compiler limit : compiler stack overflow"	/* QC */
1064	"compiler limit : identifier overflowed internal buffer"
1065	"compiler limit : declarator too complex"
1000	"UNKNOWN FATAL ERROR\n\t\tContact Microsoft Technical Support"

						/* errors */
	
2001	"newline in constant"
2002	"out of macro actual parameter space"
2003	"expected 'defined id'"
2004	"expected 'defined(id)'"
2005	"#line expected a line number, found '%s'"
2006	"#include expected a file name, found '%s'"
2007	"#define syntax"
2008	"'%c' : unexpected in macro definition"
2009	"reuse of macro formal '%s'"
2010	"'%c' : unexpected in formal list"
2011	"'%s' : definition too big"
2012	"missing name following '<'"
2013	"missing '>'"
2014	"preprocessor command must start as first non-whitespace"
2015	"too many chars in constant"
2016	"no closing single quote"
2017	"illegal escape sequence"
2018	"unknown character '0x%x'"
2019	"expected preprocessor command, found '%c'"
2020	"bad octal number '%c'"
2021	"expected exponent value, not '%c'"
2022	"'%ld' : too big for char"
2023	"divide by 0"
2024	"mod by 0"
2025	"'%s' : enum/struct/union type redefinition"
2026	"'%s' : member of enum redefinition"
2028	"struct/union member needs to be inside a struct/union"
2029	"'%Fs' : bit-fields only allowed in structs"
2030	"'%Fs' : struct/union member redefinition"
2031	"'%Fs' : function cannot be struct/union member"
2032	"'%Fs' : base type with near/far/huge not allowed"
2033	"'%Fs' : bit-field cannot have indirection"
2034	"'%Fs' : bit-field type too small for number of bits"
2035	"enum/struct/union '%Fs' : unknown size"
2036	"left of '%s%s' must have a struct/union type"
2037	"left of '%s' specifies undefined struct/union '%Fs'"
2038	"'%s' : not struct/union member"
2039	"'->' requires struct/union pointer"
2040	"'.' requires struct/union name"
2042	"signed/unsigned keywords mutually exclusive"
2043	"illegal break"
2044	"illegal continue"
2045	"'%s' : label redefined"
2046	"illegal case"
2047	"illegal default"
2048	"more than one default"
2050	"non-integral switch expression"
2051	"case expression not constant"
2052	"case expression not integral"
2053	"case value %d already used"
2054	"expected '(' to follow '%Fs'"
2055	"expected formal parameter list, not a type list"
2056	"illegal expression"
2057	"expected constant expression"
2058	"constant expression is not integral"
2059	"syntax error : '%s'"
2060	"syntax error : EOF"
2061	"syntax error : identifier '%s'"
2062	"type '%s' unexpected"
2063	"'%s' : not a function"
2064	"term does not evaluate to a function"
2065	"'%s' : undefined"
2066	"cast to function returning . . . is illegal"
2067	"cast to array type is illegal"
2068	"illegal cast"
2069	"cast of 'void' term to non-void"
2070	"illegal sizeof operand"
2071	"'%Fs' : bad storage class"
2072	"'%Fs' : initialization of a function"
2073	"'%Fs' : cannot initialize array in function"
2074	"'%Fs' : cannot initialize struct/union in function"
2075	"'%Fs' : array initialization needs curly braces"
2076	"'%Fs' : struct/union initialization needs curly braces"
2077	"non-integral field initializer '%Fs'"
2078	"too many initializers"
2079	"'%Fs' uses undefined struct/union '%Fs'"
2082	"redefinition of formal parameter '%Fs'"
2083	"array '%Fs' already has a size"
2084	"function '%Fs' already has a body"
2085	"'%Fs' : not in formal parameter list"
2086	"'%Fs' : redefinition"
2087	"'%Fs' : missing subscript"
2088	"use of undefined enum/struct/union '%s'"
2089	"typedef specifies a near/far function"
2090	"function returns array"
2091	"function returns function"
2092	"array element type cannot be function"
2093	"cannot initialize a static or struct with address of automatic vars"
2094	"label '%Fs' was undefined"
2095	"'%Fs' : actual has type void : parameter %d"
2096	"struct/union comparison illegal"
2097	"illegal initialization"
2098	"non-address expression"
2099	"non-constant offset"
2100	"illegal indirection"
2101	"'&' on constant"
2102	"'&' requires lvalue"
2103	"'&' on register variable"
2104	"'&' on bit-field ignored"
2105	"'%s' needs lvalue"
2106	"'%s' : left operand must be lvalue"
2107	"illegal index, indirection not allowed"
2108	"non-integral index"
2109	"subscript on non-array"
2110	"'+' : 2 pointers"
2111	"pointer + non-integral value"
2112	"illegal pointer subtraction"
2113	"'-' : right operand pointer"
2114	"'%s' : pointer on left; needs integral right"
2115	"'%s' : incompatible types"
2116	"'%s' : bad %s operand"
2117	"'%s' : illegal for struct/union"
2118	"negative subscript"
2119	"'typedefs' both define indirection"
2120	"'void' illegal with all types"
2121	"typedef specifies different enum"
2122	"typedef specifies different struct"
2123	"typedef specifies different union"
2125	"%Fs : allocation exceeds 64K"		/* QC, c23 */
2126	"%Fs : auto allocation exceeds %s"	/* QC, c23 */
2127	"parameter allocation exceeds 32K"	/* QC, c23 */
2130	"#line expected a string containing the file name, found '%s'"
2131	"attributes specify more than one near/far/huge"
2132	"syntax error : unexpected identifier"
2133	"array '%Fs' : unknown size"
2134	"'%Fs' : struct/union too large"
2135	"missing ')' in macro expansion"
2137	"empty character constant"
2138	"unmatched close comment '*/'"
2139	"type following '%s' is illegal"
2140	"argument type cannot be function returning . . ."
2141	"value out of range for enum constant"
2142	"ellipsis requires three periods"
2143	"syntax error : missing '%s' before '%s'"
2144	"syntax error : missing '%s' before type '%Fs'"
2145	"syntax error : missing '%s' before identifier"
2146	"syntax error : missing '%s' before identifier '%s'"
2147	"unknown size"
2148	"array too large"
2149	"'%Fs' : named bit-field cannot have 0 width"
2150	"'%Fs' : bit-field must have type int, signed int, or unsigned int"
2151	"more than one cdecl/fortran/pascal attribute specified"
2152	"'%s' : pointers to functions with different attributes"
2153	"hex constants must have at least 1 hex digit"
2154	"'%s' : does not refer to a segment"
2155	"'%s' : already in a segment"
2156	"pragma must be at outer level"
2157	"'%s' : must be declared before use in pragma list"
2158	"'%s' : is a function"
2159	"more than one storage class specified"
2160	"## cannot occur at the beginning of a macro definition"
2161	"## cannot occur at the end of a macro definition"
2162	"expected macro formal parameter"
2163	"'%s' : not available as an intrinsic"
2164	"'%s' : intrinsic was not declared"
2165	"'%s' : cannot modify pointers to data"
2166	"lval specifies 'const' object"
2167	"'%Fs' : too many actual parameters for intrinsic"
2168	"'%Fs' : too few actual parameters for intrinsic"
2169	"'%Fs' : is an intrinsic, it cannot be defined"
2170	"'%s' : intrinsic not declared as a function"
2171	"'%s' : bad operand"
2172	"'%Fs' : actual is not a pointer : parameter %d"
2173	"'%Fs' : actual is not a pointer : parameter %d, parameter list %d"
2174	"'%Fs' : actual has type void : parameter %d, parameter list %d"
2175	"'%Fs' : unresolved external"	/* QC */
2176	"static far data not supported"	/* QC */
2177	"constant too big"
2178	"'%s' : storage class for same_seg variables must be 'extern'"
2179	"'%Fs' : was used in same_seg, but storage class is no longer 'extern'"
2180	"controlling expression has type 'void'"
2181	"pragma requires command line option '%s'"	/* QC */
2182	"'%Fs' : 'void' on variable"
2183	"'%Fs' : 'interrupt' function must be 'far'"
2184	"'%Fs' : '%s' function cannot be 'pascal/fortran'"
2186	"'%Fs' : 'saveregs/interrupt' modifiers mutually exclusive"
2187	"cast of near function pointer to far function pointer"
2188	"#error : %s"
2190	"'%s' : is a text segment"
2191	"'%s' : is a data segment"
2192	"'%s' : function has already been defined"
2000	"UNKNOWN ERROR\n\t\tContact Microsoft Technical Support"

						/* warnings */
	
4001	"macro '%s' requires parameters"
4002	"too many actual parameters for macro '%s'"
4003	"not enough actual parameters for macro '%s'"
4004	"missing close parenthesis after 'defined'"
4005	"'%s' : redefinition"
4006	"#undef expected an identifier"
4009	"string too big, trailing chars truncated"
4011	"identifier truncated to '%s'"
4012	"float constant in a cross compilation"
4013	"constant too big"
4014	"'%Fs' : bit-field type must be unsigned"
4015	"'%Fs' : bit-field type must be integral"
4016	"'%s' : no function return type, using 'int' as default"
4017	"cast of int expression to far pointer"
4020	"'%Fs' : too many actual parameters"
4021	"'%Fs' : too few actual parameters"
4022	"'%Fs' : pointer mismatch : parameter %d"
4024	"'%Fs' : different types : parameter %d"
4025	"function declaration specified variable argument list"
4026	"function was declared with formal argument list"
4027	"function was declared without formal argument list"
4028	"parameter %d declaration different"
4029	"declared parameter list different from definition"
4030	"first parameter list is longer than the second"
4031	"second parameter list is longer than the first"
4032	"unnamed struct/union as parameter"
4033	"function must return a value"
4034	"sizeof returns 0"
4035	"'%Fs' : no return value"
4036	"unexpected formal parameter list"
4037	"'%Fs' : formal parameters ignored"
4038	"'%Fs' : formal parameter has bad storage class"
4039	"'%Fs' : function used as an argument"
4040	"near/far/huge on '%Fs' ignored"
4041	"formal parameter '%s' is redefined"
4042	"'%Fs' : has bad storage class"
4044	"huge on '%Fs' ignored, must be an array"
4045	"'%s' : array bounds overflow"
4046	"'&' on function/array, ignored"
4047	"'%s' : different levels of indirection"
4048	"array's declared subscripts different"
4049	"'%s' : indirection to different types"
4051	"data conversion"
4052	"different enum types"
4053	"at least one void operand"
4060	"conversion of long address to short address"	/* QC, c23 */
4061	"long/short mismatch in argument : conversion supplied"	/* QC, c23 */
4062	"near/far mismatch in argument : conversion supplied"	/* QC, c23 */
4067	"unexpected characters following '%s' directive - newline expected"
4068	"unknown pragma"
4071	"'%Fs' : no function prototype given"
4074	"non standard extension used - '%s'"
4075	"size of switch expression or case constant too large - converted to int"
4076	"'%s' : may be used on integral types only"
4077	"unknown check_stack option"
4079	"unexpected token '%s'"
4080	"expected 'identifier' for segment name, found '%s'"
4081	"expected a comma, found '%s'"
4082	"expected an identifier, found '%s'"
4083	"expected '(', found '%s'"
4084	"expected a pragma keyword, found '%s'"
4085	"expected [on | off]"
4086	"expected [1 | 2 | 4]"
4087	"'%Fs' : declared with 'void' parameter list"
4088	"'%Fs' : pointer mismatch : parameter %d, parameter list %d"
4089	"'%Fs' : different types : parameter %d, parameter list %d"
4090	"different 'const' attributes"
4091	"no symbols were declared"
4092	"untagged enum/struct/union declared no symbols"
4093	"unescaped newline in character constant in non-active code"
4094	"unexpected newline"
4095	"expected ')', found '%s'"
4096	"huge treated as far"		/* QC */
4098	"void function returning a value"
4099	"expected ')', (too many arguments?)"
4100	"'%Fs' : unreferenced formal parameter"
4101	"'%Fs' : unreferenced local variable"
4102	"'%Fs' : unreferenced label"
4103	"'%Fs' : function definition used as prototype"
4104	"'%s' : near data in same_seg pragma, ignored"
4105	"'%Fs' : code modifiers only on function or pointer to function"
4106	"pragma requires integer between 1 and 127"
4107	"pragma requires integer between 15 and 255"
4108	"pragma requires integer between 79 and 132"
4109	"unexpected identifier '%s'"
4110	"unexpected token 'int constant'"
4111	"unexpected token 'string'"
4112	"macro name '%s' is reserved, %s ignored"
4113	"function parameter lists differed"
4000	"UNKNOWN WARNING\n\t\tContact Microsoft Technical Support"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\smartmon\smartmon.rtf ===
{\rtf1\ansi \deff0{\fonttbl{\f0\froman Tms Rmn;}{\f1\froman Symbol;}{\f2\fswiss Helv;}{\f3\froman Times New Roman;}{\f4\fswiss Arial;}{\f5\fmodern Courier New;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255; \red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;}{\stylesheet{\s244 \fs16\up6 \sbasedon0\snext0 footnote reference;}{\s245 \fs20 \sbasedon0\snext245 footnote text;}{\s254\sb240 \b\f2\ul  \sbasedon0\snext0 heading 1;}{\fs20 \snext0 Normal;}}{\info{\author David Edelman}{\operator David Edelman}{\creatim\yr1992\mo9\dy3\hr16\min36}{\revtim\yr1992\mo9\dy3\hr16\min36}{\version2}{\edmins2}{\nofpages1}{\nofwords65536}{\nofchars65536}{\vern8368}} \widowctrl\ftnbj \sectd \linex0\endnhere \pard\plain \s254\sb240 \b\f2\ul {\plain \b\f4\fs16\up6 ${\footnote \pard\plain \s245 \fs20 {\fs16\up6 $} Contents for SmartMon Help} #{\footnote \pard\plain \s245 \fs20 {\fs16\up6 #} contents}}{\plain \b\f4   Contents for SmartMon Help \par }\pard\plain \fs20 {\f4  \par SmartMon is a companion application to the SmartDrive 4.0 disk cache utility.  It  provides vi sual indications of cache activities, and allows you to alter the cache mode of each cacheable drive.  Through SmartMon you can manipulate the run-time parameters of SmartDrive and monitor the effect on cache efficiency. \par  \par SmartMon's functionalities are organized visually into four main groups.  Please click the appropriate topic for additional information: \par  \par }{\f4\uldb Cache Memory Controls}{\v\f4\uldb cmc}{\f4\uldb  \par Drive Caching  Controls}{\v\f4\uldb dcc}{\f4\uldb  \par Cache Hit Rate Display}{\v\f4\uldb chrd}{\f4\uldb  \par Options and Cache Activity Logging}{\v\f4\uldb ocal}{\f4\uldb  \par Iconic Display}{\v\f4\uldb icond}{\f4\uldb  \par }{\f4  \par }{\f4\uldb \page }{\b\f4\fs16\up6 ${\footnote \pard\plain \s245 \fs20 {\fs16\up6 $} Cache Memory Controls}}{\b\f4\uldb  }{\b\f4\fs16\up6 #{\footnote \pard\plain \s245 \fs20 {\fs16\up6 #} cmc}}{\b\f4\uldb  }{\b\f4 Cache Memory Controls \par }{\f4  \par The Cache Memory control group shows the cache size under DOS and under Windows.  The sizes are determined from the }{\f4\ul SmartDrive command line}{\v\f4 lu_command_line}{\f4  parameters when it is loaded, and cannot be altered from this application. \par  \par The COMMIT button forces SmartDrive to write back all cache elements that have not been committed to disk.  It is not necessary to commit the cache to disk manually, as SmartDrive itself will never let any writable cache element age for more than five  seconds. \par  \par The RESET button tells SmartDrive to commit the cache to disk and then discard all cache elements.  This also resets the cumulative average cache hit rate, which is shown on the information bar. \par  \par \page }{\b\f4\fs16\up6 ${\footnote \pard\plain \s245 \fs20 {\fs16\up6 $} Drive Caching Controls}}{\b\f4  }{\b\f4\fs16\up6 #{\footnote \pard\plain \s245 \fs20 {\fs16\up6 #} dcc}}{\b\f4  Drive Caching Controls \par }{\f4  \par Through the Drive Control section, you can select any drive available on your system and see its current cache mode.  There are three possible settings:  Cache Read Only, Cache Read and Write, and No Caching; and you can change the setting for the selecte d drive by click ing the appropriate radio button.  However, you will see that for some of the drives the radio buttons are all disabled (e.g., CD-ROM drives, RAM drives, and Network shares)  That is because SmartDrive does not cache them , and you will not be able to alt er their "No Caching" status. \par  \par When you exit Windows the current cache setting for each drive will remain in effect until the next time }{\f4\ul SmartDrive is loaded}{\v\f4\ul lu_load}{\f4 , at which time all drives will be reset to the }{\f4\ul default cache mode}{\v\f4\ul lu_default} {\f4  according to it s drive type.  SmartMon offers you an option to preserve the drive settings by re-writing the SmartDrive line in the batch file where SmartDrive is loaded.  For most people it is their AUTOEXEC.BAT file.  Please see the Options section for more detail. \par  \par \page }{\b\f4\fs16\up6 ${\footnote \pard\plain \s245 \fs20 {\fs16\up6 $} Cache Hit Rate Display}}{\b\f4  }{\b\f4\fs16\up6 #{\footnote \pard\plain \s245 \fs20 {\fs16\up6 #} chrd}}{\b\f4  Cache Hit Rate Display \par }{\f4  \par The Cache Hit Rate chart  shows a histogram of the instantaneous cache hit rate for a given number of time intervals, and at a given frequency.  The number of intervals defaults to 30, the frequency to 500 msec, and can be ch anged through the Options dialog box.  The instantaneous cache hit rate is calculated by the following formula: \par  \par \tab Hit_Rate = 100 * (Current_hits - Previous_hits) / (Current_total - Previous_total) \par  \par When the cache is idle (i.e., Current_total equals Previous_total), the histogram does not get updated. \par  \par SmartMon also displays the Average Cache Hit Rate in the information bar at the bottom of the window.  That number shows the cumulative hit rate since the time SmartMon was started, or the last cache reset. \par  \par }{\f4\uldb Iconic Display}{\v\f4\uldb icond}{\f4\uldb  \par }{\fs16\up6 \page  \par ${\footnote \pard\plain \s245 \fs20 {\fs16\up6 $} Iconic Display}}{\f4  }{\fs16\up6 #{\footnote \pard\plain \s245 \fs20 {\fs16\up6 #} icond}}{\f4  }{\b\f4 Iconic Display \par }{\f4  \par When SmartMon is minimized, the cache hit rate is displayed in numeric format.  If the cache was active, the icon displays the instantaneous hit rate for the sampling period.  On a color display, this number is shown in red; on a monochrome display, it is  shown in white.  If the cache was idle, the average hit rate is displayed in the current button text color. \par  \par The little disk drive bitmap in the lower part of the icon simulates a red light blinking when the cache is not idle.  The bitmap is updated at the same time as the hit rate, it does not reflect in real-time the activity of the cache or your hard disks. \par \page }{\b\f4\fs16\up6 ${\footnote \pard\plain \s245 \fs20 {\fs16\up6 $} Options and Cache Activity Logging}}{\b\f4  }{\b\f4\fs16\up6 #{\footnote \pard\plain \s245 \fs20 {\fs16\up6 #} ocal}}{\b\f4  Options and Cache Activity Logging \par }{\f4  \par Through the Options dialog box you can configure various SmartMon parameters, which are saved in WIN.INI under the [smartmon] section. \par  \par }{\b\f4 Cache Hit  Rate \par }{\f4  \par For Cache Hit Rate display, you can select the sampling frequency (from  50 to 10000 milliseconds, with 500 as default), and the number of  histogram  display intervals (from 3 to 100, with 30 as default).  In addition to controlling how often SmartMon samples the cache hit rate, the sampling frequency also determines the rate at which the histogram and the iconic display gets updated, as well as when  to write to the log file (when logging is enabled.) \par  \par }{\b\f4 Log File \par  \par }{\f4 For logging cache activities to file, you can select the file name, and the automatic stop time.  If the given log file exists, SmartMon will append to it.  Otherwise, the file will be creat ed.  You should specify the full pathname of the log file; otherwise, SmartMon will create the file in the current directory of the current drive. \par  \par The log file contains three columns of information.  The first is the timer tick count since the beginning of the current Windows session.  The second is the total number of cache accesses since the time SmartDrive was loaded.  The third is the number of  cache hits since the time SmartDrive was loaded. \par  \par The Automatic Stop time tells SmartMon to stop logging  to file after the specified number of minutes.  The minimum is one minute, the maximum is eight hours, the default is two hours.  You can also turn off this feature by unchecking the check box.  Note that changing the Automatic Stop time setting will affe ct  the current logging session, if one is underway. \par  \par }{\b\f4 Drive Control \par }{\f4  \par Assuming that you loaded SmartDrive from a batch file (typically it is loaded from the AUTOEXEC.BAT), on exit, SmartMon can rewrite the }{\f4\ul SmartDrive command line}{\v\f4\ul lu_command_line}{\f4  in the ba tch file to preserve the the drive cache settings.  If you choose not to use this feature (by unchecking the check box), any new drive setting would still remain in effect even after Windows exits.  But it will be lost the next time SmartDrive is loaded.  \par  \par The batch file you specify must be an existing file.  The default is the AUTOEXEC.BAT file on the boot drive.  SmartMon will not update the file if there is more than one SmartDrive line in it. \par }{\f4\fs16\up6 \page #{\footnote \pard\plain \s245 \fs20 {\fs16\up6 #} lu_command_line}}{\f4  smartdrv [[/E:elementsize] [/B:buffersize] [drive [+]|[-]] [size] [winsize]]... \par  \par /E:element size\tab Specifies the size of the cache elements (in bytes). \par /B:buffer size\tab Specifies the size of the read buffer. \par drive letter\tab Specifies the letter of the disk drive to cache. \par +\tab \tab Enables write-behind caching for the specified drive. \par -\tab \tab Disables all caching for the specified drive. \par size\tab \tab Specifies the amount of XMS memory (KB) used by the cache. \par winsize\tab \tab Specifies the amount of XMS memory (KB) used in Windows. \par \page }{\f4\fs16\up6 #{\footnote \pard\plain \s245 \fs20 {\fs16\up6 #} lu_load}}{\f4  Once started, SmartDrive cannot be reloaded until you reboot the machine. \par \page }{\f4\fs16\up6 #{\footnote \pard\plain \s245 \fs20 {\fs16\up6 #} lu_default}}{\f4  The default cache setting for a floppy drive is Cache Read Only.  For a fixed drive it is Cache Read and Write. \par }}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\bin\readme.doc ===
README.DOC File

             Release Notes for the Microsoft(R) C Professional
                      Development System, Version 6.0

                  (C) Copyright Microsoft Corporation, 1990
                                          
     This document contains release notes for version 6.0 of the
     Microsoft C Professional Development System and libraries for
     MS-DOS(R) and the Microsoft Operating System/2 (MS(R) OS/2). The
     information in this document and in the Microsoft Advisor (on-line
     help) is more up to date than that in the manuals.
  
     Microsoft improves its languages documentation at the time of
     reprinting, so some of the information in this file may already be
     included in your manuals.



================================< Contents >================================

  
     This file has ll parts:
  
               Part     Note
               ----     ----
               1        SETUP Program Notes

               2        Differences between C 5.1 and 6.0

               3        Compiler and C Language Notes

               4        Programmer's WorkBench (PWB) Notes

               5        CodeView and Utilities Notes

               6        Getting Help on Start-Up Error Messages

               7        Notes on "Installing and Using"

               8        Notes on "C Reference"

               9        Notes on "Advanced Programming Techniques"

               10       Notes on Patching the MOUCALLS.DLL Dynamic-
                        Link Library (OS/2 1.1 Only)

               11       HIMEM, RAMDRIVE, and SMARTDRV



=======================< Part 1: SETUP Program Notes >=======================


     Installation Program Notes
     --------------------------

        - If you are already running QuickHelp as a keyboard monitor
          under OS/2, disable it before running SETUP so it can copy
          new versions of QuickHelp and MSHELP.DLL to your hard disk.



===============< Part 2: Differences between C 5.1 and 6.0 >=================


     For a complete discussion of the differences between Microsoft C
     versions 5.1 and 6.0, see Appendix B of "Advanced Programming
     Techniques."


     Functions Declared as Float
     ---------------------------

     In Microsoft C 5.1, functions declared as float always return a
     result of type double. In C 6.0, functions declared as float
     return a value of type float for ANSI compliance. This difference
     will cause compatibility problems when linking C 6.0 objects with
     C 5.1 objects and libraries that contain functions that return
     values of type float.

     To remedy the problem, prototype each function in your C 5.1
     libraries that returns type float as type double in your C 6.0
     source code. Then compile with C 6.0. For example:

          double func_in_51_lib( float );


     The sizeof Function Return Value
     --------------------------------

     To comply with ANSI specifications, the sizeof function now
     returns an unsigned int rather than an int. This may cause
     problems in statements of the following form:

          -sizeof( expression )

     For example, the following line of code, used to position
     a file pointer one record from the end, no longer works:

          fseek( file, (long)(-sizeof( record )), SEEK_END );

     Because sizeof returns an unsigned int, the record size is
     zero-extended to a long value rather than sign-extended to the
     appropriate signed value.

     To avoid this problem, you can cast the record size to a
     long before you negate it, as follows:

          fseek( file, -((long)sizeof( record )), SEEK_END );


     Arithmetic Operations on Signed Short Values
     --------------------------------------------

     In C 5.1 and Microsoft QuickC(R) 2.0, arithmetic on constants of
     type signed short is done using a signed long value. C 6.0
     conforms to the ANSI specification by performing arithmetic
     operations on signed shorts and yielding a signed short value.

     This causes overflow in some instances of constant arithmetic,
     most noticeably, multiplication. For example, when interpreted
     as a signed short, 48*1000 results in a value of -15232 rather
     than 48000.


     Hexadecimal Constants in Strings
     --------------------------------

     Hexadecimal escape sequences in strings now conform to the ANSI
     specification by treating every potential hexadecimal digit
     following the \x as part of the constant. In C 5.1 and QuickC 2.0,
     hexadecimal escape sequences are limited to three characters.

     Typically, you will notice this when using hexadecimal escape
     sequences for length-preceded strings. Consider the following
     example:

          char TypeArray[] =
              "\x005float\x006double";

     In C 5.1 and QuickC 2.0, TypeArray contains the following bytes:

          <5>float<6>double<0>

     In C 6.0, TypeArray has the following bytes:

          _loatmouble<0>

     This is because in C 6.0, \x005f and \x006d are legal hexadecimal
     sequences that represent the underscore and 'm' characters,
     respectively.

     There are two ways to avoid this problem. The simplest is to
     use string concatenation, as follows:

          char TypeArray[] =
              "\x005"  "float"  "\x006"  "double";

     According to the ANSI standard, adjacent string literals are
     concatenated after escape sequences have been calculated.

     A second solution is to use octal, which can never be more than
     three digits. The use of octal requires a small calculation and
     also requires that you pad out the digits with zeros on the left
     if necessary. However, even older, non-ANSI compilers will support
     this solution if portability is a concern.


     The offsetof Macro
     ------------------

     The offsetof macro (defined in STDDEF.H) takes a struct type
     name and member name, and returns a type size_t value giving the
     offset in bytes of the member from the beginning of the struct.

     The expression

          offsetof( type, member_name )

     yields the byte offset of the member from the beginning of the
     struct.

     Loop Optimization (/Ol)
     -----------------------

     The loop optimization option (/Ol) in C 6.0 has a different effect
     than in C 5.1. To get the equivalent of the C 5.1 /Ol option
     in C 6.0, use /Ole (loop code optimization and global register
     optimization). See Chapter 1 of "Advanced Programming Techniques"
     and on-line help for further details.



=================< Part 3: Compiler and C Language Notes >===================

     Compiler notes:

        - The CL and LINK environment variables work just as in
          previous versions of Microsoft C. The contents of the
          environment variable are interpreted as a series of command-
          line options for the associated utility. Note, however, that
          the use of these environment variables can cause
          unpredictable build behavior under the Programmer's WorkBench
          (PWB).

        - The CL command line can be used to specify the name of
          an OS/2 or Microsoft Windows(TM) module-definition file to be
          used by the linker. For example,

               CL CLOCK.C CLOCK.DEF

          tells CL to pass the name of the module-definition file
          'CLOCK.DEF' to the linker after compiling.

        - The /Gm compiler option, as described in the "C Reference"
          and in on-line help, is no longer supported by C 6.0.
          The /Gm option placed near const items in the CONST segment.

        - When using the /qc and /Zr options together, specify them
          in the following order on the command line:

               /qc /Zr

        - Using the setjmp and longjmp functions with global
          optimization options /Ox, /Oe, /Ol, or /Og can cause
          incorrect code to be generated. To ensure that the compiler
          generates correct code, either compile without these
          options, or use the optimize pragma to turn off /Oe, /Ol,
          and /Og in functions containing setjmp and longjmp, as
          follows:

               #pragma optimize( "elg",off )

                    . . . {function containing setjmp or longjmp}

               #pragma optimize( "",on )


     Features added since the documentation was printed:

        - /BATCH Option. To disable prompting for library names or
          other information and permit the use of CL in a batch or
          command file, specify the /BATCH option.

        - To get the fastest possible code, use the following
          optimization settings:

               /Oxaz /Grs

          The /Oz option causes the compiler to perform the most
          aggressive type of loop optimization.

          To get the smallest possible code, use the following
          settings:

               /Osleazr

          For small code with a greater margin of safety, use

               /Osler

        - The /Gh option allows building with Microsoft Windows 2.x
          libraries. This option is not needed for versions of Windows
          greater than 2.x. In addition, this feature exists only in C
          6.0, and will be phased out in future versions of the
          compiler.


     C Language notes:

        - The return values for _setfont as described in on-line help
          are incorrect. The _setfont function returns the font index
          number if successful, or a negative number if unsuccessful.

        - The return values for the fstat function are described
          incompletely in on-line help. Under DOS or versions of
          OS/2 prior to 1.2, fstat returns the same value (the
          modification time) in the st_mtime, st_atime, and st_ctime
          fields, because that is the only value maintained by the
          system.

          However, under OS/2 1.2's High Performance File System,
          fstat returns the expected values in st_mtime (time the
          file was last written), st_atime (time the file was last
          accessed for reading or writing), and st_ctime (time the
          file was created).

        - You cannot use a tag or typedef to add the members of an
          anonymous (nameless) struct or union to another anonymous
          struct or union. Instead, you must give the full definition
          of the struct to be nested. Assume you have the following
          anonymous struct:

               struct oneTag
               {
                   int aMem;
                   int bMem;
               };

          The following code fragment shows the incorrect way to
          include the members of this struct in another anonymous
          struct:

               struct anotherTag
               {
                   struct oneTag;       // INCORRECT
                   int cMem;
               };

          The correct method is to specify the nested struct fully:

               struct anotherTag
               {
                   struct              // CORRECT
                   {
                       int aMem;
                       int bMem;
                   };
                   cMem;
               };

        - The signal function has limitations when used to build
          multithreaded applications or dynamic-link libraries.
          Specifically, only signal(SIGFPE,...) is supported in a
          multithreaded environment. To trap error or interrupt
          conditions in this case, use direct calls to
          DOSSETSIGHANDLER or DOSSETVEC.



================< Part 4: Programmer's WorkBench (PWB) Notes >==============


     PWB Build Procedure
     -------------------

     When developing programs with PWB, you usually follow these basic
     steps:

        - Edit your source file or files.
        - Use the Build Options command on the Options menu to set
          initial build options.
        - Use the Compiler Options and Link Options commands to adjust
          specific parameters.
        - If you are building a multimodule program, use Set Program
          List on the Make menu to specify the files that will be
          included in the program.
        - Choose Build or Rebuild All from the Make menu to
          build your program.

     For more information, choose "Building and Running Programs" from
     the Programmer's WorkBench contents screen in on-line help.


     Building Presentation Manager Applications in PWB
     -------------------------------------------------

     The Presentation Manager build options in PWB assume that
     functions in your program use the _loadds attribute in the
     functions that require it and that exported functions are
     identified with the _export keyword.

     If your program does not identify exported and/or _loadds
     functions in the function header, you need to do two things to
     build the program successfully under PWB. First, select the
     Windows Entry/Exit Codes check box in the C Compiler Options
     dialog box. This is the equivalent of specifying /Gw on the
     command line.

     Second, make sure the exported function names in your .DEF file
     are all in uppercase so that they can be found correctly at link
     time. You can also build the program successfully by disabling
     the No Ignore Case option in the Link Options dialog box, but
     this is not recommended.

     In particular, you will have the problems described here if you
     use PWB to build the example programs in Charles Petzold's book
     "Programming the OS/2 Presentation Manager." Programs built using
     the makefiles provided in the book will run correctly, but
     programs built from within PWB must follow the instructions
     specified above.


     Loading PWB Quickly
     -------------------

     PWB consists of the basic editor and four editor extensions that
     contain the functionality for building, linking, on-line help,
     and the Source Browser. These editor extensions are loaded
     automatically each time you invoke PWB.

     If you want PWB to load more quickly, you can rename some or all
     of the PWB extensions and then load them only when they are
     needed.

     For example, you can change the names of all the extension files
     from *.MXT (DOS) or *.PXT to *.EXT. Then include the following
     section in your TOOLS.INI file:

          [pwb-ext]
          load:$PATH:pwbhelp.ext      ;On-line Help
          load:$PATH:pwbc.ext         ;C compiler
          load:$PATH:pwbrowse.ext     ;Source Browser
          load:$PATH:pwbutils.ext     ;LINK, NMAKE, and CodeView

     To load all the extensions at once, execute the following in PWB:

          arg "ext" initialize

     With the default key assignments, this is

          ALT+A "ext" SHIFT+F8

     To load a single extension--the help extension, for example--you
     can use the following:

          arg "load:$PATH:pwbhelp.ext" assign

     With the default key assignment, this translates to

          ALT+A "load:$PATH:pwbhelp.ext" ALT+=

     If you decide to rename the extensions and thus disable the
     extension autoload feature of PWB, you still have the option
     of starting up PWB with all the extensions loaded.

     To do this, define a macro in the PWB section of TOOLS.INI
     and assign it to a key of your choice. The following TOOLS.INI
     entry creates a macro called 'extload' and assigns it to the F11
     key:

          extload:=arg "ext" initialize
          extload:F11

     Then when you start PWB, you can use the /e option to execute
     'extload' on start-up:

          PWB /e extload


     PWB Notes
     ---------

        - In OS/2 1.1, starting up PWB on a dual-monitor system will
          result in PWB appearing on the monitor that was active at
          the time the system was booted.

          For example, suppose you have both a color and a monochrome
          monitor, and the color monitor is the active monitor when you
          boot your machine. If you switch to the monochrome monitor
          and then invoke PWB, PWB will appear on the color monitor.

          This problem does not exist under OS/2 1.2.

        - To avoid conflict with special characters used by the
          PWB MAKE facility, file names in a PWB program list or in
          customized build options can only have extensions that
          contain the following characters:

               09
               AZ
               az

          No other characters are allowed in a file-name extension.

        - The Command Line option on the Run menu in PWB cannot contain
          characters that have special meaning for NMAKE. In particular,
          you should not use the caret (^) or the dollar sign ($)
          in command lines that are passed to your application by
          PWB.

        - The CL environment variable is fully supported in version
          6.0 of the C compiler. However, when building programs
          from within PWB, you should disable the CL environment
          variable to avoid interaction with PWB build settings.

        - You can launch the editor of your choice from within the
          PWB integrated environment. For more information, consult
          the on-line help for the Customize Menu option on the Run
          menu.

        - The on-line help for the Customize Menu option on the Run
          Menu is partially incorrect. It says that when you are
          adding a command to the Run menu you can specify %S in the
          Argument box to get the name of the current file. However,
          to specify the current file as an argument, you must use
          %s (lower-case s).

        - PWB handles the SHIFT+ALT and SHIFT+CTRL key assignments
          differently depending on whether you are running in DOS or
          OS/2. In DOS, a key sequence beginning with SHIFT+ALT or
          SHIFT+CTRL only recognizes the unshifted value of the third
          key:

               SHIFT+CTRL+<unshifted_character>
               SHIFT+ALT+<unshifted_character>

          In OS/2, however, this key combination requires the shifted
          version of the key to work correctly:

               SHIFT+CTRL+<shifted_character>
               SHIFT+ALT+<shifted_character>

        - For information on how to keep system include files (include
          file names surrounded by angle brackets) out of your list of
          build dependencies, see on-line help for a description of
          the Build switch's system/no system option.

        - You can add your own build information to a PWB makefile by
          putting the following line at the end of the file:

               # << User_supplied_information >>

          You can then add your own NMAKE description file commands
          without disturbing the information created by PWB's build
          process.

          For more information, consult the on-line help for the Make
          menu's Set Program List command.


     OS/2 1.2 Long File-Name Support
     -------------------------------

     OS/2 1.2 long file names are supported in all PWB file-handling
     functions, with a couple of exceptions. This section defines
     long file names, summarizes restrictions, and enumerates special
     cases. See Part 5 for additional information on support of long
     file names.


     Long File Names

     To PWB, a "long file name" is any file name containing the
     characters

          +=[];^,

     Also included is any file name containing a space, or any file
     name whose base name is longer than eight characters. Long file
     names can contain more than one period (.) and can have more
     than three letters following the final period.

     However, files that are intended to be used as part of the build
     process have more severe naming restrictions. To be used as part
     of a build, the file name cannot contain spaces or any of the
     special characters listed above.

     In addition, existing rules for specifying an extension apply:
     the extension consists of a period (.) followed by one to three
     alphanumeric characters. To avoid conflict with NMAKE, file-name
     extensions should not contain any dollar signs ($).


     Quoted File Names

     Any file name may be quoted anywhere. Quoting involves ONLY the
     addition of the double-quote character (") at the beginning and
     end of the complete file name, including the path. There is no
     escape character, as quotes themselves are not valid file-name
     characters. Some situations may require quoting of long file
     names containing characters that were previously illegal.


     File-Name Length

     Under OS/2 1.2, each portion of a file name is restricted in
     length to 256 characters. In PWB and other utilities, the ENTIRE
     file-name length is restricted to 200 characters.


     Extensions

     For build purposes, file-name extensions are recognized as such
     ONLY if they are three characters or fewer in length. Thus
     'WAIT.C' is recognized as having an extension of '.C', while
     'WAIT.C PROGRAM' is treated as if it has no extension.


     Case Preservation

     OS/2 1.2 is case insensitive and case preserving. Thus, 'File' and
     'FILE' both refer to the same file, but OS/2 will not perform any
     case changes on the file names created or copied. PWB operates
     similarly: case in file names is preserved as typed by the user,
     but matches are made without regard to case.


     Exceptions

     Help files may not have long file names. The Helpfiles switch,
     therefore, does not support long file names.


     What to Quote

     You must explicitly quote long file names in the following
     situations:

        - File names inserted in a "%s" format field that could be long
          file names. For example, if long file names could be used,
          the Readonly switch, under OS/2, could be set to:

               readonly: attrib -r "%s"

        - Commands to be executed that happen to be long file names.
          For example, for a program named "Change Attribute", the
          readonly command above might instead be:

               readonly: "Change Attribute" -r "%s"


     Disabled Keyboard in OS/2 1.1 Release 88300
     -------------------------------------------

     If you are using release 88300 of OS/2 1.1 and running PWB in a
     window, your keyboard may become disabled after choosing Run OS/2
     Command or Execute on the Run menu. If you have this release,
     contact your OS/2 distributor for upgrade information.

     This is not a problem with versions of OS/2 other than 88300,
     nor does it occur when running PWB in a full-screen group.



=================< Part 5: CodeView and Utilities Notes >===================


     CodeView notes:

        - The Microsoft CodeView(R) debugger now has a TOOLS.INI switch
          that controls whether breakpoints, window configurations, and
          other information is saved and restored from one debugging
          session to the next. This switch, the Statefileread switch,
          is set to yes if you want this information to be preserved,
          and no if you do not.

          For further information, see "Configuring CodeView" in the
          CodeView on-line help. Also, see the description of the /TSF
          start-up option below.

        - Do not attempt to debug programs with code in include files
          if those files are included prior to the main function.

        - When using CodeView to debug programs containing _fastcall
          functions, you cannot call the _fastcall functions from
          within CodeView.

        - Pressing CTRL+BREAK to end a debugging session while
          recording debug history in OS/2 can result in a corruption
          of the files used to record debug history. Turn off debug
          history before ending a debugging session with CTRL+BREAK.

          If you do press CTRL+BREAK while debug history is on, do not
          try to reuse the files containing the debug history
          information (.CVH or .CVI files).

        - When debugging a graphics program or using two-monitor
          debugging, make sure you have the most current version (7.0)
          of the Microsoft Mouse driver installed. If you do not have
          the most current version, or are using a mouse from another
          manufacturer, you should use the /M option (disable mouse
          support) in the situations referred to above.


     CodeView features added since the documentation was printed:

          Start-up switches:

               /K     Disable keyboard monitor installation (OS/2) or
                      disable hooking of the keyboard interrupt (DOS).
                      See on-line help for further details.

               /TSF   Disable or enable the reading of the CodeView
                      state file, depending on the setting of the
                      Statefileread switch in TOOLS.INI. The CodeView
                      state file restores breakpoints, windows,
                      and other parameters from the last debugging
                      session. See on-line help for further details.


     Utilities notes:

        - The text for the LINK error message L1116 should read as
          follows: "/EXEPACK only valid for OS/2 and real mode
          applications." In other words, you cannot use the
          /EXEPACK option when linking Windows applications.

        - If you experience difficulties using NMAKE with memory-
          intensive makefiles under DOS, you can use the alternate
          program NMK.COM. For further information about NMK, type
          NMK /HELP at the operating system prompt.

        - LINK, LIB, NMAKE, and BIND have two restrictions
          with regard to support of OS/2 1.2 long file names:

            1. Quoted file names can be used only once per argument.
               You can get around this limitation by using a
               response file.

            2. If quotes are necessary, the full file name (including
               the path) must be enclosed in quotes.

        - You can define NMAKE inference rules that allow for the
          placement of source files in one directory and object files
          in another directory. The following example makefile shows
          how to do this:

               # Define 'source' as the directory for .C files and
               # 'obj' for .OBJ files. The caret (^) is required prior
               # to the last backslash (\) to tell NMAKE to use the
               # character literally, not as the line-continuation
               # character.

               source = d:\src^\
               obj    = d:\obj^\

               # Next, set up an inference rule to compile .C files in
               # the d:\src directory into a .OBJ file and put the
               # .OBJ in the d:\obj directory. Use the compiler option
               # /Fo to give the object the name of the current target
               # ($@).

               {$(source)}.c{$(obj)}.obj :
                   $(CC) -c /Fo$@ $<

               $(obj)test.obj : $(src)test.c


     LINK feature added since the documentation was printed:

        - The /NOG[ROUPASSOCIATION] option

          The /NOG option causes the linker to ignore group
          associations when assigning addresses to data and code
          items. It is provided primarily for compatibility with
          previous versions of the linker (versions 2.02 and earlier)
          and early versions of Microsoft language compilers.

          NOTE: This option should be used only with assembly-language
                programs.


     Blank Screen While Debugging under OS/2 1.2
     -------------------------------------------

     If your screen group goes blank after returning from debugging,
     check to see if the following conditions are true:

        - You are running CodeView under OS/2 1.2
        - You are using the two-monitor option (/2)

     If all of the above conditions are true, take the following
     steps to determine if you need to upgrade your version of
     OS/2:

       1. Type 'syslevel' at an OS/2 command prompt. This identifies
          the version of OS/2 you have installed.

          NOTE: Identifying the version alone does not indicate
                a problem. The conditions above must be present
                before an upgrade is required.

       2. If the syslevel command returns the value 'xr04043' and
          you have experienced the difficulties described above,
          contact your OS/2 distributor for an upgrade.


     CodeView Extended Memory Option with Video Seven VGA 16
     -------------------------------------------------------

     To use the CodeView extended memory option (/X) on a Northgate(TM)
     computer with the Video Seven Vega(TM) 16-bit VGA video adapter,
     you must run the Northgate program NORMAL.COM before starting
     CodeView.

     Northgate is a registered trademark of Northgate Computer
     Systems, a division of ABL Corporation. Vega is a trademark of
     Video Seven, Inc.



============< Part 6: Getting Help on Start-Up Error Messages >==============


     Sometimes a program in the C 6.0 Professional Development System
     may encounter an error condition on start-up that prevents the
     program from running.

     To find out more about the resulting error message, you can use
     the on-line help system. Access on-line help by using the
     stand-alone utility QuickHelp, or by using the Help menu in the
     Programmer's WorkBench (PWB).

     To find out about an error message using QuickHelp, at the
     operating system prompt type

          QH cxxxx

     where <c> is the error's alphabetic prefix and <xxxx> is the
     four-digit error number.

     To find out more about how to view errors from within PWB, choose
     "Errors Help" from the Microsoft Advisor Contents screen in PWB.
     (The Microsoft Advisor Contents screen appears when you choose
     "Contents" from the Help menu in PWB.)



================< Part 7: Notes on "Installing and Using" >=================


     Getting Help on Files Listed in the Packing List
     ------------------------------------------------

     You can use the QuickHelp program to get help on any of the
     executable files listed in the file PACKING.LST. Simply type
     QH followed by the name of executable file. For example, to
     view the on-line help file for NMAKE, type

          QH NMAKE.EXE

     at the operating-system prompt.


     Using a Large Number of Help Files
     ----------------------------------

     If the help files for OS/2 and several different languages are
     loaded onto your system, you may receive a message that you have
     too many help files open.

     You can get around this problem by concatenating some of the help
     files. Most applications that display help allow up to 19 open
     physical help files. However, the number of logical (that is,
     concatenated) help files allowed is usually much larger.

     To concatenate help files, use the DOS or OS/2 COPY command with
     the /B (binary) option. For example, to concatenate LINK.HLP and
     UTILS.HLP into a single help file called COMBO.HLP, use the
     following command:

          COPY LINK.HLP /B + UTILS.HLP /B COMBO.HLP /B

     The order in which you concatenate the files determines the order
     in which the files are searched for help information.

     As a final step, be sure to delete the original help files, or
     move them to a directory that is not listed in your HELPFILES
     environment variable.


     Increasing the Maximum Number of Open Files
     -------------------------------------------

     C 6.0 allows you to increase the maximum number of files that may
     be open for I/O (the default number is 20). To use this feature,
     you must be running either OS/2 or DOS version 3.3 or later. Use
     the procedures described in the remainder of this section to
     increase the maximum number of open files.


     Increasing File Handles

     To increase the number of file handles, edit the start-up source
     file CRT0DAT.ASM, which is provided in this release. Change the
     line

          _NFILE_ = 20

     so that _NFILE_ is set to the desired maximum. For example, to
     increase the maximum number of available file handles to 40,
     change the line as shown here:

          _NFILE_ = 40

     NOTE: Increasing the number of file handles allows you to use
           low-level I/O functions, such as open and read, with more
           files. However, it does not affect the number of
           stream-level I/O files (that is, the number of FILE *
           streams).


     Increasing Streams

     To increase the number of streams, edit the source file _FILE.C.
     Change the line

          #define _NFILE_ 20

     to set _NFILE_ to the desired maximum. For example, to allow a
     maximum of 40 streams, change the line as shown here:

          #define _NFILE_ 40

     Increasing the number of streams allows you to use stream-level
     I/O functions, such as fopen and fread, with more files.

     NOTE: The number of low-level file handles must be greater than
           or equal to the number of stream-level files. Thus, if you
           increase the value of _NFILE_ in the module _FILE.C, you
           must also increase the value of _NFILE_ in the module
           CRT0DAT.ASM.


     Increasing the System Limit

     To use more than 20 files at a time, you must increase the file
     limit imposed on your process by the operating system.

     To increase the system-wide limit, increase the number of files
     available on your system as a whole by editing your system
     configuration file (CONFIG.SYS). For example, to allow 100 open
     files at a time on your system, put this statement in the
     configuration file:

          FILES=120

     To increase the process-by-process limit, you must also increase
     the number of files the operating system makes available to your
     particular process. To do this, edit CRT0DAT.ASM and enable the
     commented-out code that is preceded by the appropriate
     description.

     In the DOS version of CRT0DAT.ASM, for example, the commented-out
     code appears as shown here:

          ;       mov     ah,67h
          ;       mov     bx,_NFILE_
          ;       callos

     In the OS/2 version of CRT0DAT.ASM, the code appears as a
     call to DOSSETMAXFH. Under OS/2, you must also enable the
     'extrn DOSSETMAXFH:far' declaration that appears near the
     beginning of the file.

     In either case, remove the semicolon (;) comment characters.

     NOTE: Under OS/2, you must take into account the fact that each
           process has the potential to "own" open files. When
           planning how many open files to allow on a system-wide
           basis, take this into account.


     Using the Modified Startup Files

     After you modify CRT0DAT.ASM and/or _FILE.C, assemble or compile
     the file(s). The start-up MAKEFILE contains sample command lines
     to perform these jobs. Note that the object files will differ for
     OS/2 and DOS.

     To use the new object files, either explicitly link your program
     with the new CRT0DAT.OBJ and _FILE.OBJ file(s), or replace the
     CRT0DAT.OBJ and _FILE.OBJ object(s) in the appropriate model of
     the C run-time library.


     Multithread (MT) and Dynamic-Link Library (DLL) Libraries

     By default, the C 6.0 MT and DLL libraries support 40 file
     handles and streams instead of 20, which is the single thread
     library default.

     To increase the number of file handles (low-level I/O), simply
     issue a DOSSETMAXFH call from within your program. This increases
     the open file limit for the calling process.

     To increase the allowable number of open streams, first make sure
     that the number of file handles is greater than or equal to the
     number of streams you want. Then rebuild module _FILE.C with the
     desired _NFILE setting (as described under the single thread
     description). Since the MT and DLL libraries are large model, be
     sure to compile _FILE.C with the /AL switch.


     43-Line Mode with DOS 4.01 ANSI.SYS
     -----------------------------------

     You may experience problems trying to switch CodeView or the
     Programmer's WorkBench (PWB) to 43-line mode if you are using DOS
     4.01 and ANSI.SYS.

     To use Codeview or PWB in 43-line mode in this situation,
     switch to 43-line mode using the MODE command (MODE CO80,43)
     before you invoke the program.

     This problem also affects the graphics functions _settextrows
     and _setvideomoderows. Under DOS 4.01 with ANSI.SYS installed,
     using these functions to set 43-line mode may cause unexpected
     behavior.

     At the moment, the only known solution is to remove ANSI.SYS
     from your CONFIG.SYS file and reboot your machine.



====================< Part 8: Notes on "C Reference" >======================


     Page    Note
     ----    ----

     5       CL (Compiler) /Bx Options
             -------------------------
             The complete syntax of the /B1, /B2, and /B3 options is as
             follows:

                  /B1 [drive:path]C1L
                  /B2 [drive:path]C2L
                  /B3 [drive:path]C3L

             See on-line help for further information.

     7       CL (Compiler) /ML Option
             ------------------------
             The third sentence should read: "The /ML option is
             functionally equivalent to /ALw /FPa /G2 /D_MT; however, you
             must specify /ML rather than the expanded equivalent."

     8       CL (Compiler) /MT Option
             ------------------------
             The second sentence should read: "The /MT option is
             functionally equivalent to /ALw /FPi /G2 /D_MT; however, you
             must specify /MT rather than the expanded equivalent."

     34      NAME Statement
             --------------
             The syntax for the NAME statement in a LINK module-definition
             file is as follows:

                  NAME [appname] [apptype] [NEWFILES]

             The optional attribute NEWFILES specifies that the
             application supports long file names and extended file
             attributes under OS/2 1.2.

             The linker also supports LONGNAMES as a synonym for NEWFILES,
             although LONGNAMES is now considered obsolete.

     347     The _strtold Function
             ---------------------
             The _strtold function is not an ANSI function.



==========< Part 9: Notes on "Advanced Programming Techniques" >============


     C 6.0 and the ANSI C Specification
     ----------------------------------

     The on-line help for the __STDC__ macro implies that C 6.0 is
     fully ANSI C compatible. While C 6.0 has many ANSI-related
     enhancements, it is not strictly accurate to say that the
     compiler is fully ANSI compatible.

     For complete information on Microsoft C 6.0 ANSI compatibility,
     see Appendix B of "Advanced Programming Techniques."


     "Advanced Programming Techniques" Notes
     ---------------------------------------

     Page    Note
     ----    ----

     36      The Tiny Memory Model
             ---------------------
             In the third paragraph, the reference to CRTCOM.OBJ should be
             to CRTCOM.LIB.

     38      Specifying a Memory Model
             -------------------------
             At the bottom of the page, the reference to CRTCOM.OBJ should
             be to CRTCOM.LIB.

     99      Preparing for Incremental Linking: The /INCREMENTAL Option
             ----------------------------------------------------------
             The first sentence of the second paragraph in this section
             should read: "The /INCREMENTAL (/INC) option prepares a .EXE
             file for incremental linking."

     124     PWB's extmake Syntax
             --------------------
             The Programmer's WorkBench extmake switch referred to in this
             section is now called the build switch. However, the syntax
             for getting information about fully qualified file names is
             still valid.

             For further information, see the help topic "build."

     348     Calling the OS/2 API
             --------------------
             The second paragraph on page 349 should read: "Most OS/2 API
             functions return 0 if the operation is successful. They
             return an error code if the operation fails. The exception to
             this is Presentation Manager APIs, which return 0 if the
             operation fails. If you are programming under the
             Presentation Manager, use the WinGetLastError function to
             determine the nature of an API function call error."

     352     Family API Functions
             --------------------
             The functions VioGetBuf and VioShowBuf should not be
             included in the list of OS/2 1.1 Family API functions.

     430     The _fastcall Attribute (/Gr Option)
             ------------------------------------
             The list of argument types and their potential register
             assignments should note that far pointers are passed on
             the stack.

     456     Default Date and Time
             ---------------------
             References in this section to the predefined date and
             time macros should be to __DATE__ and __TIME__, rather
             than _DATE_ and _TIME_.



=============< Part 10: Patching MOUCALLS.DLL (OS/2 1.1 Only) >==============


     The dynamic-link library, MOUCALLS.DLL, handles OS/2 API
     functions that process mouse messages. Some versions of
     MOUCALLS.DLL shipped with OS/2 1.1 cause a general protection
     fault when running such applications as the Programmer's
     WorkBench (PWB). This section describes how to patch MOUCALLS.DLL
     to correct the error.

     Identifying the Problem
     -----------------------
     When a general protection fault occurs under OS/2, the system
     displays the location of the fault. If the fault occurs with CS
     equal to 20F, follow the procedure outlined in the next section
     to patch MOUCALLS.DLL.

     Patching MOUCALLS.DLL
     ---------------------
     Because OS/2 1.1 with the Presentation Manager uses MOUCALLS.DLL,
     you cannot directly alter the file. Instead you must modify a copy
     of the file as shown:

       1. Create a directory on your boot disk called C:\NEWMOU.

       2. Copy your C:\CONFIG.SYS file to C:\CONFIG.MOU.

       3. Edit your C:\CONFIG.SYS file. There is a line in it that
          begins with LIBPATH. Add the directory C:\NEWMOU as the first
          directory in the line. So, if the LIBPATH line originally
          looks like

               LIBPATH=C:\OS2;C:\LANMAN

          change it to

               LIBPATH=C:\NEWMOU;C:\OS2;C:\LANMAN

       4. Locate the file MOUCALLS.DLL on your hard drive. It is
          probably in the OS2 directory of your boot drive. If not, it
          is certainly in one of the directories listed in the LIBPATH
          line you just edited.

          Copy MOUCALLS.DLL to the C:\NEWMOU directory.

       5. Reboot your computer.

       6. After the system has come back up, change directories to the
          C:\OS2 directory, or wherever the original MOUCALLS.DLL
          resides.

       7. Run the following command:

               PATCH MOUCALLS.DLL

          The PATCH program prompts you for the offset location to be
          patched. Type the following offset:

               1432

          Then change the hexadecimal value of the byte at that
          location from 1A to 1C.

          Note that there should be a program called PATCH.EXE on your
          path. It will make the appropriate change to the
          MOUCALLS.DLL file.

       8. Copy C:\CONFIG.MOU back over C:\CONFIG.SYS and delete
          C:\CONFIG.MOU.

       9. Reboot your computer.

      10. After the system has come back up, delete the files in
          C:\NEWMOU and remove the directory.



================< Part 11: HIMEM, RAMDRIVE, and SMARTDRV >==================


     The DOS device driver HIMEM.SYS is provided with the C 6.0
     Professional Development System for compatibility with CodeView
     3.0. In addition, new versions of two related drivers,
     SMARTDRV.SYS and RAMDRIVE.SYS, are provided to go with the updated
     version of HIMEM.

     NOTE: This version of HIMEM is not compatible with versions of
           Microsoft Windows earlier than version 3.0.


     HIMEM
     -----

     Description

     HIMEM.SYS is an extended memory manager provided so that CodeView
     can take advantage of all your computer's available memory when
     running under DOS on an 80286 or 80386 machine with expanded
     memory.


     Usage

     DEVICE=[d:][path]HIMEM.SYS [options]

     The most common way to use HIMEM.SYS is to include the following
     line in your CONFIG.SYS file:

          DEVICE=HIMEM.SYS

     The following options are also available:

          /HMAMIN=h
          /NUMHANDLES=n

     The /HMAMIN option allows controlled access to high memory by
     specifying (in <h>) the minimum amount of memory a terminate-and-
     stay-resident (TSR) program can use in high memory.

     The /NUMHANDLES option sets (in <n>) the maximum number of
     extended memory block handles that can be used at any given time.


     RAMDRIVE
     --------

     Description

     RAMDRIVE.SYS is an installable device driver that lets you use a
     portion of your computer's memory as if it were a hard disk.


     Usage

     DEVICE=[d:][path]RAMDRIVE.SYS [disksize][sectorsize][entries][memtype]

     <disksize> specifies the disk size in kilobytes (K). The default
     is 64K, and the minimum is 16K.

     <sectorsize> specifies the sector size in bytes. The default size
     is 512 bytes. The following values are allowed: 128, 256, 512, and
     1024.

     <entries> specifies the number of entries allowed in the root
     directory. The default value is 64; the minimum, 4; the maximum,
     1024.

     <memtype> specifies what kind of memory you want RAMDRIVE to use.
     The following options are available:

        - The /e option lets you use any installed memory above one
          megabyte as a RAM disk. This option cannot be used with the
          /a option.

        - The /a option lets you use memory on an expanded memory
          board that is compatible with the Lotus/Intel/Microsoft
          Expanded Memory specification. This option cannot be used
          with the /e option.

        - If you omit the <memtype> option altogether, RAMDRIVE
          attempts to set up a virtual drive in conventional memory.


     SMARTDRV
     --------

     Description

     SMARTDRV.SYS is a disk-caching program for computers that have a
     hard disk and extended or expanded memory. For SMARTDRV to operate
     correctly, the current version of HIMEM must be installed.


     Usage

     DEVICE=[d:][path]SMARTDRV.SYS [size][/a]

     <size> is the amount of memory you want SMARTDRV to have. The
     default is 256K of extended memory or all of expanded memory.

     The /a switch is used when you have expanded memory or an
     expanded memory emulator. If you omit this switch, SMARTDRV uses
     extended memory.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\tools6\bin\tools.ini ===
[nmake]

#############################################################################
#                                                                           #
# These are the built in rules and path definitions used by the new MS Make #
# Utility (NMAKE). The following variables are set externaly (ie set in the #
# individual makefiles.                                                     #
#                                                                           #
# extasw = The 'extra assembly switch' variable is optionaly used in the    #
#          makefile to specify special MASM command line switches.          #
#                                                                           #
# extcsw = The 'extra C switch' variable is optionaly used in the makefile  #
#          to specify special C compiler command line switches.             #
#                                                                           #
# inc    = The include file search path from the utility being built to the #
#          INC directory. Used if needed.                                   #
#                                                                           #
# hinc   = The include file search path from the utility being built to the #
#          H directory. Used if needed for C source compilation.            #
#                                                                           #
#############################################################################

########## Definitions for the Assembler      #####
########## awarn can be overridden by placing #####
##########    the new warning level in extasw #####
##########    in the makefile                 #####

asm     =masm
awarn   =-W2
aflags  =-Mx -t $(awarn) $(extasw)
ainc    =-I.

########## Definitions for C compiler         #####
########## cwarn can be overridden by placing #####
##########    the new warning level in extcsw #####
##########    in the makefile                 #####

cc      =cl
cwarn   =-W3
cflags  =-Os -Zp $(cwarn) $(extcsw)
cinc    =-I.

########## Definitions for linker ##########

link    =link
exelink =/E

########## Definitions for compress ##########

compress =compress

########## Built-in rules ##########

.SUFFIXES:
.SUFFIXES: .c .obj .lst .exe .exc .exs .com .sal .cod .sil .inc .skl .cla .cl1 .ctl .asm .idx .msg

.sal.asm:
        salut $*.sal,nul,$*.asm

.asm.obj:
        $(asm) $(ainc) $(aflags) $*.asm;

.asm.lst:
        $(asm) -l $(ainc) $(aflags) $*.asm;

.c.obj:
        $(cc) -c $(cinc) $(cflags) $*.c

.c.lst:
        $(cc) -c $(cinc) $(cflags) -fc$*.cod -fo$*.obj $*.c

.exs.sys:
        copy $*.exs $*.exe
        reloc $* $*.sys
        del $*.exe

.exc.com:
        copy $*.exc $*.exe
        reloc $* $*.com
        del $*.exe

.exe.com:
        convert $*.exe

.skl.cl1:
	nosrv $(msg)\$(COUNTRY) $*

.sil.inc:
	salut $*.sil,nul,$*.inc

.sal.obj:
	salut $*.sal,nul,$*.asm
	$(asm) $(aflags) $(ainc) $*.asm,$*.obj;

.msg.idx:
        chmode -r $*.msg
	buildidx $*.msg
        chmode +r $*.msg
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\csource.txt ===
The following extrinsic commands have portions written in C:

	ATTRIB
	BACKUP
	FDISK
	JOIN
	FILESYS
	MEM
	REPLACE
	RESTORE
	SUBST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\command\readme.txt ===
This directory contains source files for COMMAND.COM, including
internal commands.

A list of the internal commands, some characteristics, and hints
about where they're found appears in TDATA.ASM, labelled COMTAB.

COMSEG.ASM contains a brief description of each segment in
COMMAND.COM.

  TRANDATA contains data which doesn't usually change, so is
  included in the transient checksum area, while TRANSPACE is
  modifiable, and excluded from the transient checksum.  TRANSPACE
  variable should be treated as uninitialized data for every
  command cycle.

----------------------------------------------------------------------

Here's a listing of the general contents of files,
concentrating on central functions and publics in each module.

Sizes are approximate and probably obsolete by the time you
read this.


Name         Size     Contents
            (000's)

COMEQU   ASM  10   Command.com equates, structures, macros.
COMMAND1 ASM  19   Main header & some resident code: 
		    command.com entry point; exec call; ctrl/c handler.
COMMAND2 ASM  14   Resident code: alloc mem, load, & checksum transient;
		    int 2E (single command line execute) entry point;
		    check for removable media (callable by transient);
		    save user's stdin/out & set to stderr; restore stdin/out;
		    clean up program header, closing files;
		    set terminate, ctrl/c, disk error 'interrupt' vectors;
		    move environment to new segment at end of init.
COMSEG   ASM   1   All segments, in load order.
COMSW    ASM       Build switches: refers to version.inc.
COPY     ASM  28   COPY command.
COPYPR1  ASM   6   Routines for COPY command.
COPYPR2  ASM  10   Routines for COPY command.
CPARSE   ASM   9   Command-line parse routine.
DIR      ASM  73   DIR command.
ENVDATA  ASM       Default environment data definitions.
FORDATA  ASM       A data definition for FOR loop routine (tfor.asm).
IFEQU    ASM       'Equates which are switch-dependent' (none here).
INIT     ASM  47   Command.com initialization routine.
IPARSE   ASM       SYSPARSE equates (this file is probably obsolete).
PARSE2   ASM  13   Command-line parse routines, argv style.
PATH1    ASM  16   Pathname invocation (find an executable or batch file).
PATH2    ASM  13   See PATH1.
RDATA    ASM  17   Resident data definitions.
RUCODE   ASM  19   Language-dependent resident code:
		    ctrl/c batch termination dialog;
		    int 24 disk error handler;
		    DBCS lead byte check ITESTKANJ;
		    reset parse & critical error message ptrs before exiting;
		    RPRINT message printer.
TBATCH   ASM  26   Batch processing routines.
TBATCH2  ASM  15   Batch processing routines.
TCMD1A   ASM  17   Obsolete DIR command.  Module no longer used.
TCMD1B   ASM  20   PAUSE, DEL, RENAME, TYPE, VOL commands.
		    Find & print volume label & serial #.
		    Get/set a file's code page;
		    Set extended error message pointer;
		    Get extended error number.
TCMD2A   ASM  12   VER, CLS command.
		    Support routines for transient:
		    build directory strings; print things.
TCMD2B   ASM  18   CTTY, CHCP, TRUENAME commands.
		    Parse routines to set up error messages.
TCODE    ASM  13   Main entry points to transient.
TDATA    ASM  21   Transient data:  internal command table;
		    parse control blocks; miscellaneous.
TENV     ASM  13   PROMPT, SET commands.  Environment utilities.
		    Restore user directory.
TENV2    ASM  14   CHDIR, MKDIR, RMDIR commands.  Path crunch.
		    Save user directory.
TFOR     ASM  15   FOR loop processing.
TMISC1   ASM  15   Old switch parser; find & execute commands;
		    prescan command-line, removing pipes & redirects;
		    Error recycle point for command.com.
TMISC2   ASM  10   Examine pathname, set up pathname argument.
		    Move string to srcbuf.
		    Set up error message for extended error.
		    Some redirection stuff (IOSET).
TPARSE   ASM   1   Transient interface to system parser SYSPARSE.
TPIPE    ASM  17   Pipe stuff.  DATE, TIME commands.
		    Check for single command execute.
		    Set flag (in resident) to restore default directory.
TPRINTF  ASM  11   Set up and print messages, with substitutions.
TRANMSG  ASM  20   Transient messages and substitution blocks.
TSPC     ASM  11   Transient 'uninitialized' data.
TUCODE   ASM  14   Transient 'modifiable' code:
		    verification prompts for DEL;
		    ECHO, BREAK, VERIFY commands;
		    print date;
UINIT    ASM   7   Data definitions/messages for initialization.
		    Includes parse control block for COMMAND command.
COMMAND  CL1   2   Messages, class 1.  Automatically generated.
COMMAND  CL2   1   Messages, class 2.  Automatically generated.
COMMAND  CL3   1   Messages, class 3.  Automatically generated.
COMMAND  CL4   1   Messages, class 4.  Automatically generated.
COMMAND  CLA   8   Messages, class A.  Automatically generated.
COMMAND  CLB   2   Messages, class B.  Automatically generated.
COMMAND  CLC   3   Messages, class C.  Automatically generated.
COMMAND  CLD   5   Messages, class D.  Automatically generated.
COMMAND  CLE   7   Messages, class E.  Automatically generated.
COMMAND  CLF  18   Messages, class F.  Automatically generated.
COMMAND  CTL       Number of message classes.  Automatically generated.
RESMSG   EQU   2   Message number equates for resident and init code.
COMMAND  LNK       LINK input file.
COMMAND  SKL  10   Message skeleton file.
README   TXT	   This file.

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fastopen\fastopen.txt ===
.*
.pm 5
:gdoc sec=''
:frontm
:titlep
:title.FASTOPEN UTILITY HIGH LEVEL DESIGN
:date.
:author.J. K.
:ETITLEP
:toc
:body
.DH NUM
.*.pa
&SYSDATE.
.*:H1.INTRODUCTION
.*:H1.ARCHITECTURE OVERVIEW

:H1.FASTOPEN DESIGN
:H2.FASTOPEN UTILITY
:H3.FASTOPEN Overview
FASTOPEN is a utility that allows DOS to maintain the information about
files that have been opened.  The purpose is to reduce the number of times DOS
has to look into the directory area of the disk for information on the file once
the information is stored by FASTOPEN.	In real life, many application
programs, especially current database systems on the market, tend to open the
same file repeatedly and every open operation needs an access to the disk if the
information does not exist in the DOS buffer.  The FASTOPEN utility will
eliminate these disk accesses, and hence will increase the efficiency of DOS
performance.


:H3.FASTOPEN Operational Description
Conceptually FASTOPEN itself is a database maintained by DOS.  The data will
be stored and maintained in the system RAM.

FASTOPEN is a user-installable, stay resident utility loaded by entering a
command
.fo off
	1). FASTOPEN D:{=L} ...

where	"..." means a possible repetition.

	"D:" is a drive letter for a non_removable media.

	"L" is the maxium number of files and subdirectories that can be
	stored in the drive cache. The default value is 34, minimum
	value, 10.  The total number for all the drives is less
	than 1000.

.fo on

:H4.Name Caching
FASTOPEN will keep the history of the accessed subdirectory and file
information in LRU fashion.  The data are stored in a partial tree
structure that represents all the recently accessed files and
subdirectories of that drive.  The number of entries entered by the
user, or the default number of 34, represents the maximum number of
nodes and leaves of the tree.	As it suggests, the bigger the
number is, the more the efficient it will be.  Currently each additional
increase of the entry will take 36 bytes, which is the fixed length of
a node.

The number entered by the user should be bigger than the deepest nesting
of path entries in the drive.

The operation on this name cache is similar to the operation on the
physical drive.
With the look up request, FASTOPEN will traverse the name cache tree from the
root to the bottom to find the requested path, filename.  If found, then the
pointer to the file or subdirectory information packet will be returned, else FASTOPEN
will return the string pointer that points up to the matching subdirectory name.
In this case, if DOS wants to insert the rest of the subdirectory/file information
an insert operation should be requested for every subdirectory/file.  FASTOPEN
will use the information from the previous Look_up operation for a sequence of Insert operations.

At this moment, if there are any free entries left, then it will be used.
Otherwise, FASTOPEN will delete the least recently used leaf.  Any node cannot
be deleted until the node becomes an empty leaf, i.e., without children.
If a file or a directory has been removed, then DOS will update the name
cache tree with the Delete request.  The path, file will be looked up
first, and if found, then the corresponding entries will be free to the
free entry chain.  If not found, then still it is O.K. since the matching file
entries had been removed by the LRU scheme.


:H3.Fastopen Interface
When installed, by the nature of the functionality, FASTOPEN becomes
a part of DOS and a private communication mechanism will be
established.
Inside DOS, vector pointers are established for FASTOPEN and will be
initialized by the call "CALLinstall" macro by the FASTOPEN initialization.
The structure of the FASTOPEN entry will look like;

.fo off
FASTOPEN_ENTRY	struc
FASTOPEN_ENTRY_SIZE		dw	4    ;size of the following
FASTOPEN_NAME_CACHING		dd	?
;FASTOPEN_FATCHAIN_CACHING	 dd	 ?     ;not for DOS 3.3
;NUMBER_OF_SFTS 		 dw	 ?     ;# of files - 3
FASTOPEN_ENTRY	ends
.fo on

The initial vector pointer for FASTOPEN_NAME_CACHING
points to a dummy routine in DOS which simply set the carry flag and set AX to 0FFFFh.

When FASTOPEN is installed, then this vectors table will be established to
point to the matching procedures in FASTOPEN module.

The register AL will contain subfunction value on entry to FASTOPEN.

.fo off
;FASTOPEN NAME CACHING	Subfunctions
fastopen_name_look_up	equ	1
fastopen_name_insert	equ	2
fastopen_name_delete	equ	3
;fastopen_name_purge	equ	4	;Not for DOS 3.3

.fo off
1. Name Caching

 a. Look up
   IN)	DS:SI -> d:path
	ES:DI -> DIR_INFO buffer in DOS to be filled by FASTOPEN
	ES:CX -> Extended_Info buffer in DOS to be filled by FASTOPEN
   OUT)
	if found, DS:SI -> the last character of the path, i.e., 0.
		  ES:DI -> DIR INFO
		  ES:CX -> Extended INFO (explained in the data structure)
   else if there exist the name cache for the drive, but could not
	completely find the matching path,
		  DS:SI -> "\" following the directory that FASTOPEN can
			   find the match,
			   Will points to "\" after "d:" if no matching
			   root directory is found.
		  ES:DI -> Compct_Dir_Info of the subdirectory FASTOPEN
			   can find the match.
		  ES:CX -> the matching directory's Extended INFO
		  If cannot find the matching root directory entry, then
		  ES:DI, ES:CX are undetermined.
   else carry flag set and AX = 0FFFFh.

 b. Insert
   IN)	DS:DI -> DIR info
	ES:BX -> Extended info

   OUT)
	If failed, then carry flag set and AX = 0FFFFh.
	Insert operation handles only one file or subdirectory at a time.
	So, usually insert operations are performed in a sequential manner.
	A look up operation should be performed before any new sequential
	insert operation.
	FASTOPEN will keep the information of the pervious look up
	operation in CURRENT_NODE.  The CURRENT_NODE points to the matching
	directory node of the previous Look up operation.  The next insert
	operation will use this CURRENT_NODE information to insert the
	directory or file information.	So, DOS will call only one Look_
	up operation and possibly several Insert operation to insert the
	path.

	For example, suppose DOS wants to look up C:\DIR1\DIR2\FILE1 and
	FASTOPEN only has the inforamtion up to C:DIR1.  After the
	look up operation, FASTOPEN will return with DS:SI points "\"
	following C:\DIR1.
	At this moment, if DOS decides to insert this information,then
	it sets DS:DI to DIR_INFO, and ES:BX to EXTENDED_INFO of the
	subdirectory DIR2, and will request an insert operation.
	When control returned back to DOS, then it will set this time
	DS:DI and ES:BX to those of FILE1, and will call an another
	insert operation.
	At the first insert operation, FASTOPEN automatically knows
	that those informaton given by DOS belong to the child of
	C:\DIR1, and will install it as a child.  In the second operation,
	again FASTOPEN knows that it is for the child of C:\DIR1\DIR2
	and will accordingly install the information for FILE1.

 c. Delete
   IN)	DS:SI -> d:path

   OUT)
	If failed, then carry flag set and AX = 0FFFFh.

.fo on

:H3.FASTOPEN Special Considerations
FASTOPEN uses the following DOS function calls in its initialization
rouitine.  No DOS or BIOS function calls are allowed inside the
main routine that is resident once installed.
:ul
:li.AH = 40h, Int 21h; Write to device for the messages,
:li.AH = 31h, Int 21h; Terminate Process and Remain Resident,
:li.AH = 48h, AH = 49h, AH = 4Ah, Int 21h;  Allocate, free and
modify memory block.
:eul
:p.

To prevent the corruption of any DOS operation, once FASTOPEN is
loaded it cannot be reloaded.


:H4.FASTOPEN Top Level Design

:H5.Data Structure

The structures of the records in FASTOPEN are:

.fo off
NAME_record struc
	LRU_pointer	dw	-1
	Child_pointer	dw	-1
	Sibling_pointer dw	-1
	MRU_pointer	dw	-1
	Compct_Dir_info db	22 dup (?)
	Extended_Info	db	 5 dup (?)
NAME_record ends

Extended_Info	struc
dirpos	db	0
dirsec	dw	0
clusnum dw	0
Extended_Info	ends

Drive_cache_header	struc
LRU_ROOT	dw	0	 ;Start of LRU chain for this Name cache
Child_ptr	dw     -1	 ;points to the name cache
Sibling_ptr	dw     -1	 ;points to the next drive header
MRU_ROOT	dw	0	 ;set to the end of LRU chain
Drive_letter	db     'C'
Num_Entries	dw	0
Name_Cache_start dw	0	 ;Start of name cache for this drive
Drive_cache_header	ends

Cmpct_Dir_Info	struc
CD_File_name		db	11 dup (0)
CD_File_attr		db	?
CD_time 		dw	?
CD_date 		dw	?
CD_cluster		dw	?
CD_Filesize		dd	?
Cmpct_Dir_Info	ends

Dir_Info	struc		;= full directory entry information.
DI_head 		db	12 dup (?)
DI_skip 		db	10 dup (0) ;reserved area. All the time 0.
DI_tail 		db	10 dup (?)
Dir_Info	ends

.fo


:H5.FASTOPEN Hierarch
:H6.FASTOPEN Components

.fo off

		      Ŀ
		        FASTOPEN    
		      
			     
			     
	  Ŀ
	  					
	  V					V
Ŀ			 Ŀ
  INIT				   MAIN	
			 
						
						V
			    Ŀ
			    					   
			    	LOOK_UP, INSERT, DELETE, INIT_TREE 
			    					   
			      (SUPPORTING MODULES)		   
			    					   
			    	GET_FREE_NODE, PRE_LRU_STACK,	   
			    	SET_LRU,  MAKE_NAME_RECORD,	   
			    	UNFOLD_NAME_RECORD, PACK_DIR_NAME, 
			    	REMOVEFROMLRUCHAIN		   
			    

.fo

:H6.FASTOPEN Memory Structure

.fo off
  Lo_memory   Ŀ 
	            LOOK_UP,		     
	            INSERT,		     M
	            DELETE,		     A
	          & Supporting Routines     I
	       			     N
	       Ĵ  
	             INIT_TREE 	     
	       Ĵ 
	           DRIVE_CACHE_HEADER	     I
	           (After Init, this	     N
	            area will be used	     I
	            for name caches.)	     T
	           SHOW_ERR_MESSAGE	     
	        

  High_memory
.fo

.pa
:H5.FASTOPEN Component Interfaces

.fo off
;*************************************************************************
;
;SUBROUTINE: INIT
;
;INPUT:
;
;OUTPUT:
;
;DESCRIPTION:
;
;      1:(Installation check)
;	{ Get the entry pointer of FASTOPEN from DOS.
;	  Check the signature ($FASTOPEN01$)
;	  If already installed,
;	   then Show 'FASTOPEN already installed'; Exit
;	}
;
;      2:(Parse the command line)
;	 Input: User input
;
;	 Output: Total_Entry_Num.
;		 Drive_Cache_Headers set.
;		 End_Cache_Header.
;
;	{ For every drive entered
;	  { Drive sanity check;
;	    Get_Num;
;	    if success and Total_Entry_Num < 1000, then
;	       Set Drive_Cache_Header;
;	  }
;	 }
;
;	3:(Check the system memory) - Check if the system has enough
;				      memory for the Name caches.
;				      Name cache will start from the
;				      End_Cache_Header.
;
;	 Input: Total_Entry_Num, End_Cache_Header, End_Init,
;	 Output: End_Caches
;	{
;	  Needed_space = size of (Name_Record) * Total_Entry_Num;
;	  Needed_space = Needed_space - (End_Init - End_Cache_Header);
;	  Free allocated memory from End_Init (AH = 4Ah);
;	  Set memory block from End_Init to Needed_Space (AH = 48h);
;	  if fail, Show 'Insufficient memory for FASTOPEN cache';
;	  Set End_Caches;
;	}
;
;	4: jmp to INIT_TREE
;
;*************************************************************************


.pa
.fo off
;*************************************************************************
;
;SUBROUTINE: INIT_TREE
;
;INPUT: Drive_cache_header, End_Caches
;
;OUTPUT:Name_cache entries installed for every drive requested.
;	LRU chain established for every drive.
;	FASTOPEN entry pointer set in DOS.
;	Terminate & stay resident. (Up to End_Caches)
;
;DESCRIPTION:
;
;	1:(Install_Name_Cache)
;	 Input: Drive cache header, End_cache_header (= Name cache start)
;	 Output:According to the information in the header,
;		the name cache entries will be established.
;		Also, LRU chain, MRU_pointer are established.
;
;	{ Buffer_start = End_cache_header;
;	  For every drive header
;	  { LRU_ROOT = Buffer_start;
;	    For (i=1;i=Num_Entries;i++)
;	    { MRU_pointer = Buffer_start;
;	      Buffer_start= Buffer_start + size_of (Name_record);
;	      if i = Num_Entries then LRU_pointer = -1
;				 else LRU_pointer = Buffer_start;
;	    }
;	  }
;	}
;
;	2:(Set FASTOPEN entry pointer in DOS)
;	 Use CALL INSTALL macro.
;
;	3: Terminate and stay resident up to Buffer_start;
;
;*************************************************************************


.pa
.fo off
;*************************************************************************
;
;SUBROUTINE: MAIN
;
;INPUT: Called by DOS throught Look_up, Insert, Delete requests.
;
;OUTPUT:Request performed based on LRU scheme.
;	CX, DX, DS, ES, BP value saved.  Other register are destroyed.
;
;DESCRIPTION:
;	Call Pack_Dir_Name		;get the drive letter in BL
;	Call Get_Drive_Cache_Header	;find the matching drive header
;	if not found, then AX = 0ffffh, Carry set
;  else if AL = Look_up then Call Look_up
;  else if AL = Insert	then Call Insert
;  else if AL = Delete	then Call Delete
;  else AX = 0ffffh, Carry set.
;
;	MAJOR SUBROUTINES:
;	(Look_up) - Refer to Look_up subroutine.
;	(Delete)  - Refer to Delete subroutine.
;	(Insert)  - Refer to Insert subroutine.
;
;	SUPPORTING SUBROUTINES:
;	1:(Get_Free_Node) - Get the entry from the LRU_ROOT,
;			    Set LRU_ROOT to the next entry of the
;			    LRU chain
;	 Input: none
;	 Output:Entry address. LRU_ROOT updated to the next entry.
;
;	2:(Pre_LRU_Stack) - This is needed to implement LRU scheme in
;	  a tree structure.  Since the order of traversing a tree is
;	  from the root to bottom and from left to right, the direct
;	  implementation of LRU will result the parent the least mostly
;	  used one instead of the child.  This is exactly in the reverse
;	  order to what had been expected.  This procedure will
;	  solve this problem without loss of any efficiency.  In the
;	  Look_up operation and found the match, the found entris will
;	  be saved with each of its LRU, MRU pointer modified to reflect
;	  the desired LRU order.
;	  These created mini LRU chain will be attached to the
;	  LRU chain again by SET_LRU.  SET_LRU and PRE_LRU_STACK
;	  should work in a synchronized fashion.  SET_LRU routine
;	  will be called in the beginning of every Look_up, Insert
;	  operation.  PRE_LRU_Stack will be called whenever a matching
;	  entry is found in a Look_up operation, or whenever a new
;	  entry is inserted by the Insert operation.
;	 Input: Current_Drive,Target node.
;	 Output:Depth, Top, Bottom set
;
;	3:(SET_LRU)
;	 Input: Depth, Top, Bottom, Current_Drive
;	 Output:Mini LRU chain created by Pre_LRU_Stack will be
;		placed at the end of LRU chain.
;
;	4:(MAKE_NAME_RECORD) - At Insert time, BOS will give
;	 two types of information. DS:DI -> Dir_Info, ES:BX -> Extended_
;	 Info.	The Name_Record is composed of Cmpct_Dir_Info and
;	 Extend_Info.  MAKE_NAME_RECORD will simply make a Name_Record
;	 from the informations from DOS.
;	 Input: Dir_Info, Extended_Info
;	 Output:Name_Record
;
;	5:(UNFOLD_NAME_RECORD) - Inverse function of above. When Look_up
;	 operation finishes,  then unfold the Name_Record of the current_
;	 node for DOS.  If the Current_Node is a drive_cache_header,
;	 then will just return.
;	 Input: CS:Current_Node, ES, DI, BX set for the buffer
;	 Output:ES:DI->Dir_Info, ES:BX->Extended_Info buffer in DOS.
;
;	6:(PACK_DIR_NAME) - At Look_up or Delete operation, DS:SI points
;	 to the requested full path, for ex., "C:\DIR1.EXT\DIR2\FILE.EXT",
;	 0.  This routine is smart enough to recognize ":","\" and 0 as
;	 a delimeter and will parse until the next delimeter and leave
;	 SI to the next delimeter found.  Also, if it is a drive name
;	 it will  set SI to the "\" after ":" for consistency and
;	 it will set BL to the drive letter.
;	 The main function of this routine is "pack" the given directory
;	 name into 11 bytes format.  PACKED_NAME will be filled with
;	 the result.  For example, when it is called the first time,
;	 DL =  "C" and SI will point to "\" before DIR1.EXT.
;	 The second time, PACKED_NAME will be filled with
;	"DIR1     EXT" and SI will points to "\" before "DIR2".
;	 Likewize, if this routine is called the fourth time,
;	 FILE.EXT has been parsed and DS:SI will points to 0.
;	 When this routine is called again, then it will return
;	 with carry signaling that it has reached the end.
;	 The user is required to call this routine consequtively
;	 until it returns with carry.
;	 Input:
;	 Output:
;
;*************************************************************************


.pa
.fo off
;*************************************************************************
;
;SUBROUTINE: LOOK_UP
;
;INPUT: DS:SI -> path
;	ES:DI -> DIR_INFO buffer in DOS to be filled by FASTOPEN
;	ES:CX -> Extended_Info buffer in DOS to be filled by FASTOPEN
;	CS:BP -> Matching Drive_cache_header
;
;OUTPUT:if found, DS:SI -> the last character of the path, i.e., 0.
;		  ES:DI -> DIR_INFO
;		  ES:CX -> Extended_INFO (explained in the data structure)
;  else if there exist the name cache for the drive, but could not
;	completely find the matching path,
;		  DS:SI -> "\" following the directory that FASTOPEN can
;			   find the match,
;			   Will points to "\" after "d:" if no matching
;			   root directory is found.
;		  ES:DI -> Dir_Info of the subdirectory FASTOPEN
;			   can find the match.
;		  ES:CX -> the matching directory's Extended INFO
;		  If cannot find the matching root directory entry, then
;		  ES:DI, ES:BX are undetermined.
;		  If the requested path is "D:\,0" then FASTOPEN will
;		  return with carry flag set and, AX = 0ffffh.
;  else carry flag set and AX = 0FFFFh.
;
;GLOBAL VARIABLES:
;	CURRENT_NODE,
;	CURRENT_SIBLING,
;
;DESCRIPTION:
;	   Save Dir_Info, Extended_Info buffer address in DOS.
;	   Set ES to Name_Cache_Seg
;	   SET_LRU;
;      1:
;	   Current_Node = BP
;	   Current_Sibling = 0
;	   PACK_DIR_NAME (from the path);
;	   if CX = 0, then jmp to 3 /*Found*/;
;	   Find_child (from the current_node);
;	   if not found then jmp to 3
;      2:  Compare Packed_name with Child_pointer.CD_filename
;	   if yes, then PRE_LRU_STACK; JMP to 1
;	   else Find_Sibling;Current_sibling=Sibling_pointer
;		if found a sibling, then Current_Node = Current_Sibling
;					 jmp to 2
;		   else jmp to 3;
;      3:  UNFOLD_NAME_RECORD	/*for the info packet to DOS */
;	   Exit
;
;*************************************************************************


.pa
.fo off
;*************************************************************************
;
;SUBROUTINE: INSERT
;
;INPUT: DS:DI -> DIR info
;	ES:BX -> Extended info
;
;OUTPUT:Automatic insertion based on CURRENT_NODE, CURRENT_SIBLING
;	If failed, then carry flag set and AX = 0FFFFh.
;	Insert operation handles only one file or subdirectory at a time.
;	So, usually insert operations are performed in a sequential manner.
;	A look up operation should be performed before any new sequential
;	insert operation.
;
;GLOBAL VARIABLES:
;	CURRENT_NODE,
;	CURRENT_SIBLING,
;
;DESCRIPTION:
;
;	Make_Name_Record	;Make Name Record from the input
;	Get_Free_Node
;	Set_LRU 		;(from TEMP_LRU_STACK)
;	if current_sibling <> 0 (or current_sibling=0FFh)
;		then Install as a sibling of Current_Node
;	   else Install as a child under Current_Node;
;	Pre_LRU_stack		;(pre operation for LRU)
;	Exit
;
;*************************************************************************


.pa
.fo off
;*************************************************************************
;
;SUBROUTINE: Delete
;
;INPUT: DS:SI -> d:path
;
;OUTPUT: If found, then remove the item from the Tree and from the
;	 LRU chain.  Move that slot to the Top of the LRU chain.
;
;GLOBAL VARIABLES:
;
;DESCRIPTION:
;	Look_Up
;	If ds:si -> 0, then Remove that entry from Tree, LRU chain,
;			    Put that entry to the top of LRU chain
;	else AX = 0FFFFh, Carry set,
;	Exit
;
;*************************************************************************


.fo
:egdoc.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\format.doc ===
A WALK THROUGH FORMAT
			---------------------
			  Ver.5.00.410Beta
			  ----------------

	Upon entry to Format, the routine Main_Init is called.  This 
performs all the parsing of the command line, and determines the 
default value for DeviceParameters, which represents the highest 
capacity format for the disk drive being used.  Upon return, a copy of 
SwitchMap (a word value which holds all the switches entered on the 
command line) is saved in SwitchCopy.

	The memory block allocated to the Format code is then resized 
using Int 21h function 4Ah, so as to free extra un-needed memory 
allocated for the FORMAT.COM program when it was loaded.

	Module GLBLINIT is responsible for allocating all the buffers 
needed by Format.  These buffers are listed below.


Name			Size				Primary Usage
---------------------------------------------------------------------		
DirectorySector		1 sector (512 bytes)	Holds a zeroed 
						sector to be written to 
						disk as the root dir.

FatSpace		FAT+RootDir+		Holds new FAT.  
			7 sectors		Reserves space for 
						buffers needed by 						
						Mirror.

FatSector		1 sector		Read in old FAT 
						one sector at a time.

DirBuf			1 sector		General-purpose use e.g.
						reading in boot sector,
      		 				first sector of root dir.

ClustBound_Buffer_Seg 	1 cluster		Read in bad clusters
						on fixed disks.

mStart			Biggest block of 	Read in system files,
						if needed.


	A buffer for system files will be allocated only if /S is specified.  
If this is present, system files will be read in at this time.  The system 
files are read in now so as to prevent an extra disk swap later, i.e. it is 
assumed that the system disk will be in the default drive at this point.  
In case the buffer was not big enough for all the system files (IO.SYS, 
MSDOS.SYS, COMMAND.COM), they will be read in as much as 
possible.  The remainder will then be read in when the system files 
are being written out to disk, after completion of formatting (This idea
is now prevented: if the files cannot be all read prior to format, format
will fail).

	The 1-cluster buffer will be allocated only if the drive being 
formatted is a fixed disk.

	This module also determines the default value for 
DeviceParameters (by a call to routine GetDeviceParameters, which 
obtains them through Int 21h function 440Dh, subfunction 60h).  These 
default parameters are copied to SavedParams.

	A failure of any function call in GLBLINIT will result in the 
termination of Format.

	The portion after the call to Global_Init is the main loop of the 
program.  The code between 'SysLoop' and 'call More' is repeated for 
each disk to be formatted.

	The routine InitSysParm restores the state of several variables 
so that they are in the original state at the outset for each disk being 
formatted.  Thus DeviceParameters are restored from SavedParams 
and SwitchMap is restored from SwitchCopy.

	All allocated buffers are zeroed out in the routine 
ZeroAllBuffers.

	After prompting the user for the disk to be formatted, disk 
access is ensured through a call to Get_Disk_Access.

	Now module PHASE1 is invoked.  This module primarily 
determines the final value of DeviceParameters to be used in 
formatting the disk.  It also handles all the logical requirements to 
validate a safe format.

	In Phase1Initialisation firstly a media sensing call is made, for 
removable media.  This will utilize new media sensing capabilities of 
the hardware to determine what type of disk is being used.  If this 
function is supported, the BPB field in DeviceParameters will be set to 
that of the media detected.  Media sensing can be supported only on 
3.5in disks.

	The routine Set_BPB_Info is now called to handle the case 
when the disk to be formatted is a non-FAT disk.  This routine will set 
DeviceParameters appropriately in this case. 
Note: This case has not been tested, or ever observed, for that matter.

	The CheckSwitches routine takes action based on the size 
specification switches (/F /N /T /1 /4 /8) entered by the user.  If /F was 
specified, it will be translated into the appropriate value for /N & /T.  
Thus SwitchMap may be modified.  Also, DeviceParameters will be set 
appropriately, for all the formats supported.
Note:  CheckSwitches does NOT modify DeviceParameters if it detects 
that the size specification entered by the user is equal to the default 
size for that drive.  This property is taken into account in determining 
the validity of a safe format in PHASE1.

	Upon return from CheckSwitches, a copy of DeviceParameters 
is saved in SwitchDevParams.

	If the user had specified an unconditional format (/U present), 
the format will be done either according to the entered size 
specification, or else to the default size for the drive (which is its 
maximum capacity).

	If /U is not present, the routine DetermineExistingFormat is 
called.  This routine reads the first 2 sectos and validates the boot
sector (the first sector) on the disk.  If the existing format is found
to be valid, then ResetDeviceParameters is called to copy the BPB read
off the boot sector into that of DeviceParameters.  Further, for removable
media the field DP_CYLINDERS is calculated and set.

	If the disk is not found to have a valid format at this point, 
another routine is called to check in case a disk with a CP/M-type boot 
sector is present (for 160K and 180K disks).  The routine DetermineCPMFormat
validates the first sector of the FAT (the second sector read in 
DetermineExistingFormat) by examining the media descriptor byte.  If this is
found to be a CP/M media descriptor, DeviceParameters will be modified.  
A table of customized BPBs is used for this purpose.  <In short, this is 
an extensive routine which will almost always have to be called, while 
being applicable only in obsolete cases.>

	If the disk if found NOT to have a valid format, a check is made 
to see if there was an error reading the disk due to an open door, etc.  
If so, a message will be given and Format will be terminated.  
Otherwise SwitchMap is checked to see if /Q was specified.  Since 
there is no valid existing format, Quick format cannot be done, so a 
warning message will be issued, and the user will be prompted 
whether or not to continue with an unconditional format.  If the user 
chooses to continue, /Q will be turned off, and /U will be turned on.  

	There is one exception to this logic: the user is allowed to 
enter /Q together with a size specification, which means "Quick format 
all pre-formatted disks with their original format, but format new disks 
with the specified size".  Thus, if /Q is present, SwitchMap is checked 
for (/F, /N or /T) and if these are present, the warning message is not 
given.  Instead, the message is jumped over, and the program 
continues as if the user had entered "Yes" to the continue prompt.  
The code will now continue, with DeviceParameters finalized, at 
DevParamsOk.

	In case the disk is found to have a valid existing format, then 
the values of SwitchDevParams and DeviceParameters are compared 
for equality.  If found to be equal, execution continues at 
DevParamsOk (i.e. there is no conflict between any user-specified 
size and the existing format on disk).  Otherwise a warning message
will be issued since there is a conflict between the entered size or
default size andthe format on disk, and the user will be asked 
whether to proceed with an unconditional format.  If the user chooses 
to continue, /U will be turned on and SwitchDevParams will be copied 
into DeviceParameters, so as to utilize the size specification given by 
the user.

	The only exception to the last case is when /Q is present 
together with a size specification, as explained above. Then a safe 
format will be done using the current disk format.

	After having finalized DeviceParameters, the track layout in 
DeviceParameters is initialized, in the loop LoadSectorTable.  Some 
other initialisation is performed here also, such as determining the 
starting sector, and whether we have a 12 or 16-bit FAT.  The total 
number of clusters is also computed.

	After PHASE1, the MIR_MAIN module will be invoked to create 
the recovery file in case /U has not been turned on.  In order to 
accomodate any buffer space needed by the Mirror utility, it is 
necessary to release the space used by the FatSpace buffer.  This 
buffer is originally made big enough to accomodate all the buffer 
requirements of Mirror (this is FAT + Root Dir + Boot Sector + 6 extra 
sectors + 1 surplus sector to allow for arena headers).  The FatSpace 
buffer is re-allocated upon successful return from Mirror.  In case the 
creation of the recovery file failed, the user will be given the option of 
continuing with an unconditional format.

	Phase2Initialisation performs some calculations relating to the 
format to be performed.

	The routine ShowFormatSize is now called to display the size 
of the format to be done.

	Finally, the actual disk formatting is done in module 
DSKFRMT.  The FatSpace buffer is initialised and loaded with the 
media descriptor byte at the start.  The drive parameters are set to 
those of the intended format through a call to SetDeviceParameters, 
using the DeviceParameters parameter block.  For a Quick format, the 
routine QuickFormat is called.  This pseudo-formats the disk by 
copying all bad cluster markers from the old FAT into the new FAT.  
The old FAT is traversed sequentially, and is read in 1 sector at a 
time, into FatSector.

	In the case of a regular format, SwitchMap is first checked to 
see if /U is present.  If it is, the 'Format and Verify Track' operation will 
be performed on each track.  Otherwise only 'Verify Track' will be 
performed.

	The routine Write_Disk_Info writes out the new boot sector, 
root directory and FAT, as well as the system files, if requested.  Great 
care is taken not to over-write any old files if a system transfer is 
being done together with a safe format.  There are four cases which 
must be addressed here.  These are as follows.

		[1]	Unconditional format without system files
		[2]	Unconditional format with system files
		[3]	Safe format without system files
		[4]	Safe format with system files

	Cases [1], [2] and [3] are all handled the same way.  This is as 
follows.  The boot sector is written out, followed by a zeroed root 
directory, and the new FAT (which is zero except for bad cluster 
markers).  If needed, the system files can now be written out.

	Case [4] is handled in a special way, as described below.  The 
boot sector and a zeroed root directory is written out.  The disk is now 
checked to see if there is enough space for the system files.  At this 
point the old FAT on the disk is still there, so the free space cannot 
overlap any allocated clusters.

	If there is insufficient space, the user will be given a warning 
message and prompted whether to perform a system transfer which 
will prevent later recovery, or just not to transfer the system files.  If 
the user chooses to continue with the transfer, then the old FAT will 
first be over-written with the new FAT, and then system files will be 
written out.  If the user chooses not to continue, the new FAT will be 
written out, and system files will not be transferred.

	If there is sufficient space, then it is necessary to ensure that 
IO.SYS (the first system file) is written out to a location on disk so that 
it is contiguous.  This is achieved by calculating the number of 
clusters needed to accomodate a size of 1.5Kbytes (the maximum 
size of IO.SYS).  This value will be between 1 and 3.  The old FAT will 
then be scanned to find a free cluster block of this size, and disk 
allocation will be forced to start from there, using an undocumented 
DPB function.  In case such a cluster block cannot be found (extremely 
unlikely), the user will be given a warning that system transfer will 
destroy disk files and the program will proceed as described above.  
Once the cluster block is found, the system files are now written out to 
disk.  Since the old FAT is still on disk, this method obviates the 
possibility of over-writing old disk files.  After transfer is complete, the 
FAT chains for the three system files will be copied from the old FAT 
into the new FAT.  Note that the root directory entries will automatically 
appear in the new root directory as the system files are written out.  
The new FAT will then be written out to disk, over the old FAT.

	The routine More prompts the user whether another disk is to 
be formatted.  If the user chooses to format another disk, execution 
will resume at SysLoop, where the original state of parameters will be 
restored.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\safefmt.doc ===
SAFEFORMAT

=======================================================================

The following new source files have been added to the format
directory.

      SAFE.ASM    - Additional program source code
      SAFE.INC    - Extrn definitions to be included in other modules
      SAFEDEF.INC - Structure and equates used in SAFE.ASM
      NEWFMT.DOC  - This information and specification file


All changes to the existing format program have been incorporated
within conditionals. The defined value SAFE will determine whether
the new safe format is built. The build the safe format add the
command line switch for the assembler "-DSAFE=1". To disable
creation of the safe format and build the normal format program
change the switch to -DSAFE=0.

=======================================================================

The design specification for the MS-DOS 4.x safe format and unformat
utility is based on the these underlying assumptions.


FORMAT assumptions:

  1.  The utility is version dependent and will alway fail to run
      under versions of DOS (as reported by DOS function 30h)
      other the version it was designed for.

  2.  The utility will only attempt to preserve and restore existing
      DOS 4.x compatible parititions.

  3.  The utililty will incorporate general safty features but will
      rely on the integrety of the underlying operating system for
      detecting error conditions while accessing the hard disk.

  4.  There will be no attempt to allow restoration of a partition
      which was recognized as being damaged before the format
      operation had begun.

  5.  If for any reason the restoration files cannot be created
      the user will notified and allowed to decide if the format
      should continue without the restoration ability. There is
      one exception to this assumption and that is the case where
      a partition is detected to be unformated as described later.

  6.  The default operation during format will be to create the
      restoration file. A command line switch will allow the user
      to disable the feature.

  7.  All disk access will be done via DOS file handles and interrupts
      25h and 26h to allow DOS to detect and return any error
      conditions.

  8.  Only the first copy of the FAT will be saved. If any sectors
      in the first copy of the FAT cannot be successfully read
      using int 25h, an attempt will be made to read the corresponding
      sectors from the second copy of the FAT. Only if the
      corresponding sectors in both copies of the FAT cannot be read
      will it be assumed the the FAT is bad and a restoration file
      cannot be created.

  9.  The restoration file must contain all information neccessary
      to allow the restoration program to restore the original
      partition immediately after a format. If the original partition
      was a boot partition it must be restored so that it will boot
      the original operating system which was present before the
      format operation.

  10. The system files will consist of the either of the following
      2 groups of files plus COMMAND.COM.
      (IO.SYS and MSDOS.SYS) or (IBMBIO.SYS and IBMDOS.SYS)

  11. It will be assumed that a partition has never been formatted
      if the boot record is not valid using the conditions that the
      last 2 bytes of a boot sector contain a boot signature and
      the first byte is near or short jump opcode. When a partition
      has never been formatted a restoration file will not be
      created. There will be no need to alert the user to this action
      and formating will proceed as it does with the existing DOS 4.x
      utility.

  12. The restoration file will be created in the root directory
      before formating begins and this directory entry will be
      restored to the root directory as the 4th entry in the new
      root directory with an E5h placed in the first byte of the
      first 3 directory entries to allow room for operating system
      files. The restoration file will use the name "UNFORMAT.DAT"
      and will be created with HIDDEN, SYSTEM and READONLY
      attributes set.

  13. Any previous restoration file will be deleted at the time
      a new restoration file is created.

      WARNING: This will mean that if a user reformats a hard
      disk immediately after a previous format, the original
      contents of the hard disk will be lost.

  14. The restoration file will be designed so that it can allow
      restoration of the hard disk reguardless of the condition of
      boot sector, FAT or root directory after completion of the
      format operation. This feature is only for possible future
      enhancements and in this implementation there will be no
      attempt to restore a hard disk if the restoration file
      cannot be successfully read from the disk using the normal
      DOS file and sector read and write operations.

  15. The FAT which is written to the restoration file will also
      contain the FAT allocation chain for the restoration file.

  16. The DOS control C check will be disabled while the system areas
      of the disk are being written to help minimize the chance of
      losing the restoration file's directory entry and FAT chain.

      NOTE:
      The user will still be allowed to CTRL C out of the format at
      any time previous to this without damaging the integrity of
      the existing partition other than the deletion of any
      previously existing restoration file. 

  17. There will be 2 checksums in the restoration file header. One
      will be a checksum of the sector containing the file header
      and the other will be a checksum of the entire restoration
      file. The file header checksum will be used to confirm the
      file header is the valid starting sector of a restoration
      file and the file checksum will be used to insure the
      integrety of entire restoration file before a restoration
      is done.

  18. The information contained in the restoration file is intended
      to only allow the restoration of a hard disk partition if the
      UNFORMAT utility is used before any new files are written to
      the partition after a format operation. If any new files are
      written the partition is formatted it will void the integrety
      of the original FAT and the partition will be corrupt.

  19. The FORMAT utility must allow restoration of the original
      partition even in the event that the /S option is used to
      install a new operating system on the partition. This will
      be accomplished by assuring that the new OS does not
      overwrite any existing allocated areas other than the first
      2 clusters of the disk which have been saved in the restoration
      file.

  20. The fatal disk error handler will be changed so that IGNORE is
      not an option for handling of fatal disk errors. Only RETRY,
      FAIL and ABORT will be valid options.

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\readme.txt ===
MS-DOS 6 National Language Support Update - Supplement to the OAK
-----------------------------------------------------------------

The following files where included on the MS-DOS 6 Supplemental disk
as updated or alternate files for adding additional language support
for MS-DOS:

EGA.CPI
KEYB.COM
KEYBOARD.SYS

The following directories contain the source for those files:

oak\cmd\keyb\keyb2
oak\dev\keyboard\kbd2
oak\dev\display\ega2

The MAKEFILEs for these tools will not be called during a complete
build of the OAK unless the parent makefiles are modified to visit
these new directories.  These makefiles will deposit the completed
file in the BINARIES and COMPRESS directories of the OAK under the
following names:

KEYBOARD.SYS - KEYBRD2.SYS / KEYBRD2.SY_
KEYB.COM     - KEYB2.COM / KEYB2.CO_
EGA.CPI      - EGA2.CPI / EGA2.CP_

The batch file that moves these files from the OAK to the ODK in
preparation for product disk image creation will also need to be
modified.


The changes to these files are outlined below:

EGA.CPI
-------
Corrects Cyrillic display.

Note:   The EGA.CPI file built from these updated sources is suitable
as a replacement for the EGA.CPI file included in MS-DOS. The EGA.ICE
found on the MS-DOS 6 product diskettes is still required if
Icelandic support is used.


KEYB.COM
--------
Support for Canadian switchable keyboard.

Note:  This KEYB.COM is suitable as a replacement for the one
in MS-DOS. The changes to this file are for the dual layout
French-Canadian keyboard, but all other functionality remains the
same.


KEYBOARD.SYS
------------
 1)  Added keybard support for:
   - CF Canadian standard CAN/CSA-Z243.200-92
   - BR secondary Brazilian standard keyboard
       (supports keyboard IDs 274 and 275,
        with 274 as default)
   - RO Romania

 2)  Changed:
   - GR German shift lock behavior of top row:
        now remains unaffected, functionally the same as US
        (ie, "Typewriter mode" has been removed.)

Note:  The supplemental disk KEYBOARD.SYS is NOT a replacement for
the existing KEYBOARD.SYS. It is best decribed as an 'alternate' file
since it includes Icelandic, Brazillian, Romainian, and dual
French-Canadian keyboards, but is missing the following support:

  Swiss German     (keyb sg)
  Swiss French     (keyb sf)
  Japan            (keyb jp)

In addition, the following keyboards are now accessible by Letter
only (previously could be accessed by both letter and number):  Pl,
Cz, Sl, Yu, Hu.  The removal of the above support was due to size
limitations.

Additional Notes for Icelandic support:  The COUNTRY.ICE and
KEYBOARD.ICE files for Icelandic are superceded by the COUNTRY.SYS
and the KEYBOARD.SYS files on the new supplemental disk, but the
EGA.ICE file will still be required for Icelandic code page support.
EGA.CPI is sufficient for all other supported languages.



Source file differences
-----------------------
Below is a summary of the files that changed between the original
OAK source files and the updates included in this supplement.  Note
that all source files for each utility are included, even if they are
unchanged. 


CMD\KEYB\KEYB2
--------------
The following file has been added:
KEYBSHAR.INC - normally in OAK\INC directory

The following source files have been changed:
KEYBCMD.ASM
KEYBI9.ASM
KEYBI9.INC
KEYBI9C.ASM
KEYBI9C.INC
MAKEFILE


DEV\KEYBOARD\KBD2
-----------------
The following files have been added:
KEYBSHAR.INC - normally in OAK\INC directory
KDFBR2.ASM
KDFCP.ASM
KDFIC.ASM
KDFRO.ASM

The following source files have been changed:
KDFCF.ASM
KDFGE.ASM
KDFNOW.ASM
KEYBMAC.INC
KEYBOARD.LNK
MAKEFILE


DEV\DISPLAY\EGA2
----------------
The following source files have been changed:
852-8X14.ASM
852-8X16.ASM
852-8X8.ASM
MAKEFILE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\setver\setver.doc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


                        SETVER Command overview
			MS-DOS 6.00
			05/13/90

SETVER is an external MS-DOS command which allows the user to
determine the MS-DOS version number will be reported by MS-DOS
to a specified user application. This will allow applications
which check for a specific version of MS-DOS to run under
MS-DOS 6.0.

A version table has been included as part of the MS-DOS system
files on the user's boot disk. SETVER will update the system
files so that next time and times thereafter, that MS-DOS is
booted, the updated version table will be in effect. NOTE: The
changes to the version table will not take effect until the
user reboots using the updated version of the table.


NOTE:
	Currently there is 512 bytes set aside for entries in the
	table but Ericst may want to up it in the near future so
	for right now I wouldn't mention the number of entries
	which the table will hold. Right now it will hold a minimum
	of 34 entries.

==========================================================================

USEAGE:
		List table:	SETVER [D:]
		Add entry:	SETVER [D:] name.ext N.NN
		Delete entry:	SETVER [D:] name.ext /DELETE
		Display help	SETVER /?

WHERE:
		D: is the drive containing MSDOS.SYS
		name.ext is the executable file name
		N.NN is the major and minor version numbers
		/DELETE is any combination of /D - /DELETE

==========================================================================

MESSAGES:

	If the table is being updated and there are no errors detected
	this message will be displayed.

	"Version table successfully updated"

	If the version table is only being displayed it will listed
	on the screen in the format:

	WIN200.BIN     3.30
	EXCEL.EXE      4.01
	MYPROG.EXE     3.20
	DELNODE.EXE    4.01
	

==========================================================================

EXAMPLE 1:

	SETVER a: excel.exe 4.01

	This example will add a new entry in the table for EXCEL.EXE
	to the version table on drive A: and will tell DOS to always
	report the MS-DOS version number 4.01 to this application.

EXAMPLE 2:

	SETVER	a: excel.exe /DELETE

	This example will delete the EXCEL.EXE entry from the version
	table on drive A:.

EXAMPLE 3:

	SETVER

	This example will list the contents of the version table
	on the current drive.

EXAMPLE 4:

	SETVER /?

	This example will cause the SETVER command to display
	help in using the command.

==========================================================================

RETURN CODES:
	0  Successful completion
	1  Invalid command switch
	2  Invalid file name specified
	3  Insuffient memory
	4  Invalid version number format
	5  Specified entry was not found in table
	6  MS-DOS system files not found
	7  Invalid drive specifier
	8  Too many command line parameters
	9  Missing parameters
	10 Error reading MS-DOS system files
	11 Version table is corrupt in system files
	12 Specifed MS-DOS system files do not support a version table
	13 Insuffient space in version table for new entry
	14 Error writing MS-DOS system files


==========================================================================

ERROR MESSAGES:

ERROR:  Invalid switch

	The user specified an invalid command line switch.

ERROR:  Invalid file name

	The user specified an invalid file name for a new
        version table entry. Possible causes are the specified
        file name did not follow standard MS-DOS file naming
	conventions or was a reserved MS-DOS file name

ERROR:  Insuffient memory

	There is insuffient memory for the program to run.

ERROR:  Invalid version number format must be 2.11 - 9.99

	An invalid version number was specified. Possible causes
	of this are that the specified version number was not in
	the proper format or it was less than 2.11 or greater than
	9.99.

ERROR:  Specified entry was not found in the version table

	The tried to delete an entry which was not in the existing
	version table.

ERROR:  File MSDOS.SYS not found on specified drive

	The user specified a drive which does not contain MS-DOS
	system files.

ERROR:  Invalid drive specifier

	The user specified a drive that does not exist.

ERROR:  Too many command line parameters

	The user specifed too many command line parameters such as
	by specifing both a version number and the /DELETE switch.

ERROR:  Missing parameter

	The user entered a file name but forgot to include either
	a version number or the /DELETE switch.

ERROR:  Reading MS-DOS system file

	There was an error trying to read the system files on the
	specified drive. Possible cause is that the specified drive
	does not contain system files.

ERROR:  Version table is corrupt

	An error was detected in the version table and it is not
	useable. The user should replace the system files on that
	disk and try again.

ERROR:	System files on the specifed drive do not support a version table

	The user specified a drive which contains MS-DOS system files
	which at not version 6.0 or above.

ERROR:  Insuffient space in version table for new entry

	The version table on the specified drive is full. The user can
	delete some entries from the table and try again.
	NOTE:	To be sure of room for the new entry the user should be
		sure that the entry that is deleted has a file name
		at least as long as the new entry.

ERROR:  Writing MS-DOS system file
	
	There was an error while trying to write the updated version
	version table. This would be caused by a bad disk.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\display\ega2\readme.txt ===
MS-DOS 6 National Language Support Update - Supplement to the OAK
-----------------------------------------------------------------

The following files where included on the MS-DOS 6 Supplemental disk
as updated or alternate files for adding additional language support
for MS-DOS:

EGA.CPI
KEYB.COM
KEYBOARD.SYS

The following directories contain the source for those files:

oak\cmd\keyb\keyb2
oak\dev\keyboard\kbd2
oak\dev\display\ega2

The MAKEFILEs for these tools will not be called during a complete
build of the OAK unless the parent makefiles are modified to visit
these new directories.  These makefiles will deposit the completed
file in the BINARIES and COMPRESS directories of the OAK under the
following names:

KEYBOARD.SYS - KEYBRD2.SYS / KEYBRD2.SY_
KEYB.COM     - KEYB2.COM / KEYB2.CO_
EGA.CPI      - EGA2.CPI / EGA2.CP_

The batch file that moves these files from the OAK to the ODK in
preparation for product disk image creation will also need to be
modified.


The changes to these files are outlined below:

EGA.CPI
-------
Corrects Cyrillic display.

Note:   The EGA.CPI file built from these updated sources is suitable
as a replacement for the EGA.CPI file included in MS-DOS. The EGA.ICE
found on the MS-DOS 6 product diskettes is still required if
Icelandic support is used.


KEYB.COM
--------
Support for Canadian switchable keyboard.

Note:  This KEYB.COM is suitable as a replacement for the one
in MS-DOS. The changes to this file are for the dual layout
French-Canadian keyboard, but all other functionality remains the
same.


KEYBOARD.SYS
------------
 1)  Added keybard support for:
   - CF Canadian standard CAN/CSA-Z243.200-92
   - BR secondary Brazilian standard keyboard
       (supports keyboard IDs 274 and 275,
        with 274 as default)
   - RO Romania

 2)  Changed:
   - GR German shift lock behavior of top row:
        now remains unaffected, functionally the same as US
        (ie, "Typewriter mode" has been removed.)

Note:  The supplemental disk KEYBOARD.SYS is NOT a replacement for
the existing KEYBOARD.SYS. It is best decribed as an 'alternate' file
since it includes Icelandic, Brazillian, Romainian, and dual
French-Canadian keyboards, but is missing the following support:

  Swiss German     (keyb sg)
  Swiss French     (keyb sf)
  Japan            (keyb jp)

In addition, the following keyboards are now accessible by Letter
only (previously could be accessed by both letter and number):  Pl,
Cz, Sl, Yu, Hu.  The removal of the above support was due to size
limitations.

Additional Notes for Icelandic support:  The COUNTRY.ICE and
KEYBOARD.ICE files for Icelandic are superceded by the COUNTRY.SYS
and the KEYBOARD.SYS files on the new supplemental disk, but the
EGA.ICE file will still be required for Icelandic code page support.
EGA.CPI is sufficient for all other supported languages.



Source file differences
-----------------------
Below is a summary of the files that changed between the original
OAK source files and the updates included in this supplement.  Note
that all source files for each utility are included, even if they are
unchanged. 


CMD\KEYB\KEYB2
--------------
The following file has been added:
KEYBSHAR.INC - normally in OAK\INC directory

The following source files have been changed:
KEYBCMD.ASM
KEYBI9.ASM
KEYBI9.INC
KEYBI9C.ASM
KEYBI9C.INC
MAKEFILE


DEV\KEYBOARD\KBD2
-----------------
The following files have been added:
KEYBSHAR.INC - normally in OAK\INC directory
KDFBR2.ASM
KDFCP.ASM
KDFIC.ASM
KDFRO.ASM

The following source files have been changed:
KDFCF.ASM
KDFGE.ASM
KDFNOW.ASM
KEYBMAC.INC
KEYBOARD.LNK
MAKEFILE


DEV\DISPLAY\EGA2
----------------
The following source files have been changed:
852-8X14.ASM
852-8X16.ASM
852-8X8.ASM
MAKEFILE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\lhvxd\readme.txt ===
SUBDIR	       		WHAT IT CONTAINS
------	       		----------------
STUB		 (1)	SRC for LHITST.ASM a dummy stub which
	       		traps the WIN386 startup call and 
	       	        loads the VXD (LOADHI.EXE). As an
	       		example it allocates a hunk of XMS
	       		memory and pretends that there are
	       		16 UMB pages starting at 0C800:0

		 (2)    MAKESTUB.BAT
			This assembles and links the test stub
			and copies over the exe to the root.
	       		
	       		The Limulator should take the place
	       		of this dumb stub.

                 (3)    INT2FAPI.INC -- stub code include file


SRC		 (1)	SRC for UMB.ASM. This file provides 
	       		the interface between the Limulator
	       		and the VXD and is a part of the VXD.
	       		
	       		Change this file to match the
	       		the Limulators interface.

                  (2)   SRC for COPYINST.ASM. This file has a routine
			that is not a part of the VxD itself,
			however, this routine should be called by the
			LIMulator at "virtual-disable" time to
			extract and copy out UMB related instance data 
		        information from the Windows/386 3.00 initialization
			data structure into a table inside the UMB.
			The address of this table is later supplied
			to the VxD via one of the routines in UMB.ASM 

	       	  (3)	LOADHI.DEF
	       		Change the STUB statement in this
	       		file appropriately (should be the
	       		LIMulator EXE)

		  (4)   MAKEUMB.BAT assembles UMB.ASM and copies the
			obj over to the RETOBJ & DBGOBJ directories
			(the sample UMB.ASM does not have any debug
			 code).

INCLUDE           (1)   VMM.INC needed to build UMB.ASM

RETOBJ		  Retail version of the fixed obj files.
		
		  (1)	LOADHI.OBJ, INSTINIT.OBJ, INSTSWAP.OBJ
			These are precompiled retail OBJs used during link

		  (2)   UMB.OBJ will be copied over here after 
			assembling UMB.ASM in the SRC subdir

DBGOBJ		  Debug version of the fixed OBJ files.

		  (1)	LOADHI.OBJ, INSTINIT.OBJ, INSTSWAP.OBJ
			These are precompiled debug OBJs used during link

		  (2)   UMB.OBJ will be copied over here after 
			assembling UMB.ASM in the SRC subdir
	
TOOLS			MASM5.EXE, LINK5.EXE, LINK386.EXE, ADDHDR.EXE
			
			These are all the tools that will be needed
			to build the VXD.


ROOT directory		WHAT IT CONTAINS
--------------		----------------

		  (1)	LOADHID.LNK	--  used in linking debug VXD
		  (2)	LOADHIR.LNK	--  used in linking retail VXD
		  (3)   MAKEVXDD.BAT	--  builds the debug VXD.
		  (4)   MAKEVXDR.BAT	--  builds the retail VXD.
                  (5)   README.TXT      --  this readme file


STEPS:

	(1) go to the STUB directory and run MAKESTUB.BAT

	    LHITST.EXE would be built and copied over to the root.

        (2) go to the SRC directory and run MAKEUMB.BAT
	
	    UMB.OBJ would be built and copied over to the OBJ dir

        (3) go to the root and run MAKEVXDD.BAT	or MAKEVXDR.BAT
	    to build the debug or retail versions respectively.

	    builds LOADHI.EXE which is the STUB combimed with the
	    VXD


NOTE:

	(1) If your LIMulator device drivers has an .EXE format:

	    LHITST.EXE is a dummy stub. In the final product, your
	    LIMulator EXE file would be the stub. The VxD would be
	    appended as an extended part in the .EXE file.

            In this case, you will end up having only one file which
	    will hold both the LIMulator device driver as well as the
	    LoadHi VxD

        (2) If your LIMulator device driver is a .COM format file

	    In this case, the VxD and the device driver cannot be 
	    clubbed together. You will have to modify the .DEF file
	    to take away the 'stub' statement and modify the
	    MAKEVXD?.BAT file to avoid doing the 'ADDHDR' part.

            You end up having a separate VxD file. However, at
	    Windows load time it is the responsibility of the
	    LIMulator VxD to provide the complete path name of the
	    LoadHi VxD file.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\lhvxd\loadhi.doc ===
1           _4  m } }    NORMAL.STY                                                          HPLASER  @ A  ~ }    
					LoadHi VxD

The portion of DOS memory above 640KB (linear address 0A0000h) is normally used by varios hardware devices like video memory, network adapters and so on. These adapters provide their own memory blocks which are then addressed in the range from 0A0000h to 1MB. However, large chunks in this address range might not have any memory at all. On a typical configuration you may have even upto 128 Kb worth of address space which is like a 'hole' with no memory being present.

The LIMulators, being protected mode programs, can use hardware paging option on a 80386 or higher processor to map in extended memory pages into the above address ranges which are without any physical memory. The blocks of memory, which are now addressible because the LIMualtor has mapped in some extended memory, are known as Upper Memory Blocks or UMBs.

Once the UMBs have been mapped in, they can be treated as conventional memory and programs may be loaded in them. There are two ways by which a program can get loaded in an UMB. These are:

(1) Some of the LIMulators like QEMM and 386Max have their own LoadHi utilities to load programs in the UMBs that they provide.

(2) MS-DOS 5.0 now links in UMBs into the DOS memory arena chain and device drivers, TSRs and normal programs can be loaded into the UMBs with DOS commands.

Windows 3.0, however, does not deal with UMBs very well. When Windows starts up, there may be programs already loaded in the UMBs which will have data areas to be instanced when Windows runs multiple VMs. The Virtual Memory Manager (VMM) in Windows 3.0 will not deal correctly with Instance Data request which specify instance areas above 0A0000h.

To make Windows 3.0 work with programs loaded in UMBs, LIMulators need to provide a VxD at Windows load time which will take over the management of instance data areas in UMBs on behalf of the Windows 3.0 VMM. This VxD, henceforth referred to as the LoadHi VxD, is partly developed by Microsoft. The LIMulators are expected to fill in a module which is LIMulator specific and ship the VxD with their LIMulator. Microsoft will provide them with Object files for the modules in the VxD that are specific to Windows alone and also tools to compile the LIMulator specific module and to link together all the modules to build the VxD.

Seamless integration of the LIMulator and the VxD:

LIMulators, that have an EXE load format, can combine the LoadHi VxD with the LIMulator EXE itself. The VxD would be appended to the LIMulator EXE file as an extended EXE portion. In this case, users will not have to worry about the VxD at all. This is the option that Microsoft encourages the vendors to adopt and provides tools to build the extended EXE Limulator file from the basic LIMulator EXE and the LoadHi VXD. However, LIMulators that have a binary load format will still have to ship the LoadHi VxD separately and would have to figure out the path name to access the VxD when Windows starts up.

Windows and the EMM import process:

The LIMulator has to deactivate itself when Windows starts up. Windows, itself being a protected mode program, will not load if the LIMulator is still in protected mode. To take care of this, Windows and the LIMulator follow the following protocol:

(1) When Windows 3.0 starts up in Enhanced Mode, it makes an INT 2FH broadcast. The boradcast has a multiplex code of 1605H in AX and the details of this call can be found in the "Virtual Device Adaptation Guide" which is a part of the Windows 3.0 DDK.

(2) The LIMulator hooks on to the above broadcast and should setup ES:BX to point to a block of memory having the structure defined by the 'WIN386_Startup_Info_Structure' structure. Specifically, the 'SIS_Virt_Dev_File_Ptr field in the above structure should have a completely qualified name of the LoadHi VxD. In the case where the VxD is combined with the LIMulator itself, the path name should refer to the LIMulator EXE itself and Windows would automatically load the VxD from the extended part of the EXE.

The LIMulator can also specify instance data areas at this point, via the 'SIS_Instanec_Data_Ptr' field and this could include instance data areas in the UMBs.

The 'SIS_Reference_Data' field should return a pointer to block of information which the LIMulator specific module in the LoadHi VxD will understand and maintain. The information contained in this block is described later.

The LIMulator should also specify the address of their virtual 8086 mode enable/disable routine, which will be called later by Windows 3.0 when it is time for it to take over the EMM management from the LIMulator. 

(3) Finally, Windows 3.0 will call the virtual 8086 enable/disable routine in the LIMulator to disable itself and hand over the EMM import information to Windows. In addition of doing this, the LIMulator will also have to do one additional piece of processing.

When Windows makes the virtual disable call, it has in it's data segment a list of memory areas to be instanced that was specified by the real mode portion of other VxDs. This list may contain areas in UMBs. The LIMulator must scan this list to extract all the instance requests that are for UMB areas and copy it over into the block of memory that the LIMulator specific module in the LoadHi VxD would maintain. The code to do this processing will be provided my Microsoft and should be included into the LIMulator (and not the VxD).




Brief description of the VxD:

The LoadHi VxD has a control entry point like all other VxDs. This entry point is called by WIN386 to let the VxD initialize itself and to let it know about various system events like a VM starting up, VM being suspended etc. The LoadHi VxD initializes pretty early and hooks three VMM and DOSMGR  services. These are:

(a) Add_Instance_Item:

It hooks this serveice to watch for all 'Add_Instance_Item' requests. It then tests to see whether the area to be instanced is in a UMB or not. If it is not in a UMB, the reqeust is chained on to the normal handler in the VMM which will then take care of the request. Instance requests which are in UMBs are intercepted by the VxD and managed by it. The original handler in the VMM never gets to see these requests.

(b) DOSMGR_Instance_Device:

A device driver can be instanced by calling this service. The LoadHi device once again will intercept only those calls that are for devices loaded in UMBs. It fill then figure out the starting address of the device and its length and internally generate a 'Add_Instance_Item' request to instance the device.

Sizing a device is a very tricky issue and has to be carefully addressed. The code which does this is in the LIMulator specific part of the VxD as it also has to deal with devices that were loaded by the LIMulator itself. The sample code that Microsoft provides, show how to size devices loaded by MS-DOS 4.0 and higher. This will have to be modified to size devices loaded by the LIMulator.

(c) TestGlobalV86Mem:

Apart from the areas in the UMBs that are being instanced, all other areas are always globally present in the context of all VMs.

Most of the code to do the above functions are independent of how the LIMulator fuctions or where the UMBs are located and is developed by Microsoft. Microsoft provides the object modules for these code and the three object modules that are provided to the vendors, LOADHI.OBJ, INSTINIT.OBJ and INSTSWAP.OBJ, constitute the fixed part of the VxD. 

However, the UMBs themselves where created by the LIMulator and the VxD has to know the details about these blocks. This information is LIMulator dependent. The fixed part of the VxD obtains these information by callin predefined functions which are contained in the LIMulator specific part of the VxD. The names of these routines with the Entry and Exit parameters specified can be found in the sample source file UMB.ASM. This file also has sample code to show how the functions work. These functions basically work on a block of information, the address of which was specified by the LIMulator when Windows made the start up INT 2FH broadcast (The variable 'SIS_Virt_Dev_Ptr' in the WIN386_Startup_Info_Struc is where the address of this block was passed in). It is important to note that only the name and the ENTRY, EXIT and REGISTER USAGE parameters are important. The vendor may want to maintain the information in a manner that's appropriate for him.

Information that the LIMulator specific module must maintain:

The LIMulator specific part of the VxD must know about the following information:

(a) The first UMB page. A page is a 4 Kb block of memory, and pages are numberd starting at physical address 0. Thus linear address 0A0000H (0A000:00h) is physical page 0A0h.

(b) The number of pages, starting with the number designating the first UMB pages, that may be UMB pages. Note, there will be some pages that will belong to hardware adapters and the UMB pages may not always be contiguous in physical memory.

(c) The page in extended memory that is mapped in for each UMB. Please note, the pages where mapped in by the LIMulator. This mapping was later invalidated when the LIMulator disabled itself. However, it is important to remember the earlier mapping. The VxD will restore this mapping.

As mentioned earlier, the vendor may choose to maintain the above block of information in any appropriate manner. The sample code maintains the information as an array of DWORDS. This is documented in the file UMB.ASM

(d) A pointer to the list of Instance data areas that was extracted from within a Windows segment by the LIMulator. The code to do the extraction is contained in the file COPYINST.ASM and should be built into the LIMulator. Note, the list extraction does not occur till the virtual disable call is actually made. However, a pointer to the information that the LIMulator specific part of the VxD needs is passed in by the LIMulator much earlier, at Windows start up time. It is Ok, to include a pointer to the block of memory, which will eventually hold the additional instance data list, at Windows start up time and actually fill up the information and virtual disable time.

(e) A pointer to the start of the device header chain in DOS. This chain will have to be traversed to size devices. It is adavantageous to have this pointer passed in from the LIMulator.

Procedures in the LIMulator specific part of the VxD:

This section describes the functions that are contained in the file UMB.ASM. The entry and exit parameters are all documented in the file. 

(1) Real_Mode_Hook:

This routine is called from the Real_Mode_Init routine of the VxD and lets the LIMulator specific part of the VxD do it's own real mode initializations. The sample code does nothing much in this procedure.

Note, this routine is contined in the VxD_REAL_INIT_SEG segment

(2) Get_UMB_Info:

This routine is called to get information about the first UMB page number and the number of consecutive pages that may have UMBs in them.
The entry to this routine has in EDX the pointer to the block of information described above.

(3) Get_Device_Info:

This routine is called to get information about a device which may or may not be loaded in an UMB. A pointer to the device name is passed in on input and the procedure should return with carry set if the device has not been loaded in a UMB (or cannot be sized). If the device is loaded in a UMB, the procedure must return it's starting linear address and the length of the device.

(4) Get_Ptr_To_Instance_Data_List:

Returns a linear pointer to the list of additinal instance data information that was extracted from within Windows and built by the LIMulator (code to do the extraction is in COPYINST.ASM)

(5) Control_Call_Hook:

This routine is called from the main entry point in the VxD and will thus be called for every control call that is made into the VxD. This hook has been provided to let the LIMulator specif part of the VxD to do additional processing on any control call. The idea is that the vendor may want to add more functionality to the VxD.

The sample code for this routine simply returns without doing anything.

(6) Get_Mapped_Page_Num:

This procedure is called to get the mapping page number, in extended memory, for a UMB page frame in conventional memory. The page number on entry may not be a UMB page at all, and in this case the function whould retrun a 0. 

Please note, some of the above functions are called only during initialization and must be included in VxD_ICODE_SEG segment. The procedures in UMB.ASM should be retained in the sgments that are currently in. For any new code that the vendor add, he will have to figure out what segment the code goes into. 

Example Stub:

Microsoft provides the source for an example stub program to show how the Window start up broadcast is to be trapped. It should be remembered that, all that the stub does would actually be done in the LIMulator and, in the actual VxD, the LIMulator must replace the example stub. 

Building the VxD:

A README.TXT file is provided with the distribution diskette to list down the steps needed to build the VxD.














܀         v 	  	  q *  Q  l   j   e 9  c O  ^   \   W   U               v !  t !  o 5)  m n)  h )  f *  a (+  _ 9+  Z ),  X =,  S -  Q   U             -  -  v .  t .  o Y0  m q0  h 2  f 2  a 2  ^ 3  \ 3  W P4  U R4  P T4  N              T4  V4  v Z4  t _4  Y0  m q0  h 2  f 2  a 2  ^ 3  \ 3  W P4  U R4  P T4  N                          m  x o  x   x   x   x   x  `T  `T  `T  `T  `T  `T  `T  `T  `T     <	    r   r   r   o   o   o 	  o 	  o 	  o  `T  `T  `T  `T  `T  `T  	`T  `T  `T  <<   @		  	  x (  x *  x O  x Q  x K  x M  x K  o M  o  `T        `T  `T  `T  `T  `T  `T  `T  <   @<	M  M  r O  r   r   r   r   r   r   r   r        `T  `T  `T  `T  `T  `T  `T  `T  <<   @	    r   r   r   r   r   r   o   o 7  o  `T  `T  `T  `T  `T  `T  `T  `T  `T  <<   @	7  9  x Q  o S  o   o   o   o   o J  o L  o  `T  `T  `T  `T  `T  `T  `T  `T  `T  <   @<	L    r   r   r   r s  r u  r   o   o !  o  `T  `T  `T  `T  `T  `T  `T  `T        <<   @	!  !  x !  x !  x *"  x ,"  x "  o "  o #  o #  o  `T  `T  `T  `T  `T  `T  `T  `T  `T  <   @<	#  $  r $  r %  o %  f u(  f w(  f 3)  f 5)  c  `T  `T  `T  `T  
`T  `T  `T  `T  `<<   @<<   @5)  l)  x n)  x )  x )  x *  o *  o *  o *  o &+  o  `T  `T  `T  `T  `T  `T  `T  `T  `T  @<   @<	&+  (+  r ;+  r =+  r +  r ',  r ),  r ?,  r A,  r -  r  `T  `T  `T  `T  `T  `T  `T  `T  `T  @<<   @	-  -  r -  r -  r .  r .  r .  r .  r 0  r 0  r  `T  `T  `T  `T  `T  `T  `T  `T  `T  @<<   @	0  W0  r Y0  r s0  r u0  r Y1  r [1  o 2  o 2  o 2  o  `T  `T  `T  `T  `T  `T  `T  `T  `T  @<<   @	2  2  x 3  x 3  x 3  x 3  x B4  x D4  x F4  o H4  l  `T  `T  `T  `T  `T  `T  `T  `T  `T <<   @<	H4  J4  x L4  o N4  o P4  o R4  l T4  l V4  l X4  l Z4  l  `T  `T  `T  `T  `T  `T  `T  `T  `T <<   @<	Z4  \4  x ^4  x _4  `4   `T                   Z4  l  `T  `T  `T  `T  `T  `T  `T  `T  `T <<   @<=/20* 
     G  T  4   e*  ?3  3      a               A              3   >  3   + ; > E q u }  LoadHi VxD documentation Amit Chatterjee AC LoadHi Documentation for PSS's support of this VxD 3.0 11/15/9011/15/903  
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kbd2\readme.txt ===
MS-DOS 6 National Language Support Update - Supplement to the OAK
-----------------------------------------------------------------

The following files where included on the MS-DOS 6 Supplemental disk
as updated or alternate files for adding additional language support
for MS-DOS:

EGA.CPI
KEYB.COM
KEYBOARD.SYS

The following directories contain the source for those files:

oak\cmd\keyb\keyb2
oak\dev\keyboard\kbd2
oak\dev\display\ega2

The MAKEFILEs for these tools will not be called during a complete
build of the OAK unless the parent makefiles are modified to visit
these new directories.  These makefiles will deposit the completed
file in the BINARIES and COMPRESS directories of the OAK under the
following names:

KEYBOARD.SYS - KEYBRD2.SYS / KEYBRD2.SY_
KEYB.COM     - KEYB2.COM / KEYB2.CO_
EGA.CPI      - EGA2.CPI / EGA2.CP_

The batch file that moves these files from the OAK to the ODK in
preparation for product disk image creation will also need to be
modified.


The changes to these files are outlined below:

EGA.CPI
-------
Corrects Cyrillic display.

Note:   The EGA.CPI file built from these updated sources is suitable
as a replacement for the EGA.CPI file included in MS-DOS. The EGA.ICE
found on the MS-DOS 6 product diskettes is still required if
Icelandic support is used.


KEYB.COM
--------
Support for Canadian switchable keyboard.

Note:  This KEYB.COM is suitable as a replacement for the one
in MS-DOS. The changes to this file are for the dual layout
French-Canadian keyboard, but all other functionality remains the
same.


KEYBOARD.SYS
------------
 1)  Added keybard support for:
   - CF Canadian standard CAN/CSA-Z243.200-92
   - BR secondary Brazilian standard keyboard
       (supports keyboard IDs 274 and 275,
        with 274 as default)
   - RO Romania

 2)  Changed:
   - GR German shift lock behavior of top row:
        now remains unaffected, functionally the same as US
        (ie, "Typewriter mode" has been removed.)

Note:  The supplemental disk KEYBOARD.SYS is NOT a replacement for
the existing KEYBOARD.SYS. It is best decribed as an 'alternate' file
since it includes Icelandic, Brazillian, Romainian, and dual
French-Canadian keyboards, but is missing the following support:

  Swiss German     (keyb sg)
  Swiss French     (keyb sf)
  Japan            (keyb jp)

In addition, the following keyboards are now accessible by Letter
only (previously could be accessed by both letter and number):  Pl,
Cz, Sl, Yu, Hu.  The removal of the above support was due to size
limitations.

Additional Notes for Icelandic support:  The COUNTRY.ICE and
KEYBOARD.ICE files for Icelandic are superceded by the COUNTRY.SYS
and the KEYBOARD.SYS files on the new supplemental disk, but the
EGA.ICE file will still be required for Icelandic code page support.
EGA.CPI is sufficient for all other supported languages.



Source file differences
-----------------------
Below is a summary of the files that changed between the original
OAK source files and the updates included in this supplement.  Note
that all source files for each utility are included, even if they are
unchanged. 


CMD\KEYB\KEYB2
--------------
The following file has been added:
KEYBSHAR.INC - normally in OAK\INC directory

The following source files have been changed:
KEYBCMD.ASM
KEYBI9.ASM
KEYBI9.INC
KEYBI9C.ASM
KEYBI9C.INC
MAKEFILE


DEV\KEYBOARD\KBD2
-----------------
The following files have been added:
KEYBSHAR.INC - normally in OAK\INC directory
KDFBR2.ASM
KDFCP.ASM
KDFIC.ASM
KDFRO.ASM

The following source files have been changed:
KDFCF.ASM
KDFGE.ASM
KDFNOW.ASM
KEYBMAC.INC
KEYBOARD.LNK
MAKEFILE


DEV\DISPLAY\EGA2
----------------
The following source files have been changed:
852-8X14.ASM
852-8X16.ASM
852-8X8.ASM
MAKEFILE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\bambi.doc ===
Being a document on the workings of WinCache.



The following is a brief summary of what can be found in various modules.

umbload.asm 	-- code which automagically loads the TSR into a UMB
bambinit.asm 	-- initialization code which initialized data stuctures/hooks
bambi.asm	-- device driver hooks main entry points. core of program
hooks.asm	-- contains interrupt hooks for 8,9,10,13,15,19,28, also write
		   behind entry point
hooksini.asm	-- initialization code for hooks.asm
dirtywrt.asm	-- core code for write_behind
queueman.asm	-- code which maintains the lru and cache structure
queueini.asm    -- initialization code for queueman.asm
cacheman.asm	-- code which manages queueman's interface to xms
cacheini.asm	-- initialization code for cacheman.asm
xms.asm		-- xms interface code
xmsini.asm	-- initialization code for xms.asm
int2f.asm	-- int 2f communication multiplex, used for cache control
int2fini.asm	-- initialization code for int2f.asm
reboot.asm	-- contains code for a software reboot
dev.asm		-- contains dummy device driver header
devini.asm	-- entry points for dev.asm's device--only displays error message
get_dpb.asm	-- code to get a drive's DPB without causing disk access
drvtype.asm	-- code which detects drive type sets up default drives to cache
indosbox.asm	-- code which detects if the program is launched in a VM
cmdline.asm	-- code which handles command line parseing,initialization
text.asm	-- all text messages which are not resident
rtest.asm	-- all text messages which are resident
rdata.asm	-- global resident data
tdata.asm 	-- global transient data
dec_out.asm	-- nifty routine to pretty-display numbers
popup.asm	-- pop-up dialog for error messages
devsym.inc	-- definition of device driver headers,packets,constants (DOS)
dpb.inc		-- definition of device parameter block (DOS)
version.inc	-- just the version number text
mseuq.inc	-- standard offsets for DOS
bambi.inc	-- constants used by bambi internally, interface constants
xms.inc		-- constants used by XMS standard


	 
	WinCache works by latching into the device driver chain.  It does
this by first duplicating a device driver header for each block device driver
in the DOS device driver chain and inserting the duplicate at the head of the
device chain.  Next, the duplicated headers are modified to have the strategy
and interrupt entry points point to WinCache's entry point.  Finally, the
DPB's are all updated to point to the modified device driver headers.
---
---	see	bambinit.asm
---
	The WinCache strategy and interrupt entry point replacement in its
most base form (when caching is disabled) simply chains the strategy and
interrupt calls to the correct device drivers.  However, when caching
is enabled, the WinCache entry point code takes additional action before
and after chaining to the correct device drivers.  
---
---	see	bambi.asm
---
	The first type of caching done by WinCache is read and read-ahead
caching.  When the WinCache entry point is called with a read packet 
(as passed via a packet from DOS auspiciously to the device driver), and the
data required to satisfy the request is determined to not be in the cache
(via algorithms described below), WinCache
interprets the packet and re-issues read commands to the device driver
accordingly: if the read does not align on a cache block boundary, WinCache
instructs the device driver to read the one block that contains the beginning
of DOS's requested read.  Then the body of the data is read in by instructing
the device driver to read the central body of data into the user's (as passed
in the packet by DOS) buffer.  Finally, if the last portion of the read does
not align on a cache block boundary, WinCache instructs the device driver to
read the final cache block into the WinCache local buffer.  The beginning
portion and final portion of the read data is updated in the user's buffer
as appropriate. Once the data read in, WinCache copies the newly read data
into the cache ram (using algorithms described below) and returns to DOS.
	A special case arises when WinCache detects that sequential reads
are being performed: if a second read is requested which is logically
contiguous to the previous read request, WinCache will instruct the device
driver to read more data than requested (according to the size of the
read-ahead buffer which is typically equal to the cache block size).  The
data that was read-ahead is placed into the cache in expectation of further
sequential read requests.
	The second type of caching done by WinCache is write and write-behind
caching.  When the Wincache entry point is called with a write packet (from
DOS), instead of allowing the data to be written to the disk, Wincache copies
the data into the ram cache and marks them as "dirty".  No data is committed
to disk at this time.
	Data is committed to disk asynchronously via interrupt 08 (the hardware
timer interrupt) and on interrupt 28 (the DOS idle interrupt).  Due to the
non-re-entrant nature of DOS, the ROM BIOS and DOS device drivers, and due
to timing issues for video and keyboard input and output the 
disk cannot be accessed at all times.   The cases when device driver/disk
access is not allowed are: during a video BIOS interrupt (int 10h),during
a hardware keyboard interrupt (int 09), during BIOS disk intterrupts
(int 13) and while the WinCache code is already entered (WinCache is not
re-entrant since it makes calls to non-rentrant device drivers). If a
timer or idle interrupt occurs and any of these cases are true, WinCache
will skip the write-behind since it would bring about a system crash. If
WinCache determines that write-behind is ok, it selects the first-in 
dirty block and commits it to disk by copying the block from XMS ram to
local (conventional) ram and instructing the appropriate device driver
to perform a write operation.
---
---	see	hooks.asm
---
	On all read requests, WinCache first checks to see if the request
can be satisfied by data in the ram cache.  Wincache keeps a queued list
of recently used blocks of the disks (block granularity is user configurable,
default is 8k). Each list entry corresponds to data cached in XMS ram.
Currently, WinCache uses a FIFO (first in first out) priority queue structure
for data organization.  This allows the data structures to be small (one
array of disk addresses) and quickly scanned for membership in the queue.
---
---	see 	queueman.asm
---


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\smartdrv\bambiapi.txt ===
The following is the smartdrv 4.x API.

Please note register usage.  Most calls use all registers.  If you
fail to restore SI,DI,BP in a C program, undesirable results will ensue.

WARNING: input parameters are NOT range checked by smartdrv.  If you
input invalid parameters (drive letters, etc) you could crash the machine
and trash the hard drive.

EXAMPLE: [detecting smartdrv]  
	mov	ax,MULT_BAMBI
	mov     bx,BAMBI_GET_STATS
	int	2fh
	cmp	ax,BAMBI_SIGNATURE
	jne	smartdrv4x_not_installed
smartdrv4x_installed:
...
;
;       MULT_BAMBI(ax)                                  equ     4a10h
;            BAMBI_GET_STATS(bx)                        equ        0
;            BAMBI_COMMIT_ALL(bx)                       equ        1
;            BAMBI_REINITIALIZE(bx)                     equ        2
;            BAMBI_CACHE_DRIVE(bx)                      equ        3
;                  CACHE_DRIVE_GET(dl)                  equ        0
;                  CACHE_DRIVE_READ_ENABLE(dl)          equ        1
;                  CACHE_DRIVE_READ_DISABLE(dl)         equ        2
;                  CACHE_DRIVE_WRITE_ENABLE(dl)         equ        3
;                  CACHE_DRIVE_WRITE_DISABLE(dl)        equ        4
;            BAMBI_GET_INFO(bx)                         equ        4    
;
;       BAMBI_SIGNATURE                                 equ     BABEh
;
;BAMBI_GET_STATS:
;FUNCTION:
;       Gets cache hit/miss statistics as well as detects presence of cache.
;
;       INPUT:
;               AX=MULT_BAMBI
;               BX=BAMBI_GET_STATS
;       OUTPUT:
;               AX=BAMBI_SIGNATURE
;               DI=cache misses (hiword)
;               SI=cache misses (loword)
;               DX=cache hits (hiword)
;               BX=cache hits (loword)
;               CX=number of uncommitted (dirty) blocks
;               BP=version number in binary (win31=0400h,msdos6=401h)
;       USED:
;               All except DS,ES
;
;BAMBI_COMMIT_ALL:
;FUNCTION:
;       Commits all uncommitted blocks (dirty blocks) to disk.
;
;       INPUT:
;               AX=MULT_BAMBI
;               BX=BAMBI_COMMIT_ALL
;       OUTPUT:
;               NONE
;       USED:   
;               NONE
;
;BAMBI_REINITIALIZE:
;FUNCTION:
;       Commits all uncommitted blocks to disk and invalidates the cache.
;Re-sizes the cache with input parameters.
;       INPUT:
;               AX=MULT_BAMBI
;               BX=BAMBI_REINITIALIZE
;               CX=number of cache elements
;               DX=size of cache elments
;       OUTPUT:
;               carry set if procedure unable to complete via XMS errors
;       USED:
;               ALL except DS,ES
;
;BAMBI_CACHE_DRIVE:
;FUNCTION:
;       Enables and disables read or write caching for a particular drive unit.
;Returns the cache state of the drive in DL. Get takes no action, but simply
;returns cache state for drive unit in DL.
;       INPUT:
;               AX=MULT_BAMBI
;               BX=BAMBI_CACHE_DRIVE
;               DL=CACHE_DRIVE_<get,read|write enable|disable>
;               BP=unit number of drive 
;       OUTPUT:
;               DL=cache state of unit:
;                       Bit 8 set -> no caching enabled for this unit
;                       Bit 8 not set -> read caching enabled for this unit
;                       Bit 7 set -> write caching not enabled for this unit
;                       Bit 7 not set -> write caching enabled for this unit
;                       -1 -> not a cachable drive
;       USES:
;               ALL except DS,ES
;
;BAMBI_GET_INFO:
;FUNCTION:
;       Get the current size of the cache.
;       INPUT:
;               AX=MULT_BAMBI
;               BX=BAMBI_GET_INFO
;       OUTPUT:
;               CX=size of cache block in bytes
;               AX=number of cache blocks while in dos
;               BX=number of cache blocks in cache
;       USES:
;               ALL except DS,ES
;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dos\dispatch.txt ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;	SCCSID = @(#)dispatch.asm	1.1 85/04/10
;	SCCSID = @(#)dispatch.asm	1.1 85/04/10
;
; Major dispatch code and table for MSDOS 2.X and above.
;
;   Modification history:
;
;	Created: MZ 30 March 1983
;
; The system calls are dispatched to in such a fashion as to have their entire
; register set passed to them except for CS:IP and SS:SP.  This reduces the
; need for retreiving information from the user's stack.
;
; There are also critical sections that need to be observed when running in a
; multitasking environment.  These sections are:
;
;   1	critDisk    any of the disk code that will twiddle the buffer cache
;   2	critDevice  all device drivers
;
;   4	critMem     memory allocation stuff
;   5	critNet     network critical section
;
; The system calls below are noted as to which of these critical sections they
; belong.  The critical sections are noted in the source files by the macros
; EnterCrit and LeaveCrit.
;
; The break-down of the individual system calls into source files is as
; follows (* means done):
;
;   *	handle.asm:	Close, Read, Write, LSeek, XDup, XDup2, FileTimes
;	IOCTL.INC:	IOCTL
;   *	file.asm:	Open, Creat, ChMod, Unlink, Rename, CreateTemp,
;			CreateNew
;   *	srvcall.asm:	$ServerCall
;   *	path.asm:	MkDir, RmDir, ChDir, CurrentDir
;   *	alloc.asm:	$Alloc, $Dealloc, $SetBlock, $AllocOper
;			arena_free_process, arena_next -> LOW LEVEL <-
;			check_signature, Coalesce
;   *	search.asm:	DirSearchFirst, DirSearchNext, FindFirst, FindNext,
;			PackName		 -> LOW LEVEL <-
;   *	proc.asm:	Exec, Exit, Abort, Wait, KeepProcess
;   *	cpmio.asm:	StdConInput, StdConOutput, StdAuxInput, StdAuxOutput,
;			StdPrinterOutput, RawConIO, RawConInput,
;			StdConInputNoEcho, StdConStringInput,
;			StdConStringOutput, StdConInputStatus,
;			StdConInputFlush
;			OUT, BUFOUT, RAWOUT, RAWOUT2	-> LOW LEVEL <-
;   *	fcbio.asm:	FCBOpen, FCBClose, FCBDelete, FCBSeqRead, FCBSeqWrite,
;			FCBCreate, FCBRename, FCBRandomRead, FCBRandomWrite,
;			GetFCBFileLength, GetFCBPosition, FCBRandomReadBlock,
;			FCBRandomWriteBlock
;   *	Time.asm:	GetDate, SetDate, GetTime, SetTime
;   *	Parse.asm:	Parse_file_descriptor, PathParse
;   *	GetSet.asm:	GetInterruptVector, SetInterruptVector,
;			GetVerifyOnWrite, SetVerifyOnWrite, GetDMA, SetDMA,
;			GetVersion, SetCTRLCTrapping, GetDriveFreespace,
;			CharOper, International, SetDefaultDrive,
;			GetDefaultDrive
;   *	Misc.asm:	Sleazefunc, SleazefuncDL, GetDefaultDPB, GetDPB,
;			CreateProcessDataBlock, GetINDOSFlag, GetInVars,
;			SetDPB, DupPDB, DiskReset
;			StrCmp, StrCpy, Ucase		 -> LOW LEVEL <-
;
; STUB MODULES
;	Net.asm 	**** This will get broken down more???
;   *	Share.asm	Share_Check, Share_Violation
;   *	Lock.asm	$LockOper
;			DOS_LOCK,DOS_UNLOCK,Lock_Check, Lock_Violation

; INTERNAL INTERFACE MODULES
;   *	Lock.asm	DOS_LOCK, DOS_UNLOCK   -->> STUBS <<--
;   *	Dinfo.asm	DISK_INFO
;   *	Finfo.asm	GET_FILE_INFO, SET_FILE_ATTRIBUTE
;   *	Create.asm	DOS_CREATE, DOS_CREATE_NEW,
;			Set_Mknd_Err	       --> Low level routine <--
;   *	Dup.asm 	DOS_DUP
;   *	Open.asm	DOS_OPEN,
;			SetBadPathError,       --> Low level routines <--
;			Check_Access_AX, Share_Error, Set_SFT_Mode
;   *	Close.asm	DOS_CLOSE, DOS_COMMIT, DOS_CLOSE_GOT_SFT,
;			Free_SFT	       --> Low level routine <--
;   *	Abort.asm	DOS_ABORT
;   *	ISearch.asm	DOS_SEARCH_FIRST, DOS_SEARCH_NEXT,
;			RENAME_NEXT	       --> Low level routine <--
;   *	Dircall.asm	DOS_MKDIR, DOS_CHDIR, DOS_RMDIR
;   *	Rename.asm	DOS_RENAME
;   *	Delete.asm	DOS_DELETE,
;			REN_DEL_Check	       --> Low level routine <--
;   *	Disk.asm	DOS_READ, DOS_WRITE

; LOW LEVEL MODULES
;   *	Fat.asm 	UNPACK, PACK, MAPCLUSTER, FATREAD_SFT,
;			FATREAD_CDS, FAT_operation
;   *	Ctrlc.asm	--> STD/IBM versions <--
;			FATAL, FATAL1, reset_environment, DSKSTATCHK,
;			SPOOLINT, STATCHK, CNTCHAND, DIVOV, RealDivOv,
;			CHARHARD, HardErr
;   *	Buf.asm 	SETVISIT, ScanPlace, PLACEBUF, PLACEHEAD, PointComp,
;			GETBUFFR, GETBUFFRB, FlushBuf, BufWrite,
;			SKIPVISIT
;   *	Disk.asm	SWAPBACK, SWAPCON, get_io_sft, DirRead, FATSecRd,
;			DskRead, SETUP, BREAKDOWN, DISKREAD, DISKWRITE,
;			FIRSTCLUSTER, DREAD, DWRITE, DSKWRITE,
;			READ_LOCK_VIOLATION, WRITE_LOCK_VIOLATION,
;			SETSFT, SETCLUS, AddRec
;   *	Mknode.asm	BUILDDIR, SETDOTENT, MakeNode, NEWENTRY, FREEENT,
;			NEWDIR, DOOPEN,RENAME_MAKE
;   *	FCB.asm 	MakeFcb, NameTrans, PATHCHRCMP, GetLet, TESTKANJ,
;			NORMSCAN, CHK, DELIM
;   *	Rom.asm 	GET_random_record, GETRRPOS1, GetRRPos, SKPCLP,
;			FNDCLUS, BUFSEC, BUFRD, BUFWRT, NEXTSEC,
;			OPTIMIZE, FIGREC, GETREC, ALLOCATE, RESTFATBYT,
;			RELEASE, RELBLKS, GETEOF
;   *	Dev.asm 	IOFUNC, DEVIOCALL, SETREAD, SETWRITE, GOTDPB,
;			DEVIOCALL2, DEV_CLOSE_SFT, DEV_OPEN_SFT
;   *	Dir.asm 	SEARCH, SETDIRSRCH, GETPATH, ROOTPATH, StartSrch,
;			MatchAttributes, DEVNAME, Build_device_ent,
;			FindEntry, Srch, NEXTENT, GETENTRY, GETENT,
;			NEXTENTRY, GetPathNoSet, FINDPATH
;

; critical section information for the system calls

;   System Call 		      Who takes care of the reentrancy
;   Abort			   0	(flushbuf) DOS_Close
;   Std_Con_Input		   1	DOS_Read
;   Std_Con_Output		   2	DOS_Write
;   Std_Aux_Input		   3	DOS_Read
;   Std_Aux_Output		   4	DOS_Write
;   Std_Printer_Output		   5	DOS_Write
;   Raw_Con_IO			   6	DOS_Read/DOS_Write
;   Raw_Con_Input		   7	DOS_Read
;   Std_Con_Input_No_Echo	   8	DOS_Read
;   Std_Con_String_Output	   9	DOS_Write
;   Std_Con_String_Input	   A	DOS_Read
;   Std_Con_Input_Status	   B	DOS_Read
;   Std_Con_Input_Flush 	   C	DOS_Read
;   Disk_Reset			   D	(FlushBuf, ScanPlace, SkipVisit)
;   Set_Default_Drive		   E	*none*
;   FCB_Open			   F	DOS_Open
;   FCB_Close			  10	DOS_Close
;   Dir_Search_First		  11	DOS_Search_First
;   Dir_Search_Next		  12	DOS_Search_Next
;   FCB_Delete			  13	DOS_Delete
;   FCB_Seq_Read		  14	DOS_Read/DOS_Write
;   FCB_Seq_Write		  15	DOS_Read/DOS_Write
;   FCB_Create			  16	DOS_Create
;   FCB_Rename			  17	DOS_rename
;   Get_Default_Drive		  19	*none*
;   Set_DMA			  1A	*none*
;   Get_Default_DPB		  1F	*none*
;   FCB_Random_Read		  21	DOS_Read/DOS_Write
;   FCB_Random_Write		  22	DOS_Read/DOS_Write
;   Get_FCB_File_Length 	  23	Get_file_info
;   Get_FCB_Position		  24	*none*
;   Set_Interrupt_Vector	  25	*none*
;   Create_Process_Data_Block	  26	*none*
;   FCB_Random_Read_Block	  27	DOS_Read/DOS_Write
;   FCB_Random_Write_Block	  28	DOS_Read/DOS_Write
;   Parse_File_Descriptor	  29	*none*
;   Get_Date			  2A	DEVIOCALL
;   Set_Date			  2B	DEVIOCALL
;   Get_Time			  2C	DEVIOCALL
;   Set_Time			  2D	DEVIOCALL
;   Set_Verify_On_Write 	  2E	*none*
;   Get_DMA			  2F	*none*
;   Get_Version 		  30	*none*
;   Keep_Process		  31	$abort...
;   Get_DPB			  32	*none*
;   Set_CTRL_C_Trapping 	  33	*none*
;   Get_InDOS_Flag		  34	*none*
;   Get_Interrupt_Vector	  35	*none*
;   Get_Drive_Freespace 	  36	Disk_Info
;   Char_Oper			  37	*none*
;   International		  38	*none*
;   MKDir			  39	DOS_MkDir
;   RMDir			  3A	DOS_RmDir
;   CHDir			  3B	DOS_ChDir
;   Creat			  3C	DOS_Create
;   Open			  3D	DOS_Open
;   Close			  3E	DOS_Close
;   Read			  3F	DOS_Read
;   Write			  40	DOS_Write
;   Unlink			  41	DOS_Delete
;   LSeek			  42	*none*
;   CHMod			  43	Get_file_info, Set_File_Attribute
;   IOCtl			  44	DEVIOCALL
;   XDup			  45	*none*
;   XDup2			  46	*none*
;   Current_Dir 		  47	$Current_Dir
;   Alloc			  48	$Alloc
;   Dealloc			  49	$Dealloc
;   Setblock			  4A	$SetBlock
;   Exec			  4B
;   Exit			  4C	$abort...
;   Wait			  4D	*none*
;   Find_First			  4E	DOS_Search_First
;   Find_Next			  4F	DOS_Search_Next
;   Set_Current_PDB		  50	*none*
;   Get_Current_PDB		  51	*none*
;   Get_In_Vars 		  52	*none*
;   SetDPB			  53	*none*
;   Get_Verify_On_Write 	  54	*none*
;   Dup_PDB			  55
;   Rename			  56	DOS_Rename
;   File_Times			  57	*none*
;   AllocOper			  58	*none*
;   GetExtendedError		  59	*none*
;   CreateTempFile		  5A	DOS_Create_New
;   CreateNewFile		  5B	DOS_Create_New
;   LockOper			  5C
;   ServerCall			  5D
;   UserOper			  5E
;   AssignOper			  5F

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\copyrite.txt ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1993
; *                      All Rights Reserved.
; */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\dosshell.doc ===
ۥ- R@	    -             ƕ                    F                                     ^    ^ ^    ^    ^    ^    ^   l   &    &    &    &    &  4 Z   &    p  j ڭ  4                                                       .  4 b   .    ^          .    .      K S                                                             			DOSSHELL DESIGN DOCUMENT

1.1 Overview

This document describes the DOS 5.0 DOSSHELL. It gives an overview of its features and how they have been implemented. This is intended more as an aid for someone to take the current source code and be able to modify/adapt it based on new needs/requirements rather than as something that is a end user document. Thus, this document is intended more as a road map of the source code rather than an in-depth analysis of it. It should be noted that when work was begun on the DOSSHELL the specification was to clone the DOS 4.0 DOSSHELL -- a rewrite using C so that it would be easily maintainable. Most of the design decisions were based on this and the data structures were tailor made to take up the least amount of memory (using bit fields, etc.) as that is a major concern under DOS. Quite a ways into the project, it was decided to move towards a Windows like interface. Given the schedule constraints, certain things like reading just the top level of the drive structure in the File Manager (hereinafter referred to as FM) at start up, etc. could not be done. It should also be remembered that several features like File.Search, File.Run, Task Switching, etc. were added as after thoughts and were made to fit in with the rest of the design. However, considering the final product and how it all came out, it seems that these were the right decisions.

We decided to use Microsoft CW (Character Windows) Library as the basis for doing all the menu and dialog creations, screen manipulation, etc. This let us concentrate on the device independent portions and so we did not have to worry about whether we were running on a monochrome, CGA, EGA, VGA monitor, etc. CW libraries are also used by other MS products such as QuickBasic, MS Works, etc. This way we have a uniform platform making all these products feel like parts of the same family.

Before reading this document it might be a good idea to read the DOSSHELL specification document prepared by ericst. That should give a very good description of all the features that were planned/implemented. It also talks about the screen layouts and other such fine details.

1.2 Skeleton/Guts of the DOSSHELL

Let us now look at the DOSSHELL from a very high level. 

SYMBOL 183 \f "Symbol" \s 10 \h	The stub, basically a program loader, first gets control when one launches DOSSHELL. It initializes the various interrupt vectors, resizes itself appropriately (depending on whether the task switcher is enabled or not) and then launches DOSSHELL.EXE which has the bulk of the functionality. This is the resident portion of the DOSSHELL and this memory is never freed until the user uses the DOSSHELL exit command.

SYMBOL 183 \f "Symbol" \s 10 \h	When DOSSHELL.EXE gets control from the stub, the first thing it does is read and parse the DOSSHELL.INI file (for information on the contents of the INI file, read the DOSSHELL spec.). It also sets up the data structures like the collating table, International Data (country specific information like date/time formats, etc.). It then parses the command line switches.

SYMBOL 183 \f "Symbol" \s 10 \h	The initialization of the DOSSHELL is done based on the information in the INI file and the command line switches. This includes information like the startup screen mode (medium resolution graphics,  high resolution text, etc.), the startup tree mode (single tree mode, dual tree mode, program manager mode, etc.), sort order, etc. The screen driver (DOSSHELL.VID), if present, is loaded and the screen is put in the appropriate mode. The FM and PM (Program Manager) data structures are set up. These include setting up the menus, figuring out the various drive letters that are active, installing interrupt handlers for stuff like critical errors, etc.

SYMBOL 183 \f "Symbol" \s 10 \h     Finally, the DOSSHELL gets into its message pump. It sits in a loop that looks for keyboard and mouse messages. CW handles the low level keyboard and mouse input and puts these in a message queue. When there is a message in the queue, it is processed appropriately. However, when the queue is empty, we do some idle processing like updating list boxes, reading portions of the tree data structures from disk, etc. If we did not do anything useful, we inform the world that we are indeed idle (INT 2f for WINDOWS, OS/2 ; INT 28 for TSRs ; INT 15 for power management guys). It is the message pump that takes care of user input and hence passes control to the appropriate window procedures which in turn perform the user requested tasks like menu operations, etc.

2.1 A closer look at the implementation

Now, let us look a little closer at how some of the functionality described above has been implemented.  It should be noted that this document is no substitute to actually looking at the source code and the documentation there. In a later section, the source code layout has been described and this will provide information regarding what functionality is in which source file.

Let us first look at the INI file processing. All other INI file parsing code is in the INIPARSE directory of the DOSSHELL source tree. At startup, the file is read in and token-ized and stored in memory. We made a decision that a static symbol table is sufficient to hold all the tokens of a reasonable size file. It would help to clarify what a token means at this point. At token is basically an 'integer' encoding of a string. We manipulate tokens throughout the shell and it is much more convenient than carrying these strings around. Also, it serves as a means of indirection and saves a lot of storage if one uses the same strings over and over again in the INI file as the same token refers to all these duplicates. Thus, if the same string is used more than once, the memory for the string is allocated just once. The maximum number of symbols (distinct tokens) we allow is specified by the constant MAXSYMBOLS. Note that we have several pre-defined internal keyword tokens. The number of these is specified by NUMKEYWORDS and all the keywords may be found in file symbols.h. For example, the following two lines:

	help = blah blah blah...
	help = blah blah blah 2...

need a total of 4 tokens (1 for "help", 1 for "=" and 1 each for the two help strings). If two strings are the same (like in this case "help" and "="), they map into the same token and so we don't eat into our limited token space. During our analysis of the run-time profiles, we found that a lot of time was spent looking up strings to avoid duplication in memory. To alleviate this problem, we implemented hashing. It should be noted that since we have a static symbol table size, we cannot handle arbitrarily large INI files. However, we have not found this a serious restriction. Several optimizations have been used to speed up the INI file writing code (like buffered writes, etc.) and we keep track of whether any changes have been made to it before writing the file out. That is, if one changed view modes from Shared File List to Single File List and back to Shared File List, we detect that there is no net change and avoid writing out the INI file. The INI file is written out every time a program/group item is created/modified. It is also written out when the DOSSHELL temporarily relinquishes control to launch an application specified by the user or when one exits it (if changes were detected). The PM relies heavily on the INI file parsing code as its basic task is to handle program and group items.

Now let us look at the menu structure and the messaging system, the PM and FM. Almost all the functionality of the DOSSHELL is available through menu items (except stuff like drag and drop using the mouse). These can be selected using the keyboard or the mouse. In both cases, we get input from CW in the form of messages. Each window has a message procedure that interprets these messages and takes appropriate action.

There are basically two menu bars, one for the PM and one for the FM. The way it is set up is that for each menu item, we have a procedure to handle it. Thus, when the user selects a certain menu item like File.Move in the FM (using the keyboard accelerator F7 or otherwise), the function DoMoveFiles() is called (provided this menu item is not grayed out). The file menus.c has all the menu items and their corresponding  menu procedures. So, to find out how a certain functionality has been implemented all that one has to do is to look up this file for the appropriate menu-proc and then see its code path. It is a very simple but powerful and general mechanism. I shall not go into any more details in this regard as it is quite easy to understand when one looks at the source.

We have implemented listboxes in a very modular manner. We did not use the support CW provides for listboxes. A listbox is basically a window containing a list of items that may be scrolled if the total number of items exceeds the number that will fit at any given instant. Note that our model is quite simple and so we don't have horizontal scrolling or re-sizeable listboxes. However, the design is very clean and it should be pretty straight forward to enhance its capabilities and add these features. The reason we did not use CW's listbox support is because we had to give it all the strings that would be displayed in the listbox at one shot and this we felt was a big memory hit. We have the ability to traverse our compact data structures and so when we have to display the items in the listbox, we generate them on the fly, one at a time, and draw them. We did not observe any noticeable degradation in speed even though we were building these lines each time (for example: a line in the file listbox of the FM contained the FileName, FileSize, Date, etc. formatted appropriately). We designed it so that each listbox had its own list-proc that would handle messages like draw,  select, get-count, set-focus, etc. This worked out very well and was very structured.

The PM, as I mentioned before, basically has to do a lot of book-keeping and so it relies heavily on the parsing code. It lets one create/modify program and group items. All this information is stored in the INI file from one session to another. One very important task of the PM (which is not available through the plain vanilla COMMAND.COM) is to act as an interface to DOSSWAP.EXE (basically, real mode WINDOWS) and provide task switching/task swapping. It should be noted that this is not true multi-tasking. That is, when one switches out of an application, it is swapped to disk and it stays dormant there. When the task swapper is disabled, the PM acts simply as a  program loader/launcher. However, when task swapping is enabled, it takes care of all the book keeping associated with task lists, like maintaining them in Z-order, adding and deleting specific tasks, etc. A quick look at files taskman.c and dts_api.asm should give you almost all the information you would like to know about the interaction between the task swapper and the DOSSHELL. The PM also supports a primitive command language to pass arguments to programs that one launches (see file cmdlan.c). We added hot-key support to applications in the task list (something that was not there in WIN 3.0) and we had to get around CW to get to scan codes. This is a pretty cool feature (see file scancode.asm). A more detailed layout of the source code and the functionality in each file will be provided later for a better understanding.

The FM provides a view of the directory structure of the user's drives. It allows one to do all sorts of file and directory manipulations like copy, rename, move, delete, search, view, etc. It is a very convenient means of working with one's data on the disk. Before one understands how it accomplishes these tasks it is very essential to be familiar with the fairly complex but compact/concise data structures. For this, one should have a full grasp of all the lines in file filemgr.h. These are pretty well documented and so there should not be much trouble perusing it. Note the use of bit-fields and unions, etc. to try and use as little memory as possible to store file/directory information (example structures: fileinfo, treehdr). It is important to know that a decision was made very early in the project (DOS 4.0 SHELL cloning effort) to have a whole tree read into memory before allowing any operations on it. Thus memory was clearly an issue and we did everything to make optimum use of it. On big disks (with a few thousand files and a few hundred directories), it might take a few extra seconds to have the whole tree read in but the wait is well worth it as file manipulation operations are very fast. For example, File.Search is almost instantaneous. The delay is just the time it takes to match the requested pattern (wild cards, etc.) in memory and sort all the matched files appropriately. Of course, it is possible to run out of memory or be low on memory when one tries to read in a big network drive (with several thousand files on it). To handle this situation, we decided to implement a mode called compact mode. In this mode, only the directories are kept in memory and the files are read in dynamically as one selects each new directory. The files belonging to the directory that is not currently selected are discarded from memory and the directory is marked as such. In a future version, it would be nice to read in just the top level of the directory structure (like in WIN 3.1) and read in the rest as needed. We did not implement this cool feature due to schedule constraints.
	The functions that one has to understand thoroughly before one can get an in-depth grasp of the FM are AddFile(), AddLateFile(), and DelFileEntry() (file add.c). These form the guts of it and they make calls to routines that manipulate the data structures in complex and interesting ways. It will also be a good idea to become familiar the manner in which sorting of the files and directories has been implemented (files snext.c and sort.c) as assumptions about the snext and dnext chain linkages are made throughout the source. snext is a pointer field of a file node and points to the next file in the directory/disk in appropriate sort  order (name, extension, date, size, or disk-order) and dnext is a pointer field of a directory node and points to the next directory in the disk in name order. Let me re-iterate once more that it will be very difficult to follow the algorithms used to implement the features of the FM unless one understands the underlying data structures. So, spend sufficient time on this. For example, we don't store the pointer to the parent directory of a file/directory. To get this information one needs to follow its sibling pointer chain and know that the last sibling points to the parent of these files/directories (The bit field nosib is used to find out whether a file/directory is the last sibling in the chain).

Dialog boxes are used extensively to get user input. We used CW's Dialog Editor (DE) to create these. Look at the DE manual to learn about its fundamentals and become familiar with it. We provide a dialog procedure for each dialog box to handle all the messages related to it. All dialog-procs have basically the same structure/layout. Spend some time studying a few dialog procedures (for example: FDlgrun(), FDlgaddprogram(), FDlgcolor(), FDlgdispopt(), and FDlghelp()) to see how listboxes, push-buttons, check-boxes, edit-boxes, radio-buttons, etc. are handled. Once you understand these templates, it is simply a matter of cut-and-paste to create new and complex dialog procedures of your own. CW, as the name implies, is actually meant for character mode based applications but it provides just enough hooks for applications to intercept all its rendering (drawing) procedures so that they had do it on their own. We have made full use of this feature to draw graphical radio-buttons, push-buttons, etc. At first, these may look like hacks but later on you will realize that these are indeed elegant solutions. See functions Pfnradiobutton(), Pfnbutton(), Pfneditbox(), etc. (file screen.c) to see how these work. An understanding of these functions will enable you to appreciate the amount of work we put into the DOSSHELL to get graphics mode to look cool. The pretty graphic icons you see are actually bit maps we created by hand. It is a very primitive way of doing it but it worked well. We would first draw the icons using Xs in appropriate columns of each row and then convert it to hexadecimal data by hand (see file icons.c). Drawing such icons on the screen is quite slow. So, we cache and keep track of  the screen real estate as to what icons are where and avoid screen output if we find out that the appropriate icon is already at the right spot. We have used so many such neat tricks all over the place to be as efficient as possible.

3.1 Source code layout

I shall now try to give a layout of the source code. This will provide a guideline as to what each file in the DOSSHELL source tree contains.

[GRBS]: 
This directory has all the grabbers for different video configurations (MONO, HERC, CGA, EGA, VGA, etc. -- files with extension .grb). The appropriate one will be copied by the installation program (DOS 5.0 setup) as the file dosshell.grb.
 
[HLPS]:
This directory has the help file (dosshell.hlp) that is used to display on-line help.

[INC]:
This directory has all the include/header files (extension .h) used in the shell sub-directory. It also contains all the templates for the dialog boxes created using CW's DE (files with extension .des). The makefile in this directory uses DE to generate the include files (ones with extension .hs and .sdm) from these .des files. These .hs and .sdm files are the ones which define the dialog box data structures (used in the shell sub-directory). It is very important that one understands the various constructs in the .h files in this directory as it will make it easier to follow the rest of the source much better (especially files common.h, cwindows.h, filemgr.h, and listbox.h).

[INIPARSE]:
This directory has all the code dealing with reading and writing the INI file. It takes care of tokenizing all the words and strings so that we can store and manipulate them easier in memory. There are basically only three files in this directory to do all the manipulation (files iniparse.c, lex.c, and symbols.c). These files are very extensively documented, to the point where one might get fed up with it and so it should be very easy to understand all the routines in them. The include files parse.h and symbols.h contain the constants and prototypes used by the parse routines in the .c files. The main functions in these files that one should be aware of are: Read_Ini_File(), Write_Ini_File(), Insert_Symbol(), Get_Ith_Element(), Delete_Ith_Element(), Get_List_Length(), Get_Token_Identifier(), Get_Identifier_Token(), Set_KeyWord_Assignment(), Get_Keyword_Assignment(), String_To_Token(). This looks like a big list but these are the building blocks to parse almost any kind of construct.

[INIS]:
This is similar to the grabber stuff. The appropriate file is copied as dosshell.ini. Note that the only real difference between these .ini files is that the color schemes are different. Also, note that there is no vga.ini file. The .ini file is the same for EGAs and VGAs.

[LIB]:
This has the libraries we link in to build DOSSHELL.EXE. The two libraries we link in are cow3m.lib (CW lib) and mlibce.lib (medium model C lib).

[LOADER]:
This directory contains the file loader.asm that is used to build DOSSHELL.COM, which is basically the stub that takes care of launching DOSSHELL.EXE and other applications that the user wants to launch from within the shell. It contains the resident portion of the shell. The only reason this .com file is built is to reduce the start up time when the user first types DOSSHELL. Note that command.com launches a .com file instead of the .exe file if two files have the same name in the same directory. The .com file is only about 4K in size whereas the .exe is over 230K and it is faster to load a smaller size file when DOS does the exec call. Note that DOSSHELL.EXE also has this loader/stub functionality in it and so the .com is not essential/necessary if one has a fast enough drive and does not notice a speed degradation. The file loader.asm includes the files swtch_re.inc and swtch_tr.inc which are actually assembler files that  contains code dealing with interfacing with DOSSWAP.EXE (switcher data structures, adding/deleting programs from the task list, etc.). These are the resident and transient portions respectively. It is definitely worth your time to get a feel for these routines. Modifying these should be quite easy as they are very modular. The message strings for internationalization purposes are in two separate files resmsg.inc and transmsg.inc. These are also the resident and transient portions respectively.

[SHELL]:
This directory has the code for all the major DOSSHELL features. So, let us look at each source file and the functionality it provides.

add.c: The four basic functions AddFile(), AddLateFile(), GetNextFile(), and DelFileEntry() that allow one to manipulate the file nodes/structures in memory are in this file. It is very important to understand these well as these are building blocks.

asmutils.asm: This file has several utility functions written in assembly language. These were written to be efficient in calling various DOS interrupts (like int 2f, int 21, etc.) and also because it was more convenient to do these in assembly than in C!

attr.c: code for File.Change Attributes menu item.

busydlg.c: This file contains the functions that put up and take down the files/dirs being read-in information when a drive has not been fully read into memory (PutUpBusyDialog() and TakeDownBusyDialog()) .

cmdlan.c: This file has routines that handle the DOSSHELL batch/command language to run/launch programs. This includes processing arguments like %1-%9 (putting up dialogs asking for user input when launching programs from the PM that require arguments). We also tried to support the IBM DOS 4 SHELL batch language %T (for title), %P (user prompt), etc. but these are not thoroughly tested as we decided to not support these later on. I also believe we do not document these. We launch programs by creating a batch file and placing the commands in it. This batch file is passed as argument to command.com. The routines dealing with creating this batch file and deleting it when done are also in this file (SetUpCommand() and DeleteBatchFile()).

color.c: This file deals with setting the color scheme/mode at startup based on the information from the INI file (or default, if no INI file) as well as changing it from within the DOSSHELL if the INI file has some color schemes defined in it. The main routine that one should look at is ColorBox() (this functions handles the Options.Colors in the menu).

compare.asm: This file has the assembly routines to do string compares (esp. for file/directory sorting based on name and extension). They have been written in assembly for the sake of high speed sorting. These routines take the collating table and country information into account.

confirm.c: This file has the routines that put up confirmation dialogs (if user has requested confirmation using menu item Options.Confirmation) on direct manipulation using the mouse, deleting a file/directory or replacing a file using move/copy (routines: MouseConfirmationDialog(), DeleteConfirmationDialog(), and ReplaceConfirmationDialog()).

copy.c: This file name is a terrible misnomer! The first feature that was implemented in this file was File.Copy and hence the name copy.c. However, later on, several other FM file manipulation menu functions were added to it but the file name wasn't changed. This file has many menu-procs, namely DoCopyFiles(), DoMoveFiles(), DoRenameFiles(), DoDelFiles(), DoViewFile(), DoChangeAttributes(), DoPrintFiles(), and DoCreateDirectory()). Note that almost all of these set up some constants and invoke the general function DoFileOp() which performs the operation on each selected file. This file also has the routines to handle the four items under the Tree menu of the FM (DoExpand1Level(), DoExpandBranch(), DoExpandAll(), and DoCollapse()).

critical.asm: This file has our critical error hooker that causes all critical errors to return failure. It saves the critical error code in global variable ErrorCrit so that we can put up a user friendly dialog box explaining to the user what critical error happened. Note that this is how we have avoided having the user-hostile "abort, retry, ignore?" message from popping up and corrupting the screen.

delprog.c: The routine that handles deleting program/group items (DeleteProgram()) is in this file (PM menu item File.Delete).

dir.c: This file has the routines to create/delete directories (CreateDirectory() and DelDirectory()).

disp.c: Code for Options.File Display Options FM menu item.

dosintf.c: Code that uses the user friendly critical error handler (CriticalDialog()). This file has the function shell_findfirst() which is basically _dos_findfirst() except that we check if a critical error occurred during this call telling us that the drive is not ready or some such thing and put up an appropriate dialog box.

dotrees.c: Code to handle the following four View menu items: View.Single File List (DoSingleTree()), View.Dual File Lists (DoDoubleTree()), View.All Files (DoFlatDisplay()), and View.Program/File Lists (DoShareMode()). It has also the code to handle the listbox when one is doing a file search (DoSearchDisplay()). This function will be invoked from function FileLocateBox() in file locate.c.

drive.asm: Has code for function getdrivetype() which determines whether a given drive is a local (hard-disk/floppy), cd-rom, or net drive.

dts_api.asm: Has switcher data structures and code to handle the DOS Task Switcher API (DTS_API(), DTS_API_Init(), DTS_API_Exit()).

errbox.c: This file has two very important functions that are used very often throughout the shell to put up a message and then get the user to select one of a list of choices. These are GetResponse() and DOSErrorBox(). It will help a lot to understand these well.

filemgr.c: Code to initialize the FM, draw the FM screen (drive icons on top, message bar at bottom, etc.), reading in the drive, etc. Interesting routines are InitFileMgr(), DoFileMgr(), FileMgrIdle(), SelectDrive(), MessageBar(), and RefreshFMScreen(). 

fileops.c: This file has pretty much the bulk of the file manipulation routines. Note that I said that file copy.c has a lot of menu-procs to do file manipulation. That file only has the entry points and end up invoking the functions in this file (fileops.c). It has functions like DeleteFile(), CopyFile(), MoveFile(), RenameFile() (handles files as well as dirs), and PrintFile(). It also has the menu-procs for the following menu items: Options.Confirmation (DoFileOptions() -- misnomer for historical reasons!), File.Select All (DoSelectAll()), and File.Deselect All (DoDeselectAll()).

flatleft.c: Code to draw the left part of the screen when one is in All Files view mode.

graphics.c: This file has functions to enhance CW's graphics capabilities. It has functions like FrameButton(), FrameDialog(), etc. to make the screen look pretty in graphics modes.

groups.c: This file is to the PM what fileops.c and filemgr.c are to the FM. It has all the menu-procs and routines that handle all the PM's program/group item manipulations except File.Delete (which is in file delprog.c). These are: File.New (AddProgram()), File.Open (StartAProgram()), File.Copy (CopyProgram()), File.Properties (ChangeProgram()), and File.Reorder (ReorderGroup()). This file also has the code to initialize the PM (InitializeStartPrograms()) and to draw the PM screen (RefreshStartPrograms()), etc.

help.c: This file has all the routines that put up context sensitive help in the DOSSHELL based on the file dosshell.hlp. The starting point is the routine Help(). It has the menu-procs for Help.Index (IndexBox()), Help.KeyBoard (KeyBox()), Help.Shell Basics (BasicsBox()), Help.Commands (CommandsBox()), Help.Procedures (ProceduresBox()), and Help.Using Help (UsingHelpBox()). All these functions end up calling the main function HelpBox() which what one should focus on when trying to understand the help code.

helper.c: This file has many FM utility functions like Tree2Path(), FindTree(), FindNode(), FindParent(), LoadCompactDir(), etc. Before you write a certain routine to do a job in the FM, check this file first to see if it has what you want.

icons.c: This file has the bit-maps for all the graphical icons that are in the DOSSHELL. Look at the data structure for any one bit map (example: bigFileIcon) and you will understand all of them as they all follow the same model.

init.c: This file has all the routines to initialize the shell at start up (loading the CW drivers, setting up the screen, etc.) and also the exit code. Routines to look at are InitializeShell(), SetScreenMode(), and DoExit(). It also has the menu-proc for Options.Display (ScreenBox()).

launch.c: This file has the code to handle the menu-procs File.Associate (AssociateBox()), File.Open (LaunchBox()), and File.Run (Run()). 

lbox.c: This has the two list-proc routines to handle all the messages (select, draw, drag, drop, activate, etc.) sent to the file and directory listboxes of the FM (ListProcTreeList() and ListProcFileList()). It is very important to understand these well.

list.c: This file, like helper.c, has several utility functions of the FM. Routines that need special mention are memory allocation for files/dirs (AllocTreeEntry()), tree compaction routines (CompactifyTree(),  PackDirs(), ClobberFiles(), etc.), and get info routines (GetNthMatchedFile(), GetNthDir(), CountDirFiles(), etc.).

listbox.c: This file has all the code for our listbox implementation. These send messages to the various list-proc routines based on keyboard and mouse events. Routines that need special mention are ListBoxInit(), DoRedisplayList(), DoUpdateListBox(), FocusLineChange(), ListKey(), ListMouse(), InsertListItem() and ListBoxIdle(). These routines are invoked all over the place and it will pay to understand these well.

locate.c: code for File.Search FM menu item.

main.c: This has the entry point to the DOSSHELL (main()) that takes care of reading in the INI file, parsing of command line arguments (ParseCommandLine()) and calling all the initialization routines. It then goes into its message pump and idle handling routines (MainIdle()).

manip.c: This file has the routines that handle direct manipulation (drag and drop using the mouse). The three main routines are BeginManipulation(), EndManipulation(), and MonitorManipulation().

memmgr.c: This file has all the basic functions to allocate and free memory. The routines you should be aware of are PbAllocWork(), FreeWork(), LpbAllocWorkFar(), FreeWorkFar(), and OutOfMemory(). Note that the memory to put up the out of memory dialog box has been allocated at initialization time itself. 

menus.c: Almost everything to do with menus is in this file. This has the routines to create menus, draw them, enable and disable them, add keyboard accelerators to menu items, etc. All routines in this file are very important. Start with routine DoInitMenus() makes use of all the basic building blocks.

mousebug.asm: We found that certain old mouse drivers were not compatible with our switcher (caused system hangs during task swapping). Hence, we decided to detect the mouse version number and warn the user if he had an old mouse driver installed (version < 6.21 of MS or compatible mouse driver) at start up. However, logitech mouse driver version number 5.01 was compatible with the switcher but to detect it, we had to grovel in memory to look for a the logitech signature (LOGITECH MOUSE DRIVER V5.01). This file has the routine DetectLogitech() that does this. We found that several different vendors' mouse drivers did not respond properly to the GetMouseDriverVersion API and this gave us lot of grief.

pfiles.asm: This file has the interface to the DOS print spooler (print.com) -- to check whether it has been loaded (check_spooler()) and to print a file using it (a_print_file()).

scancode.asm: It should be noted that the DOSSHELL supports hot keys to activate programs in the active task list. The way we implement this is by hooking int 9 getting the scan code of the hot key that one specifies in the properties dialog for a program item. This file has the routines to hook and unhook the hardware keyboard interrupt (HookISR9() and UnHookISR9()). The global variable gcancode (scan code of key just hit) and gshiftstate (shift state of key just hit).

screen.c: It should be noted that there is a window called MainWind that covers the whole screen. All other windows are children of this window. Thus, under normal mode of operation (that is, say, when there is no dialog box put up) all messages (paint, keyboard, mouse, etc.) from CW are send to its wind-proc, namely, WindProc(). This is a very key routine to understand and forms the core of the CW-DOSSHELL interaction. Depending on where the global focus is at any given point in time user input is processed appropriately. This file also has all the hooks to provide dialog boxes with a nice graphical look (as mentioned before). The functions in here to do this will make very interesting reading.

showinfo.c: Code for Options.Show Information FM menu item.

snext.c: All the snext and dnext chain manipulation code. Even with all the documentation in this file, it will take a while to get a full grasp of these routines.

sort.c: All the routines to sort the files and dirs belonging to a tree in an appropriate order. It should be noted that when we are not in All Files view mode, we do incremental sorting. That is, files belonging to a directory are sorted on the fly and are done only when needed (when one selects them for the first time). When one chooses the All Files view mode, we do a fast merge sort. The main routines are FormDirectoryOrder(), SystemSort(), SortDirectory(), and InsertDir().

swapdisk.asm: Note that in older versions of DOS, there was no clean way for an application to prevent the message "Insert diskette for drive B: and ..." from being put up on the screen when one tried to use both the A and B drive letters on a machine with a single physical floppy drive. In MS-DOS 5.0, the BIOS makes an int 2f call out to let someone else handle it, if they want to. If no one handled it, it defaults to the current behavior. This lets the application put up an user friendly message or at least something that it can put up and take down gracefully without having its screen corrupted. This file has the routines that do this (InstallSwapHandler(), int2fswaphandler(), and RemoveSwapHandler()).

taskman.c: This file has the code that interfaces with the task swapper. It initializes the switcher data structures, enables/disables task swapping, handles manipulation of items in the task list (hot keys, etc.). The main routines are EnableSwitching(), Switch_To_Ith_Task(), InitGlobalSwitchData(), FirstInitTaskMan(), and DeleteTask() (file launch.c has the routine AddTask()).

text.c: This file contains all the strings that are put on the screen (in dialogs or otherwise). This helps international as they need to only localize this file (translate all the strings in this file) and re-compile. We didn't come up with an efficient method wherein we don't have to re-compile. Internationalization worked out pretty well for us.

utils.c: This file has a major chunk of utility functions (as the name suggests). This includes routines like pmatch(), get_comspec(), get_temp_dir(), PutUpStatusMessage(), TakeDownStatusMessage(), Buffered_Write_Ini_File(), Do_Read_Ini_File(), ShellAboutBox() (Help.About Shell menu-proc), etc. When one needs to find if a certain utility function is available, one should first check the files helper.c, list.c, and utils.c.

view.c: Code for File.View File Contents FM menu item.

winidle.asm: This file has the routine GlobalIdle() that makes the WINDOWS, DOS, and power management idle calls (int 2f, int 28, and int 15). When we figure that we don't have anything useful to do, we make this call be nice guys to the world.

[ SWAPPER]:
This directory has all the files to build DOSSWAP.EXE (the DOSSHELL's task swapper). This used to be called WINOLDAP.EXE, as it is basically WINDOWS in real mode. However, the task switcher API has been added to it, so that newer applications/programs (that do things like Asynchronous I/O, etc.) can conform to this and thus get the most benefit. To get more information on it, please read the design document for WINDOWS and the publication on the switcher API. The task swapper actually swaps applications to disk and not extended/expanded memory and one can use its abilities even on a simple PC.

[VIDS]:
This is similar to the grabber and ini file stuff. The appropriate file is copied by the installation program as dosshell.vid. If one changes video cards and displays, etc., it is up to the user to expand the appropriate .vid from the DOS source disks and call it dosshell.vid. It should be noted that it is the .vid file that provides the graphical modes. One can use the shell without this external video driver as it has an in-built default driver. However, the default one only supports text modes and on older model CGAs it will most likely cause annoying snowing on the screen.
           
dTree(), FindNode(), FindParent(), LoadCompactDir(), etc.               %  &  '  5  6  Y	  _	  
  )
  e
  f
  
  
  A  N      (  )  H  I                  r  s          '  (          p  y  v  }      |!  !  !  !  "  $"  "  "  /$  6$  \(  (  H*  Q*  +   ,  A,  J,  O,  Z,  J-  R-  .  .  0  0  0  0  1  1  s1  {1  }1  1  r3  }3  4  5                                [5  I7  a7  g7  u7  |7  7  8  8  8  8  8  8  8  8  8  8  9  9  ;  ;  =  =  =  =  =  =  =  =  =  >  @  @  @  @  @  @  @  @  B  B  C  C  C  C  E  
E  ME  ZE  hE  tE  E  E  F  !F  /F  4F  F  F  F  F  	G  G  G  G  "G  &G  4G  7G  <G  @G  G  G  G  G  _H  H  H  H  I  I  I  I  I  I  J  J  J  J  J  J  ;K   L  L  L  M  M  iM               aiM  pM  {M  M  	N  N   N  *N  pN  zN  uO  yO  O  O  O  O  P  	P  JP  NP  yP  }P  P  P  %Q  )Q  Q  Q  Q  Q  Q  Q  S  S  S  S  T  T  T  T  T  T  T  T  T  T  U  U  #V  )V  +V  1V  V  V  V  V  V  V  ^W  oW  tW  W  W  W  Y  Y  PZ  ^Z  cZ  tZ  zZ  Z  [  [  [  [  [  [   ]  	]  {]  ]  ^  ^  ^  7^  =^  X^  ^^  d^  ^  ^  ^  ^  u_  _  _  _  _            b_  `  g`  r`  `  `  `  a  a   a  "a  /a  5a  ?a  Ga  Sa  a  a  b  b  "c  1c  Qc  \c  bc  gc  c  c  c  c  c  c  c  c  d  d  Od  _d  }d  d  d  d  Ye  be  e  e  e  e  e  e  e  e  e  e  e  e  e  f  f  #f  %f  2f  f  f  f  f  f  f  f  f  g  g  ug  g  g  g  g  g  g  g  g  h  h  h  h  h  i  i  i  i  i  i  i  i  i  i  i  i  i            bi  j  j  j  wj  }j  k  k  %k  1k  3k  =k  ?k  Ik  Kk  Wk  }k  k  k  k  k  k  l  l   l  -l  4l  El  Gl  Vl  \l  fl  l  l  m  &m  (m  5m  qm  ym  m  m  m  m  &n  2n  Dn  Mn  [n  cn  en  qn  tn  }n  n  n  n  n  n  n  n  n  n  n  n  n  n  n  $o  =o  Zo  po  {o  o  o  o  p  p  9p  Cp  Ep  Op  Rp  _p  ap  ip  lp  }p  p  p  p  p  p  p  p  p  p  p  p            bp  p  p  p  *q  3q  q  q  q  q  q  q  q  q  q  q  q  q  sr  zr  s  s  ]s  cs  t  t  !t  0t  6t  >t  ^t  mt  ot  zt  t  t  t  t  t  t  t  t  t  t  t   u  u  u  u  u  u  u  u  u  v  v  *v  2v  v  v  v  v  v  v  v   w   w  3w  5w  @w  Bw  Qw  ]w  fw  $x  1x  3x  Dx  Fx  Wx  Yx  jx  lx  ux  wx  x  x  x  x  x  y  y  y  !y  3y  9y  y  y  <z            b<z  Fz  Lz  Sz  z  z  z  z  z  {  {  {  {  {  {  {  {  {  {  {  {  {  J|  Q|  A}  N}  ~}  }      G  Q        ˀ          ;  C  `  p      ߁    T  ^  c  o          ݂           '            ΅                           $  8  :  F  H  W  ]  h  m  y          
    "  5  ;            b;  D  (  9  ;  O  Q  g  i  {                    %                Ɏ  ˎ              "  $  4            Ǐ  ̏  ҏ  ݏ        -  9  x  ~              M  Q  x        ĕ  ƕ                                                                                                                                                                        C                  
  
  '
  )
  c
  e
  &  (      p  r          <  >                      #  #  (  (  .  .  6  )<  +<  C  C  C  C  ɹɱ|      !    !    !    !    	!    !    !    !    !        h   
!h   !h   !h   !h   !h  !K    !    !   !    !    !   ! 0C  zD  |D  D  wE  zE  E  E  E  E  H  H  H  L  L  L  M  M  M  BN  DN  ON  S  S  S  T  T  U  U  V  V  V  V  W  W  xZ  zZ  [  [  \   ]  \^  ^^  Ea  Ga  b  b  `c  bc  c  c  	d  d  We  Ye  f  f  sg  ug  g  g  i  i  	j  j  Zl  \l  l  l  om  qm  yo  {o  }q  q  qr  sr  [s  ]s  ~t       !             !    	!    !    !    !    !    !    !    ! O~t  t  u  u  v  v  [w  ]w  y  y  1y  3y  Jz  Lz  {  {  H|  J|  |}  ~}  E  G      ۂ  ݂      ޅ        k  m  9  ;          ʏ  ̏            e  g  p    ƕ                                                                                                                                                             !     !    !    !    	!    !    !    !    !    ! 3       sub heading   F        	             
                      F           ,  %-  <  H  T  _  j  u  ]    F     {                     "   H     
  	 Z    
                5  iM  _  i  p  <z  ;  ƕ  K L M N O P Q R   C  ~t  ƕ  S T U j  Times New Roman 	Symbol & Arial 
1 Courier 	BScript 1 LinePrinter  New Times Roman 
 italics   	  
  
  ?  _      F  9 9 9 9    Gf  Gf     Gf          "       h    L%s%Fj 8  3            DOSSHELL Design Document  1This is the design document for the DOSSHELL 5.0.Seetharaman HarikrishnanSeetharaman Harikrishnan         
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\inis\jega.ini ===
JEGA.INI
****************  WARNING  ********************
This file may contain lines with more than 256
characters. Some editors will truncate or split
these lines. If you are not sure whether your
editor can handle long lines, exit now without
saving the file.

Note: The editor which is invoked by the
	  MS-DOS 5.0 EDIT command can be used
	  to edit this file.
****************  NOTE  ***********************
Everything up to the first left square bracket
character is considered a comment.
***********************************************
[savestate]
screenmode = text
resolution = low
startup = filemanager
filemanagermode = shared
sortkey = name
pause = disabled
explicitselection = disabled
swapmouse = disabled
tasklist = disabled
switching = disabled
[programstarter]
currentcolor = Ocean
filemanager = enabled
command = enabled
group = 
{
	program = 
	{
	command = COMMAND
	title = Command Prompt
	help = Starts the MS-DOS command prompt where you can type any MS-DOS command.^m^mTo return to MS-DOS Shell from the command line:^m^m1. Type exit^m2. Press ENTER.^m^mRelated Topic^m   " More on Command Prompt "~$129~
	pause = disabled
	}
	program = 
	{
	command = EDLIN %1
	title = Edlin
	help = Starts Edlin, a text editor you can use to create and modify text files. After you choose Edlin, you can specify the file you want to work with in a dialog box.
	pause = disabled
	dialog = 
	{
		title = File to Edit
		info = Enter the name of the file to edit.
		prompt = File to edit?
		parameter = %1
	}
	}
	group = 
	{
	title = Disk Utilities
	help = Displays program items you can choose to manage your disks. You can also choose to open the Main group or any group you may have added.
	program = 
	{
		command = diskcopy %1
		title = Disk Copy
		pause = enabled
		dialog = 
		{
		title = Disk Copy
		info = Enter the source and destination drives.
		prompt = Parameters . . .
		default = a: b:
		parameter = %1
		}
		help = Temporarily leaves MS-DOS Shell to copy the contents of a floppy disk to another floppy disk. After you choose Disk Copy, a dialog box suggests parameters and switches you can either accept or replace.^m^mRelated Topic^m   " More on Disk Copy "~$132~
	}
	program = 
	{
		command = backup %1
		title = Backup Fixed Disk
		pause = enabled
		dialog = 
		{
		title = Backup Fixed Disk
		info = Enter the source and destination drives.
		prompt = Parameters . . .
		default = c:\*.* a: /s
		parameter = %1 
		}
		help = Temporarily leaves MS-DOS Shell to copy files from one disk to another. After you choose Backup Fixed Disk, a dialog box suggests parameters and switches you can either accept or replace.^m^mRelated Topic^m   " More on Backup Fixed Disk "~$133~
	}
	program = 
	{
		command = restore %1
		title = Restore Fixed Disk
		pause = enabled
		dialog = 
		{
		title = Restore Fixed Disk
		info = Enter the source and destination drives.
		prompt = Parameters . . .
		parameter = %1
		}
		help = Temporarily leaves MS-DOS Shell to restore files that were backed up. After you choose Restore Fixed Disk, a dialog box suggests parameters and switches you can either accept or replace.^m^mRelated Topic^m   " More on Restore Fixed Disk "~$134~
	}
	program = 
	{
		command = format %1 /q
		title = Quick Format
		pause = enabled
		dialog = 
		{
		title = Quick Format
		info = Enter the drive to quick format.
		prompt = Parameters . . .
		default = a:
		parameter = %1
		}
		help = Temporarily leaves MS-DOS Shell to prepare a disk to accept MS-DOS files. After you choose Quick Format, a dialog box suggests parameters and switches you can either accept or replace.^m^mRelated Topic^m   " More on Quick Format "~$136~
		screenmode = text
		alttab = enabled
		altesc = enabled
		ctrlesc = enabled
		prevent = enabled
	}
	program = 
	{
		command = format %1
		title = Format
		pause = enabled
		dialog = 
		{
		title = Format
		info = Enter the drive to format.
		prompt = Parameters . . .
		default = a:
		parameter = %1
		}
		help = Temporarily leaves MS-DOS Shell to prepare a disk to accept MS-DOS files. After you choose Format, a dialog box suggests parameters and switches you can either accept or replace.^m^mRelated Topic^m   " More on Format "~$135~
	}
	program = 
	{
		command = undelete %1
		title = Undelete
		help = Recovers deleted files.^m^mWARNING: If your disk is full or if you are using task swapping, using this program item may render some deleted files unrecoverable.^m^mRelated Procedure^m   " Restoring Deleted Files "~I155~
		pause = enabled
		dialog = 
		{
		title = Undelete
		info = WARNING! This action may cause the permanent loss of some deleted files.  Press F1 for more information.
		prompt = Parameters . . .
		default = /LIST
		parameter = %1
		}
		screenmode = text
		alttab = enabled
		altesc = enabled
		ctrlesc = enabled
		prevent = enabled
	}
	}
}
color = 
{
	selection = 
	{
	title = Basic Blue
	foreground = 
	{
		base = black
		highlight = brightwhite
		selection = brightwhite
		alert = brightred
		menubar = black
		menu = black
		disabled = white
		accelerator = cyan
		dialog = black
		button = black
		elevator = white
		titlebar = black
		scrollbar = brightwhite
		borders = black
		drivebox = black
		driveicon = black
		cursor = black
	}
	background = 
	{
		base = brightwhite
		highlight = blue
		selection = black
		alert = brightwhite
		menubar = white
		menu = brightwhite
		disabled = brightwhite
		accelerator = brightwhite
		dialog = brightwhite
		button = white
		elevator = white
		titlebar = white
		scrollbar = black
		borders = brightwhite
		drivebox = brightwhite
		driveicon = brightwhite
		cursor = brightblack
	}
	}
	selection = 
	{
	title = Ocean
	foreground = 
	{
		base = black
		highlight = brightwhite
		selection = brightwhite
		alert = brightwhite
		menubar = black
		menu = black
		disabled = white
		accelerator = brightwhite
		dialog = black
		button = black
		elevator = white
		titlebar = black
		scrollbar = brightwhite
		borders = black
		drivebox = black
		driveicon = black
		cursor = black
	}
	background = 
	{
		base = brightwhite
		highlight = blue
		selection = black
		alert = white
		menubar = cyan
		menu = cyan
		disabled = cyan
		accelerator = cyan
		dialog = cyan
		button = brightwhite
		elevator = white
		titlebar = white
		scrollbar = black
		borders = black
		drivebox = brightwhite
		driveicon = brightwhite
		cursor = brightcyan
	}
	}
	selection = 
	{
	title = Monochrome-2 Colors
	foreground = 
	{
		base = black
		highlight = white
		selection = white
		alert = black
		menubar = black
		menu = black
		disabled = white
		accelerator = white
		dialog = black
		button = white
		elevator = black
		titlebar = white
		scrollbar = white
		borders = black
		drivebox = black
		driveicon = black
	}
	background = 
	{
		base = white
		highlight = black
		selection = black
		alert = white
		menubar = white
		menu = white
		disabled = white
		accelerator = black
		dialog = white
		button = black
		elevator = white
		titlebar = black
		scrollbar = black
		borders = black
		drivebox = white
		driveicon = white
	}
	}
	selection = 
	{
	title = Monochrome-4 Colors
	foreground = 
	{
		base = black
		highlight = brightwhite
		selection = brightwhite
		alert = black
		menubar = black
		menu = black
		disabled = white
		accelerator = brightwhite
		dialog = black
		button = black
		elevator = white
		titlebar = black
		scrollbar = brightwhite
		borders = black
		drivebox = black
		driveicon = black
		cursor = black
	}
	background = 
	{
		base = brightwhite
		highlight = brightblack
		selection = brightblack
		alert = brightwhite
		menubar = brightwhite
		menu = white
		disabled = white
		accelerator = brightblack
		dialog = brightwhite
		button = white
		elevator = white
		titlebar = white
		scrollbar = black
		borders = black
		drivebox = brightwhite
		driveicon = brightwhite
		cursor = black
	}
	}
	selection = 
	{
	title = Reverse
	foreground = 
	{
		base = white
		highlight = black
		selection = black
		alert = white
		menubar = white
		menu = white
		disabled = black
		accelerator = black
		dialog = white
		button = black
		elevator = white
		titlebar = black
		scrollbar = black
		borders = white
		drivebox = white
		driveicon = white
	}
	background = 
	{
		base = black
		highlight = white
		selection = white
		alert = black
		menubar = black
		menu = black
		disabled = black
		accelerator = white
		dialog = black
		button = white
		elevator = black
		titlebar = white
		scrollbar = white
		borders = black
		drivebox = black
		driveicon = black
	}
	}
	selection = 
	{
	title = Hot Pink
	foreground = 
	{
		base = black
		highlight = brightwhite
		selection = brightwhite
		alert = brightmagenta
		menubar = black
		menu = black
		disabled = white
		accelerator = magenta
		dialog = black
		button = brightwhite
		elevator = white
		titlebar = brightwhite
		scrollbar = brightwhite
		borders = black
		drivebox = black
		driveicon = black
		cursor = black
	}
	background = 
	{
		base = brightwhite
		highlight = brightmagenta
		selection = magenta
		alert = brightwhite
		menubar = brightwhite
		menu = brightwhite
		disabled = brightwhite
		accelerator = brightwhite
		dialog = brightwhite
		button = magenta
		elevator = white
		titlebar = magenta
		scrollbar = black
		borders = black
		drivebox = brightwhite
		driveicon = brightwhite
		cursor = brightred
	}
	}
	selection = 
	{
	title = Emerald City
	foreground = 
	{
		base = black
		highlight = black
		selection = brightwhite
		alert = green
		menubar = black
		menu = black
		disabled = white
		accelerator = green
		dialog = black
		button = brightwhite
		elevator = white
		titlebar = brightwhite
		scrollbar = brightwhite
		borders = black
		drivebox = black
		driveicon = black
		cursor = black
	}
	background = 
	{
		base = brightwhite
		highlight = brightgreen
		selection = green
		alert = brightwhite
		menubar = brightwhite
		menu = brightwhite
		disabled = brightwhite
		accelerator = brightwhite
		dialog = brightwhite
		button = green
		elevator = white
		titlebar = green
		scrollbar = black
		borders = black
		drivebox = brightwhite
		driveicon = brightwhite
		cursor = brightcyan
	}
	}
	selection = 
	{
	title = Turquoise
	foreground = 
	{
		base = black
		highlight = brightwhite
		selection = brightwhite
		alert = brightred
		menubar = brightwhite
		menu = black
		disabled = white
		accelerator = white
		dialog = black
		button = black
		elevator = white
		titlebar = black
		scrollbar = brightwhite
		borders = black
		drivebox = black
		driveicon = black
		cursor = black
	}
	background = 
	{
		base = brightwhite
		highlight = brightblue
		selection = black
		alert = brightwhite
		menubar = brightcyan
		menu = brightcyan
		disabled = brightcyan
		accelerator = brightcyan
		dialog = brightcyan
		button = brightwhite
		elevator = white
		titlebar = white
		scrollbar = black
		borders = black
		drivebox = brightwhite
		driveicon = brightwhite
		cursor = cyan
	}
	}
}

associations = 
{
	association = 
	{
	program = EDLIN
	extension = TXT
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\shell\readme.txt ===
This is the Source to the DOSSHELL version 2 

	To build, use the build.bat batch file: "build clean"


Special Note to Internationalizers:
	Throughout the code we have added comments indicating all
	the places we are aware of which may require internationalization.
	The comment is "/* INTERNATIONALIZE HERE! [...] */" or
	in asm ";;;; INTERNATIONALIZE HERE! ..."
	It is almost certainly the case that we have missed places.

	In particular, dialogs should be modified with the CW dialog
	editor "de21.exe". These are the ".sdm",".hs",and ".des" files in
	shellh. To change strings in the dialog, open the ".des" file and
	click on items with text. Boxes surrounding the text or button
	may have to be expanded. Be certain that with buttons the box is
	resized appropriately so that it does not become lopsided!
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dosshell\swapper\copyrite.txt ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1985-1991
; *                      All Rights Reserved.
; */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dosdata\doc\data.doc ===
Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential


This document gives the format for data files required for the
retail upgrade installation program.  

Basically, the data for each DOS-version has a one line header, giving
the Oem name and version number, followed by a number of classes of
information. Each class consists of the class name, in brackets, on a
single line, followed by a number of lines of textual information
that depend on the particulars of each class.  Not all classes need
be used for any given DOS.  The classes are:

[lie-to]	Lists existing programs that require addition
		to the lie version table.

[rename]	Lists on pairs of lines DOS programs that should
		be installed with new names.

[delete]	Lists programs which should be deleted from the
		target directory.  This includes existing utilities
		with different extensions from the current version.

[device]	Lists device drivers which need to be installed
		in the target drive and added to CONFIG.SYS.

[drivparm]	Lists drivparm commands which need to be added to
		CONFIG.SYS.

[rem-device]	Lists non-functional device drivers which need to
		be removed from CONFIG.SYS.  (E.g. disk cache 
		programs that no longer work properly.)

[no-install]	Lists any DOS 4.0 utilities that should not be
		installed on the new system.

[diff-file]    Lists the name of a non-standard file to be installed
		instead of the default file.

Blank lines are ignored.  Comments are introduced by a ";" and
terminated by the end of the line.  If more than one Oem-version of
DOS is being described in a file, the data for the various DOS's
needs to be separated by a line containing the end-of-data mark,
"###".  A typical example file might look like:

-----------------TOP-OF-FILE-------------------
COMPAQ 3.31

[lie-to]
display.sys
driver.sys
mode.com
basic.com
basica.com
basica.exe
clock.sys
enhdisk.sys
setclock.com

[rename]
display.sys
disply40.sys

driver.sys
driver40.sys

mode.com
mode40.com

ansi.sys
ansi40.sys

fdisk.com
fdisk40.com

keyb.com
keyb40.com

keyboard.sys
keybrd40.sys
###

ZENITH 3.30

[bios]
zenith.bio

[lie-to]
fdisk.exe

[rename]
fdisk.exe
fdisk40.exe
--------------------END-OF-FILE-----------------

Needless to say, it is important to maintain consistency throughout
the numerous data files.  The exact same string should always be used
when refering to the same OEM.  Similarly, the file names listed
should all be given in lower case.



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dosdata\doc\dbase.doc ===
Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential


This document gives the format for data files required for the
retail upgrade installation program.  

Basically, the data for each DOS-version has a one line header, giving
the Oem name and version number, followed by a number of classes of
information. Each class consists of the class name, in brackets, on a
single line, followed by a number of lines of textual information
that depend on the particulars of each class.  Not all classes need
be used for any given DOS.  The classes are:


[lie-to]	Lists existing programs that require addition
		to the lie version table.

[rename]	Lists on pairs of lines DOS programs that should
		be installed with new names.

[delete]	Lists programs which should be deleted from the
		target directory.  This includes existing utilities
		with different extensions from the current version.

[device]	Lists device drivers which need to be installed
		in the target drive and added to CONFIG.SYS.

[drivparm]	Lists drivparm commands which need to be added to
		CONFIG.SYS.

[rem-device]	Lists non-functional device drivers which need to
		be removed from CONFIG.SYS.  (E.g. disk cache 
		programs that no longer work properly.)

[no-install]	Lists any DOS 4.0 utilities that should not be
		installed on the new system.

[diff-file]	Lists the name of a non-standard file to be installed
		instead of the default file.

[upd-device]	Update the "DEVICE=" line in the config.sys file
		for the specified device name to prefix the path
		to the new DOS directory.


Blank lines are ignored.  Comments are introduced by a ";" and
terminated by the end of the line.  If more than one Oem-version of
DOS is being described in a file, the data for the various DOS's
needs to be separated by a line containing the end-of-data mark,
"###".  A typical example file might look like:

-----------------TOP-OF-FILE-------------------
COMPAQ 3.31

[lie-to]
display.sys
driver.sys
mode.com
basic.com
basica.com
basica.exe
clock.sys
enhdisk.sys
setclock.com

[rename]
display.sys
disply40.sys

driver.sys
driver40.sys

mode.com
mode40.com

ansi.sys
ansi40.sys

fdisk.com
fdisk40.com

keyb.com
keyb40.com

keyboard.sys
keybrd40.sys
###

ZENITH 3.30

[bios]
zenith.bio

[lie-to]
fdisk.exe

[rename]
fdisk.exe
fdisk40.exe
--------------------END-OF-FILE-----------------

Needless to say, it is important to maintain consistency throughout
the numerous data files.  The exact same string should always be used
when refering to the same OEM.  Similarly, the file names listed
should all be given in lower case.





/* DOSDATA -
		Program to maintain the data file for the retail upgrade install
		utility.  Usage is as follows:

		DOSDATA filename
			Incorporates the information from the specified text information
			file into the master data file.

		DOSDATA /D oemname version
			Deletes all information for the specified version of DOS
			from the master data file.


		An typical text information file might contain:

			Compaq 3.31
			lie:
			mode.com
			fdisk.exe
			rename:
			mode.com mode40.com
			fdisk.exe fdisk40.exe
			delete:
			print.exe

		The master data file has the format:

			Dos_record_1
			Dos_record_2
			...
			Dos_record_n
			Null_dos_record
			Name_record_1
			Name_record_2
			...
			Name_record_n
			Null_name_record
			Name_entry_1
			Name_entry_2
			...

		A Dos_record is:

			[oem-name][dos-version][data-addr]
			    18          2           4       = 24 bytes

			(The data-addr field is a pointer to the beginning of the
			various data tables for that DOS.)

		A Name_record is a variable length record containing a
			zero-terminated string with a file name or action name.

		A Name_entry is a 1 byte record containing an integer index into
			the name record table.


	Base name types
		n		number (as in minor/major version number)
		file	file
		ddr	Dos descriptor record
		ne		Name entry (index into array of names (isz))
*/



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\install\dosdata\doc\readme.doc ===
Copyright (c) 1991 - Microsoft Corp.
	All rights reserved.
	Microsoft Confidential


The program DOSDATA.EXE is used to compact the source data files for
the retail upgrade into DOSDATA.DAT, the master data file.
There are currently two source files:

	list.330: contains data for various OEM DOS 3.30's
	upgrade.401: contains data for the retail upgrade DOS
	
To build the master data file, type these commands:

	dosdata list.330
	dosdata upgrade.401



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\setup\build.txt ===
To build this directory you must have IExpress installed.
Run "iexpress /N /Q /M vbsnapsetup.sed" from razzle window.

Please contact AnandhaG for any problems.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\setup\mmceula.txt ===
Microsoft Management Console - Technical Preview Only

END-USER LICENSE AGREEMENT FOR MICROSOFT SOFTWARE
IMPORTANT-READ CAREFULLY: This Microsoft End-User License Agreement ("EULA") is a legal agreement between you (either an individual or a single entity) and Microsoft Corporation for the Microsoft software identified above, which includes computer software and may include associated media, printed materials, and "online" or electronic documentation ("SOFTWARE PRODUCT"). By installing, copying, or otherwise using the SOFTWARE PRODUCT, you agree to be bound by the terms of this EULA. If you do not agree to the terms of this EULA, do not install or use the SOFTWARE PRODUCT.

The SOFTWARE PRODUCT is protected by copyright laws and international copyright treaties, as well as other intellectual property laws and treaties. The SOFTWARE PRODUCT is licensed, not sold.
1.  GRANT OF LICENSE. 
This EULA grants you the right to install and use one (1) copy of the SOFTWARE PRODUCT for the limited purpose of performing a technical preview and evaluation of the software.  No other rights are granted to you.  All rights not expressly granted are reserved by Microsoft. 
2.  DESCRIPTION OF LIMITATIONS. 
You may not reverse engineer, decompile, or disassemble the SOFTWARE PRODUCT, except and only to the extent that such activity is expressly permitted by applicable law notwithstanding this limitation.  No support services for the SOFTWARE PRODUCT will be provided to you by Microsoft. 
3.  TERMINATION.  
Without prejudice to any other rights, Microsoft may terminate this EULA if you fail to comply with its terms and conditions. In such event, you must destroy all copies of the SOFTWARE PRODUCT and all of its component parts.
4.  COPYRIGHT. 
All title, including but not limited to copyrights, in and to the SOFTWARE PRODUCT and any copies thereof are owned by Microsoft or its suppliers.  All title and intellectual property rights in and to the content which may be accessed through use of the SOFTWARE PRODUCT is the property of the respective content owner and may be protected by applicable copyright or other intellectual property laws and treaties.  This EULA grants you  no rights to use such content.  All rights not expressly granted are reserved by Microsoft.
5.  NOTE ON JAVA SUPPORT.  
The SOFTWARE PRODUCT may contain support for programs written in Java.  Java technology is not fault tolerant and is not designed, manufactured, or intended for use or resale as on-line control equipment in hazardous environments requiring fail-safe performance, such as in the operation of nuclear facilities, aircraft navigation or communication systems, air traffic control, direct life support machines, or weapons systems, in which the failure of Java technology could lead directly to death, personal injury, or severe physical or environmental damage
6.  NO WARRANTIES. 
MICROSOFT EXPRESSLY DISCLAIMS ANY WARRANTY FOR THE SOFTWARE PRODUCT.  THE SOFTWARE PRODUCT AND ANY RELATED DOCUMENTATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OR MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NONINFRINGEMENT.  THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE PRODUCT REMAINS WITH YOU.
7.  LIMITATION OF LIABILITY. 
TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL MICROSOFT OR ITS SUPPLIERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THE SOFTWARE PRODUCT OR THE PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES, EVEN IF MICROSOFT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. IN ANY CASE, MICROSOFT'S ENTIRE LIABILITY UNDER ANY PROVISION OF THIS EULA SHALL BE LIMITED TO THE GREATER OF THE AMOUNT ACTUALLY PAID BY YOU FOR THE SOFTWARE PRODUCT OR US$5.00; PROVIDED HOWEVER, IF YOU HAVE ENTERED INTO A MICROSOFT SUPPORT SERVICES AGREEMENT, MICROSOFT'S ENTIRE LIABILITY REGARDING SUPPORT SERVICES SHALL BE GOVERNED BY THE TERMS OF THAT AGREEMENT. BECAUSE SOME STATES AND JURISDICTIONS DO NOT ALLOW THE EXCLUSION OR LIMITATION OF LIABILITY, THE ABOVE LIMITATION MAY NOT APPLY TO YOU.
8.  U.S. GOVERNMENT RESTRICTED RIGHTS. 
All software provided to the U.S. Government pursuant to solicitations issued on or after December 1, 1995 shall be provided with the commercial rights and restrictions described elsewhere herein.  All software provided to the U.S. Government pursuant to solicitations issued prior to December 1, 1995 are provided with RESTRICTED RIGHTS as provided for in FAR, 48 CFR 52.227-14 (JUNE 1987) or DFAR, 48 CFR 252.227-7013 (OCT 1988), as applicable.  All rights not expressly granted are reserved. 
9.  EXPORT RESTRICTIONS. 
You agree that you will not export or re-export the SOFTWARE PRODUCT or any portion thereof to any country, person, entity or end user subject to U.S. export restrictions.  You specifically agrees not to export or re-export the SOFTWARE PRODUCT or any portion thereof (i) to any country to which the U.S. has embargoed or restricted the export of goods or services, which currently include, but are not necessarily limited to Cuba, Iran, Iraq, Libya, North Korea, Sudan and Syria, or to any national of any such country, wherever located, who intends to transmit or transport the products back to such country; (ii) to any end-user who you know or has reason to know will utilize the SOFTWARE PRODUCT or portion thereof in the design, development or production of nuclear, chemical or biological weapons; or (iii) to any end-user who has been prohibited from participating in U.S. export transactions by any federal agency of the U.S. government.
9.  MISCELLANEOUS
If you acquired this product in the United States, this EULA is governed by the laws of the State of Washington, U.S.A.  
If you acquired this product in Canada, this EULA is governed by the laws of the Province of Ontario, Canada. Each of the parties hereto irrevocably attorns to the jurisdiction of the courts of the Province of Ontario and further agrees to commence any litigation which may arise hereunder in the courts located in the Judicial District of York, Province of Ontario. 
If this product was acquired outside the United States, then local law may apply.
Should you have any questions concerning this EULA, or if you desire to contact Microsoft for any reason, please contact Microsoft Sales Information Center/One Microsoft Way/Redmond, WA 98052-6399.

Si vous avez acquis votre produit Microsoft au CANADA, la garantie limite suivante vous concerne :
GARANTIE LIMITE
EXCLUSION DE GARANTIES. Microsoft exclut expressment toute garantie relative au LOGICIEL. Le LOGICIEL et la documentation y affrente sont fournis "en l'tat", sans garantie d'aucune sorte, expresse ou 
implicite, y compris, de manire limitative, sans aucune garantie de qualit, d'adquation  un usage particulier ou de non-contrefaon. Vous assumez l'ensemble des risques dcoulant de l'utilisation ou des performances du LOGICIEL.
ABSENCE DE RESPONSABILIT POUR LES DOMMAGES. Pas de Responsabilit pour les Dommages Indirects - Microsoft ou ses fournisseurs ne seront pas responsables en aucune circonstance pour tout dommage  spcial, incident, indirect, ou consquent quel qu'il soit (y compris, sans limitation, les dommages entrains par la perte 
de bnfices, l'interruption des activits,  la perte d'information ou toute autre perte pcuniaire) dcoulant de l'utilisation ou de l'impossibilit d'utilisation de ce  LOGICIEL  ainsi que pour toute disposition concernant le Suport Technique ou la faon dont celui-ci a t rendu et ce, mme si Microsoft a t avise de la possibilit de tels dommages. la responsabilit de  Microsoft en vertu de toute disposition de cette convention  ne pourra en aucun temps excder  
le plus lev entre i) le montant effectivement pay par vous pour le LOGICIEL ou ii) US$5.00. advenant que vous ayez contract par entente distincte avec Microsoft pour un Support Technique tendu, vous serez li par les termes d' une telle entente.
La prsente Convention est rgie par les lois de la province d'Ontario, Canada. Chacune des parties  la prsente reconnat irrvocablement la comptence des tribunaux de la province d'Ontario et consent  instituer tout litige qui pourrait dcouler de la prsente auprs des tribunaux situs dans le district judiciaire de York, province d'Ontario.
Au cas o vous auriez des questions concernant cette licence ou que vous dsiriez vous mettre en rapport avec Microsoft pour quelque raison que ce soit, veuillez contacter la succursale Microsoft desservant votre pays, dont l'adresse est fournie dans ce produit, ou crire  : Microsoft Customer Sales and Service, One Microsoft Way, Redmond, Washington 98052-6399.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\setup\readme.txt ===
-----------------------------------------------------
MMC Snap-in Designer for Visual Basic Readme File
                     August 1999
-----------------------------------------------------
(c) Microsoft Corporation, 1999. All rights reserved.

This document provides setup information that supplements the MMC Snap-in Designer for Visual Basic documentation.

------------------------
How to Use This Document
------------------------
To view the Readme file on-screen in Windows Notepad, maximize the Notepad window. On the Edit menu, click Word Wrap. To print the Readme file, open it in Notepad or another word processor, and then use the Print command on the File menu.

---------------------------------------------------------------
Setup Information for the MMC Snap-in Designer for Visual Basic
---------------------------------------------------------------
The setup for this beta is a self-extracting .exe file. To run the setup program, at the command prompt type "Setup". Setup performs the following steps:

1. Displays a dialog box with the message, "Do you want to install the MMC Snap-in Designer for Visual Basic?" If you click Yes, Setup checks to see whether Visual Basic 6.0 is installed. If Visual Basic 6.0 is not installed, Setup quits without installing anything. If it is installed, Setup proceeds with the following steps.

2. Removes old Visual Basic snap-in entries in the registry. 

3. Checks to see whether you have the Microsoft Platform SDK installed. If so, Setup installs the samples in <Platform SDK directory>\samples\SysMgmt\mmc\SnapInDesigner. If you do not have the Platform SDK installed, Setup prompts you for the directory in which to install the samples and documentation. The samples and documentation are installed in <directory that you provide>\samples\SysMgmt\mmc\SnapInDesigner.

4. Registers all the sample snap-ins. 

Note: If you had an earlier version of the Snap-in Designer installed, this setup procedure replaces the earlier files with the new files.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\vblic\readme.txt ===
//---------------------------------------------------------------------------
// Copyright (c) 1988-1996, Microsoft Corporation
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

readme.txt       - This file
vblic.h		 - VB Licensing support file declarations
vblic.lib        - VB Licensing support file
vblicd.lib       - VB Licensing support file

------------------------------- LICENSING -------------------------------
OVERVIEW

License enforcement is designed into the OLE Control architecture.  The 
Custom Control Framework provides a simple mechanism for implementing 
custom licensing schemes.  For Visual Basic 5.0 licensed controls, we are 
using the registry to store the license key.  When the control is
created on a form at design time the control's CheckForLicense function
is called.  The control should call VBValidateControlsLicense passing
the license key to validate.  If VBValidateControlsLicense returns TRUE
then the license is valid, otherwise its not valid and your control will
not load at design-time.

When creating an Visual Basic compiled EXE file for a project containing
your control, the GetLicenseKey function will be called to retrive your
EXE license key.  This key will be stored as part of the EXE.  When the
EXE is run, the EXE calls CheckLicenseKey passing in the license key that
was stored at make EXE time.  The code changes below demonstrate using
the same license key for both the design environment and EXE.

REQUIRED CODE CHANGES (using the Custom Control Framework)
1.  If you use the CtlWiz template builder provided with the Framework,
    some of the licensing related code will be generated for you.

    The main .CPP file for the control should contain the following function:

     BOOL CheckForLicense()
     {

     }

2.  Open the main .CPP file for your custom control project and add the 
    following #include statement to the top:

	#include "vblic.h"

3.  To add a license key, run GUIDGEN provided with Microsoft Visual C++ 4.0
4.  Copy the generated guid value and assign it to the g_wszLicenseKey 
    variable in the main .CPP file for the control project.  
    For example:

 	 //Note: The following key is for demonstration purposes only
	 //      You should run GUIDGEN provided with Microsoft Visual C++
	 //      to generate your own unique GUID key.
	 //
	 const WCHAR g_wszLicenseKey [] = L"45DAEA50-4FF7-11cf-8ACB-00AA00C00905";

5. Add the following code to the CheckForLincense function in the main .CPP
   file:

     BOOL CheckForLicense()
     {
	 MAKE_ANSIPTR_FROMWIDE(pszLicense, g_wszLicenseKey);		
	 return VBValidateControlsLicense(pszLicense);	
     }	

6. Add the following code to the CheckLicenseKey function:

     BOOL CheckLicenseKey
     (
         LPWSTR pwszKey
     )
     {
    	 // Compare the passed in license key w/ our EXE license key
	 //
	 return CompareLicenseStringsW(pwszKey, (LPWSTR) g_wszLicenseKey);
     }

7. Add the following code to the GetLicenseKey function:

     BSTR GetLicenseKey
     (
         void
     )
     {
	 // Return our control unique license key
	 //
	 return SysAllocString(g_wszLicenseKey);
     }

BUILDING THE CONTROL
After following the above steps, recompile the code and link with VBLIC.LIB for
a release build of VBLICD.LIB for a debug build.
    
TESTING YOUR LICENSE KEY
To test your license key you will need to add the value assigned to
g_wszLicenseKey to License section of the registry under HKEY_CLASSES_ROOT.
WARNING: DO NOT DISTRIBUTE LICENSE KEY OR THIS INFORMATION WITH YOUR CONTROL.  
The setup program, such as VB, should handle the installation of your control's
license key.  Below are two examples of how you can register your control's
license key.

Example 1, Steps using REGEDIT:
	- Run REGEDIT or REGEDIT32
	- Under the HKEY_CLASSES_ROOT section find Licenses.
        - If Licenses does not exist select Add Key from the Edit menu and add it
          under HKEY_CLASSES_ROOT
        - Select the Licenses key
        - From the Edit menu, select Add Key and enter the license value for the
          key name

Example 2, Steps creating your own .REG file:

	- Run a text editor such as Notepad
	- Enter the following text:

              REGEDIT
              HKEY_CLASSES_ROOT\Licenses = Licensing: Copying the keys may be a violation of established copyrights.

	      // My control license key
              HKEY_CLASSES_ROOT\Licenses\45DAEA50-4FF7-11cf-8ACB-00AA00C00905 = 0

	- Save the file using a .REG extension such as MYCTL.REG
	- Run RegEdit from the command line as follows to register your license key:
		
              RegEdit MYCTL.REG

To test the key:
	- Run VB and attempt to add your control to the form
        - You should be able to add the control without error
        - Exit VB
 	- Run REGEDIT and delete the controls license key from the registry
	- Run VB
	- Attempt to add the control to the form
	- You should encounter an invalid license error attempting to add the
          control to the form
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\locparser\locstudiosdk\readme.txt ===
LocStudio SDK was coppied from nt\admin\wmi\WBEM\SDK\LocStudioParser

it is (was) newer version than one distributed with current (4.2) LocStudio
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\benefits\readme.txt ===
README.TXT

BenefitsSvr Sample Readme 
Copyright (C) 1995-1998 Microsoft Corporation. All Rights Reserved. 

====================================================== 
Notes for BenefitsSvr
====================================================== 

BenefitsSvr is an ATL-based snap-in component for use
with the Microsoft Management Console.

The BenefitsSvr sample demonstrates advanced implementations
of version 1.0 and 1.1 MMC technologies. Version 1.1 of MMC is required
to run this sample, this can be obtained from
http://www.microsoft.com/management/mmc. For basic snap-in
functionality or help on using the ATL Snap-In Wizard,
please refer to the Microsoft Visual C++ 6.0 documentation.

Some of the features that BenefitsSvr demonstrates are:

* Extending the namespace
* Adding unique node types
* Enumerating nodes
* Adding OCX support
* Adding HTML support
* Customizing results
* Extending toolbars
* Extending menus
* Adding toolbar and menu command handlers
* Adding property page support
* Using property pages as snap-in wizards
* Using Taskpads (select the "view web resources" menu item
		on the "health & dental plan" node)

Implementation overviews and details, as well as
architectural notes, are included in the BenefitsSvr Help
system. With the BenefitsSvr snap-in inserted into the 
current MMC console, you can view context-sensitive
and topical help using the F1 function key.

To insert a BenefitsSvr snap-in into the current MMC
console, choose "Add/Remove Snap-in..." from the
"Console" menu. In the "Add/Remove Snap-in" dialog box,
click "Add...". Click the "Benefits (ATL
snap-in wizard sample)" list item and then click "OK" in
the "Add Standalone Snap-in" dialog box.
Click "OK" in the "Add/Remove Snap-in" dialog box to
dismiss it. A BenefitsSvr snap-in node should now be
displayed in your console.

Microsoft Visual C++ 6.0 must be installed in order to
build the BenefitsSvr sample. While a compiled binary is
included with this sample, the source for a Microsoft
Visual Basic 6.0 OCX is also included. If you wish to
modify the OCX, you must have Visual Basic 6.0 installed.

Proper registration of the BenefitsSvr sample and the
included OCX is required for its proper function. While
the BenefitsSvr is registered automatically by the Visual
C++ 6.0 build process, the included OCX must be registered
by hand. To register the OCX, move to the SampCtrl
directory and type:

	regsvr32 SampCtrl.ocx

After the process is complete, you should be presented with
a dialog box confirming successful registration of the control.

An item to be aware of, there have occasionally been some problems
in getting the include directories in VC++ 6.0 correct. The first
entry on your include list should be the MSSDK\include directory,
followed by the MSSDK\include\atl30 directory. Furthermore, to
get the help to function properly in this sample, you will have
to copy BENSVR.CHM by hand to the directory in which the sample
DLL is registered.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\extension.ini ===
HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\SnapIns
    {27E5EC4E-9F2D-11D0-A7D6-00C04FD909DD}
        = REG_SZ "Sample Extension Snapin"
        NameString = REG_SZ "Extension"
        StandAlone
        NodeTypes
            {65ca8054-9f4d-11d0-a7d6-00c04fd909dd}
            {e5092d22-1d7e-11d0-a29b-00c04fd909dd}
            {e6092d22-1d7e-11d0-a29b-00c04fd909dd}



HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes
    {44092d22-1d7e-11d0-a29b-00c04fd909dd}
        = "Sample snapins static node type"
        Extensions
            NameSpace
                {27E5EC4E-9F2D-11D0-A7D6-00C04FD909DD} = "Sample extension snapin"
            PropertySheet
                {27E5EC4E-9F2D-11D0-A7D6-00C04FD909DD} = "Sample extension snapin"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\readme.txt ===
******Other Helpful Documentation******
The MMC SDK Overview contains suggestions for finding additional
programming information that relates to developing snap-ins. 
In terms of convenience, you will find virtually everything you need
to know about COM and Win32 in the Microsoft Platform SDK. Topics 
like structured storage and data objects are beyond the scope of the 
MMC SDK but are covered thoroughly in the material available there.

******Our website******
The current MMC executable and the most recent MMC-related information
is available on our website. You can reach us at the following URL:

    http://www.microsoft.com/management/mmc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\pdc\step4\sample.ini ===
HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\SnapIns
    {18731372-1D79-11D0-A29B-00C04FD909DD}
        = REG_SZ "PDC Sample Snapin"
        NameString = REG_SZ "Sample"
        About = {F0A1B9BE-A172-11D0-A7D7-00C04FD909DD}
        StandAlone
        ColumnPersistence
        NodeTypes
            {44092d22-1d7e-11d0-a29b-00c04fd909dd}
            {55092d22-1d7e-11d0-a29b-00c04fd909dd}
            {66092d22-1d7e-11d0-a29b-00c04fd909dd}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\readme.rtf ===
{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;} {\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;} {\f28\fswiss\fcharset0\fprq2{\*\panose 020b0506020202030204}Arial Narrow;}{\f29\fmodern\fcharset0\fprq1{\*\panose 020b0509030504030204}Lucida Sans Typewriter{\*\falt Lucida Console};}{\f64\froman\fcharset238\fprq2 Times New Roman CE;} {\f65\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f67\froman\fcharset161\fprq2 Times New Roman Greek;}{\f68\froman\fcharset162\fprq2 Times New Roman Tur;}{\f69\froman\fcharset177\fprq2 Times New Roman (Hebrew);} {\f70\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f71\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f72\fswiss\fcharset238\fprq2 Arial CE;}{\f73\fswiss\fcharset204\fprq2 Arial Cyr;}{\f75\fswiss\fcharset161\fprq2 Arial Greek;} {\f76\fswiss\fcharset162\fprq2 Arial Tur;}{\f77\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f78\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f79\fswiss\fcharset186\fprq2 Arial Baltic;}{\f80\fmodern\fcharset238\fprq1 Courier New CE;} {\f81\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f83\fmodern\fcharset161\fprq1 Courier New Greek;}{\f84\fmodern\fcharset162\fprq1 Courier New Tur;}{\f85\fmodern\fcharset177\fprq1 Courier New (Hebrew);} {\f86\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f87\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f288\fswiss\fcharset238\fprq2 Arial Narrow CE;}{\f289\fswiss\fcharset204\fprq2 Arial Narrow Cyr;} {\f291\fswiss\fcharset161\fprq2 Arial Narrow Greek;}{\f292\fswiss\fcharset162\fprq2 Arial Narrow Tur;}{\f295\fswiss\fcharset186\fprq2 Arial Narrow Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0; \red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128; \red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{ \s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\f1\fs32\lang1033\langfe1033\kerning32\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 1;}{\s2\ql \li-1800\ri0\sb140\sa60\sl-380\slmult0 \keepn\widctlpar\nooverflow\faroman\outlinelevel0\rin0\lin-1800\itap0 \b\f28\fs34\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon1 \snext0 heading 2;}{ \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 4;}{ \s5\ql \li0\ri0\sb240\sa60\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\i\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}{\s15\ql \li560\ri0\sl-220\slmult0 \widctlpar\tx950\tx1340\tx1730\tx2120\tx2510\tx2900\tx3290\tx3680\tx4070\tx4460\tx4850\tx5240\tx5630\tx6020\tx6410\tx6800\nooverflow\faroman\rin0\lin560\itap0 \f29\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext15 Exl2;}{ \s16\ql \fi-280\li280\ri0\sa80\sl-240\slmult0\widctlpar\tx280\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext16 Lb1;}{\s17\ql \fi-440\li280\ri0\sa80\sl-240\slmult0\widctlpar \tqr\tx160\tx280\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext17 Ln1;}{\s18\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\tqr\tx160\tx280\nooverflow\faroman\rin0\lin280\itap0  \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon17 \snext18 Lp1;}{\s19\qr \li0\ri0\sl-160\slmult0\widctlpar\nooverflow\faroman\rin0\lin0\itap0 \fs12\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 Le;}{ \s20\ql \fi-360\li0\ri0\sb80\sa80\sl-240\slmult0\keepn\widctlpar\tx280\nooverflow\faroman\rin0\lin0\itap0 \b\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext17 Proch;}{\s21\ql \li0\ri0\sa80\sl-240\slmult0 \keepn\widctlpar\nooverflow\faroman\rin0\lin0\itap0 \v\f28\fs24\cf5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 index;}{\s22\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0  \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext22 Body Text;}}{\*\listtable{\list\listtemplateid-889716058\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0 {\leveltext\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360 \levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1 \levelspace360\levelindent0{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0 \levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23 \leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23 \levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 } {\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040 \jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0  \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1  \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid1372460348}{\list\listtemplateid-2090595180\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat6\levelold\levelspace0 \levelindent360{\leveltext\'03\'00. ;}{\levelnumbers\'01;}\b0\i0\f0\fs21\ulnone\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li365 }{\listname ;}\listid2138140817}}{\*\listoverridetable{\listoverride\listid2138140817 \listoverridecount0\ls1}{\listoverride\listid1372460348\listoverridecount0\ls2}}{\info{\title Building the Samples}{\author RADHAKOT}{\operator RADHAKOT}{\creatim\yr1999\mo12\dy6\hr16\min42}{\revtim\yr1999\mo12\dy7\hr17\min23}{\version16}{\edmins16} {\nofpages3}{\nofwords848}{\nofchars4837}{\*\company Microsoft Corporation}{\nofcharsws0}{\vern8247}}\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\formshade\horzdoc\dgmargin\dghspace180\dgvspace180 \dghorigin1701\dgvorigin1984\dghshow1\dgvshow1\jexpand\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule \fet0\sectd  \linex0\endnhere\sectlinegrid360\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4 \pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (} {\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s2\ql \li-1800\ri0\sb140\sa60\sl-380\slmult0 \keepn\widctlpar\nooverflow\faroman\outlinelevel1\rin0\lin-1800\itap0 \b\f28\fs34\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Building the C++ Samples \par }\pard\plain \s22\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {The MMC C++ sample snap-ins are installed as part of the Microsoft\'ae  Platform SDK. Currently this location has a path similar to the following. Here, it is assumed that D: is the Platform SDK installation drive: \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 { \par }\pard\plain \s15\ql \li560\ri0\sl-220\slmult0\widctlpar\tx950\tx1340\tx1730\tx2120\tx2510\tx2900\tx3290\tx3680\tx4070\tx4460\tx4850\tx5240\tx5630\tx6020\tx6410\tx6800\nooverflow\faroman\rin0\lin560\itap0  \f29\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {D:\\Platform SDK\\Samples\\SysMgmt\\MMC\\ \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs21  \par To build any of the MMC C++ sample snap-ins, the following environment is required: \par  \par {\listtext\pard\plain\s16 \f3\fs21 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard\plain \s16\ql \fi-360\li720\ri0\sa80\sl-240\slmult0\widctlpar\tx280\jclisttab\tx720\nooverflow\faroman\ls2\rin0\lin720\itap0  \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Microsoft Windows 2000, Windows NT 4.0, or Windows 98 operating system \par {\listtext\pard\plain\s16 \f3\fs21 \loch\af3\dbch\af0\hich\f3 \'b7\tab}Microsoft Visual C++ 6.0; or properly installed C++ compiler, linker, and resource compiler that are compatible with Microsoft Visual C++ 6.0  \par {\listtext\pard\plain\s16 \f3\fs21 \loch\af3\dbch\af0\hich\f3 \'b7\tab}Microsoft Windows 2000 RC1 or later version of the Microsoft Platform SDK \par }\pard\plain \s19\qr \li0\ri0\sl-160\slmult0\widctlpar\nooverflow\faroman\rin0\lin0\itap0 \fs12\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs21  \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs21  It is usually wise to install the Platform SDK last. The Platform SDK provides .h (include) files and .lib (library) files needed for MMC and COM functionality coded in the samples.  \par  \par The MMC C++ sample sn ap-ins assume an environment with the Platform SDK properly installed. However, releases of Microsoft Visual C++ after version 6.0 may also provide the Mmc.h include file and Mmc.lib library file needed for compilation. In such cases, installation of the  Platform SDK may not be required to compile the samples.  \par  \par Each sample directory has the necessary source files to build and run the sample. For convenient use in Microsoft Visual Studio, a project file is provided for each sample. This file has the .dsp ex tension. A Samples.dsw workspace file is also provided in the main directory so that you can view and compile all the samples at once from within Visual Studio.}{ \par }\pard\plain \s5\ql \li0\ri0\sb240\sa60\widctlpar\aspalpha\aspnum\faauto\outlinelevel4\adjustright\rin0\lin0\itap0 \b\i\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {To load the appropriate project for a sample from a command prompt \par }\pard\plain \s17\ql \fi-440\li280\ri0\sa80\sl-240\slmult0\widctlpar\tqr\tx160\tx280\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\tab 1.\tab Make sure that the direc tory containing the Msdev.exe executable file of your Visual Studio installation is in your system\rquote s path. \par \tab 2.\tab Run Visual Studio at the command prompt in the sample\rquote s directory as follows: \par }\pard\plain \s15\ql \li560\ri0\sl-220\slmult0\widctlpar\tx950\tx1340\tx1730\tx2120\tx2510\tx2900\tx3290\tx3680\tx4070\tx4460\tx4850\tx5240\tx5630\tx6020\tx6410\tx6800\nooverflow\faroman\rin0\lin560\itap0  \f29\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {MSDEV <MYSAMPLE>.DSP \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 { \par }{\fs21 You can also simply double-click the .dsp file in Windows Explorer to load a sample\rquote  s workspace into Visual Studio. From within Visual Studio you can then browse the C++ classes of the sample source and generally perform the other edit-compile-debug operations.  \par  \par Note that, as part of the Platform SDK, the compilation of these samples from within Visual Studio requires the proper setting of directory paths in Visual Studio.  \par }\pard\plain \s5\ql \li0\ri0\sb240\sa60\widctlpar\aspalpha\aspnum\faauto\outlinelevel4\adjustright\rin0\lin0\itap0 \b\i\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i0 To }{set the directory paths (assuming Visual Studio 6.0)  \par }\pard\plain \s17\ql \fi-440\li280\ri0\sa80\sl-240\slmult0\widctlpar\tqr\tx160\tx280\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\tab 1.\tab Run Microsoft Visual Studio (Visual C++).  \par \tab 2.\tab On the }{\b Tools}{ menu, click }{\b Options}{.  \par \tab 3.\tab In the }{\b Options}{ dialog box, click the }{\b Directories}{ tab.  \par \tab 4.\tab In the }{\b Show Directories For}{ drop-down list box, select \'93Executable files\'94 and enter the Bin directory path for your installed Platform SDK (for example, D:\\Platform SDK\\ Bin). Click the up arrow button to move this newly entered path so that it is the first entry in the \'93Directories\'94 list.  \par \tab 5.\tab In the }{\b Show Directories For}{ drop-down list box, select \'93Include files\'94 and enter the INCLUDE directory path for your installed Platform SDK (for example, D:\\Platform SDK\\ Include). Click the up arrow button to move this newly entered path so that it is the first entry in the \'93Directories\'94 list. \par }\pard\plain \s18\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\tqr\tx160\tx280\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Follow the same procedure for adding the INCLUDE\\Win64\\mfc and INCLUDE\\Win64\\ crt directory paths to the list of include files. These paths can follow the INCLUDE directory path in the list. Note that INCLUDE refers to the directory path for your installed Platform SDK. \par }\pard\plain \s17\ql \fi-440\li280\ri0\sa80\sl-240\slmult0\widctlpar\tqr\tx160\tx280\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\tab 6.\tab In the }{\b Show Directories For}{ drop-down list box, select  \'93Library files\'94 and enter the Lib directory path for your installed Platform SDK (for example, D:\\Platform SDK\\Lib). Click the up arrow button to move this newly entered path so that it is the first entry in the \'93Directories\'94 list.  \par \tab 7.\tab In the }{\b Options}{ dialog box, click }{\b OK}{ to complete the settings.  \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 { \par }{\fs21 From there you can use the editor, debugger, and project facilities to edit, compile, link, and debug.  \par }\pard\plain \s2\ql \li-1800\ri0\sb140\sa60\sl-380\slmult0\keepn\widctlpar\nooverflow\faroman\outlinelevel1\rin0\lin-1800\itap0 \b\f28\fs34\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Building ANSI or Unicode Versions of the C++ Samples \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs21 All of the MMC C++ samples can be built in both ANSI and Unicode environ ments. When building a Unicode version of a sample, you should ensure that the proper preprocessor settings are entered in the project settings of the sample\rquote s .dsp project file. \par }\pard\plain \s5\ql \li0\ri0\sb240\sa60\widctlpar\aspalpha\aspnum\faauto\outlinelevel4\adjustright\rin0\lin0\itap0 \b\i\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {To build a Unicode version of a sample \par }\pard\plain \s17\ql \fi-440\li280\ri0\sa80\sl-240\slmult0\widctlpar\tqr\tx160\tx280\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\tab 1.\tab Load the sample\rquote s .dsp project fil e in Microsoft Visual Studio (Visual C++).  \par \tab 2.\tab On the }{\b Tools}{ menu, click }{\b Project}{.  \par \tab 3.\tab In the }{\b Settings For}{ drop-down list box, select \'93Win32 Release\'94 for a release build or \'93Win32 Debug\'94 for a debug build. \par \tab 4.\tab In the }{\b Project Settings}{ dialog box, click the }{\b C/C++}{ tab.  \par \tab 5.\tab In the }{\b Preprocessor definitions}{ field, make sure that the UNICODE and _UNICODE definitions are included. If not, add them. \par {\pntext\pard\plain\s17 \fs21 \hich\af0\dbch\af0\loch\f0 6. \tab}}\pard \s17\ql \fi-360\li365\ri0\sa80\sl-240\slmult0\widctlpar\tqr\tx160\tx280{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec\pnb0\pni0\pnfs21\pnstart6\pnindent360\pnhang{\pntxta . }} \nooverflow\faroman\ls1\rin0\lin365\itap0 {In the }{\b Project Settings}{ dialog box, click }{\b OK}{ to complete the settings.  \par }\pard\plain \s19\qr \li0\ri0\sl-160\slmult0\widctlpar\nooverflow\faroman\rin0\lin0\itap0 \fs12\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 { \par }\pard\plain \s2\ql \li-1800\ri0\sb140\sa60\sl-380\slmult0\keepn\widctlpar\nooverflow\faroman\outlinelevel1\rin0\lin-1800\itap0 \b\f28\fs34\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Using the Help C++ Sample \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs21 The HTML Help file for the Help sample is Snapsamp.chm. You can find this file in the \'93help source\'94  subdirectory for the Help sample. Assuming that that D: is the Platform SDK installation drive, Snapsamp.chm is located in: \par }{ \par }\pard\plain \s15\ql \li560\ri0\sl-220\slmult0\widctlpar\tx950\tx1340\tx1730\tx2120\tx2510\tx2900\tx3290\tx3680\tx4070\tx4460\tx4850\tx5240\tx5630\tx6020\tx6410\tx6800\nooverflow\faroman\rin0\lin560\itap0  \f29\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {D:\\Platform SDK\\Samples\\SysMgmt\\MMC\\Help\\Help source\\ \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 { \par }{\fs21 The Help sample assumes that Snapsamp.chm is located in the system help directory (usually C:\\WINNT\\Help on Microsoft Windows 2000). Therefore, before loading the Help sample into an MMC console, copy Snapsamp.chm to the system help directory. \par  \par }\pard\plain \s2\ql \li-1800\ri0\sb140\sa60\sl-380\slmult0\keepn\widctlpar\nooverflow\faroman\outlinelevel1\rin0\lin-1800\itap0 \b\f28\fs34\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Using the WMI C++ Sample \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs21 The WMI sample connects to the }{\fs21 root\\Vehicles namespace }{\fs21 in the WMI Repository. This  namespace }{\fs21 is created by compiling the Vehicles.mof MOF file that is part of the WMI sample. To compile the Vehicles.mof file, }{\fs21 first make sure that the WMI service is properly installed and running. Then, }{\fs21  run the following command in a command prompt from within the WMI sample directory }{\i\fs21 before }{\fs21 loading the sample in an MMC console. Here we assume that that th}{\fs21 e WMI sample is located in the D}{\fs21 :\\Platform SDK\\Samples\\SysMgmt \\MMC\\WMI directory: \par  \par }\pard\plain \s15\ql \li560\ri0\sl-220\slmult0\widctlpar\tx950\tx1340\tx1730\tx2120\tx2510\tx2900\tx3290\tx3680\tx4070\tx4460\tx4850\tx5240\tx5630\tx6020\tx6410\tx6800\nooverflow\faroman\rin0\lin560\itap0  \f29\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {wmi_sample_dir:\\>MOFComp Vehicles.mof \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs21  \par Note that the MOFComp.exe executable is installed in the system32\\wbem directory. For details about MOF files and the MOFComp compiler, see the "Managed Object Format (MOF) Language" topic and related topics in the Platform SDK documentation.}{\fs21  \par }{ \par }\pard\plain \s2\ql \li-1800\ri0\sb140\sa60\sl-380\slmult0\keepn\widctlpar\nooverflow\faroman\outlinelevel1\rin0\lin-1800\itap0 \b\f28\fs34\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Building the MMC Snap-in Designer for Visual Basic Samples \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs21 Refer to the \'93Snap-in Designer Samples\'94 subtopic in the \'93Microsoft Management Console\'94  topic in the Microsoft Platform SDK documentation for details about building and running the Snap-in Designer samples. \par }\pard\plain \s2\ql \li-1800\ri0\sb140\sa60\sl-380\slmult0\keepn\widctlpar\nooverflow\faroman\outlinelevel1\rin0\lin-1800\itap0 \b\f28\fs34\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {MMC Snap-in Designer for Visual Basic - Known Issue \par }\pard\plain \ql \li0\ri0\widctlpar\faauto\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1\fs20  \par }{\b\fs21 Symptom}{\fs21 : MMC performs an access violation (AV) while debugging configuration wizards or property pages on Windows 95, Windows 98 or NT4 with Service Pack 5 or less. \par  \par }\pard \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\b\fs21 Work Around}{\fs21 : On Windows 95 and Windows 98 there is no known work around.  On NT4, please upgrade to Service Pack 6. \par }}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\compman.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Corp. Extending Computer Management Title _PID_HLINKSExtending Computer Management RADHAKOT Normal.dot RADHAKOT Microsoft Word 9.0ib{=h g:^` @ $dAf$dAfC:\DOCUME~1\DOCUME~1\DEREKJ~1\LOCALS~1\Temp\ServicesExt.docbjbjU Extending Computer Management The Computer Management snap-in offers the following extensibility features: Computer Management provides a clipboard format containing the name of the current target computer. All extensions should consume this information to retarget properly. A mechanism is provided to have an extension snap-in appear only when the service it is managing is actually installed on that particular machine Extendable Node Types The following table lists the GUIDs of the extendable nodetype that Computer Management makes available. Note that all the node types listed in the table correspond to scope items. Display Name Nodetype GUID Computer Management {476e6446-aaff-11d0-b944-00c04fd8d5b0} System Tools {476E6448-AAFF-11D0-B944-00C04FD8D5B0} Services and Applications {476E6449-AAFF-11D0-B944-00C04FD8D5B0} Storage {476e644a-aaff-11d0-b944-00c04fd8d5b0} Generally, snap-in developers can write extensions of any type for the node types listed above. However, namespace extensions to the Computer Management scope item are discouraged. This is because the structure of namespace items in Computer Management is designed to organize management functionality into 3 groups: system tools, services and applications, and storage. If extension snap-ins add new groups, this will make it more difficult for users to find what they need in the existing groups.  Also, the Services and Applications scope item is generally extended by dynamic namespace extensions. Required Clipboard Formats The following table lists the clipboard formats required for making use of Computer Management s extensibility features: Clipboard Format Description MMC_SNAPIN_MACHINE_NAME Used for retargetting. Provides the name of the machine that Computer Management currently targets.  Extending Computer Management   Sample Scenario There are number of different ways of extending Computer Management. In this section, we ll consider a sample scenario that can be realized by extending one of the scope items of Computer Management. Here s the scenario: You provide a services application that conforms to the interface rules of the Windows NT/2000 Service Control Manager (SCM). You want users of your service to be able to modify the status of the service from within the Computer Management snap-in. Also, when Computer Management is retargetted to another machine, users should be able to modify the status of the service on the new machine (if the service is installed on that machine.)  To realize this scenario, you need to do the following things: Create a namespace extension that extends the Applications and Services scope item by adding its own child scope item. Implement retargetting of your namespace extension when Computer Management is retargetted. Install your service application on the system(s) on which it is to run. Use the Services APIs to properly write your service and install it on host machines. Add the functionality that allows users to modify the status of your service. This document covers only the first of the above steps. For details about creating and installing a service application, refer to the Platform SDK documenation. Details about Step 3 are covered in the document  HYPERLINK "ServicesExt.doc" Using the Services Extension Snap-in . This document is available on the Snap-in Gallery. The ExtSnap Sample Snap-in A sample snap-in, ExtSnap, is available. The sample demonstrates how to implement the scenario covered in this section. The sample snap-in is written in C++ and makes use of the ATL COM Appwizard. Note that all the code snippets in the remaining part of this document are taken from this sample. The ExtSnap source files can be downloaded from the following Web site: HYPERLINK "\\\\bosrc\\sources\\SRC\\MMCSamp\\atl_samp\\extsnap" \\bosrc\sources\SRC\MMCSamp\atl_samp\extsnap Extending the Applications and Services Scope Item To extend Applications and Services, you need to do the following things: Create a namespace extension snap-in. Allow your extension snap-in to be retargetted (if necessary). Register your snap-in as a namespace extension to the Applications and Services scope item. Creating a Namespace Extension Snap-in For general information about creating a namespace extension snap-in, see the  Extending a Primary Snap-in's Namespace  topic and related topics in the MMC section of the Platform SDK documentation. This section discusses how to handle the MMCN_EXPAND notification.  The following code snippet taken from the sample snap-in demonstrates how to handle the MMCN_EXPAND notification: case MMCN_EXPAND:     GUID myGuid;     GUID* pGUID= &myGuid;     hr = ExtractObjectTypeGUID(lpDataObject, pGUID);    _ASSERT( S_OK == hr );         if (IsEqualGUID(*pGUID, getPrimaryNodeType()))     {         HRESULT hr = ExtractString(lpDataObject, s_cfMachineName, m_szMachineName, sizeof(m_szMachineName));         /* Uncomment following three lines of code to disable re-targeting of this snap-in. */ //      if ( _tcslen(m_szMachineName) ) // Non-zero string length indicates remote machine //         return hr = S_FALSE; //      else         hr = OnExpand(m_ipConsoleNameSpace2, m_ipConsole2, (HSCOPEITEM)param);     }     else     // currently selected node is one of ours instead     {        CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();        hr = base->OnExpand(m_ipConsoleNameSpace2, m_ipConsole2, (HSCOPEITEM)param);     }     break; When the extension snap-in receives the MMCN_EXPAND notification message in a call to its IComponentData::Notify implementation, it must first determine if the data object passed in the method call belongs to the primary snap-in (Computer Management), or whether the data object is one of its own. The ExtractObjectTypeGUID helper function is used to request the currently selected scope item s nodetype GUID from the data object. The getPrimaryNodeType function returns the GUID of the node type that the extension snap-in extends. If the values returned by the two functions match, the scope item belongs to a primary snap-in. The extension snap-in then adds its own items underneath it. The data object passed to the namespace extension supports the MMC_SNAPIN_MACHINE_NAME clipboard format. Before inserting its own scope item, the namespace extension calls the ExtractString helper function with the MMC_SNAPIN_MACHINE_NAME clipboard format to request the current machine name, which is then stored in the m_szMachineName member variable. The ExtractString helper function is defined as follows: HRESULT CClassExtSnap::ExtractString( IDataObject *piDataObject,                                              CLIPFORMAT   cfClipFormat,                                              _TCHAR       *pstr,                                              DWORD        cchMaxLength)     return ExtractData( piDataObject, cfClipFormat, (PBYTE)pstr, cchMaxLength ); ExtractData is a generic helper function for extracting data of a specified clipboard format from a specified data object: HRESULT CClassExtSnap::ExtractData( IDataObject* piDataObject,                                            CLIPFORMAT   cfClipFormat,                                            BYTE*        pbData,                                            DWORD        cbData )     HRESULT hr = S_OK;     FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};     STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};     stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);     do // false loop     {         if (NULL == stgmedium.hGlobal)         {             hr = E_OUTOFMEMORY;             break;         }         hr = piDataObject->GetDataHere( &formatetc, &stgmedium );         if ( FAILED(hr) )         {             break;         }                  BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);         if (NULL == pbNewData)         {             hr = E_UNEXPECTED;             break;         }         ::memcpy( pbData, pbNewData, cbData );     } while (FALSE); // false loop     if (NULL != stgmedium.hGlobal)     {         ::GlobalFree(stgmedium.hGlobal);     }     return hr; } // ExtractData() Retargetting your Extension Snap-in Extensions snap-ins of any type can be retargetted to another computer when the user retargets Computer Management. One important thing to keep in mind when writing a namespace extension snap-in is that MMC associates with every root node of a console a list of IComponentData instances, where each IComponentData is for a particular snap-in (as identified by its CLSID). For a particular namespace extension, all its scope items anywhere under that console root node are serviced by one IComponentData instance.  With this in mind, here is what happens to your namespace extension s IComponentData instance when Computer Management is targetted at one machine and then retargetted: The user expands the Computer Management console root node (targetted, let's say, at the local computer) and Computer Management creates the Applications and Services scope item targetted at the local computer. The user expands the Applications and Services scope item. Because there is currently no instance of your extension snap-in under this Computer Management console root node, MMC creates one and associates it with the console root node and with your snap-in s CLSID. Your IComponentData::Notify method is called with the MMCN_EXPAND notification . The data object passed to your namespace extension in the method call supports the MMC_SNAPIN_MACHINE_NAME clipboard format. You can call the GetDataHere method on the data object with this clipboard format to request the current machine name that Computer Management (and Applications and Services) is targetted to. You can store this information with either your child scope items or with the IComponentData instance. The user tells Computer Management to retarget to another machine. In response, Computer Management deletes the Applications and Services scope item. Your IComponentData::Notify method is called with the MMCN_REMOVE_CHILDREN notification. Your namespace extension should destroy all resources for the subtree it added under Applications and Services scope item. MMC takes care of removing the items for the scope pane, so your snap-in need not call IConsoleNameSpace2::DeleteItem. Note that your IComponentData is not released - MMC will use it for the life of the Computer Management console root node. MMC creates a new Applications and Services scope item targetted at the new machine. When the user expands this item, your same IComponentData will get another MMCN_EXPAND notification. You should read the new current machine name and store this information with either your IComponentData instance or your child scope items. Registering the Snap-in as a Namespace Extension  The following registration snippet taken from the .rgs file for the sample snap-in shows the appropriate registery settings that you will need: HKLM      NoRemove Software     {         NoRemove Microsoft         {             NoRemove MMC             {                 NoRemove NodeTypes                 {                     NoRemove {476e6449-aaff-11d0-b944-00c04fd8d5b0}                     {                         NoRemove Extensions                         {                             NoRemove NameSpace                             {                                 val '{3F40BB91-D7E4-4A37-9DE7-4D837B30F998}' =                                 s 'ATL-based extension snap-in sample'                             }                             NoRemove 'Dynamic Extensions'                             {                                 val '{3F40BB91-D7E4-4A37-9DE7-4D837B30F998}' =                                  s 'ATL-based extension snap-in sample'                             }                         }                     }                             }             }         }     } The GUID {476e6449-aaff-11d0-b944-00c04fd8d5b0}is the nodetype GUID of the  Applications and Services scope item. The GUID {3F40BB91-D7E4-4A37-9DE7-4D837B30F998} is the CLSID of the sample snap-in. This should be replaced by the CLSID of your namespace extension. As you can see, the sample snap-in is a dynamic namespace extension to the Applications and Services scope item. This is discussed later on in this document. Dynamically Extending Applications and Services Namespace extensions to the Applications and Services scope item are typically dynamic namespace extensions. This ensures that your snap-in extends only the specific instance of the Applications and Services item. Other scope items of the same nodetype as Applications and Services are not affected. To register your namespace extension as a dynamic extension to Computer Management, you need to add the appropriate registery settings. See the registration snippet in the  Extending the Applications and Services Scope Item  above for sample settings. In addition to the registry requirements imposed by MMC, your namespace extension s CLSID must also be registered under the HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Server Applications key. This registration should be done when your service is installed. When your service is un-installed, the registry settings for your snap-in should be removed. Note that it is important that you add your snap-in s CLSID under the HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Server Applications only when the underlying service is installed, not when your snap-in is installed. Otherwise, MMC dynamic extensibility feature may not work properly. Also note that the sample snap-in performs this registration when its DLL (ExtSnap.dll) is registered. This of course contradicts the statement above. The snap-in uses the Windows Alerter service to demonstrate how to modify the status of a service. Since this is a NT standard service that is installed during installation of the OS, performing this registration at that time was impossible. As a result, the sample snap-in has to add the appropriate regisration entries itself.  The following registry snippet taken from the .rgs for the sample snap-in shows this: HKLM      NoRemove SYSTEM     {         NoRemove CurrentControlSet         {             NoRemove Control             {                 NoRemove 'Server Applications'                 {                     val '{3F40BB91-D7E4-4A37-9DE7-4D837B30F998}' =                      s 'ATL-based extension snap-in sample'                 }             }         }     } The GUID {3F40BB91-D7E4-4A37-9DE7-4D837B30F998} is the CLSID of the sample snap-in. This should be replaced by the CLSID of your namespace extension.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\servicesext.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Corp. Extending Computer Management Title _PID_HLINKSExtending Computer Management RADHAKOT Normal.dot RADHAKOT Microsoft Word 9.0compman.docbjbjU Using the Services Extension Snap-in The Services Extension Snap-in can be used to extend the context menu of scope and result items. The snap-in adds Start, Stop, Pause, Resume, and Restart menu items to the context menu of the node type it extends. These menu items can then be used to modify the status of a services application that conforms to the interface rules of the Windows NT/2000 Service Control Manager (SCM). Required Clipboard Formats The following table lists the clipboard formats required for making use of the Services Extension Snap-in: Clipboard Format Description MMC_SNAPIN_MACHINE_NAME Provides the name of the machine on which the service is installed.  FILEMGMT_SNAPIN_SERVICE_NAME Provides the name of the service.  FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME Provides the display name for the service as it should appear in the context menu items. Using the Services Extension Snap-in   Sample Scenario In this section, we ll consider a sample scenario that makes use of the Services Extension Snap-in. Here s the scenario: You provide a services application that conforms to the interface rules of the Windows NT/2000 Service Control Manager (SCM). You want users of your service to be able to modify the status of the service from within the Computer Management snap-in. Also, when Computer Management is retargetted to another machine, users should be able to modify the status of the service on the new machine (if the service is installed on that machine.)  To realize this scenario, you need to do the following things: Create a namespace extension that extends the Applications and Services scope item of Computer Management by adding its own child scope item. Implement retargetting of your namespace extension when Computer Management is retargetted. Install your service application on the system(s) on which it is to run. Use the Services APIs to properly write your service and install it on host machines. Add the functionality that allows the Services Extension Snap-in to extend the context menu of item(s) added by your namespace extension snap-in. This document covers only the last of the above steps. For details about creating and installing a service application, refer to the Platform SDK documenation. For details about writing a namespace extension to the Applications and Services scope item of Computer Management, see the document  HYPERLINK "compman.doc" Extending Computer Management . This document is available on the Snap-in Gallery. The ExtSnap Sample Snap-in A sample snap-in, ExtSnap, is available. The sample demonstrates how to implement the scenario covered in this section. The sample snap-in is written in C++ and makes use of the ATL COM Appwizard. Note that all the code snippets in the remaining part of this document are taken from this sample. The ExtSnap source files can be downloaded from the following Web site: HYPERLINK "\\\\bosrc\\sources\\SRC\\MMCSamp\\atl_samp\\extsnap" \\bosrc\sources\SRC\MMCSamp\atl_samp\extsnap Adding Start/Stop/Pause/Resume/Restart Menu Items to your Context Menus To use this functionality in your snap-in: Make sure that your service is properly installed. Register the nodetype GUID of your snap-in s scope or result item that should be extended by Services Extension Snap-in. Add the appropriate registry entries that indicate that Services Extension Snap-in should be a context menu extension for the nodetype GUID you registered in the previous step. Support the following clipboard formats in your snap-in s IDataObject::GetDataHere method:  MMC_SNAPIN_MACHINE_NAME FILEMGMT_SNAPIN_SERVICE_NAME FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME Registration Settings The node type GUID of your extendable scope or result item should be registered under the HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\SnapIns\{snapinCLSID}\NodeTypes key, where {snapinCLSID} is the CLSID of the snap-in.  The following registration snippet from the .rgs file for the sample snap-in shows this: HKLM      NoRemove Software     {         NoRemove Microsoft         {             NoRemove MMC             {                 NoRemove Snapins                 {                     ForceRemove {3F40BB91-D7E4-4A37-9DE7-4D837B30F998} =                         s 'ATL-based extension snap-in sample'                      {                         val NameString = s 'ATL-based extension snap-in sample'                         val About = s '{4E7F429A-9A8A-4FA5-BBA0-10EB183898D1}'                                                      ForceRemove NodeTypes                         {                             ForceRemove {28D4F536-BDB5-4bc5-BA88-5375A4996850} =                              s 'Extendable scope node of ATL-based extension snap-in sample'                         }                     }                             }             }         }     } The CLSID of the Services Extension Snap-in must be registered under the HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes\{nodetypeGUID}\Extensions\ContextMenu key, where {nodetypeGUID} is the nodetype GUID registered under the HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\SnapIns\{snapinCLSID}\NodeTypes key. The following registration snippet from the .rgs file for the sample snap-in shows this: HKLM      NoRemove Software     {         NoRemove Microsoft         {             NoRemove MMC             {                 NoRemove NodeTypes                 {                     NoRemove {28D4F536-BDB5-4bc5-BA88-5375A4996850} =                      s 'Extendable scope node of ATL-based extension snap-in sample'                     {                         NoRemove Extensions                         {                             NoRemove ContextMenu                             {                                 val '{58221C6A-EA27-11CF-ADCF-00AA00A80033}' =                                 s 'System Service Management Extension'                             }                         }                     }                             }             }         }     } The GUID {58221C6A-EA27-11CF-ADCF-00AA00A80033} is the CLSID of Services Extension Snap-in s cocreatable class object, which exposes the snap-in s IExtendContextMenu interface to MMC. Supporting the Necessary Clipboard Formats As stated earlier, the Services Extension Snap-in requires the following three clipboard formats: Clipboard Format Description MMC_SNAPIN_MACHINE_NAME Provides the machine name that is currently targetted by your snap-in. FILEMGMT_SNAPIN_SERVICE_NAME Provides the name of the service whose status you want to be able to modify. This name must a service name that is known to the Service Control Manager (SCM) and which is maintained in its database of installed services. FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME Provides the display name for the service that will appear in the context menu items. The following code snippets taken from the sample snap-in s IDataObject::GetDataHere implementation show sample implementations of these three clipboard formats: } else if (cf == s_cfSnapinMachineName) { LPOLESTR wszName = NULL; const _TCHAR *pszName = base->GetMachineName(); wszName = (LPOLESTR)T2COLE(pszName); // get length of original string and convert it accordingly ULONG ulSizeofName = lstrlen(pszName); ulSizeofName++;  // Count null character ulSizeofName *= sizeof(WCHAR); hr = pStream->Write(wszName, ulSizeofName, NULL); } else if (cf == s_cfServiceName) { LPOLESTR wszName = NULL; static _TCHAR buf[128]; _stprintf(buf, _T("Alerter")); wszName = (LPOLESTR)T2COLE(buf);          // get length of original string and convert it accordingly ULONG ulSizeofName = lstrlen(buf);          ulSizeofName++;  // Count null character          ulSizeofName *= sizeof(WCHAR);          hr = pStream->Write(wszName, ulSizeofName, NULL); } else if (cf == s_cfServiceDisplayName) { LPOLESTR wszName = NULL; static _TCHAR buf[128]; _stprintf(buf, _T("Alerter")); wszName = (LPOLESTR)T2COLE(buf); // get length of original string and convert it accordingly          ULONG ulSizeofName = lstrlen(buf);          ulSizeofName++;  // Count null character          ulSizeofName *= sizeof(WCHAR);         hr = pStream->Write(wszName, ulSizeofName, NULL); T2COLE is an ATL string conversion macro for converting an LPTSTR or LPWSTR (depending on compiler directive) to an LPCOLESTR. The s_cfSnapinMachineName, s_cfServiceName, and s_ cfServiceDisplayName variables are defined and implemented as follows: static UINT s_cfServiceName; static UINT s_cfServiceDisplayName; static UINT s_cfSnapinMachineName; #define _T_FILEMGMT_SNAPIN_SERVICE_NAME _T("FILEMGMT_SNAPIN_SERVICE_NAME") #define _T_FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME _T("FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME") #define _T_CCF_SNAPIN_MACHINE_NAME _T("MMC_SNAPIN_MACHINE_NAME") //Additional formats needed for allowing our snap-in to be extended by //System Service Management Extension UINT CDataObject::s_cfServiceName = RegisterClipboardFormat(_T_FILEMGMT_SNAPIN_SERVICE_NAME); UINT CDataObject::s_cfServiceDisplayName = RegisterClipboardFormat(_T_FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME); UINT CDataObject::s_cfSnapinMachineName = RegisterClipboardFormat (_T_CCF_SNAPIN_MACHINE_NAME); In the code snippet above, the GetMachineName function returns the current machine name: _TCHAR* GetMachineName() { return m_szMachineName; } To fill the value of the m_szMachineName variable, the snap-in uses the MMC_SNAPIN_MACHINE_NAME clipboard format to query the data object (from the Applications and Services scope item) passed into the snap-in s IComponentData::Notify method during an MMCN_EXPAND notification. The MMC_SNAPIN_MACHINE_NAME clipboard format is therefore used by both your snap-in and by the Services Extension Snap-in for querying for the current machine name.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\samples\sdksamples\atl_samp\extsnap\readme.rtf ===
{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;} {\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;} {\f28\fswiss\fcharset0\fprq2{\*\panose 020b0506020202030204}Arial Narrow;}{\f29\fmodern\fcharset0\fprq1{\*\panose 020b0509030504030204}Lucida Sans Typewriter{\*\falt Lucida Console};}{\f64\froman\fcharset238\fprq2 Times New Roman CE;} {\f65\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f67\froman\fcharset161\fprq2 Times New Roman Greek;}{\f68\froman\fcharset162\fprq2 Times New Roman Tur;}{\f69\froman\fcharset177\fprq2 Times New Roman (Hebrew);} {\f70\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f71\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f72\fswiss\fcharset238\fprq2 Arial CE;}{\f73\fswiss\fcharset204\fprq2 Arial Cyr;}{\f75\fswiss\fcharset161\fprq2 Arial Greek;} {\f76\fswiss\fcharset162\fprq2 Arial Tur;}{\f77\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f78\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f79\fswiss\fcharset186\fprq2 Arial Baltic;}{\f80\fmodern\fcharset238\fprq1 Courier New CE;} {\f81\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f83\fmodern\fcharset161\fprq1 Courier New Greek;}{\f84\fmodern\fcharset162\fprq1 Courier New Tur;}{\f85\fmodern\fcharset177\fprq1 Courier New (Hebrew);} {\f86\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f87\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f288\fswiss\fcharset238\fprq2 Arial Narrow CE;}{\f289\fswiss\fcharset204\fprq2 Arial Narrow Cyr;} {\f291\fswiss\fcharset161\fprq2 Arial Narrow Greek;}{\f292\fswiss\fcharset162\fprq2 Arial Narrow Tur;}{\f295\fswiss\fcharset186\fprq2 Arial Narrow Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0; \red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128; \red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{ \s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\f1\fs32\lang1033\langfe1033\kerning32\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 1;}{\s2\ql \li-1800\ri0\sb140\sa60\sl-380\slmult0 \keepn\widctlpar\nooverflow\faroman\outlinelevel0\rin0\lin-1800\itap0 \b\f28\fs34\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon1 \snext0 heading 2;}{ \s4\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 4;}{ \s5\ql \li0\ri0\sb240\sa60\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\i\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}{\s15\ql \li560\ri0\sl-220\slmult0 \widctlpar\tx950\tx1340\tx1730\tx2120\tx2510\tx2900\tx3290\tx3680\tx4070\tx4460\tx4850\tx5240\tx5630\tx6020\tx6410\tx6800\nooverflow\faroman\rin0\lin560\itap0 \f29\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext15 Exl2;}{ \s16\ql \fi-280\li280\ri0\sa80\sl-240\slmult0\widctlpar\tx280\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext16 Lb1;}{\s17\ql \fi-440\li280\ri0\sa80\sl-240\slmult0\widctlpar \tqr\tx160\tx280\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext17 Ln1;}{\s18\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\tqr\tx160\tx280\nooverflow\faroman\rin0\lin280\itap0  \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon17 \snext18 Lp1;}{\s19\qr \li0\ri0\sl-160\slmult0\widctlpar\nooverflow\faroman\rin0\lin0\itap0 \fs12\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 Le;}{ \s20\ql \fi-360\li0\ri0\sb80\sa80\sl-240\slmult0\keepn\widctlpar\tx280\nooverflow\faroman\rin0\lin0\itap0 \b\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext17 Proch;}{\s21\ql \li0\ri0\sa80\sl-240\slmult0 \keepn\widctlpar\nooverflow\faroman\rin0\lin0\itap0 \v\f28\fs24\cf5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 index;}{\s22\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0  \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext22 Body Text;}}{\*\listtable{\list\listtemplateid-889716058\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0 {\leveltext\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360 \levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li1440\jclisttab\tx1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1 \levelspace360\levelindent0{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2160\jclisttab\tx2160 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0 \levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li2880\jclisttab\tx2880 }{\listlevel\levelnfc23\levelnfcn23 \leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li3600\jclisttab\tx3600 }{\listlevel\levelnfc23 \levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li4320\jclisttab\tx4320 } {\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698689\'01\u-3913 ?;}{\levelnumbers;}\f3\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li5040 \jclisttab\tx5040 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698691\'01o;}{\levelnumbers;}\f2\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0  \fi-360\li5760\jclisttab\tx5760 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698693\'01\u-3929 ?;}{\levelnumbers;}\f14\chbrdr\brdrnone\brdrcf1  \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li6480\jclisttab\tx6480 }{\listname ;}\listid1372460348}{\list\listtemplateid-2090595180\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat6\levelold\levelspace0 \levelindent360{\leveltext\'03\'00. ;}{\levelnumbers\'01;}\b0\i0\f0\fs21\ulnone\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li365 }{\listname ;}\listid2138140817}}{\*\listoverridetable{\listoverride\listid2138140817 \listoverridecount0\ls1}{\listoverride\listid1372460348\listoverridecount0\ls2}}{\info{\title Building the Samples}{\author RADHAKOT}{\operator RADHAKOT}{\creatim\yr1999\mo12\dy6\hr16\min42}{\revtim\yr2000\mo1\dy10\hr14\min6}{\version17}{\edmins16} {\nofpages2}{\nofwords671}{\nofchars3827}{\*\company Microsoft Corporation}{\nofcharsws4699}{\vern8247}}\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\formshade\horzdoc\dgmargin\dghspace180\dgvspace180 \dghorigin1701\dgvorigin1984\dghshow1\dgvshow1\jexpand\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule \fet0\sectd  \linex0\endnhere\sectlinegrid360\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4 \pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (} {\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s2\ql \li-1800\ri0\sb140\sa60\sl-380\slmult0 \keepn\widctlpar\nooverflow\faroman\outlinelevel1\rin0\lin-1800\itap0 \b\f28\fs34\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Building the C++ Samples \par }\pard\plain \s22\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {The MMC C++ sample snap-ins are installed as part of the Microsoft\'ae  Platform SDK. Currently this location has a path similar to the following. Here, it is assumed that D: is the Platform SDK installation drive: \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 { \par }\pard\plain \s15\ql \li560\ri0\sl-220\slmult0\widctlpar\tx950\tx1340\tx1730\tx2120\tx2510\tx2900\tx3290\tx3680\tx4070\tx4460\tx4850\tx5240\tx5630\tx6020\tx6410\tx6800\nooverflow\faroman\rin0\lin560\itap0  \f29\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {D:\\Platform SDK\\Samples\\SysMgmt\\MMC\\ \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs21  \par To build any of the MMC C++ sample snap-ins, the following environment is required: \par  \par {\listtext\pard\plain\s16 \f3\fs21 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard\plain \s16\ql \fi-360\li720\ri0\sa80\sl-240\slmult0\widctlpar\tx280\jclisttab\tx720\nooverflow\faroman\ls2\rin0\lin720\itap0  \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Microsoft Windows 2000, Windows NT 4.0, or Windows 98 operating system \par {\listtext\pard\plain\s16 \f3\fs21 \loch\af3\dbch\af0\hich\f3 \'b7\tab}Microsoft Visual C++ 6.0; or properly installed C++ compiler, linker, and resource compiler that are compatible with Microsoft Visual C++ 6.0  \par {\listtext\pard\plain\s16 \f3\fs21 \loch\af3\dbch\af0\hich\f3 \'b7\tab}Microsoft Windows 2000 RC1 or later version of the Microsoft Platform SDK \par }\pard\plain \s19\qr \li0\ri0\sl-160\slmult0\widctlpar\nooverflow\faroman\rin0\lin0\itap0 \fs12\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs21  \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs21  It is usually wise to install the Platform SDK last. The Platform SDK provides .h (include) files and .lib (library) files needed for MMC and COM functionality coded in the samples.  \par  \par The MMC C++ sample sn ap-ins assume an environment with the Platform SDK properly installed. However, releases of Microsoft Visual C++ after version 6.0 may also provide the Mmc.h include file and Mmc.lib library file needed for compilation. In such cases, installation of the  Platform SDK may not be required to compile the samples.  \par  \par Each sample directory has the necessary source files to build and run the sample. For convenient use in Microsoft Visual Studio, a project file is provided for each sample. This file has the .dsp ex tension. A Samples.dsw workspace file is also provided in the main directory so that you can view and compile all the samples at once from within Visual Studio.}{ \par }\pard\plain \s5\ql \li0\ri0\sb240\sa60\widctlpar\aspalpha\aspnum\faauto\outlinelevel4\adjustright\rin0\lin0\itap0 \b\i\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {To load the appropriate project for a sample from a command prompt \par }\pard\plain \s17\ql \fi-440\li280\ri0\sa80\sl-240\slmult0\widctlpar\tqr\tx160\tx280\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\tab 1.\tab Make sure that the direc tory containing the Msdev.exe executable file of your Visual Studio installation is in your system\rquote s path. \par \tab 2.\tab Run Visual Studio at the command prompt in the sample\rquote s directory as follows: \par }\pard\plain \s15\ql \li560\ri0\sl-220\slmult0\widctlpar\tx950\tx1340\tx1730\tx2120\tx2510\tx2900\tx3290\tx3680\tx4070\tx4460\tx4850\tx5240\tx5630\tx6020\tx6410\tx6800\nooverflow\faroman\rin0\lin560\itap0  \f29\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {MSDEV <MYSAMPLE>.DSP \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 { \par }{\fs21 You can also simply double-click the .dsp file in Windows Explorer to load a sample\rquote  s workspace into Visual Studio. From within Visual Studio you can then browse the C++ classes of the sample source and generally perform the other edit-compile-debug operations.  \par  \par Note that, as part of the Platform SDK, the compilation of these samples from within Visual Studio requires the proper setting of directory paths in Visual Studio.  \par }\pard\plain \s5\ql \li0\ri0\sb240\sa60\widctlpar\aspalpha\aspnum\faauto\outlinelevel4\adjustright\rin0\lin0\itap0 \b\i\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i0 To }{set the directory paths (assuming Visual Studio 6.0)  \par }\pard\plain \s17\ql \fi-440\li280\ri0\sa80\sl-240\slmult0\widctlpar\tqr\tx160\tx280\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\tab 1.\tab Run Microsoft Visual Studio (Visual C++).  \par \tab 2.\tab On the }{\b Tools}{ menu, click }{\b Options}{.  \par \tab 3.\tab In the }{\b Options}{ dialog box, click the }{\b Directories}{ tab.  \par \tab 4.\tab In the }{\b Show Directories For}{ drop-down list box, select \'93Executable files\'94 and enter the Bin directory path for your installed Platform SDK (for example, D:\\Platform SDK\\ Bin). Click the up arrow button to move this newly entered path so that it is the first entry in the \'93Directories\'94 list.  \par \tab 5.\tab In the }{\b Show Directories For}{ drop-down list box, select \'93Include files\'94 and enter the INCLUDE directory path for your installed Platform SDK (for example, D:\\Platform SDK\\ Include). Click the up arrow button to move this newly entered path so that it is the first entry in the \'93Directories\'94 list. \par }\pard\plain \s18\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\tqr\tx160\tx280\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Follow the same procedure for adding the INCLUDE\\Win64\\mfc and INCLUDE\\Win64\\ crt directory paths to the list of include files. These paths can follow the INCLUDE directory path in the list. Note that INCLUDE refers to the directory path for your installed Platform SDK. \par }\pard\plain \s17\ql \fi-440\li280\ri0\sa80\sl-240\slmult0\widctlpar\tqr\tx160\tx280\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\tab 6.\tab In the }{\b Show Directories For}{ drop-down list box, select  \'93Library files\'94 and enter the Lib directory path for your installed Platform SDK (for example, D:\\Platform SDK\\Lib). Click the up arrow button to move this newly entered path so that it is the first entry in the \'93Directories\'94 list.  \par \tab 7.\tab In the }{\b Options}{ dialog box, click }{\b OK}{ to complete the settings.  \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 { \par }{\fs21 From there you can use the editor, debugger, and project facilities to edit, compile, link, and debug.  \par }\pard\plain \s2\ql \li-1800\ri0\sb140\sa60\sl-380\slmult0\keepn\widctlpar\nooverflow\faroman\outlinelevel1\rin0\lin-1800\itap0 \b\f28\fs34\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {Building ANSI or Unicode Versions of the C++ Samples \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs21 All of the MMC C++ samples can be built in both ANSI and Unicode envi ronments. When building a Unicode version of a sample, you should ensure that the proper preprocessor settings are entered in the project settings of the sample\rquote s .dsp project file. \par }\pard\plain \s5\ql \li0\ri0\sb240\sa60\widctlpar\aspalpha\aspnum\faauto\outlinelevel4\adjustright\rin0\lin0\itap0 \b\i\fs26\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {To build a Unicode version of a sample \par }\pard\plain \s17\ql \fi-440\li280\ri0\sa80\sl-240\slmult0\widctlpar\tqr\tx160\tx280\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\tab 1.\tab Load the sample\rquote s .dsp project  file in Microsoft Visual Studio (Visual C++).  \par \tab 2.\tab On the }{\b Tools}{ menu, click }{\b Project}{.  \par \tab 3.\tab In the }{\b Settings For}{ drop-down list box, select \'93Win32 Release\'94 for a release build or \'93Win32 Debug\'94 for a debug build. \par \tab 4.\tab In the }{\b Project Settings}{ dialog box, click the }{\b C/C++}{ tab.  \par \tab 5.\tab In the }{\b Preprocessor definitions}{ field, make sure that the UNICODE and _UNICODE definitions are included. If not, add them. \par {\pntext\pard\plain\s17 \fs21 \hich\af0\dbch\af0\loch\f0 6. \tab}}\pard \s17\ql \fi-360\li365\ri0\sa80\sl-240\slmult0\widctlpar\tqr\tx160\tx280{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec\pnb0\pni0\pnfs21\pnstart6\pnindent360\pnhang{\pntxta . }} \nooverflow\faroman\ls1\rin0\lin365\itap0 {In the }{\b Project Settings}{ dialog box, click }{\b OK}{ to complete the settings.  \par }\pard\plain \s19\qr \li0\ri0\sl-160\slmult0\widctlpar\nooverflow\faroman\rin0\lin0\itap0 \fs12\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 { \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs21  \par }}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\test\snapins\readme.txt ===
1. To create a standalone snapin do the following

a) A sample snapin is created in samplesnap.?xx files. Use this to get started for a standalone snapin. (USe the standalone part & ignore namespace sample).

b) A CBaseSnapin derived class is created for each snapin. This encapsulates the ComponentData and can create component. 

c) The ComponentData and Component delegates any calls to the underlying CBaseSnapinItem derived object. A CBaseSnapinItem is derived from IDataObject (which is also a cookie) which implements default implementation for most of the actions.

d) Add your SNAPININFO and nodetypes to inc\nodetypes.hxx. (Use these snapininfo & nodetypes in CBaseSnapinItem derived class).

e) Add your ComponentData & About objects in TestSnapins.idl.

f) Add any of your resources to TestSnapins.rc.

g) Add an entry to your CBaseSnapin derived object in TestSnapinsList.hxx.


2. To create a namespace extension snapin do the following
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\adminpak\dllsource\placeadm.txt ===
adminpak.dll		adminpak
WiStream.vbs		adminpak
updversn.vbs		adminpak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\adsprop\hello.txt ===
1999-06-14 11:47:20-VarSet
1999-06-14 11:47:20-Case Sensitive: Yes, Indexed: Yes
1999-06-14 11:47:20-User Data ( 0 ) items
1999-06-14 11:47:20- [] <Empty>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\placefil.txt ===
; ADMT Multi-Use File 
; (placefil.txt, symbolcd\cablists\ADMigration.lst, and 
;  retail\map\ADMigration.map)
;
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory. It also service to indicate which
; files are accompanied by symbols.  And final it serves to inform the internationalization
; team which files are included in this product. The ADMT Post-build script will
; copy and rename this file to 
;
; The format is like this:
;
; <imagename>    <class name>	<symbol location>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;



; Package-level records
;PACKAGE_NAME = ADMigration.msi
;MEDIA_TARGET = valueadd\MSFT\mgmt\ADMT


;
; ADMT Files
;


; ADMT Dlls

AddToGroup.dll			 retail
ADMTScript.dll			 retail
DBManager.dll			 retail
DisableTargetAccount.dll	 retail
DomMigSI.dll			 retail
GetRids.dll			 retail
McsADsClassProp.dll		 retail
McsDctWorkerObjects.dll		 retail
McsDmMsg.dll			 retail
McsDmRes.dll			 retail
McsMigrationDriver.dll		 retail
MCSNetObjectEnum.dll		 retail
McsPISag.dll			 retail
McsVarSetMin.dll		 retail
MoveObj.dll			 retail
ScmMigr.dll			 retail
SetTargetPassword.dll		 retail
TrustMgr.dll			 retail
UpdateDB.dll			 retail
UpdateMOT.dll			 retail
UPNUpdt.dll			 retail
Wizards.dll			 retail
MsPwdMig.dll		         retail


; ADMT Exes

ADMT.exe			 retail
ADMTAgnt.exe			 retail
DCTAgentService.exe		 retail
McsDispatcher.exe		 retail


; Documents

DomainMig.chm			 admt
ADMTReadMe.doc			 admt
TemplateScript.vbs		 admt


; Static Alpha Binaries 

;ADMTAgnt.exe1			 retail
;DCTAgentService.exe2		 retail
;McsDctWorkerObjects.dll3	 retail
;McsDmMsg.dll.Alpha		 retail
;McsDmRes.dll.Alpha		 retail
;McsPISag.dll4			 retail
;McsVarSetMin.dll5		 retail


; NT4 Agent Binaries 

ADMTAgntNT4.exe			 retail
DCTAgentServiceNT4.exe		 retail
McsDctWorkerObjectsNT4.dll	 retail
McsDmMsgNT4.dll		 	 retail
McsDmResNT4.dll			 retail
McsPISagNT4.dll			 retail
McsVarSetMinNT4.dll		 retail


; Installation Fonts

Gothic.ttf			 admt
Gothicb.ttf			 admt
Gothicbi.ttf			 admt
Gothici.ttf			 admt


; Misc.

Migrator.msc			 admt
Protar.mdb			 admt
ADMigration.msi			 admt
ADMigration.lst			 symbolcd\cablists
CpySym.cmd			 admt

; Sub Package
;PACKAGE_NAME = PwdMig.exe
;MEDIA_TARGET = valueadd\MSFT\mgmt\ADMT\PwdMig

;
; PwdMig Files
;

; PwdMig Dlls
PwMig.dll			 retail
PwdMsi.dll			 dump
Mschapp.dll			 retail

; PwdMig Installation Files
PwdMig.exe			 admt
PwdMig.ini			 admt
PwdMig.msi			 admt
Instmsiw.exe		         admt

; NT4 Binaries 
PwMigNT4.dll		         retail

; Auxiliary dlls
msvcp60.dll			 admt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\command\readme.txt ===
========================================================================
       CONSOLE APPLICATION : admtCommand
========================================================================


AppWizard has created this admtCommand application for you.  

This file contains a summary of what you will find in each of the files that
make up your admtCommand application.

admtCommand.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

admtCommand.cpp
    This is the main application source file.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named admtCommand.pch and a precompiled types file named StdAfx.obj.


/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\documents\help-ms\shared.txt ===
INDEX~TEXT
para1~"To open a Control Panel item, click <B>Start</B>, point to <B>Settings</B>, click <B>Control Panel</B>, and then double-click the appropriate icon."
para2~"To open an accessory, click <B>Start</B>, point to <B>Programs</B>, point to <B>Accessories</B>, and then click the appropriate icon."
para3~"To search for a specific word or phrase, click the <B>Index</B> or <B>Search</B> tab."
para4~"For more information, see Related Topics."
para5~"Web addresses can change, so you might be unable to connect to the Web site or sites mentioned here."
para6~"To open Computer Management, click <B>Start</B>, point to <B>Settings</B>, and then click <B>Control Panel</B>. Double-click <B>Administrative Tools</B>, and then double-click <B>Computer Management</B>."
para7~"To open <B>Fax</B>, click <B>Start</B>, point to <B>Settings</B>, click <B>Control Panel</B>, and then double-click <B>Fax</B>. If <B>Fax</B> does not appear, you need to install a fax device (such as a modem)."
para8~"To open Network and Dial-up Connections, click <B>Start</B>, point to <B>Settings</B>, click <B>Control Panel</B>, and then double-click <B>Network and Dial-up Connections</B>."
para10~"You must be logged on as an administrator or a member of the Administrators group in order to complete this procedure. If your computer is connected to a network, network policy settings may also prevent you from completing this procedure."
para13~"Open <A ID='shortcut' HREF='EXEC=,compmgmt.msc,/s CHM=mmc.chm FILE=alt_url_snapin.htm'>Computer Management (Local)</A>."
para14~"To open My Computer, double-click its icon on the desktop."
para15~"To open Windows Explorer, click <B>Start</B>, point to <B>Programs</B>, point to <B>Accessories</B>, and then click <B>Windows Explorer</B>."
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\documents\installation guide\active directory migration tool installation guide.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Mission Critical Software, Inc. Active Directory Migration Tool Installation Guide Title _PID_GUIDActive Directory Migration Tool Installation Guide Mission Critical Software, Inc. MCSbooks97.dot Paul Mueller Microsoft Word 8.0qdZbFbjbjt+t+ Active Directory Migration Tool Installation Guide October 29, 1999 The Active Directory Migration Tool simplifies migrating and reconfiguring your distributed Windows NT and Windows 2000 account definitions.  This product allows you to copy user accounts, groups, and computer accounts to another domain.  Then, you can use this product to resolve the related file, directory, share, and Microsoft Exchange security issues for the copied user accounts, groups, and computer accounts.  The Active Directory Migration Tool provides a comprehensive set of tools that allow you to analyze the migration impact both before and after the actual migration process.  Requirements The Active Directory Migration Tool has several requirements to ensure it can perform the required tasks:  The Active Directory Migration Tool runs only on Windows 2000 computers.  The target domain must be running Windows 2000 RC2 or later in native mode.  The PDC in the source domain must be running Windows NT 4.0 Service Pack 4 or later.  If the source domain is running Windows 2000, it can run in native mode or mixed mode.  If the Windows 2000 source domain has two or more domain controllers, and the source and target domains are in the same forest, you must run this tool on the domain controller with the RID pool allocator role. Memory requirements depend on the number of user accounts, groups, and computer accounts you migrate at one time.  If you migrate a large number of accounts at one time, such as 30,000 accounts, you should run the Active Directory Migration Tool on a computer with at least 128MB of RAM (256MB recommended). Auditing for account management (success and failure events) must be enabled in the source and target domains.  In Windows NT, account management is referred to as user and group management. If you have more than 10,000 user accounts, groups, or computers, you need to increase the Maximum size of Active Directory Searches group policy in the target domain.  By default, this value is set to 10,000. If you want to translate Exchange security for Exchange mailboxes, distribution lists, custom recipients, organizations, sites, and containers, the account credentials you specify during the translation process must be a Permissions Admin in the Exchange site of the specified Exchange server. If you want to translate Exchange security, you must install Microsoft Exchange Administrator on the computer where you run the Active Directory Migration Tool. To use the Active Directory Migration Tool, the user account you log on with when you run the Active Directory Migration Tool must have the following permissions: Administrator rights in the source domain (member of Domain Admins) Administrator rights in the target domain Administrator rights on each computer you migrate Administrator rights on each computer on which you translate security Administrator rights on any computer where the Active Directory Migration Tool must install an agent to perform the migration. These agents allow the Active Directory Migration Tool to resolve the security-related issues and to gather information for impact analysis The source domain must trust the target domain.  In addition, the target domain must trust all domains that are trusted by the source domain and that contain accounts that are members of local groups you will migrate in the source domain.  The Trust Migration wizard allows you to compare the source and target domain trusts.  You can also migrate the source domain trusts to the target domain. To update the SID History of migrated accounts in the target domain, the Active Directory Migration Tool has several additional requirements: You must run the tool on a domain controller in the target domain. The domain$$$ local group must exist in the source domain.  The tool creates this group. The tool must be able to connect to all domains related to the information in the SID History property of each migrated account.  In addition, the user account you log on with when you run the tool must have administrator rights in each domain from which SID information is used. For example, if you migrate accounts from Domain A to Domain B, then migrate accounts from Domain B to Domain C, your account must have administrator rights in Domain A to copy the SID History information related to that domain.  If Domain A is no longer available, the tool cannot copy the SID History information related to Domain A. The following registry key must exist on the PDC in the source domain as a DWORD with the value set to 1.  If you create this registry key, you must restart the domain controller to activate this value.  The tool creates this registry key if it does not exist and restarts the domain controller. HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa\ TcpipClientSupport Notes: To read the entries the Active Directory Migration Tool writes in the Application event log, you should read the log from a computer where the Active Directory Migration Tool is installed. The Active Directory Migration Tool uses an Access database to collect information.  The tool then uses this information to perform the migration tasks.  Two users should not run this tool at the same time using the same database.  The security translation process modifies the Security Descriptors for various files, directories, shares, printers, and user profiles to reflect the Security Identifier (SID) for the new account in the target domain.  The Active Directory Migration Tool also allows you to change the Security Descriptors for Exchange mailboxes, distribution lists, custom recipients, organizations, sites, and containers, as well as the primary Windows NT or Windows 2000 account for each mailbox to reflect the SID for the new account in the target domain.  This process ensures the new account provides the same access to files, directories, shares, and Exchange components that the original account provided. Installing the Active Directory Migration Tool You must set the permissions as outlined in the previous section.  You cannot install or uninstall the Active Directory Migration Tool through a Windows Terminal Server connection. To install the Active Directory Migration Tool: Log on with a user account that has the required permissions outlined in the previous section.  If you want to translate Exchange security, install Microsoft Exchange Administrator on the computer where you will install the Active Directory Migration Tool.  Then, configure the required permissions.  For more information about permissions, see the   REF _Ref460053529 \h  Requirements  section. Install the Active Directory Migration Tool on a Windows 2000 server by completing the following steps: Run the ADMigration.msi program file in the root directory of the Active Directory Migration Tool installation kit. Click Next on the Welcome window. Review the terms of the Licence Agreement.  If you agree to these terms, click I accept the License Agreement, and then click Next. Specify where you want the Active Directory Migration Tool installed, then click Next. Click Next on the Start Installation window. When the Active Directory Migration Tool has been installed, click Finish. Starting the Active Directory Migration Tool When you install the Active Directory Migration Tool, the installation program creates a shortcut in the Administrative Tools program group. To start the Active Directory Migration Tool: Click Start on the taskbar. Click Programs on the Start menu. Click Administrative Tools on the Programs menu. Click Active Directory Migration Tool. Learning More about the Active Directory Migration Tool The Active Directory Migration Tool provides detailed Help, which includes context-sensitive information and step-by-step guidance for common tasks, as well as definitions for each field on each window.  The Help also provides various domain migration and user interface concepts. To display the Active Directory Migration Tool Help, click Help Topics on the Help menu. General Notes and Identified Issues This section identifies some of the key issues identified and currently being researched.  Please review this section to be familiar with these potential issues. Migrating Large Numbers of Accounts The Active Directory Migration Tool allows you to select up to 10,000 accounts to migrate at one time.  If you need to migrate a domain with more than 10,000 accounts, you can use the Group Migration wizard to migrate the groups and all their members, which can include more than 10,000 accounts. Primary Group Set to Domain Users The Active Directory Migration Tool sets the primary group to Domain Users for each migrated account. Profile Migration Does Not Replace Existing Profile If you migrate local profiles, adding profiles and permissions for the migrated accounts, the Active Directory Migration Tool does not replace profiles that already exist in the target domain. Locked Database Due to Unexpected Interruption If the Active Directory Migration Tool is interrupted, such as due to a power outage, the database can become locked.  To correct this problem, delete the .LDB file with the same name as the database you are trying to use. Windows NT 3.51 Computer Accounts with $ Can Cause Problems When a Windows NT 3.51 domain is joined with a Windows 2000 domain, some Windows NT 3.51 computer accounts have a dollar sign ($) added to their computer name.  The Active Directory Migration Tool may not correctly handle these accounts. Next Button on Domain Selection Window The Next button on the Domain Selection window is enabled even if you have not selected a source and target domain.  However, if you click the Next button without specifying the source and target domain, the tool prompts you to enter this required information.  1995 1999 Mission Critical Software, Inc.; all rights reserved.  1999 Microsoft Corporation; all rights reserved.  Developed with Mission Critical Software of Houston, Texas (www.missioncritical.com) using the Mission Critical Software Domain Migrator technology. wmcYOJ mhaWMC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\documents\releasenotes\admtreadme.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Corporation TitleMicrosoft Corporation Normal.dot Microsoft Corporation Microsoft Word 10.0@\\grandcentral\PS4$ Ne00: winspool HP LaserJet 5Si/5Si MX PSbjbj4 Microsoft Active Directory Migration Tool (ADMT) Release Notes This document provides late-breaking or other information that supplements the Microsoft( Active Directory( Migration Tool (ADMT) online Help documentation. Information in this document, including URL and other Internet Web site references, is subject to change without notice. Unless otherwise noted, the example companies, organizations, products, people, and events depicted herein are fictitious and no association with any real company, organization, product, person, or event is intended, nor should any be inferred. Compliance with all applicable copyright laws is the responsibility of the user. Without limiting the rights under copyright, no part of this document may be reproduced, stored in or introduced into a retrieval system, or transmitted in any form or by any means (electronic, mechanical, photocopying, recording, or otherwise), or for any purpose, without the express written permission of Microsoft Corporation. Microsoft may have patents, patent applications, trademarks, copyrights, or other intellectual property rights covering subject matter in this document. Except as expressly provided in any written license agreement from Microsoft, the furnishing of this document does not give you any license to these patents, trademarks, copyrights, or other intellectual property.  2003 Microsoft Corporation. All rights reserved. Microsoft, Active Directory, Windows, and Windows NT are either registered trademarks or trademarks of Microsoft Corporation in the United States and/or other countries/regions. The names of actual companies and products mentioned herein may be the trademarks of their respective owners. Contents How to View This Document Installation ADMT Installation Password Export Server Installation New Features In ADMT Version 2.0 Scripting and Command-line Interface Password Migration Migration Log Files Credentials Needed for Migration Operations SID Mapping Files for Security Translation Windows 2000 Attribute Exclusion Agent Credentials Skip Membership Restoration Decommission Source Domains Known Issues User Migration Group Migration Service Account Migration Trust Migration Computer Migration User Profile Migration Password Migration Report Creation Retry Wizard Online Help ADMT Remote Agent Software ADMT Migration Database Intraforest Migration Command-line Tool Scripting Component How to View This Document To review the latest release notes and other updated information for ADMT, see the Domain Migration Web site at: http://www.microsoft.com/windows2000/downloads/tools/admt/default.asp Installation ADMT Installation This section describes a known issue related to the installation of this version of ADMT. ADMT Version 1.0 Installs Over Version 2.0 ADMT Version 1.0 will install itself over Version 2.0 without warning the user. ADMT Version 2.0 Installation Preserves the ADMT Version 1.0 Database When upgrading, ADMT v-2 upgrades the internal database to a new version of the Microsoft Access database. The installation copies the old database to a file named protar3x.mdb.  Should the upgrade fail, ADMT v-1 can be reinstalled. To use the current database again, rename protar3x.mdb to protar.mdb. Installation Over A Terminal Server Session Fails Unless Files Reside Locally On Target Computer  The Admt.msi installation program must reside locally on the Terminal Services client computer for the installation to be successful. If these files are not present internal error 2755 occurs. If you experience this behavior, simply cancel the installation, copy the ADMT installation files to the terminal client, and restart the installation. Installation of ADMT on 64-Bit Computers Not Supported Installation of this version of ADMT is not supported on 64-Bit computers.  Rights Needed to Run ADMT Administrative rights on the local computer are required to run ADMT. If ADMT runs on a domain controller, membership in the Domain Admins global group or in the domain local group Administrators is required. If ADMT runs on a member server membership in the local group, Administrators is required. Password Export Server Installation This section describes the requirements for installing and using a Password Export Server (PES) to perform password migration with ADMT. More detailed information is available in the Windows Server 2003 Deployment Kit on the Microsoft Windows Deployment and Resource Kits Web page at: http://www.microsoft.com/reskit If your password export server is running Windows NT version 4.0, you must meet the following requirements: It is recommended that the source domain s PES be a backup domain controller (BDC) dedicated for this purpose. 128-bit encryption must be installed on the PES. 128-bit encryption must be installed locally on the computer running ADMT. The Password Export Server installation cannot complete unless it supplies an encryption key created on the computer running ADMT. The key must be available on a local drive. This can be a floppy drive or a folder on the local hard disk, but not a network mapped drive or share. For security reasons, it is best to use a floppy disk so that it can be stored in a secure location or reformatted after the migration is complete. To set up your Password Export Server: Create a key that protects the password list: Run ADMT.exe from the command line using the key operation. The syntax for this command is ADMT.exe key Source_Domain_Name folder: [Password] (Type ADMT.exe key at the command line for more usage information). Give the location of the key when prompted. Provide a matching password if one was given when you created the encryption key. Check the value of the AllowPasswordExport registry entry (located in HKLM\ SYSTEM\CurrentControlSet\Control\Lsa on the PES). The value must be set to 1 to allow ADMT to use that PES for password migration. You can disable a PES from supporting password migration by setting the value to 0. Add the Everyone system group to the  Pre-Windows 2000 Compatible Access  group on the target domain. If this is not done, ADMT will log an  Access Denied  error. To do this, use the Active Directory Users and Computers snap-in, or use the following syntax at the command prompt on a target domain controller: NET LOCALGROUP "Pre-Windows 2000 Compatible Access" Everyone /ADD In the Active Directory Users and Computers snap-in, verify permissions on the PES server object. The PES requires that the  Pre-Windows 2000 Compatible Access  group has  Read All Properties  rights on the following object: CN=Server,CN=System,DC=<domain_name> If you are running ADMT on a server running Windows Server 2003, add ANONYMOUS LOGON to the  Pre-Windows 2000 Compatible Access  group on the target domain. If this is not done, ADMT will log an  Access Denied  error. To do this, use the Active Directory Users and Computers snap-in, or use the following syntax at the command prompt on a target domain controller: NET LOCALGROUP "Pre-Windows 2000 Compatible Access  ANONYMOUS LOGON/ADD New Features in ADMT Version 2.0 Scripting and Command-line Interface Most ADMT operations can now be performed via a scriptable interface or a new command-line tool (ADMT.exe). TemplateScript.vbs is a template script that installs with ADMT and explains most of the interface. For help using the command-line tool, type ADMT.exe and press ENTER, or see the Help documentation.  The Undo Wizard is not available through these new interfaces. However, you can use the GUI Undo Wizard to undo operations that are originally performed through scripts or the command-line interface. Password Migration Passwords can now be migrated for interforest user migrations. ADMT uses a Password Export Server (PES) in the source domain to perform that migration. See the section entitled  Password Export Server Installation  in this document, for more specifics and requirements. Migration Log Files A single log file was used in ADMT v-1 to log migration results and issues. In ADMT v-2, a new log file is created for each new migration operation. The most current log file is migration.log. When a new migration is started, the old migration.log file is renamed to migrationxxxx.log, where xxxx is the next available sequence number. The sequence of numbers begins at 0001 and continues up to 9999 with the highest sequence number being the most recently renamed log file. ADMT v-2 only saves a specific number of log files. By default, this number is 20. The number can be changed through the following registry entry. HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ADMT\LogHistory: 20 Credentials Needed for Migration Operations ADMT v-1 has a hard-coded check that verifies that the account that is running ADMT has administrative rights in both the source and the target domains. ADMTv-2 leaves this check to the operating system.  Note 1: When migrating security identifier history (SIDHistory), the user running ADMT must have administrative rights in the source domain and domain administrative rights in the target domain unless rights have been delegated as explained in Note Note 2: In Windows Server 2003, SIDHistory migration can be delegated. The user who migrates accounts with SIDHistory needs appropriate rights in the target Organizational Unit (Create Users), and the delegated extended right MigrateSIDHistory on the domain object (DC=<domain_name>). Note 3: When user passwords are migrated, the user running ADMT must have administrative rights in the source domain. Note 4: For agent-based operations such as security translations or computer migrations, the account used for migration must also have local administrative rights on the target computer. SID Mapping Files for Security Translation ADMT performs security translation based on a comma-separated file. The form of the comma-separated file is Source Object, Target Object followed by a new line. Domain\Username or the decimal representation of a SID such as S-1-5-21-1222312332-327112949-1237804090-1056 are acceptable for the source and target objects. The Account Reference report includes an object SID in decimal form and can be used to help build this mapping file. The Windows 2000 version of LDP.exe does not display the full SID in decimal form, however, the Windows Server 2003 version of LDP.exe does. Windows 2000 Attribute Exclusion For interforest migrations, you can define a list of attributes to be excluded in a user, group or computer migration. There are three types of attribute lists: Attributes always excluded by the system System attribute exclusion list Per migration attribute exclusion list Attributes Always Excluded by the System These attributes are always excluded by ADMT. This is done to protect system-owned attributes. They cannot be configured. The attributes are: Object GUID Object SID (but can be written to the SIDHistory) pwdLastSet userPassword (can be separately migrated by ADMT) isCriticalSystemObject LegacyExchangeDN System Attribute Exclusion List Attributes listed on the system attribute exclusion list are excluded from every migration. Attributes on the system attribute exclusion list will not appear on the per migration attribute exclusion list. This is done to protect attributes that are important for server-based applications to work, like Exchange. ADMT stores the system attribute exclusion list in its database. However, an administrator can change the make changes to it using the ADMT scripting interface. When ADMT is installed on a computer, it reads the schema of the forest of which the computer is a member. Any attribute that is not part of the Windows Server 2003 base schema is automatically added to the system attribute exclusion list and will not be migrated. The following is an example of a script that can be used to reset the System Attribute Exclusion list to contain the attributes  proxyAddresses , and  description Set objMigration = CreateObject("ADMT.Migration") objMigration.SystemPropertiesToExclude = "description,mail,proxyAddresses" Per Migration Attribute Exclusion List This is a list of attributes is defined by the administrator using the Object Property wizard page in ADMT in the User, Group, and Computer Migration Wizards. This wizard displays only the attributes that are found in both the source and target domains. The administrator then has the option to choose which attributes are excluded for this individual migration only. The attributes that are selected for one migration will automatically be selected for exclusion in subsequent migrations, but can be edited when this wizard page appears. Since, the scripting and command-line interfaces do not maintain state information, a per migration exclusion list is not maintained for these interfaces. Attributes must be excluded either through the attribute name or an option file for every individual migration using these interfaces. However, the Object Property wizard page reflects the properties that were excluded on the previous migration regardless of whether the migration was done using the scripting, command-line or GUI interfaces. For example, the attributes excluded during a command-line migration can be viewed on the Object Property wizard page if the next migration is done through the GUI interface. Agent Credentials ADMT v-2 no longer requires agent dispatch credentials. ADMT v-1 prompts the user for credentials used by the agent to report results back to ADMT. Credentials are no longer required due to a change in the architecture of the agents. The computer running ADMT now retrieves results from the agents. Skip Membership Restoration Fix Membership  option is included in the User and Group Migration Wizards in ADMT v-2. This is improves performance when group membership reconstruction is not needed. Decommission Source Domains During security translation, ADMT v-1 communicates with the source domain that is referenced on the access control list (ACL) of the object. If the source domain is already decommissioned, the security translation fails. ADMT v-2 stores all necessary information in a database so that security translations are successful even after source domains are decommissioned. If ADMT v-2 is installed as an update to ADMT v-1, ADMT v-2 must update the database to a new format. ADMT v-2 adds information to the database to do this. When the ADMT v-1 database is upgraded, ADMT v-2 prompts the administrator with a list of domains that have objects previously migrated using ADMT v-1. This dialog box gives the administrator a chance to exclude some domains from the list before ADMT v-2 attempts to contact them. This process happens the first time ADMT v-2 is run. If a source domain controller is not online when ADMT v-2 is run for the first time, then you must perform a migration to update the information. You can do this, even as a test migration, once the domain controller is online again. When the migration or test run succeeds, the database is updated, and domain controllers from the source domain are not contacted for subsequent operations.  Exchange 5.5 Administration Tools Not Required The ADMT v-1 Exchange 5.5 mailbox security translation wizard requires that Exchange 5.5 administration tools be installed on the ADMT computer. The tools are needed for ADMT to detect the LDAP port configured on the Exchange server. In ADMT v-2, ADMT expects Exchange 5.5 to use the standard LDAP ports 389 and 636 (SSL port). If the Exchange server uses different ports, the following registry entries need to be set on the ADMT computer: HKLM\Software\Microsoft\ADMT\ExchangeLDAPPort: <LDAP port number> HKLM\Software\Microsoft\ADMT\ExchangeSSLPort: <SSL port number> Security Considerations Migrate Service Accounts from Trusted Computers Only The Service Account Migration Wizard scans an administrator-defined list of servers for services configured with a domain account. The accounts are then flagged as service accounts in the ADMT database. The password is never migrated when a service account is migrated. Instead, ADMT uses a clear-text representation of the password to configure the services after the service account migration. An encrypted version of the password is then stored in the  password.txt  file in the ADMT installation folder. An administrator of a workstation or server can install any service and configure the service with any domain account. If the administrator cannot configure the service with the correct password, then the service will be unable to start. After the service account is migrated, ADMT configures the service on the workstation or the server with the new password and the service will now start under the user account. It is important to include in the Service Account Migration Wizard only those servers that are managed by trusted administrators. The Service Account Migration Wizard should never be used to detect service accounts on un-trusted computers, such as a workstation. Known Issues If Install Path Is Empty, the Installation Wizard Shuts Down If the user changes the default installation path to an empty path first, and then clicks Browse, the installation wizard presents a dialog box with  Error 2343  and then shuts down.  User Migration This section describes known issues related to migrating users with this version of ADMT. Special Characters Are Replaced When Migrating Account Names  ADMT replaces the following characters with an underscore character   in the pre-Windows 2000 name Security Accounts Manager (SAM) account name and user principal name (UPN): "*+,/:;<=>?[\]| The period character   is replaced with an underscore character   if it is the last character of a name. Some Characters Are Not Allowed In a Prefix/Suffix The following characters are not allowed in a prefix or suffix: " (quotation mark) # (number sign) $ (dollar sign) * (asterisk) + (plus sign) , (comma) . (period) / (slash mark) : (colon) ; (semicolon) < (less than) = (equal sign) > (greater than) ? (question mark) [ (open bracket) \ (backslash) ] (close bracket) |(pipe) Clicking Stop on the Migration Progress Page of the User Migration Wizard Does Not Pause the Operation When you click Stop on the Migration Progress page of the User Migration Wizard, it does not stop the user migration operation even though a verification message displays.  Subsequent User Migrations Update Group Membership of Target Accounts When migrating a user who has been previously migrated, the Replace conflicting accounts option in the User Migration Wizard updates the group membership of the migrated account. Any new group memberships of the source account are appended to the group membership of the user in the target account. Example: Bob is a user in the domain HB-ACCT-WC. He is a member of the group HB-ACCT-WC \Writers and is migrated, along with the Writers and Editors groups, to the target domain hay-buv.tld (NetBIOS name HAY-BUV). After the first migration, the following occurs: HB-ACCT-WC\Bob is added to the group HB-ACCT-WC \Editors HAY-BUV\Bob is added to HAY-BUV\TechEditors When this account is migrated again, HAY-BUV\Bob will be a member of HAY-BUV\Writers, HAY-BUV\Editors, and HAY-BUV\TechEditors. This behavior is by design. To reset to the account to only the groups of the source user you must delete the target account then repeat the migration of the source account. It is also possible to re-migrate groups with the Remove existing members option. Undo Wizard Does Not Reset Properties on Target Users and Groups After a Migration in Replace Mode When the properties of a migrated user or group are changed in the target domain and that same user or group is migrated again using the Replace conflicting accounts option, the Undo Wizard cannot undo the change to the properties of the target user or group. This is by design, because ADMT does not store attribute values that are overwritten during a migration in replace mode. User Names Using Double Byte Character Sets Cannot Be Migrated with Password Same as User Name User names consisting of characters from Double Byte Character Sets (DBCS) should not be migrated using the Same as the user name password setting option because Windows 2000 does not accept DBCS passwords. When migrating users with names containing DBCS characters, the complex password or copy password setting option should be used. Permissions on a User Migrated From an Active Directory Domain Are Reset to Default Values During Migration When migrating a user from one Active Directory domain to another, the User Migration Wizard creates a new security descriptor on migrated user objects using settings from the target domain. The security tab is only visible for users if the View\Advanced Features option has been selected. This is by design, because the target domain, not the source domain, dictates security settings on the migrated user account. Incorrect Error Message Created During User Group Fix-up if User Account Is Deleted If a user account in the target domain is deleted after a migration, and a group that had the user account in the source domain as a group member is migrated between the same domains, then ADMT logs the following wrong error message: <account> has not been migrated to the target domain. Incorrect Error Messages for Group Fix-up Failures During Trial Migration When migrating users with the User Migration Wizard during an interforest migration, an error message is logged when the user is a member of a global group that was previously migrated. This error message is incorrect. If Test the migration settings and migrate later is selected for group membership fixup, then the error looks similar to the following: W1:7352 Failed to add to CN=Executives. RC=80005008. One or more input parameters are invalid. Group Migration This section describes known issues related to migrating groups with this version of ADMT. Local Group Contains Both Source and Target Account When That Account Is Migrated After Migrating the Local Group When migrating a member of a previously migrated local group, the source account for that member is not removed when the target member is added. If the member is migrated prior to migrating the local group, only the target account member is added. This is by design and applies to interforest migrations only. Group Membership Is Not Maintained for Nested Groups  Group membership within other groups is not maintained for interforest migrations. Group Member List Is Not Updated for a Group that Includes a Migrated Group from a Third Domain  If you migrate a group, any groups in a third domain that include that original group as a member, still refer to the group in the source domain. In the case of an intraforest migration, that original group in the source no longer exists. Because of SIDHistory group members still have access to resources. Use the Group Migration Wizard to Migrate Users Belonging to Nested Groups If the Migrate associated user groups option is selected, the User Migration Wizard only migrates the groups the user is directly a member of. It does not migrate groups the user is a member of through group nesting. When migrating groups using the Group Migration Wizard, if the Copy group members option is selected, then the wizard recursively migrates all users and groups that are members of that group, including groups that are members through group nesting. Where the source domain is running Windows 2000 or Windows Server 2003, and group nesting is used, if you wish to preserve group membership gained through such nesting, it is recommended that you migrate the objects affected using the Group Migration Wizard.  Service Account Migration This section describes known issues related to migrating service accounts with this version of ADMT. Service Account Migration Wizard Has Hidden  Service Account  Column The Service Account Migration Wizard displays a list of service accounts. One of the columns shown,  Service , is the Display Name of the service. There is a hidden column that also displays the  Service Name  of the service. Updating a Service Account on a Remote Computer While Migrating that Account The user account running ADMT must have Logon Locally rights to any remote computer to which the tool will dispatch an agent. This also applies to any remote computer whose Service Control Manager (SCM) is modified while migrating a service account with the User Migration Wizard. If this account does not have the right to change the SCM, the service account is still migrated to the target domain, but the service on the remote computer is not updated to use the target domain account. To update the service on the remote computer, run the Service Account Migration Wizard and select the No, use the previously collected information option. Because the user s lack of access is not always flagged as an error in Migration Progress, it is a good practice to check the migration log file for any errors after migrating service accounts. Services Should Be Identified on All Computers Before Service Accounts Are Migrated When service accounts are migrated, ADMT creates a new complex password and saves the password in an encrypted file. The password is needed to configure services on remote servers for the new service account and password. After the last service is configured, ADMT deletes the password. If services on servers are identified after ADMT has deleted the password, configuration of these services with the migrated account and password information will fail. Therefore, services on all servers need to be identified before service accounts are migrated.  Trust Migration This section describes known issues related to migrating trusts with this version of ADMT. Trust Migration Wizard Does Not Verify Existing Trusts If a domain is listed as a trusted domain on the source and target domains, the Trust Migration Wizard does not allow the creation of that trust, even if the trust is broken. Do not use the Trust Migration Wizard to verify pre-existing trusts. Use it only to create new trusts. Final   Button Unavailable in Wizard After trusts are migrated using the  Copy Trust  button, there is no Finish button by which you can leave the wizard. The Next button is only enabled if at least one trust was migrated. To close this dialog box, click Cancel. Insufficient Credentials for Trust Migration Wizard The Trust Migration Wizard will not prompt for additional credentials if the user running ADMT does not have rights to create trust relationships in the target domain. An  Access Denied  error is noted in the log file. The user running ADMT must have administrator rights in the target domain to create the needed trust relationships for migration. Computer Migration This section describes known issues related to migrating computers with this version of ADMT. Intraforest Computer Migration Does Not Disable the Computer Account in the Source Domain After an intraforest computer migration, the migrated computer account in the source domain is neither disabled nor deleted. As a workaround, you can write a simple Active Directory Service Interfaces (ADSI) script to disable or delete the accounts of migrated computers in the source domain. This is by design and needed to enable the undo functionality. Computer Account Created Even if Migration Fails If a computer migration fails due to an agent related error, the computer account created for the computer in the target domain is not deleted.  In an Intraforest Migration Migrate Computers Before Any Groups If you have any computers that are members of groups (other than the Domain Computers group), you should always migrate those computers prior to migrating the groups to which they belong. This is a condition for intra-forest migrations and prevents those computers from losing their group membership. A Prefix Given to a Windows 4.0 Computer During a Computer Migration Can Create Duplicate Computer Names  When adding a prefix to a computer that is running Windows 4.0 with the Computer Migration Wizard, be careful not to create a computer name that duplicates the name of another computer being migrated or an existing computer in the target domain. ADMT truncates Windows 4.0 computer account names to 15 characters during the migration. As a result, you need to make sure that computer names resulting from a prefix being added are unique in the target domain. Any computer that has a duplicate name cannot successfully join the target domain. Intermittent Failure of ADMT Remote Agent Service If a failure occurs when deploying the ADMT remote agent service on a remote computer as part of a computer migration, security translation, or service account identification, it is possible that the agent might fail to stop or uninstall itself. Some instances of this behavior have been reported. If this occurs, it manifests itself during subsequent agent deployments as a failure with the message An instance of the agent is already running. This persists until either the ADMT agent process is closed or the remote computer is rebooted. The Undo Wizard Cannot Undo Security Translation  The Undo Wizard cannot undo security translation operations even if that security translation was performed as part of a computer migration. It is recommended that   mode be used in any security translation. Computer Migration May Fail if a Computer Account with the Same Name Already Exists in the Target Domain Dispatching an agent to migrate a computer from a source domain may fail if a computer account with the same name already exists in the target domain. Migration Log File Can Truncate Computer Names If a prefix or suffix is added to a computer name during migration, and the new computer name is longer than 15 characters, the computer name has to be truncated to 15 characters. The entry in the migration log only shows the original computer name in some locations, and the full new computer name in other locations. User Profile Migration This section describes a known issue related to migrating user profiles with this version of ADMT. ADMT Remote Agent Service Reports that the User Profile Is Locked During Profile Migration When User Is Logged Off If you deploy the ADMT remote agent service on a remote computer as part of a user profile migration, the agent may fail to migrate the profile, even if the user whose profile is being migrated has logged off the computer. It displays Error enumerating the profile list entries, rc=32. The process cannot access the file because it is being used by another process. This error has not been traced, but appears to relate to a process that keeps the user profile open after the user has logged off. Rebooting the computer before reattempting the migration the profile may solve the problem. Password Migration Migrated Passwords May Not Conform to Password Policy of the Target Domain A password policy is enforced only when the domain controller can read an entered password in plain text. Since the password migration tool does not decrypt the password, the Domain Controller cannot see it in clear text until the user is prompted to reset his/her password. The only policy that is still enforced is password history as this is based on the hash of the password. Password Migration in Networks Without NetBIOS If NetBIOS name resolution is not available between the ADMT computer and the Password Export Server (PES), the PES must be specified with the fully qualified domain name (FQDN) in the  Password Options  dialog box of the User or the Group Migration Wizards. Supplying the short name only results in the following error message: Server not operational Report Creation This section describes a known issue related to generating reports with this version of ADMT. Account Reference Report Fails to Enumerate Printers if Spooler Service Is Stopped If the printer sub-system or the spooler service is stopped on a remote Windows 2000 or Windows Server 2003 computer, the agent dispatched to the computer used to create the Account Reference Report fails to enumerate printers and logs the following error into the migration log file: ERR2:7173 Failed to enumerate the printers on the local machine, rc=1722  The RPC server is unavailable. Account Name Conflict Report Does Not Report Conflicts on inetOrgPerson Objects Correctly The Account Name Conflict Report is run to determine whether migrations of users, groups or inetOrgPersons will create conflicts with existing objects in the target domain. Unreported name collisions could be caused by inetOrgPersons objects. inetOrgPerson Objects Are Reported as User Objects in the Migrated User Accounts Report After objects of the class inetOrgPerson are migrated, the Migrated User Accounts Report reports these objects with the class   instead of the  inetOrgPerson  class.  Online Help This section describes a known issue related to the online Help shipped with this version of ADMT. Help Window always stays on top. In any ADMT wizard, when the Help button is clicked and the Help window appears, when the user reactivates the wizard window, the Help window stays in the foreground.  ADMT Remote Agent Service  This section describes a known issue related to the ADMT remote agent shipped with this version of ADMT. The Agent Does Not Quit Upon Early Termination of the Command-line Tool or Visual Basic (VB) Script Using the CTRL+C key combination or some other method to terminate the ADMT prematurely does not stop the agent process. This process must be stopped manually. Alpha Support is Removed From ADMT Version 2.0. ADMT no longer supports deploying agents to Alpha machines. Agent Monitor Monitoring Settings Tab  The Monitoring Settings tab of the Agent Monitor is designed to allow the user to view different logs on the remote computer. Since there is only one log created by ADMT agents on the remote computer, this feature is not useful. SIDs That Cannot Be Resolved During Security Translation Are Displayed in Raw Format in the Migration Log File If SIDs cannot be resolved during security translations (that is, if the user / group was deleted), the SIDs are stored in raw format in the migration log file.  No Security Translation for Remote Desktop Settings Remote Desktop Settings includes a list of users that are allowed to remotely access a computer. This list is not updated during a migration with ADMT. To continue to use the Remote Desktop service the accounts in the source domain must be updated with the name of the accounts in the target domain once the user account is migrated.  Security Translations with SID Mapping Files Does Not Allow One to Many Translations When a SID Mapping file is used for security translations, the same account cannot be used multiple times as a source account.. If a SID Mapping file has the following content: Domain1\user1, domain2\user1 Domain1\user1, domain2\user2 and security translation runs in   mode, only domain2\user1 is added as trustee in security translations, not domain2\user2. ADMT Migration Database This section describes a known issue related to the ADMT migration database. Single Use State information that is critical to the proper operation of ADMT is stored in a Microsoft Access database named Protar.mdb. This database is installed in the same directory as all the other installation files for ADMT. Many of the wizards for this tool require some knowledge of previously migrated users or groups, such as the original source domain of the users, which users have been marked as service accounts, and other state information. All of this information is stored in the Protar.mdb database. With that in mind, some thought should given when the following actions are being considered: Moving ADMT operations to another computer. If, after performing some migration operations, ADMT is run from a different computer, Protar.mdb and Scmdata.txt should be copied from the original computer to that new computer. Reinstalling ADMT. If some migration operations have already occurred before reinstalling or upgrading over the existing installation of ADMT, save the Protar.mdb database and copy the saved database over the new version once the reinstallation is complete. Furthermore, take the following steps to protect the security and integrity of the database: Run only one instance of ADMT at a time. ADMT is not designed to support simultaneous operations. It is possible to have two installations of the tool carrying out migrations, but it requires disciplined practices to keep the databases manually synchronized.  Backup and Restore. The Protar.mdb database should be backed up frequently, especially if you are performing the migration process over an extended period of time. Intraforest Migration This section describes a known issue related to intraforest migrations. Domain-wide User and Group Rights Are Not Migrated to the Target Domain Intraforest user and group migrations fail to migrate domain-wide account rights even if the  User Rights  checkbox is selected. Global Group Migration and Mixed Mode Source Domains When global groups are migrated between a mixed mode source domain and a native mode target domain, and the groups are not empty, ADMT creates copies of the global groups in the target domain and does not add the SID of the source domain s global group to the SID history attribute. This is by design. In this situation, ADMT cannot convert the global group to a universal group because mixed mode domains do not recognize universal groups and cannot add them to the access token of the user. Therefore, the users would lose access to resources. It is strongly recommended to migrate users and groups between native mode domains only. Global Groups Are Copied Without SIDHistory for Intraforest Migrations If Not Migrated with Group Members and the Source Domain is in Mixed Mode When migrating a global group in a mixed mode domain for an intraforest migration using the Group Migration Wizard, if the Copy Group Members option is not selected, that global group will be copied, not migrated, without SID history instead of moved. This behavior is a result of the rules of global group membership. If ADMT moves, rather than copies, the global group, the group members are  orphaned  from the group and lose any resource access granted through membership of the group because global groups cannot contain members from other domains. When that global group s members are later migrated, the group membership is restored, but because SID history is not migrated with the group, you must run the Security Translation Wizard to update the access control lists (ACLs), just as you would do in an interforest migration without SID history. It is strongly recommended that you migrate users and groups only between native mode domains only. Undo Operations and Mixed Mode Source Domains Undo operations of user and group migrations are not supported when the source domain is mixed mode. This is by design. An undo is a re-migration to the source domain, and ADMT only supports native mode domains as target domains for migrations. It is strongly recommended that users and groups migrate between native mode domains only. Migrated Objects Table Does Not Sync If the administrator in the target domain deletes a migrated group after the migration, then the entries for the migrated group are not removed from the migrated object table. If a group with the same name as the group deleted in the target domain is migrated from the source domain, an error can occur. This error occurs only if users are migrated with the group. The error message is: ERR2:7422 Failed to move object <object_RDN>, hr=80070057  The parameter is incorrect. Command-line Tool Note that the command-line tool uses the scripting component and, therefore, scripting issues are also applicable to the command-line tool. Command Line and Scripting Do Not Provide Detailed Error Messages When ADMT is invoked from a command line or script, the calling process waits until ADMT has finished the migration task to return a general success or error message. Detailed information is only available through the migration log file. The command-line does display the contents of migration logs as part of the standard output. Duplicate Command-line Parameters Override any Previous Occurrences If a command-line parameter is specified more the once, the last value overrides the previous value. This is by design. Extended Characters Are Not Displayed by Command-line Interface The ADMT command-line interface does not convert Unicode to original equipment manufacturer (OEM). Therefore, extended characters such as the German  Umlaut  do not display correctly. Enable Source Account Option Not Disabled in Intra-Forest Migrations In intraforest migrations, accounts are moved and not copied between domains. The source account is destroyed as part of the move. However, the option to enable a source account is available through the ADMT command line interface. Using the option will result into the following warning: WRN1:  7362: <object_name> - Could not enable source account.  The parameter is wrong If the Undo Wizard is used to undo an operation, ADMT attempts to enable the account. This will fail and create the same warning. Help Documentation Errors User Migration Wizard Password Option Help File In the Password Options help for the User Migration Wizard a note cuts off in the middle of a sentence. The sentence currently reads as follows: When users are migrated multiple times This note should read: When users are migrated multiple times the password history is half of what is expected. For example, if a user is migrated four times to a target domain with that has a password policy set, the target domain will prevent only the first two passwords from being reused. Group Migration Wizard Help File In the Group Migration Wizard the help file for the Name Conflict wizard page has some text that refers to a check box option. This text reads as follows:  Move replaced accounts to the previously specified target Organizational Unit This text should read: Move replaced accounts to specified target Organizational Unit Security Translation Wizard Help File In the Security Translation Wizard, the Translate Objects Wizard Page Help File, the User Rights section, and the For More Information section at the bottom of the page read as follows: User Rights Translates security For More information see Security identifier (SID) translation. This text should read: User Rights Translates security for user right ACLs on the migrated computer. For more information see security identifier (SID) translation and the Help for the Security Translation Options wizard page. Command Line Group Syntax Help File In the ADMT Group Syntax help file the text for the migrateSIDs option reads as follows: Migrates the SID from the source account and creates a SID History on the source account.  This text should read: Migrates the SID from the source account and creates a SID History on the target account. Command Line Syntax Notes Help File In the ADMT Command-Line Notes help file text under the Using Option Files section reads as follows: You can use migration files to update objects without retyping information at the command prompt. This text should read: You can use option files to update objects without retyping information at the command prompt.  Microsoft Active Directory Migration Tool (ADMT) Release Notes Microsoft Active Directory Migration Tool (ADMT) Release Notes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\documents\help-ms\admtglos.rtf ===
{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;} {\f11\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f29\fswiss\fcharset0\fprq2{\*\panose 020b0506020202030204}Arial Narrow;}{\f30\fmodern\fcharset0\fprq1{\*\panose 020b0509030504030204}Lucida Sans Typewriter;} {\f161\froman\fcharset238\fprq2 Times New Roman CE;}{\f162\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f164\froman\fcharset161\fprq2 Times New Roman Greek;}{\f165\froman\fcharset162\fprq2 Times New Roman Tur;} {\f166\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f168\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f177\fmodern\fcharset238\fprq1 Courier New CE;}{\f178\fmodern\fcharset204\fprq1 Courier New Cyr;} {\f180\fmodern\fcharset161\fprq1 Courier New Greek;}{\f181\fmodern\fcharset162\fprq1 Courier New Tur;}{\f182\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f183\fmodern\fcharset178\fprq1 Courier New (Arabic);} {\f184\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255; \red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li115\ri130\sb80\sl-240\slmult0 \widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\s1\ql \li115\ri130\sb280\sa40\sl-240\slmult0\widctlpar\nooverflow\faroman\outlinelevel0\rin130\lin115\itap0  \b\f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 1;}{\s2\ql \li115\ri130\sb120\sl-240\slmult0\widctlpar\nooverflow\faroman\outlinelevel1\rin130\lin115\itap0  \b\f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 heading 2;}{\s3\ql \li115\ri130\sb120\sa60\sl-240\slmult0\widctlpar\nooverflow\faroman\outlinelevel2\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \snext0 heading 3;}{\s4\ql \fi-245\li360\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\outlinelevel3\rin130\lin360\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 4;}{ \s5\ql \li0\ri130\sb40\sa40\sl-240\slmult0\widctlpar\nooverflow\faroman\outlinelevel0\rin130\lin0\itap0 \b\f11\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon1 \snext0 heading 5;}{\s6\ql \li0\ri130\sb40\sl-238\slmult0 \widctlpar\pvpara\posy0\absh255\dxfrtext130\dfrmtxtx130\dfrmtxty0\nooverflow\faroman\outlinelevel0\rin130\lin0\itap0 \b\f11\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon1 \snext15 heading 6;}{\*\cs10 \additive Default Paragraph Font;}{ \s15\ql \li115\ri130\sb40\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 H6p;}{\s16\ql \li720\ri130\sb80\sl-240\slmult0 \widctlpar\nooverflow\faroman\rin130\lin720\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 Normal Indent;}{\*\cs17 \additive \cf6 \sbasedon10 annotation reference;}{\s18\ql \fi-187\li302\ri130\sb48\sl-240\slmult0 \widctlpar\tx302\nooverflow\faroman\rin130\lin302\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon19 \snext18 Lb2;}{\s19\ql \fi-187\li302\ri130\sb80\sl-240\slmult0\widctlpar\tx302\nooverflow\faroman\rin130\lin302\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext18 Lb1;}{\*\cs20 \additive \up6 \sbasedon10 footnote reference;}{\s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 footnote text;}{\s22\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon0 \snext22 endnote text;}{\*\cs23 \additive \fs16\cf5 HTML Tag;}{\*\cs24 \additive \fs16\cf0\up6 ExternalFN;}{\*\cs25 \additive \ulnone\super NonXlatableBitmap;}{\*\cs26 \additive \v\fs20\cf6\up0\nosupersub NonXlatableLink;}{ \s27\ql \fi-187\li274\ri130\sb80\sl-120\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \tx302\nooverflow\faroman\rin130\lin274\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 a/k link;}{ \s28\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext28 annotation text;}{ \s29\ql \li115\ri130\sb120\sa120\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 bitmap;}{\s30\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 Context;}{\s31\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon0 \snext31 Jl;}{\s32\ql \fi-158\li461\ri130\sb48\sl-240\slmult0\widctlpar\tx461\nooverflow\faroman\rin130\lin461\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon18 \snext32 Lb3;}{\s33\ql \li302\ri130\sb60\sl-240\slmult0 \widctlpar\tx302\nooverflow\faroman\rin130\lin302\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon18 \snext18 Lp1;}{\s34\ql \fi-187\li274\ri130\sl-120\slmult0\widctlpar\tx302\nooverflow\faroman\rin130\lin274\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon27 \snext34 oem a/k link;}{\s35\ql \fi-302\li418\ri86\sa120\sl-240\slmult0\widctlpar\nooverflow\faroman\rin86\lin418\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon0 \snext35 oem button;}{\s36\ql \fi-302\li418\ri86\sb160\sa120\sl-240\slmult0\widctlpar\tx720\nooverflow\faroman\rin86\lin418\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon35 \snext36 oem button1;}{ \s37\ql \fi-187\li302\ri0\sb160\sl-240\slmult0\widctlpar\tx302\nooverflow\faroman\rin0\lin302\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext37 oem Lb1;}{\s38\ql \li115\ri130\sb160\sl-240\slmult0 \widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext38 oem normal;}{\s39\ql \li115\ri2160\sb160\sl-240\slmult0\widctlpar\nooverflow\faroman\rin2160\lin115\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext39 oem popup;}{\s40\ql \li0\ri2160\widctlpar\nooverflow\faroman\rin2160\lin0\itap0 \f11\fs12\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon39 \snext40  oem popup end;}{\s41\ql \fi-187\li302\ri2160\sb160\sl-240\slmult0\widctlpar\tx302\nooverflow\faroman\rin2160\lin302\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon37 \snext41 oem popup Lb1;}{ \s42\ql \li115\ri0\sb240\sl-240\slmult0\widctlpar\nooverflow\faroman\rin0\lin115\itap0 \b\f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext42 oem proc head;}{\s43\ql \li115\ri86\sb80\sl-240\slmult0 \widctlpar\nooverflow\faroman\rin86\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 oem tb text;}{\s44\ql \li58\ri0\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin0\lin58\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext44 oem tb text 2;}{\s45\ql \fi-187\li245\ri0\sb80\sl-240\slmult0\widctlpar\tx245\tx302\nooverflow\faroman\rin0\lin245\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon19 \snext45 oem tb text 2 Lb1;}{\s46\ql \fi-187\li245\ri0\sb48\sl-240\slmult0\widctlpar\tx245\tx302\nooverflow\faroman\rin0\lin245\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon18 \snext46 oem tb text 2 Lb2;}{\s47\ql \fi-158\li403\ri0\sb48\sl-240\slmult0\widctlpar\tx403\tx461\nooverflow\faroman\rin0\lin403\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon32 \snext47 oem tb text 2 Lb3;}{\s48\ql \li115\ri130\sb80\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon0 \snext48 Pop-up;}{\s49\ql \li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \b\f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext19 proc head;}{\s50\ql \li115\ri86\sb280\sl-240\slmult0 \widctlpar\nooverflow\faroman\rin86\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon35 \snext35 table top;}{\s51\ql \li58\ri0\sb280\sl-240\slmult0\widctlpar\nooverflow\faroman\rin0\lin58\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon50 \snext44 table top 2;}{\s52\ql \fi-317\li432\ri130\sb120\sl-240\slmult0\widctlpar\tx432\tx576\nooverflow\faroman\rin130\lin432\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon18 \snext52 Tbr1;}{\s53\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon0 \snext0 Tech Rev;}{\s54\ql \li58\ri0\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin0\lin58\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon50 \snext54 vertrule;}{\s55\ql \fi-302\li388\ri130\sb80\sl-240\slmult0 \widctlpar\tqr\tx274\tx389\nooverflow\faroman\rin130\lin388\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon19 \snext55 Lb1a;}{\s56\ql \fi-302\li388\ri130\sb48\sl-240\slmult0\widctlpar \tqr\tx274\tx389\nooverflow\faroman\rin130\lin388\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon55 \snext56 Lb2a;}{\s57\ql \fi-547\li662\ri187\sb60\sa60\sl240\slmult0\nowidctlpar\tx660\nooverflow\faroman\rin187\lin662\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext57 Np;}{\s58\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f2\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0  Code;}{\*\cs59 \additive \cf12 \sbasedon10 HTML;}{\*\cs60 \additive \b \sbasedon10 UI;}{\*\cs61 \additive \scaps\fs14 \sbasedon10 Smallcaps;}{\s62\ql \li240\ri130\sb20\sa60\sl-220\slmult0\widctlpar\tx280\tx560\nooverflow\faroman\rin130\lin240\itap0  \f11\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext62 Tp;}{\s63\ql \li0\ri130\sb20\sa60\sl-220\slmult0\keepn\widctlpar\nooverflow\faroman\rin130\lin0\itap0 \b\f11\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon66 \snext66 Thf;}{\s64\qr \li115\ri130\sb80\sl-160\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs12\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 Le;}{\s65\qr \li115\ri130\sb80\sl-80\slmult0 \widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs12\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon64 \snext1 Leh;}{\s66\ql \li240\ri130\sb20\sa60\sl-220\slmult0\keepn\widctlpar\nooverflow\faroman\rin130\lin240\itap0  \b\f11\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext66 Th;}{\s67\ql \li0\ri130\sb20\sa60\sl-220\slmult0\widctlpar\tx280\tx560\nooverflow\faroman\rin130\lin0\itap0 \f11\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon62 \snext67 Tpf;}{\s68\ql \li-280\ri0\sl-80\slmult0\keepn\pagebb\widctlpar\pvpara\phpg\posy0\dxfrtext180\dfrmtxtx180\dfrmtxty0\nooverflow\faroman\rin0\lin-280\itap0 \fs12\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Pb;}{ \s69\ql \fi-187\li302\ri130\sb80\sl-240\slmult0\widctlpar\tx302\nooverflow\faroman\rin130\lin302\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon19 \snext64 Lbp;}{\s70\ql \fi-440\li280\ri130\sb80\sa80\sl-240\slmult0\widctlpar \tqr\tx160\tx280\nooverflow\faroman\rin130\lin280\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext70 Ln1;}{\s71\ql \fi-600\li560\ri130\sb80\sa80\sl-240\slmult0\widctlpar \tqr\tx440\tx560\nooverflow\faroman\rin130\lin560\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon70 \snext71 Ln2;}{\s72\ql \li560\ri130\sb60\sl-240\slmult0\widctlpar\tx302\nooverflow\faroman\rin130\lin560\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon33 \snext72 Lp2;}{\s73\qr \li30\ri30\sb80\sa80\sl-180\slmult0\widctlpar\brdrt\brdrs\brdrw15\brsp20 \nooverflow\faroman\rin30\lin30\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 Te;}{\s74\qr \li115\ri130\sb80\sl-100\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs12\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon65 \snext1  Teh;}{\s75\qr \li310\ri30\sb80\sa80\sl180\slmult0\widctlpar\brdrt\brdrs\brdrw15\brsp20 \nooverflow\faroman\rin30\lin310\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext70 Tei;}{\s76\ql \li0\ri0\sb40\sl-238\slmult0 \keepn\widctlpar\pvpara\posy0\absh235\dxfrtext130\dfrmtxtx130\dfrmtxty0\nooverflow\faroman\rin0\lin0\itap0 \b\f29\fs21\cf2\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon77 \snext78 Wh;}{\s77\ql \li0\ri0\sb40\sl-238\slmult0 \keepn\widctlpar\pvpara\posy0\absh235\dxfrtext130\dfrmtxtx130\dfrmtxty0\nooverflow\faroman\rin0\lin0\itap0 \b\f29\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext78 Nh;}{\s78\ql \li115\ri130\sb40\sa80\sl-240\slmult0 \keepn\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon79 \snext80 Np1;}{\s79\ql \li115\ri130\sb80\sa80\sl-240\slmult0\keepn\widctlpar\nooverflow\faroman\rin130\lin115\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext80 Np2;}{\s80\ql \li30\ri30\sa40\sl-140\slmult0\widctlpar\brdrt\brdrs\brdrw15\brsp20 \nooverflow\faroman\rin30\lin30\itap0  \fs12\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Ne;}{\s81\ql \li30\ri30\sb40\sl-80\slmult0\keepn\widctlpar\brdrb\brdrdb\brdrw15\brdrcf2 \nooverflow\faroman\rin30\lin30\itap0 \fs12\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \snext76 Ws;}{\s82\ql \li30\ri30\sb80\sl-200\slmult0\widctlpar\brdrt\brdrdb\brdrw15\brsp20\brdrcf2 \nooverflow\faroman\rin30\lin30\rtlgutter\itap0 \f11\fs16\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 We;}{ \s83\ql \li30\ri30\sl-80\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brsp20 \nooverflow\faroman\rin30\lin30\itap0 \fs12\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext77 Ns;}{\s84\ql \li280\ri0\sb40\sl-238\slmult0 \keepn\widctlpar\pvpara\posy0\absh235\dxfrtext130\dfrmtxtx130\dfrmtxty0\nooverflow\faroman\rin0\lin280\itap0 \b\f29\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon77 \snext85 Nhi;}{\s85\ql \fi-280\li280\ri130\sb40\sa80\sl-240\slmult0 \keepn\widctlpar\nooverflow\faroman\rin130\lin280\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon78 \snext86 Np1i;}{\s86\ql \li310\ri30\sl-140\slmult0\widctlpar\brdrt\brdrs\brdrw15\brsp20 \nooverflow\faroman\rin30\lin310\itap0  \fs12\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon80 \snext70 Nei;}{\s87\ql \li310\ri30\sl-80\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brsp20 \nooverflow\faroman\rin30\lin310\itap0  \fs12\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon83 \snext84 Nsi;}{\s88\ql \li310\ri30\sb40\sl-80\slmult0\keepn\widctlpar\brdrb\brdrdb\brdrw15\brdrcf2 \nooverflow\faroman\rin30\lin310\itap0  \fs12\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon81 \snext89 Wsi;}{\s89\ql \li280\ri0\sb40\sl-238\slmult0\keepn\widctlpar\pvpara\posy0\absh235\dxfrtext130\dfrmtxtx130\dfrmtxty0\nooverflow\faroman\rin0\lin280\itap0  \b\f29\fs21\cf2\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon84 \snext85 Whi;}{\s90\ql \li280\ri280\sb220\sa40\sl-280\slmult0\keepn\widctlpar\nooverflow\faroman\rin280\lin280\itap0  \b\f29\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Sbrh;}{\s91\ql \li310\ri30\sb80\sl-140\slmult0\widctlpar\brdrt\brdrdb\brdrw15\brsp20\brdrcf2 \nooverflow\faroman\rin30\lin310\rtlgutter\itap0  \f11\fs12\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon82 \snext70 Wei;}{\s92\ql \li0\ri0\sb20\sa60\sl-220\slmult0\keepn\widctlpar\nooverflow\faroman\rin0\lin0\itap0 \b\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext93 Tt;} {\s93\qr \li0\ri0\sl-20\slmult0\keepn\widctlpar\brdrt\brdrs\brdrw15 \nooverflow\faroman\rin0\lin0\itap0 \fs8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Tr;}{\s94\ql \li-1800\ri0\sb20\sa60\sl-220\slmult0 \keepn\widctlpar\nooverflow\faroman\rin0\lin-1800\itap0 \b\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon92 \snext93 Ttw;}{\s95\ql \li-1800\ri0\sa420\sl-600\slmult0\keepn\pagebb\widctlpar\nooverflow\faroman\rin0\lin-1800\itap0  \b\f29\fs48\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Ih;}{\s96\ql \li0\ri0\sl-540\slmult0\keepn\widctlpar\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap\nooverflow\faroman\rin0\lin0\itap0  \b\f29\fs48\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Ch;}{\s97\ql \li0\ri0\sl-220\slmult0\widctlpar \tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630\nooverflow\faroman\rin0\lin0\itap0 \f30\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext97 Ex;}{ \s98\ql \fi-360\li0\ri0\sb80\sa80\sl-240\slmult0\keepn\widctlpar\tx280\nooverflow\faroman\rin0\lin0\itap0 \b\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext70 Proch;}{\s99\ql \li115\ri130\sb280\sa40\sl-240\slmult0 \widctlpar\nooverflow\faroman\rin130\lin115\itap0 \b\f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon1 \snext0 Hn1;}{\s100\ql \li115\ri130\sb120\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0  \b\f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon2 \snext0 Hn2;}{\s101\ql \li0\ri0\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty0\nooverflow\faroman\rin0\lin0\itap0  \f29\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Mp;}{\s102\ql \li115\ri240\sb100\sa40\sl240\slmult0\keepn\widctlpar\nooverflow\faroman\rin240\lin115\itap0 \b\f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon0 \snext103 Erm;}{\s103\ql \li115\ri130\sb80\sa100\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext103 Erp;}{\s104\ql \li-1800\ri0\sa280\sl-240\slmult0 \keepn\widctlpar\nooverflow\faroman\rin0\lin-1800\itap0 \caps\fs24\expnd24\expndtw120\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext96 Cn;}{\s105\ql \li280\ri0\sl-220\slmult0\widctlpar \tx670\tx1060\tx1450\tx1840\tx2230\tx2620\tx3010\tx3400\tx3790\tx4180\tx4570\tx4960\tx5350\tx5740\tx6130\tx6520\tx6910\nooverflow\faroman\rin0\lin280\itap0 \f30\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon97 \snext105 Exl;}{ \s106\ql \li0\ri0\sa240\sl-220\slmult0\widctlpar\tx280\tx560\nooverflow\faroman\rin0\lin0\itap0 \b\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Cap;}{\s107\ql \li-1770\ri30\sb50\sl-80\slmult0\widctlpar\brdrt\brdrs\brdrw15\brdrcf2  \nooverflow\faroman\rin30\lin-1770\rtlgutter\itap0 \fs12\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 header rule;}{\s108\ql \li-1800\ri0\sa180\sl-440\slmult0\keepn\widctlpar\tx0\nooverflow\faroman\rin0\lin-1800\itap0  \b\f29\fs40\up6\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext109 Rh1;}{\s109\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\nooverflow\faroman\rin0\lin0\itap0  \b\f29\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Rmh;}{\s110\ql \li115\ri240\sb20\sa60\sl240\slmult0\keepn\widctlpar\nooverflow\faroman\rin240\lin115\itap0 \b\f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon102 \snext110 Ermn;}{\s111\ql \li115\ri130\sb120\sa60\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon3 \snext0 Hn3;}{\s112\ql \li0\ri0\sl-240\slmult0 \keepn\widctlpar\nooverflow\faroman\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext113 Term1;}{\s113\ql \li280\ri130\sb80\sa80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin280\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext112 Def1;}{\s114\ql \li280\ri130\sb80\sa80\sl-240\slmult0\keepn\widctlpar\nooverflow\faroman\rin130\lin280\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon79 \snext86 Np2i;}{\s115\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\nooverflow\faroman\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon112 \snext116 Term2;}{\s116\ql \li560\ri130\sb80\sa80\sl-240\slmult0 \widctlpar\nooverflow\faroman\rin130\lin560\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon113 \snext115 Def2;}{\s117\ql \li-1800\ri0\sl-220\slmult0\widctlpar \tx-1410\tx-1020\tx-630\tx-240\tx150\tx540\tx930\tx1320\tx1710\tx2100\tx2490\tx2880\tx3270\tx3660\tx4050\tx4440\tx4830\tx5220\tx5610\tx6000\tx6390\tx6780\nooverflow\faroman\rin0\lin-1800\itap0 \f30\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon97 \snext117 Exw;}{\s118\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \nooverflow\faroman\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext108 Rule;}{ \s119\ql \li-1800\ri130\sb80\sl-240\slmult0\widctlpar\tx-1520\tx-1240\tx-960\tx-680\tx-400\tx-120\tx160\tx440\tx720\tx1000\nooverflow\faroman\rin130\lin-1800\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 Synw;}{ \s120\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar \tx280\tx560\tx840\tx1120\tx1400\tx1680\tx1960\tx2240\tx2520\tx2800\tx3080\tx3360\tx3640\tx3920\tx4200\tx4480\tx4760\tx5040\tx5320\tx5600\tx5880\tx6160\tx6440\tx6720\nooverflow\faroman\rin130\lin115\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 Syn;}{\s121\ql \li115\ri130\sb80\sa80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon0 \snext121 Lmc;}{\s122\ql \li115\ri130\sb80\sa80\sl-240\slmult0\keepn\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext70 Procp;}{ \s123\ql \fi-280\li520\ri130\sb20\sa60\sl-220\slmult0\widctlpar\tx520\nooverflow\faroman\rin130\lin520\itap0 \f11\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon62 \snext123 Tpi;}{\s124\qr \li240\ri130\sb20\sa60\sl-220\slmult0 \widctlpar\nooverflow\faroman\rin130\lin240\itap0 \f11\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon62 \snext62 Tpr;}{\s125\ql \li0\ri0\sb20\sa60\sl-220\slmult0\widctlpar \tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630\nooverflow\faroman\rin0\lin0\itap0 \f30\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon97 \snext125 Texf;}{ \s126\ql \fi-140\li140\ri130\sb20\sa40\sl-200\slmult0\widctlpar\tx280\nooverflow\faroman\rin130\lin140\itap0 \f11\fs17\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon62 \snext126 Tf;}{\s127\qr \li-1770\ri30\sb80\sa80\sl180\slmult0\widctlpar \brdrt\brdrs\brdrw15\brsp20 \nooverflow\faroman\rin30\lin-1770\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon73 \snext0 Tew;}{\s128\ql \li-1800\ri0\sb80\sa240\widctlpar\tx0\tx280\tx560\nooverflow\faroman\rin0\lin-1800\itap0  \fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Art;}{\s129\ql \fi-280\li280\ri130\sb20\sa60\sl-220\slmult0\widctlpar\tx280\nooverflow\faroman\rin130\lin280\itap0 \f11\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon123 \snext129 Tpif;}{\s130\ql \li0\ri0\sl-640\slmult0\keepn\widctlpar\pvpara\phmrg\posnegx-1801\posy2\absh-2460\absw6720\dxfrtext180\dfrmtxtx180\dfrmtxty0\nowrap\nooverflow\faroman\rin0\lin0\itap0  \fs60\cf2\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon96 \snext0 Ph;}{\s131\ql \li115\ri130\sb80\sa80\sl-240\slmult0\keepn\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \v\f29\fs24\cf5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon0 \snext0 index;}{\s132\ql \li0\ri0\sl-220\slmult0\widctlpar\tqr\tx1560\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty0\nooverflow\faroman\rin0\lin0\itap0 \b\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon106 \snext0 CapSd;}{\s133\ql \li0\ri0\sa240\keepn\widctlpar\tqr\tx1560\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty0\nooverflow\faroman\rin0\lin0\itap0 \fs28\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon128 \snext0  ArtSd;}{\s134\ql \li240\ri0\sb20\sa60\sl-220\slmult0\widctlpar\tx630\tx1020\tx1410\tx1800\tx2190\tx2580\tx2970\tx3360\tx3750\tx4140\tx4530\tx4920\tx5310\tx5700\tx6090\tx6480\tx6870\nooverflow\faroman\rin0\lin240\itap0  \f30\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon125 \snext134 Tex;}{\s135\ql \li115\ri120\sb80\sl-360\slmult0\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp80\brdrcf8 \brdrl\brdrs\brdrw15\brsp80\brdrcf8 \brdrb\brdrs\brdrw15\brsp80\brdrcf8  \brdrr\brdrs\brdrw15\brsp80\brdrcf8 \pvpara\phmrg\posxr\posy0\absh-390\nooverflow\faroman\rin120\lin115\rtlgutter\itap0 \shading6000\cfpat2 \b\f29\fs24\cf8\up10\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext108 *hb2;}{ \s136\qc \fi-245\li360\ri130\sl-360\slmult0\widctlpar\brdrt\brdrs\brdrw15\brsp20\brdrcf8 \brdrl\brdrs\brdrw15\brsp20\brdrcf8 \brdrb\brdrs\brdrw15\brsp20\brdrcf8 \brdrr\brdrs\brdrw15\brsp20\brdrcf8  \pvpara\phpg\posy0\absh-390\absw1460\dxfrtext220\dfrmtxtx220\dfrmtxty0\nooverflow\faroman\rin130\lin360\rtlgutter\itap0 \shading6000\cfpat2 \f11\fs16\cf8\up4\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon4 \snext4 *hb1;}{ \s137\ql \li0\ri130\sb20\sa60\widctlpar\tx240\tx280\tx560\nooverflow\faroman\rin130\lin0\itap0 \f11\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon62 \snext137 Tart;}{\s138\ql \li560\ri0\sl-220\slmult0\widctlpar \tx950\tx1340\tx1730\tx2120\tx2510\tx2900\tx3290\tx3680\tx4070\tx4460\tx4850\tx5240\tx5630\tx6020\tx6410\tx6800\nooverflow\faroman\rin0\lin560\itap0 \f30\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon105 \snext138 Exl2;}{ \s139\ql \li115\ri130\sb20\sa60\sl-220\slmult0\widctlpar \tx280\tx560\tx840\tx1120\tx1400\tx1680\tx1960\tx2240\tx2520\tx2800\tx3080\tx3360\tx3640\tx3920\tx4200\tx4480\tx4760\tx5040\tx5320\tx5600\tx5880\tx6160\tx6440\tx6720\nooverflow\faroman\rin130\lin115\itap0  \f11\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon120 \snext139 Tsyn;}{\s140\qr \li115\ri130\sb80\sl-140\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs12\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon0 \snext0 Tes;}{\s141\ql \fi-300\li420\ri140\sb100\sl-210\slmult0\widctlpar\tx140\tx420\nooverflow\faroman\rin140\lin420\itap0 \f29\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext141 *Cbx;}{ \s142\ql \fi-300\li420\ri140\sb100\sa100\sl-210\slmult0\widctlpar\tx140\tx420\nooverflow\faroman\rin140\lin420\itap0 \f29\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon141 \snext93 *Cbxe;}{\s143\ql \li560\ri130\sb80\sa40\sl-240\slmult0 \widctlpar\tqr\tldot\tx6960\nooverflow\faroman\rin130\lin560\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon144 \snext143 \sautoupd toc 3;}{\s144\ql \li115\ri130\sb80\sa40\sl-240\slmult0\widctlpar \tqr\tldot\tx6960\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext145 \sautoupd toc 1;}{\s145\ql \li280\ri130\sb80\sa40\sl-240\slmult0\widctlpar \tqr\tldot\tx6960\nooverflow\faroman\rin130\lin280\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon144 \snext145 \sautoupd toc 2;}{\s146\ql \li0\ri0\sl140\slmult0 \widctlpar\pvpg\phpg\posx1999\posy14702\nooverflow\faroman\rin0\lin0\itap0 \fs10\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext146 footer;}{\s147\ql \li-1800\ri0\sl-210\slmult0\widctlpar \tqr\tx6960\nooverflow\faroman\rin0\lin-1800\itap0 \b\f29\fs19\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext107 header;}{\s148\ql \li-240\ri0\sl-300\slmult0\widctlpar\nooverflow\faroman\rin0\lin-240\itap0  \fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Sbre;}{\s149\ql \li280\ri280\sb40\sa40\sl-240\slmult0\keepn\widctlpar\nooverflow\faroman\rin280\lin280\itap0 \b\f29\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Sbrh2;}{ \s150\ql \li-240\ri0\sl-100\slmult0\keepn\widctlpar\nooverflow\faroman\rin0\lin-240\itap0 \fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext90 Sbrs;}{\s151\ql \li280\ri280\sl-220\slmult0\keepn\widctlpar \tx670\tx1060\tx1450\tx1840\tx2230\tx2620\tx3010\tx3400\tx3790\tx4180\tx4570\tx4960\tx5350\tx5740\tx6130\tx6520\nooverflow\faroman\rin280\lin280\itap0 \f30\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext151 SbrEx;}{ \s152\ql \fi-280\li560\ri280\sb80\sa80\sl-240\slmult0\keepn\widctlpar\tx560\nooverflow\faroman\rin280\lin560\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext152 SbrLb;}{\s153\qr \li280\ri280\sb80\sl-160\slmult0 \keepn\widctlpar\nooverflow\faroman\rin280\lin280\itap0 \f11\fs12\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 SbrLe;}{\s154\ql \fi-280\li560\ri280\sb80\sa80\sl-240\slmult0\keepn\widctlpar \tx560\nooverflow\faroman\rin280\lin560\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon152 \snext152 SbrLp;}{\s155\ql \li280\ri280\sa160\sl-240\slmult0\keepn\widctlpar\nooverflow\faroman\rin280\lin280\itap0  \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext155 Sbrp;}{\s156\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\cf11\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext156  Print only;}{\s157\ql \li115\ri130\sb40\sa80\sl-240\slmult0\keepn\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \i\v\f11\fs23\cf6\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext157 ?;}{\*\cs158 \additive \i \sbasedon10 New term;}{\* \cs159 \additive \i \sbasedon158 nt;}{\*\cs160 \additive \b \sbasedon10 URL;}{\*\cs161 \additive \sbasedon10 keyword;}{\s162\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0  \i\v\f11\fs23\cf6\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext162 Comment;}{\*\cs163 \additive \i \sbasedon10 Cross ref Book Title;}{\*\cs164 \additive \sbasedon10 Cross ref NTRK;}{\*\cs165 \additive \v \sbasedon10 Link;}}{\info {\title #A Windows 2000 security feature that locks a user account if a number of failed logon attempts occur within a specified amount of time, based on security policy lockout settings}{\author Gina Lozier}{\operator Jason Hershey} {\creatim\yr2000\mo1\dy20\hr13\min50}{\revtim\yr2000\mo1\dy20\hr15\min36}{\printim\yr1999\mo3\dy31\hr13\min23}{\version3}{\edmins1}{\nofpages24}{\nofwords904}{\nofchars5158}{\*\company Microsoft}{\nofcharsws0}{\vern8247}} \widowctrl\ftnbj\aendnotes\ftnnrlc\aftnnar\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\linkstyles\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind4\viewscale100\nolnhtadjtbl \fet0 {\*\template D:\\Atlantica_Vss\\ADMT\\what7.dot}\sectd \linex0\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7 \pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \ql \li115\ri130\sb80\sl-240\slmult0 \widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs20\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0  \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ AccountDomain}}}{ A Windows\~NT domain in the multiple master domain model that contains user accounts.  \par \page }{\cs20\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs20\up6 #}{ Agent}}}{  In Active Directory Migration Tool, agents are dispatched to individual computers to perform operations that c an only be performed locally. An agent runs as a service on the individual computer. Examples of operations performed by an agent include changing the computer's logon domain, updating security permissions on resources, and migrating local profiles.  \par See also dispatcher. \par \page }{\cs20\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs20\up6 #}{ Dispatcher}}}{  Software that determines what pending tasks should be done next and assigns the available resources to accomplish the tasks. It may execute other programs or generate a list for human operators to follow. In Active Directory  Migration Tool, the dispatcher sends agents to individual computers and monitors their progress.  \par See also agent. \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ DomainCollapse}}}{  A form of restructure, where one or more child domains are restructured into their parent domain. \par See also restructure.  \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ DomainConsolidation}}}{  A form of restructure, where two or more domains are combined into a smaller number of domains.  \par See also restructure. \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ DomainMigration}}}{  The process of moving user accounts, groups, or computer accounts in a Windows\~NT domain to a Windows\~2000 native mode domain. Domain migration can be achieved either by upgrading the Windows\~NT domain to Windows\~2000, or by creating an ideal Windows \~2000 forest, and moving the objects from the Windows\~NT domain to a Windows\~2000 domain in the new forest.  \par See also domain upgrade; native mode. \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ DomainRestructure}}}{  The process of changing the current domain structure to an ideal domain structure. This involves creating or identifying the appropriate destination for users and groups in the forest and cloning or moving users and groups from their current location.  \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ DomainUpgrade}}}{  The process of upgrading a Windows\~NT domain to Windows\~2000 by upgrading the primary domain controller (PDC). This domain is now a Windows\~2000 mixed mode  domain. After the first upgrade the backup domain controllers (BDCs) can be upgraded. When all of the BDCs have been upgraded, the domain can be switched into native mode.  \par See also mixed mode; native mode.  \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ Forest}}}{ A collection of one or more Windows\~ 2000 domains that share a common schema, configuration, and global catalog and are linked with two-way transitive trusts.  \par See also intraforest migration; interforest migration.  \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ IntraforestMigration}}}{  The process of moving security principals and resources from one Windows\~2000 domain in a forest to another Windows\~2000 domain in the same forest.  \par See also interforest migration; forest.  \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ InterforestMigration}}}{  The process of moving security principals and resources from a Windows\~NT domain or a Windows\~2000 domain in one forest to a Windows\~2000 domain in a different forest.  \par See also intraforest migration; forest.  \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ MemberAccount}}}{  A user account that is a member of a particular group.  \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ MixedMode}}}{  The default domain mode setting on Windows\~2000 domain controllers. Mixed mode allows Windows\~NT and Windows\~2000 backup domain controllers to co-exist in a domain. Mixed mode does not support the universal and nested group enhancements of Windows\~ 2000. The domain mode setting can be changed to Windows\~2000 native mode when all Windows\~NT domain controllers are removed from a domain.  \par See also native mode; Windows\~2000 Server Help.  \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ NativeMode}}}{  The condition in which all domain controllers in the domain have been upgraded to Windows\~2000 and an admi nistrator has enabled native mode operation through Active Directory Users and Computers. Features such as universal groups, domain local groups, group nesting, and SID History are available in native mode.  \par See also mixed mode; SID History; Windows\~2000 Server Help.  \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ ResourceDomain}}}{ A Windows\~ NT domain that is used for hosting file, print, and other application services.  \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ SecurityPrincipal}}}{ A Windows\~NT or Windows\~ 2000 entity that is automatically assigned a security identifier for access to resources. A security principal can be a user, group, or computer. Windows\~2000 uses Active Directory for account management of security principals. \par \page }{\cs20\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs20\up6 #}{ SecurityDescriptor}}}{ A se t of information attached to an object that specifies the permissions granted to users and groups, as well as the security events to be audited. \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ SID}}}{  A unique number that identifies user, group, and computer accounts. Every account on your network is issued a unique SID when the account is first created. Internal processes in Windows\~ 2000 refer to an account's SID rather than the account's user or group name. If you create an account, delete it, and then create an account with the same user name, the ne w account will not have the rights or permissions previously granted to the old account because the accounts will have different SID numbers. Security identifier is also called security ID or SID.  \par See also SID History.  \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ SIDHistory}}}{ An attribute of mig rated user and group accounts that holds the security identifier (SID) previously assigned to the account. After Windows\~2000 is deployed and after the Windows\~ NT account domain is decommissioned, SID History guarantees resource access from the cloned accounts during the migration process. The attribute is named sIDHistory.  \par See also SID.  \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ SourceDomain}}}{  The domain from which security principals or resources are being migrated. A source domain can be a Windows\~NT\~4.0 domain or a Windows\~2000 domain. Target and source domains can be in the same or different forests.  \par See also forest; security principal; target domain.  \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ SourceObject}}}{  The security principal object to be migrated.  \par See also security principal; SID History; target object.  \par \page }{\cs24\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs24\up6 #}{ TargetDomain}}}{  The domain into which the security principals or resources are being migrated. The target domain must be a Windows\~2000 domain in native mode. Target and source domains can be in the same or different forests.  \par See also domain migration; forest; native mode; security principal; target object.  \par \page }{\cs20\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs20\up6 #}{ TargetObject}}}{  The security principal in the target domain whose attributes have been migrated from a source object and whose SID History contains the SID of the source object.  \par See also security principal; SID; SID History; source object; target domain.  \par \page }{\cs20\up6 #{\footnote \pard\plain \s21\ql \li115\ri130\sb80\sl-240\slmult0\widctlpar\nooverflow\faroman\rin130\lin115\itap0 \f11\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cs20\up6 #}{ SharedLocalGroup}}}{  Local groups defined on primary and backup domain controllers running Windows\~NT 4.0 and earlier and used to grant access to resources on these domain controllers. A shared local group is sh ared across all domain controllers in the domain and it exists only within the domain in which it is defined. \par }}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\enumtest\x.txt ===
[TEXT: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\netobjen\enumtest\readme.txt ===
========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : EnumTest
========================================================================


AppWizard has created this EnumTest application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your EnumTest application.

EnumTest.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

EnumTest.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CEnumTestApp application class.

EnumTest.cpp
    This is the main application source file that contains the application
    class CEnumTestApp.

EnumTest.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Visual C++.

EnumTest.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.

res\EnumTest.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file EnumTest.rc.

res\EnumTest.rc2
    This file contains resources that are not edited by Microsoft 
	Visual C++.  You should place all resources not editable by
	the resource editor in this file.




/////////////////////////////////////////////////////////////////////////////

AppWizard creates one dialog class:

EnumTestDlg.h, EnumTestDlg.cpp - the dialog
    These files contain your CEnumTestDlg class.  This class defines
    the behavior of your application's main dialog.  The dialog's
    template is in EnumTest.rc, which can be edited in Microsoft
	Visual C++.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named EnumTest.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Visual C++ reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC42XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC42DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\setup\admt beta eula.rtf ===
{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f60\froman\fcharset0\fprq2{\*\panose 02040602050305030304}Book Antiqua;} {\f100\fswiss\fcharset0\fprq2{\*\panose 020b0706030402020204}Franklin Gothic Demi Cond;}{\f120\froman\fcharset238\fprq2 Times New Roman CE;}{\f121\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f123\froman\fcharset161\fprq2 Times New Roman Greek;} {\f124\froman\fcharset162\fprq2 Times New Roman Tur;}{\f125\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f126\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f127\froman\fcharset186\fprq2 Times New Roman Baltic;} {\f600\froman\fcharset238\fprq2 Book Antiqua CE;}{\f601\froman\fcharset204\fprq2 Book Antiqua Cyr;}{\f603\froman\fcharset161\fprq2 Book Antiqua Greek;}{\f604\froman\fcharset162\fprq2 Book Antiqua Tur;}{\f607\froman\fcharset186\fprq2 Book Antiqua Baltic;} {\f920\fswiss\fcharset238\fprq2 Franklin Gothic Demi Cond CE;}{\f921\fswiss\fcharset204\fprq2 Franklin Gothic Demi Cond Cyr;}{\f923\fswiss\fcharset161\fprq2 Franklin Gothic Demi Cond Greek;}{\f924\fswiss\fcharset162\fprq2 Franklin Gothic Demi Cond Tur;} {\f927\fswiss\fcharset186\fprq2 Franklin Gothic Demi Cond Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255; \red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{ \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\ql \li0\ri0\sb60\sl-220\slmult0 \widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \caps\f100\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext15 3b. ALL CAPS;}{\s16\ql \li0\ri0\widctlpar \tqr\tx10800\pvpg\phpg\posx720\posy14687\absw3600\abslock1\dxfrtext180\dfrmtxtx180\dfrmtxty180\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs18\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 \snext16 zDocID;}{\s17\ql \li0\ri0\widctlpar \tqc\tx4320\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext17 footer;}}{\info{\title SUPPLEMENTAL END USER LICENSE AGREEMENT (\'93Supplemental EULA\'94)} {\author Microsoft Corporation}{\operator Microsoft Corporation}{\creatim\yr2003\mo1\dy24\hr9\min18}{\revtim\yr2003\mo1\dy24\hr9\min18}{\version2}{\edmins0}{\nofpages2}{\nofwords750}{\nofchars3998}{\*\company Microsoft Corporation}{\nofcharsws4757} {\vern8269}}\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\formshade\horzdoc\dgmargin\dghspace100\dgvspace136\dghorigin1701\dgvorigin1984\dghshow2\dgvshow2 \jexpand\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule \fet0\sectd \sbknone\linex0\endnhere\sectlinegrid272\sectdefaultcl {\footer \pard\plain  \s17\ql \li0\ri0\widctlpar\tqc\tx4320\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f60\fs16  \par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}} {\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8 \pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0  \caps\f100\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\caps0\f60\fs22 SUPPLEMENTAL END USER LICENSE AGREEMENT (\'93Supplemental EULA\'94) \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f60\fs22  \par }\pard \ql \li0\ri0\widctlpar\brdrb\brdrs\brdrw10\brsp20 \aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\b\f60\fs22 ACTIVE DIRECTORY MIGRATION TOOL \par }\pard \ql \li0\ri0\widctlpar\brdrb\brdrs\brdrw10\brsp20 \aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f60\fs22  \par }\pard \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f60 IMPORTANT:  READ CAREFULLY \endash  The Microsoft software referenced above is subject to the terms and conditions of the end user license agreement under which you ha ve licensed certain OS Software (defined below) and this Supplemental End User License Agreement (\'93Supplemental EULA\'94).  The accompanying Microsoft software includes computer software and may include associated media, printed materials, \'93online \'94 or electronic documentation, and Internet-based services for use with a Microsoft operating system (\'93OS\'94) product (collectively, the \'93OS\~Components\'94 ).  The OS Components are provided to update, supplement, or replace existing functionality of the applicable Microsoft software for which the OS Components are designed (any such software referred to herein as \'93OS\~Software\'94 ).  An amendment or addendum to this Supplemental EULA may accompany the OS Components.   }{\f60\fs22 YOU AGREE TO BE BOUND BY THE TERMS OF THE APPLICABLE OS\~SOFTWARE END USER LICENSE AGREEMENT (\'93OS SOFTWARE EULA\'94 ) AND THIS SUPPLEMENTAL EULA BY INSTALLING, COPYING, OR OTHERWISE USING THE OS COMPONENTS.  IF YOU DO NOT AGREE, DO NOT INSTALL, COPY, OR USE THE OS\~COMPONENTS. \par }\pard \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f60\fs22  \par }\pard \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f60\fs22 IF YOU DO NOT HAVE A VALIDLY LICENSED COPY  OF THE APPLICABLE OS SOFTWARE, YOU ARE NOT AUTHORIZED TO INSTALL, COPY OR OTHERWISE USE THE OS COMPONENTS AND YOU HAVE NO RIGHTS UNDER THIS SUPPLEMENTAL EULA. \par }\pard \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f60\fs22  \par }\pard \ql \fi-480\li480\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin480\itap0 {\b\f60\fs22 1.\tab General}{\f60\fs22 . \par }\pard \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f60\fs22  \par }\pard\plain \s15\ql \fi-480\li980\ri0\widctlpar\tx180\aspalpha\aspnum\faauto\adjustright\rin0\lin980\itap0 \caps\f100\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\caps0\f60\fs22 1.1\tab  You are granted a license to use the OS Components under the terms and conditions of the OS\~ Software EULA (which are hereby incorporated by reference except as set forth below), the terms and conditions set forth in this Supplemental EULA, and the terms and conditions of any additional end user license agreement that may accomp any the individual OS\~Components (each an "Individual EULA"), provided that you comply with all such terms and conditions.}{\f60\fs22   }{\caps0\f60\fs22 To the extent that there is a conflict among any of these terms and conditions applicable to the OS \~Components, the following hierarchy shall apply: 1) the terms and conditions of the Individual EULA; 2) the terms and conditions in this Supplemental EULA; and 3) the terms and conditions of the applicable OS Software EULA.}{\f60\fs22  }{ \caps0\f60\fs22  \par }\pard \s15\ql \li0\ri0\widctlpar\tx360\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\caps0\f60\fs22  \par }\pard \s15\ql \fi-480\li980\ri0\widctlpar\tx180\aspalpha\aspnum\faauto\adjustright\rin0\lin980\itap0 {\caps0\f60\fs22 1.2\tab The OS Components are protected by copyright and other i ntellectual property laws and treaties.  Microsoft Corporation or its suppliers own the title, copyright, and other intellectual property rights in the OS Components.  All rights not expressly granted to you in this Supplemental EULA are reserved.  }{ \b\caps0\f60\fs22 The OS Components are licensed, not sold.}{\caps0\f60\fs22   \par }\pard \s15\ql \li0\ri0\widctlpar\tx180\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\caps0\f60\fs22  \par }\pard \s15\ql \fi-480\li980\ri0\widctlpar\tx180\aspalpha\aspnum\faauto\adjustright\rin0\lin980\itap0 {\caps0\f60\fs22 1.3\tab  Capitalized terms used in this Supplemental EULA and not otherwise defined herein shall have the meanings assigned to them in the applicable OS Software EULA. \par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f60\fs22  \par }\pard \ql \fi-480\li480\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin480\itap0 {\b\f60\fs22 2.\tab Additional Rights and Limitations}{\f60\fs22 .  }{\f60\fs22\expnd-1\expndtw-5 You may in stall and use the OS Components on an unlimited number of Devices, which are running validly licensed copies of a Windows server operating system, solely for the purposes of (a) migrating user accounts, security groups and computer accounts to Windows Act ive Directory, and (b) performing additional tasks subsequent to such migrations as enabled by the OS Components and described in the documentation associated with the OS Components.  }{\b\f60\fs22\expnd-1\expndtw-5 Note on Agent Component.}{ \f60\fs22\expnd-1\expndtw-5   In addition to the foregoing, you may install and use the \'93agent\'94  component of the OS Components on any Device that is running a validly licensed copy of any Windows operating system product, as may be necessary for such migration.  The foregoing license grant does }{\f60\fs22 not relieve you of any obligations th at you may have to purchase any client access licenses (CALs) required by the OS Software EULA for use of or access to the OS Software.   \par }\pard\plain \s15\ql \li0\ri0\widctlpar\tx180\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \caps\f100\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\caps0\f60\fs22  \par }\pard\plain \ql \fi-480\li480\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin480\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f60\fs22 3.\tab DISCLAIMER OF WARRANTIES}{\f60\fs22  .  THE LIMITED WARRANTY (IF ANY) INCLUDED IN THE APPLICABLE OS SOFTWARE EULA APPLIES TO  THE OS COMPONENTS PROVIDED THE OS COMPONENTS HAVE BEEN LICENSED BY YOU WITHIN THE TERM OF THE LIMITED WARRANTY IN THE APPLICABLE OS PRODUCT EULA.  THIS SUPPLEMENTAL EULA DOES NOT EXTEND THE TIME PERIOD FOR WHICH THE LIMITED WARRANTY IS PROVIDED. \par }\pard \qj \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f60\fs22  \par }\pard \qj \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f60\fs22\lang3084\langfe1033\langnp3084 Si vous avez acquis votre produit Microsoft au CANADA, le texte suivant vous concerne : \par }\pard \qj \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f60\fs22\lang3084\langfe1033\langnp3084  \par }\pard \qj \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f60\fs22\lang3084\langfe1033\langnp3084 LA GARANTIE LIMIT\'c9E (SI ELLE EXISTE) APPLICABLE EN VERTU DU CONTRAT DE LICENCE UTILISATEUR FINAL (\'ab CLUF \'bb) RELATIF \'c0  CE PRODUIT SYST\'c8ME D\rquote EXPLOITATION DE MICROSOFT (\'ab PRODUIT OS \'bb) S'APPLIQUE AUX COMPOSANTS SYST\'c8ME D'EXPLOITATION DE MICROSOFT Y COMPRIS TOUTE DOCUMENTATION \'ab EN LIGNE \'bb OU SOUS FORME \'c9LECTRONIQUE (LES \'ab COMPOSANTS OS \'bb ) APPLICABLES, \'c0 CONDITION QUE CEUX-CI VOUS AIENT \'c9T\'c9 CONC\'c9D\'c9S SOUS LICENCE PENDANT LA DUR\'c9E DE LA GARANTIE LIMIT\'c9E DU CLUF RELATIF AU PRODUIT OS APPLICABLE. LE PR\'c9SENT CLUF SUPPL\'c9MENTAIRE N'A PAS POUR EFFET DE PROROGER LA DUR \'c9E DE CETTE GARANTIE LIMIT\'c9E. \par }\pard \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f60\fs22  \par }\pard \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\f60\fs22 EULAID:WNET_RM.0_ADMT_STD_EN \par }}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\setup\active directory migration tool.rtf ===
{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;} {\f27\fswiss\fcharset0\fprq2{\*\panose 020b0604030504040204}Tahoma;}{\f28\froman\fcharset0\fprq0{\*\panose 00000000000000000000}CG Times (WN);}{\f29\fswiss\fcharset0\fprq2{\*\panose 020b0506020202030204}Arial Narrow;} {\f57\froman\fcharset238\fprq2 Times New Roman CE;}{\f58\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f60\froman\fcharset161\fprq2 Times New Roman Greek;}{\f61\froman\fcharset162\fprq2 Times New Roman Tur;} {\f62\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f63\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f64\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f73\fmodern\fcharset238\fprq1 Courier New CE;} {\f74\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f76\fmodern\fcharset161\fprq1 Courier New Greek;}{\f77\fmodern\fcharset162\fprq1 Courier New Tur;}{\f78\fmodern\fcharset177\fprq1 Courier New (Hebrew);} {\f79\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f80\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f273\fswiss\fcharset238\fprq2 Tahoma CE;}{\f274\fswiss\fcharset204\fprq2 Tahoma Cyr;}{\f276\fswiss\fcharset161\fprq2 Tahoma Greek;} {\f277\fswiss\fcharset162\fprq2 Tahoma Tur;}{\f278\fswiss\fcharset177\fprq2 Tahoma (Hebrew);}{\f279\fswiss\fcharset178\fprq2 Tahoma (Arabic);}{\f280\fswiss\fcharset186\fprq2 Tahoma Baltic;}{\f289\fswiss\fcharset238\fprq2 Arial Narrow CE;} {\f290\fswiss\fcharset204\fprq2 Arial Narrow Cyr;}{\f292\fswiss\fcharset161\fprq2 Arial Narrow Greek;}{\f293\fswiss\fcharset162\fprq2 Arial Narrow Tur;}{\f296\fswiss\fcharset186\fprq2 Arial Narrow Baltic;}}{\colortbl;\red0\green0\blue0; \red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128; \red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{ \s1\qc \li0\ri0\sl360\slmult1\keepn\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\fs24\ul\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 1;}{\*\cs10 \additive Default Paragraph Font;}{ \s15\ql \li0\ri0\sb60\sl-140\slmult0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \f28\fs12\expnd-1\expndtw-5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext15 3. LA Body;}{\s16\ql \li0\ri0\sb120\sl-200\slmult0 \nowidctlpar\brdrt\brdrs\brdrw15 \tx576\tx1152\tx1728\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\caps\f29\fs16\expnd-1\expndtw-5\lang1033\langfe1033\kerning16\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext16 4. LA Para Head;}{ \s17\ql \li0\ri0\sb120\sl-200\slmult0\nowidctlpar\brdrt\brdrs\brdrw15\brsp20 \aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\caps\f29\fs16\expnd-1\expndtw-5\lang1033\langfe1033\kerning16\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext17  5. French LA Head;}{\s18\ql \li0\ri-18\sb120\sl-240\slmult0\nowidctlpar\tx576\tx1152\tx1728\aspalpha\aspnum\faauto\adjustright\rin-18\lin0\itap0 \b\f29\fs22\expnd-2\expndtw-10\lang1033\langfe1033\kerning22\cgrid\langnp1033\langfenp1033  \sbasedon0 \snext18 2. LA Subhead;}{\s19\ql \li0\ri0\sl-320\slmult0\nowidctlpar\tx634\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \f28\fs12\expnd-1\expndtw-5\cf5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext19 6. Part No.;}{ \s20\ql \li0\ri0\sl-460\slmult0\nowidctlpar\tx240\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\f29\fs44\expnd-6\expndtw-30\lang1033\langfe1033\kerning42\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext20 1. Section Head;}{ \s21\qr \li0\ri0\sb60\sl-140\slmult0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \f28\fs12\expnd-1\expndtw-5\cf5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon15 \snext21 9. Legal Code;}{ \s22\ql \li0\ri0\sb240\sl-240\slmult0\nowidctlpar\tx576\tx1152\tx1728\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\f29\fs22\expnd-3\expndtw-15\lang1033\langfe1033\kerning22\cgrid\langnp1033\langfenp1033 \sbasedon18 \snext22 2a. French Subhead;}{ \s23\ql \li0\ri0\sb60\sl-180\slmult0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\caps\f28\fs16\expnd-1\expndtw-5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon15 \snext23 3b. ALL CAPS;}{ \s24\ql \fi-187\li187\ri0\sb60\sl-140\slmult0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin187\itap0 \f28\fs12\expnd-1\expndtw-5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon15 \snext24 3c. Numbered;}{ \s25\ql \li0\ri0\sb60\sl-140\slmult0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \f28\fs12\expnd-1\expndtw-5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon15 \snext25 3e. French;}{\s26\ql \li0\ri0\sb60\sl-180\slmult0 \nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\caps\f28\fs16\expnd-1\expndtw-5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon15 \snext26 3f. French CAPS;}{\s27\ql \fi-180\li360\ri0\sb60\sl-140\slmult0 \nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \f28\fs12\expnd-1\expndtw-5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon15 \snext27 3d. Numbered-Sub;}{\s28\ql \li0\ri0\widctlpar \tqc\tx4320\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext28 header;}{\s29\ql \li0\ri0\widctlpar \tqc\tx4320\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext29 footer;}{\s30\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \cbpat9  \f27\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext30 Document Map;}{\s31\qj \li0\ri0\sl180\slmult0\widctlpar\brdrt\brdrs\brdrw150 \brdrbtw\brdrs\brdrw150\brsp100  \tx576\tx1152\tx1728\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs18\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext31 Body Text;}{\s32\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0  \f2\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext32 Plain Text;}{\s33\qj \fi-432\li792\ri0\sa12\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin792\itap0 \fs18\lang1033\langfe1033\cgrid\langnp1033\langfenp1033  \sbasedon0 \snext33 Body Text 2;}{\s34\qj \li0\ri0\widctlpar\brdrb\brdrs\brdrw30\brsp20 \aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs16\lang3084\langfe1033\cgrid\langnp3084\langfenp1033 \sbasedon0 \snext34 Body Text 3;}{ \s35\ql \li720\ri0\sl240\slmult0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext35 Body Text Indent 2;}{\*\cs36 \additive \ul\cf2 \sbasedon10 Hyperlink;}} {\*\listtable{\list\listtemplateid-463026382\listsimple{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat4\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\b\chbrdr\brdrnone\brdrcf1  \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li540\jclisttab\tx540 }{\listname ;}\listid1235240470}{\list\listtemplateid-576817408\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat2\levelold\levelspace0\levelindent360 {\leveltext\'03\'00. ;}{\levelnumbers\'01;}\b\fs16\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li360 }{\listname ;}\listid1858886711}{\list\listtemplateid1743844624\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0 \levelstartat2\levelold\levelspace0\levelindent360{\leveltext\'03\'00. ;}{\levelnumbers\'01;}\b\fs16\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li360 }{\listname ;}\listid1860585954}}{\*\listoverridetable{\listoverride\listid1858886711 \listoverridecount0\ls1}{\listoverride\listid1860585954\listoverridecount0\ls2}{\listoverride\listid1235240470\listoverridecount0\ls3}}{\info{\title END-USER LICENSE AGREEMENT FOR PRERELEASE MICROSOFT SOFTWARE}{\author khaniuk}{\operator Juan Medrano} {\creatim\yr2000\mo1\dy4\hr11\min44}{\revtim\yr2000\mo1\dy5\hr10\min9}{\printim\yr1999\mo12\dy20\hr11\min53}{\version5}{\edmins8}{\nofpages4}{\nofwords1895}{\nofchars10804}{\*\company Microsoft}{\nofcharsws0}{\vern8247}} \margl2275\margr2736\margt2606\margb2016\gutter418 \widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\lytprtmet\hyphcaps0\formshade\horzdoc\dghspace180\dgvspace180\dghorigin1701\dgvorigin1984\dghshow0\dgvshow0 \jexpand\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot\bdrrlswsix\nolnhtadjtbl \fet0\sectd \pgnlcrm\linex0\endnhere\titlepg\sectdefaultcl {\footer \pard\plain \s29\ql \li0\ri0\widctlpar \tqc\tx4320\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {98292001  \par }}{\footerf \pard\plain \s29\ql \li0\ri0\widctlpar\tqc\tx4320\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f28\fs14 10/19/98  982920018 }{ \par  \par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}} {\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8 \pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s20\ql \li0\ri0\sa240\widctlpar\tx240\tqr\tx7560\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0  \b\f29\fs44\expnd-6\expndtw-30\lang1033\langfe1033\kerning42\cgrid\langnp1033\langfenp1033 {\fs28 Microsoft Active Directory Migration Tool \par }\pard \s20\ql \li0\ri0\widctlpar\tx240\tqr\tx7560\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {\fs28 END-USER LICENSE AGREEMENT FOR MICROSOFT SOFTWARE}{\fs28\expnd0\expndtw0\kerning44  \par }\pard\plain \s16\ql \li0\ri0\sl360\slmult1\widctlpar\brdrt\brdrs\brdrw15 \tx576\tx1152\tx1728\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \b\caps\f29\fs16\expnd-1\expndtw-5\lang1033\langfe1033\kerning16\cgrid\langnp1033\langfenp1033 {\b0  \par }\pard\plain \s18\ql \li0\ri-18\widctlpar\tx576\tx1152\tx1728\aspalpha\aspnum\faauto\adjustright\rin-18\lin0\itap0 \b\f29\fs22\expnd-2\expndtw-10\lang1033\langfe1033\kerning22\cgrid\langnp1033\langfenp1033 {IMPORTANT\emdash  READ CAREFULLY: This Microsoft End-User License Agreement (\'93EULA\'94) is a legal agreement between you (either an individual or a single entity) and Microsoft Corporation for the}{\fs20\cf1  }{\cf1  Microsoft software identified above, which includes computer software and may include associated media, printed materials, additional computer software applications, and \'93online\'94 or electronic documentation (\'93SOFTWARE\'94)}{ .  By downloading, installing, copying, or otherwise using the SOFTWARE, you agree to be bound by the terms of this EULA.  If you do not agree to the terms of this EULA, do not install or use the SOFTWARE. \par }\pard\plain \s16\ql \li0\ri0\widctlpar\brdrt\brdrs\brdrw15 \tx576\tx1152\tx1728\aspalpha\aspnum\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\caps\f29\fs16\expnd-1\expndtw-5\lang1033\langfe1033\kerning16\cgrid\langnp1033\langfenp1033 {\fs18  \par Software LICENSE \par }\pard\plain \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \f28\fs12\expnd-1\expndtw-5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f0\fs18\expnd0\expndtw-4  \par The SOFTWARE is protected by copyright laws and international copyright treaties, as well as other intellectual property laws and treaties. }{\b\f0\fs18\expnd0\expndtw-4 The SOFTWARE is licensed, not sold. \par }\pard \s15\ql \fi-180\li180\ri0\widctlpar\tx180\aspalpha\aspnum\faauto\adjustright\rin0\lin180\itap0 {\f0\fs18 1.\tab }{\b\f0\fs18 GRANT OF LICENSE.}{\f0\fs18    You may install and use the SOFTWARE on an unlimited number of computers, including workstations, terminals or other digital electronic devices (\'93COMPUTERS\'94), which are running validly licensed copies of Wi ndows 2000 Server, Windows 2000 Advanced Server and/or Windows 2000 Datacenter Server, solely for the purposes of (a) migrating user accounts, security groups and computer accounts from Windows NT 4.0 and Windows 2000 domains to Windows 2000 Active Direct ory, and (b) performing additional tasks subsequent to such migrations as enabled by the SOFTWARE and described in the documentation associated with the SOFTWARE.  }{\b\f0\fs18 Note on Agent Component.}{\f0\fs18    In addition to the foregoing, you may install and use the \'93agent\'94 c omponent of the SOFTWARE on any COMPUTER which is running a validly licensed copy of any Windows 3.51 or Windows NT 4.0 operating system product or Windows 2000 Professional, as may be necessary for such migration. \par }\pard\plain \s24\ql \fi-187\li187\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin187\itap0 \f28\fs12\expnd-1\expndtw-5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f0\fs18 2.\tab }{\b\f0\fs18 DESCRIPTION OF OTHER RIGHTS AND LIMITATIONS.} {\f0\fs18   \par }\pard\plain \s27\ql \fi-180\li360\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0 \f28\fs12\expnd-1\expndtw-5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\fs18 a.\tab }{\b\f0\fs18  Limitations on Reverse Engineering, Decompilation, and Disassembly.}{\f0\fs18   You may not reverse engineer, decompile, or disassemble the SOFTWARE, except and only to the extent that such activity is expressly permitted by applicable law notwithstanding this limitation. \par }{\b\f0\fs18 b.}{\f0\fs18 \tab }{\b\f0\fs18 Rental.}{\f0\fs18  You may not rent, lease, or lend the SOFTWARE. \par }{\b\f0\fs18 c.}{\f0\fs18 \tab }{\b\f0\fs18 Support Services.}{\f0\fs18  Microsoft may provide you with support services related to the SOFTWARE (\'93Support Services\'94). Use of Support Services is governed by the Microsoft policies and p rograms described in the user manual, in \'93online\'94  documentation, and/or in other Microsoft-provided materials. Any supplemental software code provided to you as part of the Support Services shall be considered part of the SOFTWARE and subject to the terms  and conditions of this EULA. With respect to technical information you provide to Microsoft as part of the Support Services, Microsoft may use such information for its business purposes, including for product support and development. Microsoft will not ut ilize such technical information in a form that personally identifies you. \par }{\b\f0\fs18 d.}{\f0\fs18 \tab }{\b\f0\fs18 Termination. }{\f0\fs18 Without prejudice to any other rights, Microsoft may terminate this EULA if you fail to comply with the terms and conditions of this EULA. In such event, you must des troy all copies of the SOFTWARE and all of its component parts. \par }\pard\plain \s24\ql \fi-187\li187\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin187\itap0 \f28\fs12\expnd-1\expndtw-5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f0\fs18 3.\tab }{\b\f0\fs18 INTELLECTUAL PROPERTY RIGHTS}{\f0\fs18  . All title and intellectual property rights in and to the SOFTWARE (including but not limited to any images, photographs, animations, video, audio, music, text and \'93applets\'94  incorporated into the SOFTWARE), and any copies you are permitted to make herein are owned by Microsoft or its suppliers.  All title and intellectual property rights in and to the content which may be accessed through use of the SOFTWARE is t he property of the respective content owner and may be protected by applicable copyright or other intellectual property laws and treaties.  This EULA grants you no rights to use such content. If this SOFTWARE contains documentation which is provided only  in electronic form, you may print one copy of such electronic documentation.  You may not copy the printed materials accompanying the SOFTWARE.  \par }\pard \s24\ql \fi-187\li187\ri0\sb40\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin187\itap0 {\f0\fs18 4.\tab }{\b\f0\fs18 U.S. GOVERNMENT LICENSE RIGHTS}{\f0\fs18 . SOFTWARE provided to the U.S. Government pursuant to solicitations issued on  or after December 1, 1995 is provided with the commercial license rights and restrictions described elsewhere herein.  SOFTWARE provided to the U.S. Government pursuant to solicitations issued prior to December 1, 1995 is provided with \'93 Restricted Rights\'94 as provided for in FAR, 48 CFR 52.227-14 (JUNE 1987) or DFAR, 48 CFR 252.227-7013 (OCT 1988), as applicable.  \par 5.}{\b\f0\fs18 \tab EXPORT RESTRICTIONS}{\f0\fs18 . You agree that you will not export or re-export the SOFTWARE (or portions thereof) to any country, person or entity subjec t to U.S. export restrictions.  You specifically agree not to export or re-export the SOFTWARE (or portions thereof): (i) to any country subject to a U.S. embargo or trade restriction; (ii) to any person or entity who you know or have reason to know will  tilize the SOFTWARE (or portion thereof) in the production of nuclear, chemical or biological weapons; or (iii) to any person or entity who has been denied export privileges by the U.S. government.  For additional information see http://www.microsoft.com/ exporting/. \par }\pard \s24\ql \fi-187\li187\ri0\sb40\sl180\slmult0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin187\itap0 {\f0\fs18 6. }{\b\f0\fs18  DISCLAIMER OF  WARRANTIES. To the maximum extent permitted by applicable law, Microsoft and its suppliers provide the SOFTWARE and any (if any) Support Services }{\b\i\f0\fs18 AS IS AND WITH ALL FAULTS}{\b\f0\fs18 , and hereby d isclaim all warranties and conditions, either express, implied or statutory, including, but not limited to, any (if any) implied warranties or conditions of merchantability, of fitness for a particular purpose, of lack of viruses, of accuracy or completen ss of responses, of results, and of lack of negligence or lack of workmanlike effort, all with regard to the SOFTWARE, and the provision of or failure to provide Support Services.  ALSO, THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT, QUIET P OSSESSION, CORRESPONDENCE TO DESCRIPTION OR NON-INFRINGEMENT, WITH REGARD TO THE SOFTWARE.  THE ENTIRE RISK AS TO THE QUALITY OF OR ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE AND SUPPORT SERVICES, IF ANY, REMAINS WITH YOU. \par }\pard\plain \s23\ql \fi-187\li187\ri0\sb40\sl180\slmult0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin187\itap0 \b\caps\f28\fs16\expnd-1\expndtw-5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b0\f0\fs18 7. }{\f0\fs18  EXCLUSION OF INCIDENTAL, CONSEQUENTIAL AND CERTAIN OTHER DAMAGES}{\b0\f0\fs18 . }{\caps0\f0\fs18  TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL MICROSOFT OR ITS SUPPLIERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, BUT NOT LIMITED TO, D AMAGES FOR LOSS OF PROFITS OR CONFIDENTIAL OR OTHER INFORMATION, FOR BUSINESS INTERRUPTION, FOR PERSONAL INJURY, FOR LOSS OF PRIVACY, FOR FAILURE TO MEET ANY DUTY INCLUDING OF GOOD FAITH OR OF REASONABLE CARE, FOR NEGLIGENCE, AND FOR ANY OTHER PECUNIARY O  OTHER LOSS WHATSOEVER) ARISING OUT OF OR IN ANY WAY RELATED TO THE USE OF OR INABILITY TO USE THE SOFTWARE, THE PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES, OR OTHERWISE UNDER OR IN CONNECTION WITH ANY PROVISION OF THIS EULA, EVEN IN THE EVENT OF  THE FAULT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY, BREACH OF CONTRACT OR BREACH OF WARRANTY OF MICROSOFT OR ANY SUPPLIER, AND EVEN IF MICROSOFT OR ANY SUPPLIER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. }{\b0\f0\fs18  \par }\pard\plain \s24\ql \fi-187\li187\ri0\sb40\sl180\slmult0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin187\itap0 \f28\fs12\expnd-1\expndtw-5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f0\fs18 8.}{\b\f0\fs18   LIMITATION OF LIABILITY AND REME DIES. Notwithstanding any damages that you might incur for any reason whatsoever (including, without limitation, all damages referenced above and all direct or general damages), the entire liability of Microsoft and any of its suppliers under any provisio  of this EULA and your exclusive remedy for all of the foregoing shall be limited to the greater of the amount actually paid by you for the SOFTWARE or U.S.$5.00.  The foregoing limitations, exclusions and disclaimers shall apply to the maximum extent per mitted by applicable law, even if any remedy fails its essential purpose. \par }\pard\plain \s15\ql \fi-187\li187\ri0\sb40\sl180\slmult0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin187\itap0 \f28\fs12\expnd-1\expndtw-5\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f0\fs18 9. }{\b\f0\fs18 APPLICABLE LAW.  }{\f0\fs18  If you acquired this SOFTWARE in the United States, this EULA is governed by the laws of the State of Washington.  If you acquired this SOFTWARE in Canada, unless  expressly prohibited by local law, this EULA is governed by the laws in force in the Province of Ontario, Canada; and, in respect of any dispute which may arise hereunder, you consent to the jurisdiction of the federal and provincial courts sitting in Tor onto, Ontario. If this SOFTWARE was acquired outside the United States, then local law may apply. \par 10. }{\b\f0\fs18 ENTIRE AGREEMENT.  This EULA (including any addendum or amendment to this EULA which is included with the SOFTWARE) is the entire agreement between you and  Microsoft relating to the SOFTWARE and the Support Services (if any) and it supersedes all prior or contemporaneous oral or written communications,  proposals and representations with respect to the SOFTWARE or any other subject matter covered by this EU LA.  To the extent the terms of any Microsoft policies or programs for Support Services conflict with the terms of this EULA, the terms of this EULA shall control. \par }{\f0\fs18 11. }{\b\f0\fs18 QUESTIONS? }{\f0\fs18 Should you have any questions concerning this EULA, or if you desire to contac t Microsoft for any reason, please contact the Microsoft subsidiary serving your country, or write: Microsoft Sales Information Center/One Microsoft Way/Redmond, WA 98052-6399.  \par }\pard\plain \qj \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs18\lang3084\langfe1033\langnp3084  \par }\pard\plain \s33\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs18\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b Si vous avez acquis votre produit Microsoft au CANADA, la garantie limit\'e9e suivante vous concerne\~: \par }\pard\plain \qj \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\fs16\lang3084\langfe1033\langnp3084  \par RENONCIATION AUX GARANTIES.  }{\fs16\lang3084\langfe1033\langnp3084 Dans }{\fs18 toute la mesure permise par la l\'e9gislation en vigueur, Microsoft et ses fournisseurs fournissent le PRODUIT LOGICIEL et tous (selon le cas) Services d\rquote  assistance TELS QUELS ET AVEC TOUS LEURS D\'c9FAUTS, et par les pr\'e9sentes excluent toute garantie ou condition, expresse ou implicite, l\'e9gale ou conventionnelle, \'e9 crite ou verbale, y compris, mais sans limitation, toute (selon le cas) garantie ou condition implicite ou l\'e9gale de qualit\'e9 marchande, de conformit\'e9 \'e0 un usage particulier, d\rquote absence de virus, d\rquote exactitude et d\rquote int\'e9 gralit\'e9 des r\'e9ponses, de r\'e9sultats, d\rquote efforts techniques et professionnels et d\rquote absence de n\'e9gligence, le tout relativement au PRODUIT LOGICIEL et \'e0 la prestation ou \'e0 la non-prestation des Services d\rquote  assistance.  DE PLUS, IL N\rquote Y A AUCUNE GARANTIE ET CONDITION DE TITRE, DE JOUISSANCE PAISIBLE, DE POSSESSION PAISIBLE, DE SIMILARIT\'c9 \'c0 LA DESCRIPTION ET D\rquote ABSENCE DE CONTREFA\'c7 ON RELATIVEMENT AU PRODUIT LOGICIEL.  Vous supportez tous les risques d\'e9coulant de l\rquote utilisation et de la performance du PRODUIT LOGICIEL et ceux d\'e9coulant des Services d\rquote assistance (s\rquote il y a lieu)}{ \b\fs16\lang3084\langfe1033\langnp3084 . \par  \par }{\b\fs16 EXCLUSION DES DOMMAGES INDIRECTS, ACCESSOIRES ET AUTRES}{\b\fs16\lang3084\langfe1033\langnp3084 .  }{\fs18\lang3084\langfe1033\langnp3084 Dans toute la mesure }{\fs18 permise par la l\'e9gislation en vigueur, Mi crosoft et ses fournisseurs ne sont en aucun cas responsables de tout dommage sp\'e9cial, indirect, accessoire, moral ou exemplaire quel qu\rquote il soit (y compris, mais sans limitation, les dommages entra\'een\'e9s par la perte de b\'e9n\'e9 fices ou la perte d\rquote information confidentielle ou autre, l\rquote interruption des affaires, les pr\'e9judices corporels, la perte de confidentialit\'e9, le d\'e9 faut de remplir toute obligation y compris les obligations de bonne foi et de diligence raisonnable, la n\'e9gligence et toute autre perte p\'e9cuniaire ou autre perte de quelque nature que ce soit) d\'e9coulant de, ou de toute autre mani\'e8re li\'e9  \'e0, l\rquote utilisation ou l\rquote impossibilit\'e9 d\rquote utiliser le PRODUIT LOGICIEL, la prestation ou la non-prestation des Services d\rquote assistance ou autrement en vertu de ou relativement \'e0  toute disposition de cette convention, que ce soit en cas de faute, de d\'e9lit (y compris la n\'e9gligence), de responsabilit\'e9 stricte, de manquement \'e0 un contrat ou de manquement \'e0 une garantie de Microsoft ou de l\rquote  un de ses fournisseurs, et ce, m\'eame si Microsoft ou l\rquote un de ses fournisseurs a \'e9t\'e9 avis\'e9 de la possibilit\'e9 de tels }{\fs18\lang3084\langfe1033\langnp3084 dommages.}{\b\fs16\lang3084\langfe1033\langnp3084  \par  \par LIMITATION DE RESPONSABILIT\'c9 ET RECOURS.  }{\fs18\lang3084\langfe1033\langnp3084 Malgr\'e9 }{\fs18 tout dommage que vous pourriez encourir pour quelque raison que ce soit (y compris, mais sans limitation, tous les dommages mentionn\'e9 s ci-dessus et tous les dommages directs et g\'e9n\'e9raux), la seule responsabilit\'e9 de Microsoft et de ses fournisseurs en vertu de toute disposition de cette convention et votre unique recours en regard de tout ce qui pr\'e9c\'e8de sont limit\'e9 s au plus \'e9lev\'e9 des montants suivants:  soit (a) le montant que vous avez pay\'e9 pour le PRODUIT LOGICIEL, soit (b) un montant \'e9quivalant \'e0 cinq dollars U.S. (5,00 $ U.S.).  Les limitations, exclusions et renonciations ci-dessus s\rquote  appliquent dans toute la mesure permise par la l\'e9gislation en vigueur, et ce m\'eame si leur application a pour effet de priver un recours de son }{\fs18\lang3084\langfe1033\langnp3084 essence.}{\b\fs16\lang3084\langfe1033\langnp3084  \par  \par L\'c9GISLATION APPLICABLE.}{\fs16\lang3084\langfe1033\langnp3084 .  Sauf }{\fs18 lorsqu\rquote express\'e9ment prohib\'e9 par la l\'e9gislation locale, la pr\'e9sente  convention est r\'e9gie par les lois en vigueur dans la province d\rquote  Ontario, Canada.  Pour tout diff\'e9rend qui pourrait d\'e9couler des pr\'e9sentes, vous acceptez la comp\'e9tence des tribunaux f\'e9d\'e9raux et provinciaux si\'e9geant \'e0 Toronto, }{\fs16\lang3084\langfe1033\langnp3084 Ontario.  \par }{\b\fs16\lang3084\langfe1033\langnp3084  \par }{\fs18\lang3084\langfe1033\langnp3084 Si }{\fs18 vous avez des questions concernant cette convention ou si vous d\'e9sirez communiquer avec Microsoft pour quelque raison que ce soit, veuillez contacter la succursale Microsoft desservant votre pays, ou  \'e9crire \'e0: Microsoft Sales Information Center, One Microsoft Way, Redmond, Washington\~98052-}{\fs18\lang3084\langfe1033\langnp3084 6399. \par }}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\setup\wise\pwdmig.ini ===
[WiseInstaller]
ProductFile=PwdMig.msi
ProductCode={E090D3A6-C0B8-4E28-97F8-D06854123421}
ProductVersion=1.0.0.0
ProductName=ADMT Password Migration DLL
Remove Previous=0
AdminError=You must have administrator rights to run this installation. Please login as an administrator and re-run this installation.
ExistError=%s Version %s is already installed. You must uninstall the existing version before installing %s Version %s. Do you want to uninstall the existing version of %s?
WiseInitPrefix=Initializing
WiseInitSuffix=Wizard...
RuntimeVersion=1.10.1029.1
Runtime9X=
RuntimeNT=instmsiw.exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\ok.txt ===
*****************************************************************************************************************/
/*****************************************************************************************************************/
/*****************************************************************************************************************/
/*****************************************************************************************************************/
/*****************************************************************************************************************/
/*****************************************************************************************************************/
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//can't do
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*int doUndo();
int doRedo();
int doGroup();


int  doGroup()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[10] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure

	psp.pfnDlgProc =	IntroDlgProc;
	intropage(ahpsp,psp,IDD_GROUP_INTRO,0,wizdata,IDS_ACCOUNT_TITLE);

	psp.pfnDlgProc =	IntGeneralProc; definepage(ahpsp,psp,IDS_FOR_REAL,IDS_FOR_REAL_SUB,IDD_FOR_REAL,1,IDS_ACCOUNT_TITLE);
	psp.pfnDlgProc =	IntGeneralProc; definepage(ahpsp,psp,IDS_DOMAIN,IDS_DOMAIN_SUB,IDD_DOMAIN_SELECTION,2,IDS_ACCOUNT_TITLE);
	psp.pfnDlgProc =	IntGeneralProc; definepage(ahpsp,psp,IDS_CREDENTIALS,IDS_CREDENTIALS_SUB,IDD_CREDENTIALS,3,IDS_ACCOUNT_TITLE);
	psp.pfnDlgProc =	IntGeneralProc; definepage(ahpsp,psp,IDS_SID_HISTORY,IDS_SID_HISTORY_SUB,IDD_SID_HISTORY,4,IDS_ACCOUNT_TITLE);
	psp.pfnDlgProc =	IntGeneralProc; definepage(ahpsp,psp,IDS_USER_RIGHTS,IDS_USER_RIGHTS_SUB,IDD_USER_RIGHTS,5,IDS_ACCOUNT_TITLE);
	psp.pfnDlgProc =	IntGeneralProc; definepage(ahpsp,psp,IDS_RENAMING,IDS_RENAMING_SUB,IDD_RENAMING,6,IDS_ACCOUNT_TITLE);
	psp.pfnDlgProc =	IntGeneralProc; definepage(ahpsp,psp,IDS_REPLACE_EXISTING,IDS_REPLACE_EXISTING_SUB,IDD_REPLACE_EXISTING_GROUP_MEMBERS,9,IDS_ACCOUNT_TITLE);
	psp.pfnDlgProc =	IntGeneralProc; definepage(ahpsp,psp,IDS_OU_SELECTION,IDS_OU_SELECTION_SUB,IDD_OU_SELECTION,7,IDS_ACCOUNT_TITLE);
	psp.pfnDlgProc =	IntSelectionProc; definepage(ahpsp,psp,IDS_GROUP,IDS_GROUP_SUB,IDD_GROUP_SELECTION,8,IDS_ACCOUNT_TITLE);

	psp.pfnDlgProc =	EndDlgProc; 
	endpage(ahpsp,psp,IDD_GROUP_END,10,IDS_ACCOUNT_TITLE);

	defineSheet(ahpsp,psh,11,wizdata,10);
	return 0;
}

int doUndo()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[3] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure
	
	intropage(ahpsp,psp,IDD_INTRO_UNDO,0,wizdata,IDS_ACCOUNT_TITLE);

	psp.pfnDlgProc =	IntGeneralProc; definepage(ahpsp,psp,IDS_UNDO,IDS_UNDO_SUB,IDD_UNDO,1,IDS_ACCOUNT_TITLE);

	psp.pfnDlgProc =	EndDlgProc; 
	endpage(ahpsp,psp,IDD_END_UNDO,2,IDS_ACCOUNT_TITLE);

	defineSheet(ahpsp,psh,3,wizdata,5);
	return 0;

}


int doRedo()
{
	PROPSHEETPAGE	psp =		{0}; //defines the property sheet pages
	HPROPSHEETPAGE	ahpsp[3] =	{0}; //an array to hold the page's HPROPSHEETPAGE handles
	PROPSHEETHEADER	psh =		{0}; //defines the property sheet
	SHAREDWIZDATA wizdata =		{0}; //the shared data structure

	psp.pfnDlgProc =	IntroDlgProc;
	intropage(ahpsp,psp,IDD_INTRO_REDO,0,wizdata,IDS_ACCOUNT_TITLE);

	psp.pfnDlgProc =	IntGeneralProc; definepage(ahpsp,psp,IDS_REDO,IDS_REDO_SUB,IDD_REDO,1,IDS_ACCOUNT_TITLE);

	psp.pfnDlgProc =	EndDlgProc; 
	endpage(ahpsp,psp,IDD_END_REDO,2,IDS_ACCOUNT_TITLE);
	defineSheet(ahpsp,psh,3,wizdata,6);
	return 0;
}

						
BOOL CALLBACK IntClosedProc (
						HWND hwndDlg,
						UINT uMsg,
						WPARAM wParam,
						LPARAM lParam
						)
{

	//Process messages from the second interior page

	//Retrieve the shared user data from GWL_USERDATA

//	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLong(hwndDlg, GWL_USERDATA);
	LPSHAREDWIZDATA pdata = (LPSHAREDWIZDATA) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

	switch (uMsg)
	{
	case WM_INITDIALOG :
		{ 
			//Get the PROPSHEETPAGE lParam value and load it into
			//DWL_USERDATA

			pdata = (LPSHAREDWIZDATA) ((LPPROPSHEETPAGE) lParam) -> lParam;
//			SetWindowLong(hwndDlg, GWL_USERDATA, (long) pdata);
			SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdata);
			break;
		}

	case WM_NOTIFY :
		{
		LPNMHDR lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
			{
			case PSN_SETACTIVE : //Enable the Next and Back buttons

				PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;

			case PSN_WIZNEXT :
				//Handle a Next button click, if necessary

				break;

			case PSN_WIZBACK :
				break;

			case PSN_RESET :
				//Handle a Cancel button click, if necessary
				break;

			default :
				break;
			}
		}
		break;

	default:
		break;
	}
	return 0;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\wizards\readme.txt ===
========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : wizards
========================================================================


AppWizard has created this wizards DLL for you.  This DLL not only
demonstrates the basics of using the Microsoft Foundation classes but
is also a starting point for writing your DLL.

This file contains a summary of what you will find in each of the files that
make up your wizards DLL.

wizards.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

wizards.h
	This is the main header file for the DLL.  It declares the
	CWizardsApp class.

wizards.cpp
	This is the main DLL source file.  It contains the class CWizardsApp.


wizards.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Visual C++.

wizards.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.

res\wizards.rc2
    This file contains resources that are not edited by Microsoft 
	Visual C++.  You should place all resources not editable by
	the resource editor in this file.

wizards.def
    This file contains information about the DLL that must be
    provided to run with Microsoft Windows.  It defines parameters
    such as the name and description of the DLL.  It also exports
	functions from the DLL.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named wizards.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Visual C++ reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\dependents.txt ===
; Add your project name to this list so I can update you when changes are
; made:
;
; build root folder (relative to SDXROOT)    Contact email
;
admin\dcpromo                                sburns
admin\snapin\localsec                        sburns
admin\netid                                  jonn
admin\dsutils\migrate\clonepr                sburns
admin\select\src                             lucios
admin\dsutils\DisplaySpecifierUpgrade        lucios
admin\cys\lib                                jeffjon
admin\cys\win32                              jeffjon
admin\cys\mys                                sburns
ds\ds\src\util\adprep                        shaoyin 
admin\ssrui                                  ericb/yanggao
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\linknotes.txt ===
for burnslib\core

USE_MSVCRT=1

links to dll version of CRTs.  If STL headers are included, also causes
link to msvcrp60.dll
causes -D_DLL=1 -D_MT=1 to be passed to cl, otherwise the same.

USE_LIBCMT=1

causes -D_MT=1 but not -D_DLL=1 to be passed to cl

_MT is necessary to get correct declaration of errno from stdlib.h
for binaries, causes link to thread-aware msvcrt.dll (non-static crts)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\readme.txt ===
Copyright (c) 1997-2001 Microsoft Corporation

BURNSLIB: Basic Utility Resource 'N String Library ;->
==================================================

There are two flavors of this library: the "core" and the "rest."

The core library is the most stable, and most easily used in just about any
application.  It consists of the following:

    - class String, which is a Windows-aware, enhancement of std::wstring.

    - Replacement versions of ::operator new and ::operator delete,
      which, among other things allow each allocation to be accompanied
      with file, line number and stack trace at the point of allocation.

    - class Log, which provides thread-safe diagnostic logging with
      output directable to debugger, file, a named pipe.

    - A very small set of lightweight COM helpers which do not exhibit
      the elephantine nature of MFC and ATL constructs of similar
      purpose.

The rest is really meant for my own use, but has since garnered enough
dependent projects that we have to take version control serviously (the
bane of the shared code author).

IMPORTANT:

If you use the core or the rest, please update the dependents.txt file so
that I can make sure changes I make don't break your build.



To use the core library in your code:
====================================

In your razzle environment (for chk builds, this causes the linker to use
the debug CRT .lib files and passes -D_DEBUG to the compiler.  This is
necessary to use the heap debugging functionality)

    set DEBUG_CRTS=1

In your headers.hxx file
    
    Add #include <blcore.hpp> before any headers for code that you want to
    use the replacement operator new and delete.  (Generally, I only put
    include headers from outside my project in headers.hxx.  So, I include
    blcore.hpp last in my headers.hxx.)

    Note that blcore.hpp #includes syscore.hpp, which in turn #includes
    several sdk header files.  You may want to remove redundant inclusion
    of those files.

In your sources file:

    Add admin\burnslib\inc to the INCLUDES macro

    Add the following to your UNLIBS or TARGETLIBS macro
        $(SDXROOT)\admin\burnslib\lib\*\blcore.lib

    Add the following lines:

        # enable logging for chk builds

        !if !$(FREEBUILD)
        !MESSAGE defining LOGGING_BUILD
        C_DEFINES=$(C_DEFINES) -DLOGGING_BUILD
        !ENDIF

        # enable Unicode support

        C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE

        # enable C++ Standard Template Library

        USE_STL=1

        # enable C++ Exceptions

        USE_NATIVE_EH=1

        # use msvcrt (C runtimes)

        USE_MSVCRT=1

Somewhere in your source code, you need to define the following symbols.
See blcore.hpp for explanations of each.

        HINSTANCE hResourceModuleHandle
        const wchar_t* RUNTIME_NAME
        DWORD DEFAULT_LOGGING_OPTIONS

In your project's resource script (rc) file, #include blcore.rc.  These are
the resources for the out-of-memory dialog.



Notes:
=========================
    
Since you are using the debug CRTs, you will need to have available on your
search path msvcrtd.dll and possibly also msvcp50d.dll (depending on which
STL templates your code uses).  This means that you will may need to
include those dlls with any private chk binaries you distribute.

All of BURNSLIB compiles clean with warning level 4, so you can include
MSC_WARNING_LEVEL=/W4 in your sources if you wish.

BURNSLIB is statically linked to your binary.  There is no associated dll.

It replaces the global operator new, operator new[], operator delete, and
operator delete[] with private versions.  This isolates the behavior of
those operators to your binary.  To understand why this is a Good Thing,
see new.doc.  If you use STL template classes, then remember to use the
Burnslib::Heap::Allocator classes to keep the STL from falling back to the
CRT allocator.

If you plan to use any functions that load resources (strings, icons,
etc.), you need to make sure you set the hResourceModuleHandle to the
HINSTANCE of the binary containing the resource.  The best place to do this
is the first line of code in WinMain/DllMain.  The design of the library
assumes that all resources are in the same binary; a tradeoff between
simplicity and flexibility.  In your code, you can retrieve this handle by
calling Burnslib::GetResourceModuleHandle().

Most of the symbols are in the Burnslib namespace.  blcore.hpp specifies
"using namespace Burnslib;" so you don't have to.



To use the "rest" of the library in your code:
=============================================

Cut and paste.  Don't link directly to it.  I tweak the rest with reckless
abandon and will offer no apologies for breaking your code.

Well, that was then.  I will try to be a good citizen here.

<eof>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\diagnosedcnotfound.txt ===
switch (status)
   {
      case DNS_ERROR_RCODE_SERVER_FAILURE:
      {
         // message F (message letters correspond to those in the spec)

               IDS_DC_NOT_FOUND_DIAG_SERVER_FAILURE,


IDS_DC_NOT_FOUND_DIAG_SERVER_FAILURE "The following error occurred when DNS
was queried for the service location (SRV) resource record used to locate a
domain controller for domain %1:\r\n\r\n%2\r\n\r\nThe query was for the SRV
record for %3\r\n\r\nCommon causes of this error include the
following:\r\n\r\n- The DNS servers used by this computer contain incorrect
root hints. This computer is configured to use DNS servers with following
IP addresses:\r\n\r\n%4\r\n- One or more of the following zones contains
incorrect delegation:\r\n\r\n%5\r\n\r\nFor information about correcting
this problem, click Help."

         helpTopic = L"tcpip.chm::/sag_DNS_tro_dcLocator_messageF.htm";
         
         break;
      }
      case DNS_ERROR_RCODE_NAME_ERROR:
      {
         // message E

               IDS_DC_NOT_FOUND_NAME_ERROR,

IDS_DC_NOT_FOUND_NAME_ERROR "The following error occurred when DNS was
queried for the service location (SRV) resource record used to locate a
domain controller for domain %1:\r\n\r\n%2\r\n\r\nThe query was for the
SRV record for %3\r\n\r\nCommon causes of this error include the
following:\r\n\r\n- The DNS SRV records required to locate a domain
controller for the domain are not registered in DNS. These records are
registered with a DNS server automatically when a domain controller is
added to a domain. They are updated by the domain controller at set
intervals. This computer is configured to use DNS servers with
following IP addresses:\r\n\r\n%5\r\n- One or more of the following
zones do not include delegation to its child zone:\r\n\r\n%4\r\n\r\nFor
information about correcting this problem, click Help."

         helpTopic = L"tcpip.chm::/sag_DNS_tro_dcLocator_messageE.htm";
         
         break;
      }
      case ERROR_TIMEOUT:
      {
         // message B

               IDS_DC_NOT_FOUND_TIMEOUT,

IDS_DC_NOT_FOUND_TIMEOUT "The following error occurred when DNS was
queried for the service location (SRV) resource record used to locate a
domain controller for domain %1:\r\n\r\n%2\r\n\r\nThe query was for the
SRV record for %3\r\n\r\nThe DNS servers used by this computer for name
resolution are not responding. This computer is configured to use DNS
servers with the following IP addresses:\r\n\r\n%4\r\nVerify that this
computer is connected to the network, that these are the correct DNS
server IP addresses, and that at least one of the DNS servers is
running.\r\n\r\nFor more information on how to correct this problem,
click Help."
         
         break;
      }
      case NO_ERROR:
      {
         if (queryResults)
         {
            // non-empty query results -- message Hb

                  IDS_DC_NOT_FOUND_NO_ERROR_1,

IDS_DC_NOT_FOUND_NO_ERROR_1 "DNS was successfully queried for the
service location (SRV) resource record used to locate a domain
controller for domain %1:\r\n\r\nThe query was for the SRV record for
%2\r\n\r\nThe following domain controllers were identified by the
query:\r\n\r\n%3\r\nCommon causes of this error include:\r\n\r\n- Host
(A) records that map the name of the domain controller to its IP
addresses are missing or contain incorrect addresses.\r\n\r\n- Domain
controllers registered in DNS are not connected to the network or are
not running.\r\n\r\nFor information about correcting this problem,
click Help."
                             
            helpTopic = L"tcpip.chm::/sag_DNS_tro_dcLocator_messageHa.htm";
            break;
         }

         // empty query results -- message A
         // fall thru to default case

// See note below ***

      }
      default:
      {
         // message A

               IDS_DC_NOT_FOUND_DEFAULT,

IDS_DC_NOT_FOUND_DEFAULT "An error occurred when DNS was queried for
the service location (SRV) resource record used to locate a domain
controller for domain %1.\r\n\r\n%2\r\n\r\nThe query was for the SRV
record for %3\r\n\r\nFor more information, click Help."

         helpTopic = L"tcpip.chm::/sag_DNS_tro_dcLocator_messageA.htm";
         
         break;
      }
   }




*** I also found this one, but it is not reference in the code anywhere (if
that's a bug, please let me know)

IDS_DC_NOT_FOUND_NO_ERROR_2 "DNS was successfully queried for the
service location (SRV) resource record used to locate a domain
controller for domain %1:\r\n\r\nThe query was for the SRV record for
%2\r\n\r\nHowever, no domain controllers were identified in the query
results. This might be because the domain controllers have been
registered with the incorrect record type.\r\n\r\nFor information about
correcting this problem, click Help."
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\test\readme.txt ===
This is a collection of unit test programs.

To build a test, copy the test-xxx.cpp file that has the test you want to
run to test.cpp, then run build -cZ.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\powercfg\placefil.txt ===
;
; See public\sdk\lib\placefil.txt for info about placefil's in general.
;
powercfg.exe            retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\powercfg\placex86.txt ===
;
; See public\sdk\lib\placefil.txt for info about placefil's in general.
;
powercfg.exe            retail:opk\tools\x86
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\sld\placefil.txt ===
;
; See public\sdk\lib\placefil.txt for info about placefil's in general.
;


cmdline_tools_client.sld             mantis
cmdline_tools_server.sld             mantis
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\timeout\timeout.txt ===
The following changes were made to the existing Timeout.exe utility-

1. We have added a new switch ( /T ) for entering the timeout value.
2. We have removed all the printf statements and replacing them with ShowMessage().
3. The help/usage has been modified.
4. We have modified the logic to calculate the width of the timeout value entered.
5. We have added a function to get the command line arguments.
6. We have added a function to print the output messages.
7. We have moved all the strings to the .rc file.

Note: It is assumed that there are no DCRs and that the code is working fine.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\whoami\whoami.txt ===
The following changes were made to the existing WhoamI.exe utility-

1. A switch ( /NOVERBOSE ) has been  removed
2. A new switch ( /V ) has been added for displaying the output in verbose mode.
3. Added a function (DoParseParam ) to get the command line arguments.
4. Removed all the _tprintf statements and replaced them with ShowMessage().
5. Supported all UNICODE conversions i.,e WCHAR, LPWSTR etc...
5. Implemented to display  the output in three formats i.,e LIST, TABLE and CSV
5. The help/usage has been changed completely.
6. Files called error.cpp , wsdisplay.cpp and wsstring.cpp  have been removed as we are using common functionality to    display the proper error messages and results in CSV,LIST or TABLE formats.
8. Added a function to format the messages  for error codes i.,e in case of any API failure.
9. Moved all the strings to the .rc file.
10. Remote connectivity have been supported.
11) Old utility was not implemented for /LOGONID. I implemented the same.

FUNCTIONAL CHANGES ( Clarifications required):
--------------------------------------
1) According to old utility ,  "WHOAMI  /ALL  /NOVERBOSE" command displays the values for  user, groups, privileges and logonID without displaying the column names.  By default it displays all the values along with the column names .

Instead, I added /V switch for displaying the output in verbose mode. Default display is non-verbose mode.

For "WHOAMI /PRIV /V" , I am displaying  privileges which are enabled/disabled.
For "WHOAMI /PRIV " , I am  displaying the privileges which are enabled.
I feel,  /V option is meaningful only for /PRIV option.. it doesnt have any meaning for commands like
"WHOAMI /USER /V" or "WHOAMI /GROUPS /V" or "WHOAMI /LOGONID /V" as we need to display the column names in both non-verbose as well as verbose modes.

 Please do clarify on this.


2) According to old utility  help/usage, /SID option must be given with one of  /USER, /GROUPS, /LOGONID or /PRIV options.  But according to old source code,  /SID option must be given with either /USER or /GROUPS options only.
/SID option doesn't have any meaning with /LOGONID or /PRIV options.
Thats why I implemented like  /SID option is only applicable for /USER and /GROUPS.

3) According to old utility, it is accepting options like /USER, /GROUPS, /LOGONID or /PRIV along with /ALL option.
Actually /ALL option itself means that it is combination of /USER, /GROUPS, /LOGONID and /PRIV. Thats why I implemeted like /USER, /GROUPS, /LOGONID , /SID and  /PRIV are not applicable with the /ALL option.

4) I implemented for remote connectivity. But on the remote system all the options are giving local system values only..
For "WHOAMI /GROUPS /S SERVER" api itself is getting failed.

Please do clarify on the above.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\xcacls\placesup.txt ===
xcacls.exe   reskit\bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\consoles\fsmgmt.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Computer Management canned console Title _PID_GUIDComputer Management canned console Michele L Freed Normal.dot Michele L Freed Microsoft Word 8.0P{xC# File Service Management canned console 11/14/97 Contacts:  MFreed  JonN How the Canned console is created. run mmc Select Add/remove SnapIn from MMC s file menu Select File Service Management  In the Wizard select  local  and  Allow selected computer to be changed  and in the View group box  Enable all the extensions, if any (these should be on by default in beta2, but double check) Right click on the  File Service Management  root node and Select  new window from here Delete the original child window Fully expand the existing child window Select the Root node Save the file as  fsmgmt.msc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\consoles\eventvwr.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Computer Management canned console TitleComputer Management canned console Michele L Freed Normal David Muntyan Microsoft Word 9.0bjbjU Event Viewer canned console 11/14/1997   Created 07/12/1999   Updated Contacts:  MFreed  DavidMun How the Canned console is created. 0.    Set screen resolution to 640x480 pixels Run MMC Select Add/remove Snapin from MMC s Console menu Click Add Select Event Viewer  Click Add In the Wizard select  Local  and  Allow selected computer to be changed Click Finish Click Close Click the Extensions tab and enable all the extensions, if any Click OK Right click on the  Event Viewer  root node and Select  new window from here Close the original child window Maximize the new child window Click View/Customize and ensure that the Description bar checkbox is checked. Select Console/Options, and in the Console tab: Click Change Icon and set the icon path to %SystemRoot%\system32\els.dll Change the name from "Console1" to "Event Viewer" Set Console mode to "User mode - limited access, single window" Check "Do not save changes to this console" Click OK Select the Root node, to expand the children Select the System Node Adjust the vertical split bar to allow some space for localization on the scope pane nodes Move the window to the center of screen Save the file as  eventvwr.msc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\consoles\services.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Computer Management canned console TitleComputer Management canned console Michele L Freed Normal Jon Newman Microsoft Word 9.0bjbjU System Service Management canned console 11/14/97 Contacts:  MFreed  JonN How the Canned console is created. run mmc Select Add/remove SnapIn from MMC s file menu Select System Service Mangement  In the Wizard select  local  and  Allow selected computer to be changed Enable all the extensions (these should be on by default in beta2, but double check) Right click on the  System Services  root node and Select  new window from here Delete the original child window Fully expand the existing child window Select the Root node Save the file as  svcmgmt.msc  [JonN 5/27/99: services.doc]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\consoles\compmgmt.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Computer Management canned console TitleComputer Management canned console Michele L Freed Normal Jon Newman Microsoft Word 9.0""")))UUUMMMBBB999 33333f33 f33f3ff3 3f33ff3f ff3fffff !___www AIDATx prD|; ~,h8U `|Ic% X\,w' Q]ox+w'l=@X /,_{@ *b9-C :4F[@ ai@FX r|tol- ^}9Z{  rxV&; YtCtn [BZdH ?R^gA LT|y8 """)))UUUMMMBBB999 33333f33 f33f3ff3 3f33ff3f ff3fffff !___www @IDATx Acrwd Od*Xg CGs?V s4wI/ Z}P"CrS W|7bH 99t-5~D &R?S- lKNHiT _wps0 g;uE- 0*ei^ zN@V" 8s|Nu #rj#7/ :^v3k~ z?KQqAeU yO&2~VjC rUoFja J?S-'sr v">$MQ%M?bjbjU Computer Management canned console 11/14/97 update 1/14/97 Contacts:  MFreed  JonN Test -- JerryA How the Canned console is created. 0.   Set screen resolution to 640x480 pixels [JonN   size MMC window such that image size is 638x452 on ALT-PrtSc from console] run mmc Select Add/remove SnapIn from MMC s file menu Select Computer Management  In the Wizard select  local  and  Allow selected computer to be changed Enable all the extensions (these should be on by default in beta2, but double check), check "Add all extensions" Right click on the  Computer Management  root node and Select  new window from here Delete the original child window Fully expand the existing child window Select Console/Options, in the Console tab, change icon to %windir%\system32\mycomput.dll, change name "Console1" to "Computer Management", set Console mode to "User mode - limited access, single window", check "Do not save changes to this console", click OK Select the Root node Adjust the vertical split bar to allow some space for localization on the scope pane nodes Move the window to the center of screen From the View Menu select  Task Pad This is a Beta 2 item, this step in not in Beta 1 Select Properties from Console Menu Uncheck  show main menu show status bar Check  Prevent user from toggling console tree and standard toolbars Leave checked  prevent the user from opening and closing child windows Leave checked  force SDI Save the file as  compmgmt.msc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\clusternoderole.xml ===
<?xml version="1.0"?>
<Role
   name="Cluster Node Server"
   description="This server is a Node in a cluster."
   mys_id="Cluster"
>
<!-- mys_id attribute should be unique among the different roles.  It is used to track collapsed/expanded state. -->

<_locDefinition>
   <_locTag _loc="locData" _locAttrData="name, description">Role</_locTag>
   <_locTag _loc="locData" _locAttrData="description, tooltip">Link</_locTag>
</_locDefinition>

   <Links>
      <Link
         description="Click this link to start IE"
         type="url"
         command="http://www.microsoft.com"
         tooltip="click me!"
      />
   </Links>
</Role>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\dhcpserverrole.xml ===
<?xml version="1.0"?>
<Role
   name="DHCP Server"
   description="DHCP (Dynamic Host Configuration Protocol) servers assign IP addresses to network clients."
   mys_id="DHCP"
>
<!-- mys_id attribute should be unique among the different roles.  It is used to track collapsed/expanded state. -->
<_locDefinition>
   <_locTag _loc="locData" _locAttrData="name, description">Role</_locTag>
   <_locTag _loc="locData" _locAttrData="description, tooltip">Link</_locTag>
</_locDefinition>

   <Links>
      <Link
         description="Manage this DHCP server"
         type="program"
         command="&quot;%SystemRoot%\System32\dhcpmgmt.msc&quot;"
         tooltip="Opens the DHCP console, which helps you assign IP addresses to network clients."
      />
      <Link
         description="Review the next steps for this role"
         type="help"
         command="cys.chm::/dhcp_server_role.htm#dhcpsrvcompletion"
         tooltip="Opens a Help topic that contains a checklist of recommended tasks for this role."
      />
   </Links>
</Role>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\dnsserverrole.xml ===
<?xml version="1.0"?>
<Role
   name="DNS Server"
   description="DNS (Domain Name System) servers translate domain and computer DNS names to IP addresses."
   mys_id="DNS"
>
<!-- mys_id attribute should be unique among the different roles.  It is used to track collapsed/expanded state. -->
<_locDefinition>
   <_locTag _loc="locData" _locAttrData="name, description">Role</_locTag>
   <_locTag _loc="locData" _locAttrData="description, tooltip">Link</_locTag>
</_locDefinition>

   <Links>
      <Link
         description="Manage this DNS server"
         type="program"
         command="&quot;%SystemRoot%\System32\dnsmgmt.msc&quot;"
         tooltip="Opens the DNS console, which helps you maintain the DNS database."
      />
      <Link
         description="Review the next steps for this role"
         type="help"
         command="cys.chm::/dns_server_role.htm#dnssrvcompletion"
         tooltip="Opens a Help topic that contains a checklist of recommended tasks for this role."
      />
   </Links>
</Role>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\domaincontrollerrole.xml ===
<?xml version="1.0"?>
<Role
   name="Domain Controller (Active Directory)"
   description="Domain controllers use Active Directory to manage network resources such as users, computers, and applications."
   mys_id="DomainController"
>
<!-- mys_id attribute should be unique among the different roles.  It is used to track collapsed/expanded state. -->
<_locDefinition>
   <_locTag _loc="locData" _locAttrData="name, description">Role</_locTag>
   <_locTag _loc="locData" _locAttrData="description, tooltip">Link</_locTag>
</_locDefinition>

   <Links>
      <Link
         description="Manage users and computers in Active Directory"
         type="program"
         command="&quot;%SystemRoot%\System32\dsa.msc&quot;"
         tooltip="Opens the console for administering and publishing information in the directory."
      />
<!--
      <Link
         id="adDSALinkServMgmt"
         description="Manage users and computers in Active Directory"
         type="program"
         command="&quot;%SystemRoot%\System32\Administration\servmgmt.msc&quot;"
         tooltip="Opens the console for administering and publishing information in the directory."
      />
-->
      <Link
         description="Manage domains and trusts"
         type="program"
         command="&quot;%SystemRoot%\System32\domain.msc&quot;"
         tooltip="Opens the console for administering domain trusts, domain and forest functional levels, and user principal name suffixes."
      />
      <Link
         description="Manage sites and services"
         type="program"
         command="&quot;%SystemRoot%\System32\dssite.msc&quot;"
         tooltip="Opens the console for configuring the directory servicefor example, administering the replication of directory data."
      />
      <Link
         description="Review the next steps for this role"
         type="help"
         command="cys.chm::/ad_server_role.htm#adsrvcompletion"
         tooltip="Opens a Help topic that contains a checklist of recommended tasks for this role."
      />
   </Links>
</Role>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\fileserverrole.xml ===
<?xml version="1.0"?>
<Role
   name="File Server"
   description="File servers provide and manage access to files."
   mys_id="FileServer"
>
<!-- mys_id attribute should be unique among the different roles.  It is used to track collapsed/expanded state. -->
<_locDefinition>
   <_locTag _loc="locData" _locAttrData="name, description">Role</_locTag>
   <_locTag _loc="locData" _locAttrData="description, tooltip">Link</_locTag>
</_locDefinition>

   <Links>
      <Link
         description="Manage this file server"
         type="program"
         command="&quot;%SystemRoot%\System32\filesvr.msc&quot;"
         tooltip="Opens the File Server Management console, which helps you manage shares and disks for this server."
      />
      <Link
         description="Add shared folders"
         type="program"
         command="&quot;%SystemRoot%\System32\shrpubw.exe&quot; /s"
         tooltip="Runs the Add Shared Folders Wizard."
      />
      <Link
         description="Review the next steps for this role"
         type="help"
         command="cys.chm::/file_server_role.htm#filesrvcompletion"
         tooltip="Opens a Help topic that contains a checklist of recommended tasks for this role."
      />
   </Links>
</Role>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\pop3serverrole.xml ===
<?xml version="1.0"?>
<Role
   name="Mail Server (POP3, SMTP)"
   description="Mail servers use the POP3 service to provide e-mail delivery and tools for creating and managing e-mail accounts."
   mys_id="POP3"
>
<!-- mys_id attribute should be unique among the different roles.  It is used to track collapsed/expanded state. -->
<_locDefinition>
   <_locTag _loc="locData" _locAttrData="name, description">Role</_locTag>
   <_locTag _loc="locData" _locAttrData="description, tooltip">Link</_locTag>
</_locDefinition>

   <Links>
      <Link
         description="Manage this mail server"
         type="program"
         command="%1"
         tooltip="Provides a means to create and manage e-mail accounts using the POP3 protocol."
      />
      <Link
         description="Review the next steps for this role"
         type="help"
         command="cys.chm::/mail_server_role.htm#mailsrvcompletion"
         tooltip="Opens a Help topic that contains a checklist of recommended tasks for this role."
      />
   </Links>
</Role>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\mediaserverrole.xml ===
<?xml version="1.0"?>
<Role
   name="Streaming Media Server"
   description="Streaming media servers store digital multimedia presentations that are transmitted over an intranet or the Internet."
   mys_id="Media"
>
<!-- mys_id attribute should be unique among the different roles.  It is used to track collapsed/expanded state. -->
<_locDefinition>
   <_locTag _loc="locData" _locAttrData="name, description">Role</_locTag>
   <_locTag _loc="locData" _locAttrData="description, tooltip">Link</_locTag>
</_locDefinition>

   <Links>
      <Link
         description="Manage this streaming media server"
         type="program"
         command="&quot;%windir%\system32\Windows Media\Server\Admin\MMC\wmsadmin.msc&quot;"
         tooltip="Opens Windows Media Services, which helps you manage, deliver, and archive Windows Media content."
      />
      <Link
         description="Review the next steps for this role"
         type="help"
         command="cys.chm::/media_server_role.htm#mediasrvcompletion"
         tooltip="Opens a Help topic that contains a checklist of recommended tasks for this role."
      />
   </Links>
</Role>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\sharepointserverrole.xml ===
<?xml version="1.0"?>
<Role
   name="Team Intranet Server"
   description="Team intranet servers use Microsoft SharePoint Team Services to enable groups within an organization to work together. Users can share documents, participate in discussions, and post information, such as announcements and task assignments, in a central location."
>
<_locDefinition>
   <_locTag _loc="locData" _locAttrData="*">Role</_locTag>
   <_locTag _loc="locData" _locAttrData="description, tooltip">Link</_locTag>
</_locDefinition>
   <Links>
      <Link
         description="Manage this team intranet server"
         type="url"
         command="%1"
         tooltip="Opens the SharePoint Team Services management tool."
      />
      <Link
         description="Open your team Web site"
         type="url"
         command="%2"
         tooltip="Opens the intranet site you have configured for collaboration on your network."
      />
      <Link
         description="Review the next steps for this role"
         type="help"
         command="cys.chm::/cys_after_sharepoint.htm"
         tooltip="Opens a Help topic that contains a checklist of recommended tasks for this role."
      />
   </Links>
</Role>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\rrasserverrole.xml ===
<?xml version="1.0"?>
<Role
   name="Remote Access/VPN Server"
   description="Remote access/VPN servers enable remote clients to connect to a network through either a dial-up connection or a secure Virtual Private Network (VPN) connection. They also provide network address translation (NAT), which enables all of the computers on a small network to share a single connection to the Internet."
   mys_id="Rras"
>
<!-- mys_id attribute should be unique among the different roles.  It is used to track collapsed/expanded state. -->
<_locDefinition>
   <_locTag _loc="locData" _locAttrData="name, description">Role</_locTag>
   <_locTag _loc="locData" _locAttrData="description, tooltip">Link</_locTag>
</_locDefinition>
   <Links>
      <Link
         description="Manage this remote access/VPN server"
         type="program"
         command="&quot;%SystemRoot%\System32\rrasmgmt.msc&quot; /s"
         tooltip="Opens the console for configuring and managing the Routing and Remote Access service."
      />
      <Link
         description="Review the next steps for this role"
         type="help"
         command="cys.chm::/vpn_server_role.htm#vpnsrvcompletion"
         tooltip="Opens a Help topic that contains a checklist of recommended tasks for this role."
      />
   </Links>
</Role>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\sipserverrole.xml ===
<?xml version="1.0"?>
<Role
   name="Real-Time Communication Server"
   description="Real-time communication servers use the Session Initiation Protocol (SIP) service to enable communication sessions, such as instant messaging, data collaboration, and file transfers."
>
<_locDefinition>
   <_locTag _loc="locData" _locAttrData="*">Role</_locTag>
   <_locTag _loc="locData" _locAttrData="description, tooltip">Link</_locTag>
</_locDefinition>
   <Links>
      <Link
         description="Manage this real time communication server"
         type="program"
         command="&quot;%SystemRoot%\System32\RTCSrv\winsip.msc&quot;"
         tooltip="CODEWORK: Open issue: this will need to drop without a working tooltip."
      />
      <Link
         description="Review the next steps for this role"
         type="help"
         command="cys.chm::/cys_after_rtc.htm"
         tooltip="Opens a Help topic that contains a checklist of recommended tasks for this role."
      />
   </Links>
</Role>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\printserverrole.xml ===
<?xml version="1.0"?>
<Role
   name="Print Server"
   description="Print servers provide and manage access to network printers and printer drivers."
   mys_id="PrintServer"
>
<!-- mys_id attribute should be unique among the different roles.  It is used to track collapsed/expanded state. -->
<_locDefinition>
   <_locTag _loc="locData" _locAttrData="name, description">Role</_locTag>
   <_locTag _loc="locData" _locAttrData="description, tooltip">Link</_locTag>
</_locDefinition>

   <Links>
      <Link
         description="Open Printers and Faxes"
         type="cpl"
         command="printers"
         tooltip="Adds, configures, or removes local and network printers and fax printers."
      />
      <Link
         description="Add a printer"
         type="program"
         command="&quot;%SystemRoot%\System32\rundll32.exe&quot; printui.dll,PrintUIEntry /il"
         tooltip="Runs the Add Printer Wizard."
      />
      <Link
         description="Add a printer driver"
         type="program"
         command="&quot;%SystemRoot%\System32\rundll32.exe&quot; printui.dll,PrintUIEntry /id"
         tooltip="Runs the Add Printer Driver Wizard."
      />
      <Link
         description="Review the next steps for this role"
         type="help"
         command="cys.chm::/print_server_role.htm#printsrvcompletion"
         tooltip="Opens a Help topic that contains a checklist of recommended tasks for this role."
      />
   </Links>
</Role>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\mysstatic.xml ===
﻿<?xml version="1.0"?>
	<!--loc: keep the inline html markup below to mark the access key -->
<mys title="Manage Your Server" serverCaption="Server: " 
	dontDisplayCaption="&lt;u style=&quot;ACCELERATOR:true&quot;&gt;D&lt;/u&gt;on't display this page at logon"
	dontDisplayAccessKey="d"
	searchCaption="&lt;b&gt;&lt;u style=&quot;ACCELERATOR:true&quot;&gt;S&lt;/u&gt;earch&lt;/b&gt; Help and Support Center"
	searchAccessKey="s"
	>
	<_locDefinition>
            <_locTag _loc="locData" _locAttrData="*">mys</_locTag>
            <_locTag _loc="locData" _locAttrData="title, nodata,roledescription,nodatadescription">task</_locTag>
            <_locTag _loc="locData" _locAttrData="name, tooltip">subtask</_locTag>
            <_locTag _loc="locData" _locAttrData="*">title</_locTag>
            <_locTag _loc="locData" _locAttrData="name,link,tooltip,accesskey">tool</_locTag>
            <_locTag _loc="locData" _locAttrData="title">tooltray</_locTag>
            <_locTag _loc="locData" _locAttrData="text">linkerror</_locTag>
	</_locDefinition>
    <image src="mys_large.gif" alt="Manage Your Server"/>
    <linkerror text="Windows cannot find the file or page you requested (%1). Press F5 to refresh the Manage Your Server page, and then click the link again." />
	<tasklist>
		<task title="You do not have the correct permissions to manage this server." id="errInvalidUser">
			<image src="info_large.gif" alt=""/>
			<description>
                You do not have the correct permissions to manage this server. For more information, contact your system administrator.
			</description>
		</task>
        <task title="Managing Your Server is not available for this operating system." id="errInvalidSku">
            <image src="info_large.gif" alt=""/>
			<description>
	            Manage Your Server is available only for the following operating systems: Windows Server 2003, Standard Edition; Windows Server 2003, Enterprise Edition; Windows Server 2003, Datacenter Edition.
			</description>
		</task>
        <task title="Cluster Nodes Cannot Be Managed with Manage Your Server" id="errIsCluster">
			<image src="info_large.gif" alt=""/>
			<description>
	            Because this server is a member of a server cluster (also called a cluster node), you cannot manage it with Manage Your Server. For information about managing a cluster node, click Read about managing cluster nodes.
			</description>
			<subtasks>
                <subtask name="Read about managing cluster nodes" type="help" link="mscsconcepts.chm::/mscsquick.htm" tooltip="Runs the Configure Your Server Wizard." >
                    <image src="Help.gif" alt=""/>
				</subtask>
			</subtasks>
		</task>
		<task title="Adding Roles to Your Server" id="addrole">
			<image src="cys_small.gif" alt=""/>
			<description>
				Adding roles to your server lets it perform specific tasks. For example, the file server
				role enables your server to share files. To add a role, start the Configure Your Server Wizard
				by clicking Add or remove a role.
			</description>
			<subtasks>
                <subtask name="Add or remove a role" type="program" link="%WinDir%\\system32\\cys.exe /skipwelcome" tooltip="Runs the Configure Your Server Wizard." >
					<image src="greenarrow_small.gif" alt=""/>
				</subtask>
                <subtask name="Read about server roles" type="help" link="cys.chm::/choose_role.htm" tooltip="Opens a document that helps you determine which roles to select for your server." >
					<image src="Help.gif" alt=""/>
				</subtask>
			</subtasks>
		</task>
		<task title="Managing Your Server Roles" id="managerole" 
			nodatadescription="After you have added a role, return to this page at any time for tools and information to help you with your daily administrative tasks."
			nodata="No roles have been added to this server. To add a role, click Add or remove a role."
			roledescription="Your server has been configured with the following roles:"
		>
			<image src="mys_small.gif" alt=""/>
			<description>
				Use the tools and information found here to add or remove roles and perform your daily administrative tasks.
			</description>
			<subtasks>
                <subtask name="Add or remove a role" type="program" link="%WinDir%\\system32\\cys.exe /skipwelcome" tooltip="Runs the Configure Your Server Wizard." >
					<image src="greenarrow_small.gif" alt=""/>
				</subtask>
                <subtask name="Read about server roles" type="help" link="cys.chm::/choose_role.htm" tooltip="Opens a document that helps you determine which roles to select for your server." >
                    <image src="Help.gif" alt=""/>
				</subtask>
				<subtask name="Read about remote administration" type="help" link="remote.chm::/remoteadmin_overview.htm" tooltip="Provides information about allowing remote access to this computer." >
					<image src="Help.gif" alt=""/>
				</subtask>
			</subtasks>
		</task>		
	</tasklist>
	<tools>
	<!--loc: keep the inline html markup below to mark the access key -->
		<tooltray title="&lt;u style=&quot;ACCELERATOR:true&quot;&gt;T&lt;/u&gt;ools and Updates">             
                        <!-- The accesskey accelerator on first tool gives the appearance that the pane itself has an accelerator-->
			<tool 
                            accesskey="t" 
			    name="Administrative Tools" 
			    type="cpl" 
			    link="admintools" 
			    tooltip="Provides tools that help you manage computers, services, and resources on your network." />
            <!-- warning:  you must localize the path -->
            <!-- <tool 
			    name="System Tools" 
                type="program" 
                link='explorer.exe "%ALLUSERSPROFILE%\\Start Menu\\Programs\\Accessories\\System Tools"' 
                tooltip="Provides tools such as Disk Defragmenter to help you keep your system running smoothly." /> -->
			<tool 
			    name="More Tools" 
			    type="hcp" 
                link="hcp://services/centers/tools" 
                tooltip="Opens the Tools page in Help and Support Center." />
			<tool 
			    name="Windows Update" 
                type="program" 
			    link="%SystemRoot%\\system32\\wupdmgr.exe" 
                tooltip="Connects you to the Windows Update Web site, where you can search for the latest updates, security fixes, and device drivers." />						
            <tool
                name="Computer and Domain Name Information"
                type="cpl"
                link="sysdm.cpl,,1"
                tooltip="Displays the Computer Name tab in System properties, where you can change this server's computer name or domain membership." />
            <tool
                name="Internet Explorer Enhanced Security Configuration"
                type="program"
                link="res://%SystemRoot%\\System32\\shdoclc.dll/IESecHelp.htm"
                tooltip="Opens a Help topic about the Internet Explorer Enhanced Security Configuration tool."
             />
            <tool
                name="Server Management"
                type="program"
                link="%SystemRoot%\\System32\\Administration\\servmgmt.msc"
                tooltip="Opens the Server Management console, which helps you perform tasks associated with the roles you selected." 
                id="servMgmtLink" />
		</tooltray>
		<tooltray title="S&lt;u style=&quot;ACCELERATOR:true&quot;&gt;e&lt;/u&gt;e Also">
                        <!-- The accesskey accelerator on first tool gives the appearance that the pane itself has an accelerator-->
			<tool 
                            accesskey="e" 
			    name="Help and Support" 
			    type="hcp" 
			    link="hcp://services/centers/homepage" 
                tooltip="Opens Help and Support Center, where you can find Help topics, troubleshooting information, and support services." />
			<tool 
			    name="Microsoft TechNet" 
			    type="url" 
			    link="http://go.microsoft.com/fwlink/?LinkId=7714" 
                tooltip="Connects you to the TechNet Web site, which provides news and information for IT administration." />
			<!-- TODO -->
			<tool 
			    name="Deployment and Resource Kits" 
                type="help" 
			    link="reskit.chm::/HSS_rktopic.htm"
                tooltip="Opens a Help topic that provides information about the Windows Deployment and Resource Kits and provides a link to this content on the Web." />
			<tool 
			    name="List of Common Administrative Tasks" 
			    type="help" 
			    link="ctasks.chm::/ctasks_topnode.htm"
			    tooltip="Displays a list of the recommended daily maintenance tasks." />
			<tool 
			    name="Windows Server Communities" 
			    type="url" 
			    link="http://go.microsoft.com/fwlink/?LinkId=6098"
                tooltip="Connects you to the Microsoft Communities Web site, where you can communicate with peers and experts about deploying, managing, and troubleshooting Windows server operating systems." />
			<tool 
			    name="What's New" 
			    type="help" 
			    link="Gstart.chm::/new_features_gstart.htm"
                tooltip="Provides details about new features and improvements in Windows Server 2003." />
			<tool 
			    name="Strategic Technology Protection Program" 
			    type="url" 
			    link="http://go.microsoft.com/fwlink/?LinkId=102"
                tooltip="Connects you to the Microsoft TechNet Security Web site, which provides information and tools that help you make your server more secure." />
		</tooltray>
	</tools>
</mys>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\winsserverrole.xml ===
<?xml version="1.0"?>
<Role
   name="WINS Server"
   description="WINS (Windows Internet Name Service) servers translate computer and domain NetBIOS names to IP addresses."
   mys_id="WINS"
>
<!-- mys_id attribute should be unique among the different roles.  It is used to track collapsed/expanded state. -->
<_locDefinition>
   <_locTag _loc="locData" _locAttrData="name, description">Role</_locTag>
   <_locTag _loc="locData" _locAttrData="description, tooltip">Link</_locTag>
</_locDefinition>
   <Links>
      <Link
         description="Manage this WINS server"
         type="program"
         command="&quot;%SystemRoot%\System32\winsmgmt.msc&quot;"
         tooltip="Opens the WINS console in MMC, which helps you translate NetBIOS names to IP addresses."
      />
      <Link
         description="Review the next steps for this role"
         type="help"
         command="cys.chm::/wins_server_role.htm#winssrvcompletion"
         tooltip="Opens a Help topic that contains a checklist of recommended tasks for this role."
      />
   </Links>
</Role>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\webserverrole.xml ===
<?xml version="1.0"?>
<Role
   name="Application Server"
   description="%1"
   mys_id="WebServer"
>
<!-- mys_id attribute should be unique among the different roles.  It is used to track collapsed/expanded state. -->
<_locDefinition>
   <_locTag _loc="locData" _locAttrData="name, description">Role</_locTag>
   <_locTag _loc="locData" _locAttrData="description, tooltip">Link</_locTag>
</_locDefinition>

   <Links>
      <Link
         id="webServerMgmtLink"
         description="Manage this application server"
         type="program"
         command="&quot;%%SystemRoot%%\System32\appsrv.msc&quot;"
         tooltip="Opens the Application Server console, which helps you manage Web sites and .NET applications."
      />
      <Link
         description="Read about application servers"
         type="help"
         command="cys.chm::/web_server_role.htm"
         tooltip="Opens the implementation guide for application servers."
         />
      <Link
          description="%2"
          type="%3"
          command="%4"
          tooltip="Provides tools for using a Web browser to administer a Web server remotely."
          />
      <Link
         description="Review the next steps for this role"
         type="help"
         command="cys.chm::/web_server_role.htm#websrvcompletion"
         tooltip="Opens a Help topic that contains a checklist of recommended tasks for this role."
      />
   </Links>
</Role>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\res\terminalserverrole.xml ===
<?xml version="1.0"?>
<Role
   name="Terminal Server"
   description="%1"
   mys_id="TS"
>
<!-- mys_id attribute should be unique among the different roles.  It is used to track collapsed/expanded state. -->
<_locDefinition>
   <_locTag _loc="locData" _locAttrData="name, description">Role</_locTag>
   <_locTag _loc="locData" _locAttrData="description, tooltip">Link</_locTag>
</_locDefinition>
   <Links>
      <Link
         description="Review licensing requirements"
         type="help"
         command="cys.chm::/terminal_server_role.htm#termsrvlicensing"
         tooltip="Opens a Help topic that explains Terminal Service licensing requirements."
      />
      <Link
         description="Open Terminal Services Configuration"
         type="program"
         command="&quot;%%SystemRoot%%\System32\tscc.msc&quot; /s"
         tooltip="Opens the console for managing Terminal Services protocol configuration and server settings."
      />
      <Link
         description="Open Terminal Services Manager"
         type="program"
         command="&quot;%%SystemRoot%%\System32\tsadmin.exe&quot;"
         tooltip="Opens the console for managing and monitoring users, sessions, and processes on any server running Terminal Services."
      />
      <Link
         description="Review the next steps for this role"
         type="help"
         command="cys.chm::/terminal_server_role.htm#termsrvcompletion"
         tooltip="Opens a Help topic that contains a checklist of recommended tasks for this role."
      />
   </Links>
</Role>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\appcompat\placefil.txt ===
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;

msimain.sdb         retail
sdbapi.dll          retail
sdbapiu.dll         retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\placefil.txt ===
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;

;
; postbuild make file
;
msitool.mak       instmsi\msitools


;
; cab directive files
;
orcacab.ddf       instmsi\msitools
mergecab.ddf      instmsi\msitools
evalcab.ddf       instmsi\msitools
msivlcab.ddf      instmsi\msitools
spycab.ddf        instmsi\msitools


;
; external binaries
;

msstkprp.dll      instmsi\msitools\binary
mfc42.dll         instmsi\msitools\binary
mfc42u.dll        instmsi\msitools\binary
msvcrt.dll        instmsi\msitools\binary

;
; raw built packages
;

msival2.msi       instmsi\msitools
orca.msi          instmsi\msitools
msispy.msi        instmsi\msitools
evalcom.msm       instmsi\msitools
mergemod.msm      instmsi\msitools
orca.dat          msi_bins
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\instmsi\placefil.txt ===
; This file is used to specify where every file built by the NT build lab is
; binplaced relative to the root of the distribution point.  If a file is not
; listed, it will end up in the dump directory.
;
; The format is like this:
;
; <imagename>    <class name>
;
; where <imagename> is the filename.ext and <class name> is the directory off
; the root of the distribution point (retail is a placeholder for the root).
; If there are multiple class names for a single image, use a colon to separate
; each.
;
; All bits that ship in the NT base product and are installed with winnt32,
; must have a class name of retail.
;

instmsi.msi         retail
instmsi.mak         retail
binary.idt          retail
instsed.tmp         retail
msi.cdf             retail
msi.inf             retail
mspatcha.cdf        retail
mspatcha.inf        retail
imagehlp.dll        retail
jdate2.exe          msi_bins
msiinst.exe         retail

cabinet.dll         msi_bins
mspatcha.dll        msi_bins
instmsi.sed         msi_bins
riched20.dll        retail
usp10.dll           retail
msls31.dll          retail
shfolder.dll        retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\schema.idt\schema.log ===
Darwin Schema Change Descriptions

-----------------------------------------
     Windows Installer 1.0
-----------------------------------------

Max Supported Schema: 100

-----------------------------------------
     Windows Installer 1.1 
-----------------------------------------

Max Supported Schema: 110

Changes/Additions:

 Complus table added.
 Upgrade table added.
 Attributes column added to Class table.
 Description column added to ServiceInstall table.
 IsolatedComponent table added. 
 Description column of ODBCDataSource table was made non-localizable.
 Driver Description column of ODBCDataSource table was made non-localizable.
 Description column of ODBCTranslator table was made non-localizable.

-----------------------------------------
     Windows Installer 1.2
-----------------------------------------

Max Supported Schema: 120

Changes/Additions:

 FileSFPCatalog table added.
 SFPCatalog table added.

-----------------------------------------
     Windows Installer 2.0
-----------------------------------------

Max Supported Schema: 200

Changes/Additions:
 MsiAssembly table added.
 MsiAssemblyName table added.
 MsiDigitalCertificate table added.
 MsiDigitalSignature table added.
 MsiFileHash table added.
 Version column of TypeLib table is now of type DoubleInteger.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\sdk\layout.txt ===
REM This is the only file you should directly edit for placing files into the SDK

REM This file generates placefil.txt, layout.inc, and sdkmake.inc.  DO NOT EDIT THOSE.

REM Steps for adding or modifying a file location in the SDK
REM > sd edit layout.txt placefil.txt layout.inc sdkmake.inc
REM Modify layout.txt with location.
REM > perl sdkplace.pl layout.txt
REM check in the files

REM layout.txt format:
REM Source Directory for files                            Destination in SDK layout

REM Any source entry with %_NTTREE% will be automatically put into sdkmake.inc for use 
REM with postbuild.  These files are only copied during postbuild, as they may not
REM exist during the regular build.

REM Use the "retail\" destination to specify the parent directory to the actual
REM layout directory.  This is the location to put things like postbuild make files

REM For files by the same name that go to multiple directories, preface the source
REM path with a number 0-9.   This will generate a new file name for the placefile,
REM and generate postmake steps to rename the file to its original.

REM --------------The postbuild make file-----------------------------------------------
sdkmake.inc                                               retail\
sdkpost.mak	                                          retail\

REM --------------SDK MSI FILES---------------------------------------------------------
%BUILD_PACKAGEDIR%\msisdk.msi			          retail\

REM --------------README FILES----------------------------------------------------------
%SDXROOT%\admin\darwin\src\sdk\readme.txt                 .\
%SDXROOT%\admin\darwin\src\sdk\redist.txt                 .\
%SDXROOT%\admin\darwin\src\sdk\license.rtf                .\

REM --------------MISCELLANEOUS FILES---------------------------------------------------
%SDXROOT%\admin\darwin\src\sdk\instlr1.adm                TOOLS\
%SDXROOT%\admin\darwin\src\sdk\instlr11.adm               TOOLS\

REM --------------INCLUDE FILES---------------------------------------------------------
%SDXROOT%\public\sdk\inc\msi.h                            INCLUDE\
%SDXROOT%\public\sdk\inc\msiquery.h                       INCLUDE\
%SDXROOT%\public\sdk\inc\msidefs.h                        INCLUDE\
%SDXROOT%\admin\darwin\src\msitools\patchwiz\patchwiz.h   INCLUDE\
%SDXROOT%\public\sdk\inc\patchapi.h                 INCLUDE\
%SDXROOT%\admin\darwin\build\common\obj\i386\mergemod.h   INCLUDE\

REM --------------LIB FILES--------------------------------------------------------------
%SDXROOT%\public\sdk\lib\i386\msi.lib                     LIB\
%SDXROOT%\public\sdk\lib\i386\mspatchc.lib              LIB\
%_NTTREE%\msiwin9x\patchwiz.lib  LIB\

REM --------------HELP-------------------------------------------------------------------
%SDXROOT%\admin\darwin\doc\Msi.chm                        HELP\
%SDXROOT%\admin\darwin\doc\Msi.chi                        HELP\

REM --------------WEB--------------------------------------------------------------------
%_NTTREE%\msistuff.exe                                 WEB\
%_NTTREE%\msiwin9x\setup.exe                                WEB\

REM --------------TOOLS------------------------------------------------------------------
%SDXROOT%\admin\darwin\src\msitools\MsiTool.mak             TOOLS\
%_NTTREE%\msi_bins\mergemod.dll                                 TOOLS\
%_NTTREE%\msiwin9x\msimig.dll                          TOOLS\
%_NTTREE%\msiwin9x\msimig.exe                          TOOLS\
%_NTTREE%\instmsi\msitools\temp\orca.msi                    TOOLS\
%_NTTREE%\instmsi\msitools\temp\msival2.msi                 TOOLS\
%_NTTREE%\msiwin9x\msicert.exe                         TOOLS\
%_NTTREE%\msiwin9X\mstools\msidb.exe                        TOOLS\
%_NTTREE%\msiwin9x\mstools\msifiler.exe                     TOOLS\
%_NTTREE%\msiwin9x\msiinfo.exe                         TOOLS\
%_NTTREE%\msiwin9x\msi_bins\msimerg.exe                         TOOLS\
%_NTTREE%\msiwin9x\msitran.exe                         TOOLS\
%_NTTREE%\msiwin9x\msizap.exe                          TOOLS\
%_NTTREE%\msiwin9x\wilogutl.exe                        TOOLS\
%SDXROOT%\admin\darwin\data\archive\cubes\110\darice.cub    TOOLS\110\
%SDXROOT%\admin\darwin\data\archive\cubes\110\logo.cub      TOOLS\110\
%SDXROOT%\admin\darwin\data\archive\cubes\110\mergemod.cub  TOOLS\110\
1%SDXROOT%\admin\darwin\data\archive\cubes\120\darice.cub    TOOLS\120\
1%SDXROOT%\admin\darwin\data\archive\cubes\120\logo.cub      TOOLS\120\
1%SDXROOT%\admin\darwin\data\archive\cubes\120\mergemod.cub  TOOLS\120\

REM --------------PATCHING---------------------------------------------------------------
%SDXROOT%\admin\darwin\src\sdk\preadme.txt                 PATCHING\
%SDXROOT%\admin\darwin\bin\i386\makecab.exe                TOOLS\
%_NTTREE%\idw\mpatch.exe                                   TOOLS\
%_NTTREE%\idw\apatch.exe                                   TOOLS\
%_NTTREE%\idw\mspatchc.dll                                 TOOLS\
%_NTTREE%\msiwin9x\patchwiz.dll                       TOOLS\
%SDXROOT%\admin\darwin\src\msitools\PatchWiz\template.pcp  PATCHING\
%SDXROOT%\admin\darwin\src\msitools\PatchWiz\example.pcp   PATCHING\
%_NTTREE%\msiwin9x\msimsp.exe                         TOOLS\

REM --------------WSH TOOLS-------------------------------------------------------------
%SDXROOT%\admin\darwin\src\msitools\scripts\WiReadme.txt    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiCompon.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiDialog.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiDiffDb.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiExport.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiFilVer.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiFeatur.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiGenXfm.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiImport.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiLangId.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiLstPrd.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiLstScr.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiLstXfm.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiMakCab.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiMerge.vbs     SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiPolicy.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiRunSQL.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiStream.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiSubStg.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiSumInf.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiTextIn.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiToAnsi.vbs    SAMPLES\SCRIPTS\
%SDXROOT%\admin\darwin\src\msitools\scripts\WiUseXfm.vbs    SAMPLES\SCRIPTS\

REM --------------SAMPLES----------------------------------------------------------------
%SDXROOT%\admin\darwin\src\samples\tutorial.dll\tutorial.cpp 	SAMPLES\tutorial.dll
%SDXROOT%\admin\darwin\src\samples\tutorial.dll\tutorial.rc  	SAMPLES\tutorial.dll
%SDXROOT%\admin\darwin\src\samples\tutorial.dll\tutorial.def 	SAMPLES\tutorial.dll
3%SDXROOT%\admin\darwin\src\samples\tutorial.dll\SDKFiles\makefile     SAMPLES\tutorial.dll
3%SDXROOT%\admin\darwin\src\samples\tutorial.dll\SDKFiles\readme.txt   SAMPLES\tutorial.dll

%SDXROOT%\admin\darwin\src\samples\process.dll\process.cpp   SAMPLES\process.dll
%SDXROOT%\admin\darwin\src\samples\process.dll\process.rc    SAMPLES\process.dll
%SDXROOT%\admin\darwin\src\samples\process.dll\process.def   SAMPLES\process.dll
4%SDXROOT%\admin\darwin\src\samples\process.dll\SDKFiles\makefile      SAMPLES\process.dll
4%SDXROOT%\admin\darwin\src\samples\process.dll\SDKFiles\readme.txt    SAMPLES\process.dll

%SDXROOT%\admin\darwin\src\samples\remove.dll\remove.cpp     SAMPLES\remove.dll
%SDXROOT%\admin\darwin\src\samples\remove.dll\remove.rc      SAMPLES\remove.dll
%SDXROOT%\admin\darwin\src\samples\remove.dll\remove.def     SAMPLES\remove.dll
5%SDXROOT%\admin\darwin\src\samples\remove.dll\SDKFiles\makefile       SAMPLES\remove.dll
5%SDXROOT%\admin\darwin\src\samples\remove.dll\SDKFiles\readme.txt     SAMPLES\remove.dll

%SDXROOT%\admin\darwin\src\samples\create.dll\create.cpp     SAMPLES\create.dll
%SDXROOT%\admin\darwin\src\samples\create.dll\create.rc      SAMPLES\create.dll
%SDXROOT%\admin\darwin\src\samples\create.dll\create.def     SAMPLES\create.dll
6%SDXROOT%\admin\darwin\src\samples\create.dll\SDKFiles\makefile SAMPLES\create.dll
6%SDXROOT%\admin\darwin\src\samples\create.dll\SDKFiles\readme.txt     SAMPLES\create.dll

%SDXROOT%\admin\darwin\src\msitools\msiloc\msiloc.cpp        SAMPLES\msiloc
%SDXROOT%\admin\darwin\src\msitools\msiloc\msiloc.rc         SAMPLES\msiloc
7%SDXROOT%\admin\darwin\src\msitools\msiloc\SDKFiles\makefile SAMPLES\msiloc
7%SDXROOT%\admin\darwin\src\msitools\msiloc\SDKFiles\readme.txt SAMPLES\msiloc

%SDXROOT%\admin\darwin\src\msitools\setup.exe\*.cpp          SAMPLES\setup.exe
%SDXROOT%\admin\darwin\src\msitools\setup.exe\*.h            SAMPLES\setup.exe
%SDXROOT%\admin\darwin\src\msitools\setup.exe\*.rc           SAMPLES\setup.exe
%SDXROOT%\admin\darwin\src\msitools\setup.exe\*.ico          SAMPLES\setup.exe

%SDXROOT%\admin\darwin\src\msitools\msistuff\*.cpp           SAMPLES\MsiStuff
%SDXROOT%\admin\darwin\src\msitools\msistuff\*.rc            SAMPLES\MsiStuff

1%SDXROOT%\admin\darwin\src\msitools\setup.exe\SDKFiles\Makefile     SAMPLES\setup.exe
1%SDXROOT%\admin\darwin\src\msitools\setup.exe\SDKFiles\ReadMe.htm   SAMPLES\setup.exe
2%SDXROOT%\admin\darwin\src\msitools\msistuff\SDKFiles\Makefile      SAMPLES\MsiStuff
2%SDXROOT%\admin\darwin\src\msitools\msistuff\SDKFiles\ReadMe.htm    SAMPLES\MsiStuff

REM --------------SCHEMA AND SAMPLE DATABASES--------------------------------------------
%SDXROOT%\admin\darwin\src\sdk\dbreadme.txt                   DATABASE\
%SDXROOT%\admin\darwin\build\packages\obj\i386\schema.msi     DATABASE\
1%SDXROOT%\admin\darwin\data\archive\packages\100\schema.msi   DATABASE\100\
2%SDXROOT%\admin\darwin\data\archive\packages\110\schema.msi   DATABASE\110\
3%SDXROOT%\admin\darwin\data\archive\packages\120\schema.msi   DATABASE\120\
%SDXROOT%\admin\darwin\build\packages\obj\i386\sequence.msi   DATABASE\
1%SDXROOT%\admin\darwin\data\archive\packages\100\sequence.msi DATABASE\100\
2%SDXROOT%\admin\darwin\data\archive\packages\110\sequence.msi DATABASE\110\
3%SDXROOT%\admin\darwin\data\archive\packages\120\sequence.msi DATABASE\120\
%SDXROOT%\admin\darwin\build\packages\obj\i386\schema.msm     DATABASE\
1%SDXROOT%\admin\darwin\data\archive\packages\110\schema.msm   DATABASE\110\
2%SDXROOT%\admin\darwin\data\archive\packages\120\schema.msm   DATABASE\120\
%SDXROOT%\admin\darwin\build\packages\obj\i386\UISample.msi   DATABASE\
%SDXROOT%\admin\darwin\data\intl\Error.*                      DATABASE\INTL\
%SDXROOT%\admin\darwin\data\intl\ActionTe.*                   DATABASE\INTL\
%SDXROOT%\admin\darwin\data\schema.idt\schema.log             DATABASE\
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\sdk.idt\msipkgs.log ===
Windows Installer SDK package information (GUID list)

-----------------------------------------
     1.0 SDK GUIDs
-----------------------------------------

 msival2.msi
	PackageCode  {0CD9A0A0-DDFD-11D1-A851-006097ABDE17}
	ProductCode  {0CD9A0A0-DDFD-11D1-A851-006097ABDE17}
	UpgradeCode  {AD2A58F2-E645-11D2-88C7-00A0C981B015}

 orca.msi
	PackageCode  {80F7E030-A751-11D2-A7D4-006097C99860}
	ProductCode  {80F7E030-A751-11D2-A7D4-006097C99860}
	UpgradeCode  {1AA03E10-2B19-11D2-B2EA-006097C99860}

 msispy.msi
	PackageCode  {000C1101-0000-0000-C000-000000000047}
	ProductCode  {9BBF15D0-1985-11D1-9A9D-006097C4E489}
	UpgradeCode  0

intelsdk.msi
	PackageCode  {BE7EB700-E9F1-11D2-9810-0040053547CB}
	ProductCode  {BE7EB700-E9F1-11D2-9810-0040053547CB}
	UpgradeCode  0


-----------------------------------------
     1.0 SDK Refresh GUIDs
-----------------------------------------
 
 no changes made

-----------------------------------------
     1.1 SDK GUIDs
-----------------------------------------

 note: all SDK packages will now use the following range
			
	 {8FC7****-88A0-4b41-82B8-8905D4AA904C}

 msival2.msi
	PackageCode  {8FC70000-88A0-4B41-82B8-8905D4AA904C}
	ProductCode  {8FC70000-88A0-4B41-82B8-8905D4AA904C}
	UpgradeCode  {AD2A58F2-E645-11D2-88C7-00A0C981B015}

 orca.msi
	PackageCode  {8FC71000-88A0-4B41-82B8-8905D4AA904C}
	ProductCode  {8FC71000-88A0-4B41-82B8-8905D4AA904C}
	UpgradeCode  {1AA03E10-2B19-11D2-B2EA-006097C99860}

 msispy.msi
	PackageCode  {8FC72000-88A0-4B41-82B8-8905D4AA904C}
	ProductCode  {8FC72000-88A0-4B41-82B8-8905D4AA904C}
	UpgradeCode  0

 intelsdk.msi
	PackageCode  {8FC73000-88A0-4B41-82B8-8905D4AA904C}
	ProductCode  {8FC73000-88A0-4B41-82B8-8905D4AA904C}
	UpgradeCode  0


-----------------------------------------
     1.2 SDK GUIDs
-----------------------------------------

 intelsdk.msi
	PackageCode    {8FC73001-88A0-4B41-82B8-8905D4AA904C}
	ProductCode    {8FC73001-88A0-4B41-82B8-8905D4AA904C}
	UpgradeCode    0
	ProductVersion 1.2

 msival2.msi
	PackageCode    {8FC70001-88A0-4B41-82B8-8905D4AA904C}
	ProductCode    {8FC70001-88A0-4B41-82B8-8905D4AA904C}
	UpgradeCode    {AD2A58F2-E645-11D2-88C7-00A0C981B015}
	ProductVersion 1.2

-----------------------------------------
     1.5 Beta 1 SDK GUIDs
-----------------------------------------

 intelsdk.msi
	PackageCode    {8FC73002-88A0-4B41-82B8-8905D4AA904C}
	ProductCode    {8FC73002-88A0-4B41-82B8-8905D4AA904C}
	UpgradeCode    0
	ProductVersion 1.5

 msival2.msi (x86)
	PackageCode  {B399DEDC-D348-42D0-9F1A-2A91BF1ABA76}
	ProductCode  {E1EA0AF4-6522-459C-9C0F-A1362E1286F9}
	UpgradeCode  {AD2A58F2-E645-11D2-88C7-00A0C981B015}

 orca.msi (x86)
	PackageCode  {FC556C9A-4292-4469-9150-7EF90B81FE61}
	ProductCode  {6F7CB29C-1319-4816-B345-0856916EB801}
	UpgradeCode  {1AA03E10-2B19-11D2-B2EA-006097C99860}

 msispy.msi -- NO LONGER AVAILABLE IN SDK RELEASES

 msival2.msi (ia64)
	PackageCode  {9F8F8E58-7A2B-4FD5-8057-7EEE069D9CA1}
	ProductCode  {546F90BE-A8F0-4FA4-853A-F6871CFEE41A}
	UpgradeCode  {105A6FFA-62E0-48B7-A02D-22E707DA24E3}

 orca.msi (ia64)
	PackageCode  {AE72B279-C841-457D-A819-1125683BBA81}
	ProductCode  {E46A76C0-F46C-463E-983D-E4FC123383BF}
	UpgradeCode  {606D211B-0E7E-4E98-9BF6-1A6BB10F5050}

-----------------------------------------
     1.5 Beta 2 SDK GUIDs
-----------------------------------------

 intelsdk.msi
	PackageCode    {8FC73003-88A0-4B41-82B8-8905D4AA904C}
	ProductCode    {8FC73003-88A0-4B41-82B8-8905D4AA904C}
	UpgradeCode    0

 msival2.msi (x86)
	PackageCode  {B399DEDD-D348-42D0-9F1A-2A91BF1ABA76}
	ProductCode  {E1EA0AF5-6522-459C-9C0F-A1362E1286F9}
	UpgradeCode  {AD2A58F2-E645-11D2-88C7-00A0C981B015}

 orca.msi (x86)
	PackageCode  {FC556C9A-4292-4469-9150-7EF90B81FE61}
	ProductCode  {6F7CB29D-1319-4816-B345-0856916EB801}
	UpgradeCode  {1AA03E10-2B19-11D2-B2EA-006097C99860}

 msival2.msi (ia64)
	PackageCode  {9F8F8E59-7A2B-4FD5-8057-7EEE069D9CA1}
	ProductCode  {546F90BF-A8F0-4FA4-853A-F6871CFEE41A}
	UpgradeCode  {105A6FFA-62E0-48B7-A02D-22E707DA24E3}

 orca.msi (ia64)
	PackageCode  {AE72B27A-C841-457D-A819-1125683BBA81}
	ProductCode  {E46A76C1-F46C-463E-983D-E4FC123383BF}
	UpgradeCode  {606D211B-0E7E-4E98-9BF6-1A6BB10F5050}

-----------------------------------------
     2.0 RC1 SDK GUIDs (decision made to make 1.5 a 2.0 version)
-----------------------------------------

 intelsdk.msi
	PackageCode    {8FC73004-88A0-4B41-82B8-8905D4AA904C}
	ProductCode    {8FC73004-88A0-4B41-82B8-8905D4AA904C}
	UpgradeCode    0

 msival2.msi (x86)
	PackageCode  {B399DEDE-D348-42D0-9F1A-2A91BF1ABA76}
	ProductCode  {E1EA0AF6-6522-459C-9C0F-A1362E1286F9}
	UpgradeCode  {AD2A58F2-E645-11D2-88C7-00A0C981B015}

 orca.msi (x86)
	PackageCode  {FC556C9B-4292-4469-9150-7EF90B81FE61}
	ProductCode  {6F7CB29E-1319-4816-B345-0856916EB801}
	UpgradeCode  {1AA03E10-2B19-11D2-B2EA-006097C99860}

 msival2.msi (ia64)
	PackageCode  {9F8F8E5A-7A2B-4FD5-8057-7EEE069D9CA1}
	ProductCode  {546F90C0-A8F0-4FA4-853A-F6871CFEE41A}
	UpgradeCode  {105A6FFA-62E0-48B7-A02D-22E707DA24E3}

 orca.msi (ia64)
	PackageCode  {AE72B27B-C841-457D-A819-1125683BBA81}
	ProductCode  {E46A76C2-F46C-463E-983D-E4FC123383BF}
	UpgradeCode  {606D211B-0E7E-4E98-9BF6-1A6BB10F5050}

-----------------------------------------
     2.0 RTM SDK GUIDs
-----------------------------------------

 intelsdk.msi
	PackageCode    {8FC73005-88A0-4B41-82B8-8905D4AA904C}
	ProductCode    {8FC73005-88A0-4B41-82B8-8905D4AA904C}
	UpgradeCode    0

 msival2.msi (x86)
	PackageCode  {B399DEDF-D348-42D0-9F1A-2A91BF1ABA76}
	ProductCode  {E1EA0AF7-6522-459C-9C0F-A1362E1286F9}
	UpgradeCode  {AD2A58F2-E645-11D2-88C7-00A0C981B015}

 orca.msi (x86)
	PackageCode  {FC556C9C-4292-4469-9150-7EF90B81FE61}
	ProductCode  {6F7CB29F-1319-4816-B345-0856916EB801}
	UpgradeCode  {1AA03E10-2B19-11D2-B2EA-006097C99860}

 msival2.msi (ia64)
	PackageCode  {9F8F8E5B-7A2B-4FD5-8057-7EEE069D9CA1}
	ProductCode  {546F90C1-A8F0-4FA4-853A-F6871CFEE41A}
	UpgradeCode  {105A6FFA-62E0-48B7-A02D-22E707DA24E3}

 orca.msi (ia64)
	PackageCode  {AE72B27C-C841-457D-A819-1125683BBA81}
	ProductCode  {E46A76C3-F46C-463E-983D-E4FC123383BF}
	UpgradeCode  {606D211B-0E7E-4E98-9BF6-1A6BB10F5050}

-----------------------------------------
     2.0 RTM SDK GUIDs	2003 Windows Server
-----------------------------------------

 intelsdk.msi
	PackageCode    {8FC73005-88A0-4B41-82B8-8905D4AA904C}
	ProductCode    {8FC73005-88A0-4B41-82B8-8905D4AA904C}
	UpgradeCode    0

 msival2.msi (x86)
	PackageCode  {7C779095-763D-462F-9FF9-4E8216C68C0F}
	ProductCode  {451DE7F5-B98D-487E-9F22-0B7AE4D9462E}
	UpgradeCode  {AD2A58F2-E645-11D2-88C7-00A0C981B015}

 orca.msi (x86)
	PackageCode  {0A68AF67-E966-40F1-958F-A3E2062DC78B}
	ProductCode  {63A68338-16A3-4763-8478-A45F91A61E7A}
	UpgradeCode  {1AA03E10-2B19-11D2-B2EA-006097C99860}

 msival2.msi (ia64)
	PackageCode  {3BFA1A8E-4170-495A-8E77-827547F5353F}
	ProductCode  {796E8603-51A3-4AD1-9390-6620358E0A4C}
	UpgradeCode  {105A6FFA-62E0-48B7-A02D-22E707DA24E3}

 orca.msi (ia64)
	PackageCode  {8B1D0371-5CCF-4CC5-B4D4-D0F89B4CF501}
	ProductCode  {C9FBE0DF-994D-4868-B4B8-9184ED7B5ADF}
	UpgradeCode  {606D211B-0E7E-4E98-9BF6-1A6BB10F5050}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\sdk\placefil.txt ===
# --------- DO NOT EDIT THIS FILE ------------ DO NOT EDIT THIS FILE ---------
# --------- DO NOT EDIT --- see layout.txt --- DO NOT EDIT -------------------
# --------- DO NOT EDIT THIS FILE ------------ DO NOT EDIT THIS FILE ---------
sdkmake.inc      retail
sdkpost.mak      retail
msisdk.msi      retail
ReadMe.txt      sdk
Redist.txt      sdk
License.rtf      sdk
INSTLR1.ADM      sdk\TOOLS
instlr11.adm      sdk\TOOLS
msi.h      sdk\INCLUDE
msiquery.h      sdk\INCLUDE
msidefs.h      sdk\INCLUDE
patchwiz.h      sdk\INCLUDE
patchapi.h      sdk\INCLUDE
Mergemod.h      sdk\INCLUDE
msi.lib      sdk\LIB
mspatchc.lib      sdk\LIB
msi.chm      sdk\HELP
msi.chi      sdk\HELP
msitool.mak      sdk\TOOLS
darice.cub      sdk\TOOLS\110
logo.cub      sdk\TOOLS\110
mergemod.cub      sdk\TOOLS\110
darice.cub1      1sdk\TOOLS\120
logo.cub1      1sdk\TOOLS\120
mergemod.cub1      1sdk\TOOLS\120
preadme.txt      sdk\PATCHING
makecab.exe      sdk\TOOLS
TEMPLATE.PCP      sdk\PATCHING
EXAMPLE.PCP      sdk\PATCHING
WiReadMe.txt      sdk\SAMPLES\SCRIPTS
WiCompon.vbs      sdk\SAMPLES\SCRIPTS
WiDialog.vbs      sdk\SAMPLES\SCRIPTS
WiDiffDb.vbs      sdk\SAMPLES\SCRIPTS
WiExport.vbs      sdk\SAMPLES\SCRIPTS
WiFilVer.vbs      sdk\SAMPLES\SCRIPTS
WiFeatur.vbs      sdk\SAMPLES\SCRIPTS
WiGenXfm.vbs      sdk\SAMPLES\SCRIPTS
WiImport.vbs      sdk\SAMPLES\SCRIPTS
WiLangId.vbs      sdk\SAMPLES\SCRIPTS
WiLstPrd.vbs      sdk\SAMPLES\SCRIPTS
WiLstScr.vbs      sdk\SAMPLES\SCRIPTS
WiLstXfm.vbs      sdk\SAMPLES\SCRIPTS
WiMakCab.vbs      sdk\SAMPLES\SCRIPTS
WiMerge.vbs      sdk\SAMPLES\SCRIPTS
WiPolicy.vbs      sdk\SAMPLES\SCRIPTS
WiRunSQL.vbs      sdk\SAMPLES\SCRIPTS
WiStream.vbs      sdk\SAMPLES\SCRIPTS
WiSubStg.vbs      sdk\SAMPLES\SCRIPTS
WiSumInf.vbs      sdk\SAMPLES\SCRIPTS
WiTextIn.vbs      sdk\SAMPLES\SCRIPTS
WiToAnsi.vbs      sdk\SAMPLES\SCRIPTS
WiUseXfm.vbs      sdk\SAMPLES\SCRIPTS
tutorial.cpp      sdk\SAMPLES\tutorial.dll
tutorial.rc      sdk\SAMPLES\tutorial.dll
tutorial.def      sdk\SAMPLES\tutorial.dll
makefile3      3sdk\SAMPLES\tutorial.dll
readme.txt3      3sdk\SAMPLES\tutorial.dll
process.cpp      sdk\SAMPLES\process.dll
process.rc      sdk\SAMPLES\process.dll
process.def      sdk\SAMPLES\process.dll
makefile4      4sdk\SAMPLES\process.dll
readme.txt4      4sdk\SAMPLES\process.dll
remove.cpp      sdk\SAMPLES\remove.dll
remove.rc      sdk\SAMPLES\remove.dll
remove.def      sdk\SAMPLES\remove.dll
makefile5      5sdk\SAMPLES\remove.dll
readme.txt5      5sdk\SAMPLES\remove.dll
create.cpp      sdk\SAMPLES\create.dll
create.rc      sdk\SAMPLES\create.dll
create.def      sdk\SAMPLES\create.dll
makefile6      6sdk\SAMPLES\create.dll
readme.txt6      6sdk\SAMPLES\create.dll
msiloc.cpp      sdk\SAMPLES\msiloc
msiloc.rc      sdk\SAMPLES\msiloc
Makefile7      7sdk\SAMPLES\msiloc
readme.txt7      7sdk\SAMPLES\msiloc
setup.cpp      sdk\SAMPLES\setup.exe
setupui.cpp      sdk\SAMPLES\setup.exe
upgrdmsi.cpp      sdk\SAMPLES\setup.exe
utils.cpp      sdk\SAMPLES\setup.exe
vertrust.cpp      sdk\SAMPLES\setup.exe
common.h      sdk\SAMPLES\setup.exe
resource.h      sdk\SAMPLES\setup.exe
setup.h      sdk\SAMPLES\setup.exe
setupui.h      sdk\SAMPLES\setup.exe
setup.rc      sdk\SAMPLES\setup.exe
setup.ico      sdk\SAMPLES\setup.exe
msistuff.cpp      sdk\SAMPLES\MsiStuff
msistuff.rc      sdk\SAMPLES\MsiStuff
Makefile1      1sdk\SAMPLES\setup.exe
ReadMe.htm1      1sdk\SAMPLES\setup.exe
Makefile2      2sdk\SAMPLES\MsiStuff
ReadMe.htm2      2sdk\SAMPLES\MsiStuff
dbreadme.txt      sdk\DATABASE
schema.msi      sdk\DATABASE
schema.msi1      1sdk\DATABASE\100
schema.msi2      2sdk\DATABASE\110
schema.msi3      3sdk\DATABASE\120
sequence.msi      sdk\DATABASE
sequence.msi1      1sdk\DATABASE\100
sequence.msi2      2sdk\DATABASE\110
sequence.msi3      3sdk\DATABASE\120
schema.msm      sdk\DATABASE
schema.msm1      1sdk\DATABASE\110
schema.msm2      2sdk\DATABASE\120
uisample.msi      sdk\DATABASE
error.ara      sdk\DATABASE\INTL
error.cat      sdk\DATABASE\INTL
error.chs      sdk\DATABASE\INTL
error.cht      sdk\DATABASE\INTL
error.csy      sdk\DATABASE\INTL
error.dan      sdk\DATABASE\INTL
error.deu      sdk\DATABASE\INTL
error.ell      sdk\DATABASE\INTL
error.enu      sdk\DATABASE\INTL
error.esn      sdk\DATABASE\INTL
Error.eti      sdk\DATABASE\INTL
error.euq      sdk\DATABASE\INTL
error.fin      sdk\DATABASE\INTL
error.fra      sdk\DATABASE\INTL
error.heb      sdk\DATABASE\INTL
error.hrv      sdk\DATABASE\INTL
error.hun      sdk\DATABASE\INTL
error.idt      sdk\DATABASE\INTL
error.ita      sdk\DATABASE\INTL
error.jpn      sdk\DATABASE\INTL
error.kor      sdk\DATABASE\INTL
Error.lth      sdk\DATABASE\INTL
Error.lvi      sdk\DATABASE\INTL
error.nld      sdk\DATABASE\INTL
error.nor      sdk\DATABASE\INTL
error.plk      sdk\DATABASE\INTL
error.ptb      sdk\DATABASE\INTL
error.ptg      sdk\DATABASE\INTL
error.rom      sdk\DATABASE\INTL
error.rus      sdk\DATABASE\INTL
error.sky      sdk\DATABASE\INTL
error.slv      sdk\DATABASE\INTL
error.sve      sdk\DATABASE\INTL
error.tha      sdk\DATABASE\INTL
error.trk      sdk\DATABASE\INTL
error.vit      sdk\DATABASE\INTL
actionte.ara      sdk\DATABASE\INTL
actionte.cat      sdk\DATABASE\INTL
actionte.chs      sdk\DATABASE\INTL
actionte.cht      sdk\DATABASE\INTL
actionte.csy      sdk\DATABASE\INTL
actionte.dan      sdk\DATABASE\INTL
actionte.deu      sdk\DATABASE\INTL
actionte.ell      sdk\DATABASE\INTL
actionte.enu      sdk\DATABASE\INTL
actionte.esn      sdk\DATABASE\INTL
ActionTe.eti      sdk\DATABASE\INTL
actionte.euq      sdk\DATABASE\INTL
actionte.fin      sdk\DATABASE\INTL
actionte.fra      sdk\DATABASE\INTL
actionte.heb      sdk\DATABASE\INTL
actionte.hrv      sdk\DATABASE\INTL
actionte.hun      sdk\DATABASE\INTL
actionte.idt      sdk\DATABASE\INTL
actionte.ita      sdk\DATABASE\INTL
actionte.jpn      sdk\DATABASE\INTL
actionte.kor      sdk\DATABASE\INTL
ActionTe.lth      sdk\DATABASE\INTL
ActionTe.lvi      sdk\DATABASE\INTL
actionte.nld      sdk\DATABASE\INTL
actionte.nor      sdk\DATABASE\INTL
actionte.plk      sdk\DATABASE\INTL
actionte.ptb      sdk\DATABASE\INTL
actionte.ptg      sdk\DATABASE\INTL
actionte.rom      sdk\DATABASE\INTL
actionte.rus      sdk\DATABASE\INTL
actionte.sky      sdk\DATABASE\INTL
actionte.slv      sdk\DATABASE\INTL
actionte.sve      sdk\DATABASE\INTL
actionte.tha      sdk\DATABASE\INTL
actionte.trk      sdk\DATABASE\INTL
actionte.vit      sdk\DATABASE\INTL
schema.log      sdk\DATABASE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\secured\none\none.txt ===
[TEXT: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\secured\admin\rw.txt ===
Read, Write
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\simple.idt\simple.txt ===
This is the simple file.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\cmpanion.txt ===
Hi!  I'm a companion file of my parent file, TestDB.exe.  If my parent is installed, I must be installed too).  Thanks for your concern!
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\secured\user\rw.txt ===
Read, Write
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\secured\admin\rwx.txt ===
Read, Write, Execute
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\secured\user\rwx.txt ===
Read, Write, Execute
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\secured\mixed\rw.txt ===
Read, Write
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\simple\simple.txt ===
This is the simple file.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\secured\mixed\rwx.txt ===
Read, Write, Execute
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\secured\other\rwx.txt ===
Read, Write, Execute
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\secured\other\rw.txt ===
Read, Write
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\tools\win95\system.txt ===
I should only be installed on Windows 95.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\tools\tools.txt ===
You are going to really like these tools.  They will let you do a bunch of wonderful things, such as type text, and have it appear right on your screen!  Soon, you will be able to even erase a word, and replace it with another.  In a future version, we even hope to be able to allow you to print out your excellent text on paper!
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\tools\toolhelp.txt ===
OK, this file is supposed to supply a lot of help concerning the use of all our tools.  As soon as I figure out how to use a hammer and chisel, I'll let you know where this fits into the stream of thought that normally results in concrete action.  Until then, hang tight.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\test\tools\winnt\system.txt ===
I should only be installed on Windows NT.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\help\conman.rtf ===
{\rtf1\ansi {\fonttbl{\f0\fswiss Helv;}{\f1\fmodern Courier New;}} {\colortbl;} \fs20 #{\footnote MsiConfigurationManager_Object} ${\footnote MsiConfigurationManager Object} K{\footnote MsiConfigurationManager} +{\footnote Class:MsiConfigurationManager} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MsiConfigurationManager Object \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The MsiConfigurationManager object provides the MsiEngine access to configuraion data. The Configuration Manager performs the follows tasks:\par \line 1. Manages product information and databases. \line 2. Manages registry backward compatibility. \line 3. Manages shared components and their clients. \line 4. Provides a facility for locating a file that supports a particular  component. \line 5. Manages volumes. \par\li0{\b Properties}\par\li180 {\uldb Services}{\v MsiConfigurationManager_Services}\line \par\li0{\b Methods}\par\li180 {\uldb RunScript}{\v MsiConfigurationManager_RunScript}\line \line {\uldb RegisterRollbackScript}{\v MsiConfigurationManager_RegisterRollbackScript}\line {\uldb UnregisterRollbackScript}{\v MsiConfigurationManager_UnregisterRollbackScript}\line {\uldb RollbackScripts}{\v MsiConfigurationManager_RollbackScripts}\line \line {\uldb RegisterProduct}{\v MsiConfigurationManager_RegisterProduct}\line {\uldb RegisterUser}{\v MsiConfigurationManager_RegisterUser}\line {\uldb UnregisterProduct}{\v MsiConfigurationManager_UnregisterProduct}\line \line {\uldb RegisterComponent}{\v MsiConfigurationManager_RegisterComponent}\line {\uldb UnregisterComponent}{\v MsiConfigurationManager_UnregisterComponent}\line \line {\uldb RegisterFolder}{\v MsiConfigurationManager_RegisterFolder}\line {\uldb IsFolderRemovable}{\v MsiConfigurationManager_IsFolderRemovable}\line {\uldb UnregisterFolder}{\v MsiConfigurationManager_UnregisterFolder}\line \line {\uldb DoInstall}{\v MsiConfigurationManager_DoInstall}\line \line {\uldb LockServer}{\v MsiConfigurationManager_LockServer}\line {\uldb UnlockServer}{\v MsiConfigurationManager_UnlockServer}\line {\uldb InstallFinalize}{\v MsiConfigurationManager_InstallFinalize}\line {\uldb SetLastUsedSource}{\v MsiConfigurationManager_SetLastUsedSource}\line \line \page #{\footnote MsiConfigurationManager_Services} ${\footnote MsiConfigurationManager.Services} +{\footnote MsiConfigurationManager:Services} K{\footnote SERVICES} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Services Property \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The MsiServices object used by the Configuration Manager. Read-only. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Services} \par{\i object}\line Required. The MsiConfigurationManager object. \page #{\footnote MsiConfigurationManager_ProductDatabasePath} ${\footnote MsiConfigurationManager.ProductDatabasePath} +{\footnote MsiConfigurationManager:ProductDatabasePath} K{\footnote ProductDatabasePath} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b} This method is undocumented. \page #{\footnote MsiConfigurationManager_RunScript} ${\footnote MsiConfigurationManager.RunScript} +{\footnote MsiConfigurationManager:RunScript} K{\footnote RunScript} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b RunScript Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Runs an installation script. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .RunScript({\i scriptFile, userToken, message})} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i\b scriptfile}\line Required. The full path (string) to an installation script file. \par{\i\b userToken}\line Required. Handle to the user to impersonate while executing the script. Pass 0 for no user impersonation. \par{\i\b message}\line Required. Any object supporting the {\uldb MsiMessage}{\v MsiMessage_Object}  interface. Installation progress will be reported via this object. \par\fi0\li0{\b Remarks}\par\li180 {\uldb Scriptfile format}{\v Server_ScriptFormat} \page #{\footnote MsiConfigurationManager_InstallFinalize} ${\footnote MsiConfigurationManager.InstallFinalize} +{\footnote MsiConfigurationManager:InstallFinalize} K{\footnote InstallFinalize} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b InstallFinalize Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Rolls back the system to the given date, or purges the system of  backup files created before the given date. See   {\uldb MsiExecute.RollbackFinalize}{\MsiExecute_RollbackFinalize} for more info. Also removes in-progress information for the install if the install was successful or if the install  was rolled back. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .InstallFinalize({\i state, rollback, userToken, message})} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i\b state}\line Required. The return status of the last executed action. This value is used to determine  whether to roll back the system or to purge backup files. This value is an enumeration  iesEnum, as described in the {\uldb DoAction}{\v MsiEngine_DoAction} method.   \par{\i\b rollback}\line Required. True to rollback the install if {\i\b state} indicates failure or cancellation. \par{\i\b userToken}\line Required. Handle to the user to impersonate while rolling back. Pass 0 for no user impersonation. \par{\i\b message}\line Required. Any object supporting the {\uldb MsiMessage}{\v MsiMessage_Object}  interface. Rollback progress will be reported via this object. \page #{\footnote MsiConfigurationManager_LockServer} ${\footnote MsiConfigurationManager.LockServer} +{\footnote MsiConfigurationManager:LockServer} K{\footnote LockServer} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b LockServer Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .LockServer({\i})} \par{\i object}\line Required. The MsiConfigurationManager object. \page #{\footnote MsiConfigurationManager_UnlockServer} ${\footnote MsiConfigurationManager.UnlockServer} +{\footnote MsiConfigurationManager:UnlockServer} K{\footnote UnlockServer} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b UnlockServer Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .UnlockServer({\i})} \par{\i object}\line Required. The MsiConfigurationManager object. \page #{\footnote MsiConfigurationManager_SetLastUsedSource} ${\footnote MsiConfigurationManager.SetLastUsedSource} +{\footnote MsiConfigurationManager:SetLastUsedSource} K{\footnote SetLastUsedSource} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b SetLastUsedSource Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Sets the last used source for a product, optionally adding it to the product's source list. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .SetLastUsedSource({\i strProductCode, strSource, fAddToList})} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i\b strProductCode}\line Required. The product code for the product whose source is being updated. \par{\i\b strPath}\line Required. The source to be added, in the form of a path (e.g. D:\\X\\Y, \\\\foo\\bar\\x\\y) (string) \par{\i\b fAddToList}\line Required. If true then the source is added to the list if it's not already there. (see Remarks for restrictions) \par\fi0\li0{\b Remarks}\par\li180 SetLastUsedSource only adds new sources if the following criteria are met:\line 1) The user is either an Admin or has the EnableBrowse policy value set to 1\line 2) The source is of a type allowed by the SearchOrder policy\line \page #{\footnote MsiConfigurationManager_RegisterRollbackScript} ${\footnote MsiConfigurationManager.RegisterRollbackScript} +{\footnote MsiConfigurationManager:RegisterRollbackScript} K{\footnote RegisterRollbackScript} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b RegisterRollbackScript Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Registers a rollback script with the configuration manager. The date and   time of the registration is saved along with the script file path. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .RegisterRollbackScript({\i scriptFile})} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i\b scriptfile}\line Required. The full path (string) to a rollback script file. \par\fi0\li0{\b Remarks}\par\li180 Registration of a scriptfile that is already registered will overwrite the old  registration. \page #{\footnote MsiConfigurationManager_UnregisterRollbackScript} ${\footnote MsiConfigurationManager.UnregisterRollbackScript} +{\footnote MsiConfigurationManager:UnregisterRollbackScript} K{\footnote UnregisterRollbackScript} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b UnregisterRollbackScript Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Unregisters a rollback script with the configuration manager. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .UnregisterRollbackScript({\i scriptFile})} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i\b scriptfile}\line Required. The full path (string) to a rollback script file. \par\fi0\li0{\b Remarks}\par\li180 Unregistration of a scriptfile that is not already registered will cause  no action to be taken. \page #{\footnote MsiConfigurationManager_RollbackScripts} ${\footnote MsiConfigurationManager.RollbackScripts} +{\footnote MsiConfigurationManager:RollbackScripts} K{\footnote RollbackScripts} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b RollbackScripts Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns an collection of strings that each contain the date that the rollback  script was generated and the name of the rollback script. The collection is restricted to the set of scripts that meet the specifed date restriction. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .RollbackScripts({\i date, after})} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i\b date}\line Required. The date that, along with {\b after}, specifies  which rollback scripts should be in the collection. \par{\i\b after}\line Required. If {\b after} is true then the collection will contain all rollback   scripts registered on or after {\b date}. If {\b after} is false then the  collection will contain all rollback scripts registered on or before {\b date}. \par\fi0\li0{\b Remarks}\par\li180 The strings in the collection are of the following form:\line \tab MsiDate#scriptfilePath, e.g. "3043#C:\\windows\\aim\\rb5365.scr" \page #{\footnote MsiConfigurationManager_RegisterProduct} ${\footnote MsiConfigurationManager.RegisterProduct} +{\footnote MsiConfigurationManager:RegisterProduct} K{\footnote RegisterProduct} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b RegisterProduct Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Registers a product with the Configuration Manager. This supplements the product  information that was advertised. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .RegisterProduct({\i productInfo})} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i\b productInfo}\line Required. A record containing the product information. See the Remarks section  for the record's details. \par\fi0\li0{\b Remarks}\par\li180 The record returned contains the following fields:\par \tab {\f1\i Field Number        }  {\i Field Contents}\line \tab {\f1 icmrpfProductKey         -} product code\line \tab {\f1 icmrpfDisplayName        -} ProductName property\line \tab {\f1 icmrpfVersionString      -} ProductVersion property\line \tab {\f1 icmrpfVersionMajorString -} From ProductVersion property\line \tab {\f1 icmrpfVersionMinorString -} From ProductVersion property\line \tab {\f1 icmrpfHelpLink           -} From SupportURL property\line \tab {\f1 icmrpfHelpTelephone      -} From SupportPhone property\line \tab {\f1 icmrpfInstallLocation    -} TBD -- Currently TARGETDIR property\line \tab {\f1 icmrpfInstallSource      -} TBD -- Currently SOURCEDIR property\line \tab {\f1 icmrpfInstallDate        -} String form of install date\line \tab {\f1 icmrpfPublisher          -} Manufacturer property\line \tab {\f1 icmrpfLocalPackage       -} cached database location\line \tab {\f1 icmrpfURLInfoAbout       -} SupportURL property\line \tab {\f1 icmrpfURLUpdateInfo      -} TBD\line \tab {\f1 icmrpfUninstallString    -} TBD\line \tab {\f1 icmrpfModifyString       -} msiexec /c {ProductCode} /qf\line \tab {\f1 icmrpfUninstallPath      -} msiexec /t {ProductCode} /qb\line \page #{\footnote MsiConfigurationManager_RegisterUser} ${\footnote MsiConfigurationManager.RegisterUser} +{\footnote MsiConfigurationManager:RegisterUser} K{\footnote RegisterUser} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b RegisterUser Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Registers user information for a registered product. This is separate from  RegisterProduct to allow the collection of user information to be deferred  until first-run, if desired. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .RegisterUser({\i productKey, userInfo})} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i\b productKey}\line Required. The productKey for the product with which the user info is to be  associated \par{\i\b userInfo}\line Required. A record containing the user information. See the Remarks section  for the record's details. \par\fi0\li0{\b Remarks}\par\li180 The record returned contains the following fields:\par \tab {\f1\i Field Number    }  {\i Field Contents}\line \tab {\f1 icmrufOwner      -}  User name from UI or registry\line \tab {\f1 icmrufCompany    -}  Organization name from UI or registry\line \tab {\f1 icmrufProductId  -}  Generated PID, 23 characters including 3 dashes\line \page #{\footnote MsiConfigurationManager_RegisterComponent} ${\footnote MsiConfigurationManager.RegisterComponent} +{\footnote MsiConfigurationManager:RegisterComponent} K{\footnote RegisterComponent} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b RegisterComponent Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Registers an component.  \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .RegisterComponent({\i componentCode, keyPath,  supersededComponents})} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i\b componentCode}\line Required. The GUID that represents the component. \par{\i\b keyPath}\line The path to the key file, registry key, or folder for this component. \par{\i\b supersededComponents}\line Optional. An MsiRecord containing the componentIds of components that are  superseded by this component. \page #{\footnote MsiConfigurationManager_UnregisterComponent} ${\footnote MsiConfigurationManager.UnregisterComponent} +{\footnote MsiConfigurationManager:UnregisterComponent} K{\footnote UnregisterComponent} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b UnregisterComponent Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Unregisters a component. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .UnregisterComponent({\i productKey, componentCode})} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i\b componentCode}\line Required. The GUID that represents the component. \page #{\footnote MsiComponentManager_Object} ${\footnote MsiComponentManager Object} K{\footnote MsiComponentManager} +{\footnote Class:MsiComponentManager} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MsiComponentManager Object \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The Component Manager performs the follows tasks:\par \line 1. Supports run-time run-time installation and uninstallation of components \line 2. Allows an application's components to be dynamically located at run-time,  based on currently available components. \page #{\footnote MsiConfigurationManager_RegisterFolder} ${\footnote MsiConfigurationManager.RegisterFolder} +{\footnote MsiConfigurationManager:RegisterFolder} K{\footnote RegisterFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b RegisterFolder Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Registers a folder with the Configuration Manager. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .RegisterFolder({\i path, fExplicitCreation})} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i\b path}\line Required. A path object pointing to the folder to be registered. \par{\i\b component}\line Required. A bool indicating whether the component was explicitly created. \par\fi0\li0{\b Remarks}\par\li180 \page #{\footnote MsiConfigurationManager_IsFolderRemovable} ${\footnote MsiConfigurationManager.IsFolderRemovable} +{\footnote MsiConfigurationManager:IsFolderRemovable} K{\footnote IsFolderRemovable} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b IsFolderRemovable Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Registers a folder with the Configuration Manager. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .IsFolderRemovable({\i path, fExplicit})} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i\b path}\line Required. A path object pointing to the folder to be registered. \par{\i\b amComponent}\line Required. Required. A bool indicating whether the component was explicitly created. \par\fi0\li0{\b Remarks}\par\li180 \page #{\footnote MsiConfigurationManager_UnregisterFolder} ${\footnote MsiConfigurationManager.UnregisterFolder} +{\footnote MsiConfigurationManager:UnregisterFolder} K{\footnote UnregisterFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b UnregisterFolder Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Unregisters a folder with the Configuration Manager. Nothing is done if  the folder wasn't registered. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .UnregisterFolder({\i path})} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i\b path}\line Required. A path object pointing to the folder to be unregistered. \par\fi0\li0{\b Remarks}\par\li180 \page #{\footnote MsiConfigurationManager_UnregisterProduct} ${\footnote MsiConfigurationManager.UnregisterProduct} +{\footnote MsiConfigurationManager:UnregisterProduct} K{\footnote UnregisterProduct} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b UnregisterProduct Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Unregisters a product with the Configuration Manager. Removes all references  to the product from the Configuration Database, but only if no client products remain.  Returns a boolean indicating whether any additional clients remain. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .UnregisterProduct({\i productKey, parentKey})} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i\b productKey}\line Required. The product key identifying the product to be unregistered. \par{\i\b parentKey}\line Optional. Only if a nested install: the product key of parent product. \par\fi0\li0{\b Remarks}\par\li180 A non-nested install is considered as having the user as a client, such that when  a parent product installs it again as a child, it will be held by two clients,  and not released until both the parent and the standalone (via Add/Remove or API) goes away. \page #{\footnote MsiConfigurationManager_DoInstall} ${\footnote MsiConfigurationManager.DoInstall} +{\footnote MsiConfigurationManager:DoInstall} K{\footnote DoInstall} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b DoInstall Method \line\tx360\tab\fs18\b0{\uldb MsiConfigurationManager Object}{\v MsiConfigurationManager_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Runs an install. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .DoInstall()} \par{\i object}\line Required. The MsiConfigurationManager object. \par{\i product}\line Required. Product code or path to database . \par{\i action}\line Optional. The action to run \par{\i object}\line Optional. Property=Value string. \par{\i object}\line Required. Message object for UI callback. \par\fi0\li0{\b Remarks}\par\li180 \page
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\help\author.rtf ===
{\rtf1\ansi {\fonttbl{\f0\fswiss Arial;}{\f1\fmodern Courier New;}} {\colortbl;} \fs20 #{\footnote Authoring_TargetDirValidation} ${\footnote TargetDirValidation} +{\footnote TargetDirValidation} K{\footnote Validation of Target Directories;_BrowseProperty;BrowseDialog} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Validation of Target Directories \par}\li180 As a part of the {\uldb CostFinalize}{\v _msi_Action_CostFinalize@msi.hlp} action, all target directories (as authored in  the {\uldb Directory}{\v _msi_Directory_Table@msi.hlp} table) are validated to ensure that each represents a writable  location. If there is any target directory for which the Installer does not have write-access, a  substitute location must be selected by the user if the install is to continue.  If the author wishes to  accommodate this (highly recommended), do the following:  \par 1) Author a {\uldb Browse}{\v SpecialDialog_Browse} dialog (a special dialog type that allows the user  to specify a directory location).  The name of this dialog must be "{\b BrowseDialog}" (i.e. this name must be  specified in the "Dialog" column of the {\uldb Dialog}{\v _msi_Dialog_Table@msi.hlp} table). 2) The name of the directory property that is to be modified by this Browse dialog must be  "{\b _BrowseProperty}" (see the {\uldb Browse}{\v SpecialDialog_Browse} dialog topic to determine how to  author this property name). If an unwritable target directory is located during the above-mentioned validation, AND a Browse dialog  as specified above is available, the {\uldb CostFinalize}{\v _msi_Action_CostFinalize@msi.hlp} action will display  that dialog, prompting the user to select an alternate location for the directory.  However, also note  that only those directories that are authored as "configurable" (i.e. that directory's property name  is specified in the "Directory_" column of any row in the {\uldb Feature}{\v _msi_Feature_Table@msi.hlp}  table) can result in a Browse dialog.  If any unwritable directory is non-configurable, an error will  eventually result if and when the Installer attempts to write a file to that directory. \page #{\footnote Authoring_FeatureConfiguration} ${\footnote FeatureConfiguration} +{\footnote FeatureConfiguration} K{\footnote Reinstalling features;Removing Features} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Reinstalling and Removing Installed Features \par}\li180 There are several ways of reinstalling and removing features once they have been installed.  A reinstall  might be required if any files or registry entries associated with any feature have become corrupted or  are missing for any reason.  And of course at any time, the user might want or need to remove a particular  feature, or the whole product.\line \par\fi0\li0{\b Reinstalling Features}\par\li180 Once an installation for a particular product has been performed once (with some or all of the  product's features installed), one way to perform a reinstallation is to specify the  {\uldb REINSTALL}{\v Property_REINSTALL} and {\uldb REINSTALLMODE}{\v Property_REINSTALLMODE} properties  on the command line.  These properties allow the user to reinstall any or all of the product's features.  In  addition, the 'type' of reinstallation can be specified; for instance, you could specify that only those files  that are totally missing should be reinstalled, or that only corrupted files (i.e. any executable file whose  checksum doesn't match the actual file contents) be replaced.  Alternatively, you could specify that the  fitness of the current install be only verified, without actually repairing any broken or missing files/registry  entries.  In this case, for all installed features, the Installer would report (typically in a log file) the  results of any verification that you specify, such as whether there are any missing or corrupt files,   any files of the wrong version, or any missing or incorrect registry entries.  At any later time, you could then  run the install again to repair any or all of the detected problems.  \par  A reinstall can also authored to be performed via the Installer user interface, at the click of a button.  To add  a "Reinstall" button to any dialog, follow these steps:\line  \line 1) Add a pushbutton to the desired dialog by adding an entry to the {\uldb Control}{\v _msi_Control_Table@msi.hlp} table.\line 2) Add a "ReinstallMode" event to the ControlEvent table, with the "Dialog_" and "Control_" fields referencing  the pushbutton control you created in step 1.  In the "Argument" field, enter a string containing the letters  corresponding to the reinstall mode(s) you want (the acceptable values for this field are identical to those  accepted for the {\uldb REINSTALLMODE}{\v Property_REINSTALLMODE} property).  The value in the "Ordering" column  for this event should be "1".\line 3) Add a "Reinstall" event to the ControlEvent table, again referencing the same pushbutton control.  The   "Argument" field for this event will normally be "ALL", to force the reinstall of all features, but you  could place the name of a specific feature here.  The value in the "Ordering" column for this event should be  "2".\line 4) Finally, add one more event tied to the same pushbutton control, to actually initiate the reinstallation.  This could be an "EndDialog" dialog event (with an argument of "Return"), but more typically a "NewDialog"  event would be used here, to jump to an "Are you sure you want to reinstall?" confirmation dialog.  The value  in the "Ordering" column for this event should be "3".\line \line If desired, several "Reinstall" buttons can be provided on one dialog, to give the user the option of selecting  the type of reinstall to perform.  In this case, each button would be authored as outlined in the above steps, with  only the argument provided for the "ReinstallMode" control event being different for each button. \par\fi0\li0{\b Removing Features}\par\li180 To remove any or all features, you can specify the {\uldb REMOVE}{\v Property_REMOVE} property on the command line.  Alternatively, as with a reinstall, a removal of the entire product can be authored to be performed via the Installer  user interface, with one button.  To add a "Remove All" button to any dialog, follow these steps:\line \line 1) Add a pushbutton to the desired dialog by adding an entry to the {\uldb Control}{\v _msi_Control_Table@msi.hlp} table.\line 2) Add a "Remove" event to the ControlEvent table, with the "Dialog_" and "Control_" fields referencing  the pushbutton control you created in step 1.  The "Argument" field for this event will normally be "ALL", to force  the removal of all features, although could place the name of a specific feature here.  The value in the "Ordering"  column for this event should be "1".\line 4) Add another event tied to the same pushbutton control, to actually initiate the removal.  This could be an "EndDialog" dialog event (with an argument of "Return"), but more typically a "NewDialog"  event would be used here, to jump to an "Are you sure you want to remove the entire product?" confirmation dialog.   The value in the "Ordering" column for this event should be "2".\line \page #{\footnote Authoring_Advertisement} ${\footnote Advertisement} +{\footnote Authoring:Advertisement} K{\footnote Advertisement} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Darwin Advertisement \par}\li180 Advertisement is the mechanism in Darwin whereby information about the product and discretely installable features of  the product are provided to the system, without actually installing the features. Advertisement in Darwin is initiated by the  {\uldb ADVERTISE}{\v _msi_Action_ADVERTISE@msi.hlp} action. \par  The information regarding the feature is provided by specifying a {\b Darwin Descriptor}. The Darwin Descriptor holds  product, feature and the {\b Key Component} information that is used for installing the components that are required.  The key component is the component of the feature whose {\b KeyPath} (see {\uldb Component}{\v _msi_Component_Table@msi.hlp} )  is the entry into using the feature. The following information is advertised by Darwin: 1. The feature to components mapping.\line This is the information that enumerates the individual  components of a feature of a product. Whenever a feature is requested to be made available by the application or the system using    the Installer API, the system ensures that all the components composing the feature are installed.\line Registry structure for the information -\line Tables queried - {\uldb FeatureComponents}{\v _msi_FeatureComponents_Table@msi.hlp} 2. Any component that needs to be available for use across processes via the MsiProvideComponentIndirect API.\line Tables queried - {\uldb PublishComponent}{\v _msi_PublishComponent_table@msi.hlp} 3. COM Servers.\line This is the information regarding COM servers. The system faults in a COM server on request using the darwin descriptor that represents the  COM server.\line\line Registry structure for the information -\line HKCR\\CLSID\\<Class.Context> default=<Class.Description> (created if Class.Description not null)\line HKCR\\CLSID\\<Class.Context> <Class.Context>=<darwindescriptor for Class.Feature_, Class.Component_>\line HKCR\\CLSID\\<Class.Context>\\ProgID default=<Class.ProgId> (created if Class.ProgId not null)\line HKCR\\<Class.ProgId> default=<Class.Description> (created if Class.ProgId not null)\line  HKCR\\CLSID\\<Class.Context>\\Insertable default="" (created if Class.Insertable not null)\line HKCR\\CLSID\\<Class.Context>\\InprocHandler32 default=<server-name> (depends on Class.DefInprocHandler).\line HKCR\\CLSID\\<Class.Context>\\DefaultIcon default=<full path to Class.Icon > (created if Class.Icon_ not null).\line HKCR\\FileType\\<Class.Context>\\1 default=type mask 1\line HKCR\\FileType\\<Class.Context>\\2 default=type mask 2\line HKCR\\FileType\\<Class.Context>\\3 default=type mask 2\line ...\line ...\line ...\line when Class.FileTypeMask is a non null ";" delimited list of type masks.\line Tables queried - {\uldb Class}{\v _msi_Class_Table@msi.hlp}\ 4. COM Type Libraries.\line This is the information regarding COM type libraries. This is used by the system to allow the user to browse  installable type libraries. The system faults in a COM type library on request using the darwin descriptor  that represents the COM type library.\line Registry structure for the information -\line HKCR\\TypeLib\\<TypeLib.LibID>\\<TypeLib.Version> default=TypeLib.Description\line HKCR\\TypeLib\\<TypeLib.LibID>\\<TypeLib.Version>\\<Locale ID from TypeLib.Language>\\win32 win32=<darwindescriptor for TypeLib.Feature_, TypeLib.Component_>\line Tables queried - {\uldb TypeLib}{\v _msi_TypeLib_Table@msi.hlp} 5. Extension servers.\line This is the information regarding extension servers. This is used by the system to default in servers using the darwin descriptor  for opening/editing/printing documents by file extension.\line Registry structure for the information -\line HKCR\\<Extension.Extension>\\<Extension.ProgId> default = ""\line HKCR\\<Extension.Extension>\\<Extension.ProgId>\\ShellNew <Extension.ShellNew>=<Extension.ShellNewValue>\line HKCR\\<Extension.ProgId>\\shell\\<Verb.Verb> default=<Verb.Command>\line HKCR\\<Extension.ProgId>\\shell\\<Verb.Verb>\\command command=<darwindescriptor for Extension.Feature_, Extension.Component_> <Verb.Arguments>\line when Extension.ProgId not null - else\line HKCR\\<Extension.Extension> default = ""\line HKCR\\<Extension.Extension>\\ShellNew <Extension.ShellNew>=<Extension.ShellNewValue>\line HKCR\\<Extension.Extension>\\shell\\<Verb.Verb> default=<Verb.Command>\line HKCR\\<Extension.Extension>\\shell\\<Verb.Verb>\\command command=<darwindescriptor for Extension.Feature_, Extension.Component_> <Verb.Arguments>\line Tables queried - {\uldb Extension}{\v _msi_Extension_Table@msi.hlp}, {\uldb Verb}{\v _msi_Verb_Table@msi.hlp} 6. MIME information.\line This is the MIME information placed in the registry.\line Registry structure for the information -\line HKCR\\MIME\\Database\\Content Type\\<MIME.ContentType> default=""\line HKCR\\MIME\\Database\\Content Type\\<MIME.ContentType> Extension=<MIME.Extension>\line HKCR\\MIME\\Database\\Content Type\\<MIME.ContentType> CLSID=<MIME.CLSID> (if MIME.CLSID is not null)\line HKCR\\Extension Content Type=<MIME.ContentType>\line Tables queried - {\uldb MIME}{\v _msi_MIME_Table@msi.hlp} 7. Shortcuts under Shell Folders.\line Darwin creates shortcuts under Shell Folders, containing the darwin descriptor that represents the application.  The system installs the application referred to by the darwin descriptor when the user clicks on the shortcut. Tables queried - {\uldb Shortcut}{\v _msi_Shortcut_Table@msi.hlp}\line NOTE: This is the only advertisement entity that needs to be created only if there is GPT support on the system. (Else we do not advertise  and use the filename in place of the Darwin Descriptor at installation time).Currently we determine "GPTSupport" by detecting the presence of  the HKCR\\GPTSupport key. 8. Icons under the {\b <userprofile directory>\Applications} folder for the shortcuts and the COM servers that are advertised.\line Tables queried - {\uldb Icon}{\v _msi_Icon_Table@msi.hlp}\line Explicit advertisement occurs on a system when - \line 1. The installer is activated with the ACTION property set to ADVERTISE.\line 2. Through the MsiAdvertiseProduct API with the scriptfile argument set to null.\line 3. Through the MsiAdvertiseScript or the MsiProcessAdvertiseScript API with the scriptfile argument set to to script file generated by  the MsiAdvertiseProduct API. NOTE:Since these APIs return the key file of the component referred to in the Darwin Descriptor, any file that  is  pointed to by a shortcut, or is a COM server, an extension server, or a type library is to be the key file  of a component. In other words no two such files can share the same component. Darwin removes any advertised information for a feature during the uninstall of the feature. This implies that the  feature then cannot be faulted in by the system. However on a ZAW enabled client this is pushed back onto the  client via the advertise script.\line \page #{\footnote Authoring_Components} ${\footnote Components} +{\footnote Authoring:Components} K{\footnote Components} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Darwin Components \par}\li180 A Darwin component is a set of files, shorcuts, .ini entries, registry entries and other installable entities  and associated Darwin actions to be performed on the installation/ uninstallation of the set. A Darwin  component has a globally unique id, Component.ComponentId (see {\uldb Component}{\v _msi_Component_Table@msi.hlp} table).  Two components (from two different products) may have the same ComponentId only if they have the same set of files  and other installable entities with the same set of associated Darwin actions to be performed on the  installation/ uninstallation of the set. Using the same ComponentId implies that the products share the component  as regards installation, uninstallation and application usage. The objective here is to use a single install that  is shared by more than one product. The abovementioned restrictions ensure that a component installed by one product  can be shared by another product and uninstalled, if it is the last client of that component. The file versions  between different installs of the same product may be different. In this case the file copy logic will kick in when  installing a component over an existing installation. Also a component is associated with one and only one  directory. i.e. all the files of a component go to the same folder. Each component has a {\b KeyPath} (see {\uldb Component}{\v _msi_Component_Table@msi.hlp} table) associated with it. This is the  file or folder that represents the component. The KeyPath serves two purposes. First, it is used to determine the  presence of the component in the MSI APIs. If it is a folder it is also used as the key file for the component.  This is what is passed back to the user in the MsiLocateComponent, MsiLocateLanguageComponent, MsiProvideComponent,  MsiProvideComponentFromDescriptor, and MsiProvideComponentIndirect MSI APIs. {\b Management of Components } \line Here are the set of rules that govern the management of components by Darwin:\line 1. Each installed component has a key path registered with it. The component is in the installed state if it  is registered with the configuration manager and its key path exists (the configuration manager physically checks  for the existence of the file/ folder that is the key path). \line 2. Each installed component has a set of clients registered with it. These are the products that wished the  component to be installed. Additionally we associate the state (local/ source) that the client wished the state  to the component to be.\line 3. A component can be installed only at one location on the system. This restriction is because products today  register hard coded path references to the component in the registry, shortcuts, etc.\line 4. If a product is not as yet a client of the component and wishes to install the component locally we always  install (there is no existing install, there is an existing source install, there is an existing local install).  If there is a local install we set the directory of install to be the same as the existing local install.\line 5. If a product is not as yet a client of the component and wishes to install the component as run from source  we install only if there is no valid local install. In this case we always install (there is no existing  install, there is an existing source install, there is an existing local install). If there is a local install  we set the directory of install to be the same as the existing local install.\line 6. A local installation is uninstalled when the last local client wishes it to be uninstalled. This will leave  the component in an invalid state for any clients that wished the component as run from source.\line 7. If a product is a client of the component and the installation is not valid we (silently) reinstall the  component in the desired state when Darwin runs (either explicitely during maintenance or implicitely through  the APIs) in the context of that product. {\b Component Redirection} \line Components can register that the configuration manager redirect requests for one or more other component to  them. This is done by use of the {\uldb RedirectComponent}{\v _msi_RedirectComponent_Table@msi.hlp} table. All requests  for the older component(s) through the MSI API will be redirected to the newer component. However the clients  of the older components cannot prevent the newer component from going away when its last client uninstalls it.   When this happens the older redirected component appear "broken" and are reinstalled as per rule 7. above. {\b Component Publishing and Qualified Components} \line Products can publish "component factories" by advertising the Darwin Descriptors for installing components.  This is done by using the {\uldb PublishComponent}{\v _msi_PublishComponent_table@msi.hlp} table  (see {\uldb Advertisement}{\v Authoring_Advertisement}). Products can use the MsiProvideComponentIndirect  API to get these components. Also there may be another level of heirarchy (further qualification) between the GUID and the Darwin Descriptor. This is the {\bQualifier} to be used with a generic GUID to get a specific Darwin Descriptors. \page #{\footnote Authoring_ProofingTools} ${\footnote ProofingTools} +{\footnote Authoring:ProofingTools} K{\footnote ProofingTools} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Managing proofing tools using Darwin \par}\li180 Proofing tools is a term applied to a set of tools such as the speller and the thesaurus which can be characterised  as having a pair of files that serve the task. The first file is the {\b lex} file. It is the data file for the tool.  The second file is the {\b engine} file which provides the tool function and is driven by the lex file. Proofing tools  are catagorised by their function, sub-type and language (example - a dictionary of the sub-type medical and language english).\line Darwin manages proofing tools by use of the Qualified Components mechanism (see {\uldb Darwin Components}{\v Authoring_Components}).  Each (type of) proofing tool is associated with a universally recognised GUID. So Spelling will have its own GUID separate from  the thesaurus. All the speller lex files will hang off this GUID. The proofing tools subtype and language will form the {\b Qualifier}.  Thus the Qualifier may be - "1033-Medical". The Darwin Descriptor associated with the Qualifier will be the feature that denotes the proofing tool (lex + engine components).  The component passed back by the Darwin Descriptor will be the lex component.\line Similarly each (type of) proofing tool engine is associated with a universally recognised GUID. So Spelling will have its own GUID separate from  the thesaurus. All the speller engine files will hang off this GUID. The proofing tools subtype and language will form the {\b Qualifier}.  Thus the Qualifier may be - "1033-Medical". The Darwin Descriptor associated with the Qualifier will be the feature that denotes the proofing tool (lex + engine components).  The component passed back by the Darwin Descriptor will be the engine component.\line When an application wants a particular proofing tool it will ask Darwin to provide the lex file and the engine for the proofing tools by calling MsiProvideComponentIndirect  for both the engine and the corresponding lex file. \page
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\help\general.rtf ===
{\rtf1\ansi {\fonttbl{\f0\fswiss Arial;}{\f1\fmodern Courier New;}} {\colortbl;} \fs20 #{\footnote MsiAutoContents} ${\footnote Msi Automation Contents} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Microsoft Installer Help Contents \par}\li180 NOTE: If you see this topic initially instead of the outline content view,  make sure that msiauto.cnt is in the same directory as msiauto.hlp the  first time you run help. \par\li0{\b\uldb Objects}{\v Msi_Objects} \par\li0{\b\uldb Properties}{\v Property_Contents} \par\li0{\b\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par\li0{\b\uldb Actions}{\v _msi_Installation_Database_Actions_List@msi.hlp} \par\li0{\uldb Installer Components}{\v Installer_Components} \par\li0{\uldb Released Components}{\v Release_Components} \par\li0{\uldb Command Line Options}{\v CommandLine_Options} \par\li0{\uldb REGMSI.EXE Tool}{\v RegMsi_Tool} \par\li0{\uldb MSIALTER.EXE Tool}{\v MsiAlter_Tool} \par\li0{\uldb MSIVAL.EXE Tool}{\v MsiVal_Tool} \par\li0{\uldb MSIDB.EXE Tool}{\v MsiTable_Tool} \par\li0{\uldb MSIINFO.EXE Tool}{\v MsiInfo_Tool} \par\li0{\uldb MSITRAN.EXE Tool}{\v MsiTran_Tool} \par\li0{\uldb MSIMERG.EXE Tool}{\v MsiMerge_Tool} \par\li0{\uldb Automating C++ method}{\v Coding_AutomateMethod} \par\li0{\uldb Help File Syntax}{\v Coding_HelpFile} \line\line {\b Obsolete tools}\line \par\li0{\uldb MSIDBVAL.EXE Tool}{\v MsiDbVal_Tool} \par\li0{\uldb MSITABLE.EXE Tool}{\v MsiDb_Tool} \page #{\footnote NoHelp} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Under Construction \line\tx360\tab\fs18\b0{\uldb Automation Overview}{\v MsiAutoOverview} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 No help is available for this topic yet. \page #{\footnote Msi_Obsolete} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Obsolete Method or Property \line\tx360\tab\fs18\b0{\uldb Automation Overview}{\v MsiAutoOverview} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This method or property has been replaced.  It is retained temporarily until code and tests are updated. \page #{\footnote What_Is} ${\footnote What Is The Microsoft Installer?} K{\footnote Microsoft Installer} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b What Is The Microsoft Installer? \par}\li180 The  Microsoft Installer is an all new installation technology designed from the  ground up using COM and relational database principles; targeting the Windows 95,  Windows NT, and PowerMac platforms (32-bit only).  Utilizing relational database  principles frees the Microsoft Installer from the myriad parsers previously  required to interpret an Acme STF, making the code smaller and faster.  In addition,  databases are easily merged.  Components can be added to an existing installation  and be supported as if they were authored here at Microsoft. \par\li0{\b Reduced Overhead}\par\li180 The Microsoft Installer's components are shared system  components.  In the near term Microsoft Installer components will still need to be  shipped, but they may not be installed.  Even if installed, there is only ever  one copy as opposed to the per product copies of Acme which tend to litter a user's  computer over time.  Eventually, Darwin components should make their way into the  operating system, freeing product groups from having to ship them at all. \par\li180 Regarding speed, the Microsoft Installer uses pre-defined queries.  Two substantial  advantages result from this design: processing is file based rather than in memory  and no parsing is required.  Acme uses an in memory model, meaning an entire STF  is read into memory for processing.  Therefore, the memory footprint is proportional  to the complexity of a product's installation.  The Microsoft Installer, on the other  hand, loads into memory only those database tables required for the task at hand.  So the memory footprint is greatly reduced.  Rather than the multitude of parsers  Acme supports for all its different actions, the Microsoft Installer uses pre-defined  queries and fetching.  Very little overhead and faster processing are the result. \par\li180 Perceived performance is also improved by performing background searching and costing.  While a user navigates through the interface, the Microsoft Installer is searching  for previously installed products, compliant products (i.e., CCP), etc.  Also in the  background the Microsoft Installer is adjusting initial costing estimates,  accounting for files being replaced to improve disk space calculations.  Performing  these tasks in the background alleviates the need to make users explicitly wait. \par\li0{\b Easier Authoring}\par\li180 A multitude of schemes exist throughout Microsoft to facilitate Acme authoring.  These  were born out of the inherent complexities of the Acme STF as well as the pronounced  lack of formal support.  The Microsoft Installer addresses these by providing an  integrated authoring environment, code named Scopes.  Scopes is a separate yet  parallel effort with a similar time frame as the installer.  Two of the major  goals for Scopes are to provide a clear migration path from Acme and to support  buttom up authoring.  A semi-interactive conversion utility between Acme's *.STF and the  Microsoft Installer's *.MSI is provided.  Because of the radically different paradigms  used by these two products, the process does not achieve 100 percent conversion.  But  all of the content of an *.STF (i.e., files, registry entries, shortcuts, etc.)  gets converted as well as some of the logic.  In bottom up authoring, a component  such as Graph can be authored and tested independently.  Once completed, the Graph  component can be imported into a larger authoring effort such as Excel.  Additional  authoring is required to wire up the dependencies between Graph and other components,  but the logic for installing Graph does not change. \par\li0{\b Upgrading}\par\li180 In order to reduce the pain associated with upgrading, the Microsoft Installer provides  support for moving files and folders as well as reading and propagating registry  settings.  REcognizing that locations of product components change over time, the Microsoft  Installer facilitates keeping up.  User settings files (e.g., *.ACL, *.FAV) and template  folder hierarchies are two examples.  Similarly, registry organization changes  over time.  Registry based settings made in the past should be preserved when upgrading.  For these reasons, the Microsoft Installer provides support for detecting and propagating  registry settings to preserve behavior. \par\li0{\b Administration}\par\li180 Like the Office business unit, many business units within Microsoft are facing  previous versions of their own products as their largest competitor.  Though an  envious position to be in, it has its problems.  Maintaining a steady revenue  stream in such a situation requires establishing some form of annuity model where  customers pay a periodic fee to Microsoft for products and services.  This is  particularly true for corporate sales; whether small, medium, or large corporations.  The Microsoft Installer addresses this new market landscape by providing a host of  administration features like an integrated Network Installation Wizard for creating  network installations, an Installation Script Wizard for creating one or more  department specific scripts to be run from a network installation, the ability  to add corporate specific templates to an existing network installation and have  them managed like intrinsic components, silent installations, tight integration with  SMS, and more. \par\li0{\b Wizard User Interface}\par\li180 Though authorable, the default user interface is a wizard.  Users may go back and  forth through a consistent set of dialogs any number of times, making changes along  the way or viewing what the Microsoft Installer has chosen.  Not until the "Install  Now" button is clicked are a user's choices cast in stone.  Special emphasis has been  placed on providing both novice and advanced paths through the user interface.  For  novice users, the novice path is easier than Acme while advanced users have more  flexibility when taking the advanced path. \par\li0{\b Pre-Installation}\par\li180 OEM pre-installation of Microsoft products is an over growing business and one which  Acme does not address very well.  Coincidentally, many corporations have a centralized  purchasing and deployment center which employs similar techniques as OEMs to get new  machiens pre-configured and tested before rolling out to end users.  Both of these  scenarios are addressed by the Microsoft Installer's build int pre-installation  support.  This support creates an image directly, without having to take before  and after snapshots of a reference machine to derive file and registry differences. \par\li0{\b Intra(er)net}\par\li180 The Internet offers a pervasive low cost infrastructure for distributing product updates  as well as content.  The Microsoft Installer, because of its database underpinnings,  allows for the modification of existing components or the addition of new components  without distruption.  Once modified or introduced, these components behave as if they  were authored and shipped with theoriginal product.  This capability dramatically  simplifies and reduces the cost of letter releases.  Plus, a new vehicle is  created for disseminating product content not mainstream enough to make the CD  content bar. \par\li180 Distribution via the Internet can be accomplished with the Microsoft Installer using  a general concept known as launchers.  Launchers are executables responsible for  bootstrapping Microsoft Installer compnents.  One way to package up an Internet  installation is to stuff into the resource section of a launcher a table file  containing authored installation logic, a cabinet file, and properties to set  conditions.  The Microsoft Installer then runs directly out of the launcher's  resource section.  IN this way, a single file can be downloaded from the Internet  then an installation can be invoked. \par\li0{\b OLE Automation}\par\li180 For the ultimate in flexibility, the Microsoft Installer provides an OLE automation  wrapper for all of its COM interfaces.  While quite useful inside Microsoft for  testing purposes, the automation layer also offers corporations with advanced IS  departments a framework around which they cna build even more sophisticated  deployment schemes than the Microsoft Installer will ever consider. \page #{\footnote Supported_Platforms} ${\footnote Supported Platforms} K{\footnote Supported Platforms} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Supported Platforms \par}\li180 The Microsoft Installer is a core code application.  This is accomplished by centralizing  all platform specific code in the Services component where low level file and operating  system functionality resides.  Above that layer in the Services component, the rest of  the Microsoft Installer's code is platform independent.  Using this approach, the  platforms support by the Microsoft Installer include the following 32-bit only platforms: \line {\b Windows 95} \line {\b Windows 98} \line {\b Windows NT 4.0}\tab (x86, Alpha) \line {\b Windows NT 5.0}\tab (x86, Alpha) \page #{\footnote Localize} ${\footnote Localization} K{\footnote Localization} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Localization \par}\li180 None of the Microsoft Installer's components contain any resources requiring localization.  The user interface is authored as part of a Microsoft Installer installation  database, so visible text resides in the database.  Error strings also reside  in the installation database.  In addition to abstracting out all strings form  within the Installer's components, the Microsoft Installer is also DBCS enabled.  As the Microsoft Installer loads it checks the operating system to see if DBCS is  turned on.  If it is then it loads code to handle double byte characters as part  of its string object.  However, if a user's system is not DBCS enabled then the  Microsoft Installer does not incur the performance penalty of loading double byte  character handling code. \page #{\footnote Installer_Components} ${\footnote Installer Components} K{\footnote Components} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Microsoft Installer Components \par}\li180 Microsoft Installer has been developed as a set of shared components:   {\uldb Automation}{\v Automate_Info},  {\uldb Engine}{\v ENGINE_Info}, {\uldb Handler}{\v HANDLER_Info},  {\uldb Services}{\v SERVICES_Info}.  These components are DLLs that expose COM objects.  These objects are accessible  from a simple bootstrapper executable known as a {\uldb Launcher}{\v Launcher_Info},  from C++ programs, or from VBA applications using the OLE automation facility. All  of the functionality within the Microsoft Installer is exposed as a rich set of  objects exposing only abstract COM interfaces. These interfaces are operating  system independent; operating system dependencies are encapsulated within the  implementation. \page #{\footnote Installer_Installer} ${\footnote Installer Installer} K{\footnote Installer} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Active Installation Manager Installer \par}\li180 For cases where the Installer is not delivered with the operating system,  it is supplied as a separate self-installing executable that unregisters  old components and installs and registers new Installer components. The  location of this installer package is specified by the  {\uldb INSTALLER}{\v Property_INSTALLER} property in the launcher, and may be a URL.  If the installer package is a relative path, it will be copied during an admin install. \page #{\footnote Launcher_Info} ${\footnote Launcher} K{\footnote Launcher} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Launcher (INSTALL.EXE) \par}\li180 Because the Installer components all live in shared DLLs, an executable  module is required to load the rest of the components.  The basic launcher is very small, containing only enough code  to handle any startup errors occurring before the components are initialized.  In addition, its resources can be configured to  set any number of initial property values, most importantly the names of the   component libraries and the installation database to use. Also configurable is  the icon to use and the name of the launcher so that multiple specific use  launchers can be created.  For instance, the distribution media might contain  a launcher with an installation type icon and a name like "Install".  However,  on a user's machine after installation, a launcher may be created with a  modification type icon and a name like "Change Installation". Or in a corporate  world an administrator might create a launcher named "Install Finance Templates"  containing properties to install only a set of internally developed financial  templates. The launcher is responsible for loading the  various Installer COM components. It loads each DLL, calls the public entry point  to obtain a class factory for the desired object, the calls the entry point to  create an instance. The also reads property values from its resources  parses the command line for additional property settings.  Command line data can consist of either option flags followed by a data value  if appropriate or property names with associated values, separated by an equals sign.  This module is not used when an installation is controlled by OLE Automation (VBA).  The automation wrapper DLL is used to load components instead. \page #{\footnote Automate_Info} ${\footnote Automation} K{\footnote Automation} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Automation (MSIAUTO.DLL) \par}\li180 Each of the objects exposed by the various Microsoft Installer components is  exposed to OLE automation by using a shadow object which contains the COM   object pointer and dispatches calls through that pointer. The automation  translation code is contained in a separate DLL to permit the use of highly  shared code, and because this capability is not required for most shipping  products. The main uses for the automation include testing and custom install  controllers employed by many corporate customers. The automation code for  each function has been kept as small as possible, mostly specifying the  arguments to pass and testing for error returns. \page #{\footnote ENGINE_Info} ${\footnote ENGINE} K{\footnote ENGINE} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Engine (MSIENG.DLL) \par}\li180 The Engine object controls the installation process, relying on the  {\uldb Services}{\v SERVICES_Info} object to perform all of the operating  system functions. It opens the installation database containing the  installation logic and data as well as passes error handling on to the  {\uldb Handler}{\v HANDLER_Info} object. The Engine object is associated  with a standard set of {\uldb Actions}{\v _msi_Installation_Database_Actions_List@msi.hlp}, each of which  performs a particular operation on data from one or more action specific  table. Additional Custom Actions may be added for  particular product installations requiring functionality not provided natively.  The basic Engine functionality is that of a sequencer which is driven by   data authored into a designated "sequence" table (such as   {\uldb InstallSequence}{\v _msi_InstallSequence_Table@msi.hlp}) in the installation  database. In addition, the Engine manages the source and destination directory  layout, the product selection tree, and cost calculations. \page #{\footnote HANDLER_Info} ${\footnote HANDLER} K{\footnote HANDLER} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Handler (MSIHND.DLL) \par}\li180 The Handler module is a replaceable component which processes all interactions  with users or a controlling applications. The interface provides two  functions, one of which handles messages of several kinds: warnings, errors,   and progress notifications. The other function is a request to  perform a particular action. The action is normally used to invoke a particular  dialog or wizard sequence, but can also be implemented as code functionality.  The standard implementation utilizes its own database tables to store the structure  and sequencing of all the dialogs. However, an alternate implementation of the  Handler module could operate completely silently or even remotely. \page #{\footnote SERVICES_Info} ${\footnote SERVICES} K{\footnote SERVICES} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Services (MSISRV.DLL) \par}\li180 The Services component provides wrappers for several operating system functions  as well as higher level functionality appropriate to the installation process.  Some services are implemented as objects, as they have a lifetime beyond a single  method call, while others are simple function calls. Examples of some of the services  include: \line 1. String handling - Common string handling objects to avoid the use of buffers and to minimize string copying. \line 2. Record management - Generalized mechanism for passing sets of values, used for database access and error handling. \line 3. Property management - Centralized global install property table management. \line 4. Volumes - Management of the characteristics of the various drive types, including floppy, hard, CD-ROM, and network servers. \line 5. File paths - Performs all file and folder operations used by install, provides path parsing, concatenation, and validation. \line 6. File copy - Copies compressed and uncompressed files, handles resource copying on Mac. \line 7. Registry - Handles all registry and INI file operations, including key cleanup on uninstall. \line 8. Program groups and shortcuts - Creating linkes on the Start menu or anywhere else in a user's file system. \line 9. Hardware and OS detection - Setting the appropriate property values that can be tested elsewhere. \page #{\footnote Shipped_Components} ${\footnote Shipped Components} K{\footnote Shipped Components} +{\footnote Shipped:Components} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Shipped Components \par}\li180 The following components are shipped with each product installed using the Microsoft Installer.  Microsoft Installer components are included in this list because in  a majority of the scenarios, they need to be shipped even if they are not  installed or used.  Major releases of a product must contain Microsoft Installer  components because you cannot assume a user has them already.  However, for  letter upgrades, patches, Web content releases, etc. you can assume user's have  these components.  Consequently, they need not be shipped. {\f1\line\uldb INSTALL.EXE}{\v Launcher_Info}{ } Launcher that loads the Installer's components. {\f1\line\uldb MSIENG.DLL}{\v ENGINE_Info}{   } Installer engine responsible for sequencing actions in the Action table. {\f1\line\uldb MSIHND.DLL}{\v HANDLER_Info}{   } UI handler which constructs dialogs and processes errors. {\f1\line\uldb MSISRV.DLL}{\v SERVICES_Info}{   } Operating system and database services available to the rest of the Installer. {\f1\line\b <{\i app}>.MSI}{     } A product specific installation database containing install logic and data. {\f1\line\b <{\i app}>.CAB}{     } One or more cabinet files containing compressed files to be installed. \page #{\footnote Release_Components} ${\footnote Released Components} K{\footnote ReleasedComponents} +{\footnote Released:Components} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Released Components \par}\li180 The following components are delivered with each retail build of the Microsoft Installer.  Because the Microsoft Installer is a cross platform application, separate sets  of components are produced for each platform. {\f1\line\b ERROR.IDT}{       } Table of parameterized Microsoft Installer error messages. {\f1\line\uldb INSTALL.EXE}{\v Launcher_Info}{   } Launcher that loads the Installer's components. {\f1\line\b MSIALTER.EXE}{ } Tool to load or display properties and resources into(in) a launcher. {\f1\line\b MSI.ODL}{           } Type library used for VBA object browsing . {\f1\line\b MSIAUTO.CNT}{   } WinHelp contents file used to organize information about the Microsoft Installer. {\f1\line\uldb MSIAUTO.DLL}{\v Automate_Info}{   } OLE automation layer and loader for use with VBA. {\f1\line\b MSIAUTO.HLP}{   } WinHelp file containing on-line help information for the Microsoft Installer. {\f1\line\uldb MSIENG.DLL}{\v ENGINE_Info}{     } Installer engine responsible for sequencing actions in the Action table. {\f1\line\uldb MSIHND.DLL}{\v HANDLER_Info}{     } UI handler which constructs dialogs and processes errors. {\f1\line\uldb MSISRV.DLL}{\v SERVICES_Info}{     } Operating system and database services available to the rest of the Installer. {\f1\line\b MSIDB.EXE}{ } Tool to import from and export to a text based archive format for tables. {\f1\line\b REGMSI.EXE}{   } Tool to self-register and unregister installer components as OLE objects. {\f1\line\b MSIVAL.EXE}{ } Tool to validate an authored database. {\f1\line\b TESTDB.MDB}{     } Test database containing the basic tables and examples of data. \par\par In addition, debug builds of the Microsoft Installer deliver the following additional components: {\f1\line\b  INSTALLD.EXE  } Launcher stub with properties set to use debug components {\f1\line\b  MSIAUTOD.DLL,MSIAUTOD.PDB,MSIAUTOD.BSC,MSIAUTOD.MAP} Automation, debug components {\f1\line\b  MSIENGD.DLL, MSIENGD.PDB, MSIENGD.BSC, MSIENGD.MAP } Engine, debug components {\f1\line\b  MSIHNDD.DLL, MSIHNDD.PDB, MSIHNDD.BSC, MSIHNDD.MAP } Handler, debug components {\f1\line\b  MSISRVD.DLL, MSISRVD.PDB, MSISRVD.BSC, MSISRVD.MAP } Services, debug components {\f1\line\b  REGMSID.EXE  } debug build for registration tools, works identically to REGMSI.EXE \page #{\footnote CommandLine_Options} ${\footnote Command Line Options} K{\footnote Command;Options} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Command Line Options \par}\li180 Command line options may be specified when invoking a Windows launcher executable.  The command line is parsed by the launcher with corresponding property values  being passed on to the Services module, along with any properties stored in the  resource section of the launcher itself.  The general format is to specify property  =value pairs using an equals sign between the case insensitive property name and value.  Property pairs are separated by white space on the command line.  If a value contains  embedded white space it must be enclosed in double quotes.  Only properties whose  names consist of all upper case characters can be entered on the command line. Help for command line parameters is available by using a question mark as the  command line artument, (e.g., install ?). A selected list of property names and  descriptions are displayed. If two successive question marks are provided as a  property, the default values for properties predefined in the launcher are displayed.  Both property values and their descriptions are programmed either by the build process  or by using the MSIALTER.EXE tool. For backward compatibility with Acme, forward slash or minus sign followed by a letter continues  to be supported by the Microsoft Installer (e.g., install /?).  The letters are  case-insensitive and must be immediately preceeded by either a forward slash or minus sign.  Some of the options set a particular value for a property while others require the value  to follow the option letter. Backwards compatibile options are shown below, along with their  resultant property assignments. {\line\f1   /A {\i }          } {\uldb ACTION}{\v *Property_ACTION} = Admin {\line\f1   /G {\i logfile}   } {\uldb LOGFILE}{\v *Property_LOGFILE} = {\f1\i logfile} {\line\f1   /I {\i rootdrive} } {\uldb ROOTDRIVE}{\v *Property_ROOTDRIVE} = {\f1\i rootdrive} {\line\f1   /K {\i cdkey}     } !!?? CDKEY = {\f1\i cdkey} {\line\f1   /M {\i logmode}   } {\uldb LOGMODE}{\v *Property_LOGMODE} = {\f1\i logmode} {\line\f1   /N {\i username}  } {\uldb USERNAME}{\v *Property_USERNAME} = {\f1\i username} {\line\f1   /O {\i orgname}   } {\uldb COMPANYNAME}{\v *Property_COMPANYNAME} = {\f1\i orgname} {\line\f1   /P {\i pidstring} } {\uldb PRODUCTID}{\v *Property_PRODUCTID} = {\f1\i pidstring} {\line\f1   /R {\i }          } {\uldb ACTION}{\v *Property_ACTION} = Reinstall {\line\f1   /S {\i sourcedir} } {\uldb SOURCEDIR}{\v *Property_SOURCEDIR} = {\f1\i sourcedir} {\line\f1   /T {\i database}  } {\uldb DATABASE}{\v *Property_DATABASE} = {\f1\i database}  {\line\f1   /U {\i }          } {\uldb ACTION}{\v *Property_ACTION} = Uninstall \par\par\li0\fi0{\b Remarks}\par\li180 Command line options are not available on the Mac.  In their place will be an alternate mechanism for the user  to specify property settings such as a preference file. \page #{\footnote MsiAutoOverview} ${\footnote Automation Overview} K{\footnote Overview; Automation} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Microsoft Installer Automation Interface \par}{\b Access to C++ Libraries}\par\li180 An MsiAuto object must be initially created in order to load the automation  support that is required in order to access the Microsoft Installer components  through OLE automation. This object provides wrappers to create the top level  objects and access their methods. These wrapper simply provide argument  translations to expose the C++ methods in manner consitent with BASIC without  changing the behavior of the methods. When possible, a pair of Get and Set C++  methods will be exposed to BASIC as a single property. Multiple C++ methods  that simply handle different data types will be exposed as a single method.  Where appropriate, C++ methods taking an index argument will be exposed as an  indexed property. Many C++ methods return the result through an argument, as  the return value is used for the error return; however in BASIC errors are  handled by a separate mechanism, and the result is always passed in the return  value. \page #{\footnote MsiDb_Tool} ${\footnote MsiDb Tool} K{\footnote MsiDb} +{\footnote Tool:MsiDb} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MSIDB.EXE Tool To Modify A Database \par}\li180 The MSIDB.EXE tool uses the MSI database external API to import and export database tables as well  as merge databases and apply transforms to databases.  It is essentially a UI and/or command line  processing layer on MsiDatabase.Import and .Export.  If all required  parameters (mode, folder, database and and table list) are specified on the command line,  the tool will not bring up any UI and will operate as silent command line-driven utility,  suitable for a build script. The -m and -t and create modes can only be used in silent command line mode.  Up to  10 transforms or merge databases can be specified. If the folder  containing the text archive files is not specified it will be prompted for; likewise the database will   be prompted for if not specified. Create new database (both .msi and .mdb), Import archives to database  and Export tables to archives.  Tables can be exported from a read only database (only in interactive mode). \par\fi-180\li180{\b Command Line Syntax} {\line\f1 MsiDb \{option\}...\{option\}... \{table\}...\{table\}} \line The following case-insensitive command line options are supported (slash delimiter may also be used). {\line\f1\b  -i   } Import text archive files from folder into specified database {\line\f1\b  -e   } Export selected tables into text archive files in specified folder {\line\f1\b  -c   } Creates a new database file (overwrites existing) and imports tables {\line\f1\b  -f   } Specifies the folder containing the text archive files for tables and streams {\line\f1\b  -d   } Fully-qualified path to the database {\line\f1\b  -m   } Fully-qualified path to the database to merge in {\line\f1\b  -t   } Fully-qualified path to the transform to apply {\line\f1\b  -?   } Displays command line help dialog \line Table names for import are file names. Standard wild card specifications may be used. \line Table names for export are table names. Only the wildcard specification, "*", may be used. \par{\b Archive Table Naming} \line The table name is truncated to 8 characters and the extension ".idt" added. \line Tables names supplied by command for import are likewise converted. \line The name used for database table creation is maintained in the .idt file. \line Binary data streams are stored as separate files with extension ".ibd". \line Binary filename used is primary key data for the row containing the stream. \par{\b Database Naming Syntax} \line Microsoft Installer database:  \{databasepath(*.msi)\} \line Access database:    \{databasepath(*.mdb)\}[@\{owner\}][#\{password\}] \line SQLServer database: \\\\\{server\}\\\{database\}[@\{owner\}][#\{password\}] \line ODBC data source:   \{ODBCdatasource name\}[@\{owner\}][#\{password\}] \line        \{owner\} defaults to the current network username \line        \{password\} defaults to none \line\line Note:  When using long filenames with spaces, use quotes around them.  For example, for a  database that is in the 'My Documents' folder, specify it as "c:\my documents". \page #{\footnote MsiTable_Tool} ${\footnote MsiTable Tool} K{\footnote MsiTable} +{\footnote Tool:MsiTable} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MSITABLE.EXE Tool To Modify A Database \par}\li180 \line !!! OBSOLETE !!! \line\line The {\b MSITABLE.EXE} tool uses the MSI database engine to import and export database tables as well  as merge databases.  It is essentially a UI and/or command line processing layer on MsiDatabase.Import  and .Export.  This tool uses OLE to create an instance of the MsiServices component. If all required  parameters (mode, folder, database and and table list) are specified on the command line,  the tool will not bring up any UI and will operate as silent command line-driven utility,  suitable for a build script. It will also operate as a silent command line-driven utility if  the -m mode and database are specified for merging.  No UI is available for merging.  If the folder  containing the text archive files is not specified it will be prompted for; likewise the database will   be prompted for if not specified. There are three modes in which to tool can operate:  Create new database, Import archives to database and Export tables to archives.  The Create and Merge   options are not available when in interactive mode.  One can use multiple merge options (up to 10). \par\fi-180\li180{\b Command Line Syntax} {\line\f1 MsiTable \{option\}...\{option\}... \{table\}...\{table\}} \line The following case-insensitive command line options are supported (slash delimiter may also be used). {\line\f1\b  -i   } Import text archive files from folder into specified database {\line\f1\b  -e   } Export selected tables into text archive files in specified folder {\line\f1\b  -c   } Creates a new database file (overwrites existing) and imports tables {\line\f1\b  -f   } Specifies the folder containing the text archive files for tables and streams {\line\f1\b  -d   } Fully-qualified path to the database {\line\f1\b  -m   } Fully-qualified path to the database to merge in {\line\f1\b  -?   } Displays command line help dialog \line Table names for import are file names. Standard wild card specifications may be used. \line Table names for export are table names. Only the wildcard specification, "*", may be used. \par{\b Archive Table Naming} \line The table name is truncated to 8 characters and the extension ".idt" added. \line Tables names supplied by command for import are likewise converted. \line The name used for database table creation is maintained in the .idt file. \line Binary data streams are stored as separate files with extension ".ibd". \line Binary filename used is primary key data for the row containing the stream. \par{\b Database Naming Syntax} \line Microsoft Installer database:  \{databasepath(*.msi)\} \line Access database:    \{databasepath(*.mdb)\}[@\{owner\}][#\{password\}] \line SQLServer database: \\\\\{server\}\\\{database\}[@\{owner\}][#\{password\}] \line ODBC data source:   \{ODBCdatasource name\}[@\{owner\}][#\{password\}] \line        \{owner\} defaults to the current network username \line        \{password\} defaults to none \line\line\line\line\line \page #{\footnote RegMsi_Tool} ${\footnote RegMsi Tool} K{\footnote RegMsi} +{\footnote Tool:RegMsi} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b REGMSI.EXE Tool to Self-register Installer Components \par}\li180 The REGMSI.EXE tool simply calls the DllRegisterServer and DllUnregisterServer  entry points of the Installer components to cause them to register or unregister  themselves as OLE objects. Registration allows them to be called using the OLE  call CoCreateInstance, or by using CreateObject from VBA. The tool interprets  individual characters on the command line to set execution options. Options are  case insensitive and may appear in any order.  The default behavior is to register all the components designated below: {\line\f1\b  A   } Automation module, MsiAuto(D).DLL, ProgId = Msi.Automation(Msi.AutoDebug) {\line\f1\b  S   } Services module,     MsiSrv(D).DLL,   ProgId = Msi.Services(Msi.ServicesDebug) {\line\f1\b  E   } Engine module,       MsiEng(D).DLL,  ProgId = Msi.Engine(Msi.EngineDebug) {\line\f1\b  H   } Handler module,      MsiHnd(D).DLL,  ProgId = Msi.Handler(Msi.HandlerDebug) {\line\f1\b  D   } Access the debug builds of the components (D suffix), rather than ship. {\line\f1\b  B   } Access the Lego (BBT) builds of the components (L suffix), not available on Mac. {\line\f1\b  U   } Unregister modules, otherwise register {\line\f1\b  Q   } Quiet, no Errors show, returns non-zero status to batch file if failure. {\line\f1\b  G   } Generate tool module, MsiGen(D).DLL,  ProgId = Msi.Generate {\line\f1\b  L   } Localaize tool module, MsiLoc(D).DLL,  ProgId = Msi.Localize {\line\f1\b  T   } Utilities tool module, MsiUtil(D).DLL,  ProgId = Msi.Utilities {\line\f1\b  P   } Patch tool module,      MsiPat(D).DLL,  ProgId = Msi.Patch     {\line\f1\b  C   } Acme convert tool module, MsiAcme(D).DLL,  ProgId = Msi.AcmeConvert {\line\f1\b  ?   } Displays option letters The REGMSID.EXE tool is simply a debug build of the tool and is no different in funtionality.\par MAC NOTE: This tool cannot use command line arguments on the Mac, and thus  only can register the components. A solution to this is being considered for unregistration.  On the Mac, only the Automation module self-registers, as the others have no access to the registry, yet. \page #{\footnote MsiAlter_Tool} ${\footnote MsiAlter Tool} K{\footnote MsiAlter} +{\footnote Tool:MsiAlter} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MSIALTER.EXE (formerly LOADPROP.EXE) Tool  \par}\li180 The {\i\b MSIALTER.EXE} tool sets, updates, or displays launcher resources.  Also inserts cabinets or  transforms into a Database. {\i\b Stuffing cabinets or transforms into the database:} \line The tool can be used to stuff a cabinet or transform into the database storage.  For cabinets, use the syntax msialter \{database\} \{cabinet file\} where \{cabinet  file\} is the full path to the cabinet and \{database\} is the full path to the database.  The cabinet  will be stored as the base name in the database.  For example, if you specify the cabinet file as  c:\\temp\\msproj1.cab, the c:\\temp\\msproj1.cab file will be opened and its data put into the database  storage file as a stream whose name is msproj1.cab.  For transforms, use the syntax msialter -t \{database\} \{transform file\} where  \{transform file\} is the full path to the transform file and \{database\} is the full path to the database.  Note, you  don't have to use full paths if the transform or cabinet or database is in the same directory as msialter.exe.  Like the  cabinet file, the transform file will be stored under its base name.  The transform is stored as a child storage of the  database.  Note, OLE limits the size of streams and child storages allowed in the database.  This could be the cause of the  'Unable to open child storage' error.  Currently, spaces are not allowed in the names of the cabinet stream or transform storage. {\i\b Setting or Updating resources:} \line The tool can be used to set specific properties like DATABASE, ACTION, MESSSAGEBASE, and COMPANYNAME.  It can also update  the ICON resource and insert a DATABASE, TRANSFORMS, and/or CABINET file resource(s) into the  launcher.  The input is a text file of property and value pairs with one pair per text line.  Note that the end of  line/carriage return is required for a property-value pair to be added. The  delimiter between the property and value pair is the equals sign '='.  Only property  names that  use no lower case characters can be set; however, the property names in the text file are case-insensitive.  The value string in the text file is case sensitive.  File resources are designated by an at sign '@'  preceding the name of the file in the value string.  The resource is loaded as a file resource in the  launcher and its resource name is the base name [no path or file extension].  For the DATABASE property, an at  sign loads the resource as a file resource and sets the DATABASE property to point to that resource using the  @\{RESOURCE NAME\} syntax.  To specifiy languages for a property, use the following format: \{Property\}(langId)=\{Value\}  where langId is the language in decimal form.  All file resources, CABINET, DATABASE, ICON, and TRANSFORMS are always  netural and the DATABASE property is always neutral.  All other properties can have multiple languages associated  with them.  If no language is specified, it is assumed to be language neutral or zero (0).  To remove an install  property from the launcher, simply supply nothing after the delimiter as in the following format: \{Property\}(langId)=     .  Only one DATABASE property/file resource and one ICON resource is allowed per launcher.  One can only specifiy  a DATABASE property once in the property text file.  {\i\b Displaying resources:} \line The tool can also be used to display the resources in the launcher.  It will display the install property resources as  well as the transform, cabinet, database, and icon file resources.  Use of the -f option will dump the file resources into  the current directory. The Icon file resource is displayed as ICON=@{exe name} where {exe name} is the executable whose  resources the tool is displaying. {\i\b Command Line Syntax:} \line {\b msialter \{database\} \{cabinet file\} } -- Stuffs the Cabinet file into the database \line {\b msialter -t \{database\} \{transform file\} } -- Stuffs the Transform file into the database. \line {\b msialter -l \{launcher\} \{property file\} } -- Loads resources in the property file into the  launcher \line {\b msialter \{launcher\} } -- Displays the resources in the launcher. \line {\b msialter -f \{launcher\} } -- Displays the resources in the launcher and outputs the file resources  to the current directory \line {\i\b Sample property file:} \line COMPANYNAME(1032)=Microsoft \line DATABASE=@testdb.msi \line ICON=@cd.ico \line MESSAGEBASE=32 \line {\i\b Comments on property file:} \line COMPANYNAME(1032)=Microsoft sets the COMPANYNAME property to have the value of Microsoft in the Greek language.  DATABASE=@testdb.msi loads the testdb.msi database as a file resource in the launcher.  It will be called TESTDB and  the DATABASE property will contain the value @TESTDB.  ICON=@cd.ico changes the current icon resource in the launcher  to display the cd.ico icon.  MESSAGEBASE=32 sets the MESSAGEBASE property to 32 in language neutral. {\i\b NOTE:} \line This tool does not run on the current Windows95 release, as the API  function UpdateResource is not implemented. It requires WindowsNT. \page #{\footnote MsiInfo_Tool} ${\footnote MsiInfo Tool} K{\footnote MsiInfo} +{\footnote Tool:MsiInfo} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MSIINFO.EXE Tool To Modify A Database \par}\li180 The MSIINFO.EXE tool uses the MSI database external API to edit or display the summary information of a  database. It is a command line tool. \par\fi-180\li180{\b Command Line Syntax} {\line\f1 MsiInfo \{database\}}\line Displays the Summary information of the database to the console\line {\line\f1 MsiInfo \{database\} \{option\} \{data\}.....}\line Sets the corresponding summary information property\line \line The following case-insensitive command line options are supported (slash delimiter may also be used). {\line\f1\b  -I   }  PID_DICTIONARY {\line\f1\b  -C   }  PID_CODEPAGE {\line\f1\b  -T   }  PID_TITLE {\line\f1\b  -J   }  PID_SUBJECT {\line\f1\b  -A   }  PID_AUTHOR {\line\f1\b  -K   }  PID_KEYWORDS {\line\f1\b  -O   }  PID_COMMENTS {\line\f1\b  -P   }  PID_TEMPLATE {\line\f1\b  -L   }  PID_LASTAUTHOR {\line\f1\b  -V   }  PID_REVNUMBER {\line\f1\b  -E   }  PID_EDITTIME {\line\f1\b  -S   }  PID_LASTPRINTED {\line\f1\b  -R   }  PID_CREATE_DTM {\line\f1\b  -Q   }  PID_LASTSAVE_DTM {\line\f1\b  -G   }  PID_PAGECOUNT {\line\f1\b  -W   }  PID_WORDCOUNT {\line\f1\b  -H   }  PID_CHARCOUNT {\line\f1\b       }  PID_THUMBNAIL     !! NOT SUPPORTED !! {\line\f1\b  -N   }  PID_APPNAME {\line\f1\b  -U   }  PID_SECURITY \line The data following the option is optional. If there is no data following the option, then the property is  removed. The database must not be a readOnly database.  The same properties can be specified again on the  command line, but only 20 switches can be used.  If the data for a particular option contains a space,  encapsulate it in quotes, such as /T "MY TITLE".  The quotation marks notify the command line parser to  ignore the space.  For the file time  properties, those being PID_EDITTIME, PID_LASTPRINTED, PID_CREATE_DTM,  and PID_LASTSAVE_DTM, use the following format "year/month/day hour:minute:second" which is required to  be "yyyy/mm/dd hh:mm:ss" (i.e. "1997/06/20 03:25:59). \page #{\footnote MsiDbVal_Tool} ${\footnote MsiDbVal Tool} K{\footnote MsiDbVal} +{\footnote Tool:MsiDbVal} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MSIDBVAL.EXE Tool to Validate an Msi Database \par}\li180 \line !!! OBSOLETE !!! The {\i\b MSIDBVAL.EXE} tool validates a *.msi database.  It utilizes  the Validation tool module MsiVal(D).DLL for validation.  For any database  to be validated, the tool requires that the {\uldb _Validation table}{\v _msi__Validation_Table@msi.hlp}   {\b ( _Validation table )} exist in that database.  This table contains the values allowed  in the columns of all of the tables.  This is a console app and output is output  to stdout or a pipe or handle if specified.  If any errors are found in validation,  they are output to the screen. A valid database returns a valid database message. {\i\b COMMAND LINE SYNTAX:} \line {\b msidbval \{database\} } \page #{\footnote MsiVal_Tool} ${\footnote MsiVal Tool} K{\footnote MsiVal;Validation} +{\footnote Tool:MsiVal} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MSIVAL.EXE Tool to Validate an Msi Database \par}\li180 The {\b MsiVal.EXE} tool validates a *.msi database.  It utilizes  the external API for validation.  For any database  to be validated, the tool requires that the {\uldb _Validation table}{\v _msi__Validation_Table@msi.hlp}   {\b ( _Validation table )} exist in that database.  This table contains the values allowed  in the columns of all of the tables.  The msival.exe tool also performs the Missing  Columns validation in which any column defined in the _Validation table, but not in the  Columns catalog of the database is considered an error.  If one wishes to add a new  table/column, then one has to add the corresponding entry(ies) to the _Validation table.   If one removes an {\b optional} column {\i(no way of regulating this except through the  authoring environment)}, then one has to remove the corresponding entry from the  _Validation table.  The _Validation table is not shipped, and is merely used for  validation during authoring.  The Missing column validation code is external to the  Darwin code.  This is a console app and output is output  to stdout or a pipe or handle if specified.  If any errors are found in validation,  they are output to the screen. A valid database returns a valid database message. \line {\i\b Required Tables:}\line\line Depending on the validation, the following tables are required for the msival.exe tool to work\line {\f1 _Validation:} Required when using the external APIs for validation.\line {\f1 _Required:} Required for the 'Required' validation.  Not needed if use -OFF option\line {\f1 _InstallSequence:} Required for the 'Organizational' InstallSequence validation.  Not needed if use -OFF option\line {\f1 _Sequence:} Required for the 'Sequential' InstallSequence validation.  Not needed if use -OFF option\line \line {\i\b Command Line Syntax:} \line\line {\b msival \{database\} } --> All validation (missing column, data/foreign key, required, organizational install, sequential install)\line {\b msival \{database\} -OFF } --> Missing column and data/foreign key validation \line \line {\i\b How Validated:}\line\line {\f1 Missing Columns:}\line Use the _Validation table and ensure that every column listed in the _Validation table is also listed in the _Columns catalog  of the database. (Normal validation using the API's catches the other way from _Columns to _Validation)\line {\f1 Required:}\line Use the _Required table and ensure that the values are found in the particular table.  This only makes sure that the primary  keys are there, not that the values are valid.  See below for table definition information.\line {\f1 Install Organization:}\line Use the _InstallValidate table and ensure that the organization of the actions fall in the sections defined in the table.  If  an action is not listed in this table, it is assumed to be either a Dialog or a Custom Action and checked to be sure that  it is found in either the Dialog or CustomAction tables.\line {\f1 Install Sequence:}\line Use the _Sequence table and ensure that the actions occur in the correct order.  Some actions have pre and post conditional  actions. \line \line {\i\b Table Definitions (except _Validation)}\line\line {\f1 _Required}\line Table (string, primary key, required) -- name of table with said required value\line Value (string, primary key, required) -- required value, if multiple primary keys, then it is a delimited list (separator is semi-colon)\line KeyCount (short, required) -- number of primary keys in table\line Description (string, optional) -- description of required value\line \line {\f1 _InstallValidate}\line Action (string, primary key, required) -- name of action (do not list Dialog or CustomActions here!!)\line SectionFlag (integer, required) -- flag value of sections, 1 or more of the following:\line {\i Search --> Searching actions, from LaunchConditions to RMCCPSearch}\line {\i Costing --> Costing actions}\line {\i Selection --> UI actions, CustomActions, etc.}\line {\i Advertise --> RegisterProduct, PublishProduct, PublishFeatures, PublishComponents actions}\line {\i Execution --> Script operations, InstallFiles, etc}\line Other notes:\line 1.) Divisor between search and costing is CostInitialize\line 2.) Divisor between costing and selection is CostFinalize\line 3.) Divisor between selection and advertise is RegisterProduct\line 4.) Divisor between advertise and execution is InstallValidate\line 5.) If any advertise or execute action called, then ExecuteFinalize must be called\line 6.) A call to ExecuteFinalize resets section to search so more actions can occur afterwards\line \line {\f1 _Sequence}\line Action (string, primary key, required) -- name of action (do not list Dialog or CustomActions here!!)\line Dependent (string, primary key, required) -- action required to come before or after said action\line After (boolean, required) -- 0 if action comes before dependent, 1 if action comes after dependent\line Optional (boolean, required) -- (ignored for 'Before') 0 if action is not optional, 1 if optional\line Other notes:\line 1.) Temporary column is created for marking 'dependent' action of actions\line\line 2.) As action is encountered in InstallSequence table, its sequence number if filled in for every row of the  _Sequence table where the 'Dependent' action value equals the current action (thus marking the temp column)\line\line 3.) Two special queries are done for the _Sequence table (one for 'Before' and one for 'After' actions)\line\line 4.) The result sets of the fetches are important, as the idea is to not have a result set for valid (explained below)\line\line a.) Action Is To Go After A Required Dependent Action And Marking Column Is  Zero --> ERROR\line Explanation: A preceding action is required before this one, but it hasn't been found, so this is an error\line\line b.) Action Is To Go After A Required Dependent Action And Marking Column Is Not Zero --> CORRECT\line Explanation: A preceding action is required before this one, and it has been found, so this is valid\line\line c.) Action Is To Go After An Optional Dependent Action And Marking Column Is Zero --> CORRECT\line Explanation: This action doesn't have to be listed, but if it were to be found (some point after us, it would be caught as  if the _Sequence table is authored correctly, the Dependent Action would have us listed as coming Before them so we  would be caught in that pass)\line\line d.) Action Is To Go After An Optional Dependent Action And Marking Column Is Not Zero --> CORRECT\line Explanation: This action must come after an optional dependent action which happens to be listed before us, so this is valid\line \line{\i\bThe Optional/Required Attrib is ignored for Before conditions}\line\line e.) Action Is To Go Before Optional/Required Dependent Action And Marking Column Is Zero --> CORRECT\line Explanation: Action is supposed to come before the dependent action and the dependent action hasn't been seen yet, so this  is valid\line\line f.) Action Is To Go Before Optional/Required Dependent Action And Marking Column Is Not Zero --> ERROR\line Explanation: Action is supposed to come before the dependent action, but the dependent action has already been found, so this  is invalid\line\line \line {\i\b Extensibility of Validation}\line Validation is very extensible, as it is dependent upon tables, so changing the _Validation, _Required, _InstallValidate, and  _Sequence tables will change validation.\line \page #{\footnote MsiTran_Tool} ${\footnote MsiTran Tool} K{\footnote MsiTran} +{\footnote Tool:MsiTran} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MSITRAN.EXE Tool to Generate, Apply, or View a Transform file \par}\li180 The {\i\b MSITRAN(d).EXE} tool can generate or apply a transform file  and can be used to  view the transform file.  It utilizes the external API.  \par {\i\b COMMAND LINE SYNTAX:} \line {\b msitran(d) -g \{base db\} \{ref db\} \{transform file name\} [\{error conditions\}] --> Generate a Transform file }\line {\b msitran(d) -v \{transform\} \{base db\} --> View a Transform file}\line {\b msitran(d) -a \{transform\} \{database\} [\{error conditions\}] --> Apply a Transform}\line \line Error Conditions:\line The following errors may be suppressed when applying a transform.  To suppress an error, include the appropriate character in  the \{error conditions\} argument. Conditions specified with -g are placed in  the summary information of the transform, but are not used when  applying a transform with -a.\line \line {\f1 'a': }Add existing row.\line {\f1 'b': }Delete non-existing row.\line {\f1 'c': }Add existing table.\line {\f1 'd': }Delete non-existing table.\line {\f1 'e': }Modify existing row.\line \page #{\footnote MsiMerge_Tool} ${\footnote MsiMerge Tool} K{\footnote MsiMerge; MsiMerg} +{\footnote Tool:MsiMerge} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MSIMERG.EXE Tool to Merge a database into another \par}\li180 The {\i\b MSIMERG(d).EXE} tool can a database into another.  If MergeConflicts are reported, information  is placed in the _MergeErrors table.  Note, the _MergeErrors table may not always be created depending  on the error that occured (an error not related to the actual merge of the data).  It utilizes the external API.  \par {\i\b COMMAND LINE SYNTAX:} \line {\b msimerg(d) \{base db\} \{ref db\}}\line \page *{\footnote Dev} #{\footnote Coding_AutomateMethod} ${\footnote Automating C++ method} K{\footnote Automate} +{\footnote Coding:AutomateMethod} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Steps to Exposing a C++ Method to Automation \par}\li180 The following describes the series of operations that must be performed  in order to expose a C++ method to OLE Automation and Object browers,  including help topics, for use with VBA applications. For each C++ class that is exposed to OLE automation, a shadow class is  defined which is derived from the common base class CAutoBase, and which  simply holds a pointer to the C++ object. A member function is defined for  each property or method exposed. All such functions take argument stack  object, which abstracts the complicated Variant arguments and return values.  All functions have a void return, as they throw exceptions on any error. C++ functions that get and set values are usually exposed as properties, with  the "Get" and "Set" part of the names removed. If both a Get and a Set are  present, they will likely be exposed as a single property. Since all data is  passed as Variant unions, multiple functions that vary only in data types can  sometimes be combined into a single function. Also note that properties can  accept arguments, such that access to data from a particular field can be  exposed as an indexed property. These index arguments may be of any data type. \par\li0{\b Automation Wrapper}\par\li180 Add function to wrapper class definition: \line {\f1   void MyFunc(CAutoArgs& args);}\line Add implementation function that processes the arguments and return values:{\f1 \line  void CAutoFoo::MyFunc(CAutoArgs& args) \line   \{ \line      args = m_riFoo.MyFunc(args[1], args[2]); \line   \}} \par\li0{\b Dispatch Table Entry}\par\li180 Add an entry to the dispatch table, supplying function and argument names,  separated only by a comma. The convention is that both are mixed case,  but the method or property names start with upper case, and the argument  names start with lower case. Each entry in the dispatch table must be  assigned a unique dispatch Id, normally starting with the number 1. The  value 0 denotes the default property, which is called if the object itself  is used in the context of a value, i.e. assignment or function argument.  Properties use {\f1 aafPropRW} or {\f1 aafPropRO} instead of {\f1 aafMethod}. \line {\f1  10, aafMethod, CAutoFoo::MyFunc, "MyFunc,arg1,arg2", } \line  \par\li0{\b ODL Specification}\par\li180 To expose the method in the type library, the prototype of the exposed  method or property must be defined in ODL syntax, along with the help info:{\f1 \line   [id(10),helpcontext(MsiFoo_MyFunc),helpstring("What MyFunc does.")] \line      Boolean MyFunc([in] long arg1, [in] BSTR arg2);} \par\li0{\b Help Context ID}\par\li180 In the file "msiauto.hh", the help context Id must be defined. This file is  used to compile the ODL file to the type library and to generate the help file.  To insure uniqueness of the Ids, the low two digits are the same as the  dispatch Id, and the upper digits are the decimal equivalent of the low byte  of the GUID defined for the class. \line {\f1   #define MsiFoo_MyFunc  1510} \par\li0{\b Help Topic}\par\li180 Generate a new topic, including the necessary header information. It is best  to copy an existing topic or the sample topic, and modify it as required. *{\footnote Dev} {\f1\line   *\{\\footnote VBA\}            }{\i <-Build tab, must be first} {\f1\line   #\{\\footnote MsiFoo_MyFunc\}  }{\i <-Topic Id} {\f1\line   $\{\\footnote MsiFoo.MyFunc\}  }{\i <-Topic Title, diplayed in Find} {\f1\line   +\{\\footnote MsiFoo:MyFunc\}  }{\i <-Browse Sequence Id} {\f1\line   K\{\\footnote MyFunc;Internet\}}{\i <-List of keywords, separated by ';'} {\f1\line   \\pard\\f0\\cf1\\sb90           }{\i <-Restore paragraph and text styles} {\f1\line   \{\\li-150\\fi150\\brdrb\\fs24\\b }{\i <-Set special format for heading} {\f1\line   MyFunc Method               }{\i <-Heading text, larger font size, bold} {\f1\line   \\line\\tx360\\tab\\fs18\\b0\{\\uldb MsiFoo Object\}\{\\v MsiFoo_Object\} } {\f1\line   \\tx3000\\tab\{\\uldb Msi Objects\}\{\\v Msi_Objects\} }{\i <-Hot links} {\f1\line   \\tx5000\\tab\{\\uldb Database Tables\}\{\\v Database_Tables\} } {\f1\line   \\par\}\\li180                 }{\i <-End of heading, set normal indent} {\f1\line   Tell what MyFunc does here. } {\f1\line   \\par\\li0\{\\b Syntax\}\\par\\li500\\fi-320 }{\i <-Hanging indend} {\f1\line   \{\\i object\}\{\\b .MyFunc(\{\\i arg1, arg2\})\} } {\f1\line   \\par\{\\i object\}\\line } {\f1\line   Required. The MsiFoo object. } {\f1\line   \\par\{\\i\\b arg1\}\\line } {\f1\line   Required. Description of a required argument. } {\f1\line   \\par\{\\i\\b arg2\}\\line } {\f1\line   Optional. Description of an optional argument. } {\f1\line   \\par\\fi0\\li0\{\\b Remarks\}\\par\\li180 }{\i <-No indent, bold title, normal indent} {\f1\line   Additional notes as required.... } {\f1\line   \\page                       }{\i <-End of topic} \par\li0{\b Help References}\par\li180 Incorporate links to the new topic inside other relevent topics. In particular,  include the new topic under the appropriate {\b Methods} or {\b Properties}  section within the topic for the class itself. \line {\f1  \{\\uldb DoAction\}\{\\v MsiEngine_DoAction}\\line \par\li0{\b Help Contents Entry}\par\li180 In the help contents file, "msiauto.cnt" for the VBA help file, the new topic  must be inserted in the proper place in the topic hierarchy. The single digit  at the start of each line is the tree level. Spaces are inserted only for  clarity when editing this file. The first symbol is what is shown in the  contents view.  Following the equal sign is the help topic Id. \line {\f1   3 MyFunc=MsiFoo_MyFunc } \page *{\footnote Dev} #{\footnote Coding_HelpFile} ${\footnote Coding Help File} K{\footnote Help;RTF} +{\footnote Coding:HelpFile} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b\keepn Help Source File Syntax \par}\li180 This topic describes the syntax and tokens used to develop help topics for  Microsoft Installer. For a complete reference, use the VC++ help file  {\uldb HCW.HLP}{\v RTFHelpRTFStatementReference@HCW.HLP}. \par\li0{\b General RTF notes}\par\li180 The RTF format used in help files is a subset of that used by word processors.  Some of the tokens have been usurped to have different meanings. Tokens always  begin with a backslash and must be followed with a space (ignored), another  backslash, or a brace character. Enclosing tokens within braces restricts their  effect to the text enclosed within the braces. The entire RTF souce file must  also be enclosed in a set of braces (take care not to delete the ending brace.) Line breaks are ignored in RTF files, but spaces are displayed except for the  space immediately following an RTF token. Avoid accidently use of tab characters.  When wrapping text, the space between words must be included. The convention here  to avoid errors is to indent each wrapped line by a single space. \par\li0{\b Text format tokens}\par\li180 These tokens change the following text style, independent of paragraph formatting.  The change ends when the value is restored, either by explicitly restoring the  previous value or preferably by enclosing the token with the affected text in braces.  Avoid using "{\f1\\plain}" as this will reset the font size set in the file header. {\f1\line   \\b     } Starts {\b bold} text, ends at {\f1\\b0} or closing {\f1\}}. {\f1\line   \\i     } Starts {\i italic} text, ends at {\f1\\i0} or closing {\f1\}}. {\f1\line   \\f1    } Starts {\f1 font number 1} (fixed-pitch here), ends at {\f1\\f0} or closing {\f1\}}. {\f1\line   \\fs16  } Starts {\fs16 font size 8} (half the value), ends at next {\f1\\fs} or closing {\f1\}}. \par\li0{\b Paragraph format tokens}\par\li180 These tokens affect line indentation and spacing, and will be reset either by  the {\f1 \\pard} token, or by the ending brace if the token is enclosed in braces. {\f1\line   \\tab    } Inserts a tab character, moves to the next tab stop {\f1\line   \\line   } Forced line feed within a paragraph {\f1\line   \\par    } Start a new paragraph {\f1\line   \\li300  } Specified the line indent from left margin in twips (1\1440 inch) {\f1\line   \\fi-100 } Specified the first line indent relative to the line indent {\f1\line   \\sb90   } Specifies the extra space before paragraph in twips {\f1\line   \\tx500  } Specifies the location of a single tab stop in twips \par\li0{\b Topic header tokens}\par\li180 These tokens must placed at the start of each topic.  Each topic must be terminated with a {\f1 \\page} token.  If build tags are specified, the topic will only be included based on the   {\f1\b BUILD} expression in the help project file (.HPJ).  Topics may be group into a browse sequence, enabling the next and previous buttons,  by specifiying browse identifiers with identical text before the colon.  The build tag and keyword tokens may be repeated as necessary. {\f1\line   *\{\\footnote VBA\}            } Optional build tag, must be first tokens {\f1\line   #\{\\footnote MsiFoo_MyFunc\}  } Required Topic Id, used by links and contents {\f1\line   $\{\\footnote MsiFoo.MyFunc\}  } Topic Title, diplayed in Find and History {\f1\line   +\{\\footnote MsiFoo:MyFunc\}  } Optional Browse Sequence Id, group and sequence {\f1\line   K\{\\footnote MyFunc;Internet\}} Optional list of keywords, separated by ';' \par\li0{\b Hot links}\par\li180 These paired tokens create hot spots, displayed as green underlined text. {\f1\line   \{\\uldb Hot Spot Text\}\{\\v Help_Topic\}  } Jumps to another topic {\f1\line   \{\\ul Hot Spot Text\}\{\\v Help_Topic\}    } Creates a popup window \par\li0{\b File header tokens}\par\li180 These tokens are required to appear at the start of each RTF file.  In addition, the default font size for the file is set to 10 points  with the token: {\f1 \\fs20}. {\f1\line   \\rtf1           } Identifies the file as RTF, must be first. {\f1\line   \\ansi           } Identifies the character set {\f1\line   \{\\fonttbl\{\\f0\\fswiss Arial;\}\{\\f1\\fmodern Courier New;\}\} }Font table {\f1\line   \{\\colortbl;\}    } Color table, only color 0, black, is used here. \page *{\footnote Dev} #{\footnote Coding_MemoryLeaks} ${\footnote Coding Memory Leaks} K{\footnote Memory Leaks} +{\footnote Coding:Memory Leaks} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b\keepn Tracking Down Memory Leaks \par}\li180 Memory errors come in two flavors.   Rarely seen, but possible is a  list of memory blocks not freed when the services DLL goes away.  More common is an assert the CMsiMalloc was not released and then a list  of memory blocks not freed.  The first case happens when everyone releases CMsiMalloc correctly.  The second happens when someone holds on to CMsiMalloc without releasing it  and we assert when the destructor for the object is called when the DLL is being  removed by the system.  Both give a stack backtrace of when the memory was allocated, hopefully with function  names. They should also print out the type of object and which allocation it was  made on.  In order to get the stack backtrace to give function names, you need some DLLs in your  system or system32 directory to allow Darwin to interpret the PDB files. On Win95 and NT you need imagehlp.dll and mspdb50.dll in your system32 directory. If you think you have this set-up and it's not working, see DavidMck. The memory management code also allows you to increase the size of the stack back trace  if you need more data kept to make it easier to debug. There is a #define at the beginning  of imemory.cpp for cFuncTrace. It is currently set to 4 by default. You can adjust it as  needed. The output of the asserts should go to the log file if the log is open and set on the command  line. Otherwise the output of all asserts goes to the file c:\msidbg.log. Generally memory leaks are either a simple case of not freeing something that was allocated, or  a more complex issue of a reference counting problem. We have integrated code to help track  down reference counting issues. See {\uldb Reference Tracking}{\v Coding_RefTracking} for  more information on those features. \page *{\footnote Dev} #{\footnote Coding_DebugMemMgr} ${\footnote Coding Debug Memory Manager} K{\footnote Debug Memory Manager} +{\footnote Coding:Debug Memory Manager} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b\keepn Hooking up the Debug memory manager \par}\li180 The debug memory manager is hooked up for the main darwin DLLs. There are two cases  where you will need to hook it up your self to either make debugging easier or get  your new object to work. The debug memory manager overloads the new and delete operators. In order to work, a global  piMalloc needs to be set (since we have globally defined the new and delete overloaded functions).  These functions are in imsimem.h.  In order to set piMalloc you need to call SetAllocator with a pointer to a services object.  The allocator will be retrieved from the services object. We also keep a count for the DLL of how  many objects have called SetAllocator. This is needed since some DLLs contain multiple objects  that do not hold references to each other.  When your object that called SetAllocator is being deleted, you will want to call ReleaseAllocator.  The object that calls SetAllocator, however, cannot be allocated with the overloaded new and delete  operators since piMalloc will probably not be set correctly. In order to handle this we have  functions AllocSpc and FreeSpc which should be included as public member functions of your class  as follows. \par\tab static void *operator new(size_t cb) \{ return AllocSpc(cb); \} \par\tab static void operator delete(void * pv) \{ FreeSpc(pv); \} If you include imsimem.h in all the source files of your DLL, and appropriately hook up SetAllocator,  ReleaseAllocator, AllocSpc and FreeSpc, you should have the Darwin memory management installed. I would  urge that we have this done in all our DLLs in order to track down memory issues. \page *{\footnote Dev} #{\footnote Coding_RefTracking} ${\footnote Coding Reference Tracking} K{\footnote Reference Tracking} +{\footnote Coding:Reference Tracking} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b\keepn Tracking Down Reference Counting Problems \par}\li180 The services DLL (and in the future other Darwin DLLs) has a reference counting harness built in  to it to aid in tracking down problems with AddRefs and Releases.  Currently it is only useful in tracking down problems where objects are not released correctly. I  plan to add code to handle the case where an object is released too many times. The code hooks in to the AddRef and Release calls and uses the CMsiRef ref object which encompases  the m_iRefCnt as well as pointers to keep a link list of objects and a list of reference counting  actions and the stack track of each action. Due to the overhead imposed by keeping the tracking data this functionality is turned on for individual  classes. The environment variable TRACK_OBJECTS should be set to a comma separated list of darwin iids  which you wish to have tracked (you just need to use the low byte of the iid so to track services  set TRACK_OBJECTS=B). A static object that is an object of the CMsiRefHead class checks for objects not deleted in its  destructor. At that point it will assert with a list of actions and the stack track for those actions.  This info is also placed in the debug log (since usually the normal log has been closed by this point  in the process).  Using this information it is usually quite simple to look at the log and pair up AddRef and Release  calls until you end up with one or more AddRefs that shouldn't have happened. Looking through the code  you can then uncover the problem. As with the memory manager you can increase the size of the stack backtrace that is recorded if you  need more information. In imsidbg.h the defined value cFuncStack defaults to 3 currently and can  be adjusted as necessary. \page *{\footnote Dev} #{\footnote Coding_CodeReview} ${\footnote Code Review guidelines} K{\footnote Code Review guidelines;Coding conventions;Variable naming} +{\footnote Coding: Code Review guidelines} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b\keepn Coding Conventions and Code Review Guidelines \par}\li180 {\b General Coding Conventions} {\ul Tabs}\line * Every 3 columns, i.e. 1,4,7..., but only before the first non-white space character on the line.\line * Use tabs rather than spaces to indent lines, no tabs between any text on a line.\line * Avoid trailing white space on a line (expecially important for help .RTF files).\line * Avoid lines greater than 80 characters when possible (hard to diff and print).\line * When wrapping lines with multiple arguments, indent (with tabs) to line up the args if possible.\line * A utility exists, FIXTAB.EXE (from OTOOLS), to indicate or correct tab problems.\line \line {\ul Braces}\line * Opening and closing braces line up with each other and with the enclosing scope.\line * Code within braces indented one tab stop.\line * Braces may optionally be omitted for single line clauses following if, else, for, etc.\line * Lines with switch case values are lined up with the switch braces, code lines are indented.\line {\b Variable naming} {\ul Global Variables}\line Use the "g_" prefix followed by the Hungarian name. Ex: int g_cInstances\line \line {\ul Member Data Variables}\line Use the "m_" prefix followed by the Hungarian name. Ex: int m_iRefCnt\line \line {\ul COM Object Methods}\line Use mixed-case non-Hungarian (OLE Standard); args use Hungarian prefixes.\line Ex: int GetPropertyLen(const ICHAR* szProperty)\line \line Methods that return enumerators should be named Get{Item}Enumerator. \line Ex: IEnumMsiString* GetSubFolderEnumerator()\line \line {\ul COM Pointers And References}\line Use the "pi" (pointer to interface) and "ri" (reference to interface) prefixes followed by the variable name,  followed by the object type.  Do not include the type of instance pointer in the hungarian prefix. For the standard Darwin objects, preferred naming convention examples are:\line \line IMsiString*:   piComponentString (not pistrComponent)\line IMsiRecord&:   riErrRecord (riErrRec is also common in Darwin code, and is ok)\line IMsiCursor*:   piFeatureCursor\line IMsiTable*:    piFeatureTable\line IMsiDatabase&: riDatabase\line IMsiEngine&:   riEngine\line IMsiPath&:     riSourcePath\line \line {\ul MsiString}\line Use the "str" prefix followed by the variable name. After the prefix follow the same convention as for COM pointers. Ex: MsiString strUserName.\line \line {\ul Wrapper COM Pointers (PMsi...)}\line Use the "p" prefix, followed by the same convention as for "COM Pointers and References".  Ex: PMsiRecord pErrorRecord(0); \line {\ul Usage of char[], ICHAR[], IMsiString, and MsiString types} IMsiString is Darwin's string interface. It provides reference-counted string handling. An MsiString  is a wrapper object around an IMsiString interface. The MsiString class simplifies string handling  by automating the reference-counting. Avoid the use of the char data type except where 8-bit bytes are used.  Use ICHAR to refer to text characters; this define is current char but eventually will be  changed to wchar_t (16-bit) when we convert Darwin to Unicode.  Avoid the direct use of strlen, strcpy, strcat (run-time library functions).  Use the string functions defined in ISTRING.H: IStrLen, IStrCopy, etc.  These are wrappers for system APIs that are DBCS enabled. These will change to Unicode someday.  For non-trivial string handling, use the IMsiString and MsiString objects. \line {\b Type} Avoid the use of Windows-defined macros, such as WORD, whenever possible; use the inherent C type instead.  The exception is local variables used directly as in/out parameters to Windows API.  For boolean values, use the Darwin Bool enum, to allow type checking and automation conversion.  Avoid #defines whenever possible; use "const int" or other const values instead. This allows full  type checking without generating additional code. Use the int type when size doesn't matter, since that is  processed most efficiently. \line {\b Header Files}  Only put defines in header files that are required by more than one source file. Otherwise,  dependencies may inadvertently be created by exposing internal structures.  Define derived implementation classes at the start of the .CPP file when possible.  Headers local to a module are put in the same directory as the .CPP files  Put detailed method comments in the help file, put the help file source name in the header  Put comments in the header file describing classes defined and include and define requirements. \line {\b Function calls} All calls to functions other than a member function of the current object, or a static member of another class,   should be qualified with one of the dummy specifiers below to indicate the API that is being used. Unspecified  global functions can use just a "::" prefix, such as ::operator new.\line \line Currently the following API dummy specifiers are defined (all defined to nothing):\line WIN::  - Win32 API call, fails on Mac\line MAC::  - Mac API call, fails on Win32\line OLE::  - OLE API call, fails on modules not using OLE\line AUT::  - Local automation DLL functions\line SRV::  - Local services DLL function\line LOC::  - Functions local to a file\line {\b Procedure headers} All procedures should be well documented, with all input and return parameters described.  If the procedure  is an interface function of any object exposed through an IMsi* COM interface, the documentation for that  function should reside in the MSIAUTO help file (not in the source code).  In this case, the function header  should be formatted like this example:\line  \line{\f1 IMsiRecord* CMsiEngine::GetFeatureCost(IMsiString& ristrFeature, int& iCost)\line //----------------------------------------------\line \{\line ...\line \}\line \line If the procedure is a local function (whether global, or a protected or private member of a class), then  the documentation should appear in the function header, as in this example:\line \line {\f1 ifiEnum CMsiPath::GetFileVersion(const ICHAR* szFullPath, int& riMS, int& riLS )\line /*----------------------------------------------------------------------------\line Gets the file version values from the given file and sets the given riMS & \line riLS variables.\line \line Arguments:\line szFullPath: a zero terminated character string containing the fully\line qualified path (including disk drive) to the file.\line riMS: Most significant 32 bits of source file version stamp.\line riLS: Least significant 32 bits of source file version stamp.\line Returns:\line ifiNoError-       Version retrieved successfully \line ifiNoFile-        Specified file does not exist\line ifiNoFileInfo-    Specified file has no version\line ifiFileInfoError- An error occurred while trying to retrieve the version\line ------------------------------------------------------------------------------*/\line \{\line ...\line \}\line \line {\b General Code Review Checklist} Here are a few of the important issues, and potential problems, to look for when reviewing code:\line \line * Are all input values and return values well-defined?\line \line * Are all return states well-defined and correct?\line \line * Are potential errors returned by function calls always being handled properly?\line \line * Are there any "magic numbers" that should be made into well-defined constants?\line \line * Are there any useful assertions (or other debugging code) missing?\line \line * Are comments correct and concise?\line \line * Any code that is commented or #IFDEF'ed out should either be taken out, or well commented  as to why the code isn't being used.\line \line * Are any header files included that are unnecessary?\line \line * Is there code here that duplicates code found elsewhere in the project?\line \line * Are there any local variables which are used only once, where a constant value might be better?\line \line * Are there any unnecessary globals?\line \line * Are there any other performance problems?\line \line {\b Specific problems to watch for} * Is the value returned by the GetLastError() system call being interpreted properly?  Remember that the error  code returned by GetLastError() gets reset on every system call (successful or not), so a better name for it  would be GetLastStatus().\line \page #{\footnote Coding_UsingMemMgr} ${\footnote Coding Using Debug Memory Manager} K{\footnote Using Debug Memory Manager} +{\footnote Coding:Using Debug Memory Manager} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b\keepn Using the Debug memory manager \par}\li180 The debug memory manager has several flags you can set to change how it works. Setting the environment variable DEBUGMEM or calling the {\uldb SetDebugFlags}{\v MsiMalloc_SetDebugFlags} method  on an allocator from VB allows you to set several flags. \par 1\tab Does not actually free memory.   Places it in a linked list for comparing with future free requests.  Useful for tracking down doubly freeing memory. \par 2\tab Logs all allocations to the debug log file. \par 4\tab Checks the status of all memory blocks when a block is allocated \par 8\tab Checks the status of all memory blocks when a block is freed. \par 16\tab Only initializes the symbol information when it's needed.  This is useful when tracking down a memory leak when the EXE terminates and frees  memory. There are currently problems with the symbol information being freed when  this happens. \page #{\footnote Coding_BuildingDatabases} ${\footnote Building the databases} K{\footnote Building the databases} +{\footnote Coding:Building the databases} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b\keepn Building the databases \par}\li180 The makefile currently builds five databases during the debug build process: {\f1 testdb.msi}, {\f1 template.msi},  {\f1 schema.msi}, {\f1 testcab.msi}, and {\f1 repack.msi} and then validates all five (validation won't catch  everything though). \par {\b Source directories for the databases}\line {\f1  testdb.msi    } %DARWIN%\\data\\testdb \line {\f1  template.msi  } %DARWIN%\\data\\template \line {\f1  schema.msi    } %DARWIN%\\data\\schema \line {\f1  testcab.msi   } %DARWIN%\\data\\testdb.cab \line {\f1  repack.msi    } %DARWIN%\\src\\tools\\repack\\support \line \par {\b Build order}\line {\f1 first  } schema.msi \line {\f1 second } template.msi \line {\f1 third  } testdb.msi \line {\f1 fourth } testcab.msi \line {\f1 fifth  } repack.msi \line \par {\b What's in the databases}\line {\f1 schema.msi   } contains defined _Validation table, all other table schemas (no row data)\line {\f1 template.msi } basic UI, install sequences and actions \line {\f1 testdb.msi   } UITEST, sample install \line {\f1 testcab.msi  } sample install \line {\f1 repack.msi   } repackager template database, some extra tables (i.e. SourceDirectory)\line \par {\b How built}\line {\f1 schema.msi   } create new, import from schema source\line {\f1 template.msi } create new, import from template source, merge in schema.msi \line {\f1 testdb.msi   } create new, import from testdb source, merge in template.msi \line {\f1 testcab.msi  } create new, import from testcab source, merge in template.msi, add msproj1.cab\line {\f1 repack.msi   } create new, import from repack source, merge in template.msi \line  \par {\b Making changes}\line\line {\f1 Table schema changes}\line \tab When adding, removing, or modifying columns or tables, always change the .idt file in  the schema source.  If the table also exists in one of the other four source directories, be sure to  change it there as well (or merge problems or worse could arrise). {\b Always remember to make  the change to the {\uldb Validation table}{\v _msi__Validation_Table@msi.hlp} as well.}  You will also have to  modify the _Validation table in %DARWIN%\\data\\testdb.cab\\validate as it is another copy of the  _Validation table which was required since the cabinets were generated before the decision to  enforce the primary key as token rule.\line\line {\f1 Bumping the Database version}\line \tab When the database version is bumped up, edit the _Summary.idt tables in all five source  directories.  Merging does not deal with the {\uldb Summary Information}{\v Summary_Overview} stream.\line\line  {\f1 Changing the _Validation table}\line  \tab When changing the entries in the _Validation table, be sure to change it in schema source and in   the _Validation table in %DARWIN%\\data\\testdb.cab\\validate.  If you add a new table particular to   only one database (and not any others), update or add the _Validation table and the entries required   for the new table or column.  During merging, the database will import those new entries and   receive the rest from the merging of the other database (which will bring schema.msi's _Validation   table).\line\line {\f1 Other}\line \tab Make sure all of the databases pass validation and that the '_MergeErrors' table is not  created as it means that merge conflicts occured and those conflicts should be investigated. \page #{\footnote Msispy_Tool} ${\footnote Msispy Tool} K{\footnote Msispy} +{\footnote Tool:Msispy} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MSISPY: A Tool to Display Component-Level View of System \par}\li180 \line {\i\b MSISPY} provides a component level view of the products and features installed on a system,  using either a Darwin database, or the registry information. Msispy also displays the status of  each, and allows you to partially or completely re-install missing or damaged items. You  can also  re-configure any product or feature, selecting the install level, and specifying whether to install  it locally or run it from a network server. \line\line {\b Menu Options}\line\line  Under the {\b File} Menu,\line \tab {\i\b Open Any Database} allows you to open an MSI package.\line \tab {\i\b Open Local Database} uses the registry information to display information about all the\line \tab   products installed on the computer.\line \tab {\i\b Load Saved Profile} allows you to load a profile of the system previously saved by Msispy.\line \tab {\i\b Restore Profile} (enabled only when a profile is loaded) attempts to restore the system\line \tab   to the saved profile. If more components have been added since the profile was saved, they\line \tab   are left untouched. If some products or components have been damaged since the profile was\line \tab   saved, msispy attempts to restore them by attempting to re-install them from the original\line \tab   source. If the source is not available, you are given the option to abort, retry or ignore.\line \tab {\i\b Save Current Profile} allows you to save a complete profile of the system onto a file. The\line \tab   information is stored in an easy to read text format. This information should not be modified\line \tab   directly.\line\line  Under the {\b View} Menu,\line \tab {\i\b Refresh} refreshes the display by getting the displayed information again and redrawing it.\line\line  Under the {\b Options} Menu, \line \tab {\i\b Diagnostic Mode} allows you to run msispy in either of the two modes- normal and diagnostic.\line \tab   In the Normal mode, a component's status is determined by the status of its key-file.\line \tab   In the Diagnostic mode, each file of the component is checked and the component status\line \tab   displayed is determined using this information. This gives a more accurate picture of the\line \tab   system, but make the program much slower.\line\line {\b Context Menus}\line\line When a product, feature or component is selected, clicking on the right mouse-button brings up the   context menus that allow you to perform operations on the selected item.\line\line All context menus have a {\i\b Properties} option, that brings up a property sheet containing information  about the selected item. In addition to the {\b General} tab that contains the information, the property  sheets also contain a {\b File List} tab, that contains information about all the files needed by the  selected item. The list of files contains information about the file including the component that uses it,  the file name and size when it was installed, the location of the file. In this tab, the {\b Verify Files}  button allows you to check the current status of the files. This button brings up a window with the current  file information, including current size, creation, last access and modification dates. If the file is not  found, or if the file size is different, the file is marked broken with an icon to the its left.\line\line {\b Important:} If a profile is in use, the verify files brings up information about the files {\i when the  profile was saved, not the current file information}.\line\line Additional context-menu choices cary depending on the item selected. When the selected item is a\line\line {\b Component}: The menu comprises \line \tab {\i\b Re-install Component} (enabled only if the component is broken), which allows you to re-install\line \tab   the component from it's original install source.\line\line {\b Installed Feature or Product}: The menu comprises \line \tab {\i\b Re-install}, which allows you to use one of the available re-install modes, including\line \tab   options to re-install just the damaged or missing files. Other options allow you to force all \line \tab   the files to be re-installed, the registry entries to be verified, and so on.\line \tab {\i\b Configure}, which allows you to install the feature on your local machine, or run it\line \tab   from a remote source. Some features may have components that need to be installed on the local\line \tab   machine. Attempting to install such features to run from a remote location will lead to a mix\line \tab   of some components being on the local system and the rest at the remote location.\line \tab {\i\b Un-install}, which allows you to un-install the product or feature. If a feature with\line \tab   sub-features is un-installed, all of its sub-features will be un-installed as well.\line\line {\b Uninstalled Product or Feature}: If an MSI package for a product not installed on the local system \line \tab   is in use, the context menu has the following options:\line \tab {\i\b Install Product}, which will install the product on the local system using the default options\line \tab {\i\b Advertise Product}, which will advertise the product on to the local system. This will \line \tab   set all the registry entries needed for the product, but will not actually install any files \line \tab   on the local system. The files will be transferred in when the component they belong to is used.\line\line {\b Product or Feature in a Profile}: The menu always comprises:\line \tab {\i\b Restore Profile}, which has the same functionality as {\b Restore Saved Profile} described above.\line\line {\b Command Line Syntax:} \line {\b msispy } \page
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\help\property.rtf ===
{\rtf1\ansi {\fonttbl{\f0\fswiss Helv;}{\f1\fmodern Courier New;}} {\colortbl;} \fs20 #{\footnote Property_Contents} ${\footnote Property Contents} K{\footnote Property Summary; Hardware; System} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Standard Properties \line\fs18\b0\tx2400\tab{\uldb Msi Objects}{\v Msi_Objects} \tx4500\tx6600\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par} The following properties are defined by the Microsoft Installer.  Additional properties may be specified by authored data or custom actions.  Properties whose names are entirely upper case can be specified on  the command line or as resources within the launcher. \par\li0{\b Component Locations}\par\li180 {\uldb DATABASE}{\v Property_DATABASE}\tab {\uldb SOURCEDIR}{\v Property_SOURCEDIR}\tab {\uldb TARGETDIR}{\v Property_TARGETDIR}\line {\uldb INSTALLER}{\v Property_INSTALLER}\tab \par\li0{\b Feature Installation Options}\par\li180 {\uldb ADDLOCAL}{\v Property_ADDLOCAL}\tab {\uldb ADDSOURCE}{\v Property_ADDSOURCE}\tab {\uldb REMOVE}{\v Property_REMOVE}\line {\uldb REINSTALL}{\v Property_REINSTALL}\tab {\uldb COMPADDLOCAL}{\v Property_COMPADDLOCAL}\tab {\uldb COMPADDSOURCE}{\v Property_COMPADDSOURCE}\tab {\uldb FILEADDLOCAL}{\v Property_FILEADDLOCAL}\tab {\uldb FILEADDSOURCE}{\v Property_FILEADDSOURCE}\tab \par\li0{\b Other Configurable Properties}\par\li180 {\uldb ACTION}{\v Property_ACTION}\tab {\uldb ALLUSERS}{\v Property_ALLUSERS}\tab {\uldb CCP_DRIVE}{\v Property_CCP_DRIVE}\tab {\uldb EXECUTEMODE}{\v Property_EXECUTEMODE}\tab {\uldb INSTALLLEVEL}{\v Property_INSTALLLEVEL}\tab {\uldb LOGACTION}{\v Property_LOGACTION}\tab {\uldb LOGFILE}{\v Property_LOGFILE}\tab {\uldb LOGMODE}{\v Property_LOGMODE} {\uldb MESSAGEBASE}{\v Property_MESSAGEBASE}\line {\uldb REBOOT}{\v Property_REBOOT}\line {\uldb ROOTDRIVE}{\v Property_ROOTDRIVE}\tab {\uldb SCRIPTFILE}{\v Property_SCRIPTFILE}\tab {\uldb SHORTFILENAMES}{\v Property_SHORTFILENAMES}\line {\uldb TRANSFORMS}{\v Property_TRANSFORMS}\tab {\uldb NOUI}{\v Property_NOUI}\tab \par\li0{\b Advertise/Admin install related information}\par\li180 {\uldb ADTFOLDER}{\v Property_ADTFOLDER}\tab {\uldb ADTSTARTFOLDER}{\v Property_ADTSTARTFOLDER}\tab \par\li0{\b User-Supplied Information}\par\li180 {\uldb COMPANYNAME}{\v Property_COMPANYNAME}\tab {\uldb PRODUCTID}{\v Property_PRODUCTID}\tab {\uldb USERNAME}{\v Property_USERNAME} \par\li0{\b Product-specific Properties Specified in the Property Table}\par\li180 {\uldb ProductCode}{\v Property_ProductCode}\tab {\uldb ProductName}{\v Property_ProductName}\tab {\uldb ProductVersion}{\v Property_ProductVersion}\tab {\uldb ProductLanguage}{\v Property_ProductLanguage}\line {\uldb Manufacturer}{\v Property_Manufacturer}\tab {\uldb PIDTemplate}{\v Property_PIDTemplate}\tab {\uldb DiskPrompt}{\v Property_DiskPrompt}\tab {\uldb DiskSerial}{\v Property_DiskSerial}\line {\uldb ComponentDownload}{\v Property_ComponentDownload}\tab {\uldb SupportPhone}{\v Property_SupportPhone}\tab {\uldb SupportURL}{\v Property_SupportURL}\tab {\uldb LeftUnit}{\v Property_LeftUnit}\tab \par\li0{\b System Folders} - Set by Microsoft Installer as startup\par\li180 {\uldb AppDataFolder}{\v Property_AppDataFolder}\tab {\uldb CommonFilesFolder}{\v Property_CommonFilesFolder}\tab {\uldb DesktopFolder}{\v Property_DesktopFolder}\tab {\uldb FavoritesFolder}{\v Property_FavoritesFolder}\line {\uldb FontsFolder}{\v Property_FontsFolder}\tab {\uldb NetHoodFolder}{\v Property_NetHoodFolder}\tab {\uldb PersonalFolder}{\v Property_PersonalFolder}\tab {\uldb PrintHoodFolder}{\v Property_PrintHoodFolder}\line {\uldb ProgramFilesFolder}{\v Property_ProgramFilesFolder}\tab {\uldb ProgramMenuFolder}{\v Property_ProgramMenuFolder}\tab {\uldb RecentFolder}{\v Property_RecentFolder}\tab {\uldb SendToFolder}{\v Property_SendToFolder}\line {\uldb StartMenuFolder}{\v Property_StartMenuFolder}\tab {\uldb StartupFolder}{\v Property_StartupFolder}\tab {\uldb System16Folder}{\v Property_System16Folder}\tab {\uldb SystemFolder}{\v Property_SystemFolder}\line {\uldb TempFolder}{\v Property_TempFolder}\tab {\uldb TemplateFolder}{\v Property_TemplateFolder}\tab {\uldb WindowsFolder}{\v Property_WindowsFolder}\tab \par\li0{\b Operating System Properties} - Set by Microsoft Installer at startup\par\li180 {\uldb Bidirectional}{\v Property_Bidirectional}\tab {\uldb ComputerName}{\v Property_ComputerName}\tab {\uldb IME}{\v Property_IME}\tab {\uldb Language}{\v Property_Language}\line {\uldb LanguageId}{\v Property_LanguageId}\tab {\uldb LogonUser}{\v Property_LogonUser}\tab {\uldb Modem}{\v Property_Modem}\tab {\uldb Network}{\v Property_Network}\line {\uldb Security}{\v Property_Security}\tab {\uldb SharedWindows}{\v Property_SharedWindows}\tab {\uldb Sound}{\v Property_Sound}\tab {\uldb Version95}{\v Property_Version95}\line {\uldb VersionNT}{\v Property_VersionNT}\tab {\uldb WindowsBuild}{\v Property_WindowsBuild} \par\li0{\b Hardware Properties} - Set by Microsoft Installer at startup\par\li180 {\uldb Alpha}{\v Property_Alpha}\tab {\uldb BorderSide}{\v Property_BorderSide}\tab {\uldb BorderTop}{\v Property_BorderTop}\tab {\uldb CaptionHeight}{\v Property_CaptionHeight}\line {\uldb ColorBits}{\v Property_ColorBits}\tab {\uldb Intel}{\v Property_Intel}\tab {\uldb PhysicalMemory}{\v Property_PhysicalMemory}{\v}\line {\uldb ScreenX}{\v Property_ScreenX}\tab {\uldb ScreenY}{\v Property_ScreenY}\tab {\uldb TextHeight}{\v Property_TextHeight}\line {\uldb VirtualMemory}{\v Property_VirtualMemory}{\v}\tab \par\li0{\b Status Properties} - Updated by Microsoft Installer during install\par\li180 {\uldb Launcher}{\v Property_Launcher}\tab {\uldb CCPTrigger}{\v Property_CCPTrigger}\tab {\uldb Installed}{\v Property_Installed}\tab {\uldb OutOfDiskSpace}{\v Property_OutOfDiskSpace} {\uldb Preselected}{\v Property_Preselected}\tab {\uldb Resume}{\v Property_Resume}\tab {\uldb Time}{\v Property_Time}\tab {\uldb UpdateStarted}{\v Property_UpdateStarted}\tab \page #{\footnote Property_CCP_DRIVE} ${\footnote CCP_DRIVE Property} +{\footnote Property:CCP_DRIVE} K{\footnote CCP_DRIVE} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b CCP_DRIVE Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Property to be set to the root path on the removable volume that has the installation for  any of the qualifying products for CCP. \par\li0{\b Set By}\par\li180 Property table, launcher property, command line or throught the UI \par\li0{\b Used By}\par\li180 {\uldb RMCCPSearch}{\v _msi_RMCCPSearch_Action@msi.hlp} action. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_SOURCEDIR} ${\footnote SOURCEDIR Property} +{\footnote Property:SOURCEDIR} K{\footnote SOURCEDIR} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b SOURCEDIR Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Root directory containing the source files (either the source cabinet file, or the source file tree). \par\li0{\b Set By}\par\li180 Property table, launcher property, or command line \par\li0{\b Used By}\par\li180 Directory resolution actions \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 If not set otherwise, SOURCEDIR will default to the directory containing the {\uldb Launcher}{\v Launcher_Info}. \page #{\footnote Property_TARGETDIR} ${\footnote TARGETDIR Property} +{\footnote Property:TARGETDIR} K{\footnote TARGETDIR} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b TARGETDIR Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 TARGETDIR must be the name of one root in the  {\uldb Directory}{\v Directory_Table@msi.hlp} table. It is used as the location to copy  the {\uldb Launcher}{\v Launcher_Info} and the  {\uldb Installer installation package}{\v Installer_Installer} during an  Admin install. \par\li0{\b Set By}\par\li180 Command line, user interface, {\uldb CostFinalize}{\v _msi_CostFinalize_Action@msi.hlp} \par\li0{\b Used By}\par\li180 Actions. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_DATABASE} ${\footnote DATABASE Property} +{\footnote Property:DATABASE} K{\footnote DATABASE} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b DATABASE Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Database containing install tables \par\li0{\b Set By}\par\li180 {\uldb Launcher}{\v Launcher_Info} property or command line \par\li0{\b Used By}\par\li180 Used by launcher to open database \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 When creating an admin image, this property must be defined in a resource of  the launcher. It is not sufficient to specify this property on the command-line.  The value of this property is used to copy the correct database file to the  admin image in the {\uldb AdminInstallFinalize}{\v _msi_AdminInstallFinalize_Action@msi.hlp}  action. Also, if this property is defined in the launcher, the launcher can be used  with no command line options. \page #{\footnote Property_INSTALLER} ${\footnote INSTALLER Property} +{\footnote Property:INSTALLER} K{\footnote Installer} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b INSTALLER Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Location of {\uldb installer package for the Installer components}{\v Installer_Installer}. \par\li0{\b Set By}\par\li180 {\uldb Launcher}{\v Launcher_Info} property or command line. \par\li0{\b Used By}\par\li180 Launcher to locate the installer installation package. {\uldb AdminInstallFinalize}{\v _msi_AdminInstallFinalize_Action@msi.hlp} action  to locate the installer package to copy to admin image, only if a relative path is given. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 If the property value is not defined, the Installer must be resident on the system.  If a bare file name is supplied, the package is assumed to reside in the  same directory as the Launcher.  If the property value is a relative path, the components are  assumed to reside in that path beneath the Launcher's directory. \page #{\footnote Property_MESSAGEBASE} ${\footnote MESSAGEBASE Property} +{\footnote Property:MESSAGEBASE} K{\footnote MESSAGEBASE} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MESSAGEBASE Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Specifies the base of the error messages contained within the launcher.  These messages are used for errors that occur before the product database is successfully opened.  The order of messages must agree with the ieiEnum return codes from the installer. \par\li0{\b Set By}\par\li180 Launcher resource property only, must match resource string IDs. \par\li0{\b Used By}\par\li180 Installer to determine string IDs for error messages. \par\li0{\b Default Value}\par\li180 None. If not set, no error or status messages can be displayed. \page #{\footnote Property_INSTALLLEVEL} ${\footnote INSTALLLEVEL Property} +{\footnote Property:INSTALLLEVEL} K{\footnote INSTALLLEVEL} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b INSTALLLEVEL Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The initial 'level' at which features will be selected 'ON' for installation by default.  See the  {\uldb Feature}{\v _msi_Feature_Table@msi.hlp} table for further discussion of install levels. \par\li0{\b Set By}\par\li180 Property table or launcher property \par\li0{\b Used By}\par\li180 Selection resolution actions. \par\li0{\b Default Value}\par\li180 If no value is specified, the install level defaults to 1. \page #{\footnote Property_OutOfDiskSpace} ${\footnote OutOfDiskSpace Property} +{\footnote Property:OutOfDiskSpace} K{\footnote OutOfDiskSpace Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b OutOfDiskSpace Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This property is set to a value of TRUE by the {\uldb MsiSelectionManager}{\v MsiSelectionManager_Object}  if any volume that is a target of the current install has insufficient disk space to accomodate the   proposed installation.  If all volumes have sufficient space, the value is FALSE. \par\li0{\b Set By}\par\li180 The {\uldb MsiSelectionManager}{\v MsiSelectionManager_Object}.  This property is valid at any time after  the {\uldb CostInitialize}{\v _msi_CostInitialize_Action@msi.hlp} action has been executed.  The OutOfDiskSpace  property status is dynamically updated any time the total install cost is re-calculated (for example, any time  the install state of any feature is changed via the {\uldb Selection}{\v SpecialDialog_Selection} dialog). \par\li0{\b Used By}\par\li180 Selection resolution actions. \page #{\footnote Property_Installed} ${\footnote Installed Property} +{\footnote Property:Installed} K{\footnote Installed} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Installed Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Set when the product has already been installed. \par\li0{\b Set By}\par\li180 Engine at initialization. \par\li0{\b Used By}\par\li180 UI conditionalization.  May be used to show first-install or maintenance mode UI. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_Preselected} ${\footnote Preselected Property} +{\footnote Property:Preselected} K{\footnote Preselected} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Preselected Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Set when selections have been pre-determined and the selection dialog need not be shown.  This occurs when properties such as ADDLOCAL or REMOVE are set on the command line  or when a suspended install is being resumed. \par\li0{\b Set By}\par\li180 Engine at initialization. \par\li0{\b Used By}\par\li180 UI conditionalization.  May be used to suppress any dialogs used to make selections. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_UpdateStarted} ${\footnote UpdateStarted Property} +{\footnote Property:UpdateStarted} K{\footnote UpdateStarted} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b UpdateStarted Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Set when changes to the system have begun for this install.  This includes the case  when a suspended install is resumed. \par\li0{\b Set By}\par\li180 Engine at initialization. \par\li0{\b Used By}\par\li180 UI conditionalization.  If this property is set, the user should be asked whether to restore  or continue later after an error and cancellation. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_Resume} ${\footnote Resume Property} +{\footnote Property:Resume} K{\footnote Resume} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Resume Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Set when resuming a suspended install.  This property can be used to determine what text to  show the user in the UI.  For example, when not in resume mode the user could be asked  "Are you ready to install?" while in resume mode the user could be asked  "Are you ready to complete your install?". \par\li0{\b Set By}\par\li180 Engine at initialization. \par\li0{\b Used By}\par\li180 UI conditionalization. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_ACTION} ${\footnote ACTION Property} +{\footnote Property:ACTION} K{\footnote Action} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ACTION Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Specifies the intial action function that is called after the installer.  in initialized. \par\li0{\b Set By}\par\li180 Must be set by the launcher, normally to the {\b Install} action,   but may be changed to {\b Remove}, {\b Admin}, or other actions  with customized launchers. This property may also be overridden  on the command line. \par\li0{\b Used By}\par\li180 The value of the property is the name of the action to invoke after  the installer is successfully initialized. That action most like will  in turn invoke other actions, commonly by querying the Action table. \par\li0{\b Default Value}\par\li180 None. Install will fail if no action is specified. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_LOGFILE} ${\footnote LOGFILE Property} +{\footnote Property:LOGFILE} K{\footnote LOGFILE} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b LOGFILE Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Enables logging of messages by specifying a path to the file where the log  information is to be written. The file will be created if not present,  else any old log information from a previous installation will be overwritten  unless the append option is set by the {\uldb LOGMODE}{\v Property_LOGMODE} property.  The logfile is flushed after each line is posted, and it is closed when the  MsiServices object is destroyed. \par\li0{\b Set By}\par\li180 Normally set on the command line, but may be customized into the launcher. \par\li0{\b Used By}\par\li180 The file specified will be opened when the installer is initialized. The  initialization will fail if the log file cannot be opened. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 The first line of the log will be formatted according to the value of the  imgLogHeader entry in the Error table.  Log line formats are determined by the various message and action types,  as well by code that directly writes directly to the log.  The final line of the log will be formatted according to the value of the  imsgLogTrailer entry in the Error table. \page #{\footnote Property_REBOOT} ${\footnote REBOOT Property} +{\footnote Property:REBOOT} K{\footnote Reboot} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b REBOOT Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 If this property is set to "Force" the installation will reboot at the end, regardless of what the actions require. If the property is set to "Suppress" the installation will not reboot in case of reboots that happen at the end of the installation before the new program can be used. If the reboot is needed to continue the installation, the reboot will still take place. \par\li0{\b Set By}\par\li180 Normally set on the command line, but may be customized into the launcher. \par\li0{\b Used By}\par\li180 By the Engine at termination to override the reboot decision made by the actions. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 This property is typically used by an administrator who installs several products at the same time and wants to have only one reboot at the end of the series of installations. \page #{\footnote Property_LOGMODE} ${\footnote LOGMODE Property} +{\footnote Property:LOGMODE} K{\footnote LOGMODE} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b LOGMODE Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 A string containing letters that specify which messages are to be written  to the log file. Options are case-insensitive and order-independent. \par\li0{\b Set By}\par\li180 Launcher resource or command-line setting. \par\li0{\b Used By}\par\li180 MsiEngine uses the value to initialize the logging for the various message types,  only if the {\uldb LOGFILE}{\v Property_LOGFILE} property has been defined. \par\li0{\b Default Value}\par\li180 None. Internal default log options, "dewarim", are used if this property is undefined. \par\li0{\b Log Option Codes} - for message types: {\uldb MsiHandler.Message}{\v MsiHandler_Message}\par\li180 {\f1  i  (imtInfo)        } Informational-only messages\line {\f1  w  (imtWarning)     } Warning messages, not fatal\line {\f1  e  (imtError)       } Error messages, may be fatal\line {\f1  d  (imtDiagnostic)  } Diagnostics, debug build only\line {\f1  a  (imtActionStart) } Start of action notification\line {\f1  r  (imtActionData)  } Action data record, contents action-specific\line {\f1  u  (imtUser)        } User request messages\line {\f1  c  (imtCommonData)     } UI control messages\line {\f1  m  (imtOutOfMemory) } Out of memory messages\line {\f1  p                   } Dump property table, "property = value" at MsiEngine.Terminate {\f1  +                   } Append to existing logfile \page #{\footnote Property_LOGACTION} ${\footnote LOGACTION Property} +{\footnote Property:LOGACTION} K{\footnote LOGACTION} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b LOGACTION Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 A list of action names, separated only by semicolons (no spaces), for which logging will  occur. \par\li0{\b Set By}\par\li180 Normally set on the command line, but could be customized into the launcher. \par\li0{\b Used By}\par\li180 MsiEngine.Message \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 The action names in this property are case-insensitive. The list may optionally end with a semicolon. \page #{\footnote Property_ROOTDRIVE} ${\footnote ROOTDRIVE Property} +{\footnote Property:ROOTDRIVE} K{\footnote ROOTDRIVE} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ROOTDRIVE Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 When not in Admin mode, ROOTDRIVE supplies the default paths for any  undefined root directories in the {\uldb Directory}{\v Directory_Table@msi.hlp}  table. If not already defined, this property is defined by the  {\uldb CostInitialize}{\v _msi_CostInitialize_Action@msi.hlp} action to the local  volume with the most available disk space. \par\li0{\b Set By}\par\li180 DirectoryInitialize action, command line \par\li0{\b Used By}\par\li180 {\uldb CreateTargetPaths}{\v MsiDirectoryManager_CreateTargetPaths}  method of the {\uldb MsiDirectoryManager}{\v MsiDirectoryManager_Object} object. \par\li0{\b Default Value}\par\li180 None. (Defined to path of local volume with most available disk space by  DirectoryInitialize) \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_NOUI} ${\footnote NOUI Property} +{\footnote Property:NOUI} K{\footnote NOUI Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b NOUI Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 If this property is set, the UI level used when installing this package is capped  as Basic.  This property can be used when a package has no authored UI to use the  Installer's built in default UI. \par\li0{\b Set By}\par\li180 Property table or command line. \par\li0{\b Used By}\par\li180 Installer to determine what UI to display. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_EXECUTEMODE} ${\footnote EXECUTEMODE Property} +{\footnote Property:EXECUTEMODE} K{\footnote EXECUTEMODE Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b EXECUTEMODE Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The mode of execution performed by the installer. This property can have one of the  following values: \par\li360 {\f1\b None   } No changes are made to the system, although the UI and database querying are  executed normally.\line {\f1\b Direct } All changes to the system are executed directly by the client, without  using script files. This mode is not  valid when the installer runs in client-server mode. In this case, the execution mode  defaults to None.\line {\f1\b Script } All changes to the system are made through script execution. This is the  default mode. \par\li180 Note that only the first letter of this property value is examined, case insensitively. \par\li0{\b Set By}\par\li180 Launcher property or command line. \par\li0{\b Used By}\par\li180 Engine to determine how to execute system updates. \par\li0{\b Default Value}\par\li180 If not defined, the execution mode defaults to Script. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_SCRIPTFILE} ${\footnote SCRIPTFILE Property} +{\footnote Property:SCRIPTFILE} K{\footnote SCRIPTFILE Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b SCRIPTFILE Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 If this property is set, a script file is created containing all operations executed  during the install. This property defines the location of the script file. If a relative  path is given, the path is assumed to be relative to the location of the launcher. \par\li0{\b Set By}\par\li180 Launcher property or command line. \par\li0{\b Used By}\par\li180 Engine to determine if and where to create a script file. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 This property is completely unrelated to the {\uldb EXECUTEMODE}{\v Property_EXECUTEMODE}  property. In other words, if this property is set, the script will be created regardless  of the installer's execution mode. \page #{\footnote Property_ADDLOCAL} ${\footnote ADDLOCAL Property} +{\footnote Property:ADDLOCAL} K{\footnote ADDLOCAL Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ADDLOCAL Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The property value denotes a list of features, delimited by semi-colons, that are to be installed  locally. The features listed are to be found in the {\b Feature } column of the  {\uldb Feature }{\v _msi_Feature_Table@msi.hlp} table. Optionally, the value could be {\b All } to denote  installing all features locally. Thus, if you wish to install all features locally  you would provide the command line {\b ADDLOCAL=All } to the installer. \par\li0{\b Set By}\par\li180 Launcher property or command line. \par\li0{\b Used By}\par\li180 Engine to determine what Features to set to be installed locally. \par\li0{\b Default Value}\par\li180 \par\li0{\b Remarks}\par\li180 Note that the feature names are case-sensitive. Also note that if the {\b\i RunFromSource } column  of the {\uldb Component }{\v _msi_Component_Table@msi.hlp} table for a component has a value of {\b irsSourceOnly }  then the component is installed as run from source. \page #{\footnote Property_ADDSOURCE} ${\footnote ADDSOURCE Property} +{\footnote Property:ADDSOURCE} K{\footnote ADDSOURCE Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ADDSOURCE Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The property value denotes a list of features, delimited by semi-colons, that are to be installed  to run from source. The features listed are to be found in the {\b Feature } column of the  {\uldb Feature }{\v _msi_Feature_Table@msi.hlp} table. Optionally, the value could be {\b All } to denote  installing all features to run from source. Thus, if you wish to install all features as run from source  you would provide the command line {\b ADDSOURCE=All } to the installer. \par\li0{\b Set By}\par\li180 Launcher property or command line. \par\li0{\b Used By}\par\li180 Engine to determine what Features to set to be installed as run from source. \par\li0{\b Default Value}\par\li180 \par\li0{\b Remarks}\par\li180 Note that the feature names are case-sensitive. Also note that if the {\b\i RunFromSource } column  of the {\uldb Component }{\v _msi_Component_Table@msi.hlp} table for a component has a value of {\b irsLocalOnly} then the  component is installed locally. \page #{\footnote Property_REMOVE} ${\footnote REMOVE Property} +{\footnote Property:REMOVE} K{\footnote REMOVE Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b REMOVE Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The property value denotes a list of features, delimited by semi-colons, that are to be removed, if  installed. The features listed are to be found in the {\b Feature } column of the  {\uldb Feature }{\v _msi_Feature_Table@msi.hlp} table. Optionally, the value could be {\b All } to denote  removing all features. Thus, if you wish to remove all features (i.e. uninstall the entire product),  you would provide the command line {\b REMOVE=All } to the installer. \par\li0{\b Set By}\par\li180 Launcher property or command line. \par\li0{\b Used By}\par\li180 Engine to determine what Features to set to be removed. \par\li0{\b Default Value}\par\li180 \par\li0{\b Remarks}\par\li180 Note that the feature names are case-sensitive. \page #{\footnote Property_REINSTALL} ${\footnote REINSTALL Property} +{\footnote Property:REINSTALL} K{\footnote REINSTALL Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b REINSTALL Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The property value denotes a list of features, delimited by semi-colons, that are to be reinstalled.   The features listed are to be found in the {\b Feature } column of the  {\uldb Feature }{\v _msi_Feature_Table@msi.hlp} table. Optionally, the value could be {\b All } to denote  reinstalling all features. Thus, if you wish to reinstall all features you would provide the  command line {\b REINSTALL=All } to the installer. \par\li0{\b Set By}\par\li180 Launcher property or command line. \par\li0{\b Used By}\par\li180 Engine to determine what Features to set to be reinstalled. \par\li0{\b Default Value}\par\li180 \par\li0{\b Remarks}\par\li180 Note that the feature names are case-sensitive. \line \line If the REINSTALL property is set, the {\uldb REINSTALLMODE}{\v Property_REINSTALLMODE} property should  also be set, to indicate the type of reinstall to be performed.  If the REINSTALLMODE property is not  set, then by default all files that are currently installed will be reinstalled, IF the currently  installed file is a lesser version (or is not present). By default, no registry entries will be rewritten.\line \line Note that even if REINSTALL is set to "ALL", only those features that were already installed previously  will be reinstalled.  Thus, if REINSTALL is set for a product that is yet to be installed, no installation  action will take place at all. \page #{\footnote Property_REINSTALLMODE} ${\footnote REINSTALLMODE Property} +{\footnote Property:REINSTALLMODE} K{\footnote REINSTALLMODE Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b REINSTALLMODE Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 A string containing letters that specify the type of reinstall to perform. Options are case-insensitive  and order-independent.  This property should normally always be used in conjunction with the  {\uldb REINSTALL}{\v Property_REINSTALL} property.  \par\li0{\b Set By}\par\li180 Launcher resource or command-line setting. \par\li0{\b Used By}\par\li180 MsiEngine uses the value to determine the type of reinstall (if any) to perform. \par\li0{\b Default Value}\par\li180 By default the REINSTALLMODE is "romus". \par\li0{\b Reinstall Option Codes}\line {\f1  r  (iefInstallEnable)              } Enable {\b r}einstall of any files/registry found to be invalid.\line {\f1  p  (iefOverwriteNone)              } Reinstall only if file is missing (i.e. verify that the file is {\b p}resent).\line {\f1  o  (iefOverwriteOlderVersions)     } Reinstall if file is missing, or an {\b o}lder version is present.\line {\f1  e  (iefOverwriteEqualVersions)     } Reinstall if file is missing, or an {\b e}qual or older version is present.\line {\f1  d  (iefOverwriteDifferingVersions) } Reinstall if file is missing, or a {\b d}ifferent version is present.\line {\f1  c  (iefOverwriteCorruptedFiles)    } Reinstall if file is missing, or {\b c}orrupt (i.e. the stored checksum doesn't match the computed value).\line {\f1  a  (iefOverwriteAllFiles)          } Force {\b a}ll files to be reinstalled, regardless of checksum or version\line {\f1  u  (iefInstallUserData)            } Re-write all required {\b u}ser registry entries.\line {\f1  m  (iefInstallMachineData)         } Re-write all required local {\b m}achine registry entries.\line {\f1  s  (iefInstallShortcuts)           } Reinstall all {\b s}hortcuts, overwriting any existing shortcut.\line All of the reinstall options shown above, except for iefInstallEnable, can actually be thought of as "detection"  flags, which are used to detect that the feature or features specified by the REINSTALL property are installed properly.  If any of the specified detection operations fail during the reinstall, this fact will be logged for informational  purposes. However, the invalid installation will actually be repaired only if the iefInstallEnable option is also set.  For example, if the iefOverwriteCorruptedFiles flag is set, corrupted files will be detected and logged on reinstall,  but the corrupted files will actually be repaired (by reinstallation) only if the iefInstallEnable flag is also  specified. If the REINSTALLMODE property is defined without the REINSTALL property defined, then the specified "detection"  modes still apply; however, only those features that are selected normally for install will actually be "reinstalled".  Thus, in this case, REINSTALLMODE actually specifies the "overwrite" mode for a normal install. {\b Note:} only those files that are designated in the {\uldb File}{\v _msi_File_Table@msi.hlp} table as containing checksum information  will ever be verified for accurate checksum. \page #{\footnote Property_COMPADDLOCAL} ${\footnote COMPADDLOCAL Property} +{\footnote Property:COMPADDLOCAL} K{\footnote COMPADDLOCAL Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b COMPADDLOCAL Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The property value denotes a list of component ID's, delimited by semi-colons, that are to be installed  locally. Specifically, for each listed component ID, the installer examines all features linked   (via the {\uldb FeatureComponents}{\v _msi_FeatureComponents_Table@msi.hlp} table) to that component, and installs the  "cheapest" feature (i.e. the feature that would require the least amount of disk space to install).  The components listed are to be found in the {\b Component } column of the  {\uldb Component }{\v _msi_Component_Table@msi.hlp} table. \par\li0{\b Set By}\par\li180 Launcher property or command line. \par\li0{\b Used By}\par\li180 Engine to determine what Feature(s) to set to be installed locally, based on the specified component(s). \par\li0{\b Default Value}\par\li180 \par\li0{\b Remarks}\par\li180 Note that the component names are case-sensitive. Also note that if the {\b\i RunFromSource } column  of the {\uldb Component }{\v _msi_Component_Table@msi.hlp} table for a component has a value of {\b irsSourceOnly }  then the component will be installed to run from source. \page #{\footnote Property_COMPADDSOURCE} ${\footnote COMPADDSOURCE Property} +{\footnote Property:COMPADDSOURCE} K{\footnote COMPADDSOURCE Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b COMPADDSOURCE Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The property value denotes a list of component ID's, delimited by semi-colons, that are to be installed  to run from the source media. Specifically, for each listed component ID, the installer examines all  features linked (via the {\uldb FeatureComponents}{\v _msi_FeatureComponents_Table@msi.hlp} table) to that  component, and installs the "cheapest" feature (i.e. the feature that would require the least  amount of disk space to install). The components listed are to be found in the {\b Component }  column of the {\uldb Component }{\v _msi_Component_Table@msi.hlp} table. \par\li0{\b Set By}\par\li180 Launcher property or command line. \par\li0{\b Used By}\par\li180 Engine to determine what Feature(s) to set to be installed to run from source, based on the specified component(s). \par\li0{\b Default Value}\par\li180 \par\li0{\b Remarks}\par\li180 Note that the component names are case-sensitive. Also note that if the {\b\i RunFromSource } column  of the {\uldb Component }{\v _msi_Component_Table@msi.hlp} table for a component has a value of {\b irsLocalOnly }  then the component will be installed to run locally. \page #{\footnote Property_FILEADDLOCAL} ${\footnote FILEADDLOCAL Property} +{\footnote Property:FILEADDLOCAL} K{\footnote FILEADDLOCAL Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b FILEADDLOCAL Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The property value denotes a list of file keys, delimited by semi-colons, that are to be installed  to run locally. Specifically, for each listed file key, the installer determines the  component that controls that file, then examines all features linked   (via the {\uldb FeatureComponents}{\v _msi_FeatureComponents_Table@msi.hlp} table) to that component, and installs the  "cheapest" feature (i.e. the feature that would require the least amount of disk space to install).  The file keys listed must be found in the {\b File } column of the  {\uldb File }{\v _msi_File_Table@msi.hlp} table. \par\li0{\b Set By}\par\li180 Launcher property or command line. \par\li0{\b Used By}\par\li180 Engine to determine what Feature(s) to set to be installed locally, based on the specified file key(s). \par\li0{\b Default Value}\par\li180 \par\li0{\b Remarks}\par\li180 Note that the file key names are case-sensitive. Also note that if the {\b\i RunFromSource } column  of the {\uldb Component }{\v _msi_Component_Table@msi.hlp} table for a component has a value of {\b irsSourceOnly }  then the component will be installed to run from source. \page #{\footnote Property_FILEADDSOURCE} ${\footnote FILEADDSOURCE Property} +{\footnote Property:FILEADDSOURCE} K{\footnote FILEADDSOURCE Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b FILEADDSOURCE Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The property value denotes a list of file keys, delimited by semi-colons, that are to be installed  to run from the source media. Specifically, for each listed file key, the installer determines the  component that controls that file, then examines all features linked   (via the {\uldb FeatureComponents}{\v _msi_FeatureComponents_Table@msi.hlp} table) to that component, and installs the  "cheapest" feature (i.e. the feature that would require the least amount of disk space to install).  The file keys listed must be found in the {\b File } column of the  {\uldb File }{\v _msi_File_Table@msi.hlp} table. \par\li0{\b Set By}\par\li180 Launcher property or command line. \par\li0{\b Used By}\par\li180 Engine to determine what Feature(s) to set to be installed to run from source, based on the specified file key(s). \par\li0{\b Default Value}\par\li180 \par\li0{\b Remarks}\par\li180 Note that the file key names are case-sensitive. Also note that if the {\b\i RunFromSource } column  of the {\uldb _msi_Component }{\v _msi_Component_Table@msi.hlp} table for a component has a value of {\b irsLocalOnly }  then the component will be installed to run locally. \page #{\footnote Property_ADTFOLDER} ${\footnote ADTFOLDER Property} +{\footnote Property:ADTFOLDER} K{\footnote ADTFOLDER Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ADTFOLDER Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The property is used during the advertise mode to determine the folder where to place the  proxy/proxies for the product. \par\li0{\b Set By}\par\li180 Launcher property, command line or set in the admin mode UI. \par\li0{\b Used By}\par\li180 Engine to determine where to create the proxy/proxies for the product when run in the  advertise mode. \par\li0{\b Default Value}\par\li180 \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_ADTSTARTFOLDER} ${\footnote ADTSTARTFOLDER Property} +{\footnote Property:ADTSTARTFOLDER} K{\footnote ADTSTARTFOLDER} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ADTSTARTFOLDER Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The property is used during the advertise mode to determine the folder where to place the  shortcut(s) to the proxy/proxies for the product. \par\li0{\b Set By}\par\li180 Launcher property, command line or set in the admin mode UI. \par\li0{\b Used By}\par\li180 Engine to determine where to create the shortcut(s) to the proxy/proxies for the product  when run in the advertise mode. \par\li0{\b Default Value}\par\li180 \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_ALLUSERS} ${\footnote ALLUSERS Property} +{\footnote Property:ALLUSERS} K{\footnote ALLUSERS} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ALLUSERS Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 If this property is set, the folder properties representing folders in a profile  are set to the folders in the "All Users" profile, if such a profile exists.  Otherwise,  those properties are set to folders in the user's personal profile. \par\li0{\b Set By}\par\li180 Launcher property, command line. \par\li0{\b Used By}\par\li180 {\uldb SetPlatformProperties}{\v MsiServices_SetPlatformProperties}. \par\li0{\b Default Value}\par\li180 None. May be undefined. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_USERNAME} ${\footnote USERNAME Property} +{\footnote Property:USERNAME} K{\footnote USERNAME} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b USERNAME Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 User performing installation \par\li0{\b Set By}\par\li180 Set by registry properties, overridable on command line \par\li0{\b Used By}\par\li180 Used by UI dialogs, and ultimately for personalization actions \par\li0{\b Default Value}\par\li180 Default value may be put in database Property table \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_COMPANYNAME} ${\footnote COMPANYNAME Property} +{\footnote Property:COMPANYNAME} K{\footnote COMPANYNAME} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b COMPANYNAME Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Organization for user performing the installation \par\li0{\b Set By}\par\li180 Set by registry properties, overridable on command line or launcher property. \par\li0{\b Used By}\par\li180 Used by UI dialogs, and ultimately for personalization actions \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_PRODUCTID} ${\footnote PRODUCTID Property} +{\footnote Property:PRODUCTID} K{\footnote PRODUCTID} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b PRODUCTID Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This property initially contains the part of the Product ID entered by the user, and after validation it contains the complete ID. \par\li0{\b Set By}\par\li180 The initial value can be set on the command line or through the UI. At this point the property contains only the part of the Product ID that has to be entered by the user. The {\uldb ValidateProductID}{\v MsiEngine_ValidateProductID} validates this value by comparing it to the {\uldb PIDTemplate}{\v Property_PIDTemplate} property. This method also adds the needed random digits and makes other modifications. Upon successfull validation the value of this property is changed to the complete Product ID. \par\li0{\b Used By}\par\li180 The value is used and modified by the ValidateProductID method, and displayed and modified by the UI. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_LeftUnit} ${\footnote LeftUnit Property} +{\footnote Property:LeftUnit} K{\footnote LeftUnit} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b LeftUnit Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 If this property is set, the unit is placed to the left of the number instead of the usual right hand side. This is needed to accomodate languages where this is the accepted format.  \par\li0{\b Set By}\par\li180 The value is set in the {\uldb Property Table}{\v _msi_Property_Table@msi.hlp}.  \par\li0{\b Used By}\par\li180 The property is used by the UI when displaying the size of files and the available space on different volumes. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_PIDTemplate} ${\footnote PIDTemplate Property} +{\footnote Property:PIDTemplate} K{\footnote PIDTemplate} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b PIDTemplate Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This property contains the string used as a template for the {\uldb PRODUCTID}{\v Property_PRODUCTID}. For the syntax used in the template, see the {\uldb MaskedEdit}{\v ControlType_MaskedEdit} control type. Removal of this property indicates that the Product ID has been successfuly validated. \par\li0{\b Set By}\par\li180 The value is initialy set in the {\uldb Property Table}{\v _msi_Property_Table@msi.hlp}. It is modified (removed) by the {\uldb ValidateProductID}{\v MsiEngine_ValidateProductID} method upon successful validation. \par\li0{\b Used By}\par\li180 The property is used by the ValidateProductID method and the UI when displaying the Product ID. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_CCPTrigger} ${\footnote CCPTrigger Property} +{\footnote Property:CCPTrigger} K{\footnote CCPTrigger} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b CCPTrigger Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 If the {\uldb PIDTemplate}{\v Property_PIDTemplate} contains a "=" character indicating a special CCP digit, this digit is pulled from the Product ID upon validation and saved in this property. \par\li0{\b Set By}\par\li180 The {\uldb ValidateProductID}{\v MsiEngine_ValidateProductID} method. \par\li0{\b Used By}\par\li180 CCP??? \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_Launcher} ${\footnote Launcher Property} +{\footnote Property:Launcher} K{\footnote Launcher} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Launcher Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The path to the laucher when an installation in invoked using an Installer API call. \par\li0{\b Set By}\par\li180 Installer API functions that take a launcher argument, pass it to the engine as this property. \par\li0{\b Used By}\par\li180 Installer initialization to determine location of launcher resources. \par\li0{\b Default Value}\par\li180 None. \page #{\footnote Property_ProductCode} ${\footnote ProductCode Property} +{\footnote Property:ProductCode} K{\footnote ProductCode} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ProductCode Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 A unique identifier for the particular product release,  represented as a string GUID, e.g. "\{12345678-1234-1234-1234-123456789012\}".  This ID must differ for different versions and languages. \par\li0{\b Set By}\par\li180 Authored into Property table. REQUIRED. \par\li0{\b Used By}\par\li180 Advertised as a product property, as the primary method of specifying the product. \par\li0{\b Default Value}\par\li180 None. \page #{\footnote Property_ProductName} ${\footnote ProductName Property} +{\footnote Property:ProductName} K{\footnote ProductName} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ProductName Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The ProductName property contains the human-readable name of the application being installed  (e.g. Microsoft Office 97). This is only used for display purposes. \par\li0{\b Set By}\par\li180 Authored into Property table. REQUIRED. May be changed by transform. \par\li0{\b Used By}\par\li180 Advertised as a product property. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_ProductVersion} ${\footnote ProductVersion Property} +{\footnote Property:ProductVersion} K{\footnote ProductVersion} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ProductVersion Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The string format of the product version. \par\li0{\b Set By}\par\li180 Authored into Property table. REQUIRED. \par\li0{\b Used By}\par\li180 Advertised as a product property, as a numeric value \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 Only the major and minor versions are used for the advertised property. \page #{\footnote Property_ProductLanguage} ${\footnote ProductLanguage Property} +{\footnote Property:ProductLanguage} K{\footnote ProductLanguage} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ProductLanguage Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The numeric language ID  \par\li0{\b Set By}\par\li180 Authored into Property table. REQUIRED. May be changed by transform. \par\li0{\b Used By}\par\li180 Advertised as a product property. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 The language in the summary information stream is to be set from this value. \page #{\footnote Property_Manufacturer} ${\footnote Manufacturer Property} +{\footnote Property:Manufacturer} K{\footnote Manufacturer} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Manufacturer Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The name of the manufacturer for the product. \par\li0{\b Set By}\par\li180 Authored into Property table. REQUIRED. \par\li0{\b Used By}\par\li180 Advertised as a product property. \par\li0{\b Default Value}\par\li180 None. \page #{\footnote Property_DiskPrompt} ${\footnote DiskPrompt Property} +{\footnote Property:DiskPrompt} K{\footnote DiskPrompt} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b DiskPrompt Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The localized string displayed when prompting for CD.  This should contain the text printed on the CD surface. \par\li0{\b Set By}\par\li180 Authored into Property table. Required if a CD product. \par\li0{\b Used By}\par\li180 Advertised as a product property. Displayed when CD not detected in any drive. \par\li0{\b Default Value}\par\li180 None. \page #{\footnote Property_DiskSerial} ${\footnote DiskSerial Property} +{\footnote Property:DiskSerial} K{\footnote DiskSerial} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b DiskSerial Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The internal serial number for the CD for this particular product release. \par\li0{\b Set By}\par\li180 Authored into Property table. Required if a CD product. \par\li0{\b Used By}\par\li180 Advertised as a product property. Used to locate the CD in any drive. \par\li0{\b Default Value}\par\li180 None. \page #{\footnote Property_SupportPhone} ${\footnote SupportPhone Property} +{\footnote Property:SupportPhone} K{\footnote SupportPhone} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b SupportPhone Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Technical support phone number(s). \par\li0{\b Set By}\par\li180 Authored into Property table. Optional. \par\li0{\b Used By}\par\li180 Available for display by product maintenance applet. \par\li0{\b Default Value}\par\li180 None. \page #{\footnote Property_SupportURL} ${\footnote SupportURL Property} +{\footnote Property:SupportURL} K{\footnote SupportURL} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b SupportURL Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Internet address for technical support. \par\li0{\b Set By}\par\li180 Authored into Property table. Optional. \par\li0{\b Used By}\par\li180 Available for display by product maintenance applet. \par\li0{\b Default Value}\par\li180 None. \page #{\footnote Property_ComponentDownload} ${\footnote ComponentDownload Property} +{\footnote Property:ComponentDownload} K{\footnote ComponentDownload} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ComponentDownload Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 URL for downloading components by ID (string GUID). \par\li0{\b Set By}\par\li180 Authored into Property table. Optional. \par\li0{\b Used By}\par\li180 Installer uses this value to request a component when it is not  possible to connect any product source (server or CD). \par\li0{\b Default Value}\par\li180 None. \page #{\footnote Property_WindowsFolder} ${\footnote WindowsFolder Property} +{\footnote Property:WindowsFolder} K{\footnote WindowsFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b WindowsFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the Windows folder. Set for Windows platforms. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 Common values for this property are  C:\\Winnt (NT) and C:\\Windows (Win95). \line This folder will be local, even when configured for shared Windows. \page #{\footnote Property_SystemFolder} ${\footnote SystemFolder Property} +{\footnote Property:SystemFolder} K{\footnote SystemFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b SystemFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the System folder. Set for all platforms. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 Common values for this property are:  C:\\Winnt\\System32 (NT 4.0) and C:\\Windows\\System\\ (Win95). \line\line Windows only:\line This folder is normally a subfolder of the Windows folder.  However, it will reside on a server when configured for shared Windows. \page #{\footnote Property_System16Folder} ${\footnote System16Folder Property} +{\footnote Property:System16Folder} K{\footnote System16Folder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b System16Folder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to folder for 16-bit system DLLs.  Set for NT 4.0 and above and Win95. Not set for NT 3.51. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table \par\li0{\b Default Value}\par\li180 None.  \par\li0{\b Remarks}\par\li180 Common values for this property are  C:\\Winnt\\System\\ (NT 4.0) and C:\\Windows\\System\\ (Win95). \page #{\footnote Property_ProgramFilesFolder} ${\footnote ProgramFilesFolder Property} +{\footnote Property:ProgramFilesFolder} K{\footnote ProgramFilesFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ProgramFilesFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the Program Files folder.  Set for all Windows platforms. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 A common value for this property is C:\\Program Files\\. \page #{\footnote Property_CommonFilesFolder} ${\footnote CommonFilesFolder Property} +{\footnote Property:CommonFilesFolder} K{\footnote CommonFilesFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b CommonFilesFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the Common Files folder for the current user.  Set for all Windows platforms. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 A common value for this property is C:\\Program Files\\Common Files\\. \page #{\footnote Property_StartupFolder} ${\footnote StartupFolder Property} +{\footnote Property:StartupFolder} K{\footnote StartupFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b StartupFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the Startup folder.  By default, this property is set to the folder for  the current user.  If an "All Users" profile exists and the  {\uldb ALLUSERS}{\v Property_ALLUSERS} property is set, than this property is set to the folder  in the "All Users" profile.  Set for NT 4.0 and above and Win95. Not set for NT 3.51. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 Common values for this property are  C:\\Winnt\\Profiles\\[LogonUser]\\Start Menu\\Programs\\Startup\\ (NT 4.0) and  C:\\Windows\\Start Menu\\Programs\\Startup\\ (Win95). \page #{\footnote Property_TempFolder} ${\footnote TempFolder Property} +{\footnote Property:TempFolder} K{\footnote TempFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b TempFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the Temp folder. Set for all platforms. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 A common value for this property is  C:\\Temp\\ (Windows). \page #{\footnote Property_StartMenuFolder} ${\footnote StartMenuFolder Property} +{\footnote Property:StartMenuFolder} K{\footnote StartMenuFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b StartMenuFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the Start menu folder.  By default, this property is set to the folder for  the current user.  If an "All Users" profile exists and the  {\uldb ALLUSERS}{\v Property_ALLUSERS} property is set, than this property is set to the folder  in the "All Users" profile.  Set for NT 4.0 and above and Win95. Not set for NT 3.51. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 Common values for this property are  C:\\Winnt\\Profiles\\[LogonUser]\\Start Menu\\ (NT 4.0) and  C:\\Windows\\Start Menu\\ (Win95). \page #{\footnote Property_PersonalFolder} ${\footnote PersonalFolder Property} +{\footnote Property:PersonalFolder} K{\footnote PersonalFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b PersonalFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the Personal folder for the current user.  Set for NT 4.0 and above and Win95. Not set for NT 3.51. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 Common values for this property are  C:\\Winnt\\Profiles\\[LogonUser]\\Personal\\ (NT 4.0) and  C:\\My Documents\\ (Win95). \page #{\footnote Property_AppDataFolder} ${\footnote AppDataFolder Property} +{\footnote Property:AppDataFolder} K{\footnote AppDataFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b AppDataFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the Application Data folder for the current user.  Set for NT 4.0 and above. Not set for NT 3.51 or Win95. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 A common value for this property is  C:\\Winnt\\Profiles\\[LogonUser]\\Application Data\\. \page #{\footnote Property_PrintHoodFolder} ${\footnote PrintHoodFolder Property} +{\footnote Property:PrintHoodFolder} K{\footnote PrintHoodFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b PrintHoodFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the PrintHood (Printer Neighborhood) folder for the  current user.  Set for NT 4.0 and above. Not set for NT 3.51 or Win95. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 A common value for this property is  C:\\Winnt\\Profiles\\[LogonUser]\\PrintHood\\. \page #{\footnote Property_FontsFolder} ${\footnote FontsFolder Property} +{\footnote Property:FontsFolder} K{\footnote FontsFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b FontsFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the Fonts folder.  Set for all platforms. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 A common value for this property is [WindowsFolder]\\Fonts (Windows). \page #{\footnote Property_ProgramMenuFolder} ${\footnote ProgramMenuFolder Property} +{\footnote Property:ProgramMenuFolder} K{\footnote ProgramMenuFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ProgramMenuFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the Program Menu folder.  By default, this property is set to the folder for  the current user.  If an "All Users" profile exists and the  {\uldb ALLUSERS}{\v Property_ALLUSERS} property is set, than this property is set to the folder  in the "All Users" profile.  Set for NT 4.0 and above and Win95. Not set for NT 3.51. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 Common values for this property are  C:\\Winnt\\Profiles\\[LogonUser]\\Start Menu\\Programs\\ (NT 4.0) and  C:\\Windows\\Start Menu\\Programs\\ (Win95). \page #{\footnote Property_DesktopFolder} ${\footnote DesktopFolder Property} +{\footnote Property:DesktopFolder} K{\footnote DesktopFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b DesktopFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the Desktop folder.  By default, this property is set to the folder for  the current user.  If an "All Users" profile exists and the  {\uldb ALLUSERS}{\v Property_ALLUSERS} property is set, than this property is set to the folder  in the "All Users" profile.  Set for NT 4.0 and above and Win95. Not set for NT 3.51. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 Common values for this property are  C:\\Winnt\\Profiles\\[LogonUser]\\Desktop\\ (NT 4.0) and  C:\\Windows\\Desktop\\ (Win95). \page #{\footnote Property_TemplateFolder} ${\footnote TemplateFolder Property} +{\footnote Property:TemplateFolder} K{\footnote TemplateFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b TemplateFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the Template folder for the current user.  Set for NT 4.0 and above and Win95. Not set for NT 3.51. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 Common values for this property are  C:\\Winnt\\Profiles\\[LogonUser]\\ShellNew\\ (NT 4.0)  and C:\\Windows\\ShellNew\\ (Win95). \page #{\footnote Property_SendToFolder} ${\footnote SendToFolder Property} +{\footnote Property:SendToFolder} K{\footnote SendToFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b SendToFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the SendTo folder for the current user.  Set for NT 4.0 and above and Win95. Not set for NT 3.51. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 Common values for this property are  C:\\Winnt\\Profiles\\[LogonUser]\\SendTo\\ (NT 4.0) and  C:\\Windows\\SendTo\\ (Win95). \page #{\footnote Property_NetHoodFolder} ${\footnote NetHoodFolder Property} +{\footnote Property:NetHoodFolder} K{\footnote NetHoodFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b NetHoodFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the NetHood (Network Neighborhood) folder for the current user.  Set for NT 4.0 and above. Not set for NT 3.51 or Win95. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 A common value for this property is  C:\\Winnt\\Profiles\\[LogonUser]\\NetHood\\. \page #{\footnote Property_RecentFolder} ${\footnote RecentFolder Property} +{\footnote Property:RecentFolder} K{\footnote RecentFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b RecentFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the Recent folder for the current user.  Set for NT 4.0 and above.  Not set for Win95 or NT 3.51. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 A common value for this property is  C:\\Winnt\\Profiles\\[LogonUser]\\Recent\\. \page #{\footnote Property_FavoritesFolder} ${\footnote FavoritesFolder Property} +{\footnote Property:FavoritesFolder} K{\footnote FavoritesFolder} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b FavoritesFolder Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Full path to the Favorites folder for the current user.  Set for NT 4.0 and above and Win95. Not set for NT 3.51. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and Directory table \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 Common values for this property are  C:\\Winnt\\Profiles\\[LogonUser]\\Favorites\\ (NT 4.0) and  C:\\Windows\\Favorites\\ (Win95). \page #{\footnote Property_VersionNT} ${\footnote VersionNT Property} +{\footnote Property:VersionNT} K{\footnote VersionNT} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b VersionNT Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The version number for the Windows NT operating system,  undefined if the operating system is not Windows NT.  The value is an integer: MajorVersion * 100 + MinorVersion. \par\li0{\b Set By}\par\li180 MsiServices at startup, read-only. \par\li0{\b Used By}\par\li180 Operating system dependent actions and condition expressions. \par\li0{\b Remarks}\par\li180 Condition expressions may test for WindowsNT simply by using the  property name, or may verify the version using a comparison operator. \page #{\footnote Property_Version95} ${\footnote Version95 Property} +{\footnote Property:Version95} K{\footnote Version95} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Version95 Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The version number for the Windows 95 operating system,  undefined if the operating system is not Windows 95.  The value is an integer: MajorVersion * 100 + MinorVersion. \par\li0{\b Set By}\par\li180 MsiServices at startup, read-only. \par\li0{\b Used By}\par\li180 Operating system dependent actions and condition expressions. \par\li0{\b Remarks}\par\li180 Condition expressions may test for Windows95 simply by using the  property name, or may verify the version using a comparison operator. \page #{\footnote Property_WindowsBuild} ${\footnote WindowsBuild Property} +{\footnote Property:WindowsBuild} K{\footnote WindowsBuild} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b WindowsBuild Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 !!Desciption here.!! \par\li0{\b Set By}\par\li180 Set by Services component at initialization. \par\li0{\b Used By}\par\li180 !!Who uses value?!! \par\li0{\b Default Value}\par\li180 !!Default value (can be undefined)!! \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_SharedWindows} ${\footnote SharedWindows Property} +{\footnote Property:SharedWindows} K{\footnote SharedWindows} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b SharedWindows Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 !!Desciption here.!! \par\li0{\b Set By}\par\li180 Set by Services component at initialization. \par\li0{\b Used By}\par\li180 !!Who uses value?!! \par\li0{\b Default Value}\par\li180 !!Default value (can be undefined)!! \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_ComputerName} ${\footnote ComputerName Property} +{\footnote Property:ComputerName} K{\footnote ComputerName} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ComputerName Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 !!Desciption here.!! \par\li0{\b Set By}\par\li180 Set by Services component at initialization. \par\li0{\b Used By}\par\li180 !!Who uses value?!! \par\li0{\b Default Value}\par\li180 !!Default value (can be undefined)!! \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_LogonUser} ${\footnote LogonUser Property} +{\footnote Property:LogonUser} K{\footnote LogonUser} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b LogonUser Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 !!Desciption here.!! \par\li0{\b Set By}\par\li180 Set by Services component at initialization. \par\li0{\b Used By}\par\li180 !!Who uses value?!! \par\li0{\b Default Value}\par\li180 !!Default value (can be undefined)!! \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_LanguageId} ${\footnote LanguageId Property} +{\footnote Property:LanguageId} K{\footnote LanguageId} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b LanguageId Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 !!Desciption here.!! \par\li0{\b Set By}\par\li180 Set by Services component at initialization. \par\li0{\b Used By}\par\li180 !!Who uses value?!! \par\li0{\b Default Value}\par\li180 !!Default value (can be undefined)!! \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_SHORTFILENAMES} ${\footnote SHORTFILENAMES Property} +{\footnote Property:SHORTFILENAMES} K{\footnote SHORTFILENAMES} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b SHORTFILENAMES Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Suppresses the use of long file names. \par\li0{\b Set By}\par\li180 Set by services if the system does not support long file names. May also be set by the launcher or command line to disable long file names. \par\li0{\b Used By}\par\li180 Actions and volume services. \par\li0{\b Default Value}\par\li180 Undefined. \par\li0{\b Remarks}\par\li180 Note: The SHORTFILENAMES property has no direct effect on {\uldb MsiVolume}{\v MsiVolume_Object}  or {\uldb MsiPath}{\v MsiPath_Object} objects at all.  MsiVolume objects support long filenames only  if the volume itself intrinsically supports long names (and the active system software also supports them).  MsiPath objects support long file names if the associated MsiVolume object supports them, UNLESS the  appropriate flag to suppress long file names is specified when the MsiPath object is created.  However, the  {\uldb DirectoryManager}{\v MsiDirectoryManager_Object} does respect the SHORTFILENAMES property, i.e.  it uses the state of this property to determine whether or not to create MsiPath objects with long names  suppressed. \page #{\footnote Property_TRANSFORMS} ${\footnote TRANSFORMS Property} +{\footnote Property:TRANSFORMS} K{\footnote Transform Transforms} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b TRANSFORMS Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 A string containing a list of transforms to be applied to the database. \par\li0{\b Set By}\par\li180 Launcher resource or command-line setting. \par\li0{\b Used By}\par\li180 MsiEngine uses the value to transform the database \par\li0{\b Default Value}\par\li180 Undefined. \par\li0{\b Remarks}\par\li180 Transforms will be applied in the order they are listed in the string.  To specify multiple transforms, separate each with a semi-colon (;). \line Transforms can reside in three locations. The format for specifiying  the transforms varies based on its location: \par\par \trowd \trqc\trgaph108\trleft540  \cellx2160\cellx3960 \pard\plain \widctlpar \intbl \f4\fs20 {\b Location\cell } {\b Format\cell }\row \intbl file\cell filename\cell \row \intbl resource in launcher\cell @transformname\cell \row \intbl child storage in database\cell :transformname\cell \row \li0{\b Example}\par\li180 Suppose the following transforms need to be applied:\line \line\tab trans1, located in a file in c:\\transforms \line\tab trans2, located in a resource \line\tab trans3, located in a child storage of the database \line\line The string would be: c:\\transforms\\trans1;@trans2;:trans3 \page #{\footnote Property_Modem} ${\footnote Modem Property} +{\footnote Property:Modem} K{\footnote Modem} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Modem Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 !!Desciption here.!! \par\li0{\b Set By}\par\li180 !!Who sets value?!! \par\li0{\b Used By}\par\li180 !!Who uses value?!! \par\li0{\b Default Value}\par\li180 !!Default value (can be undefined)!! \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_Sound} ${\footnote Sound Property} +{\footnote Property:Sound} K{\footnote Sound} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Sound Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 !!Desciption here.!! \par\li0{\b Set By}\par\li180 !!Who sets value?!! \par\li0{\b Used By}\par\li180 !!Who uses value?!! \par\li0{\b Default Value}\par\li180 !!Default value (can be undefined)!! \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_Network} ${\footnote Network Property} +{\footnote Property:Network} K{\footnote Network} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Network Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 !!Desciption here.!! \par\li0{\b Set By}\par\li180 !!Who sets value?!! \par\li0{\b Used By}\par\li180 !!Who uses value?!! \par\li0{\b Default Value}\par\li180 !!Default value (can be undefined)!! \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_Language} ${\footnote Language Property} +{\footnote Property:Language} K{\footnote Language} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Language Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 !!Desciption here.!! \par\li0{\b Set By}\par\li180 !!Who sets value?!! \par\li0{\b Used By}\par\li180 !!Who uses value?!! \par\li0{\b Default Value}\par\li180 !!Default value (can be undefined)!! \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_IME} ${\footnote IME Property} +{\footnote Property:IME} K{\footnote IME} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b IME Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 !!Desciption here.!! \par\li0{\b Set By}\par\li180 !!Who sets value?!! \par\li0{\b Used By}\par\li180 !!Who uses value?!! \par\li0{\b Default Value}\par\li180 !!Default value (can be undefined)!! \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_Bidirectional} ${\footnote Bidirectional Property} +{\footnote Property:Bidirectional} K{\footnote Bidirectional} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Bidirectional Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 {\b This property is not yet set or used.}\line !!Desciption here.!! \par\li0{\b Set By}\par\li180 !!Who sets value?!! \par\li0{\b Used By}\par\li180 !!Who uses value?!! \par\li0{\b Default Value}\par\li180 !!Default value (can be undefined)!! \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_Security} ${\footnote Security Property} +{\footnote Property:Security} K{\footnote Security} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Security Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 !!Desciption here.!! \par\li0{\b Set By}\par\li180 !!Who sets value?!! \par\li0{\b Used By}\par\li180 !!Who uses value?!! \par\li0{\b Default Value}\par\li180 !!Default value (can be undefined)!! \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_Intel} ${\footnote Intel Property} +{\footnote Property:Intel} K{\footnote Intel} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Intel Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Defined only if running on an Intel processor.  The value is the numeric processor level, i.e. 4 for 486, 5 for P5, 6 for P6, etc... \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and condition expressions. \par\li0{\b Default Value}\par\li180 None. \page #{\footnote Property_Alpha} ${\footnote Alpha Property} +{\footnote Property:Alpha} K{\footnote Alpha} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Alpha Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Defined only if running on an Alpha processor.  The value is the numeric processor level. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and condition expressions. \par\li0{\b Default Value}\par\li180 None. \page #{\footnote Property_PhysicalMemory} ${\footnote PhysicalMemory Property} +{\footnote Property:PhysicalMemory} K{\footnote PhysicalMemory} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b PhysicalMemory Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Size of installed RAM in Megabytes. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and condition expressions. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_VirtualMemory} ${\footnote VirtualMemory Property} +{\footnote Property:VirtualMemory} K{\footnote VirtualMemory} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b VirtualMemory Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Amount of available page file space in Megabytes. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and condition expressions. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_ScreenX} ${\footnote ScreenX Property} +{\footnote Property:ScreenX} K{\footnote ScreenX} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ScreenX Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Width, in pixels, of the screen. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and condition expressions. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_ScreenY} ${\footnote ScreenY Property} +{\footnote Property:ScreenY} K{\footnote ScreenY} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ScreenY Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Height, in pixels, of the screen. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and condition expressions. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_TextHeight} ${\footnote TextHeight Property} +{\footnote Property:TextHeight} K{\footnote TextHeight} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b TextHeight Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The height (ascent + descent) of characters, given in logical units.  \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and condition expressions. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_CaptionHeight} ${\footnote CaptionHeight Property} +{\footnote Property:CaptionHeight} K{\footnote CaptionHeight} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b CaptionHeight Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Height, in pixels, of normal caption area. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and condition expressions. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_BorderTop} ${\footnote BorderTop Property} +{\footnote Property:BorderTop} K{\footnote BorderTop} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b BorderTop Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The height, in pixels, of window borders. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and condition expressions. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_BorderSide} ${\footnote BorderSide Property} +{\footnote Property:BorderSide} K{\footnote BorderSide} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b BorderSide Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The width, in pixels, of window borders. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and condition expressions. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_ColorBits} ${\footnote ColorBits Property} +{\footnote Property:ColorBits} K{\footnote ColorBits} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ColorBits Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Number of adjacent color bits for each pixel. \par\li0{\b Set By}\par\li180 {\uldb MsiServices.SetPlatformProperties}{\v MsiServices_SetPlatformProperties} \par\li0{\b Used By}\par\li180 Actions and condition expressions. \par\li0{\b Default Value}\par\li180 None. \par\li0{\b Remarks}\par\li180 \page #{\footnote Property_Time} ${\footnote Time Property} +{\footnote Property:Time} K{\footnote Time} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Time Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 !!Desciption here.!! \par\li0{\b Set By}\par\li180 !!Who sets value?!! \par\li0{\b Used By}\par\li180 !!Who uses value?!! \par\li0{\b Default Value}\par\li180 !!Default value (can be undefined)!! \par\li0{\b Remarks}\par\li180 !!Additional notes!!  \page #{\footnote Property_SAMPLE} ${\footnote SAMPLE Property} +{\footnote Property:SAMPLE} K{\footnote SAMPLE} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b SAMPLE Property \line\tx360\tab\fs18\b0{\uldb Property Summary}{\v Property_Contents} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 !!Desciption here.!! \par\li0{\b Set By}\par\li180 !!Who sets value?!! \par\li0{\b Used By}\par\li180 !!Who uses value?!! \par\li0{\b Default Value}\par\li180 !!Default value (can be undefined)!! \par\li0{\b Remarks}\par\li180 !!Additional notes go here, delete the following text!!  When wrapping text lines, a space must be left after the last word. Replace occurrances of "SAMPLE" with the desired property name. \page
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\help\database.rtf ===
{\rtf1\ansi {\fonttbl{\f0\fswiss Arial;}{\f1\fmodern Courier New;}} {\colortbl;} \fs20 @{\footnote   Help Topics for Microsoft Installer Database Classes} \page #{\footnote Table_ArchiveFormat} ${\footnote Database Table Archive Format} K{\footnote DATABASE; Archive; Format} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Installer Table Archive Format \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Database tables are normally maintained individually as text archive files  of the format below with the default extension ".idt". The MsiDatabase object  has {\uldb ExportTable}{\v MsiDatabase_ExportTable} and  {\uldb ImportTable}{\v MsiDatabase_ImportTable} functions that transfer these  file to and from the physical database. \par\li0{\b File Format}\par\li500\fi-320 Lines composed of tab-delimited text fields, terminated with CR and LF.\line 1st line contains the columns names as stored in the database.\line 2nd line contains the column specifications as described below.\line 3rd line contains the table name and all the primary keys for the table.\line Subsequent lines contain the data values for each row in the table.\line Integer, datetime, and bit fields are all converted to integer text.\line Control characters (CR,LF,Tab,Null) are remapped to avoid delimiter conflict.\line Memo and BLOB fields stored as separate files, filename used as column data.\line Memo filename: 1st 8 chars from row data + ".imd".\line BLOB filename: 1st 8 chars from row data + ".ibd".\line \par\fi0\li0{\b Datatype Codes}\par\li180 An upper case letter indicate that Null values are allowed in the column.  The '?' indicates that the maximum width of the column must be specified. \par\pard\li300\tx1000 b? \tab Binary bytes(not supported), SQL_BINARY\line c? \tab Character array (1-255), SQL_CHAR\line d6 \tab Date, SQL_DATE\line d16\tab Datetime, SQL_TIMESTAMP\line i0 \tab Boolean, SQL_BIT\line i1 \tab Byte, SQL_TINYINT\line i2 \tab Short, SQL_SMALLINT\line i4 \tab Integer, SQL_INTEGER\line k4 \tab Counter, SQL_INTEGER (SQL_AUTO_INCREMENT)\line s0 \tab Memo, SQL_LONGVARCHAR\line s? \tab String, variable length (n=1-255), SQL_VARCHAR\line v0 \tab BLOB, SQL_LONGVARBINARY\line v? \tab VarBinary (1-255), SQL_LONGBINARY (not supported)\line \page #{\footnote New_Table_ArchiveFormat} ${\footnote New Database Table Archive Format} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Installer Table Archive Format \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Database tables are normally maintained individually as text archive files  of the format below with the default extension ".idt". The MsiDatabase object  has {\uldb ExportTable}{\v MsiDatabase_ExportTable} and  {\uldb ImportTable}{\v MsiDatabase_ImportTable} functions that transfer these  file to and from the physical database. The format is designed to support  both MSI and ODBC database specifications. \par\li0{\b File Format}\par\li500\fi-320 Lines are composed of tab-delimited text fields, terminated with CR and LF.\line The 1st line contains the table name followed by the columns names.\line The 2nd line contains the primary key count followed by the column specifications.\line Subsequent lines contain the data values for each row in the table.\line The first data value contains the persistent row attributes, stored as characters.\line Integer, datetime, and bit fields are all converted to integer text.\line Control characters (CR,LF,Tab,Null) are remapped to avoid delimiter conflict.\line Memo and BLOB fields stored as separate files; the filename used as column data.\line Memo filename: 1st 8 chars from row data + ".imd".\line BLOB filename: 1st 8 chars from row data + ".ibd".\line Primary key columns must be specified first in priority order.\line \par\fi0\li0{\b Row Status attribute specification}\par\li180 Upper case letters are use to indicate each attribute tat is in the True state.\line \par\pard\li300\tx1000\tx3000 T \tab iraTemporary   \tab not persisted with table unless explicitly forced\line P \tab iraProvisional \tab with T, persisted only when database state dumped\line \tab \tab may be used alone by external client to mark row as incomplete\line U \tab iraUserInfo    \tab for use by external client to mark rows\line \tab \tab not used by database engine\line R \tab iraReadOnly    \tab prevents rows from being updated\line \par\fi0\li0{\b Datatype Column Specification}\par\li180 Lower case letters are used to indicate a non-nullable column.\line Upper case letters would indicate that Null values are allowed in the column.\line \par\pard\li180\tx1000 {\b Code\tab MSI type \tab SQL type}\line {\f1 b0} \tab icdObject \tab binary stream, SQL_LONGVARBINARY\line {\f1 d6} \tab icdShort \tab date, SQL_DATE\line {\f1 d16}\tab icdLong \tab datetime, SQL_TIMESTAMP\line {\f1 i0} \tab icdShort \tab boolean, SQL_BIT\line {\f1 i1} \tab icdShort \tab byte, SQL_TINYINT\line {\f1 i2} \tab icdShort \tab short, SQL_SMALLINT\line {\f1 i4} \tab icdLong \tab integer, SQL_INTEGER\line {\f1 s0} \tab icdString \tab memo, SQL_LONGVARCHAR\line {\f1 s?} \tab icdString \tab string, variable length (?=1-255), SQL_VARCHAR\line \page #{\footnote MsiDatabase_Specifications} ${\footnote Installer Database Specifications} K{\footnote DATABASE; Specifications} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Database Engine Overview and Features \line\fs18\b0\tx3000\tab{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The MSI database engine has been designed for small size, high query performance,  and very compact persistent file size, as well as to support the special requirements  of the installer such as object and stream datatypes, tree-walking cursors,  merges and diffs, and temporary tables, columns, and rows.  The engine supports two levels of access: Very high-performance direct table access via cursors,  and high-level access via SQL queries. The persistent file format uses OLE structured storage,  which is used to support the limited transaction capability.  Due to the performance and size constraints, we do not purport to be a complete SQL DBMS.  The implementation is identical between Win32 and Macintosh PPC, except for some minor differences  at the OLE interface level. \par\fi0\li0{\b Features}\par\li180 Tables are indexed by primary keys. Natural fetch order is by primary key.\line Any column may be specified to accept or reject null values, including primary keys.\line Tables may be linked as a tree through any column, and may be walked from any node.\line Strings are pooled; only one copy of each unique string is kept and stored per database.\line String columns are unsized and may hold strings up to 64K bytes.\line Streams are persisted and are accessed via stream objects.\line Databases may be opened from files, resources, and IStorage interfaces. Columns may be dynamically added to tables, and may be non-persistent.\line SummaryInformation stream properties are individually readable and writable.\line The database engine is exposed as a set of COM objects that support OLE automation.\line Rows may be marked non-persistent and/or read-only.\line Row attibutes may be queried: inserted, modified, non-persistent, merge failure, locked.\line Multiple update modes: Insert(new row), Update(existing row), Assign(force), Merge(insert or match).\line Temporary tables may be created. Even a temporary database can be created.\line Databases can be diffed, creating a transform file that can be applied to a database.\line COM objects may be stored in tables in non-persistent columns.\line Tables may optionally be locked in memory for increased performance.\line Stream objects may be used in tables, and are persisted as streams.\line A separate output database may be specified to avoid writing to original database.\line SQL updates and sorts through joins are supported.\line SQL parameterized queries can be re-executed with new parameters.\line Access and SQL Server databases and ODBC data sources are supported through ODBCS.\line Temporary tables may be use with ODBC databases and may be joined with SQL queries.\line ODBC driver available to expose MSI database as an ODBC data source.\line Table may be imported and exported to text archives by both MSI and ODBC databases.\line \par\fi0\li0{\b Low-level interface}\par\li180 The low-level interface consists of two primary objects: MsiTable which handles the schema,  and MsiCursor which handles external data transfer. The cursor object communicates to the  table object at the row level such that table updates are performed on complete rows.  String objects and stream objects are used to transfer non-integer data.  Row filtering can be performed only by matching column values for equality. \par\fi0\li0{\b High-level interface}\par\li180 The high-level interface is accessed through the MsiView object, which is constructed with  a SQL SELECT statement. The statement can contain parameter markers, "?", literal column values,  a predicate expression consisting of logical and comparison operators (including equi-joins),  and an ORDER BY column list. Queries with ORDER BY that doesn't specify the primary key are  slower to execute, as a temporary table must be constructed. Data is transferred using  MsiRecord objects, which contain the set of values transferred. The values may be integers,  strings, streams, or COM objects. \par\fi0\li0{\b Persistent storage}\par\li180 OLE structured storage is used to persist the database. Each table, including catalog tables,  is stored as a separate stream. Stream data values are also stored as unique streams.  The standard \\005SummaryStream property values are supported for use by the database client.  Transforms may be stored as substorages, typically to provide updates and language transformations.  The persistent files are compatible between the Win32 and Macintosh database engine.  Both direct and transaction modes are supported, and temporary rows may optionally be persisted.  For archiving purposes, the database engine can import and export tables as tab-delimited text files,  with stream data values exported as separate files. \par\fi0\li0{\b SQL limitations}\par\li180 Currently only SELECT statements are supported.\line Update and delete are performed following SELECT execution; positioned update and delete are supported.\line Only equi-joins are supported, using equality comparison; subqueries are not supported.\line Only logical and comparison predicate operators are supported, no functions, arithmetic operators, GROUP BY.\line \par\fi0\li0{\b Schema limitations}\par\li180 Datatypes supported: string, short integer, long integer, stream, object(non-persistent).\line Tables may contain from 1 to 32 columns. Tree-linked tables are limited to 64K rows and 256 nesting levels.\line Primary keys columns must be defined first in their priority order, followed by any non-primary key columns.\line Persistent columns must be defined before temporary columns.\line Text collating sequence is undefined; however identical text values will always group together.\line Table and column names are not contrained; however to export tables, their names must be unique in the first 8 characters.\line \page *{\footnote VBA} #{\footnote MsiDatabase_Object} ${\footnote MsiDatabase Object} K{\footnote MsiDatabase; MsiView} +{\footnote Class:MsiDatabase} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MsiDatabase Object \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The database object accesses a particular database, which may be either  an Access database file, a SQL Server database, an ODBC data source, or a  Microsoft Installer database. A low-level database engine is provided by the  {\uldb MsiTable}{\v MsiTable_Object} and {\uldb MsiCursor}{\v MsiCursor_Object}  objects, providing the basis of the Installer database and also providing  support for ODBC tables loaded into memory.  Some of the capabilities of the internal engine are object storage, dynamic  addition of temporary columns, high performance, and tree representation. In the Microsoft Installer database, strings are stored in a common pool as  an array of MsiString objects.  Database fields simply store indices to this private array of unique strings.  Internally, string uses are reference counted as part of the string management.  Functions are provided for converting string objects to and from string indices.  A string that returns zero for its index does not exist in the current database. Persistent tables are normally loaded into memory when a table object is created  and removed from memory when the last reference to the table object is released.  The LockTable function is used to keep a frequently used table in memory  independently of reference counts. As long as the lock calls are greater than  the unlock calls, the table remains in memory until the database is closed. Before the MsiDatabase object that is created for update is destructed  (by releasing all references), the {\uldb Persist}{\v MsiDatabase_Persist} method  must be called to either record all changes or to back out all changes, else  an implicit rollback is performed at object destruction. MSI, Access,  and SQLServer all support transactions and require this call. Some ODBC  data source may not support transactions, in which case changeds cannot be rolled back  (most non-transaction data source do not support update, so this is moot point). \par\li0{\b Properties}\par\li180 {\uldb UpdateState}{\v MsiDatabase_UpdateState}\line {\uldb Storage}{\v MsiDatabase_Storage}\line {\uldb TableState}{\v MsiDatabase_TableState}\line {\uldb ANSICodePage}{\v MsiDatabase_ANSICodePage}\line \par\li0{\b Methods}\par\li180 {\uldb OpenView}{\v MsiDatabase_OpenView}\line {\uldb GetPrimaryKeys}{\v MsiDatabase_GetPrimaryKeys}\line {\uldb ImportTable}{\v MsiDatabase_ImportTable}\line {\uldb ExportTable}{\v MsiDatabase_ExportTable}\line {\uldb DropTable}{\v MsiDatabase_DropTable}\line {\uldb FindTable}{\v MsiDatabase_FindTable}\line {\uldb LoadTable}{\v MsiDatabase_LoadTable}\line {\uldb CreateTable}{\v MsiDatabase_CreateTable}\line {\uldb LockTable}{\v MsiDatabase_LockTable}\line {\uldb GetCatalogTable}{\v MsiDatabase_GetCatalogTable}\line {\uldb EncodeString}{\v MsiDatabase_EncodeString}\line {\uldb DecodeString}{\v MsiDatabase_DecodeString}\line {\uldb CreateTempTableName}{\v MsiDatabase_CreateTempTableName}\line {\uldb Commit}{\v MsiDatabase_Commit}\line {\uldb CreateOutputDatabase}{\v MsiDatabase_CreateOutputDatabase}\line {\uldb GenerateTransform}{\v MsiDatabase_GenerateTransform}\line {\uldb SetTransform}{\v MsiDatabase_SetTransform}\line {\uldb MergeDatabase}{\v MsiDatabase_MergeDatabase} \par\li0{\b Query API Sequencing}\par\li500\fi-320 The normally course of data access is summarized below: \line 1. The client obtains a database object ({\uldb MsiServices.CreateDatabase}{\v MsiServices_CreateDatabase}). \line 2. OpenView is called, specifying the view name and intended actions. \line 3. View.Excecute is called, supplying any parameters in an MsiRecord object. \line 4. View.Fetch is called repeatedly, returns MsiRecord objects until exhausted. \line 5. View.Close is called, which releases the query and unfetched records. \line 6. Database.Persist is called to persist any database updates or to back out changes. \page *{\footnote CPP} #{\footnote IMsiDatabase_Class} ${\footnote IMsiDatabase Class} K{\footnote IMsiDatabase; IMsiView} +{\footnote Class:IMsiDatabase} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b IMsiDatabase Object \line\fs18\b0\tx3000\tab{\uldb Msi Classes}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The database object accesses a particular database, which may be either  an Access database file, a SQL Server database, an ODBC data source, or a  Microsoft Installer database. A low-level database engine is provided by the  {\uldb IMsiTable}{\v MsiTable_Object} and {\uldb IMsiCursor}{\v MsiCursor_Object}  objects, providing the basis of the Installer database and also providing  support for ODBC tables loaded into memory.  Some of the capabilities of the internal engine are object storage, dynamic  addition of temporary columns, high performance, and tree representation. In the Microsoft Installer database, strings are stored in a common pool as  an array of IMsiString objects.  Database fields simply store indices to this private array of unique strings.  Internally, string uses are reference counted as part of the string management.  Functions are provided for converting string objects to and from string indices.  A string that returns zero for its index does not exist in the current database. Persistent tables are normally loaded into memory when a table object is created  and removed from memory when the last reference to the table object is released.  The LockTable function is used to keep a frequently used table in memory  independently of reference counts. As long as the lock calls are greater than  the unlock calls, the table remains in memory until the database is closed. \par\li0{\b Methods}\par\li180 {\uldb OpenView}{\v MsiDatabase_OpenView}\line {\uldb GetPrimaryKeys}{\v MsiDatabase_GetPrimaryKeys}\line {\uldb ImportTable}{\v MsiDatabase_ImportTable}\line {\uldb ExportTable}{\v MsiDatabase_ExportTable}\line {\uldb DropTable}{\v MsiDatabase_DropTable}\line {\uldb FindTable}{\v MsiDatabase_FindTable}\line {\uldb LoadTable}{\v MsiDatabase_LoadTable}\line {\uldb CreateTable}{\v MsiDatabase_CreateTable}\line {\uldb LockTable}{\v MsiDatabase_LockTable}\line {\uldb GetCatalogTable}{\v MsiDatabase_GetCatalogTable}\line {\uldb EncodeString}{\v MsiDatabase_EncodeString}\line {\uldb DecodeString}{\v MsiDatabase_DecodeString}\line {\uldb CreateTempTableName}{\v MsiDatabase_CreateTempTableName} \par\li0{\b Query API Sequencing}\par\li500\fi-320 The normally course of data access is summarized below: \line 1. The client obtains a database object (IMsiServices::GetDatabase) \line 2. OpenView is called, specifying the view name and intended actions. \line 3. View->Excecute is called, supplying any parameters in an IMsiRecord. \line 4. View->Fetch is called repeatedly, returns records until exhausted. \line 5. View->Close is called, which releases the query and unfetched records. \page #{\footnote MsiDatabase_OpenView} ${\footnote MsiDatabase.OpenView} +{\footnote MsiDatabase:OpenView} K{\footnote OpenView} K{\footnote ivcNoData;ivcFetch;ivcUpdate;ivcInsert;ivcDelete;} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b OpenView Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns an {\uldb MsiView}{\v MsiView_Object} object representing the query  specified by a SQL string. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .OpenView({\i sql, intent})} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b sql}\line Required. The SQL query string. \par{\i\b intent}\line Required. The combination of ALL operations intended on the MsiView object: \line{\f1  ivcNoData   }- No data access, can get column information only. \line{\f1  ivcFetch    }- Fetch data from rows into MsiRecord objects. \line{\f1  ivcUpdate   }- Update rows from modified MsiRecord objects. \line{\f1  ivcInsert   }- Insert rows using data in MsiRecord objects. \line{\f1  ivcDelete   }- Delete rows using fetched MsiRecord objects. \par\fi0\li0{\b SQL Syntax}\par\li500\fi-320 The SQL query strings are restricted to the format:\line The {\b select} SQL query.\line {\f1\b SELECT} [DISTINCT]\{column-list\} {\f1\b FROM} \{table-list\} [{\f1\b WHERE}  \{operation-list\}] [{\f1\b ORDER BY} \{column-list\}].\line \{table-list\} is a comma delimited list of one or more table names hereby refered to as \{table\} in the join. Table names  that clash with SQL keywords need to be quoted within {\b ``}.\line \{column-list\} is a comma delimited list of one or more table columns hereby refered to as \{column\} selected. Ambiguous columns may  be further qualified as \{tablename.column\}. Column names that clash with SQL keywords need to be  quoted within {\b ``}. In case the column is qualified as \{tablename.column\} and if there is a need  to escape the identifier then the tablename and the column need to be individually escaped as  \{`tablename`.`column`\}\line \{operation-list\} clause is optional and is a grouping of operations to be used to filter the selection. The operations can be of the type -\line \{column\} = \{column\}\line \{column\} <> \{column\}\line \{column\} > \{column\}\line \{column\} < \{column\}\line \{column\} >= \{column\}\line \{column\} <= \{column\}\line \{column\} = \{constant\}\line \{column\} <> \{constant\}\line \{column\} > \{constant\}\line \{column\} < \{constant\}\line \{column\} >= \{constant\}\line \{column\} <= \{constant\}\line \{column\} is null\line \{column\} is not null\line individual operations can be grouped be {\b AND} or {\b OR} operators. Ordering can be imposed by use of {\b()}\line \{constant\} is either a string or an integer. A string has to be quoted within {\b''}.\line The {\bORDER BY} clause is optional and will cause an initial delay during sorting.\line The {\b DISTINCT} clause is optional and will not repeat identical records in the return result set.\line  The table and column names are case sensitive, even if ODBC databases are used.  However, SQL keywords are case-insensitive.  Only inner joins are supported, specified by a comparison of columns from different tables.\line The {\b delete} SQL query.\line {\f1\b DELETE FROM} \{table\} [{\f1\b WHERE} \{operation-list\}].\line The {\b update} SQL query.\line {\f1\b UPDATE} \{table-list\} {\f1\b SET} \{column\}{\f1\b =} \{constant\}  [{\f1\b ,} \{column\}{\f1\b =} \{constant\}]* [{\f1\b WHERE} \{operation-list\}].\line The {\b insert} SQL query.\line {\f1\b INSERT INTO} \{table\} \{{\b (}column-list{\b )}\} {\f1\b VALUES}  \{{\b (}constant-list{\b )}\}.\line The * implies 0 or more repitition.\line The {\b create} SQL query.\line {\f1\b CREATE TABLE} \{table\} {\f1\b (} \{column\} [{\f1\b CHAR} [{\f1\b (} \{size\} {\f1\b )}] | {\f1\b CHARACTER} [{\f1\b (} \{size\} {\f1\b )}] | {\f1\b LONGCHAR}  | {\f1\b SHORT} | {\f1\b INT} | {\f1\b INTEGER} | {\f1\b LONG} | {\f1\b OBJECT} ]  [{\f1\b NOT NULL}] [{\f1\b TEMPORARY}] [, {column}...]* {\f1\b PRIMARY KEY } {column} [, {column}]* {\f1\b )}.\line The * implies 0 or more repitition.\line The {\b alter} SQL query.\line {\f1\b ALTER TABLE} \{table\} {\f1\b ADD } \{column\} [{\f1\b CHAR} [{\f1\b (} \{size\} {\f1\b )}] | {\f1\b CHARACTER} [{\f1\b (} \{size\} {\f1\b )}] | {\f1\b LONGCHAR}  | {\f1\b SHORT} | {\f1\b INT} | {\f1\b INTEGER} | {\f1\b LONG} | {\f1\b OBJECT} ]  [{\f1\b NOT NULL}] [{\f1\b TEMPORARY}].\line \page #{\footnote MsiDatabase_GetPrimaryKeys} ${\footnote MsiDatabase.GetPrimaryKeys} +{\footnote MsiDatabase:GetPrimaryKeys} K{\footnote GetPrimaryKeys} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b GetPrimaryKeys Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns a MsiRecord object containing table name in Field(0) and the  columns names comprising the primary keys in succeeding fields,  corresponding their column numbers. The field count of the record  is the count of primary key columns. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .GetPrimaryKeys {\i table}} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b table}\line Required. Name of an existing table. An error is generated if the table does  not exist. \page #{\footnote MsiDatabase_ImportTable} ${\footnote MsiDatabase.ImportTable} +{\footnote MsiDatabase:ImportTable} K{\footnote ImportTable; Import} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ImportTable Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Imports a database table from a text archive file, dropping any existing table. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .ImportTable {\i path, file}} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b path}\line Required. An MsiPath object set to the folder where the text file is present. \par{\i\b file}\line Required. The name of the file to be imported. This does not include the folder,  as that must be set in the path object. The table name is specified within the file. \par\fi0\li0{\b\uldb Archive File Format}{\v Table_ArchiveFormat} \par\fi0\li0{\b SummaryInformation Stream}\par\li180 For .MSI databases only, not ODBC, a special stream "\005SummaryInformation" is written  containing standardized properties defined by OLE and browsable by the Explorer.  If the table name in the text archive file is named exactly "_SummaryInformation",  the table rows consisting of pairs of Property Id numbers with corresponding data values  will be written to the property stream. For ODBC databases, a normal table will be created.  If the data value is a valid integer, it is taken to be an integer property. Else if it  can be parsed as a date or date/time value (consisting of digits separated by slashes) it  is taken to be a data/time value. Otherwise it is assumed to be a string value. Date values  may have two formats: yyyy/mm/dd  (time is entered as 0) or yyyy/mm/dd/hh/mm/ss (24 hr. time).  The summary information is customarily generated for new files by the release build process. \page #{\footnote MsiDatabase_ExportTable} ${\footnote MsiDatabase.ExportTable} +{\footnote MsiDatabase:ExportTable} K{\footnote ExportTable; Export} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ExportTable Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Copies the structure and data from a specified table to a text archive file. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .ExportTable {\i table, path, file}} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b table}\line Required. The name of the database table, case-sensitive if MSI database. \par{\i\b path}\line Required. An MsiPath object set to the folder where the text file will be placed. \par{\i\b file}\line Required. The name of the file to be created. This does not include the folder,  as that must be set in the path object. Keep to the 8.3 format if SLM is used. \par\fi0\li0{\b\uldb Archive File Format}{\v Table_ArchiveFormat} \page #{\footnote MsiDatabase_LoadTable} ${\footnote MsiDatabase_LoadTable} +{\footnote MsiDatabase:LoadTable} K{\footnote LoadTable} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b LoadTable Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The LoadTable method creates and returns a database table object in memory by  reading a table from the persistent database. Additional temporary columns may  be added if desired using the {\uldb CreateColumn}{\v MsiTable_CreateColumn}  of the created table. This table remains in memory as long as there are  outstanding references to the MsiTable object, or outstanding locks from the  LockTable method. If an Access, SQL Server, or ODBC table is specified,  database operations will be performed on the in-memory table, and any update  operations on persistent columns will be replicated in the persistent table. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .LoadTable({\i table, addColumns})} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b table}\line Required. Name of an existing table. An error is generated if the table does  not exist in the current database. \par{\b\i addColumns}\line Optional. The anticipated number of columns that will be added  after the data is loaded. This is for optimization only. Columns may be  added beyond this number, but will require reallocation of the data rows. \par\fi0\li0{\b Remarks}\par\li180 If the requested table is already loaded into memory, a reference to  that table will be returned. When processing SQL queries on an Msi database,  tables will be loaded if necessary during the processing of the query, and  will remain loaded until the MsiView object is released. If a table is known  to be accessed repeatedly, {\uldb LockTable}{\v MsiDatabase_LockTable} may  be called to hold the table in memory once loaded. A table loaded from an ODBC database must have a primary key defined and the  composite columns must specified in order as the first columns in the table.  (In the future the column order to be altered when loaded into memory.) \page #{\footnote MsiDatabase_CreateTable} ${\footnote MsiDatabase.CreateTable} +{\footnote MsiDatabase:CreateTable} K{\footnote CreateTable} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b CreateTable Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Creates a temporary, in-memory table, and returns it as a  {\uldb MsiTable}{\v MsiTable_Object} object.  If columns are marked as persistent, the table will be created in the persistent  database when the database is closed. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .CreateTable({\i table, initRows})} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b table}\line Required. Name to be given to table. An error will be generated if a table  by that name already exists in the current database. \par{\b\i rowCount}\line Optional. The suggested number of rows to allocate initially.  This is an optimization only. If this argument is omitted or has a value of zero,  the default number of rows will be initially allocated.  The data array will grow as required as more rows are inserted. \page #{\footnote MsiDatabase_LockTable} ${\footnote MsiDatabase.LockTable} +{\footnote MsiDatabase:LockTable} K{\footnote LockTable} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b LockTable Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The LockTable method will lock a specified table in memory once it is loaded,  or will release a lock on a table that has been locked. When all locks are released and there  are no outstanding references to the table object, it will be released from memory.  Any outstanding locks will be removed when the database object is destroyed.  The method returns a boolean indicating whether the lock operation succeeded. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .LockTable({\i table, lock})} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b table}\line Required. The name of the table to lock. \par{\i\b lock}\line Required. Boolean value, TRUE to lock, FALSE to unlock. \par\fi0\li0{\b Remarks}\par\li180 Locking a table that is not loaded into memory will not attempt to load that  table into memory, but will hold it in memory once loaded. Locks are cumulative,  and the loaded table is held in memory until the lock count returns to zero.  Locking is a performance hint to the database engine and may not always be honored. \page #{\footnote MsiDatabase_DropTable} ${\footnote MsiDatabase.DropTable} +{\footnote MsiDatabase:DropTable} K{\footnote DropTable} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b  DropTable Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Removes a table from the persistent database along with its data.  This method will fail if the table does not exist or if the database is not  an MSI database and the table is in use. Dropping an MSI database table that  is in use will remove it from the system catalogs, but the now-anonymous MsiTable  object will remain until all references are released.  Temporary tables, created with CreateTable, cannot be dropped, but will  be destroyed when all references are released. ODBC databases generally do not  perform Drop Table within the transaction, preventing this operation from being rolled back. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .DropTable {\i table}} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b table}\line Required. The name of the database table, case-sensitive if MSI database. \page #{\footnote MsiDatabase_FindTable} ${\footnote MsiDatabase.FindTable} +{\footnote MsiDatabase:FindTable} K{\footnote FindTable} K{\footnote itsUnknown;itsTemporary;itsUnloaded;itsLoaded} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b  FindTable Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the status of a table in this database, one of the enum itsEnum: \line{\f1  itsUnknown   = 0 } named table is not in database \line{\f1  itsTemporary = 1 } table is temporary, not persistent !!marked obsolete \line{\f1  itsUnloaded  = 2 } table exists in database but is not loaded \line{\f1  itsLoaded    = 3 } table is loaded into memory from database \line{\f1  itsOutput    = 6 } table copied to output database (itsUnloaded + 4) \line{\f1  itsSaveError = 7 } unable to write table to storage (itsLoaded + 4) !!marked obsolete \line{\f1  itsTransform = 10} table need to have tranform applied when loaded !!marked obsolete \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .FindTable {\i table}} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b table}\line Required. The name of the database table, case-sensitive. \page #{\footnote MsiDatabase_TableState} ${\footnote MsiDatabase.TableState} +{\footnote MsiDatabase:TableState} K{\footnote TableState} K{\footnote itsUnknown;itsTemporary;itsUnloaded;itsLoaded} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b TableState Property \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns a selected attribute of a table in this database. Read-only. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .TableState({\i table, state})} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b table}\line Required. The name of the database table, case-sensitive. \par{\i\b state}\line Required. The particular attribute to be queried, one of the enum itsEnum: \line{\f1  itsPermanent   = 0 }  table has persistent columns \line{\f1  itsTemporary   = 1 }  temporary table, no persistent columns \line{\f1  itsTableExists = 2 }  table currently defined in system catalog \line{\f1  itsDataLoaded  = 3 }  table currently present in memory \line{\f1  itsUserClear   = 4 }  user state flag reset, not used internally \line{\f1  itsUserSet     = 5 }  user state flag set, not used internally \line{\f1  itsOutputDb    = 6 }  persistence transferred to output database \line{\f1  itsSaveError   = 7 }  error saving table, will retry at Commit \line{\f1  itsUnlockTable = 8 }  table is not locked in memory \line{\f1  itsLockTable   = 9 }  table locked in memory \line{\f1  itsTransform   = 10}  table needs to be transformed when loaded \page #{\footnote MsiDatabase_GetCatalogTable} ${\footnote MsiDatabase.GetCatalogTable} +{\footnote MsiDatabase:GetCatalogTable} K{\footnote GetCatalogTable} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b GetCatalogTable Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns one of the MsiTable objects maintained by the MsiDatabase object that  contain the table definitions for the database.  The returned MsiTable object is read-only, and its data can be queried by  creating an MsiCursor object on the table. The table structures are given below. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .GetCatalogTable({\i table})} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b table}\line Required. Table to access: 0 = {\uldb _Tables}{\v _msi__Tables_Table@msi.hlp}, 1 = {\uldb _Columns}{\v _msi__Columns_Table@msi.hlp}. \par\fi0\li0{\b Tables Catalog Table Definition} \line   1 - Table name, primary key for this catalog table \line   2 - MsiTable object, only if table is loaded into memory \par\fi0\li0{\b Columns Catalog Table Definition} \line   1 - Table name, 1st column of primary key for this catalog table \line   2 - Column number, remainder of primary key \line   3 - Column name, may be Null \line   4 - Column type, integer containing packed size and type information \par\fi0\li0{\b Remarks}\par\li180 These tables are maintained for ODBC databases as well as MSI databases,  and will also contain definitions for any temporary tables created. \page #{\footnote MsiDatabase_DecodeString} ${\footnote MsiDatabase.DecodeString} +{\footnote MsiDatabase:DecodeString} K{\footnote DecodeString} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b DecodeString Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This function converts a database string index into its referenced string. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .DecodeString({\i index})} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b index}\line Required. The database string index, 0 is always the null string. \page #{\footnote MsiDatabase_EncodeString} ${\footnote MsiDatabase.EncodeString} +{\footnote MsiDatabase:EncodeString} K{\footnote EncodeString} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b EncodeString Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This function converts a string into its corresponding database string index.  If the string is not used in the database the value 0 will be returned.  An empty string is treated as a Null in the database and not stored.  Consequently, this functions returns 0 for an empty string. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .EncodeString({\i text})} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b text}\line Required. The string for which the string index is requested. \page #{\footnote MsiDatabase_CreateTempTableName} ${\footnote MsiDatabase.CreateTempTableName} +{\footnote MsiDatabase:CreateTempTableName} K{\footnote CreateTempTableName} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b CreateTempTableName Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns a unique table name that can be used for a temporary database table  using the {\uldb CreateTable method}{\v MsiDatabase_CreateTable}. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .CreateTempTableName} \par{\i object}\line Required. The MsiDatabase object. \page #{\footnote MsiDatabase_Persist} ${\footnote MsiDatabase.Persist} +{\footnote MsiDatabase:Persist} K{\footnote Persist} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Persist Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180  {\b --This method is OBSOLETE.--} use {\uldb Commit}{\v MsiDatabase_Commit} instead.  Finalizes the persistent form of the database. Depending upon the action specified,  changes made to the database since it was opened can be committed or rolled back,  or the database can be physically deleted when the current object is destructed.  If the MsiDatabase object has been created read-only, this method will have no effect  and no error will be generated. If the  {\uldb CreateOutputDatabase}{\v MsiDatabase_CreateOutputDatabase} method has be called,  any unloaded input database tables will be transferred to the output database.  This method is normally called prior to shutdown when all database changes have been finalized.  If this method is never explicitly called, the database will be rolled back when the Database object is destructed,  with {\i\b action} set to {\f1 idpRollback}. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Persist {\i action}} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b action}\line Required. The action to be taken on the persistent format, on of the enum idpEnum: \line{\f1  idpRollback  = 0 = FALSE } NO-OP (rollback performed at database destruction) \line{\f1  idpCommit    = 1 = TRUE  } current updates committed, further updates allowed \line{\f1  idpDelete    = 2         } file is to be deleted when all references released \line{\f1  idpSave      = 3         } NOT SUPPORTED \page #{\footnote MsiDatabase_Commit} ${\footnote MsiDatabase.Commit} +{\footnote MsiDatabase:Commit} K{\footnote Commit} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Commit Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Finalizes the persistent form of the database. All persistent data will be written  to the writable database. No temporary columns or rows are written. This method has  no effect on a database opened read-only. This method can be call multiple times to  save the current state of tables loaded into memory. When the database is finally  closed, any changes made subsequent to the last Commit will be rolled back.  If the {\uldb CreateOutputDatabase}{\v MsiDatabase_CreateOutputDatabase} method has be called,  any unloaded input database tables will be transferred to the output database, applying transforms as required..  This method is normally called prior to shutdown when all database changes have been finalized. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Commit} \par{\i object}\line Required. The MsiDatabase object. \page #{\footnote MsiDatabase_CreateOutputDatabase} ${\footnote MsiDatabase.CreateOutputDatabase} +{\footnote MsiDatabase:CreateOutputDatabase} K{\footnote CreateOutputDatabase} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b CreateOutputDatabase Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Specifies the name of the output database to be created that will contain the  original database as modified by all update operations. This method will  fail if called after any modifications have been written to the original database.  This does not apply to changes made to tables loaded into memory, as the changes  are not written to the persistent database until the tables are released from memory. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .CreateOutputDatabase {\i file, saveTempRows}} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b file}\line Required. The name of the database to be created. Only .msi database format is currently supported. \par{\i\b saveTempRows}\line Optional. True to persist temporary table rows, False to drop them from persistent storage. \par\fi0\li0{\b Remarks}\par\li180 The method in provided to avoid unnecessary copying of the database.  Often the final location of the updated database is not known without processing the  information in the database itself, and the database could be significantly updated.  If this method is used, the original database can be opened read-only, and thus may reside  on a CD or a read-only server. This method must be called before the first update to the  persistent database, i.e. released a modified table from memory, or performing a update on a  non-loaded table using any of the update methods of the MsiView object.  When this MsiDatabase object is released, all unmodified tables, along with associated binary stream data,  will be copied to the output database. \page #{\footnote MsiDatabase_GenerateTransform} ${\footnote MsiDatabase.GenerateTransform} +{\footnote MsiDatabase:GenerateTransform} K{\footnote GenerateTransform} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b GenerateTransform Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \par}\li180 Creates a transform which, when applied to the {\i object} database, will  result in the {\i reference} database. The transform is stored in the  {\i storage} object. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .GenerateTransform({\i reference, storage, long errorConditions, long validation})} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b reference}\line Required. The reference MsiDatabase object. \par{\i\b storage}\line Required. The MsiStorage object where the transform is to be stored. \par{\i\b errorConditions}\line Required. The conditions that should be ignored as errors when  the transform is applied.\line Choose either: \line{\f1  iteNone                }- None of the following conditions. \line Or combine one or more of the following: \line{\f1  iteAddExistingRow      }- Adding a row that already exists. \line{\f1  iteDelNonExistingRow   }- Deleting a row that doesn't exist. \line{\f1  iteAddExistingTable    }- Adding a table that already exists. \line{\f1  iteDelNonExistingTable }- Deleting a table that doesn't exist. \line{\f1  iteUpdNonExistingRow   }- Updating a row that doesn't exist. \par{\i\b validation}\line Required. When the transform is applied to a database, which properties should  be validated to verify that this transform can be applied to the database.  The properties are all contained in the  {\uldb Summary Information}{\v Summary_Overview} stream. \line{\f1  itvNone           }- Validate no properties. \line Or combine one or more of the following \line{\f1  itvLanguage       }- Default language must match base database. \line{\f1  itvProduct        }- Product must match base database. \line{\f1  itvPlatform       }- Platform must match base database. \line To validate product version, first choose one or more of these  three flags to indicate how much of the version is to be verified. \line{\f1  itvMajVer         }- Check major version only. \line{\f1  itvMinVer         }- Check major and minor version only. \line{\f1  itvUpdVer         }- Check major, minor, and update version. \line Then choose one of the following to indicate the required  relationship between the product version of the database the transform  is being applied to, and that of the base database. \line{\f1  itvLess           }- Applied db version <  base db version \line{\f1  itvLessOrEqual    }- Applied db version <= base db version \line{\f1  itvEqual          }- Applied db version =  base db version \line{\f1  itvGreaterOrEqual }- Applied db version >= base db version \line{\f1  itvGreater        }- Applied db version >  base db version \par\fi0\li0{\b Remarks}\par\li180 !! The error and validation conditions may or may not work !!\line\line For tables that exist in both databases, the only difference between the two  schemas that is allowed is the addition of columns to the {\b end} of the   reference table. This means that you cannot add primary key columns to a  table or change the order or names or column definitions of the existng columns  as defined in the base table.  Therefore, the reference table must contain the  exact same table schema, but it can have some additional/extra columns.  These  columns must come after the columns defined in the base table though.  In other words,  if neither table contained data and the extra columns were removed from the reference  table, the resulting refernce table would be identifcal to the base table.  No deletion  of columns, addition of primary keys, or changing of column definitions is allowed. \page #{\footnote MsiDatabase_SetTransform} ${\footnote MsiDatabase.SetTransform} +{\footnote MsiDatabase:SetTransform} K{\footnote SetTransform} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b SetTransform Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \par}\li180 SetTransform will apply the given transform to this database. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .SetTransform({\i storage}, {\i errorConditions})} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b storage}\line Required. The MsiStorage object containing the transform. \par{\i\b treatAsError}\line Required. The conditions that should be ignored as errors, specified as an  integer combination of the values below. \line{\f1  iteAddExistingRow       } Adding a row that already exists. \line{\f1  iteDelNonExistingRow    } Deleting a row that doesn't exist. \line{\f1  iteAddExistingTable     } Adding a table that already exists. \line{\f1  iteDelNonExistingTable  } Deleting a table that doesn't exist. \line{\f1  iteUpdNonExistingRow    } Updating a row that doesn't exist. \par\fi0\li0{\b Remarks}\par\li180 SetTransform delays transforming tables until the last possible moment.  The steps  taken in SetTransform are to immediately transform the table and column catalogs  for the database.  The table and column catalogs are updating according to what  table is added or deleted and what column is added (no deletion of columns is  allowed).  If a table is currently loaded in memory and needs to be transformed,  it will be transformed then.  Else, the table's state will be set to that requiring  a transform so that when it is loaded or when the database is committed the transform  will be applied.  Transform in this instance means that the actual data (row data) of  the table is added, deleted, or updated. If SetTransform is called when tables have already been saved  to storage, an error will occur. \page #{\footnote MsiDatabase_MergeDatabase} ${\footnote MsiDatabase.MergeDatabase} +{\footnote MsiDatabase:MergeDatabase} K{\footnote MergeDatabase} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MergeDatabase Method \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \par}\li180 MergeDatabase will merge the reference database in with the base database. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .MergeDatabase({\i reference}, {\i errorTable})} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b reference}\line Required. The MsiDatabase object to be merged into the base. \par{\i\b errorTable}\line Optional. A table object to contain the names of the tables containing  merge conflicts, the number of conflicting rows within the table, and a  reference to the table with the merge conflict. \par\fi0\li0{\b Remarks}\par\li180 If no table is provided, the general error message provides the number of  tables containing merge conflicts.  Any table can be passed in, but all other  columns must be nullable as the operation to update the error table will fail  if a column is not nullable.  A newly created table can be passed in as well  since the MergeDatabase method will automatically create the columns it uses if  merge conflicts are found.  Three columns are used for presenting merge conflicts.   The first column is the table's name.  It's also the primary key column.  Column  two is the number of rows of that table that had merge failures.  Column three is  a temporary column that is not persisted/saved.  It contains the reference to the table  that can be obtained by cursor.ObjectData on that column and then asking for the iidMsiTable  interface.  This reference enables one to go through the table and output those rows where  merge failures occurred [using iraMergeFailed bit.]  If this is not done, that bit for that  row will be cleared, as the iraMergeFailed bit is not a persistent bit.  It should be noted  that Column three is not a persistent column, so upon commitance of the database that contains  this table, only column one and column two will remain.  \par If tables of the same name in both databases do not match in the number of  primary keys, the column types, the number of columns, or the column names,   the MergeDatabase method will fail, and will post an error message pertaining to which mismatch   occurred.  \par For the error table to remain, the error handler must commit the database to which the error table   belongs.  However, this commit should be done after using the third column to obtain the references   to those tables where merge conflicts occurred.  When the database is committed, the third column will   be lost as it is not a persistent column since it temporarily stores an object [the reference to   the table]. \page #{\footnote MsiDatabase_UpdateState} ${\footnote MsiDatabase.UpdateState} +{\footnote MsiDatabase:UpdateState} K{\footnote UpdateState} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b UpdateState Property \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the current persistence state of the database, as one of enum idsEnum: \line{\f1  idsRead     = 0} database open read-only, changes are not saved \line{\f1  idsWrite    = 1} database fully operational for read and write \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .UpdateState} \par{\i object}\line Required. The MsiDatabase object. \page #{\footnote MsiDatabase_ANSICodePage} ${\footnote MsiDatabase.ANSICodePage} +{\footnote MsiDatabase:ANSICodePage} K{\footnote ANSICodePage; codepage} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ANSICodePage Property \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the ANSI codepage of the current database, 0 if language neutral \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .ANSICodePage} \par{\i object}\line Required. The MsiDatabase object. \par\fi0\li0{\b Remarks}\par\li180 The string data in a persisted database is stored in a single codepage,  in order to support Win9x and to optimize storage. If the strings have no extended  characters, then the codepage is defaulted to 0, language-neutral. Table import,  merge, or transform operations will set a neutral database to any non-neutral merged data,  and will be rejected if a codepage conflict occurs. \page #{\footnote MsiDatabase_Storage} ${\footnote MsiDatabase.Storage} +{\footnote MsiDatabase:Storage} K{\footnote Storage} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Storage Property \line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the designated MsiStorage object if present, else returns an empty (Nothing) object, \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Storage({\i index})} \par{\i object}\line Required. The MsiDatabase object. \par{\i\b index}\line Required. An integer designating which storage to return. \line{\f1  0} The output database storage if   {\uldb CreateOutputDatabase}{\v MsiDatabase_CreateOutputDatabase} succeeded. \line{\f1  1} The original storage if the database was created from an MsiStorage  or from an MSI database file. \line{\f1 >1} Auxiliary storages used for transforms (not implemented yet). \page #{\footnote MsiView_Object} ${\footnote MsiView Object} K{\footnote MsiView; MsiDatabase} +{\footnote Class:MsiView} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MsiView Object \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This object represents a result set obtained processing a query using the  MsiDatabase method {\uldb OpenView}{\v MsiDatabase_OpenView}.  Before any data can be transferred the query must be executed  using the {\uldb Execute}{\v MsiView_Execute} method, passing to it  all replaceable parameters designated within the SQL query string.  The query may be reexecuted, with different parameters if desired,  but only after freeing the result set either by fetching all the  records or by calling the {\uldb Close}{\v MsiView_Close} method.  The data transfer methods will fail if the corresponding intent flags  were not specified in the {\uldb OpenView}{\v MsiDatabase_OpenView} call.   \par\li0{\b Methods}\par\li180 {\uldb Execute}{\v MsiView_Execute}\line {\uldb Fetch}{\v MsiView_Fetch}\line {\uldb GetColumnNames}{\v MsiView_GetColumnNames}\line {\uldb GetColumnTypes}{\v MsiView_GetColumnTypes}\line {\uldb Update}{\v MsiView_Update}\line {\uldb Insert}{\v MsiView_Insert}\line {\uldb Delete}{\v MsiView_Delete}\line {\uldb Modify}{\v MsiView_Modify}\line {\uldb Close}{\v MsiView_Close}\line {\uldb GetError}{\v MsiView_GetError}\line \par\li0{\b Properties}\par\li180 {\uldb FieldCount}{\v MsiView_FieldCount}\line {\uldb RowCount}{\v MsiView_RowCount}\line {\uldb State}{\v MsiView_State}\line \page #{\footnote MsiView_Execute} ${\footnote MsiView.Execute} +{\footnote MsiView:Execute} K{\footnote Execute} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Execute Method \line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Accepts replaceable query parameters and executes the database query,  producing a result set that can be fetched or updated. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Execute {\i record}} \par{\i object}\line Required. The MsiView object. \par{\i\b record}\line Optional. MsiRecord objects containing values to replace parameter markers,  "?", in the SQL query. \par\fi0\li0{\b Remarks}\par\li180 This method must be called before any calls to {\uldb Fetch}{\v MsiView_Fetch}.  If the SQL query specifies values in the predicate expression with parameter  markers (question marks), then a record must be supplied containing all of  the replacement values in the exact order and of compatible data types. \page #{\footnote MsiView_FieldCount} ${\footnote MsiView.FieldCount} +{\footnote MsiView:FieldCount} K{\footnote FieldCount} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b FieldCount Property \line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 A long indicating the number of columns the will be fetched into MsiRecord fields. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .FieldCount} \par{\i object}\line Required. The MsiView object. \page #{\footnote MsiView_RowCount} ${\footnote MsiView.RowCount} +{\footnote MsiView:RowCount} K{\footnote RowCount} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b RowCount Property \line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 A long indicating the number of rows affected by MsiView.Execute. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .RowCount} \par{\i object}\line Required. The MsiView object. \par\fi0\li0{\b Remarks}\par\li180 Should be called only after the MsiView.Execute and before a MsiView.Close. Would return error otherwise \page #{\footnote MsiView_State} ${\footnote MsiView.State} +{\footnote MsiView:State} K{\footnote State} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b State Property \line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 A long indicating the current cursor state for the MsiView object. Is one of \line {\b dvcsClosed}\line The MsiView object is currently in the state closed.\line {\b dvcsPrepared}\line The MsiView object has been prepared i.e. the SQL query has been parsed. \line {\b dvcsExecuted}\line  Internal use only.\line  {\b dvcsBound}\line  Parameters to the SQL query, if any have been bound to the SQL query.  This is the state before the first Fetch. (The MsiView::Execute() function has been executed).\line {\b dvcsFetched}\line  Atleast one record has been successfully fetched from the MsiView object (via the MsiView::Fetch() function).\line {\b dvcsDestructor}\line Internal use only.\line  \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .RowCount} \par{\i object}\line Required. The MsiView object. \par\fi0\li0{\b Remarks}\par\li180 \page #{\footnote MsiView_Fetch} ${\footnote MsiView.Fetch} +{\footnote MsiView:Fetch} K{\footnote Fetch} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Fetch Method \line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns an MsiRecord object containing the requested column data if more rows  are available in the result set, else returns an object of value Nothing. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Fetch} \par{\i object}\line Required. The MsiView object. \par\fi0\li0{\b Remarks}\par\li180 This method must be called after {\uldb Execute}{\v MsiView_Execute}.  For maximum performance, the same record object should be used for all fetches,  or else it should be released by going out of scope. The returned record can  be tested for the end of the result set using the syntax:  "If FetchRecord Is Nothing". \page #{\footnote MsiView_GetColumnNames} ${\footnote MsiView.GetColumnNames} +{\footnote MsiView:GetColumnNames} K{\footnote GetColumnNames} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b GetColumnNames Method \line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns an MsiRecord object containing the columns names corresponding to the fetched record fields. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .GetColumnNames} \par{\i object}\line Required. The MsiView object. \page #{\footnote MsiView_GetColumnTypes} ${\footnote MsiView.GetColumnTypes} +{\footnote MsiView:GetColumnTypes} K{\footnote GetColumnTypes} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b GetColumnTypes Method \line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns an MsiRecord objects with text fields containing the data types of  the corresponding database columns, in the   {\b\uldb Archive File Format}{\v Table_ArchiveFormat} used by ExportTable. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .GetColumnTypes} \par{\i object}\line Required. The MsiView object. \par\fi0\li0{\b Remarks}\par\li180 \page #{\footnote MsiView_Update} ${\footnote MsiView.Update} +{\footnote MsiView:Update} K{\footnote Update} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Update Method \line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Updates a database row with a modified MsiRecord object obtained by the Fetch method. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Update {\i record}} \par{\i object}\line Required. The MsiView object. \par{\i\b record}\line Required. The MsiRecord object obtained by the Fetch method, with modified field data. \par\fi0\li0{\b Remarks}\par\li180 Only the record fields that have been updated will be written to the database.  Thus multiple threads can update the same rows independently as long as they  have modified different database columns. \page #{\footnote MsiView_Insert} ${\footnote MsiView.Insert} +{\footnote MsiView:Insert} K{\footnote Insert} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Insert Method \line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Inserts a new row into the database with values in an MsiRecord object.  This method will fail if the primary key columns contain any Null  values or as a group match any existing row in the table. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Insert {\i record}} \par{\i object}\line Required. The MsiView object. \par{\i\b record}\line Required. An MsiRecord object containing values for a new database row. \par\fi0\li0{\b Remarks}\par\li180 The values in the record fields must match the query specification in sequence  and in data types (same as would be obtained by the Fetch method). Null values  may be supplied in the record fields as long as they are not part of the primary key. \page #{\footnote MsiView_Delete} ${\footnote MsiView.Delete} +{\footnote MsiView:Delete} K{\footnote Delete} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Delete Method \line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Removes the row corresponding the MsiRecord just obtained with the Fetch method. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Delete {\i record}} \par{\i object}\line Required. The MsiView object. \par{\i\b record}\line Required. The MsiRecord object obtained by the Fetch method. \par\fi0\li0{\b Remarks}\par\li180 This method will fail if the primary key fields are modified, or if the primary  key no longer exists in the database. \page #{\footnote MsiView_Modify} ${\footnote MsiView.Modify} +{\footnote MsiView:Modify} K{\footnote Modify} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Modify Method \line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Modifies a database row with a modified MsiRecord object obtained by the Fetch method. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Modify {\i record} {\i action}} \par{\i object}\line Required. The MsiView object. \par{\i\b record}\line Required. The MsiRecord object obtained by the Fetch method, with modified field data. \par{\i\b action}\line Required. Indicates the action to be performed on the database row. The operation map on to one with the modification  operation that can be performed on the {\uldb MsiCursor}{\v MsiCursor_Object} object. Is one of - \line \line {\b irmSeek}\line Completes the record data.  Seek requires that the primary key fields be filled in and then fills in the rest of the data,  allowing one to seek to a particular entry in the table (instead of having to fetch and compare).  The record must contain  all columns of the table.  Corresponds to the {\uldb MsiCursor.Seek}{\v MsiCursor_Seek} operation.  One can Insert/Update/Delete  the record after seeking.\line {\b irmInsert}\line Inserts the information into the database table. The operation does not require a {\uldb MsiView.Fetch}{\v MsiView_Fetch} to have been  performed before its calling. The function will fail if a row with the same primary key(s) exist in the table.  Corresponds to the {\uldb MsiCursor.Insert}{\v MsiCursor_Insert} operation.  The database must be open for modification. \line {\b irmInsertTemporary}\line Temporarily inserts the information into the database table. The operation does not require a {\uldb MsiView.Fetch}{\v MsiView_Fetch} to have been  performed before its calling and the database does not have to be open for modification. The function will fail if a row with the same primary key(s) exist in the table.  Corresponds to the {\uldb MsiCursor.InsertTemporary}{\v MsiCursor_InsertTemporary} operation \line {\b irmUpdate}\line Updates the information already existing in the database allowing modification of non-primary keys only. The operation does not require a {\uldb MsiView.Fetch}{\v MsiView_Fetch}  to have been  performed before its calling and has to be called with the same record as that returned by the fetch. The function will fail if the row has been deleted from the table.  Corresponds to the {\uldb MsiCursor.Update}{\v MsiCursor_Update} operation.  Requires that the database be open for modification. Update can occur on a fetched,  inserted, or deleted record.\line {\b irmDelete}\line Deletes the information already existing in the database (that is open for modification). The operation does not require a {\uldb MsiView.Fetch}{\v MsiView_Fetch}  to have been  performed before its calling and has to be called with the same record as that returned by the fetch. The function will fail if the row has been deleted from the table.  Corresponds to the {\uldb MsiCursor.Delete}{\v MsiCursor_Delete} operation.  Delete can be done on a fetched, inserted, or seeked record. \line {\b irmRefresh}\line Refreshes the information in the record from the database. The operation requires a {\uldb MsiView.Fetch}{\v MsiView_Fetch}  to have been  performed before its calling and has to be called with the same record as that returned by the fetch. The function will fail if the row has been deleted from the table.  Corresponds to the {\uldb MsiCursor.Refresh}{\v MsiCursor_Refresh} operation \line {\b irmAssign}\line Inserts/updates the information into the database table. The operation does not require a {\uldb MsiView.Fetch}{\v MsiView_Fetch} to have been  performed before its calling.  An update operation takes place if primary keys match an existing row. An insert operation takes place if primary  keys do not match any row. In either case the current data in the cursor are written to a table row.  Corresponds to the {\uldb MsiCursor.Assign}{\v MsiCursor_Assign} operation. Requires that the database be open for modification.\line {\b irmMerge}\line Inserts/validates the information into the database table. The operation does not require a {\uldb MsiView.Fetch}{\v MsiView_Fetch} to have been  performed before its calling. An insert operation takes place if primary keys do not match any row. A validation operation takes place if primary  keys match an existing row. The operation fails if the record data does not match the data in the table. Corresponds to the {\uldb MsiCursor.Merge}{\v MsiCursor_Merge} operation. Requires that the database be open for modification. \line {\b irmReplace}\line Updates/Delete-Inserts the information into the database table. The operation requires a {\uldb MsiView.Fetch}{\v MsiView_Fetch} to have been  performed before its calling and has to be called with the same record as that returned by the fetch. If the primary key(s) have not been  changed then an update of the table row occurs. If the primary key(s) have been changed the old table row is deleted and a new row corresponding  to the record is inserted. Corresponds to the {\uldb MsiCursor.Replace} operation.  Requires that the database be open for modification. \line {\b irmValidate}\line Validates a record.  Will not validate across joins. The operation requires a {\uldb MsiView.Fetch}{\v MsiView_Fetch} performed before its calling and has to be called with  the same record as that returned by the fetch.  Validation errors can be obtained by subsequent callings to {\uldb MsiView.GetError}{\ MsiView_GetError}.  Corresponds to the {\uldb MsiCursor.Validate}{\v MsiCursor_Validate} operation passing in 0 as the value for iCol.\line {\b irmValidateNew}\line Validates a record as a new record.  Requires the database to be open for modification. Will not validate across joins. This differs from irmValidate in that it checks for duplicate keys.  The operation requires that  {\uldb MsiDatabase.OpenView}{\v MsiDatabase_OpenView} be called with a modify value.  Validation errors can be obtained by  subsequent callings to {\uldb MsiView.GetError}{\v MsiView_GetError}.  Corresponds to the {\uldb MsiCursor.Validate}{\v MsiCursor_Validate}  operation passing in -1 as the value for iCol.\line {\b irmValidateField}\line Validates a field(s) of a fetched or new record.  Will not validate across joins. The validation depends upon the number of fields in the record.  If only one field exists,  it will validate the one field.  It can also validate more fields.  It should be used when the fetched/new record does not represent every  column of the table. Makes repeated calls to {\uldb MsiCursor.Validate}{\v MsiCursor_Validate} depending upon the number of fields in the record.\line {\b irmValidateDelete}\line Validates a fetched record.  Will not validate across joins. The validation depends upon the _Validation table and in particular the 'KeyTable' and 'KeyColumn'  columns of the table.  Validate delete returns an error if a row in the same table or another table explicitly references the primary  key(s) of the row to be deleted.  It requires that the database be open for modification and the operation requires a {\uldb MsiView.Fetch}{\v MsiView_Fetch} performed before its calling and has to be called with  the same record as that returned by the fetch. Corresponds to the {\uldb MsiCursor.Validate}{\v MsiCursor_Validate} operation passing in a -2 as the value for iCol.\line \par\fi0\li0{\b Remarks}\par\li180 \page #{\footnote MsiView_Close} ${\footnote MsiView.Close} +{\footnote MsiView:Close} K{\footnote Close} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Close Method \line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Terminates query execution and releases database resources. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Close} \par{\i object}\line Required. The MsiView object. \par\fi0\li0{\b Remarks}\par\li180 This method must be called before the Execute method is called again on the  MsiView object, unless all rows of the result set have been obtained with the  Fetch method. It will be called internally when the view is destroyed. \page #{\footnote MsiView_GetError} ${\footnote MsiView.GetError} +{\footnote MsiView:GetError} K{\footnote GetError} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b GetError Method \line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the Validation error and the column name for which the error occured.  In automation,  the return is a string of the form ColumnName,Error.  It returns the first error it finds in  the view's error array.  So, once a return of ColumnName,0 [zero does not show up in automation],  no more errors exist.  See {\uldb MsiCursor_Validate}{\v MsiCursor_Validate} for error enums. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .GetError} \par{\i object}\line Required. The MsiView object. \par\fi0\li0{\b Remarks}\par\li180 \page #{\footnote MsiTable_Object} ${\footnote MsiTable Object} K{\footnote MsiTable} +{\footnote Class:MsiTable} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MsiTable Object \par}\li180 This object represents a database table loaded into memory and is accessed by a  very efficient internal query engine. The table may be an image of a persistent  table with option temporary columns added, or may be totally composed of  temporary columns. If column names are not supplied, they are not accessible for  joins or by SQL. To access table data, an {\uldb MsiCursor}{\v MsiCursor_Object}  object is created that can be positioned sequentially or can seek to a particular  set of data values. The cursor seek operation will be slower when the search values  do not include the primary key columns. When a cursor object is created or when its Reset  method is called, it will be logically positioned just before the first table row.  The Next method always moves forward from the current cursor position. If a  table is linked as a tree, a tree-walking cursor can be created that will advance   to the next node in a depth-first traversal. \par Persistent tables are normally loaded into memory when a table object is created  and removed from memory when the last reference to the table object is released.  The LockTable function is used to keep a frequently used table in memory  independently of reference counts. As long as the lock calls are greater than  the unlock calls, the table remains in memory until the database is closed. \par For performance reasons, strings are not stored in the table data. Rather,  integer indices are stored which reference a common string pool maintained by  the database. Internally, string uses are reference counted as part of the string  management. Functions are provided in the {\uldb MsiDatabase}{\v MsiDatabase_Object}  object to convert strings to and from string indices. A string index of 0 indicates  a Null string value. \par\li0{\b Properties}\par\li180 {\uldb Database}{\v MsiTable_Database}\line {\uldb RowCount}{\v MsiTable_RowCount}\line {\uldb ColumnCount}{\v MsiTable_ColumnCount}\line {\uldb PrimaryKeyCount}{\v MsiTable_PrimaryKeyCount}\line {\uldb ReadOnly}{\v MsiTable_ReadOnly}\line {\uldb ColumnName}{\v MsiTable_ColumnName}\line {\uldb ColumnType}{\v MsiTable_ColumnType}\line \par\li0{\b Methods}\par\li180 {\uldb GetColumnIndex}{\v MsiTable_GetColumnIndex}\line {\uldb CreateColumn}{\v MsiTable_CreateColumn}\line {\uldb CreateCursor}{\v MsiTable_CreateCursor}\line {\uldb LinkTree}{\v MsiTable_LinkTree}\line \page #{\footnote MsiTable_Database} ${\footnote MsiTable.Database} +{\footnote MsiTable:Database} K{\footnote DATABASE} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Database Property \line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the {\uldb MsiDatabase object}{\v MsiDatabase_Object} that owns this table. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Database} \par{\i object}\line Required. The MsiTable object. \page #{\footnote MsiTable_RowCount} ${\footnote MsiTable.RowCount} +{\footnote MsiTable:RowCount} K{\footnote RowCount} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b RowCount Property \line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the number of rows that are currently contained in the table. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .RowCount} \par{\i object}\line Required. The MsiTable object. \page #{\footnote MsiTable_ColumnCount} ${\footnote MsiTable.ColumnCount} +{\footnote MsiTable:ColumnCount} K{\footnote ColumnCount} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ColumnCount Property \line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the number of columns defined in the table. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .ColumnCount} \par{\i object}\line Required. The MsiTable object. \page #{\footnote MsiTable_PrimaryKeyCount} ${\footnote MsiTable.PrimaryKeyCount} +{\footnote MsiTable:PrimaryKeyCount} K{\footnote PrimaryKeyCount} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b PrimaryKeyCount Property \line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the number of columns that comprise the primary key for the table. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .PrimaryKeyCount} \par{\i object}\line Required. The MsiTable object. \page #{\footnote MsiTable_ReadOnly} ${\footnote MsiTable.ReadOnly} +{\footnote MsiTable:ReadOnly} K{\footnote ReadOnly} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ReadOnly Property \line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns a boolean, True if table is not updatable, False if  the table can be updated provided the database is not read-only. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .ReadOnly({column})} \par{\i object}\line Required. The MsiTable object. \page #{\footnote MsiTable_ColumnName} ${\footnote MsiTable.ColumnName} +{\footnote MsiTable:ColumnName} K{\footnote ColumnName} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ColumnName Property \line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the string index for the name of the designated column,  or 0 if the column does not exist or if it has no name. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .ColumnName({column})} \par{\i object}\line Required. The MsiTable object. \par{\i\b column}\line Required. Column index, 1-based. \par\fi0\li0{\b Remarks}\par\li180 The string index may be converted to the corresponding string using the  {\b MsiDatabase} method {\uldb DecodeString}{\v MsiDatabase_DecodeString}. \page #{\footnote MsiTable_ColumnType} ${\footnote MsiTable.ColumnType} +{\footnote MsiTable:ColumnType} K{\footnote ColumnType} K{\footnote itdShort;itdLong;itdObject;itdString} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ColumnType Property \line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the column definition for the designated column, as an integer containing bit flags: \line{\f1  icdObject     } some type of object if 1, else integer if 0 \line{\f1  icdShort      } if icdObject: 1=string, 0=other object; else 1=16-bit integer, 0=32-bit integer \line{\f1  icdPersistent } persistent column if 1 (objects are streams), temporary if 0 \line{\f1  icdNullable   } if 1, column will accept null values \line{\f1  icdPrimaryKey } if 1, column comprises part of primary key \line The SQL data width for persistent columns is returned in the lower 8 bits (AND with 255). \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .ColumnType({\i column})} \par{\i object}\line Required. The MsiTable object. \par{\i\b column}\line Required. Column index, 1-based. \par\fi0\li0{\b Remarks}\par\li180 Three types of objects, all derived from MsiData, can be stored: \line  Strings stored as indices into the string pool, icdObject+icdShort \line  Persistent stream objects, accessible via MsiCursor.StreamData, icdObject+icdPersistent \line  Other objects derived from MsiData, accessible via MsiCursor.ObjectData, icdObject \page #{\footnote MsiTable_GetColumnIndex} ${\footnote MsiTable.GetColumnIndex} +{\footnote MsiTable:GetColumnIndex} K{\footnote GetColumnIndex} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b GetColumnIndex Method \line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the column number for a column name supplied as a string index.  Returns 0 if the column name does not exist for the table. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .GetColumnIndex({\i nameIndex})} \par{\i object}\line Required. The MsiTable object. \par{\i\b nameIndex}\line Required. The database string index for column name. \par\fi0\li0{\b Remarks}\par\li180 Use the MsiDatabase method {\uldb EncodeString}{\v MsiDatabase_EncodeString}  to convert a string into a string index. This method returns 0 if the column  name does not exist in the table, or if the string index is 0. \page #{\footnote MsiTable_CreateColumn} ${\footnote MsiTable.CreateColumn} +{\footnote MsiTable:CreateColumn} K{\footnote CreateColumn} K{\footnote itdShort;itdLong;itdObject;itdString} K{\footnote itcPrimaryKey;itcNullable;itcNoNulls} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b CreateColumn Method \line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180  Defines column parameters for a new column for an MsiTable object created with  {\uldb CreateTable}{\v MsiDatabase_CreateTable} or  {\uldb LoadTable}{\v MsiDatabase_LoadTable}.  Returns the column number for the created column if successful.  Fails if the column could not be created or if the a column by the same name already exists. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .CreateColumn({\i columnDef, name})} \par{\i object}\line Required. The MsiTable object. \par{\i\b columnDef}\line Required. The column attributes, an integer combination of the values below. \line The datatype of the column, comprising the bit flags icdObject and icdShort: \line{\f1  icdLong     } 32-bit integer value (icdLong = 0, for readability only) \line{\f1  icdShort    } 16-bit integer value, for persistent integer columns \line{\f1  icdObject   } MsiData object (non-persistent), MsiStream (persistent) \line{\f1  icdString   } string, stored as index to database string cache (icdObject+icdShort) \line Column characteristics: \line{\f1  icdPrimaryKey   } column is part of primary key \line{\f1  icdNullable     } column will accept null values \line{\f1  icdNoNulls      } value required (icdNoNulls = 0, for readability only) \line Persistence: \line{\f1  icdPersistent   } column saved in persistent database \line{\f1  icdTemporary    } temporary column (icdTemporary = 0, for readability only) \line SQL column width in bytes, a number between 0 and 255, persistent columns only \par{\i\b name}\line Optional. Column name, unique within the table. Persistent columns must be  given a name. Anonymous columns cannot be accessed via SQL queries. \par\fi0\li0{\b Remarks}\par\li180 All persistent columns must be defined before any non-persistent columns.  At least one column must be designated as the primary key column,  and the primary key columns must be the first columns in the table,  with the most-significant columns first.  Persistent columns cannot contain object references, but may contain binary streams.  Avoid 32-bit integers when possible for persistent columns, as the storage is inefficient.  Use 32-bit integers for termporary columns, as there is no bounds checking.  Persistent primary key columns cannot accept the icdNullable attribute.  Each row in the table must have a unique set of primary key values.  A maximum of 32 columns may be defined for a database table.  The number of rows is limited by the available memory. \page #{\footnote MsiTable_CreateCursor} ${\footnote MsiTable.CreateCursor} +{\footnote MsiTable:CreateCursor} K{\footnote CreateCursor} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b CreateCursor Method \line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns an {\uldb MsiCursor}{\v MsiCursor_Object} object that is in the reset state. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .CreateCursor({\i tree})} \par{\i object}\line Required. The MsiTable object. \par{\b\i tree}\line Optional. Boolean indicating whether to create a tree-walking cursor. A True value  will create a cursor that will walk a tree-linked table in tree traversal order,  whereas a False, or missing, value will create a normal cursor that will advance by row order.  The two types behave identically if the table is not tree-linked. \par\fi0\li0{\b Remarks}\par\li180 To avoid excessive processing, mimimize the number of active cursors on a table  that is subject to frequent row insertions and deletions. \page #{\footnote MsiTable_LinkTree} ${\footnote MsiTable.LinkTree} +{\footnote MsiTable:LinkTree} K{\footnote LinkTree} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b LinkTree Method \line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Links the table in depth-first tree-traveral order to support a tree-walking cursor.  If the tree cannot be fully resolved the method will fail, returning -1.  If the method succeeds, the number of tree roots will be returned (a return value of  0 indicates that the table is empty). A row parented to itself or having a Null parent  indicates a root node. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .LinkTree({\i parentColumn})} \par{\i object}\line Required. The MsiTable object. \par{\b\i parentColumn}\line Required. The column number specifying the tree parent data. This column  must contain values referencing the single primary key column of the table. \par\fi0\li0{\b Remarks}\par\li180  This method requires that the primary key be composed of a single column.  The method will fail if any of the values in the specified column do not match  a primary key value currently in the table. Once the table is linked, only leaf  node rows may be deleted (those that are not the parent of another row). Rows  may be inserted, provided that their parent values are present in the table.  Specifying a parentColumn value of zero will unlink the table, and all cursors  will then advance sequentially through the rows. \page #{\footnote MsiCursor_Object} ${\footnote MsiCursor Object} K{\footnote MsiCursor} +{\footnote Class:MsiCursor} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MsiCursor Object \par}\li180 To access table data, an MsiCursor object is created that can be positioned  sequentially or can seek to a particular set of data values. The cursor  seek operation will be slower when table's primary key columns are not specified.  When a cursor object is created or when its Reset method is called,  or when the Next method fails to find a qualifying row, it will be  logically positioned just before the first table row. The Next method always  moves forward from the current cursor position. If a table is linked as a tree,  a cursor can be created that advances to the next node in a depth-first traversal. The cursor contains a snapshot of a table row, and its data is transferred  to and from the table as an atomic operation. On update, only columns with  changed data will be transferred, thus allowing other columns to be updated  via other cursor objects. \par\li0{\b Properties}\par\li180 {\uldb Table}{\v MsiCursor_Table}\line {\uldb Filter}{\v MsiCursor_Filter}\line {\uldb IntegerData}{\v MsiCursor_IntegerData}\line {\uldb StringData}{\v MsiCursor_StringData}\line {\uldb DateData}{\v MsiCursor_DateData}\line {\uldb ObjectData}{\v MsiCursor_ObjectData}\line {\uldb StreamData}{\v MsiCursor_StreamData}\line {\uldb RowState}{\v MsiCursor_RowState}\line {\uldb Moniker}{\v MsiCursor_Moniker}\line \par\li0{\b Methods}\par\li180 {\uldb PutNull}{\v MsiCursor_PutNull}\line {\uldb Reset}{\v MsiCursor_Reset}\line {\uldb Next}{\v MsiCursor_Next}\line {\uldb Update}{\v MsiCursor_Update}\line {\uldb Insert}{\v MsiCursor_Insert}\line {\uldb InsertTemporary}{\v MsiCursor_InsertTemporary}\line {\uldb Assign}{\v MsiCursor_Assign}\line {\uldb Replace}{\v MsiCursor_Replace}\line {\uldb Merge}{\v MsiCursor_Merge}\line {\uldb Refresh}{\v MsiCursor_Refresh}\line {\uldb Delete}{\v MsiCursor_Delete}\line {\uldb Seek}{\v MsiCursor_Seek}\line {\uldb Validate}{\v MsiCursor_Validate}\line \page #{\footnote MsiCursor_IntegerData} ${\footnote MsiCursor.IntegerData} +{\footnote MsiCursor:IntegerData} K{\footnote IntegerData} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b IntegerData Property \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Transfers integer data to or from a column value in the cursor object. Read-write. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .IntegerData({\i column})} \par{\i object}\line Required. The MsiCursor object. \par{\i\b column}\line Required. Column index, 1-based. \par\fi0\li0{\b Remarks}\par\li180 A null value in an integer column will be returned as the defined constant {\f1 iMsiNullInteger}.  If the column is designated as a primary key or a non-null column, attempting  to set its value to {\f1 iMsiNullInteger} will produce an error. \par The IntegerData property will transfer data of all types as integers.  This method will fail if the column is type itdShort and the integers is outside the 16-bit range.  String data will be transferred using the database string index, and object data  will transferred as an integer containing the actual address of the object. Care must  exercised when passing objects as integers, as no validation can be done at this  low level. The integer returned for an object is not reference counted, but when an  object is set into the cursor using an integer, its AddRef method is called because  the cursor, and ultimately the database table, is keeping a copy of that pointer.  A null value for a non-integer column returned as an integer will be zero. \page #{\footnote MsiCursor_StringData} ${\footnote MsiCursor.StringData} +{\footnote MsiCursor:StringData} K{\footnote StringData} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b StringData Property \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Transfers string data to or from a string column value in the cursor object. Read-write. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .StringData({\i column})} \par{\i object}\line Required. The MsiCursor object. \par{\i\b column}\line Required. Column index, 1-based. \par\fi0\li0{\b Remarks}\par\li180 Setting StringData property on a non-string column will fail.  Returning the property on a non-string column will return an empty string. \page #{\footnote MsiCursor_DateData} ${\footnote MsiCursor.DateData} +{\footnote MsiCursor:DateData} K{\footnote DateData} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b DateData Property \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Transfers date/time data to or from a string or long integer column value in the  cursor object. Read-write. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .DateData({\i column})} \par{\i object}\line Required. The MsiCursor object. \par{\i\b column}\line Required. Column index, 1-based. \par\fi0\li0{\b Remarks}\par\li180 Returning the property on a non-date value may fail or return an invalid date. \page #{\footnote MsiCursor_ObjectData} ${\footnote MsiCursor.ObjectData} +{\footnote MsiCursor:ObjectData} K{\footnote ObjectData} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ObjectData Property \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Transfers object references to or from a column value in the cursor object. Read-write. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .ObjectData({\i column})} \par{\i object}\line Required. The MsiCursor object. \par{\i\b column}\line Required. Column index, 1-based. \par\fi0\li0{\b Remarks}\par\li180 Objects stored in the database tables must be derived from the MsiData base object  and cannot be stored in persistent columns. A Null value for an object has pointer  value of zero, but is set and tested in BASIC using the {\f1\b1 Missing} keyword.  If the column is designated as a primary key or a non-null column, attempting  to set its value to a null object will produce an error. Objects are reference  counted when stored in the MsiCursor and the MsiTable objects. \page #{\footnote MsiCursor_StreamData} ${\footnote MsiCursor.StreamData} +{\footnote MsiCursor:StreamData} K{\footnote StreamData} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b StreamData Property \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Transfers MsiStream objects to or from a column value in the cursor object. Read-write. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .StreamData({\i column})} \par{\i object}\line Required. The MsiCursor object. \par{\i\b column}\line Required. Column index, 1-based. \par\fi0\li0{\b Remarks}\par\li180 This property may only be used with persistent columns typed as icdObject. \page #{\footnote MsiCursor_Table} ${\footnote MsiCursor.Table} +{\footnote MsiCursor:Table} K{\footnote Table} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Table Property \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the {\uldb MsiTable object}{\v MsiTable_Object} that owns this cursor object. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Table} \par{\i object}\line Required. The MsiCursor object. \page #{\footnote MsiCursor_Reset} ${\footnote MsiCursor.Reset} +{\footnote MsiCursor:Reset} K{\footnote Reset} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Reset Method \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Positions cursor before first row, and clears all data to Null. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Reset} \par{\i object}\line Required. The MsiCursor object. \par\fi0\li0{\b Remarks}\par\li180 Because the {\b Next} method always progresses forward  through the data rows, {\b Reset} must be called first to insure  that all rows are found. When inserting new rows, {\b Reset} may     be called on the cursor to clear any existing data   if the cursor is not in the reset state. \page #{\footnote MsiCursor_PutNull} ${\footnote MsiCursor.PutNull} +{\footnote MsiCursor:PutNull} K{\footnote PutNull} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b PutNull Method \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Sets the designated column value to the Null value appropriate for the data type. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .PutNull {\i column}} \par{\i object}\line Required. The MsiCursor object. \par{\i\b column}\line Required. Column index, 1-based. \par\fi0\li0{\b Remarks}\par\li180 This method will fail unless the column has the icdNullable attribute. \page #{\footnote MsiCursor_Next} ${\footnote MsiCursor.Next} +{\footnote MsiCursor:Next} K{\footnote Next} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Next Method \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Positions this cursor to next database record in the table that matches the specified  filter values. If not filter columns are designated, the next sequential record  in primary key order will be returned. If the table is linked as a tree and a  tree-walking cursor has been created, the cursor will advance in tree traveral order.  Returns 0 if no more qualifying rows exist in the table, else returns the  tree level of the new row, 1 if the table is not linked as a tree. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Next} \par{\i object}\line Required. The MsiCursor object. \par\fi0\li0{\b Remarks}\par\li180 The filter mask, set by the {\uldb Filter}{\v MsiCursor_Filter} property,  designates columns in the cursor that contains values that must be matched.  If the mask is non-zero, rows will be skipped if the designated columns  contain data that does not match the values in the cursor. \page #{\footnote MsiCursor_Filter} ${\footnote MsiCursor.Filter} +{\footnote MsiCursor:Filter} K{\footnote Filter} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Filter Property \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 A long integer containing bit flags for all defined columns.  Marks data columns in the MsiCursor object to be used to match corresponding  data in the database table. Each bit in the filter corresponds to a database  column, with the low order bit (value=1) corresponding to the first column.  A value of zero removes all filter attributes from the columns. Read-write. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Filter} \par{\i object}\line Required. The MsiCursor object. \par\fi0\li0{\b Remarks}\par\li180 The Next method will skip over rows where the columns designated  by the filter mask do not match those in the cursor. If the filter includes  primary key columns, the search will be vastly improved because the  table rows are sorted by primary key. If the cursor was created as a  tree-walking cursor, it will advance to matching records in tree order, and  it will be optimized if the filter includes the primary key. \par\fi0\li0{\b Usage}\par\li180 In order to selectively filter rows in a table, the values to match must be set  into the corresponding columns in the MsiCursor object. The corresponding bits  must also be set in the filter mask to prevent fetching data into those columns.  When the cursor is reset, or reaches the end of the table, all data is cleared,  including the filter data, but the filter mask is not affected. To remove the  filter mask, this property value must be set to zero. \page #{\footnote MsiCursor_RowState} ${\footnote MsiCursor.RowState} +{\footnote MsiCursor:RowState} K{\footnote RowState} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b RowState Property \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Allows individual row attributes in a table row to read read or set. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .RowState({\i attribute})} \par{\i object}\line Required. The MsiCursor object. \par{\i\b attribute}\line Required. The row attribute to be read or set, one of iraEnum. \par{\i object}\line \par\fi0\li0{\b Row attributes}\par\li180 !!Not finished!! \par\fi0\li0{\b Remarks}\par\li180 !!Not finished!! \page #{\footnote MsiCursor_Update} ${\footnote MsiCursor.Update} +{\footnote MsiCursor:Update} K{\footnote Update} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Update Method \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Updates changed cursor data to the corresponding table row.  Returns True if the row was successfully updated. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Update} \par{\i object}\line Required. The MsiCursor object. \par\fi0\li0{\b Remarks}\par\li180 The table row to update is determined by set of primary key values.  If the primary key values to not match any existing row, the  function will fail and return False. \page #{\footnote MsiCursor_Insert} ${\footnote MsiCursor.Insert} +{\footnote MsiCursor:Insert} K{\footnote Insert} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Insert Method \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Inserts a new table row using the current cursor data.  The table must be writable for this method to succeed.  Returns True if the row was successfully inserted. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Insert} \par{\i object}\line Required. The MsiCursor object. \par\fi0\li0{\b Remarks}\par\li180 The table row position is determined by the primary key values.  If the primary key columns contain any Null values, or if the  set of primary key values matches an existing row, the method  will fail and return False. If the table is tree-linked, the inserted  row will be linked into the tree as a leaf node under the row specified  by its parent column (the column specified by {\uldb LinkTree}{\v MsiTable_LinkTree}). \page #{\footnote MsiCursor_InsertTemporary} ${\footnote MsiCursor.InsertTemporary} +{\footnote MsiCursor:InsertTemporary} K{\footnote InsertTemporary} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b InsertTemporary Method \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Inserts a new non-persistent table row using the current cursor data.  This method may be called on tables loaded from a read-only database.  Returns True if the row was successfully inserted. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .InsertTemporary} \par{\i object}\line Required. The MsiCursor object. \par\fi0\li0{\b Remarks}\par\li180 See {\b Remarks} under {\uldb MsiCursor.Insert}{\v MsiCursor_Insert} \page #{\footnote MsiCursor_Assign} ${\footnote MsiCursor.Assign} +{\footnote MsiCursor:Assign} K{\footnote Assign} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Assign Method \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Either updates an existing table row or inserts a new table row   using the current cursor data.  Returns True if either an update or an insert was successful. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Assign} \par{\i object}\line Required. The MsiCursor object. \par\fi0\li0{\b Remarks}\par\li180 The table row position is determined by the primary key values.  An update operation takes place if primary keys match an existing row.  An insert operation takes place if primary keys do not match any row.  In either case the current data in the cursor are written to a table row.  If any of the primary key values are Null, the method will fail and return False. \page #{\footnote MsiCursor_Replace} ${\footnote MsiCursor.Replace} +{\footnote MsiCursor:Replace} K{\footnote Replace} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Replace Method \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Updates a fetched row using current cursor data, allowing primary key changes.  Returns True if either an update or an insert+delete was successful. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Replace} \par{\i object}\line Required. The MsiCursor object. \par\fi0\li0{\b Remarks}\par\li180 The table row position is determined by the primary key values.  An update operation takes place if primary keys match an existing row.  An insert operation takes place if primary keys do not match any row,  in which case the row referenced by the previous key value will be delete (if not already deleted).  If any of the primary key values are Null, the method will fail and return False. \page #{\footnote MsiCursor_Merge} ${\footnote MsiCursor.Merge} +{\footnote MsiCursor:Merge} K{\footnote Merge} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Merge Method \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Either inserts a new record into the table, or insures that an existing record is identical.   Returns True if the insert was successful, or an existing record with the same key is completely matched.  If an existing record is not identical, the row attribute bit iraMergeFailed is set. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Merge} \par{\i object}\line Required. The MsiCursor object. \par\fi0\li0{\b Remarks}\par\li180 The table row position is determined by the primary key values.  An insert operation takes place if primary keys do not match any row.  A validation operation takes place if primary keys match an existing row.  Since matched rows are never replaced, they may be marked as read-only. \page #{\footnote MsiCursor_Refresh} ${\footnote MsiCursor.Refresh} +{\footnote MsiCursor:Refresh} K{\footnote Refresh} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Refresh Method \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Reloads the cursor with data from the current table row, replacing any changes  made to the cursor data and updating data that has been update via other cursors.  If the row has been deleted, all data will be set to null and the method will return False.  False will also be returned if the cursor is not positioned on a row, i.e. in a Reset state.  Returns True if the row is still present. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Refresh} \par{\i object}\line Required. The MsiCursor object. \page #{\footnote MsiCursor_Delete} ${\footnote MsiCursor.Delete} +{\footnote MsiCursor:Delete} K{\footnote Delete} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Delete Method \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Deletes current cursor row from table. The row to be deleted is determined  by the primary key data, not by the current position in the table. Returns  True if successful, else False if the row could not be deleted. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Delete} \par{\i object}\line Required. The MsiCursor object. \par\fi0\li0{\b Remarks}\par\li180 The delete will fail if the any of the primary key fields in the cursor  are null, or if the primary key does not exist in the table, or if a non-leaf  node is specified in a tree-linked table.  In this cursor and any other MsiCursor objects positioned at the deleted row,  all non-updated data fields will be refreshed with Null values. The logical  positions of such cursors will be maintained such that the Next method will  advance to the next row following the deleted row. An attempt to call Delete  a second time without advancing the cursor will fail and return False. \page #{\footnote MsiCursor_Seek} ${\footnote MsiCursor.Seek} +{\footnote MsiCursor:Seek} K{\footnote Seek} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Seek Method \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Positions the cursor to the table row corresponding the the current primary key values.  If the row is not present, the method will return False.  Returns True if the row is present, and reloads the cursor with data from the table row. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Seek} \par{\i object}\line Required. The MsiCursor object. \page #{\footnote MsiCursor_Validate} ${\footnote MsiCursor.Validate} +{\footnote MsiCursor:Validate} K{\footnote Validate} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Validate Method \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns an MsiRecord object where each field represents a column of the table.  All invalid  fields will contain the iveEnum associated describing the invalid data.  For valid data,  it returns an object of Nothing.  For invalid data, the zeroeth (0th) field of the record  will contain the number of columns that were invalid.  If however the cursor was in a bad  state (set to be deleted or reset if you aren't validating a new row), the zeroeth (0th)  field will be null.   \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Validate({\i Table, Cursor, Column})} \par{\i object}\line Required. The MsiCursor object. \par{\b\i Table}\line Required. The Validation table object. \par{\b\i Cursor}\line Required.  The Validation table cursor object. \par{\b\i Column}\line Required.  -2 = Delete row, -1 = New row, 0 = row, or column number. \par\fi0\li0{\b Remarks}\par\li180 Delete validation ensures that no row is explicitly referencing the row to be deleted.  This means that it ensures that  any column with the foreign key to the table of the row to be deleted (data obtained from the 'KeyTable' column of the  _Validation table) reference the primary key(s) of the row to be deleted.  This validation is however limited and does  not include checking for properties referencing the row to be deleted nor for the delimited list of tables value allowed  in the 'KeyTable' column of the _Validation table.  In this instance, those strings (delimited list ones) are ignored. New row validation should be done prior to insertion.  This will ensure that no duplicate  primary keys exist.  Row validation validates the entire row. Field validation validates  the particular field, but field/column validation does not permit validation of foreign  key fields.  If an invalid field is found, its field in the data record will contain the  iveEnum describing the error.  Valid columns will be null.  The size of the record object  is determined by the number of columns in the table to which the cursor belongs. \par\fi0\lio{\b iveEnum}\par\li180 {\f1 \b iveNoError: 0} {\i Valid data}\line {\f1 \b iveDuplicateKey: 1} {\i Duplicate Primary Key}\line  {\f1 \b iveRequired: 2} {\i Not a nullable column}\line  {\f1 \b iveBadLink: 3} {\i Not a valid foreign key}\line  {\f1 \b iveOverFlow: 4} {\i Value exceeds MaxValue}\line  {\f1 \b iveUnderFlow: 5} {\i Value below MinValue}\line  {\f1 \b iveNotInSet: 6}  {\i Not member of set}\line  {\f1 \b iveBadVersion: 7} {\i Invalid version string}\line  {\f1 \b iveBadCase: 8} {\i Invalid case, must be all upper or all lower case}\line  {\f1 \b iveBadGuid: 9} {\i Invalid GUID}\line  {\f1 \b iveBadWildCard: 10} {\i Invalid wildcard or wildcard usage}\line  {\f1 \b iveBadIdentifier: 11} {\i Invalid identifier}\line  {\f1 \b iveBadLanguage: 12} {\i Invalid LangId}\line  {\f1 \b iveBadFilename: 13} {\i Invalid filename}\line  {\f1 \b iveBadPath: 14} {\i Invalid path}\line  {\f1 \b iveBadCondition: 15} {\i Invalid condition string}\line  {\f1 \b iveBadFormatted: 16} {\i Invalid format string}\line  {\f1 \b iveBadTemplate: 17} {\i Invalid template string}\line  {\f1 \b iveBadDefaultDir: 18} {\i Invalid DefaultDir string (special for Directory table)}\line  {\f1 \b iveBadRegPath: 19} {\i Invalid registry path (Key col in Registry table for example)}\line {\f1 \b iveBadCustomSource: 20} {\i Invalid CustomSource string (special for CustomAction table)}\line  {\f1 \b iveBadProperty: 21} {\i Bad property string}\line  {\f1 \b iveMissingData: 22} {\i Validation table: missing data}\line  {\f1 \b iveMissingTable: 23} {\i NO LONGER USED!!}\line {\f1 \b iveBadCategory: 24} {\i Validation table: invalid category string}\line  {\f1 \b iveBadKeyTable: 25} {\i Validation table: bad key table name [table could not be loaded]}\line  {\f1 \b iveBadMaxMinValues: 26} {\i Validation table:  case where value in Max col is < value in Min col}\line  {\f1 \b iveNonExistingCol: 27} {\i NO LONGER USED!!}\line {\f1 \b iveBadCabinet: 28} {\i Bad cabinet string, special for Media.Cabinet column}\line {\f1 \b iveBadShortcut: 29} {\i Bad shortcut target string, special for Shortcut.Target column}\line {\f1 \b iveStringOverflow: 30} {\i String overflow, length of string greater than size allowed by col def}\line \page #{\footnote MsiCursor_Moniker} ${\footnote MsiCursor.Moniker} +{\footnote MsiCursor:Moniker} K{\footnote Moniker} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Moniker Property \line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the unique identifier for the current row of the cursor. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .GetMoniker()} \par{\i object}\line Required. The MsiCursor object. \par\fi0\li0{\b Remarks}\par\li180 Identifier in form of table.key1(.key2 ...etc).  If cursor is not on a row, will get  the name of the table to which the cursor belongs. \page #{\footnote MsiStorage_Object} ${\footnote MsiStorage Object} K{\footnote MsiStorage} +{\footnote Class:MsiStorage} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MsiStorage Object \par}\li180 The MsiStorage object represents a persistent storage unit, typically a file,  but may also be implemented on memory or a resource, or as child of a parent storage.  The current implementation is a thin layer on top of OLE structured storage. The same  data format is used for Win32 and PPCMAC, with integers stored little-endian. All data  access is via MsiStream objects, with byte-swapping required for the PPCMAC performed  by the MsiStream integer access functions. Special handling is provided to generate and  read the SummaryInformation stream, where standardized document properties are stored. \par\li0{\b Properties}\par\li180 {\uldb Class}{\v MsiStorage_Class}\line {\uldb Name}{\v MsiStorage_Name}\line \par\li0{\b Methods}\par\li180 {\uldb OpenStream}{\v MsiStorage_OpenStream}\line {\uldb OpenStorage}{\v MsiStorage_OpenStorage}\line {\uldb Streams}{\v MsiStorage_Streams}\line {\uldb Storages}{\v MsiStorage_Storages}\line {\uldb RemoveElement}{\v MsiStorage_RemoveElement}\line {\uldb Commit}{\v MsiStorage_Commit}\line {\uldb Rollback}{\v MsiStorage_Rollback}\line {\uldb DeleteOnRelease}{\v MsiStorage_DeleteOnRelease}\line {\uldb CreateSummaryInfo}{\v MsiStorage_CreateSummaryInfo}\line {\uldb CopyTo}{\v MsiStorage_CopyTo}\line \page #{\footnote MsiStorage_Class} ${\footnote MsiStorage.Class} +{\footnote MsiStorage:Class} K{\footnote Class} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Class Property \line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Read/write. The class ID (CLSID) associated with this storage,  represented as the string form of a GUID.  Return an empty value if the storage has no class ID.  Generates an error if attempting to set an invalid GUID string.  This is a thin wrapper on the OLE methods: IStorage::SetClass and IStorage::Stat.  Microsoft Installer uses this for identification of the storage usage. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Class} \par{\i object}\line Required. The MsiStorage object. \page #{\footnote MsiStorage_Name} ${\footnote MsiStorage.Name} +{\footnote MsiStorage:Name} K{\footnote Name} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Name Property \line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Read-only. The name of the storage. This is a thin wrapper on the OLE method: IStorage::Stat. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Name} \par{\i object}\line Required. The MsiStorage object. \page #{\footnote MsiStorage_OpenStream} ${\footnote MsiStorage.OpenStream} +{\footnote MsiStorage:OpenStream} K{\footnote OpenStream} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b OpenStream Method \line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Creates and returns an {\uldb MsiStream}{\v MsiStream_Object} object that allows data to be read or written to the storage. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .OpenStream({\i name, fWrite})} \par{\i object}\line Required. The MsiStorage object. \par{\b\i name}\line Required. The name of the stream as it is known in the storage. If fWrite is set  to True, the stream will be created if it does not already exist. \par{\b\i fWrite}\line Required. True to create a writable stream, which will overwrite any existing stream.  False to read a read-only stream. \par\fi0\li0{\b Remarks}\par\li180 The stream object must be released in order to flush all changes to the storage. \page #{\footnote MsiStorage_OpenStorage} ${\footnote MsiStorage.OpenStorage} +{\footnote MsiStorage:OpenStorage} K{\footnote OpenStorage} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b OpenStorage Method \line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Creates and returns an MsiStorage object represents a child storage under this storage. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .OpenStorage({\i name, openMode})} \par{\i object}\line Required. The MsiStorage object. \par{\b\i name}\line Required. The name of the storage as it is known in the storage, or a unique name if it is to be created.  to True, the stream will be created if it does not already exist. \par{\b\i openMode}\line Required. Mode in which to create or open, see {\uldb CreateStorage}{\v MsiServices_CreateStorage}. \par\fi0\li0{\b Remarks}\par\li180 The child storage object must be released and/or committed in order to flush all changes to the parent storage. \page #{\footnote MsiStorage_Streams} ${\footnote MsiStorage.Streams} +{\footnote MsiStorage:Streams} K{\footnote Streams} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Streams Method \line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns a collection of strings containing the names of all streams in this storage object. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Streams} \par{\i object}\line Required. The MsiStorage object. \page #{\footnote MsiStorage_Storages} ${\footnote MsiStorage.Storages} +{\footnote MsiStorage:Storages} K{\footnote Storages} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Storages Method \line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns a collection of strings containing the names of all child storages in this storage object. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Storages} \par{\i object}\line Required. The MsiStorage object. \page #{\footnote MsiStorage_RemoveElement} ${\footnote MsiStorage.RemoveElement} +{\footnote MsiStorage:RemoveElement} K{\footnote RemoveElement} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b RemoveElement Method \line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Removes a stream or child storage matching the supplied name.  This method will fail if the name is not found or if the storage is opened read-only. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .RemoveElement {\i name, fStorage}} \par{\i object}\line Required. The MsiStorage object. \par{\b\i name}\line Required. The name of the stream or child storage. \par{\b\i fStorage}\line Optional. True if a storage, False if a stream. Defaults to False. \page #{\footnote MsiStorage_RenameElement} ${\footnote MsiStorage.RenameElement} +{\footnote MsiStorage:RenameElement} K{\footnote RenameElement} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b RenameElement Method \line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Renames a stream or child storage from the supplied old name to a new name.  This method will fail if the old name is not found or if the storage is opened read-only. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .RenameElement {\i oldName, newName, fStorage}} \par{\i object}\line Required. The MsiStorage object. \par{\b\i oldName}\line Required. The original name of the stream or child storage. \par{\b\i newName}\line Required. The new name of the stream or child storage. \par{\b\i fStorage}\line Optional. True if a storage, False if a stream. Defaults to False. \page #{\footnote MsiStorage_Commit} ${\footnote MsiStorage.Commit} +{\footnote MsiStorage:Commit} K{\footnote Commit} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Commit Method \line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Forces all persistent data to be written to the persistent storage.  No action is taken if the storage is opened read-only (ismReadOnly). \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Commit} \par{\i object}\line Required. The MsiStorage object. \page #{\footnote MsiStorage_Rollback} ${\footnote MsiStorage.Rollback} +{\footnote MsiStorage:Rollback} K{\footnote Rollback} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Rollback Method \line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Backs out any changes made to the storage since the MsiStorage object was created or last committed..  This method only succeeds if the MsiStorage object was created in transacted mode using ismTransact;  otherwise an error will be generated. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Rollback} \par{\i object}\line Required. The MsiStorage object. \page #{\footnote MsiStorage_DeleteOnRelease} ${\footnote MsiStorage.DeleteOnRelease} +{\footnote MsiStorage:DeleteOnRelease} K{\footnote DeleteOnRelease} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b DeleteOnRelease Method \line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Forces the storage to be physically removed after all the references to the MsiStorage  object are released. Fails if the storage is opened read-only, or if the storage  was created from an existing IStorage interface (rather than from Msi services). \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .DeleteOnRelease} \par{\i object}\line Required. The MsiStorage object. \page #{\footnote MsiStorage_CreateSummaryInfo} ${\footnote MsiStorage.CreateSummaryInfo} +{\footnote MsiStorage:CreateSummaryInfo} K{\footnote CreateSummaryInfo} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b CreateSummaryInfo Method \line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns a MsiCreateSummaryInfo object that can be used examine, update,  and add properties to the SummaryInformation stream. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .CreateSummaryInfo({\i maxProperties})} \par{\i object}\line Required. The MsiStorage object. \par{\b\i maxProperties}\line Required. The maximum number of properties to be added or modified, used solely to allocate  sufficent working memory during the stream generation. It is not required to actually  store this number of properties. A value of zero prevents the stream from being updated. \par\fi0\li0{\b Remarks}\par\li180 If the MsiStorage object is opened read-only, no properties may be added or updated. \page #{\footnote MsiStorage_CopyTo} ${\footnote MsiStorage.CopyTo} +{\footnote MsiStorage:CopyTo} K{\footnote CopyTo} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b CopyTo Method \line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Copies the contents of the storage to another storage, optionally excluding  some streams or substorages from the copy. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .CopyTo({\i destStorage}, {\i excludedElements})} \par{\i object}\line Required. The MsiStorage object to which the contents of the current object should be copied. \par{\b\i destStorage}\line Required. The destination storage for the copy.  \par{\b\i excludedElements}\line Optional. A recording containing the names of elements (streams or storages) that  should not be copied. \par\fi0\li0{\b Remarks}\par\li180 \page #{\footnote MsiStream_Object} ${\footnote MsiStream Object} K{\footnote MsiStream} +{\footnote Class:MsiStream} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MsiStream Object \par}\li180 The MsiStream object is used to transfer table data and large binary objects (BLOB)  to and from the persistent database. The use of streams to manage loading and saving  of table data is wholely managed by the database. However large binary data items are  not loaded into memory when their table is loaded, but only on demand when the  {\uldb StreamData property}{\v MsiCursor_StreamData} is requested for the data item,  which returns a read-only MsiStream object which is used to access the data sequentially. When transferring data to and from stream that may be shared between Windows and PPCMAC,  use the integer tranfer routines which automatically take care of the byte-swapping issues. \par\li0{\b Properties}\par\li180 {\uldb Length}{\v MsiStream_Length}\line {\uldb Remaining}{\v MsiStream_Remaining}\line {\uldb Error}{\v MsiStream_Error}\line \par\li0{\b Methods}\par\li180 {\uldb GetData}{\v MsiStream_GetData}\line {\uldb PutData}{\v MsiStream_PutData}\line {\uldb GetInt16}{\v MsiStream_GetInt16}\line {\uldb GetInt32}{\v MsiStream_GetInt32}\line {\uldb PutInt16}{\v MsiStream_PutInt16}\line {\uldb PutInt32}{\v MsiStream_PutInt32}\line {\uldb Seek}{\v MsiStream_Seek}\line {\uldb Reset}{\v MsiStream_Reset}\line {\uldb Clone}{\v MsiStream_Clone}\line \page #{\footnote MsiStream_Length} ${\footnote MsiStream.Length} +{\footnote MsiStream:Length} K{\footnote Length} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Length Property \line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the current length of the stream in bytes. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Length} \par{\i object}\line Required. The MsiStream object. \page #{\footnote MsiStream_Remaining} ${\footnote MsiStream.Remaining} +{\footnote MsiStream:Remaining} K{\footnote Remaining} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Remaining Property \line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the remaining length of the stream in bytes.  When writing to the stream, this value will be zero. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Remaining} \par{\i object}\line Required. The MsiStream object. \page #{\footnote MsiStream_Error} ${\footnote MsiStream.Error} +{\footnote MsiStream:Error} K{\footnote Error} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Error Property \line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns a boolean indicating when any transfer error occurred when reading or  writing to the stream. The error state is then cleared in the stream. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Error} \par{\i object}\line Required. The MsiStream object. \page #{\footnote MsiStream_GetData} ${\footnote MsiStream.GetData} +{\footnote MsiStream:GetData} K{\footnote GetData} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b GetData Method \line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Copies the indicated number of bytes from the stream into a buffer. For automation,  the bytes are returned as a string, with the length equal to the byte count copied.  If the end of the stream is reached before the requested number of bytes, the stream  error state is set and a smaller string is returned. On DBCS-enabled systems, byte values  corresponding to lead byte characters may be lost due to the intermediate Unicode translation. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .GetData({\i count})} \par{\i object}\line Required. The MsiStream object. \par{\b\i count}\line Required. The number of bytes to copy from the stream \page #{\footnote MsiStream_PutData} ${\footnote MsiStream.PutData} +{\footnote MsiStream:PutData} K{\footnote PutData} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b PutData Method \line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Copies the indicated number of bytes from the supplied buffer to the stream.  For automation, a string is passed in containing the bytes. The size of the string  is used for the count of bytes to write to the stream. The string may contain any  binary byte values, including null. On DBCS-enabled systems, byte values corresponding  to lead byte characters may be lost due to the intermediate Unicode translation. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .PutData({\i buffer})} \par{\i object}\line Required. The MsiStream object. \par{\b\i buffer}\line Required. String containing the bytes to copy. The string length is used for the count. \page #{\footnote MsiStream_GetInt16} ${\footnote MsiStream.GetInt16} +{\footnote MsiStream:GetInt16} K{\footnote GetInt16} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b GetInt16 Method \line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the next two bytes from the stream as a 16-bit integer,  the first byte becoming the low-order byte of the integer. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .GetInt16} \par{\i object}\line Required. The MsiStream object. \page #{\footnote MsiStream_GetInt32} ${\footnote MsiStream.GetInt32} +{\footnote MsiStream:GetInt32} K{\footnote GetInt32} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b GetInt32 Method \line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns the next four bytes from the stream as a 32-bit integer,  the first byte becoming the low-order byte of the integer. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .GetInt32} \par{\i object}\line Required. The MsiStream object. \page #{\footnote MsiStream_PutInt16} ${\footnote MsiStream.PutInt16} +{\footnote MsiStream:PutInt16} K{\footnote PutInt16} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b PutInt16 Method \line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Writes a 16-bit integer to the stream, low-order byte first. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .PutInt16({\i value})} \par{\i object}\line Required. The MsiStream object. \par{\b\i value}\line Required. The short integer to be written to the stream. \page #{\footnote MsiStream_Seek} ${\footnote MsiStream.Seek} +{\footnote MsiStream:Seek} K{\footnote Seek} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Seek Method \line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Moves the stream pointer to a new position in the stream. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Seek({\i position})} \par{\i object}\line Required. The MsiStream object. \par{\b\i position}\line Required. The new position in the stream, relative to the beginning of the stream. \page #{\footnote MsiStream_PutInt32} ${\footnote MsiStream.PutInt32} +{\footnote MsiStream:PutInt32} K{\footnote PutInt32} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b PutInt32 Method \line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Writes a 32-bit integer to the stream, low-order byte first. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .PutInt32({\i value})} \par{\i object}\line Required. The MsiStream object. \par{\b\i value}\line Required. The long integer to be written to the stream. \page #{\footnote MsiStream_Reset} ${\footnote MsiStream.Reset} +{\footnote MsiStream:Reset} K{\footnote Reset} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Reset Method \line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Resets the stream to the beginning, allow it to be read or written again. Using this  method before writing simply replaces previous data, but does not remove old data  beyond what is newly written. To completely replace a stream, simply reopen the stream. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Reset} \par{\i object}\line Required. The MsiStream object. \page #{\footnote MsiStream_Clone} ${\footnote MsiStream.Clone} +{\footnote MsiStream:Clone} K{\footnote Clone} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Clone Method \line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Creates and returns an {\uldb MsiStream}{\v MsiStream_Object} object that accesses the  same data as the current object, but which has an independent seek pointer.  The new stream object will be in the reset state, i.e. seek pointer at the beginning.  Any clones used for writing must be kept positioned further than streams that are  current reading to avoid errors. More than one close currently writing (not recommended)  produces system-defined behavior; for file streams all writes will be appended to the end  of the stream. For storage streams, the behavior is dependent upon the OLE implementation. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Clone} \par{\i object}\line Required. The MsiStream object. \page #{\footnote MsiSummaryInfo_Object} ${\footnote MsiSummaryInfo Object} K{\footnote MsiSummaryInfo} +{\footnote Class:MsiSummaryInfo} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MsiSummaryInfo Object \par}\li180 The MsiSummaryInfo object is used to read, create, and update  document properties from the SummaryInformation stream of the storage object. \par\li0{\b Properties}\par\li180 {\uldb Property}{\v MsiSummaryInfo_Property}\line {\uldb PropertyCount}{\v MsiSummaryInfo_PropertyCount}\line {\uldb PropertyType}{\v MsiSummaryInfo_PropertyType}\line \par\li0{\b Methods}\par\li180 {\uldb WritePropertyStream}{\v MsiSummaryInfo_WritePropertyStream}\line \page #{\footnote MsiSummaryInfo_PropertyCount} ${\footnote MsiSummaryInfo.PropertyCount} +{\footnote MsiSummaryInfo:PropertyCount} K{\footnote GetPropertyCount} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b PropertyCount Property \line\tx360\tab\fs18\b0{\uldb MsiSummaryInfo Object}{\v MsiSummaryInfo_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 The current number of property values in the summary information object.  This takes into account properties that have been added, deleted, or replaced. Read-only. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .PropertyCount} \par{\i object}\line Required. The MsiSummaryInfo object. \page #{\footnote MsiSummaryInfo_PropertyType} ${\footnote MsiSummaryInfo.PropertyType} +{\footnote MsiSummaryInfo:PropertyType} K{\footnote GetPropertyType} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b PropertyType Property \line\tx360\tab\fs18\b0{\uldb MsiSummaryInfo Object}{\v MsiSummaryInfo_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Returns an integer containing the property type for the supplied property ID.  If the property does not exist, the value 0 (VT_EMPTY) is returned.  Standard property types are listed in {\uldb MsiSummaryInfo.Property}{\v MsiSummaryInfo_Property}.  Read-only. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .PropertyType({\i pid})} \par{\i object}\line Required. The MsiSummaryInfo object. \par{\b\i pid}\line Required. The property ID of one of the summary properties. \page #{\footnote MsiSummaryInfo_Property} ${\footnote MsiSummaryInfo.Property} +{\footnote MsiSummaryInfo:Property} K{\footnote Property} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Property Property \line\tx360\tab\fs18\b0{\uldb MsiSummaryInfo Object}{\v MsiSummaryInfo_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Sets or gets the value for the specified property in the summary information stream.  The properties are read when the MsiSummaryInfo object is created, but they are not  written until {\uldb WritePropertyStream}{\v MsiSummaryInfo_WritePropertyStream} is called.     Setting a property to Empty will cause its removal; likewise requesting a non-existent  property will return an Empty value. Otherwise values may be transferred as strings,  integers, or date (datetime) types. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .Property({\i pid})} \par{\i object}\line Required. The MsiSummaryInfo object. \par{\b\i pid}\line Required. The property ID of one of the summary properties. \par\fi0\li0{\b Standard Summary Property IDs} (not an enumeration) \line{\f1  PID_DICTIONARY    0 } special format, not support by MsiSummaryInfo \line{\f1  PID_CODEPAGE      1 } VT_I2 \line{\f1  PID_TITLE         2 } VT_LPSTR \line{\f1  PID_SUBJECT       3 } VT_LPSTR \line{\f1  PID_AUTHOR        4 } VT_LPSTR \line{\f1  PID_KEYWORDS      5 } VT_LPSTR \line{\f1  PID_COMMENTS      6 } VT_LPSTR \line{\f1  PID_TEMPLATE      7 } VT_LPSTR \line{\f1  PID_LASTAUTHOR    8 } VT_LPSTR \line{\f1  PID_REVNUMBER     9 } VT_LPSTR \line{\f1  PID_EDITTIME     10 } VT_FILETIME \line{\f1  PID_LASTPRINTED  11 } VT_FILETIME \line{\f1  PID_CREATE_DTM   12 } VT_FILETIME \line{\f1  PID_LASTSAVE_DTM 13 } VT_FILETIME \line{\f1  PID_PAGECOUNT    14 } VT_I4 \line{\f1  PID_WORDCOUNT    15 } VT_I4 \line{\f1  PID_CHARCOUNT    16 } VT_I4 \line{\f1  PID_THUMBNAIL    17 } VT_CF  (not supported) \line{\f1  PID_APPNAME      18 } VT_LPSTR \line{\f1  PID_SECURITY     19 } VT_I4 \par\fi0\li0{\b MSI-specific Summary Property IDs} \line{\f1  PID_MSITAG       30 } VT_LPSTR  MSI FileType \line{\f1  PID_MSIPID       31 } VT_LPSTR  MSI Product ID \line{\f1  PID_MSIUSER      32 } VT_LPSTR  MSI Registered User \line{\f1  PID_MSIORG       33 } VT_LPSTR  MSI Organization \line{\f1  PID_MSICHECK     34 } VT_LPSTR  MSI Checksum \par\fi0\li0{\b Property Data Types} (not an enumeration) \line{\f1  VT_I2        2 } 16-bit integer \line{\f1  VT_I4        3 } 32-bit integer \line{\f1  VT_LPSTR    30 } string \line{\f1  VT_FILETIME 64 } date/time (FILETIME, converted to Variant time) \line{\f1  VT_CF       71 } clipboard format + data, not handled by MsiSummaryInfo \page #{\footnote MsiSummaryInfo_WritePropertyStream} ${\footnote MsiSummaryInfo.WritePropertyStream} +{\footnote MsiSummaryInfo:WritePropertyStream} K{\footnote WritePropertyStream} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b WritePropertyStream Method \line\tx360\tab\fs18\b0{\uldb MsiSummaryInfo Object}{\v MsiSummaryInfo_Object} \tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Formats and writes the previously stored properties into the standard SummaryInformation stream.  Generates an error if the stream could not be successfully written. This method may only  be called once, after all the property values have been set. Properties may still be read  after the stream is written. \par\li0{\b Syntax}\par\li500\fi-320 {\i object}{\b .WritePropertyStream} \par{\i object}\line Required. The MsiSummaryInfo object. \page
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\help\handler.rtf ===
{\rtf1\ansi {\fonttbl{\f0\fswiss Helv;}{\f1\fmodern Courier New;}} {\colortbl;} \fs20 #{\footnote Dialog_Overview} ${\footnote Dialog Overview} K{\footnote Dialog} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Dialog Overview \line\fs18\b0\tx2400\tab{\uldb Msi Objects}{\v Msi_Objects} \tx4500\tx6600\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par} The following dialog types are defined by the Microsoft Installer.\line \par\li0{\b Dialog Types}\par\li180 {\uldb Browse}{\v DialogType_Browse}\line {\uldb Standard}{\v DialogType_Standard}\line \line Some special purpose dialogs require some communication among the controls of the dialog or some other special handling. The following list contains some of the more common cases. These pages may be used to author these dialogs as well as hints how to compose some more complicated dialogs. \par\li0{\b Special Dialogs}\par\li180 {\uldb Browse Dialog}{\v SpecialDialog_Browse}\line {\uldb Cancel Dialog}{\v SpecialDialog_Cancel}\line {\uldb DiskCost Dialog}{\v SpecialDialog_DiskCost}\line {\uldb Error Dialog}{\v SpecialDialog_Error}\line {\uldb Exit Dialog}{\v SpecialDialog_Exit}\line {\uldb FatalError Dialog}{\v SpecialDialog_FatalError}\line {\uldb FilesInUse Dialog}{\v SpecialDialog_FilesInUse}\line {\uldb LicenseAgreement Dialog}{\v SpecialDialog_LicenseAgreement}\line {\uldb Selection Dialog}{\v SpecialDialog_Selection}\line {\uldb UserExit Dialog}{\v SpecialDialog_UserExit}\line \line Different attributes of a dialog can be read or set using the {\uldb Attribute}{\v MsiDialog_Attribute} method. \par\li0{\b Dialog Attributes}\par\li180 {\uldb AddingControls}{\v DialogAttribute_AddingControls}\line {\uldb Argument}{\v DialogAttribute_Argument}\line {\uldb ClientRect}{\v DialogAttribute_ClientRect}\line {\uldb ControlsCount}{\v DialogAttribute_ControlsCount}\line {\uldb ControlsKeyInt}{\v DialogAttribute_ControlsKeyInt}\line {\uldb ControlsKeyString}{\v DialogAttribute_ControlsKeyString}\line {\uldb ControlsNext}{\v DialogAttribute_ControlsNext}\line {\uldb ControlsPrev}{\v DialogAttribute_ControlsPrev}\line {\uldb ControlsProperty}{\v DialogAttribute_ControlsProperty}\line {\uldb CurrentControl}{\v DialogAttribute_CurrentControl}\line {\uldb DefaultButton}{\v DialogAttribute_DefaultButton}\line {\uldb Error}{\v DialogAttribute_Error}\line {\uldb EventInt}{\v DialogAttribute_EventInt}\line {\uldb EventString}{\v DialogAttribute_EventString}\line {\uldb FullSize}{\v DialogAttribute_FullSize}\line {\uldb HasControls}{\v DialogAttribute_HasControls}\line {\uldb Height}{\v DialogAttribute_Height}\line {\uldb InPlace}{\v DialogAttribute_InPlace}\line {\uldb KeepModeless}{\v DialogAttribute_KeepModeless}\line {\uldb KeyInt}{\v DialogAttribute_KeyInt}\line {\uldb KeyString}{\v DialogAttribute_KeyString}\line {\uldb Locked}{\v DialogAttribute_Locked}\line {\uldb Modal}{\v DialogAttribute_Modal}\line {\uldb Palette}{\v DialogAttribute_Palette}\line {\uldb Position}{\v DialogAttribute_Position}\line {\uldb Preview}{\v DialogAttribute_Preview}\line {\uldb RefCount}{\v DialogAttribute_RefCount}\line {\uldb Running}{\v DialogAttribute_Running}\line {\uldb Showing}{\v DialogAttribute_Showing}\line {\uldb Text}{\v DialogAttribute_Text}\line {\uldb ToolTip}{\v DialogAttribute_ToolTip}\line {\uldb UseCustomPalette}{\v DialogAttribute_UseCustomPalette}\line {\uldb Width}{\v DialogAttribute_Width}\line {\uldb WindowHandle}{\v DialogAttribute_WindowHandle}\line {\uldb X}{\v DialogAttribute_X}\line {\uldb Y}{\v DialogAttribute_Y}\line \line At the time of the creation of a dialog several attributes can be selected by setting certain Style bits. \par\li0{\b Dialog Style Bits}\par\li180 {\uldb Browse}{\v DialogStyle_Browse} = 131072 (0x0002000)\line {\uldb Error}{\v DialogStyle_Error} = 65536 (0x00010000)\line {\uldb KeepModeless}{\v DialogStyle_KeepModeless} = 16 (0x00000010)\line {\uldb Minimize}{\v DialogStyle_Minimize} = 4 (0x00000004)\line {\uldb Modal}{\v DialogStyle_Modal} = 2 (0x00000002)\line {\uldb TrackDiskSpace}{\v DialogStyle_TrackDiskSpace} = 32 (0x00000020)\line {\uldb UseCustomPalette}{\v DialogStyle_UseCustomPalette} = 64 (0x000040)\line {\uldb Visible}{\v DialogStyle_Visible} = 1 (0x00000001)\line \page #{\footnote Control_Overview} ${\footnote Control Overview} K{\footnote Control; Active Control; Inert Control} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Control Overview \line\fs18\b0\tx2400\tab{\uldb Msi Objects}{\v Msi_Objects} \tx4500\tx6600\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par} The following control types are defined by the Microsoft Installer.  The controls are divided into two major groups. The {\b Active Controls} are linked to some property. These controls are authored with some property. When the control is created it shows the initial value of the property. The user can change the value of the property by interacting with the control.  The {\b Inert Controls} are not linked to a property, they change no property value. \par\li0{\b Inert Controls}\par\li180 {\uldb Billboard}{\v ControlType_Billboard}\line {\uldb Bitmap}{\v ControlType_Bitmap}\line {\uldb GroupBox}{\v ControlType_GroupBox}\line {\uldb Icon}{\v ControlType_Icon}\line {\uldb ProgressBar}{\v ControlType_ProgressBar}\line {\uldb PushButton}{\v ControlType_PushButton}\line {\uldb ScrollableText}{\v ControlType_ScrollableText}\line {\uldb Text}{\v ControlType_Text}\line {\uldb VolumeCostList}{\v ControlType_VolumeCostList}\line \par\li0{\b Active Controls}\par\li180 {\uldb CheckBox}{\v ControlType_CheckBox}\line {\uldb ComboBox}{\v ControlType_ComboBox}\line {\uldb DirectoryCombo}{\v ControlType_DirectoryCombo}\line {\uldb DirectoryList}{\v ControlType_DirectoryList}\line {\uldb Edit}{\v ControlType_Edit}\line {\uldb ListBox}{\v ControlType_ListBox}\line {\uldb ListView}{\v ControlType_ListView}\line {\uldb MaskedEdit}{\v ControlType_MaskedEdit}\line {\uldb PathEdit}{\v ControlType_PathEdit}\line {\uldb RadioButtonGroup}{\v ControlType_RadioButtonGroup}\line {\uldb SelectionTree}{\v ControlType_SelectionTree}\line {\uldb VolumeSelectCombo}{\v ControlType_VolumeSelectCombo}\line \line Different attributes of a control can be read or set using the {\uldb Attribute}{\v MsiControl_Attribute} method. \par\li0{\b Control Attributes}\par\li180 {\uldb BillboardName}{\v ControlAttribute_Billboardname}\line {\uldb Bitmap}{\v ControlAttribute_Bitmap}\line {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Enabled}{\v ControlAttribute_Enabled}\line {\uldb HasBorder}{\v ControlAttribute_HasBorder}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Icon}{\v ControlAttribute_Icon}\line {\uldb Image}{\v ControlAttribute_Image}\line {\uldb ImageHandle}{\v ControlAttribute_ImageHandle}\line {\uldb Indirect}{\v ControlAttribute_Indirect}\line {\uldb IndirectPropertyName}{\v ControlAttribute_IndirectPropertyName}\line {\uldb Integer}{\v ControlAttribute_Integer}\line {\uldb ItemsCount}{\v ControlAttribute_ItemsCount}\line {\uldb ItemsHandle}{\v ControlAttribute_ItemsHandle}\line {\uldb ItemsHeight}{\v ControlAttribute_ItemsHeight}\line {\uldb ItemsText}{\v ControlAttribute_ItemsText}\line {\uldb ItemsValue}{\v ControlAttribute_ItemsValue}\line {\uldb ItemsWidth}{\v ControlAttribute_ItemsWidth}\line {\uldb ItemsX}{\v ControlAttribute_ItemsX}\line {\uldb ItemsY}{\v ControlAttribute_ItemsY}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb Limit}{\v ControlAttribute_Limit}\line {\uldb OriginalValue}{\v ControlAttribute_OriginalValue}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb Progress}{\v ControlAttribute_Progress}\line {\uldb PropertyName}{\v ControlAttribute_PropertyName}\line {\uldb PropertyValue}{\v ControlAttribute_PropertyValue}\line {\uldb PushLike}{\v ControlAttribute_PushLike}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Transparent}{\v ControlAttribute_Transparent}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \line At the time of the creation of a control several attributes can be selected by setting certain Style bits. \par\li0{\b Control Style Bits}\par\li180 {\uldb Bitmap}{\v ControlStyle_Bitmap} = 262144 (0x00040000)\line {\uldb CDROMVolume}{\v ControlStyle_CDROMVolume} = 524288 (0x00080000)\line {\uldb ComboList}{\v ControlStyle_ComboList} = 131072 (0x00020000)\line {\uldb Enabled}{\v ControlStyle_Enabled} = 2 (0x00000002)\line {\uldb FixedSize}{\v ControlStyle_FixedSize} = 1048576 (0x00100000)\line {\uldb FixedVolume}{\v ControlStyle_FixedVolume} = 131072 (0x00020000)\line {\uldb FloppyVolume}{\v ControlStyle_FloppyVolume} = 2097152 (0x00200000)\line {\uldb HasBorder}{\v ControlStyle_HasBorder} = 16777216 (0x01000000)\line {\uldb Icon}{\v ControlStyle_Icon} = 524288 (0x00080000)\line {\uldb IconSize}{\v ControlStyle_IconSize} 2097152 (0x00200000),  4194304 (0x00400000)\line {\uldb ImageHandle}{\v ControlStyle_ImageHandle} = 65536 (0x00010000)\line {\uldb Indirect}{\v ControlStyle_Indirect} = 8 (0x00000008)\line {\uldb Integer}{\v ControlStyle_Integer} = 16 (0x00000010)\line {\uldb Progress95}{\v ControlStyle_Progress95} = 65536 (0x00010000)\line {\uldb PushLike}{\v ControlStyle_PushLike} = 131072 (0x00020000)\line {\uldb RAMDiskVolume}{\v ControlStyle_RAMDiskVolume} = 1048576 (0x00100000)\line {\uldb RemoteVolume}{\v ControlStyle_RemoteVolume} = 262144 (0x00040000)\line {\uldb RemovableVolume}{\v ControlStyle_RemovableVolume} = 65536 (0x00010000)\line {\uldb Sorted}{\v ControlStyle_Sorted} = 65536 (0x00010000)\line {\uldb SplitPath}{\v ControlStyle_SplitPath} =  33554432 (0x02000000)\line {\uldb Sunken}{\v ControlStyle_Sunken} = 4 (0x00000004)\line {\uldb Transparent}{\v ControlStyle_Transparent} = 65536 (0x00010000)\line {\uldb Visible}{\v ControlStyle_Visible} = 1 (0x00000001)\line \page #{\footnote ControlEvent_Overview} ${\footnote ControlEvent Overview} K{\footnote ControlEvent} +{\footnote ControlEvent:Overview} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ControlEvent Overview \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 Controls on the same dialog can communicate with each other by means of ControlEvents.\line Each ControlEvent has one publisher (a control or the Handler) and can have several subscribers. The kind of ControlEvents published by a control are determined by the type of the control. On the other hand theoreticaly any control can subscribe to any ControlEvent, although many combinations are not practical. \line A control can subscribe to a ControlEvent two ways.\line If a control is listed in the {\uldb EventMapping table}{\v _msi_EventMapping_Table@msi.hlp} with a ControlEvent, it describes that when the ControlEvent is published, which {\uldb attribute}{\v Control_Overview} of the control has to be changed.\line If a control is listed in the {\uldb ControlEvent table}{\v _msi_ControlEvent_Table@msi.hlp} with a ControlEvent, it means that activating the control (pushing the button) will trigger a ControlEvent with the described argument.\line A custom control can publish its own ControlEvents and other controls (custom or regular) can subscribe to them.\line  The publisher of a ControlEvent can hide/show or enable/disable its subscribers when its state requires it.\line It is perfectly reasonable to have a control on a dialog that publishes some ControlEvent but have no subscribers to it. On the other hand if a control subscribes to a ControlEvent that is not published by the Handler and no publishing control is present on the same dialog, it may result in an error (especially if the control tries to trigger that event). \par\li0{\b The Following ControlEvents Are Currently Supported}\par\li180 {\uldb ActionData}{\v ControlEvent_ActionData}\line {\uldb ActionProgress}{\v ControlEvent_ActionProgress}\line {\uldb ActionText}{\v ControlEvent_ActionText}\line {\uldb AddLocal}{\v ControlEvent_AddLocal}\line {\uldb AddSource}{\v ControlEvent_AddSource}\line {\uldb CheckExistingPath}{\v ControlEvent_CheckExistingPath}\line {\uldb CheckExistingTargetPath}{\v ControlEvent_CheckExistingTargetPath}\line {\uldb CheckPath}{\v ControlEvent_CheckPath}\line {\uldb CheckTargetPath}{\v ControlEvent_CheckTargetPath}\line {\uldb DirectoryComboPath}{\v ControlEvent_DirectoryComboPath}\line {\uldb DirectoryListNew}{\v ControlEvent_DirectoryListNew}\line {\uldb DirectoryListPath}{\v ControlEvent_DirectoryListPath}\line {\uldb DirectoryListUp}{\v ControlEvent_DirectoryListUp}\line {\uldb EndDialog}{\v ControlEvent_EndDialog}\line {\uldb NewDialog}{\v ControlEvent_NewDialog}\line {\uldb Reinstall}{\v ControlEvent_Reinstall}\line {\uldb ReinstallMode}{\v ControlEvent_ReinstallMode}\line {\uldb Remove}{\v ControlEvent_Remove}\line {\uldb Reset}{\v ControlEvent_Reset}\line {\uldb SelectionAction}{\v ControlEvent_SelectionAction}\line {\uldb SelectionBrowse}{\v ControlEvent_SelectionBrowse}\line {\uldb SelectionDescription}{\v ControlEvent_SelectionDescription}\line {\uldb SelectionIcon}{\v ControlEvent_SelectionIcon}\line {\uldb SelectionPath}{\v ControlEvent_SelectionPath}\line {\uldb SelectionPathOn}{\v ControlEvent_SelectionPathOn}\line {\uldb SelectionSize}{\v ControlEvent_SelectionSize}\line {\uldb SetInstallLevel}{\v ControlEvent_SetInstallLevel}\line {\uldb SetPath}{\v ControlEvent_SetPath}\line {\uldb SetTargetPath}{\v ControlEvent_SetTargetPath}\line {\uldb SetProperty}{\v ControlEvent_SetProperty}\line {\uldb SpawnDialog}{\v ControlEvent_SpawnDialog}\line {\uldb ValidateProductID}{\v ControlEvent_ValidateProductID}\line \page #{\footnote ControlType_Billboard} ${\footnote ControlType Billboard} K{\footnote Billboard} +{\footnote ControlType:Billboard} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Billboard Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This control plays the billboards based on progress messages. The billboards are composed of individual controls that are added and later removed from the dialog. \par\li0{\b Property}\par\li180 There can be no property associated with this control. \par\li0{\b Valid Style Bits}\par\li180 None. \par\li0{\b Valid Control Attributes}\par\li180 {\uldb BillboardName}{\v ControlAttribute_BillboardName}\line {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 \par\li0{\b Can Take Focus}\par\li180 \line \par\li0{\b Windows Implementation}\par\li180 This control has no window of its own. \page #{\footnote ControlType_CheckBox} ${\footnote ControlType CheckBox} K{\footnote CheckBox} +{\footnote ControlType:CheckBox} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b CheckBox Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This control is a simple two state check box. If the {\uldb CheckBox table}{\v _msi_CheckBox_Table@msi.hlp}  exists and specifies a value for the property associated with the checkbox, the property is set to this value when the checkbox is on, to null otherwise. If there is no such table, or it does not specify a value for this property, but the associated property has an initial value, the control remembers it and initaly drawn as selected.  When the control is unchecked, the property is set to NULL. If the check box is rechecked, it returns to its original value. If the property does not have an  original value, it is set to "1" when the control is checked. \par\li0{\b Property}\par\li180 The property associated with this control can be integer or string valued. \par\li0{\b Valid Style Bits}\par\li180 {\uldb Bitmap}{\v ControlStyle_Bitmap}\line {\uldb Enabled}{\v ControlStyle_Enabled}\line {\uldb FixedSize}{\v ControlStyle_FixedSize}\line {\uldb Icon}{\v ControlStyle_Icon}\line {\uldb IconSize}{\v ControlStyle_IconSize}\line {\uldb ImageHandle}{\v ControlStyle_ImageHandle}\line {\uldb Indirect}{\v ControlStyle_Indirect}\line {\uldb Integer}{\v ControlStyle_Integer}\line {\uldb PushLike}{\v ControlStyle_PushLike}\line {\uldb Sunken}{\v ControlStyle_Sunken}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb Bitmap}{\v ControlAttribute_Bitmap}\line {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Enabled}{\v ControlAttribute_Enabled}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Icon}{\v ControlAttribute_Icon}\line {\uldb Indirect}{\v ControlAttribute_Indirect}\line {\uldb IndirectPropertyName}{\v ControlAttribute_IndirectPropertyName}\line {\uldb Integer}{\v ControlAttribute_Integer}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb OriginalValue}{\v ControlAttribute_OriginalValue}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb PropertyName}{\v ControlAttribute_PropertyName}\line {\uldb PropertyValue}{\v ControlAttribute_PropertyValue}\line {\uldb PushLike}{\v ControlAttribute_PushLike}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 \par\li0{\b Can Take Focus}\par\li180 Yes\line \par\li0{\b Windows Implementation}\par\li180 The control is created with the "BUTTON" class.\line It has the BS_CHECKBOX, WS_TABSTOP, WS_GROUP, WS_CHILD and BS_MULTILINE styles.\line If the {\uldb PushLike}{\v ControlStyle_PushLike} style is set it has the BS_PUSHLIKE style.\line If the {\uldb Bitmap}{\v ControlStyle_Bitmap} style is set it has the BS_BITMAP style.\line If the {\uldb Icon}{\v ControlStyle_Icon} style is set it has the BS_ICON style.\line \page #{\footnote ControlType_ComboBox} ${\footnote ControlType ComboBox} K{\footnote ComboBox} +{\footnote ControlType:ComboBox} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ComboBox Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This control is a dop down combo box with an edit field. It makes possible to list a predefined list of values and also allows for the user to enter some new value.  It reads the possible values from the {\uldb ComboBox Table}{\v _ini_ComboBox_Table@msi.hlp}. If the sorted style is set, the items are displayed according the {\b Ordering} column of the table.  If the style is not set, that column is ignored and the items are displayed in alphabetical order.\line The length of the text that can be entered can be limited by putting a number from 0 to 2147483646 in curly braces at the beginning of the Text field in the {\uldb Control Table}{\v _msi_Control_Table@msi.hlp}.  For example if the text field starts with \{80\}, the length of the string is limited at 80 characters. If no such limit is supplied in the table, or if 0 is specified, the length is set to the maximum possible (2147483646 characters). A negative or non-numerical value will generate an error.\par\li0{\b Property}\par\li180 The property associated with this control can be integer or string valued. \par\li0{\b Valid Style Bits}\par\li180 {\uldb ComboList}{\v ControlStyle_ComboList}\line {\uldb Enabled}{\v ControlStyle_Enabled}\line {\uldb Indirect}{\v ControlStyle_Indirect}\line {\uldb Integer}{\v ControlStyle_Integer}\line {\uldb Sorted}{\v ControlStyle_Sorted}\line {\uldb Sunken}{\v ControlStyle_Sunken}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Enabled}{\v ControlAttribute_Enabled}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Indirect}{\v ControlAttribute_Indirect}\line {\uldb IndirectPropertyName}{\v ControlAttribute_IndirectPropertyName}\line {\uldb Integer}{\v ControlAttribute_Integer}\line {\uldb ItemsCount}{\v ControlAttribute_ItemsCount}\line {\uldb ItemsText}{\v ControlAttribute_ItemsText}\line {\uldb ItemsValue}{\v ControlAttribute_ItemsValue}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb Limit}{\v ControlAttribute_Limit}\line {\uldb OriginalValue}{\v ControlAttribute_OriginalValue}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb PropertyName}{\v ControlAttribute_PropertyName}\line {\uldb PropertyValue}{\v ControlAttribute_PropertyValue}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 \par\li0{\b Can Take Focus}\par\li180 Windows: Yes\line \par\li0{\b Windows Implementation}\par\li180 The control is created with the "COMBOBOX" class with the CBS_AUTOHSCROLL, WS_TABSTOP, WS_GROUP, WS_CHILD styles. If the {\uldb ComboList}{\v ControlStyle_ComboList} style bit is on, it also has the CBS_DROPDOWNLIST style, otherwise it has the CBS_DROPDOWN style.\line If the {\uldb Sorted}{\v ControlStyle_Sorted} style is set, it also has the CBS_SORT style. \page #{\footnote ControlType_DirectoryCombo} ${\footnote ControlType DirectoryCombo} K{\footnote DirectoryCombo} +{\footnote ControlType:DirectoryCombo} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b DirectoryCombo Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This is a special control designed for use on a browse dialog.  It is designed to be used with a {\uldb PathEdit}{\v ControlType_PathEdit} and {\uldb DirectoryList}{\v ControlType_DirectoryList} control on the same dialog.  It lets the user select the main part of a path (everything except the last segment). It displays the available volumes in an alphabetical order and the steps of the currently  displayed path in a hierarchical way. If the main part of the currently selected path contains any folders that are not existant at present time, those are displayed with a different icon.  The property associated with this control has to have an initial value, and this value has to contain at least two steps (a volume and at least one level below).  The selection of the initial style bits determines what kind of volumes are listed. \par\li0{\b Property}\par\li180 The property associated with this control can be only string valued.  \par\li0{\b Valid Style Bits}\par\li180 {\uldb CDROMVolume}{\v ControlStyle_CDROMVolume}\line {\uldb Enabled}{\v ControlStyle_Enabled}\line {\uldb FixedVolume}{\v ControlStyle_FixedVolume}\line {\uldb FloppyVolume}{\v ControlStyle_FloppyVolume}\line {\uldb Indirect}{\v ControlStyle_Indirect}\line {\uldb RAMDiskVolume}{\v ControlStyle_RAMDiskVolume}\line {\uldb RemoteVolume}{\v ControlStyle_RemoteVolume}\line {\uldb RemovableVolume}{\v ControlStyle_RemovableVolume}\line {\uldb SplitPath}{\v ControlStyle_SplitPath}\line {\uldb Sunken}{\v ControlStyle_Sunken}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Enabled}{\v ControlAttribute_Enabled}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Indirect}{\v ControlAttribute_Indirect}\line {\uldb IndirectPropertyName}{\v ControlAttribute_IndirectPropertyName}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb OriginalValue}{\v ControlAttribute_OriginalValue}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb PropertyName}{\v ControlAttribute_PropertyName}\line {\uldb PropertyValue}{\v ControlAttribute_PropertyValue}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 {\uldb DirectoryComboPath}{\v ControlEvent_DirectoryComboPath} \par\li0{\b Can Take Focus}\par\li180 Windows: Yes\line \par\li0{\b Windows Implementation}\par\li180 The control is created with the "COMBOBOX" class with the CBS_DROPDOWNLIST, CBS_OWNERDRAWFIXED, CBS_HASSTRINGS, WS_CHILD, WS_GROUP, WS_TABSTOP and WS_VSCROLL styles.\line \page #{\footnote ControlType_DirectoryList} ${\footnote ControlType DirectoryList} K{\footnote DirectoryList} +{\footnote ControlType:DirectoryList} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b DirectoryList Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This is a special control designed for use on a browse dialog.  It is designed to be used with a {\uldb PathEdit}{\v ControlType_PathEdit} and {\uldb DirectoryCombo}{\v ControlType_DirectoryCombo} control on the same dialog.  It shows the user the folders below the main part of a path (everything except the last segment). It displays the folders below the main part of the currently selected path. If the list contains  any folders that are not existant at present time, those are displayed with a different icon.  The property associated with this control has to have an initial value, and this value has to contain at least two steps (a volume and at least one level below).   The primary goal of this control is to let the user select a subfolder of the current selection. With some additional buttons it also lets the user select a new phantom folder in current selection or step up one step  in the path. If the user hits the create new folder button in folder where there is a phantom folder already, this folder is selected for editing instead of creating a second phantom folder.  \par\li0{\b Property}\par\li180 The property associated with this control can be only string valued. \par\li0{\b Valid Style Bits}\par\li180 {\uldb Enabled}{\v ControlStyle_Enabled}\line {\uldb Indirect}{\v ControlStyle_Indirect}\line {\uldb SplitPath}{\v ControlStyle_SplitPath}\line {\uldb Sunken}{\v ControlStyle_Sunken}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Enabled}{\v ControlAttribute_Enabled}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Indirect}{\v ControlAttribute_Indirect}\line {\uldb IndirectPropertyName}{\v ControlAttribute_IndirectPropertyName}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb OriginalValue}{\v ControlAttribute_OriginalValue}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb PropertyName}{\v ControlAttribute_PropertyName}\line {\uldb PropertyValue}{\v ControlAttribute_PropertyValue}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 {\uldb DirectoryListNew}{\v ControlEvent_DirectoryListNew}\line {\uldb DirectoryListPath}{\v ControlEvent_DirectoryListPath}\line {\uldb DirectoryListUp}{\v ControlEvent_DirectoryListUp}\line \par\li0{\b Can Take Focus}\par\li180 Windows: Yes\line \par\li0{\b Related Strings in the {\uldb UIText Table}{\v _msi_UIText_Table@msi.hlp}}\par\li180 {\b NewFolder} The default name of a newly created folder. \par\li0{\b Windows Implementation}\par\li180 The control is crated with the WC_LISTVIEW class with the LVS_LIST, LVS_EDITLABELS, WS_VSCROLL, LVS_SHAREIMAGELISTS, LVS_AUTOARRANGE, LVS_SINGLESEL, WS_BORDER, LVS_SORTASCENDING, WS_CHILD, WS_GROUP, WS_TABSTOP styles.\line \page #{\footnote ControlType_Edit} ${\footnote ControlType Edit} K{\footnote Edit} +{\footnote ControlType:Edit} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Edit Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This is a regular edit field. The user can enter any string or integer. If the associated property is integer valued it accepts only integer entries (not yet implemented).  The length of the text that can be entered can be limited by putting a number from 0 to 2147483646 in curly braces at the beginning of the Text field in the {\uldb Control Table}{\v _msi_Control_Table@msi.hlp}.  For example if the text field starts with \{80\}, the length of the string is limited at 80 characters. If no such limit is supplied in the table, or if 0 is specified, the length is set to the maximum possible (2147483646 characters). A negative or non-numerical value will generate an error. \par\li0{\b Property}\par\li180 The property associated with this control can be string or integer valued. \par\li0{\b Valid Style Bits}\par\li180 {\uldb Enabled}{\v ControlStyle_Enabled}\line {\uldb Indirect}{\v ControlStyle_Indirect}\line {\uldb Integer}{\v ControlStyle_Integer}\line {\uldb Sunken}{\v ControlStyle_Sunken}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Enabled}{\v ControlAttribute_Enabled}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Indirect}{\v ControlAttribute_Indirect}\line {\uldb IndirectPropertyName}{\v ControlAttribute_IndirectPropertyName}\line {\uldb Integer}{\v ControlAttribute_Integer}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb Limit}{\v ControlAttribute_Limit}\line {\uldb OriginalValue}{\v ControlAttribute_OriginalValue}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb PropertyName}{\v ControlAttribute_PropertyName}\line {\uldb PropertyValue}{\v ControlAttribute_PropertyValue}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 None. \par\li0{\b Can Take Focus}\par\li180 Yes\line \par\li0{\b Windows Implementation}\par\li180 The control is created with the "EDIT" class with the WS_BORDER, WS_CHILD, WS_TABSTOP, WS_GROUP styles.\line \page #{\footnote ControlType_MaskedEdit} ${\footnote ControlType MaskedEdit} K{\footnote MaskedEdit} +{\footnote ControlType:MaskedEdit} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b MaskedEdit Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This is a masked edit field control. The mask is contained in the text field of the control.  The syntax of the mask is the following:\line {\b #}  digit that is not part of the checksum\line {\b %}  digit that is part of the checksum\line {\b @} randomized digit, should not appear in the visible part of the template\line {\b =} digit, that is displayed in the UI as a digit followed by a dash, in the property returned by the UI it is replaced by the but will be replaced by a dash during validation. There can be only one such character in the template and it must follow a  # or a %.\line {\b ^} letter that is forced to upper case during validation\line {\b &} letter, can be upper or lower case\line {\b ?} alpha-numeric character\line {\b <} left end of the visible segment of the template. This character and everything to its left is hidden in the UI. The character is replaced by a dash during validation. There should be at most one of this character in the template.\line {\b >} right end of the visible segment of the template. The character and everything to its right is hidden in the UI. The character is replaced by a dash during validation. There should be at most one of this character in the template.\line Any other character is treated as a literal constant.\line For the characters that can be edited the control creats separate edit windows. (one window for each block of contiguous characters of the same kind.)  \par\li0{\b Property}\par\li180 The property associated with this control can be only string valued. \par\li0{\b Valid Style Bits}\par\li180 {\uldb Enabled}{\v ControlStyle_Enabled}\line {\uldb Indirect}{\v ControlStyle_Indirect}\line {\uldb Sunken}{\v ControlStyle_Sunken}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Enabled}{\v ControlAttribute_Enabled}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Indirect}{\v ControlAttribute_Indirect}\line {\uldb IndirectPropertyName}{\v ControlAttribute_IndirectPropertyName}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb OriginalValue}{\v ControlAttribute_OriginalValue}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb PropertyName}{\v ControlAttribute_PropertyName}\line {\uldb PropertyValue}{\v ControlAttribute_PropertyValue}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 None. \par\li0{\b Can Take Focus}\par\li180 Yes\line \par\li0{\b Windows Implementation}\par\li180 The control creates one parent window of the "BUTTON" class with the BS_OWNERDRAW and WS_EX_CONTROLPARENT styles. It creates several child windows to this window:  for the constant text parts it creates "STATIC" windows with the SS_LEFT and WS_CHILD styles. For the editable fields it creates an "EDIT" window with the WS_CHILD, WS_BORDER and WS_TABSTOP styles. In case of a numeric field the window also has the ES_NUMBER style.\line \page #{\footnote ControlType_ListBox} ${\footnote ControlType LisBox} K{\footnote ListBox} +{\footnote ControlType:ListBox} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ListBox Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This is a regular listbox control. It enables the user to select a value of a property from a pre-authored list of choices. This control supports only single select listboxes.  The possible values are read from the {\uldb Listbox Table}{\v _msi_Listbox_Table@msi.hlp}. Note that the string displayed is not necessarily the same as the value that the user is choosing.  If the control is created with the {\uldb Sorted}{\v ControlStyle_Sorted}, the items are listed according to the {\b Ordering} column of the table. If the style bit is not set,  the column is ignored. \par\li0{\b Property}\par\li180 The property associated with this control can be string or integer valued. \par\li0{\b Valid Style Bits}\par\li180 {\uldb Enabled}{\v ControlStyle_Enabled}\line {\uldb Indirect}{\v ControlStyle_Indirect}\line {\uldb Integer}{\v ControlStyle_Integer}\line {\uldb Sorted}{\v ControlStyle_Sorted}\line {\uldb Sunken}{\v ControlStyle_Sunken}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Enabled}{\v ControlAttribute_Enabled}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Icon}{\v ControlAttribute_Icon}\line {\uldb Indirect}{\v ControlAttribute_Indirect}\line {\uldb IndirectPropertyName}{\v ControlAttribute_IndirectPropertyName}\line {\uldb Integer}{\v ControlAttribute_Integer}\line {\uldb ItemsCount}{\v ControlAttribute_ItemsCount}\line {\uldb ItemsText}{\v ControlAttribute_ItemsText}\line {\uldb ItemsValue}{\v ControlAttribute_ItemsValue}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb OriginalValue}{\v ControlAttribute_OriginalValue}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb PropertyName}{\v ControlAttribute_PropertyName}\line {\uldb PropertyValue}{\v ControlAttribute_PropertyValue}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 None. \par\li0{\b Can Take Focus}\par\li180 Yes\line \par\li0{\b Windows Implementation}\par\li180 The control is created with the "LISTBOX" class.\line If the {\uldb Sorted}{\v ControlStyle_Sorted} style bit is on, the control is created with the LBS_NOTIFY, WS_VSCROLL, WS_BORDER styles, otherwise with the LBS_STANDARD style. It also has the WS_TABSTOP, WS_GROUP, WS_CHILD styles. \page #{\footnote ControlType_ListView} ${\footnote ControlType LisView} K{\footnote ListView} +{\footnote ControlType:ListView} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ListView Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This is a listview control displaying a single column of values with an icon next to each item. It enables the user to select a value of a property from a pre-authored list of choices. This control supports single select listviews only.  The possible values are read from the {\uldb ListView Table}{\v _msi_ListView_Table@msi.hlp}. Note that the string displayed is not necessarily the same as the value that the user is choosing.  If the control is created with the {\uldb Sorted}{\v ControlStyle_Sorted}, the items are listed according to the {\b Ordering} column of the table. If the style bit is not set,  the column is ignored. \par\li0{\b Property}\par\li180 The property associated with this control can be string or integer valued. \par\li0{\b Valid Style Bits}\par\li180 {\uldb Enabled}{\v ControlStyle_Enabled}\line {\uldb FixedSize}{\v ControlStyle_FixedSize}\line {\uldb IconSize}{\v ControlStyle_IconSize}\line {\uldb ImageHandle}{\v ControlStyle_ImageHandle}\line {\uldb Indirect}{\v ControlStyle_Indirect}\line {\uldb Integer}{\v ControlStyle_Integer}\line {\uldb Sorted}{\v ControlStyle_Sorted}\line {\uldb Sunken}{\v ControlStyle_Sunken}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Enabled}{\v ControlAttribute_Enabled}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Indirect}{\v ControlAttribute_Indirect}\line {\uldb IndirectPropertyName}{\v ControlAttribute_IndirectPropertyName}\line {\uldb Integer}{\v ControlAttribute_Integer}\line {\uldb ItemsCount}{\v ControlAttribute_ItemsCount}\line {\uldb ItemsText}{\v ControlAttribute_ItemsText}\line {\uldb ItemsValue}{\v ControlAttribute_ItemsValue}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb OriginalValue}{\v ControlAttribute_OriginalValue}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb PropertyName}{\v ControlAttribute_PropertyName}\line {\uldb PropertyValue}{\v ControlAttribute_PropertyValue}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 None. \par\li0{\b Can Take Focus}\par\li180 Windows: Yes\line \par\li0{\b Windows Implementation}\par\li180 The control is created with the WC_LISTVIEW class with the LVS_REPORT, LVS_NOCOLUMNHEADER, WS_VSCROLL, WS_HSCROLL, LVS_SHAREIMAGELISTS, LVS_SINGLESEL, LVS_SHOWSELALWAYS, WS_BORDER, WS_TABSTOP styles.\line If the {\uldb Sorted}{\v ControlStyle_Sorted} style bit is not on, the control also has the LVS_SORTASCENDING style. \page #{\footnote ControlType_PathEdit} ${\footnote ControlType PathEdit} K{\footnote PathEdit} +{\footnote ControlType:PathEdit} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b PathEdit Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This is a special control designed for use on a browse dialog.  It is designed to be used with a {\uldb DirectoryCombo}{\v ControlType_DirectoryCombo} and {\uldb DirectoryList}{\v ControlType_DirectoryList} control on the same dialog.  It lets the user select the path or the tail part of a path (the last segment of the path) depending on if the SplitPath style is set or not. It displays the currently selected folder name or the entire path in an edit field.  The property associated with this control has to have an initial value, and if the SplitPath style is on this value has to contain at least two steps (a volume and at least one level below).  This control also supports entering a full path in both modes. It first checks if the string enters is a valid path. If it is, it interprets the string as such. If it is not a valid path and the SplitPath style is on, it interprets it as the name of the folder to be selected.  One can also enter a UNC path to a drive that has no drive letter associated with it. This control does not let the focus leave if the selection is not valid. \par\li0{\b Property}\par\li180 The property associated with this control can be only string valued.  \par\li0{\b Valid Style Bits}\par\li180 {\uldb Enabled}{\v ControlStyle_Enabled}\line {\uldb Indirect}{\v ControlStyle_Indirect}\line {\uldb SplitPath}{\v ControlStyle_SplitPath}\line {\uldb Sunken}{\v ControlStyle_Sunken}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Enabled}{\v ControlAttribute_Enabled}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Indirect}{\v ControlAttribute_Indirect}\line {\uldb IndirectPropertyName}{\v ControlAttribute_IndirectPropertyName}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb OriginalValue}{\v ControlAttribute_OriginalValue}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb PropertyName}{\v ControlAttribute_PropertyName}\line {\uldb PropertyValue}{\v ControlAttribute_PropertyValue}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 None. \par\li0{\b Can Take Focus}\par\li180 Windows: Yes\line \par\li0{\b Windows Implementation}\par\li180 The control is derived from the {\uldb Edit}{\v ControlType_Edit} control.\line \page #{\footnote ControlType_RadioButtonGroup} ${\footnote ControlType RadioButtonGroup} K{\footnote RadioButtonGroup} +{\footnote ControlType:RadioButtonGroup} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b RadioButtonGroup Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This control is a group of radio buttons. It enables the user to select a value of a property from a pre-authored list of choices.   The possible values are read from the {\uldb RadioButton Table}{\v _msi_RadioButton_Table@msi.hlp}. Note that the string displayed is not necessarily the same as the value that the user is choosing.  The implementation treats the whole group as one control, therefore it is not possible to hide or disable individual buttons within the group. Similarly all the buttons have to be of the same style, i.e. either all of them have text or all of them have bitmaps, etc.  The position of the buttons is authored relative to the group. This way the entire group can be moved by changeing only the coordinates of the group without changeing the individual buttons.  At creation the control verifies that the individual buttons do not extend beyond the boundaries of the group.\line If the {\uldb Bitmap}{\v ControlStyle_Bitmap} or the {\uldb Icon}{\v ControlStyle_Icon} style bit is set, the corresponding text entry in the {\ulbd RadioButton Table}{\v _msi_RadioButton_Table@msi.hlp} is taken as a foreign key to the {\ulbd Binary Table}{\v _msi_Binary_Table@msi.hlp} that specifies the binary data needed to create the picture on the individual buttons.\line This means that the buttons can not have both a picture and a text.\line Because of the way Windows draws the frame, there is a gap between the top of the control's window and the visible frame, even when there is no caption. \par\li0{\b Property}\par\li180 The property associated with this control can be string or integer valued. \par\li0{\b Valid Style Bits}\par\li180 {\uldb Bitmap}{\v ControlStyle_Bitmap}\line {\uldb Enabled}{\v ControlStyle_Enabled}\line {\uldb FixedSize}{\v ControlStyle_FixedSize}\line {\uldb HasBorder}{\v ControlStyle_HasBorder}\line {\uldb Icon}{\v ControlStyle_Icon}\line {\uldb IconSize}{\v ControlStyle_IconSize}\line {\uldb ImageHandle}{\v ControlStyle_ImageHandle}\line {\uldb Indirect}{\v ControlStyle_Indirect}\line {\uldb Integer}{\v ControlStyle_Integer}\line {\uldb PushLike}{\v ControlStyle_PushLike}\line {\uldb Sunken}{\v ControlStyle_Sunken}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb Bitmap}{\v ControlAttribute_Bitmap}\line {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Enabled}{\v ControlAttribute_Enabled}\line {\uldb HasBorder}{\v ControlAttribute_HasBorder}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Icon}{\v ControlAttribute_Icon}\line {\uldb Indirect}{\v ControlAttribute_Indirect}\line {\uldb IndirectPropertyName}{\v ControlAttribute_IndirectPropertyName}\line {\uldb Integer}{\v ControlAttribute_Integer}\line {\uldb ItemsCount}{\v ControlAttribute_ItemsCount}\line {\uldb ItemsHandle}{\v ControlAttribute_ItemsHandle}\line {\uldb ItemsHeight}{\v ControlAttribute_ItemsHeight}\line {\uldb ItemsText}{\v ControlAttribute_ItemsText}\line {\uldb ItemsValue}{\v ControlAttribute_ItemsValue}\line {\uldb ItemsWidth}{\v ControlAttribute_ItemsWidth}\line {\uldb ItemsX}{\v ControlAttribute_ItemsX}\line {\uldb ItemsY}{\v ControlAttribute_ItemsY}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb OriginalValue}{\v ControlAttribute_OriginalValue}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb PropertyName}{\v ControlAttribute_PropertyName}\line {\uldb PropertyValue}{\v ControlAttribute_PropertyValue}\line {\uldb PushLike}{\v ControlAttribute_PushLike}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 None. \par\li0{\b Can Take Focus}\par\li180 Yes\line \par\li0{\b Windows Implementation}\par\li180 The group is created using the "BUTTON" class. If the {\uldb HasBorder}{\v ControlStyle_HasBorder} style is set, it has the BS_GROUPBOX style, otherwise it has the BS_OWNERDRAW style. \line The individual buttons are created with the "BUTTON" class.\line It has the BS_RADIOBUTTON, WS_CHILD, WS_GROUP, WS_TABSTOP, WS_EX_CONTROLPARENT and BS_MULTILINE styles.\line If the {\uldb PushLike}{\v ControlStyle_PushLike} style is set they have the BS_PUSHLIKE style.\line If the {\uldb Bitmap}{\v ControlStyle_Bitmap} style is set they have the BS_BITMAP style.\line If the {\uldb Icon}{\v ControlStyle_Icon} style is set they have the BS_ICON style.\line \page #{\footnote ControlType_VolumeSelectCombo} ${\footnote ControlType VolumeSelectCombo} K{\footnote VolumeSelectCombo} +{\footnote ControlType:VolumeSelectCombo} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b VolumeSelectCombo Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This is a special control designed to a volume from a list of volumes. It lists the volumes in alphabetical order. The types of controls displayed is determined by the style bits of the control.  \par\li0{\b Property}\par\li180 The property associated with this control can be only string valued.  \par\li0{\b Valid Style Bits}\par\li180 {\uldb CDROMVolume}{\v ControlStyle_CDROMVolume}\line {\uldb Enabled}{\v ControlStyle_Enabled}\line {\uldb FixedVolume}{\v ControlStyle_FixedVolume}\line {\uldb FloppyVolume}{\v ControlStyle_FloppyVolume}\line {\uldb Indirect}{\v ControlStyle_Indirect}\line {\uldb RAMDiskVolume}{\v ControlStyle_RAMDiskVolume}\line {\uldb RemoteVolume}{\v ControlStyle_RemoteVolume}\line {\uldb RemovableVolume}{\v ControlStyle_RemovableVolume}\line {\uldb Sunken}{\v ControlStyle_Sunken}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Enabled}{\v ControlAttribute_Enabled}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Indirect}{\v ControlAttribute_Indirect}\line {\uldb IndirectPropertyName}{\v ControlAttribute_IndirectPropertyName}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb OriginalValue}{\v ControlAttribute_OriginalValue}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb PropertyName}{\v ControlAttribute_PropertyName}\line {\uldb PropertyValue}{\v ControlAttribute_PropertyValue}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 None. \par\li0{\b Can Take Focus}\par\li180 Windows: Yes\line \par\li0{\b Windows Implementation}\par\li180 The control is created as a"COMBOBOX" with the CBS_DROPDOWNLIST, CBS_OWNERDRAWFIXED, CBS_HASSTRINGS, WS_VSCROLL, WS_CHILD, WS_GROUP, WS_TABSTOP and CBS_SORT styles.\line \page #{\footnote ControlType_Bitmap} ${\footnote ControlType Bitmap} K{\footnote Bitmap} +{\footnote ControlType:Bitmap} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Bitmap Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This control simply displays a static picture of a bitmap. \par\li0{\b Property}\par\li180 There can be no property associated with this control.  \par\li0{\b Valid Style Bits}\par\li180 {\uldb FixedSize}{\v ControlStyle_FixedSize}\line {\uldb ImageHandle}{\v ControlStyle_ImageHandle}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Image}{\v ControlAttribute_Image}\line {\uldb ImageHandle}{\v ControlAttribute_ImageHandle}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 None. \par\li0{\b Can Take Focus}\par\li180 Windows: No\line Maciontosh: No \par\li0{\b Windows Implementation}\par\li180 On NT3.51 the control is created as a "BUTTON" with the BS_OWNERDRAW style, on Win95 and NT4 it is created as a "STATIC" with the SS_BITMAP and SS_CENTERIMAGE styles. In both cases it also has the WS_CHILD and WS_GROUP styles.\line \page #{\footnote ControlType_Icon} ${\footnote ControlType Icon} K{\footnote Icon} +{\footnote ControlType:Icon} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Icon Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This control simply displays a static picture of an icon. The background of the image is transparent.\line An icon file can contain different size images of the same icon. If the {\uldb IconSize}{\v ControlStyle_Icon} bits are set, the first image of the specified size is loaded. If no size is specified, the first image is loaded.\line If the {\uldb IconSize}{\v ControlStyle_Icon} bits are not set the {\uldb FixedSize}{\v ControlStyle_FixedSize} bit is ignored and the image is stretched to fit the control rectangle.\line If both the IconSize bits and the FixedSize bit are set and the control is larger than the icon, the image is centered in the control. If the image is larger than the control it is not chopped (unlike in the {\uldb Bitmap}{\v ControlType_Bitmap} control) but shrunk to fit the control. \par\li0{\b Property}\par\li180 There can be no property associated with this control.  \par\li0{\b Valid Style Bits}\par\li180 {\uldb FixedSize}{\v ControlStyle_FixedSize}\line {\uldb IconSize}{\v ControlStyle_IconSize}\line {\uldb ImageHandle}{\v ControlStyle_ImageHandle}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Image}{\v ControlAttribute_Image}\line {\uldb ImageHandle}{\v ControlAttribute_ImageHandle}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 None. \par\li0{\b Can Take Focus}\par\li180 Windows: No\line Maciontosh: No \par\li0{\b Windows Implementation}\par\li180 On NT3.51 the control is created as a "BUTTON" with the BS_OWNERDRAW style, on Win95 and NT4 it is created as a "STATIC" with the SS_ICON and SS_CENTERIMAGE styles. In both cases it also has the WS_CHILD and WS_GROUP styles.\line \page #{\footnote ControlType_GroupBox} ${\footnote ControlType GroupBox} K{\footnote GroupBox} +{\footnote ControlType:GroupBox} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b GroupBox Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This control displays a rectangle, possibly with some caption. It only serves as a visual element on the dialog to group other controls together.\line Because of the way Windows draws this control, there is a gap between the top of the control's window and the visible frame, even when there is no caption. \par\li0{\b Property}\par\li180 There can be no property associated with this control.  \par\li0{\b Valid Style Bits}\par\li180 {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 None. \par\li0{\b Can Take Focus}\par\li180 Windows: No\line Maciontosh: No \par\li0{\b Windows Implementation}\par\li180 The control is created as a "BUTTON" with the BS_GROUPBOX, WS_CHILD, WS_GROUP styles.\line \page #{\footnote ControlType_ProgressBar} ${\footnote ControlType ProgressBar} K{\footnote ProgressBar} +{\footnote ControlType:ProgressBar} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b ProgressBar Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This control displays a rectangle filling up as it receives progress messages. Typically should subscribe to the {\uldb ActionProgress}{\v ControlEvent_ActionProgress} control event or a control event whose name matches the name of the action whose progress is gauged.  \par\li0{\b Property}\par\li180 There can be no property associated with this control.  \par\li0{\b Valid Style Bits}\par\li180 {\uldb Progress95}{\v ControlStyle_Progress95}\line {\uldb Sunken}{\v ControlStyle_Sunken}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb Progress}{\v ControlAttribute_Progress}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 None. \par\li0{\b Can Take Focus}\par\li180 Windows: No\line Maciontosh: No \par\li0{\b Windows Implementation}\par\li180 The control is created as a PROGRESS_CLASS. It also has the WS_CHILD and WS_GROUP styles.  \page #{\footnote ControlType_PushButton} ${\footnote ControlType PushButton} K{\footnote PushButton} +{\footnote ControlType:PushButton} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b PushButton Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This control displays a basic push button.\line If the {\uldb Bitmap}{\v ControlStyle_Bitmap} or the {\uldb Icon}{\v ControlStyle_Icon} style bit is set, the corresponding text entry in the {\ulbd Control Table}{\v _msi_Control_Table@msi.hlp} is taken as a foreign key to the {\ulbd Binary Table}{\v _msi_Binary_Table@msi.hlp} that specifies the binary data needed to create the picture.\line This means that the button can not have both a picture and a text. \par\li0{\b Property}\par\li180 There can be no property associated with this control.  \par\li0{\b Valid Style Bits}\par\li180 {\uldb Bitmap}{\v ControlStyle_Bitmap}\line {\uldb Enabled}{\v ControlStyle_Enabled}\line {\uldb FixedSize}{\v ControlStyle_FixedSize}\line {\uldb Icon}{\v ControlStyle_Icon}\line {\uldb IconSize}{\v ControlStyle_IconSize}\line {\uldb ImageHandle}{\v ControlStyle_ImageHandle}\line {\uldb Sunken}{\v ControlStyle_Sunken}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb Bitmap}{\v ControlAttribute_Bitmap}\line {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Enabled}{\v ControlAttribute_Enabled}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb Icon}{\v ControlAttribute_Icon}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Published}\par\li180 None. \par\li0{\b Can Take Focus}\par\li180 Windows: Yes\line Maciontosh: No \par\li0{\b Windows Implementation}\par\li180 The control is created with the "BUTTON" class.\line It has the BS_MULTILINE, WS_CHILD, WS_TABSTOP, WS_GROUP styles.\line If the {\uldb Bitmap}{\v ControlStyle_Bitmap} style is set it has the BS_BITMAP style.\line If the {\uldb Icon}{\v ControlStyle_Icon} style is set it has the BS_ICON style.\line \page #{\footnote ControlType_Text} ${\footnote ControlType Text} K{\footnote Text} +{\footnote ControlType:Text} \pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b Text Control \line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects} \tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp} \par}\li180 This control displays a static text. The text may use a predefined style. This is done by putting the name of the style in the form \{\\style\} at the start of the string, where style is one of the keys in the {\uldb TextStyle Table}{\v _msi_TextStyle_Table@msi.hlp}. A base text style can be assigned to the control by supplying \{&style\} at the very begining of a the text string. This style is used whenever no other style is defined by the string.\line \par\li0{\b Property}\par\li180 There can be no property associated with this control.  \par\li0{\b Valid Style Bits}\par\li180 {\uldb Sunken}{\v ControlStyle_Sunken}\line {\uldb Transparent}{\v ControlStyle_Transparent}\line {\uldb Visible}{\v ControlStyle_Visible}\line \par\li0{\b Valid Control Attributes}\par\li180 {\uldb ClientRect}{\v ControlAttribute_ClientRect}\line {\uldb Default}{\v ControlAttribute_Default}\line {\uldb Enabled}{\v ControlAttribute_Enabled}\line {\uldb Height}{\v ControlAttribute_Height}\line {\uldb Help}{\v ControlAttribute_Help}\line {\uldb KeyInt}{\v ControlAttribute_KeyInt}\line {\uldb KeyString}{\v ControlAttribute_KeyString}\line {\uldb Position}{\v ControlAttribute_Position}\line {\uldb RefCount}{\v ControlAttribute_RefCount}\line {\uldb Sunken}{\v ControlAttribute_Sunken}\line {\uldb Text}{\v ControlAttribute_Text}\line {\uldb Transparent}{\v ControlAttribute_Transparent}\line {\uldb Visible}{\v ControlAttribute_Visible}\line {\uldb Width}{\v ControlAttribute_Width}\line {\uldb WindowHandle}{\v ControlAttribute_WindowHandle}\line {\uldb X}{\v ControlAttribute_X}\line {\uldb Y}{\v ControlAttribute_Y}\line \par\li0{\b Control Events Publishe