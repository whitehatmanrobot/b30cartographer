ndexA( IDirectPlay8AddressIP *pInterface, const DWORD dwComponentID, CHAR * pszTag, PDWORD pdwNameLen, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType );
> typedef	STDMETHODIMP DP8ATCP_AddComponentA( IDirectPlay8AddressIP *pInterface, const CHAR * const pszTag, const void * const pComponentData, const DWORD dwComponentSize, const DWORD dwDataType );
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ATCP_BuildAddressW"
> STDMETHODIMP DP8ATCP_BuildAddressW( IDirectPlay8AddressIP *pInterface, const WCHAR * const pwszAddress, const USHORT usPort )
> {
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 	
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );
> 
> 	LPSTR pszShadowAddress = NULL;
> 
> 	if( pwszAddress != NULL )
> 	{
> 		pszShadowAddress = new char[wcslen(pwszAddress)+1];
> 
> 		if( pszShadowAddress == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Out of memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto BUILDADDRESSW_EXIT;
> 		}
> 
> 		hr = WideToAnsi( pszShadowAddress, pwszAddress, wcslen(pwszAddress)+1 );
> 
> 		if( FAILED( hr ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting Address to ANSI hr=0x%x", hr );
> 			hr = DPNERR_GENERIC;
> 			goto BUILDADDRESSW_EXIT;
> 		}
> 	}
> 
> 	hr = DP8ATCP_BuildAddressA( pInterface, pszShadowAddress, usPort );
> 
> BUILDADDRESSW_EXIT:
> 
> 	if( pszShadowAddress != NULL )
> 		delete [] pszShadowAddress;
> 
> 	return hr;
> 	
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ATCP_GetAddressW"
> STDMETHODIMP DP8ATCP_GetAddressW( IDirectPlay8AddressIP *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressLength, PUSHORT pusPort )
> {
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 	
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );
> 
> 	LPSTR pszShadowAddress = NULL;
> 	DWORD dwShadowAddressSize = 0;
> 
> 	if( pwszAddress != NULL && pdwAddressLength != NULL )
> 	{
> 		pszShadowAddress = new char[*pdwAddressLength];
> 
> 		if( pszShadowAddress == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Out of memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto GETADDRESSW_EXIT;
> 		}
> 	}
> 
> 	hr = DP8ATCP_GetAddressA( pInterface, pszShadowAddress, pdwAddressLength, pusPort );
> 
> 	if( hr == DPN_OK )
> 	{
> 		hr = AnsiToWide( pwszAddress, pszShadowAddress, *pdwAddressLength );
> 
> 		if( FAILED( hr ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Unable to convert name to Wide hr=0x%x", hr );
> 			goto GETADDRESSW_EXIT;
> 		}
> 	}
> 
> GETADDRESSW_EXIT:
> 
> 	if( pszShadowAddress != NULL )
> 		delete [] pszShadowAddress;
> 
> 	return hr;
> }
> 
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
34c34
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
24a25,31
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DPNAddress"
> 
> /*
31a39,67
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNAddress"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNAddress"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dllmain.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29
> #include "creg.h"
37a39,86
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8Address.Address.1", L"DirectPlay8Address Object", 
> 							  L"dpnaddr.dll", CLSID_DirectPlay8Address, L"DirectPlay8Address.Address") )
> 	{
> 		DPFERR( "Could not register address object" );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Address) )
> 	{
> 		DPF( 0, "Failed to unregister server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
5a6,8
> 	DirectPlay8AddressCreate	@1
> 	DllRegisterServer	PRIVATE
> 	DllUnregisterServer PRIVATE
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnaddr.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address \0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,61
> 
> #endif
> 
> #endif    // !_MAC
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2,3c17,27
< TARGETPATHLIB=$(BASEDIR)\public\sdk\lib
< TARGETTYPE=DYNLINK
---
> DLLDEF=..\dnadd.def
> UMTYPE=windows
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
4a29
> TARGETTYPE=DYNLINK
6,14c31,35
< !ifdef _BUILD_FOR_WIN2000
< UMTYPE=windows
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
16c37
< INCLUDES=..\;..\..\inc;..\..\common
---
> PASS1_PUBLISH={ $(O)\dpnaddr.lib = $(SDK_LIB_PATH)\dpnaddr.lib}
18c39,54
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
>            ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\wsock32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
20d55
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
22,23c57,58
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
26c61,65
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28c67
< DLLDEF=..\dnadd.def
---
> INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\common
29a69,76
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
38a86
>          ..\dplegacy.cpp \
40a89,95
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
> 
> USER_C_FLAGS=-nologo -W3
43,62c98,100
< TARGETLIBS= \
<            ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\winsockx.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
63a64,75
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
> // {826F86D1-AE2C-4428-A66F-974381B25F5B}
> DEFINE_GUID(IID_IDirectPlay8AddressModem,
> 0x826f86d1, 0xae2c, 0x4428, 0xa6, 0x6f, 0x97, 0x43, 0x81, 0xb2, 0x5f, 0x5b);
> 
> // {59BE79FE-A96A-4710-9BD2-22A50E7B24BD}
> DEFINE_GUID(IID_IDirectPlay8AddressSerial,
> 0x59be79fe, 0xa96a, 0x4710, 0x9b, 0xd2, 0x22, 0xa5, 0xe, 0x7b, 0x24, 0xbd);
> 
71a84,86
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
> typedef struct IDirectPlay8AddressSerial  	*PDIRECTPLAY8ADDRESSSERIAL, *LPDIRECTPLAY8ADDRESSSERIAL;
> typedef struct IDirectPlay8AddressModem		*PDIRECTPLAY8ADDRESSMODEM, *LPDIRECTPLAY8ADDRESSMODEM;
87a103
> #define DPNA_DATATYPE_STRING_ANSI           0x00000005
348a365,417
> // values for baud rate
> #define DPNA_BAUD_RATE_110					110
> #define DPNA_BAUD_RATE_300					300
> #define DPNA_BAUD_RATE_600					600
> #define DPNA_BAUD_RATE_1200					1200
> #define DPNA_BAUD_RATE_2400					2400
> #define DPNA_BAUD_RATE_4800					4800
> #define DPNA_BAUD_RATE_9600					9600
> #define DPNA_BAUD_RATE_14400				14400
> #define DPNA_BAUD_RATE_19200				19200
> #define DPNA_BAUD_RATE_38400				38400
> #define DPNA_BAUD_RATE_56000				56000
> #define DPNA_BAUD_RATE_57600				57600
> #define DPNA_BAUD_RATE_115200				115200
> #define DPNA_BAUD_RATE_128000				128000
> #define DPNA_BAUD_RATE_256000				256000
> 
> //// values for baud rate
> //#define DPNA_BAUD_RATE_110					L"110"
> //#define DPNA_BAUD_RATE_300					L"300"
> //#define DPNA_BAUD_RATE_600					L"600"
> //#define DPNA_BAUD_RATE_1200					L"1200"
> //#define DPNA_BAUD_RATE_2400					L"2400"
> //#define DPNA_BAUD_RATE_4800					L"4800"
> //#define DPNA_BAUD_RATE_9600					L"9600"
> //#define DPNA_BAUD_RATE_14400				L"14400"
> //#define DPNA_BAUD_RATE_19200				L"19200"
> //#define DPNA_BAUD_RATE_38400				L"38400"
> //#define DPNA_BAUD_RATE_56000				L"56000"
> //#define DPNA_BAUD_RATE_57600				L"57600"
> //#define DPNA_BAUD_RATE_115200				L"115200"
> //#define DPNA_BAUD_RATE_128000				L"128000"
> //#define DPNA_BAUD_RATE_256000				L"256000"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE					L"1"
> #define DPNA_STOP_BITS_ONE_FIVE				L"1.5"
> #define DPNA_STOP_BITS_TWO					L"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE					L"NONE"
> #define DPNA_PARITY_EVEN					L"EVEN"
> #define DPNA_PARITY_ODD						L"ODD"
> #define DPNA_PARITY_MARK					L"MARK"
> #define DPNA_PARITY_SPACE					L"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE				L"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF			L"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS				L"RTS"
> #define DPNA_FLOW_CONTROL_DTR				L"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR			L"RTSDTR"
> 
350a420,422
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
352a425,487
> //// ANSI DEFINITIONS
> 
> // Header
> #define DPNA_HEADER_A						"x-directplay:/"
> #define DPNA_SEPARATOR_KEYVALUE_A			'='
> #define DPNA_SEPARATOR_USERDATA_A			'#'
> #define DPNA_SEPARATOR_COMPONENT_A			';'
> #define DPNA_ESCAPECHAR_A					'%'
> 
> // key names for address components
> #define DPNA_KEY_APPLICATION_INSTANCE_A		"applicationinstance"
> #define DPNA_KEY_BAUD_A						"baud"
> #define DPNA_KEY_DEVICE_A					"device"
> #define DPNA_KEY_FLOWCONTROL_A				"flowcontrol"
> #define DPNA_KEY_HOSTNAME_A					"hostname"
> #define DPNA_KEY_PARITY_A					"parity"
> #define DPNA_KEY_PHONENUMBER_A				"phonenumber"
> #define DPNA_KEY_PORT_A						"port"
> #define DPNA_KEY_PROGRAM_A					"program"
> #define DPNA_KEY_PROVIDER_A					"provider"
> #define DPNA_KEY_STOPBITS_A					"stopbits"
> 
> //// values for baud rate
> //#define DPNA_BAUD_RATE_110_A				"110"
> //#define DPNA_BAUD_RATE_300_A				"300"
> //#define DPNA_BAUD_RATE_600_A				"600"
> //#define DPNA_BAUD_RATE_1200_A				"1200"
> //#define DPNA_BAUD_RATE_2400_A				"2400"
> //#define DPNA_BAUD_RATE_4800_A				"4800"
> //#define DPNA_BAUD_RATE_9600_A				"9600"
> //#define DPNA_BAUD_RATE_14400_A				"14400"
> //#define DPNA_BAUD_RATE_19200_A				"19200"
> //#define DPNA_BAUD_RATE_38400_A				"38400"
> //#define DPNA_BAUD_RATE_56000_A				"56000"
> //#define DPNA_BAUD_RATE_57600_A				"57600"
> //#define DPNA_BAUD_RATE_115200_A				"115200"
> //#define DPNA_BAUD_RATE_128000_A				"128000"
> //#define DPNA_BAUD_RATE_256000_A				"256000"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE_A				"1"
> #define DPNA_STOP_BITS_ONE_FIVE_A			"1.5"
> #define DPNA_STOP_BITS_TWO_A				"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE_A					"NONE"
> #define DPNA_PARITY_EVEN_A					"EVEN"
> #define DPNA_PARITY_ODD_A					"ODD"
> #define DPNA_PARITY_MARK_A					"MARK"
> #define DPNA_PARITY_SPACE_A					"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE_A			"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF_A 		"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS_A				"RTS"
> #define DPNA_FLOW_CONTROL_DTR_A				"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR_A			"RTSDTR"
> 
> // Shortcut values
> #define DPNA_VALUE_TCPIPPROVIDER_A          "IP"
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
> #define DPNA_VALUE_MODEMPROVIDER_A          "MODEM"
> #define DPNA_VALUE_SERIALPROVIDER_A         "SERIAL"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
111,112d110
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
153a152,160
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {6D4A3650-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_MODEM, 0x6d4a3650, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {743B5D60-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_SERIAL, 0x743b5d60, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
177a185,187
> typedef struct IDirectPlay8LobbiedApplication	*PDNLOBBIEDAPPLICATION;
> typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
> 
662a673
> #define	DPNCONNECT_OKTOQUERYFORADDRESSING	0x0001
667a679
> #define	DPNENUMHOSTS_OKTOQUERYFORADDRESSING	0x0001
776a789
> #define DPNSESSION_NODPNSVR					0x0040
857c870
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
902c915
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
952c965
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpsp8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
56a57
> #define DPNSPF_OKTOQUERY			0x00000002		// OK for SP to ask the user for clarification on addresses
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
105c105
< 	DNASSERT( ulFlags == 0 );
---
> 	DNASSERT( ( ulFlags & ~( DPNCONNECT_OKTOQUERYFORADDRESSING ) ) == 0 );
106a107,111
> 	if ( ( ulFlags & DPNCONNECT_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		ConnData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\enum.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
117a118,122
> 	if ( ( dwFlags & DPNENUMHOSTS_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		EnumData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\initialize.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
351c351
< 		if((pSPD->hSendEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL){
---
> 		if((pSPD->hSendEvent = CreateEventA(NULL, FALSE, FALSE, NULL)) == NULL){
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2c17,26
< TARGETTYPE=LIBRARY
---
> 
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
3a28
> TARGETTYPE=LIBRARY
5,9d29
< !ifdef _BUILD_FOR_WIN2000
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< LINKER_FLAGS=-align:32
< !endif
11c31,35
< INCLUDES=..\common;..\inc;..\dnaddress
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
13c37,41
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE -DMICHAEL
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS)
15d42
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
17,18c44,55
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> 
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
> 
> INCLUDES=$(DXROOT)\inc;..\common;..\inc;..\dnaddress
> 
> 
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
21c58,63
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
34c76,78
< USE_NOLIBS=1
---
> #
> # Next specify options for the compiler.
> #
36c80,86
< TARGETLIBS=
---
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE /DMICHAEL
> MSC_OPTIMIZATION=/Odi /Zi
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\timer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
575c575
< 	hWorkToDoSem=CreateSemaphore(NULL,0,65535,NULL);
---
> 	hWorkToDoSem=CreateSemaphoreA(NULL,0,65535,NULL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22,24
> 
> #include	"DNDBG.h"
> 
195,196c198,228
< // BUGBUG: [mgere] [xbox]  Removed all code in here.  I don't believe it's necessary anymore and it was using some COM functions that we don't have.
< 	return S_OK;
---
>     HRESULT		hr;
>     HINSTANCE	hdll;
>     LPGPCLASSFACTORY	pcf;
> 
> 
>     pcf = (LPGPCLASSFACTORY) This;
> 
>     /*
>      * call CoLockObjectExternal
>      */
>     hr = E_UNEXPECTED;
>     hdll = LoadLibraryA( "OLE32.DLL" );
>     if( hdll != NULL )
>     {
>         PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;
> 
> 
> 		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, "CoLockObjectExternal" ) );
>         if( lpCoLockObjectExternal != NULL )
>         {
>             hr = lpCoLockObjectExternal( (LPUNKNOWN) This, fLock, TRUE );
>         }
>         else
>         {
>         }
>     }
>     else
>     {
>     }
> 
> 	return hr;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
30a38,66
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNSPWinsock"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectDPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNSPWinsock"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
120a122,141
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( dwDebugLevel, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
> 					);
> 			break;
> 		}
> 
144,145d164
< // BUGBUG: [mgere] [xbox] Must convert this to unicode
< /*
193d211
< */
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> #include "resource.h"
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #include "windows.h"
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnwsock.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,153
> 
> #endif
> 
> #endif    // !_MAC
> 
> 
> 
> #ifdef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // TEXTINCLUDE
> //
> 
> 1 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "resource.h\0"
> END
> 
> 2 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "#include ""afxres.h""\r\n"
>     "\0"
> END
> 
> 3 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "\r\n"
>     "\0"
> END
> 
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // Dialog
> //
> 
> IDD_IP_SETTINGS DIALOG DISCARDABLE  0, 0, 194, 66
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION | 
>     WS_SYSMENU
> CAPTION "Enter host name"
> FONT 8, "MS Shell Dlg"
> BEGIN
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
> END
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // DESIGNINFO
> //
> 
> #ifdef APSTUDIO_INVOKED
> GUIDELINES DESIGNINFO DISCARDABLE 
> BEGIN
>     IDD_IP_SETTINGS, DIALOG
>     BEGIN
>         LEFTMARGIN, 7
>         RIGHTMARGIN, 187
>         TOPMARGIN, 7
>         BOTTOMMARGIN, 59
>     END
> END
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // String Table
> //
> 
> STRINGTABLE DISCARDABLE 
> BEGIN
>     IDS_FRIENDLYNAME_IPX    "DirectPlay8 IPX Service Provider"
>     IDS_FRIENDLYNAME_TCPIP  "DirectPlay8 TCP/IP Service Provider"
> END
> 
> #endif    // English (U.S.) resources
> /////////////////////////////////////////////////////////////////////////////
> 
> 
> 
> #ifndef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 3 resource.
> //
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> #endif    // not APSTUDIO_INVOKED
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock1.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,42c1,67
< #define p_accept accept
< #define p_bind bind
< #define p_closesocket closesocket
< #define p_connect connect
< #define p_gethostbyaddr gethostbyaddr
< #define p_gethostbyname gethostbyname
< #define p_gethostname gethostname
< #define p_getpeername getpeername
< #define p_getprotobyname getprotobyname
< #define p_getprotobynumber getprotobynumber
< #define p_getservbyname getservbyname
< #define p_getservbyport getservbyport
< #define p_getsockname getsockname
< #define p_getsockopt getsockopt
< #define p_htonl htonl
< #define p_htons htons
< #define p_inet_addr inet_addr
< #define p_inet_ntoa inet_ntoa
< #define p_ioctlsocket ioctlsocket
< #define p_listen listen
< #define p_ntohl ntohl
< #define p_ntohs ntohs
< #define p_recv recv
< #define p_recvfrom recvfrom
< #define p_select select
< #define p_send send
< #define p_sendto sendto
< #define p_setsockopt setsockopt
< #define p_shutdown shutdown
< #define p_socket socket
< //#define p_WSAAsyncGetHostByAddr WSAAsyncGetHostByAddr
< //#define p_WSAAsyncGetHostByName WSAAsyncGetHostByName
< //#define p_WSAAsyncGetProtoByName WSAAsyncGetProtoByName
< //#define p_WSAAsyncGetProtoByNumber WSAAsyncGetProtoByNumber
< //#define p_WSAAsyncGetServByName WSAAsyncGetServByName
< //#define p_WSAAsyncGetServByPort WSAAsyncGetServByPort
< //#define p_WSAAsyncSelect WSAAsyncSelect
< //#define p_WSACancelAsyncRequest WSACancelAsyncRequest
< #define p_WSACleanup WSACleanup
< #define p_WSAGetLastError WSAGetLastError
< #define p_WSASetLastError WSASetLastError
< #define p_WSAStartup WSAStartup
---
> //
> // DWNSOCK1.INC	Macros for dynamically linking to WinSock 1.1
> //
> 
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	//
> 	// Function available in both versions
> 	//
> 	DYNAMICWINSOCK(accept, LPFN_ACCEPT);
> 	DYNAMICWINSOCK(bind, LPFN_BIND);
> 	DYNAMICWINSOCK(closesocket, LPFN_CLOSESOCKET);
> 	DYNAMICWINSOCK(connect, LPFN_CONNECT);
> 	DYNAMICWINSOCK(gethostbyaddr, LPFN_GETHOSTBYADDR);
> 	DYNAMICWINSOCK(gethostbyname, LPFN_GETHOSTBYNAME);
> 	DYNAMICWINSOCK(gethostname, LPFN_GETHOSTNAME);
> 	DYNAMICWINSOCK(getpeername, LPFN_GETPEERNAME);
> 	DYNAMICWINSOCK(getprotobyname, LPFN_GETPROTOBYNAME);
> 	DYNAMICWINSOCK(getprotobynumber, LPFN_GETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(getservbyname, LPFN_GETSERVBYNAME);
> 	DYNAMICWINSOCK(getservbyport, LPFN_GETSERVBYPORT);
> 	DYNAMICWINSOCK(getsockname, LPFN_GETSOCKNAME);
> 	DYNAMICWINSOCK(getsockopt, LPFN_GETSOCKOPT);
> 	DYNAMICWINSOCK(htonl, LPFN_HTONL);
> 	DYNAMICWINSOCK(htons, LPFN_HTONS);
> 	DYNAMICWINSOCK(inet_addr, LPFN_INET_ADDR);
> 	DYNAMICWINSOCK(inet_ntoa, LPFN_INET_NTOA);
> 	DYNAMICWINSOCK(ioctlsocket, LPFN_IOCTLSOCKET);
> 	DYNAMICWINSOCK(listen, LPFN_LISTEN);
> 	DYNAMICWINSOCK(ntohl, LPFN_NTOHL);
> 	DYNAMICWINSOCK(ntohs, LPFN_NTOHS);
> 	DYNAMICWINSOCK(recv, LPFN_RECV);
> 	DYNAMICWINSOCK(recvfrom, LPFN_RECVFROM);
> 	DYNAMICWINSOCK(select, LPFN_SELECT);
> 	DYNAMICWINSOCK(send, LPFN_SEND);
> 	DYNAMICWINSOCK(sendto, LPFN_SENDTO);
> 	DYNAMICWINSOCK(setsockopt, LPFN_SETSOCKOPT);
> 	DYNAMICWINSOCK(shutdown, LPFN_SHUTDOWN);
> 	DYNAMICWINSOCK(socket, LPFN_SOCKET);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByAddr, LPFN_WSAASYNCGETHOSTBYADDR);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByName, LPFN_WSAASYNCGETHOSTBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByName, LPFN_WSAASYNCGETPROTOBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByNumber, LPFN_WSAASYNCGETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(WSAAsyncGetServByName, LPFN_WSAASYNCGETSERVBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetServByPort, LPFN_WSAASYNCGETSERVBYPORT);
> 	DYNAMICWINSOCK(WSAAsyncSelect, LPFN_WSAASYNCSELECT);
> 	DYNAMICWINSOCK(WSACancelAsyncRequest, LPFN_WSACANCELASYNCREQUEST);
> 	DYNAMICWINSOCK(WSACleanup, LPFN_WSACLEANUP);
> 	DYNAMICWINSOCK(WSAGetLastError, LPFN_WSAGETLASTERROR);
> 	DYNAMICWINSOCK(WSASetLastError, LPFN_WSASETLASTERROR);
> 	DYNAMICWINSOCK(WSAStartup, LPFN_WSASTARTUP);
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock2.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,27c1,3
< #ifdef UNICODE
< //	#define p_WSAAddressToString				WSAAddressToStringW
< //	#define p_WSADuplicateSocket				WSADuplicateSocketW
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersW
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsW
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoW
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdW
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassW
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginW
< //	#define p_WSALookupServiceNext				WSALookupServiceNextW
< //	#define p_WSASetService						WSASetServiceW
< //	#define p_WSASocket							WSASocketW
< //	#define p_WSAStringToAddress				WSAStringToAddressW
< #else
< //	#define p_WSAAddressToString				WSAAddressToStringA
< //	#define p_WSADuplicateSocket				WSADuplicateSocketA
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersA
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsA
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoA
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdA
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassA
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginA
< //	#define p_WSALookupServiceNext				WSALookupServiceNextA
< //	#define p_WSASetService						WSASetServiceA
< //	#define p_WSASocket							WSASocketA
< //	#define p_WSAStringToAddress				WSAStringToAddressA
< #endif // UNICODE
---
> //
> // DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
> //
29,53c5,70
< //#define p_WSAAccept WSAAccept
< #define p_WSACloseEvent WSACloseEvent
< //#define p_WSAConnect WSAConnect
< #define p_WSACreateEvent WSACreateEvent
< #define p_WSAEnumNetworkEvents WSAEnumNetworkEvents
< #define p_WSAEventSelect WSAEventSelect
< #define p_WSAGetOverlappedResult WSAGetOverlappedResult
< //#define p_WSAGetQOSByName WSAGetQOSByName
< //#define p_WSAHtonl WSAHtonl
< //#define p_WSAHtons WSAHtons
< #define p_WSAIoctl WSAIoctl
< //#define p_WSAJoinLeaf WSAJoinLeaf
< //#define p_WSALookupServiceEnd WSALookupServiceEnd
< //#define p_WSANtohl WSANtohl
< //#define p_WSANtohs WSANtohs
< #define p_WSARecv WSARecv
< //#define p_WSARecvDisconnect WSARecvDisconnect
< #define p_WSARecvFrom WSARecvFrom
< //#define p_WSARemoveServiceClass WSARemoveServiceClass
< #define p_WSAResetEvent WSAResetEvent
< #define p_WSASend WSASend
< //#define p_WSASendDisconnect WSASendDisconnect
< #define p_WSASendTo WSASendTo
< #define p_WSASetEvent WSASetEvent
< #define p_WSAWaitForMultipleEvents WSAWaitForMultipleEvents
---
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	DYNAMICWINSOCK(WSAAccept, LPFN_WSAACCEPT);
> 	DYNAMICWINSOCK(WSAAddressToStringA, LPFN_WSAADDRESSTOSTRINGA);
> 	DYNAMICWINSOCK(WSAAddressToStringW, LPFN_WSAADDRESSTOSTRINGW);
> 	DYNAMICWINSOCK(WSACloseEvent, LPFN_WSACLOSEEVENT);
> 	DYNAMICWINSOCK(WSAConnect, LPFN_WSACONNECT);
> 	DYNAMICWINSOCK(WSACreateEvent, LPFN_WSACREATEEVENT);
> 	DYNAMICWINSOCK(WSADuplicateSocketA, LPFN_WSADUPLICATESOCKETA);
> 	DYNAMICWINSOCK(WSADuplicateSocketW, LPFN_WSADUPLICATESOCKETW);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersA, LPFN_WSAENUMNAMESPACEPROVIDERSA);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersW, LPFN_WSAENUMNAMESPACEPROVIDERSW);
> 	DYNAMICWINSOCK(WSAEnumNetworkEvents, LPFN_WSAENUMNETWORKEVENTS);
> 	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
> 	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
> 	DYNAMICWINSOCK(WSAEventSelect, LPFN_WSAEVENTSELECT);
> 	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
> 	DYNAMICWINSOCK(WSAGetQOSByName, LPFN_WSAGETQOSBYNAME);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoA, LPFN_WSAGETSERVICECLASSINFOA);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoW, LPFN_WSAGETSERVICECLASSINFOW);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdA, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdW, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW);
> 	DYNAMICWINSOCK(WSAHtonl, LPFN_WSAHTONL);
> 	DYNAMICWINSOCK(WSAHtons, LPFN_WSAHTONS);
> 	DYNAMICWINSOCK(WSAInstallServiceClassA, LPFN_WSAINSTALLSERVICECLASSA);
> 	DYNAMICWINSOCK(WSAInstallServiceClassW, LPFN_WSAINSTALLSERVICECLASSW);
> 	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
> 	DYNAMICWINSOCK(WSAJoinLeaf, LPFN_WSAJOINLEAF);
> 	DYNAMICWINSOCK(WSALookupServiceBeginA, LPFN_WSALOOKUPSERVICEBEGINA);
> 	DYNAMICWINSOCK(WSALookupServiceBeginW, LPFN_WSALOOKUPSERVICEBEGINW);
> 	DYNAMICWINSOCK(WSALookupServiceEnd, LPFN_WSALOOKUPSERVICEEND);
> 	DYNAMICWINSOCK(WSALookupServiceNextA, LPFN_WSALOOKUPSERVICENEXTA);
> 	DYNAMICWINSOCK(WSALookupServiceNextW, LPFN_WSALOOKUPSERVICENEXTW);
> 	DYNAMICWINSOCK(WSANtohl, LPFN_WSANTOHL);
> 	DYNAMICWINSOCK(WSANtohs, LPFN_WSANTOHS);
> 	DYNAMICWINSOCK(WSARecv, LPFN_WSARECV);
> 	DYNAMICWINSOCK(WSARecvDisconnect, LPFN_WSARECVDISCONNECT);
> 	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
> 	DYNAMICWINSOCK(WSARemoveServiceClass, LPFN_WSAREMOVESERVICECLASS);
> 	DYNAMICWINSOCK(WSAResetEvent, LPFN_WSARESETEVENT);
> 	DYNAMICWINSOCK(WSASend, LPFN_WSASEND);
> 	DYNAMICWINSOCK(WSASendDisconnect, LPFN_WSASENDDISCONNECT);
> 	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
> 	DYNAMICWINSOCK(WSASetEvent, LPFN_WSASETEVENT);
> 	DYNAMICWINSOCK(WSASetServiceA, LPFN_WSASETSERVICEA);
> 	DYNAMICWINSOCK(WSASetServiceW, LPFN_WSASETSERVICEW);
> 	DYNAMICWINSOCK(WSASocketA, LPFN_WSASOCKETA);
> 	DYNAMICWINSOCK(WSASocketW, LPFN_WSASOCKETW);
> 	DYNAMICWINSOCK(WSAStringToAddressA, LPFN_WSASTRINGTOADDRESSA);
> 	DYNAMICWINSOCK(WSAStringToAddressW, LPFN_WSASTRINGTOADDRESSW);
> 	DYNAMICWINSOCK(WSAWaitForMultipleEvents, LPFN_WSAWAITFORMULTIPLEEVENTS);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
102a104
> 	m_hActiveSettingsDialog( NULL ),
129a132
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
362a366,373
> 		//
> 		// cancel any active dialogs
> 		// if there are no dialogs, cancel the active command
> 		//
> 		if ( m_hActiveSettingsDialog != NULL )
> 		{
> 			StopSettingsDialog( m_hActiveSettingsDialog );
> 		}
365a377,383
> 	else
> 	{
> 		//
> 		// there should be no active dialog if there isn't an active command
> 		//
> 		DNASSERT( m_hActiveSettingsDialog == NULL );
> 	}
847a866,872
> 	if ( m_hActiveSettingsDialog != NULL )
> 	{
> 		StopSettingsDialog( m_hActiveSettingsDialog );
> 		Unlock();
> 	}
> 	else
> 	{
853a879
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
279a280,286
> 		// UI functions
> 		//
> 		virtual	HRESULT	ShowSettingsDialog( CThreadPool *const pThreadPool ) = 0;
> 		virtual	void	StopSettingsDialog( const HWND hDlg ) = 0;
> 		virtual	void	SettingsDialogComplete( const HRESULT hr ) = 0;
> 
> 		//
298a306,307
> 
> 		HWND			m_hActiveSettingsDialog;		// handle of active settings dialog
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
44a46
> #include	"IPXAddress.h"
81c83,84
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
99a103,104
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
114a120
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
188a195,200
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
209a222,228
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
213a233,255
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
238a281,282
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
271a316,317
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
302a349,354
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
444a497,503
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
447a507,530
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
479a563,564
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
500a586,587
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
87a88,90
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
117a121
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
118a123
> 
148a154
> 		INT		m_Win9xReceiveWSAReturn;		
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
84a86
> const DWORD	g_dwIPBroadcastAddressSize = sizeof( g_IPBroadcastAddress );
978,980d979
< // BUGBUG: [mgere] [xbox] No need to enum adapters anymore since we only have one.
< // need to complete the removal of this functionality at a later date.
< /*
1300d1298
< */	return DPNERR_UNSUPPORTED;
1480a1479,1484
> 	//
> 	// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1481a1486,1504
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1484a1508,1510
> 		case 2:
> 		default:
> 		{
1485a1512,1514
> 			break;
> 		}
> 	}
1555a1585,1590
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1556a1592,1610
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1559a1614,1616
> 		case 2:
> 		default:
> 		{
1560a1618,1620
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
38a40
> #include	"StrUtils.h"
51a54
> #include	"IPUI.h"
94a98
> 	memset( m_TempHostName, 0x00, sizeof( m_TempHostName ) );
116a121,342
> // CIPEndpoint::ShowSettingsDialog - show dialog for settings
> //
> // Entry:		Pointer to thread pool
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CIPEndpoint::ShowSettingsDialog( CThreadPool *const pThreadPool )
> {
> 	HRESULT	hr;
> 
> 
> 	DNASSERT( pThreadPool != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	AddRef();
> 	hr = pThreadPool->SpawnDialogThread( DisplayIPHostNameSettingsDialog, &m_hActiveSettingsDialog, this );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to start IP hostname dialog!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:	
> 	DecRef();
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::SettingsDialogComplete - dialog has completed
> //
> // Entry:		Error code for dialog
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::SettingsDialogComplete( const HRESULT hDialogResult )
> {
> 	HRESULT					hr;
> 	HRESULT					hTempResult;
> 	IDirectPlay8Address		*pBaseAddress;
> 	DWORD					dwTotalAddressBufferSize;
> 	char					*pTempAddressString;
> 	WCHAR					WCharHostName[ sizeof( m_TempHostName ) + 1 ];
> 	DWORD					dwWCharHostNameSize;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = hDialogResult;
> 	pBaseAddress = NULL;
> 
> 	pTempAddressString = NULL;
> 
> 	//
> 	// since the dialog is exiting, clear our handle to the dialog
> 	//
> 	m_hActiveSettingsDialog = NULL;
> 
> 	//
> 	// dialog failed, fail the user's command
> 	//
> 	if ( hr != DPN_OK )
> 	{
> 		if ( hr != DPNERR_USERCANCEL)
> 		{
> 			DPF( 0, "Failing endpoint hostname dialog!" );
> 			DisplayErrorCode( 0, hr );
> 
> 		}
> 
> 		goto Failure;
> 	}
> 
> 	//
> 	// The dialog completed OK, rebuild remote address and complete command
> 	//
> 
> 	//
> 	// get the base DNADDRESS
> 	//
> 	pBaseAddress = m_pRemoteMachineAddress->DP8AddressFromSocketAddress();
> 	if ( pBaseAddress == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "SettingsDialogComplete: Failed to get base address when completing IP hostname dialog!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// Add the new 'HOSTNAME' parameter to the address.  If the hostname is blank
> 	// and this is an enum, copy the broadcast hostname.
> 	//
> 	if ( ( m_TempHostName[ 0 ] == '\0' ) && ( m_EndpointType == ENDPOINT_TYPE_ENUM ) )
> 	{
> 		DNASSERT( sizeof( WCharHostName ) >= g_dwIPBroadcastAddressSize );
> 		memcpy( WCharHostName, g_IPBroadcastAddress, g_dwIPBroadcastAddressSize );
> 		dwWCharHostNameSize = g_dwIPBroadcastAddressSize;
> 	}
> 	else
> 	{
> 		dwWCharHostNameSize = LENGTHOF( WCharHostName );
> 		hr = STR_AnsiToWide( m_TempHostName, -1, WCharHostName, &dwWCharHostNameSize );
> 		DNASSERT( hr == DPN_OK );
> 		dwWCharHostNameSize *= sizeof( WCHAR );
> 	}
> 
> 	hr = IDirectPlay8Address_AddComponent( pBaseAddress, DPNA_KEY_HOSTNAME, WCharHostName, dwWCharHostNameSize, DPNA_DATATYPE_STRING );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "SettingsDialogComplete: Failed to add hostname to address!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// set the address
> 	//
> 	hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pBaseAddress, SP_ADDRESS_TYPE_HOST );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to rebuild DNADDRESS when completing IP hostname dialog!" );
> 		DNASSERT( FALSE );
> 		goto Failure;
> 	}
> 
> 	//
> 	// the remote machine address has been adjusted, finish the command
> 	//
> 	switch ( m_EndpointType )
> 	{
> 		case ENDPOINT_TYPE_ENUM:
> 		{
> 			hr = CompleteEnumQuery();
> 			if ( hr != DPN_OK )
> 			{
> 				DPF( 0, "Problem completing EnumQuery after asking user for hostname!" );
> 				DisplayDNError( 0, hr );
> 			}
> 
> 			break;
> 		}
> 
> 		case ENDPOINT_TYPE_CONNECT:
> 		{
> 			hr = CompleteConnect();
> 			if ( hr != DPN_OK )
> 			{
> 				DPF( 0, "Problem completing Connect after asking user for hostname!" );
> 				DisplayDNError( 0, hr );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			hr = DPNERR_GENERIC;
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pBaseAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DNASSERT( pTempAddressString == NULL );
> 	if ( pBaseAddress != NULL )
> 	{
> 		DNFree( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DecRef();
> 
> 	return;
> 
> Failure:
> 	//
> 	// close this endpoint
> 	//
> 	Close( hr );
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::StopSettingsDialog - stop an active settings dialog
> //
> // Entry:		Handle of dialog to close
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::StopSettingsDialog( const HWND hDlg)
> {
> 	StopIPHostNameSettingsDialog( hDlg );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
216a443
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
262,263d488
< 
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
22a23,24
> #define	TEMP_HOSTNAME_LENGTH	100
> 
52a55,67
> 		// UI functions
> 		//
> 		HRESULT		ShowSettingsDialog( CThreadPool *const pThreadPool );
> 		void		SettingsDialogComplete( const HRESULT hr );
> 		void		StopSettingsDialog( const HWND hDlg );
> 		void		SetTempHostName( const char *const pHostName, const UINT_PTR uHostNameLength )
> 		{
> 			DNASSERT( pHostName[ uHostNameLength ] == '\0' );
> 			DNASSERT( ( uHostNameLength + 1 ) <= LENGTHOF( m_TempHostName ) );
> 			memcpy( m_TempHostName, pHostName, ( uHostNameLength + 1 ) );
> 		}
> 
> 		//
69a85
> 		char		m_TempHostName[ TEMP_HOSTNAME_LENGTH ];
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
50a52
> #include	"IPXAddress.h"
54a57
> #include	"IPXEndpt.h"
82a86
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
84a89
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
174a180,186
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
193a206,222
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
> 	
318a348,354
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
328a365,370
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
399a442
> 
428a472,515
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	CIPXAddress	*pReturnAddress;
> 
> 	
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	
> 	DNEnterCriticalSection( &g_AddressLock );
> 	pReturnAddress = g_pIPXAddressPool->Get();
> 	DNLeaveCriticalSection( &g_AddressLock );
> 
> 	return	pReturnAddress;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	
> 	DNEnterCriticalSection( &g_AddressLock );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> 	DNLeaveCriticalSection( &g_AddressLock );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
438a526,541
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
59a62,63
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
61a66
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\rsip.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40a41
> #include	"Registry.h"
512a514,517
> 
> 		hr = GetGatewayFromRegistry( reinterpret_cast<BYTE*>( gwipaddr ), sizeof( gwipaddr ) );
> 
> 		if(hr != DPN_OK){
514a520,522
> 		}
> 
> 		DPF(0,"Found suggested RSIP gateway in registry %s, running on Win95?\n",gwipaddr);
651d658
<         WCHAR wszIPHLPAPI[] = L"IPHLPAPI.DLL";
687c694
< 	hIpHlpApi = LoadLibrary(wszIPHLPAPI);
---
> 	hIpHlpApi = LoadLibrary("IPHLPAPI.DLL");
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
258a260,267
> 	
> 	//
> 	// Winsock 2 functionality always exists on WinNT.  If we're on Win9x, we can
> 	// only use Winsock2 interfaces for TCP.
> 	//
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) ||
> 		 ( ( LOWORD( GetWinsockVersion() ) >= 2 ) && ( m_pSPData->GetType() == TYPE_IP ) ) )
> 	{
259a269,273
> 	}
> 	else
> 	{
> 		m_pSendFunction = Winsock1Send;
> 	}
405a420,431
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( ( LOWORD( GetWinsockVersion() ) == 1 ) ||
> 			 ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_pSPData->GetType() == TYPE_IPX ) ) )
> 		{
> 			m_pSPData->GetThreadPool()->RemoveSocketPort( this );
> 		}
> 
836a863,875
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
838a878,974
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ),	// pointer to receive buffer
> 								pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize,		// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();
> 
> Exit:
> 	return;
> }
839a976,978
> 
> 
> //**********************************************************************
840a980,1125
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
867,868c1152,1153
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
874a1160,1168
> 	// lock the 'pending operation' list over the call to Winsock to prevent the
> 	// operation from being completed while it's being set up.
> 	//
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->LockWriteData();
> 	}
> 	
> 	//
880a1175,1177
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
892a1190,1194
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->UnlockWriteData();
> 	}
> 
933a1236,1238
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1007c1312,1313
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1016a1323,1331
> 	// lock the 'pending operation' list over the call to Winsock to prevent the
> 	// operation from being completed while it's being set up.
> 	//
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->LockReadData();
> 	}
> 
> 	//
1022a1338,1340
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1033a1352,1357
> 	
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->UnlockReadData();
> 	}
> 
1080a1405,1406
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1114a1441,1442
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1159a1488,1489
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1730a2061,2067
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1775a2113,2176
> 			break;
> 		}
> 
> 		//
> 		// Win9x.
> 		// If this is not an IPX socket and Winsock 2 (or greater) is available,
> 		// call the Winsock 2 read function.  If this is IPX or we're stuck with
> 		// Winsock 1, inform the thread pool as such.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 
> 			if ( ( LOWORD( GetWinsockVersion() ) >= 2 ) &&
> 				 ( m_pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// we're using Winsock2, call for two outstanding reads per socket.
> 				//
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #1 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #2 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 			}
> 			else
> 			{
> 				DNASSERT( m_pSPData != NULL );
> 				hr = m_pSPData->GetThreadPool()->AddSocketPort( this );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Failed to add to active socket list!" );
> 					DisplayDNError( 0, hr );
> 					goto Failure;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
1975d2375
< 
2402a2803,2960
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
> 
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			goto Exit;
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = pReadData->m_dwOverlappedBytesReceived;
> 					pReadData->m_dwOverlappedBytesReceived = 0;
> 					ProcessReceivedData( pReadData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();	
> 	DecRef();
> 
> 	return;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
239a240
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
245a247,249
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
288a293
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,3c1,5
< TARGETNAME=dpnwsock
< TARGETTYPE=DYNLINK
< TARGETPATH=obj
---
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
5c7,17
< !ifdef _BUILD_FOR_WIN2000
---
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
> TARGETNAME=dpnwsock
> DLLDEF=..\wsocksp.def
7,13d18
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
15c20,26
< INCLUDES=..\..\;..\..\..\inc;..\..\..\common;..\..\..\..\dnaddress
---
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
17c28,29
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> TARGETPATH=obj
> TARGETTYPE=DYNLINK
19c31,35
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
21,22c37,58
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
>            ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
> 
> #
> # If a debug mode is selected, make sure we include the defines to make the
> # logging code operate.
> #
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
25c61,71
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
27c73,77
< DLLDEF=..\wsocksp.def
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28a79,88
> INCLUDES=$(DXROOT)\inc;..\..\..\inc;..\..\..\common;..\..\..\dnaddress
> 
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
32a93
> 	 ..\DWinsock.cpp \
36a98,100
> 	 ..\IPUI.cpp \
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
39a104
>          ..\Registry.cpp \
48a114,116
> #
> # Next specify options for the compiler.
> #
49a118,120
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNWSock_EXPORTS /DCINTERFACE
> 
> USER_C_FLAGS=-nologo -W3
52,72c123,124
< TARGETLIBS= \
<            ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
<            $(BASEDIR)\public\sdk\lib\*\dpnaddr.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<            $(BASEDIR)\public\sdk\lib\*\winsockx.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
104c104
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
122c122,123
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
158c159,160
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
241a244
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
242a246
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
245c249
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
252c256
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
279a284
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
48a50
> #include	"IPXAddress.h"
54a57
> #include	"IPXEndpt.h"
224a228,257
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
> 			DPF( 8, "WinNT detected!" );
> 			break;
> 		}
> 
> 		//
> 		// Windows 95, 98
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DPF( 8, "Win9x detected!" );
> 			break;
> 		}
> 
> 		// other version (unsupported!)
> //		case VER_PLATFORM_WIN32_CE:
> 		case VER_PLATFORM_WIN32s:
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
578a612,617
> 		case TYPE_IPX:
> 		{
> 			pReturn = CreateIPXEndpoint( &EndpointPoolContext );
> 			break;
> 		}
> 
747a787,792
> 		case TYPE_IPX:
> 		{
> 			pReturn = CreateIPXAddress();
> 			break;
> 		}
> 
778a824,829
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
121a123,145
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
128a153,163
> //
> // structure passed to dialog threads
> //
> typedef	struct	_DIALOG_THREAD_PARAM
> {
> 	DIALOG_FUNCTION	*pDialogFunction;
> 	HWND			*phDialog;
> 	void			*pContext;
> 	CThreadPool		*pThisThreadPool;
> } DIALOG_THREAD_PARAM;
> 
233c268,275
< 	DEBUG_ONLY( 
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
235c277,278
< 	)
---
> 						break;
> 					}
236a280,287
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
243c294,301
< 	DEBUG_ONLY(
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
245c303,304
< 	)
---
> 						break;
> 					}
246a306,313
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
280a348,354
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
337a412,416
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( DNGetOSType() )
> 	{
340a420,421
> 		case VER_PLATFORM_WIN32_NT:
> 		{
346a428,454
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
375a484,485
> 	SYSTEM_INFO		SystemInfo;
> 	UINT_PTR		uDesiredThreads;
382a493,497
> 	//
> 	// get machine information
> 	//
> 	memset( &SystemInfo, 0x00, sizeof( SystemInfo ) );
> 	GetSystemInfo( &SystemInfo );
402a518,524
> 	uDesiredThreads = ( SystemInfo.dwNumberOfProcessors * 2 ) + 2;
> 	DNASSERT( uDesiredThreads != 0 );
> 	while ( uDesiredThreads > 0 )
> 	{
> 		uDesiredThreads--;
> 		StartNTCompletionThread();
> 	}
404,408d525
<     StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 
433a551,786
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT				hr;
> 	HANDLE				hPrimaryThread;
> 	HANDLE				hSecondaryThread;
> 	DWORD				dwPrimaryThreadID;
> 	DWORD				dwSecondaryThreadID;
> 	WIN9X_THREAD_DATA	*pPrimaryThreadInput;
> 	WIN9X_THREAD_DATA	*pSecondaryThreadInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	hPrimaryThread = NULL;
> 	hSecondaryThread = NULL;
> 	pPrimaryThreadInput = NULL;
> 	pSecondaryThreadInput = NULL;
> 
> 	//
> 	// Win9x requires completion events for Winsock2.  Always allocate the
> 	// events even though the they might not be used.
> 	//
> 	DNASSERT( m_hWinsock2SendComplete == NULL );
> 	m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 										   TRUE,	// manual reset
> 										   FALSE,	// start unsignalled
> 										   NULL		// pointer to name (none)
> 										   );
> 	if ( m_hWinsock2SendComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Send!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 	m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 											  TRUE,		// manual reset
> 											  FALSE,	// start unsignalled
> 											  NULL		// pointer to name (none)
> 											  );
> 	if ( m_hWinsock2ReceiveComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Receive!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	//
> 	// create parameters to worker threads
> 	//
> 	pPrimaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pPrimaryThreadInput ) ) );
> 	if ( pPrimaryThreadInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for primary Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	pSecondaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pSecondaryThreadInput ) ) );
> 	if ( pSecondaryThreadInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for secondary Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pPrimaryThreadInput, 0x00, sizeof( *pPrimaryThreadInput ) );
> 	pPrimaryThreadInput->pThisThreadPool = this;
> 	
> 	DBG_CASSERT( sizeof( *pPrimaryThreadInput ) == sizeof( *pSecondaryThreadInput ) );
> 	memcpy( pSecondaryThreadInput, pPrimaryThreadInput, sizeof( *pSecondaryThreadInput ) );
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	IncrementActiveThreadCount();
> 	
> 	//
> 	// Create one worker thread and boost its priority.  If the primary thread
> 	// can be created and boosted, create a secondary thread.  Do not create a
> 	// secondary thread if the primary could not be boosted because the system
> 	// is probably low on resources.
> 	//
> 	hPrimaryThread = CreateThread( NULL,					// pointer to security attributes (none)
> 								   0,						// stack size (default)
> 								   PrimaryWin9xThread,		// pointer to thread function
> 								   pPrimaryThreadInput,		// pointer to input parameter
> 								   0,						// let it run
> 								   &dwPrimaryThreadID		// pointer to destination of thread ID
> 								   );
> 	if ( hPrimaryThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		DecrementActiveThreadCount();
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		goto Failure;
> 	}
> 	pPrimaryThreadInput = NULL;
> 
> 
> 	DPF( 8, "Created primary Win9x thread: 0x%x\tTotal Thread Count: %d", dwPrimaryThreadID, ThreadCount() );
> 	DNASSERT( hPrimaryThread != NULL );
> 	if ( SetThreadPriority( hPrimaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of primary Win9x read thread!  Not starting secondary thread" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 	else
> 	{
> 		//
> 		// primary thread was created and boosted, create a secondary thread
> 		//
> 		IncrementActiveThreadCount();
> 		hSecondaryThread = CreateThread( NULL,						// pointer to security attributes (none)
> 										 0,							// stack size (default)
> 										 SecondaryWin9xThread,		// pointer to thread function
> 										 pSecondaryThreadInput,		// pointer to input parameter
> 										 0,							// let it run
> 										 &dwSecondaryThreadID		// pointer to destination of thread ID
> 										 );
> 		if ( hSecondaryThread != NULL )
> 		{
> 			DPF( 8, "Created secondary Win9x thread: 0x%x\tTotal Thread Count: %d", dwSecondaryThreadID, ThreadCount() );
> 			
> 			pSecondaryThreadInput = NULL;
> 			DNASSERT( hSecondaryThread != NULL );
> 			if ( SetThreadPriority( hSecondaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to boost priority of secondary Win9x thread!" );
> 				DisplayErrorCode( 0, dwError );
> 			}
> 		}
> 		else
> 		{
> 			//
> 			// thread startup failed, decrement active thread count
> 			//
> 			DecrementActiveThreadCount();
> 		}
> 	}
> 
> 
> Exit:
> 	if ( pPrimaryThreadInput != NULL )
> 	{
> 		DNFree( pPrimaryThreadInput );
> 		pPrimaryThreadInput = NULL;
> 	}
> 
> 	if ( pSecondaryThreadInput != NULL )
> 	{
> 		DNFree( pSecondaryThreadInput );
> 		pSecondaryThreadInput = NULL;
> 	}
> 
> 	if ( hPrimaryThread != NULL )
> 	{
> 		if ( CloseHandle( hPrimaryThread ) == FALSE )
> 		{
> 			DWORD	dwError;
> 
> 
> 			dwError = GetLastError();
> 			DPF( 0, "Problem closing Win9x thread hanle!" );
> 			DisplayErrorCode( 0, dwError );
> 		}
> 
> 		hPrimaryThread = NULL;
> 	}
> 
> 	if ( hSecondaryThread != NULL )
> 	{
> 		if ( CloseHandle( hSecondaryThread ) == FALSE )
> 		{
> 			DWORD	dwError;
> 
> 
> 			dwError = GetLastError();
> 			DPF( 0, "Problem closing Win9x thread hanle!" );
> 			DisplayErrorCode( 0, dwError );
> 		}
> 
> 		hSecondaryThread = NULL;
> 	}
> 
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
532a886,887
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
553a909
> 	}
629a986,989
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
647a1008,1009
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
792a1155
> 	m_IPXReadIODataPool.Deinitialize();
840d1202
< 			
844a1207,1215
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			break;
> 		}
> 
> 		//
922a1294,1302
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1177a1558,1559
> 	switch ( DNGetOSType() )
> 	{
1180a1563,1564
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1197a1582,1610
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( m_JobQueue.SignalPendingJob() == FALSE )
> 			{
> 				hr = DPNERR_OUTOFMEMORY;
> 				DPF( 0, "Failed to signal pending job!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1308a1722,1723
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1315a1731
> 	}
1517a1934,2034
> // CThreadPool::SpawnDialogThread - start a secondary thread to display service
> //		provider UI.
> //
> // Entry:		Pointer to dialog function
> //				Pointer destination for copy of dialog handle
> //				Dialog context
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext )
> {
> 	HRESULT	hr;
> 	HANDLE	hDialogThread;
> 	DIALOG_THREAD_PARAM		*pThreadParam;
> 	DWORD	dwThreadID;
> 
> 
> 	DNASSERT( pDialogFunction != NULL );
> 	DNASSERT( phDialog != NULL );
> 	DNASSERT( pDialogContext != NULL );		// why would anyone not want a dialog context??
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pThreadParam = NULL;
> 
> 	//
> 	// create and initialize thread param
> 	//
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( DNMalloc( sizeof( *pThreadParam ) ) );
> 	if ( pThreadParam == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for dialog thread!" );
> 		goto Failure;
> 	}
> 
> 	pThreadParam->pDialogFunction = pDialogFunction;
> 	pThreadParam->phDialog = phDialog;
> 	pThreadParam->pContext = pDialogContext;
> 	pThreadParam->pThisThreadPool = this;
> 
> 	//
> 	// assume that a thread will be created
> 	//
> 	IncrementActiveThreadCount();
> 
> 	//
> 	// create thread
> 	//
> 	hDialogThread = CreateThread( NULL,					// pointer to security (none)
> 								  0,					// stack size (default)
> 								  DialogThreadProc,		// thread procedure
> 								  pThreadParam,			// thread param
> 								  0,					// creation flags (none)
> 								  &dwThreadID );		// pointer to thread ID
> 	if ( hDialogThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// decrement active thread count and report error
> 		//
> 		DecrementActiveThreadCount();
> 		
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to start dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		goto Failure;
> 	}
>   								
> 	if ( CloseHandle( hDialogThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing handle from create dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:
> 	if ( pThreadParam != NULL )
> 	{
> 		DNFree( pThreadParam );
> 		pThreadParam = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
1537a2055,2056
> 	switch ( DNGetOSType() )
> 	{
1538a2058,2067
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( NTCompletionThreadCount() == 0 );
> 			break;
> 		}
> 
> 		//
1540a2070,2071
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1542a2074,2075
> 			break;
> 		}
1543a2077,2086
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1572a2116,2117
> 	switch ( DNGetOSType() )
> 	{
1573a2119,2126
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1579a2133,2134
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1619a2175,2187
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1699a2268,2415
> // CThreadPool::AddSocketPort - add a socket to the Win9x watch list
> //
> // Entry:		Pointer to SocketPort
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::AddSocketPort( CSocketPort *const pSocketPort )
> {
> 	HRESULT	hr;
> 	BOOL	fSocketAdded;
> 
> 	
> 	DNASSERT( pSocketPort != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	fSocketAdded = FALSE;
> 
> 	Lock();
> 
> 	//
> 	// We're capped by the number of sockets we can use for Winsock1.  Make
> 	// sure we don't allocate too many sockets.
> 	//
> 	if ( m_uReservedSocketCount == FD_SETSIZE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "There are too many sockets allocated on Winsock1!" );
> 		goto Failure;
> 	}
> 
> 	m_uReservedSocketCount++;
> 	
> 	DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 	m_pSocketPorts[ m_SocketSet.fd_count ] = pSocketPort;
> 	m_SocketSet.fd_array[ m_SocketSet.fd_count ] = pSocketPort->GetSocket();
> 	m_SocketSet.fd_count++;
> 	fSocketAdded = TRUE;
> 
> 	//
> 	// add a reference to note that this socket port is being used by the thread
> 	// pool
> 	//
> 	pSocketPort->AddRef();
> 
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when adding socket port to active list!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> Exit:
> 	Unlock();
> 	
> 	return	hr;
> 
> Failure:
> 	if ( fSocketAdded != FALSE )
> 	{
> 		AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
> 		m_SocketSet.fd_count--;
> 		m_pSocketPorts[ m_SocketSet.fd_count ] = NULL;
> 		m_SocketSet.fd_array[ m_SocketSet.fd_count ] = NULL;
> 		fSocketAdded = FALSE;
> 	}
> 
> 	m_uReservedSocketCount--;
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::RemoveSocketPort - remove a socket from the Win9x watch list
> //
> // Entry:		Pointer to socket port to remove
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::RemoveSocketPort( CSocketPort *const pSocketPort )
> {
> 	UINT_PTR	uIndex;
> 
> 
> 	DNASSERT( pSocketPort != NULL );
> 	
> 	Lock();
> 
> 	uIndex = m_SocketSet.fd_count;
> 	DNASSERT( uIndex != 0 );
> 	while ( uIndex != 0 )
> 	{
> 		uIndex--;
> 
> 		if ( m_pSocketPorts[ uIndex ] == pSocketPort )
> 		{
> 			m_uReservedSocketCount--;
> 			m_SocketSet.fd_count--;
> 
> 			memmove( &m_pSocketPorts[ uIndex ],
> 					 &m_pSocketPorts[ uIndex + 1 ],
> 					 ( sizeof( m_pSocketPorts[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			memmove( &m_SocketSet.fd_array[ uIndex ],
> 					 &m_SocketSet.fd_array[ uIndex + 1 ],
> 					 ( sizeof( m_SocketSet.fd_array[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			//
> 			// clear last entry which is now unused
> 			//
> 			memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) );
> 			memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) );
> 
> 			//
> 			// end the loop
> 			//
> 			uIndex = 0;
> 		}
> 	}
> 
> 	Unlock();
> 	
> 	pSocketPort->DecRef();
> 
> 	//
> 	// It's really not necessary to signal a new job here because there were
> 	// active sockets on the last iteration of the Win9x thread.  That means the
> 	// Win9x thread was in a polling mode to check for sockets and the next time
> 	// through it will notice that there is a missing socket.  By signalling the
> 	// job event we reduce the time needed for the thread to figure out that the
> 	// socket is gone.
> 	//
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when removeing socket port to active list!" );
> 	}
> }
> //**********************************************************************
> 
> 
> 
> //**********************************************************************
> // ------------------------------
1846a2563,3383
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwOverlappedBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				//
> 				// Overlapped results will complete with success and zero bytes
> 				// transferred when the overlapped structure is checked BEFORE
> 				// the operation has really been subnitted.  This is a possibility
> 				// with the current code.  To combat this, check the sent bytes
> 				// for zero (we'll never send zero bytes).
> 				//
> 				if ( pWriteIOData->m_dwOverlappedBytesSent == 0 )
> 				{
> 					goto SkipSendCompletion;
> 				}
> 
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 				pWriteIOData->m_dwOverlappedBytesSent = 0;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					//
> 					// WSAENOTSOCK = the socket has been closed, most likely
> 					// as a result of a command completing or being cancelled.
> 					//
> 					case WSAENOTSOCK:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_USERCANCEL;
> 						break;
> 					}
> 
> 					//
> 					// other error, stop and look
> 					//
> 					default:
> 					{
> 						INT3;
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwOverlappedBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				//
> 				// Overlapped results will complete with success and zero bytes
> 				// transferred when the overlapped structure is checked BEFORE
> 				// the operation has really been subnitted.  This is a possibility
> 				// with the current code.  To combat this, check the received bytes
> 				// for zero (the return when the overlapped request was checked before
> 				// it was sent) and check the return address (it's possible that someone
> 				// really sent zero bytes).
> 				//
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				if ( ( pReadIOData->m_dwOverlappedBytesReceived != 0 ) &&
> 					 ( pReadIOData->m_pSourceSocketAddress->IsUndefinedHostAddress() == FALSE ) )
> 				{
> 					pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 				}
> 				else
> 				{
> 					goto SkipReceiveCompletion;
> 				}
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::PrimaryWin9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::PrimaryWin9xThread( void *pParam )
> {
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 	
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Primary Win9x thread failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> //	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> //	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 	
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 	
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		DWORD	dwWaitReturn;
> 
> 		
> 		//
> 		// Update the job time so we know how long to wait.  We can
> 		// only get here if a socket was just added to the socket list, or
> 		// we've been servicing sockets.
> 		//
> 		DNTimeGet( &CurrentTime );
> 		if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 		{
> 			pThisThreadPool->LockTimerData();
> 			CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																		   &CoreData.NextTimerJobTime );
> 			if ( CoreData.fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 			}
> 			pThisThreadPool->UnlockTimerData();
> 		}
> 
> 		DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 		dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 
> 		//
> 		// Check for Winsock1 sockets.  If there are some around, do a quick poll
> 		// of them to check of I/O before entering the main Winsock2 loop for
> 		// the real timing.
> 		//
> 		pThisThreadPool->Lock();
> 		if ( pSocketSet->fd_count != 0 )
> 		{
> 			pThisThreadPool->Unlock();
> 
> 			pThisThreadPool->CheckWinsock1IO( pSocketSet );
> 			
> 			//
> 			// since there are Winsock1 sockets active, don't spend a lot of
> 			// time waiting for something to happen for Winsock2
> 			//
> 			if ( g_dwSelectTimeSlice < dwMaxWaitTime )
> 			{
> 				dwMaxWaitTime = g_dwSelectTimeSlice;
> 			}
> 		}
> 		else
> 		{
> 			pThisThreadPool->Unlock();
> 		}
> 
> 
> 		//
> 		// Check Winsock2 sockets.
> 		//
> 		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> 												 CoreData.hWaitHandles,					// handles to wait on
> 												 FALSE,									// don't wait for all to be signalled
> 												 dwMaxWaitTime,							// wait timeout
> 												 TRUE									// we're alertable for APCs
> 												 );
> 		switch ( dwWaitReturn )
> 		{
> 			//
> 			// timeout, don't do anything, we'll probably process timer jobs on
> 			// the next loop
> 			//
> 			case WAIT_TIMEOUT:
> 			{
> 				break;
> 			}
> 
> 			//
> 			// New job.  Account for the time spent in the wait.  Don't
> 			// account for time after the job is complete because it's
> 			// possible that the job was an job submission which will want
> 			// to reset the wait time.
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 			{
> 				DPF( 8, "Primary Win9x thread has a pending job!" );
> 				pThisThreadPool->ProcessWin9xJob( &CoreData );
> 				break;
> 			}
> 
> 			//
> 			// SP closing
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 			{
> 				DPF( 8, "Primary Win9x thread exit because SP closing!" );
> 				fLooping = FALSE;
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 send complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending write list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Primary Win9x thread failed to reset Winsock2 send event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nPrimary Win9x thread servicing sends!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingSends();
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 receive complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending read list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Primary Win9x thread failed to reset Winsock2 receive event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nPrimary Win9x thread servicing receives!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingReceives();
> 				break;
> 			}
> 
> 			//
> 			// There are I/O completion routines scheduled on this thread.
> 			// This is not a good thing!
> 			//
> 			case WAIT_IO_COMPLETION:
> 			{
> 				DPF( 1, "WARNING: APC was serviced on the primary Win9x IO service thread!  What is the application doing??" );
> 				break;
> 			}
> 
> 			//
> 			// wait failed
> 			//
> 			case WAIT_FAILED:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Primary Win9x thread wait failed!" );
> 				DisplayDNError( 0, dwError );
> 				break;
> 			}
> 
> 			//
> 			// problem
> 			//
> 			default:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Primary Win9x thread unknown problem in wait!" );
> 				DisplayDNError( 0, dwError );
> 				DNASSERT( FALSE );
> 				break;
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	COM_CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::SecondaryWin9xThread - secondary thread to handle only Win9x
> //		I/O so developers get bit faster with multithreading issues if they're
> //		developing on Win9x.  This thread will only handle Winsock2 based TCP
> //		I/O.  Winsock 1 is not deemed important enough to hack the rest of the
> //		code to work with two threads.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::SecondaryWin9xThread( void *pParam )
> {
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 
> 	
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Secondary Win9x thread failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 	
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 	
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		DWORD	dwWaitReturn;
> 
> 		
> 		//
> 		// Check Winsock2 sockets.
> 		//
> 		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> 												 CoreData.hWaitHandles,					// handles to wait on
> 												 FALSE,									// don't wait for all to be signalled
> 												 INFINITE,								// wait timeout (forever)
> 												 TRUE									// we're alertable for APCs
> 												 );
> 		switch ( dwWaitReturn )
> 		{
> 			//
> 			// timeout, shouldn't ever be here!!
> 			//
> 			case WAIT_TIMEOUT:
> 			{
> 				INT3;
> 				break;
> 			}
> 
> 			//
> 			// New job.  This is the secondary thread and is only used to handle
> 			// Winsock2 I/O.  Ignore this event and sleep to cause the proper
> 			// work thread to handle the event.
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 			{
> 				DPF( 8, "Secondary Win9x thread sleeping on job notification!" );
> 				SleepEx( 0, TRUE );
> 				break;
> 			}
> 
> 			//
> 			// SP closing
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 			{
> 				DPF( 8, "Secondary Win9x thread exit because SP closing!" );
> 				fLooping = FALSE;
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 send complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending write list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Secondary Win9x thread failed to reset Winsock2 send event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nSecondary Win9x thread servicing sends!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingSends();
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 receive complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending read list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Secondary Win9x thead failed to reset Winsock2 receive event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nSecondary Win9x thread servicing receives!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingReceives();
> 				break;
> 			}
> 
> 			//
> 			// There are I/O completion routines scheduled on this thread.
> 			// This is not a good thing!
> 			//
> 			case WAIT_IO_COMPLETION:
> 			{
> 				DPF( 1, "WARNING: APC was serviced on the secondary Win9x IO service thread!  What is the application doing??" );
> 				break;
> 			}
> 
> 			//
> 			// wait failed
> 			//
> 			case WAIT_FAILED:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Secondary Win9x thread wait failed!" );
> 				DisplayDNError( 0, dwError );
> 				break;
> 			}
> 
> 			//
> 			// problem
> 			//
> 			default:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Secondary Win9x thread unknown problem in wait!" );
> 				DisplayDNError( 0, dwError );
> 				DNASSERT( FALSE );
> 				break;
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	COM_CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2190a3728,4085
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::DialogThreadProc - thread proc for spawning dialogs
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> // ------------------------------
> DWORD WINAPI	CThreadPool::DialogThreadProc( void *pParam )
> {
> 	const DIALOG_THREAD_PARAM	*pThreadParam;
> 
> 
> 	//
> 	// Initialize COM.  If this fails, we'll have problems later.
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
> 	DNASSERT( pParam != NULL );
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( pParam );
> 	
> 	pThreadParam->pDialogFunction( pThreadParam->phDialog, pThreadParam->pContext );
> 
> 	pThreadParam->pThisThreadPool->DecrementActiveThreadCount();
> 	DNFree( pParam );
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// Remove and process a single job from the list.  If there is no job, skip
> 	// to the end of the function.
> 	//
> 	pJobInfo = GetWorkItem();
> 
> 	if ( pJobInfo == NULL )
> 	{
> 		goto Exit;
> 	}
> 
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> 
> Exit:
> 	return;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CheckWinsock1IO - check the IO status for Winsock1 sockets
> //
> // Entry:		Pointer to sockets to watch
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CheckWinsock1IO( const FD_SET *const pWinsock1Sockets )
> {
> static	const TIMEVAL	SelectNoTime = { 0 };
> 	INT			iSelectReturn;
> 	FD_SET		ReadSocketSet;
> 	FD_SET		WriteSocketSet;
> 	FD_SET		ErrorSocketSet;
> 
> 
> 	//
> 	// Make a local copy of all of the sockets.  This isn't totally
> 	// efficient, but it works.  Multiplying by active socket count will
> 	// spend half the time in the integer multiply.
> 	//
> 	Lock();
> 	memcpy( &ReadSocketSet, pWinsock1Sockets, sizeof( ReadSocketSet ) );
> 	memcpy( &WriteSocketSet, pWinsock1Sockets, sizeof( WriteSocketSet ) );
> 	memcpy( &ErrorSocketSet, pWinsock1Sockets, sizeof( ErrorSocketSet ) );
> 	Unlock();
> 
> 	//
> 	// Don't check write sockets here because it's very likely that they're ready
> 	// for service but have no outgoing data and will thrash
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  &ReadSocketSet,	// sockets to check for read
> 							  NULL,				// sockets to check for write (none)
> 							  &ErrorSocketSet,	// sockets to check for error
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// select got pissed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// WSAENOTSOCK = This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// WSAEINTR = this operation was interrupted
> 				//
> 				case WSAEINTR:
> 				{
> 					DPF( 1, "Winsock1 reporting interrupted operation when selecting read or error sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting read or error sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing read service and error service.
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 			ServiceWinsock1Sockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Since writes are likely to be ready, check for them separately
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  NULL,				// sockets to check for read (don't check reads)
> 							  &WriteSocketSet,	// sockets to check for write
> 							  NULL,				// sockets to check for error (don't check errors)
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout, no write sockets are ready for service
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// select failed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// this socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting write sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing write service
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 			break;
> 		}
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ServiceWinsock1Sockets - service requests on Winsock1 sockets ports
> //
> // Entry:		Pointer to set of sockets
> //				Pointer to service function
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction )
> {
> 	UINT_PTR	uWaitingSocketCount;
> 	UINT_PTR	uSocketPortCount;
> 	CSocketPort	*pSocketPorts[ FD_SETSIZE ];
> 
> 
> 	uSocketPortCount = 0;
> 	uWaitingSocketCount = pSocketSet->fd_count;
> 	
> 	Lock();
> 	while ( uWaitingSocketCount > 0 )
> 	{
> 		UINT_PTR	uIdx;
> 
> 
> 		uWaitingSocketCount--;
> 		uIdx = m_SocketSet.fd_count;
> 		while ( uIdx != 0 )
> 		{
> 			uIdx--;
> 			if ( pSocketSet->fd_array[ uWaitingSocketCount ] == m_SocketSet.fd_array[ uIdx ] )
> 			{
> 				//
> 				// this socket is still available, add a reference to the socket
> 				// port and keep it around to be processed outside of the lock
> 				//
> 				pSocketPorts[ uSocketPortCount ] = m_pSocketPorts[ uIdx ];
> 				pSocketPorts[ uSocketPortCount ]->AddRef();
> 				uSocketPortCount++;
> 				uIdx = 0;
> 			}
> 		}
> 	}
> 	Unlock();
> 
> 	while ( uSocketPortCount != 0 )
> 	{
> 		uSocketPortCount--;
> 		
> 		//
> 		// call the service function and remove the reference
> 		//
> 		(pSocketPorts[ uSocketPortCount ]->*pServiceFunction)();
> 		pSocketPorts[ uSocketPortCount ]->DecRef();
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
65a67
> typedef	void	DIALOG_FUNCTION( HWND *const phDialog, void *const pDialogContext );
102c104,105
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
148a152
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
153a158
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
160a166,168
> 		HRESULT	AddSocketPort( CSocketPort *const pSocketPort );
> 		void	RemoveSocketPort( CSocketPort *const pSocketPort );
> 
171a180,182
> 		HRESULT	SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext );
> 
> 		
223a235
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
282a295
> 		HRESULT	Win9xInit( void );
292a306,307
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
293a309,310
> 		static	DWORD WINAPI	PrimaryWin9xThread( void *pParam );
> 		static	DWORD WINAPI	SecondaryWin9xThread( void *pParam );
295a313
> 		static	DWORD WINAPI	DialogThreadProc( void *pParam );
300a319,322
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
> 
> 		void	CheckWinsock1IO( const FD_SET *const pWinsock1Sockets );
> 		void	ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
13a14,15
> #include <WSIPX.h>
> 
39a42
> #include	"Creg.h"
40a44,47
> #include	"strutils.h"
> 
> #include	"resource.h"
> 
50a58,66
> #define DN_REG_LOCAL_SP_ROOT				L"Software\\Microsoft\\DirectPlay8"
> #define DN_REG_LOCAL_SP_SUB					L"\\Service Providers"
> #define DN_REG_LOCAL_SP_SUBKEY				DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB
> #define DN_REG_LOCAL_WSOCK_IPX_ROOT			L"\\DPNSPWinsockIPX"
> #define DN_REG_LOCAL_WSOCK_TCPIP_ROOT		L"\\DPNSPWinsockTCP"
> #define	DN_REG_KEYNAME_ALL_APPLICATIONS		L"All Applications"
> #define	DN_REG_KEYNAME_FRIENDLY_NAME		L"Friendly Name"
> #define DN_REG_KEYNAME_GUID					L"GUID"
> 
73c89,118
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
> 	DNSP_QueryInterface,
> 	DNSP_AddRef,
> 	DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Close,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
134a180,236
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to pointer to SP interface
> //				Pointer to pointer to associated SP data
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP, CSPData **const ppSPData )
> {
> 	HRESULT 	hr;
> 	CSPData		*pSPData;
> 
> 
> 	DNASSERT( ppiDNSP != NULL );
> 	DNASSERT( ppSPData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pSPData = NULL;
> 	*ppiDNSP = NULL;
> 	*ppSPData = NULL;
> 
> 	//
> 	// create main data class
> 	//
> 	hr = CreateSPData( &pSPData, &CLSID_DP8SP_IPX, TYPE_IPX, &ipxInterface );
> 	if ( hr != DPN_OK )
> 	{
> 		DNASSERT( pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( pSPData != NULL );
> 	*ppiDNSP = pSPData->COMInterface();
> 	*ppSPData = pSPData;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( pSPData != NULL )
> 	{
> 		pSPData->DecRef();
> 		pSPData = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
221a324,326
> 	//
> 	// we can either create an IPX instance or an IP instance
> 	//
227a333,336
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP, &pSPData );
> 	}
268c377
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return ( IsEqualCLSID( rclsid, CLSID_DP8SP_TCPIP ) || IsEqualCLSID( rclsid, CLSID_DP8SP_IPX ) );
359a469,719
> #define MAX_RESOURCE_STRING_LENGTH		_MAX_PATH
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "CDPVACMI::LoadAndAllocString"
> HRESULT LoadAndAllocString( UINT uiResourceID, wchar_t **lpswzString )
> {
> 	int length;
> 	HRESULT hr;
> 
> 	if( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
> 		wchar_t wszTmpBuffer[MAX_RESOURCE_STRING_LENGTH];	
> 		
> 		length = LoadStringW( g_hDLLInstance, uiResourceID, wszTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
> 
> 		if( length == 0 )
> 		{
> 			hr = GetLastError();		
> 			
> 			DPF( 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
> 			*lpswzString = NULL;
> 
> 			return hr;
> 		}
> 		else
> 		{
> 			*lpswzString = new wchar_t[length+1];
> 
> 			if( *lpswzString == NULL )
> 			{
> 				DPF( 0, "Alloc failure" );
> 				return DPNERR_OUTOFMEMORY;
> 			}
> 
> 			wcscpy( *lpswzString, wszTmpBuffer );
> 
> 			return DPN_OK;
> 		}
> 	}
> 	else
> 	{
> 		char szTmpBuffer[MAX_RESOURCE_STRING_LENGTH];
> 		
> 		length = LoadStringA( g_hDLLInstance, uiResourceID, szTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
> 
> 		if( length == 0 )
> 		{
> 			hr = GetLastError();		
> 			
> 			DPF( 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
> 			*lpswzString = NULL;
> 
> 			return hr;
> 		}
> 		else
> 		{
> 			*lpswzString = new wchar_t[length+1];
> 
> 			if( *lpswzString == NULL )
> 			{
> 				DPF( 0, "Alloc failure" );
> 				return DPNERR_OUTOFMEMORY;
> 			}
> 
> 			if( STR_jkAnsiToWide( *lpswzString, szTmpBuffer, length+1 ) == 0 )
> 			{
> 				hr = GetLastError();
> 				
> 				DPF( 0, "Unable to upconvert from ansi to unicode hr=0x%x", hr );
> 				return hr;
> 			}
> 
> 			return DPN_OK;
> 		}
> 		
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "RegisterDefaultSettings"
> //
> // RegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT RegisterDefaultSettings()
> {
> 	CRegistry creg;
> 	WCHAR *wszFriendlyName = NULL;
> 	HRESULT hr;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB DN_REG_LOCAL_WSOCK_IPX_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create IPX sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 
> 	creg.WriteString( DN_REG_KEYNAME_ALL_APPLICATIONS, L"Y" );
> 
> 	hr = LoadAndAllocString( IDS_FRIENDLYNAME_IPX, &wszFriendlyName );
> 
> 	if( FAILED( hr ) )
> 	{
> 		DPF( 0, "Could not load IPX name hr=0x%x", hr );
> 		return hr;
> 	}
> 
> 	// Load from resource file
> 	creg.WriteString( DN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );
> 
> 	delete [] wszFriendlyName;
> 
> 	creg.WriteGUID( DN_REG_KEYNAME_GUID, CLSID_DP8SP_IPX );
> 
> 	creg.Close();
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB DN_REG_LOCAL_WSOCK_TCPIP_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create TCPIP sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 
> 	creg.WriteString( DN_REG_KEYNAME_ALL_APPLICATIONS, L"Y" );
> 
> 	hr = LoadAndAllocString( IDS_FRIENDLYNAME_TCPIP, &wszFriendlyName );
> 
> 	if( FAILED( hr ) )
> 	{
> 		DPF( 0, "Could not load IPX name hr=0x%x", hr );
> 		return hr;
> 	}
> 
> 	// Load from resource file
> 	creg.WriteString( DN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );
> 
> 	delete [] wszFriendlyName;
> 
> 	creg.WriteGUID( DN_REG_KEYNAME_GUID, CLSID_DP8SP_TCPIP );
> 
> 	creg.Close();
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "UnRegisterDefaultSettings"
> //
> // UnRegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT UnRegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot remove app, does not exist" );
> 	}
> 	else
> 	{
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_WSOCK_IPX_ROOT)[1] ) )
> 		{
> 			DPFERR( "Cannot remove IPX sub-key, could have elements" );
> 		}
> 
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_WSOCK_TCPIP_ROOT)[1] ) )
> 		{
> 			DPFERR( "Cannot remove TCPIP sub-key, could have elements" );
> 		}
> 
> 	}
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8SPWSock.IPX.1", L"DirectPlay8 WSock IPX Provider Object", 
> 							  L"dpnwsock.dll", CLSID_DP8SP_IPX, L"DirectPlay8SPWSock.IPX") )
> 	{
> 		DPFERR( "Could not register dp8 IPX object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8SPWSock.TCPIP.1", L"DirectPlay8 WSock TCPIP Provider Object", 
> 							  L"dpnwsock.dll", CLSID_DP8SP_TCPIP, L"DirectPlay8SPWSock.TCPIP") )
> 	{
> 		DPFERR( "Could not register dp8 IP object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = RegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Could not register default settings hr = 0x%x", hr );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DP8SP_IPX) )
> 	{
> 		DPF( 0, "Failed to unregister IPX object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DP8SP_TCPIP) )
> 	{
> 		DPF( 0, "Failed to unregister IP object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = UnRegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Failed to remove default settings hr=0x%x", hr );
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
22a24
> #include	"DWinsock.h"
50,53d51
< // provides us winsock1/2 support
< #include "dwnsock1.inc"
< #include "dwnsock2.inc"
< 
80a79,80
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
> 
105a106
> 	INT		iVersion;
131c132
< 	// initialize Winsock
---
> 	// initialize the bindings to Winsock
133,139c134,135
< 	WORD wVersionRequested;
< 	WSADATA wsaData;
< 	int nRet;
< 
< 	wVersionRequested = MAKEWORD(2,2);
< 	nRet = p_WSAStartup(wVersionRequested, &wsaData);
< 	if (nRet || wVersionRequested != wsaData.wVersion)
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
141,143c137,139
< 		DPF( 0, "Problem starting winsock!" );
< 	    fReturn = FALSE;
< 	    goto Failure;
---
> 		DPF( 0, "Problem binding dynamic winsock functions!" );
> 		fReturn = FALSE;
> 		goto Failure;
145d140
< 
147a143,144
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
157c154,162
< 		p_WSACleanup();
---
> 		BOOL	fFreeReturn;
> 
> 
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 		if ( fFreeReturn == FALSE )
> 		{
> 			DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 		}
> 
187a193,195
> 	BOOL	fFreeReturn;
> 
> 
191c199,203
< 	p_WSACleanup();
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 	if ( fFreeReturn == FALSE )
> 	{
> 		DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 	}
198a211,223
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
199a225
> 
285a312
> 	INT_PTR iWinsockVersion;
295a323
> 	iWinsockVersion = GetWinsockVersion();
308c336
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize();
594a623
> 
612c641
< // BUGBUG: [mgere] [xbox] This function takes a char as a parameter.  Must convert this to wchar.
---
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
48a49,50
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22
> #include	<WSIPX.h>
94,95d94
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
165a165,168
>  	switch ( pSPData->GetType() )
> 	{
> 		case TYPE_IP:
> 		{
167a171,186
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			DPF( 9, "Attempting to create IPX datagram socket." );
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
232a252
> 		case TYPE_IPX:
318a339
> 	IDirectPlay8Address		*pSPOnlyAddress;
326c347
< 	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );
---
> 	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );
341a363
> 	pSPOnlyAddress = NULL;
380a403,450
> 		HRESULT	hTempResult;
> 		GUID	SPGuid;
> 
> 
> 		//
> 		// get the SP
> 		//
> 		hTempResult = IDirectPlay8Address_GetSP( pDeviceAddress, &SPGuid );
> 		switch ( hTempResult )
> 		{
> 			//
> 			// no problem
> 			//
> 			case DPN_OK:
> 			{
> 				DNASSERT( hr == DPNERR_PENDING );
> 				break;
> 			}
> 
> 			//
> 			// pass these errors throug
> 			//
> 			case DPNERR_OUTOFMEMORY:
> 			{
> 				hr = hTempResult;
> 				goto Failure;
> 				break;
> 			}
> 
> 			//
> 			// remap other errors to addressing errors
> 			//
> 			default:
> 			{
> 				hr = DPNERR_ADDRESSING;
> 				goto Failure;
> 				break;
> 			}
> 		}
> 
> 		//
> 		// The host address is NULL, if we're using TCPIP and we're not allowed to query,
> 		// use the broadcast address.  If we're on IPX, use the broadcast address.
> 		//
> 		if ( ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
> 		{
382a453,500
> 		}
>         else
>         {
> 			HRESULT	hTempResult;
> 
> 
> 			//
> 			// Need to build address with just the SP guid.  Get it from the
> 			// device address.
> 			//
> 			DNASSERT( pSPOnlyAddress == NULL );
> 			hTempResult = COM_CoCreateInstance( CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>( &pSPOnlyAddress ) );
> 			if ( hTempResult != S_OK )
> 			{
> 				DPF( 0, "Failed to create SP-Only address when non was supplied!" );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			hTempResult = IDirectPlay8Address_SetSP( pSPOnlyAddress, &SPGuid );
> 			switch ( hTempResult )
> 			{
> 				//
> 				// set SP, no problem
> 				//
> 				case DPN_OK:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// failed to set SP, map error to an addressing error
> 				//
> 				default:
> 				{
> 					hr = DPNERR_ADDRESSING;
> 					goto Failure;
> 
> 					break;
> 				}
> 			}
> 
> 			pHostAddress = pSPOnlyAddress;
> 		}
514a633,665
> 			if ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) != 0 ) &&
> 				 ( pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// Copy the connect data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since the dialog is being popped, this command is in progress,
> 				// not pending.
> 				//
> 				DNASSERT( pSPData != NULL );
> 
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				pEndpoint->CopyEnumQueryData( pEnumQueryData );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for enum query!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove our reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
528a680,681
> 			}
> 
607a761,766
> 	if ( pSPOnlyAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pSPOnlyAddress );
> 		pSPOnlyAddress = NULL;
> 	}
> 
779c938
< 	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
---
> 	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
985a1145,1173
> 			if ( ( pConnectData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
> 			{
> 				//
> 				// Copy the connect data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since a dialog is being displayed, the command is in-progress,
> 				// not pending.
> 				//
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				pEndpoint->CopyConnectData( pConnectData );
> 				if ( ( hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() ) ) != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for connect!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove our reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
986a1175,1176
> 			}
> 
1250c1440
< 	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
---
> 	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
1456a1647,1679
> 			if ( ( pListenData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
> 			{
> 				//
> 				// Copy the listen data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since this endpoint is being handed off to another thread,
> 				// make sure it's in the unbound list.  Since a dialog is being
> 				// displayed, the command state is in progress, not pending.
> 				//
> 				DNASSERT( pSPData != NULL );
> 
> 				pEndpoint->CopyListenData( pListenData );
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for listen!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove out reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
1457a1681,1682
> 			}
> 
2424a2650,2661
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2641a2879,2890
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
6a7,8
>   DllRegisterServer PRIVATE
>   DllUnregisterServer PRIVATE
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\06141200.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\comutil.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\comutil.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\dndbg.c	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dndbg.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dneterrors.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\guidutil.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	1ece02cc	6bb05875
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\strutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\strutils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\appdesc.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\client.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\connect.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\migration.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\ntentry.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\peer.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\server.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addbase.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\addparse.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addtcp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpsp8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\backend.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\protocol\connect.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\protocol\enum.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\initialize.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\timer.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\classfac.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock1.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock2.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\rsip.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
-- 86 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\callstack.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\memlog.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\dnmisc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\dpguid.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04241015.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04261045.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05010945.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05021600.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05031030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05081300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05091400.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05111530.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05121300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05151130.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05161345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05221345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05231030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06021030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06121345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06121445.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\lastsync.bat	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\dplegacy.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\dplegacy.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvlib.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvlib.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvrq.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvrq.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpnsvr.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpsvr8.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpsvr8.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\proctbl.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\proctbl.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\inc\dpnsdef.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\inc\dpnsvmsg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\inc\dplobby8.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\classfac.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\comstuff.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dllmain.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dnlobby.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplapp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplapp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplclient.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplclient.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplcommon.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplcommon.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconnect.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconnect.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplmsgq.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplmsgq.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby8int.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplparam.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplparam.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplproc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplproc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplreg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplreg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\globals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\handles.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\handles.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\contextfixedpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\registry.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\registry.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 194 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
3a4
>       lobby \
5c6,7
<       core
---
>       core \
>       dpnsvr 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\comutil.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include "creg.h"
20a22
> #include <stdlib.h>
35c37
<     WCHAR                   wszFileName[_MAX_PATH];
---
>     CHAR                    szFileName[_MAX_PATH];
102c104
<     hr = COM_GetDLLName( clsid, pEntry->wszFileName, &dwSize );
---
>     hr = COM_GetDLLName( clsid, pEntry->szFileName, &dwSize );
110c112
<     pEntry->hDLL = LoadLibraryW( pEntry->wszFileName );
---
>     pEntry->hDLL = LoadLibraryA( pEntry->szFileName );
144c146
< HRESULT COM_GetDLLName( GUID guidCLSID, WCHAR *wszPath, DWORD *pdwSize )
---
> HRESULT COM_GetDLLName( GUID guidCLSID, CHAR *szPath, DWORD *pdwSize )
146,150c148,150
< // BUGBUG: [mgere] [xbox] These com wrapper functions will only be called to
< // retrieve the wsock com object, so I hard coded the dpwsock.dll to always
< // return from this function.
< //
<     WCHAR wszDLL[] = { wchar_t("dpwsock.dll") };
---
>     CRegistry cregRoot;
>     CRegistry cregCLSID;
>     CRegistry cregInProc;
152c152,157
<     wcscpy( wszPath, wszDLL);
---
>     HRESULT hr;
>     BOOL fSuccess;
>     WCHAR *wszTmpPath = NULL;
>     DWORD dwTmpSize = 0;
>     int res;
>     BOOL fDefault;
154c159
<     return S_OK;
---
>     fSuccess = cregRoot.Open( HKEY_CLASSES_ROOT, L"CLSID", FALSE );
155a161,225
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening HKEY_CLASSES_ROOT\\CLSID" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     fSuccess = cregCLSID.Open( cregRoot, &guidCLSID, FALSE );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening specified CLSID" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     fSuccess = cregInProc.Open( cregCLSID, L"InprocServer32", FALSE );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening inprocserver key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     cregCLSID.Close();
>     cregRoot.Close();
> 
>     fSuccess = cregInProc.ReadString( L"", wszTmpPath, pdwSize );
> 
>     if( !*pdwSize )
>     {
>         DPF( 0, "Error opening default key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     wszTmpPath = new WCHAR[*pdwSize];
> 
>     fSuccess = cregInProc.ReadString( L"", wszTmpPath, pdwSize );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening default key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     if( FAILED( hr = STR_jkWideToAnsi(szPath,wszTmpPath, *pdwSize ) ) )
>     {
>         DPF( 0, "Error converting path to DLL to ANSI hr=0x%x", hr );
>         hr = E_FAIL;
>     }
> 
>     delete [] wszTmpPath;
> 
>     return hr;
> 
> COM_GETDLLNAME_ERROR:
> 
>     if( wszTmpPath )
>         delete [] wszTmpPath;
> 
>     return hr;
> 
171a242,245
>     hr = CoCreateInstance( rclsid, pUnkOuter, dwClsContext, riid, ppv );
> 
>     if( hr == CO_E_NOTINITIALIZED )
>     {
193a268,271
> 
>         return hr;
> 
>     }
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\comutil.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18c18
< HRESULT COM_GetDLLName( GUID guidCLSID, WCHAR *szPath, DWORD *pdwSize );
---
> HRESULT COM_GetDLLName( GUID guidCLSID, CHAR *szPath, DWORD *pdwSize );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
29a37,65
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "UNKNOWN_MODULE"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectNet] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNetDebug"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dndbg.c)---()---()---()---()---()---()---()---()---()---()  
.  
.  
30a31
> #include "memlog.h"
36a38,183
> /*******************************************************************************
> 	Debug Logging to VXD.  In order to get this logging, DNET.VXD must be
> 	installed on the system.  This service is only available in the Win9x code
> 	base and can be installed by added the following to the system.ini file
> 	in the 386Enh section
> 
> 	[386Enh]
> 	device=dnet.vxd
> 
> 	This will enable a set of command under the debugger for dumping the
> 	log when broken into the debugger.  The commands can be initiated by
> 	typing .dnet at the ## prompt in the debugger.
> ==============================================================================*/
> /*
> BOOL DeviceIoControl(
> HANDLE hDevice, 			// handle to device of interest
> DWORD dwIoControlCode, 		// control code of operation to perform
> LPVOID lpInBuffer, 			// pointer to buffer to supply input data
> DWORD nInBufferSize, 		// size of input buffer
> LPVOID lpOutBuffer, 		// pointer to buffer to receive output data
> DWORD nOutBufferSize, 		// size of output buffer
> LPDWORD lpBytesReturned, 	// pointer to variable to receive output byte count
> LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
> );
> */
> 
> #define MAX_STRING       240
> #define LOG_SIZE         2000
> #define FIRST_DEBUG_PROC 100
> 
> #define OPEN_DEBUGLOG 	(FIRST_DEBUG_PROC)
> #define WRITE_DEBUGLOG 	(FIRST_DEBUG_PROC+1)
> #define WRITE_STATS     (FIRST_DEBUG_PROC+2)
> #define WSPRINTF		wsprintfA
> 
> typedef struct _LOGENTRY {
> 	CHAR	debuglevel;
> 	CHAR    str[1];
> } LOGENTRY, *PLOGENTRY;
> 
> typedef struct {
> 	UINT	nLogEntries;
> 	UINT    nCharsPerLine;
> } IN_LOGINIT, *PIN_LOGINIT;
> 
> typedef struct {
> 	UINT    hr;
> } OUT_LOGINIT, *POUT_LOGINIT;
> 
> typedef struct {
> 	CHAR	debuglevel;
> 	CHAR    str[1];
> } IN_LOGWRITE, *PIN_LOGWRITE;
> 
> typedef struct {
> 	UINT	hr;
> } OUT_LOGWRITE, *POUT_LOGWRITE;
> 
> 
> HANDLE hLoggingVxd=0;
> HANDLE hLogMutex=0;
> HANDLE hLogFile=0;
> PSHARED_LOG_FILE pLogFile=0;
> 
> /*===========================================================================
> 
> 	Debug Support.
> 
> 	Logging:
> 	========
> 
> 	Debug Logging and playback is designed to operate on both Win9x and
> 	Windows NT (Windows 2000).  On Win9x, a support VXD is used to extend
> 	the kernel debugger.  The VXD (DNET.VXD) is used for both logging and
> 	playback of debug buffers.  In addition to the debug VXD there is also
> 	logging to a shared file.  The shared file logging is played back with
> 	the DNLOG.EXE utility and can be played back on either Windows2000 or
> 	Win9x.
> 
> 	Debug support for dumping structures on Win9x is supported only in the
> 	DNET.VXD component.  Dumping of structures internal to DPLAY can only
> 	be done from the context of a DPLAY thread.  This is because the
> 	addresses are only valid in that context.  Under NT there is (will be)
> 	a debug extension for dumping internal structures.
> 
> 	Debug Logging is controlled by settings in the win.ini file.  Under
> 	the section heading [DirectPlay8].  There are 2 settings:
> 
> 	Debug=9
> 
> 	controls the debug level.  All messages, at or below that debug level
> 	are printed.
> 
> 	The second setting (logging).  If not specified, all debugs are spewed
> 	through the standard DebugPrint and will appear on in DEVSTUDIO if
> 	it is up, or on the kernel debugger if it is running.
> 
> 	log = 0 {no debug output}
> 	log = 1	{spew to console only}
> 	log = 2 {spew to log only}
> 	log = 3 {spew to console and log}
> 
> 	example win.ini...
> 
> 	[DirectPlay8]
> 	Debug=7		; lots of spew
> 	log=2		; don't spew to debug window
> 
> 	[DirectPlay8]
> 	Debug=0		; only fatal errors spewed to debug window
> 
> 	Asserts:
> 	========
> 	Asserts are used to validate assumptions in the code.  For example
> 	if you know that the variable jojo should be > 700 and are depending
> 	on it in subsequent code, you SHOULD put an assert before the code
> 	that acts on that assumption.  The assert would look like:
> 
> 	ASSERT(jojo>700);
> 
> 	Asserts generally will produce 3 lines of debug spew to highlight the
> 	breaking of the assumption.  For testing, you might want to set the
> 	system to break in on asserts.  This is done in the [DirectPlay8] section
> 	of win.ini by setting BreakOnAssert=TRUE
> 
> 	e.g.
> 
> 	[DirectPlay8]
> 	Debug=0
> 	BreakOnAssert=TRUE
> 	Verbose=1
> 
> 	Debug Breaks:
> 	=============
> 	When something really severe happens and you want the system to break in
> 	so that you can debug it later, you should put a debug break in the code
> 	path.  Some people use the philosophy that all code paths must be
> 	verified by hand tracing each one in the debugger.  If you abide by this
> 	you should place a DEBUG_BREAK() in every code path and remove them
> 	from the source as you trace each.  When you have good coverage but
> 	some unhit paths (error conditions) you should force those paths in
> 	the debugger.
> 
> 
> ===========================================================================*/
> 
39c186,193
< DWORD lDebugLevel = 1;	
---
> 
> DWORD lDebugLevel = 0;	
> 
> DWORD dwLogging   = 1;	// 0 => No debug spew
> 						// 1 => Spew to console only (default)
> 						// 2 => Spew to log only
> 						// 3 => Spew to console and log
> 
41d194
< DWORD bVerbose = FALSE;	// if TRUE, all file/line/module information is printed and logged.
42a196,202
> // if TRUE, all file/line/module information is printed and logged.
> DWORD bVerbose = FALSE;	
> BOOL  bLiveLogging = FALSE;
> 
> // if TRUE messages printed with the LOGPF will be logged, if FALSE they're ignored
> DWORD  lOutputLog = 0;
> 
63a224,347
> // open up a channel to the DirectNet VXD (DNET.VXD) that will allows
> // the log to be written to the VxD through DeviceIoControl calls.  The
> // log in this case is accessible in the Win9x kernel debugger through
> // the .dnet debugger extensions.
> void InitDirectNetVxd(void)
> {
> 	IN_LOGINIT In;
> 	OUT_LOGINIT Out;
> 	UINT cbRet;
> 
> 	// note we rely on the system automatically closing this
> 	// handle for us when the user mode application exits.
> 	hLoggingVxd = CreateFileA("\\\\.\\DNET",0,0,0,0,0,0);
> 
> 	if(hLoggingVxd != INVALID_HANDLE_VALUE){
> 
> 		In.nCharsPerLine=MAX_STRING;
> 		In.nLogEntries=5000;
> 		DeviceIoControl(hLoggingVxd,
> 						OPEN_DEBUGLOG,
> 						&In,sizeof(In),
> 						&Out, sizeof(Out),
> 						&cbRet, NULL);
> 	} else {
> 		hLoggingVxd=0;
> 	}
> }
> 
> // Write a string to the log in the debug support VxD.  This only
> // operates on Win9x, when the DNET.VXD is installed.
> static void VxdLogString( LPSTR str )
> {
> 	char logstring[MAX_STRING+sizeof(LOGENTRY)];
> 	int  i=0;
> 	PLOGENTRY pLogEntry=(PLOGENTRY)&logstring;
> 	UINT rc;
> 	UINT cbRet;
> 	int maxlen = MAX_STRING+sizeof(LOGENTRY);
> 
> 	if(hLoggingVxd && str){
> 		while(str[i] && i < maxlen)
> 			i++;
> 		pLogEntry->debuglevel=0;
> 		memcpy(pLogEntry->str,str,i+1);
> 		DeviceIoControl(hLoggingVxd,WRITE_DEBUGLOG,pLogEntry,i+sizeof(LOGENTRY), &rc, sizeof(rc), &cbRet, NULL);
> 	}
> }
> 
> // Create a shared file for logging information on the fly
> // This support allows the current log to be dumped from the
> // user mode DPLOG.EXE application.  This is useful when debugging
> // in MSSTUDIO or in NTSD.  When the DPLOG.EXE is invoke, note that
> // the application will get halted until the log is completely dumped
> // so it is best to dump the log to a file.
> static BOOL InitMemLogString(VOID)
> {
> 	static BOOL inited = FALSE;
> 
> 	if(!inited){
> 		hLogFile=CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, DPLOG_SIZE, BASE_LOG_FILENAME);
> 		hLogMutex=CreateMutexA(NULL,FALSE,BASE_LOG_MUTEXNAME);
> 		pLogFile=(PSHARED_LOG_FILE)MapViewOfFile(hLogFile, FILE_MAP_ALL_ACCESS,0,0,0);
> 
> 		if(!hLogFile || !hLogMutex || !pLogFile){
> 			if(hLogFile){
> 				CloseHandle(hLogFile);
> 				hLogFile=0;
> 			}
> 			if(hLogMutex){
> 				CloseHandle(hLogMutex);
> 				hLogMutex=0;
> 			}
> 			if(pLogFile){
> 				UnmapViewOfFile(pLogFile);
> 				pLogFile=NULL;
> 			}
> 			return FALSE;
> 		} else {
> 			inited = TRUE;
> 			pLogFile->nEntries = DPLOG_NUMENTRIES;
> 			pLogFile->cbLine   = DPLOG_ENTRYSIZE;
> 			pLogFile->iWrite   = 0;
> 			pLogFile->cInUse   = 0;
> 		}
> 	}
> 	return TRUE;
> }
> 
> // Log a string to a shared file.  This file can be dumped using the
> // DPLOG.EXE utility.
> static void MemLogString(LPSTR str)
> {
> 	PLOG_ENTRY pEntry;
> 	DWORD cbCopy;
> 
> 	if(!hLogFile){
> 		if(!InitMemLogString()){
> 			return;
> 		}
> 	}
> 
> 	WaitForSingleObject(hLogMutex,INFINITE);
> 
> 	pEntry=(PLOG_ENTRY)(((PUCHAR)(pLogFile+1))+(pLogFile->iWrite*(sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)));
> 	pEntry->hThread=GetCurrentThreadId();
> 	pEntry->tLogged=timeGetTime();
> 	pEntry->DebugLevel=0;
> 
> 	cbCopy=strlen(str)+1;
> 	if(cbCopy > DPLOG_ENTRYSIZE){
> 		str[DPLOG_ENTRYSIZE]=0;
> 		cbCopy=DPLOG_ENTRYSIZE;
> 	}
> 	memcpy(pEntry->str, str, cbCopy);
> 
> 	if(pLogFile->iWrite+1 > pLogFile->cInUse){
> 		pLogFile->cInUse=pLogFile->iWrite+1;
> 	}
> 
> 	pLogFile->iWrite = (pLogFile->iWrite+1) % pLogFile->nEntries;
> 	ReleaseMutex(hLogMutex);
> 
> }
> 
66a351,352
> 	DWORD lSpecificLevel;
> 
70a357,392
>     lDebugLevel = (signed int) GetProfileIntA( PROF_SECT, "debug", 0 );
>     lSpecificLevel = (signed int) GetProfileIntA( PROF_SECT, DPF_MODULE_NAME, -1);
>     if(lSpecificLevel != -1){
>     	lDebugLevel = lSpecificLevel;
>     }
>     dwLogging   = (signed int) GetProfileIntA( PROF_SECT, "log" , 0);
>     bBreakOnAssert = (signed int) GetProfileIntA( PROF_SECT, "BreakOnAssert", 0);
>     bVerbose = (signed int) GetProfileIntA( PROF_SECT, "Verbose", 0);
> 
>     lOutputLog = (signed int) GetProfileIntA( PROF_SECT, "OutputLog", 0);
> 
> 	switch(dwLogging){
> 		case 0:
> 			bLiveLogging=FALSE;
> 			break;
> 		case 1:
> 			bLiveLogging=TRUE;
> 			break;
> 		case 2:
> 			bLiveLogging=FALSE;
> 			break;
> 		case 3:
> 			bLiveLogging=TRUE;
> 			break;
> 		default:
> 			break;
> 	}
> 	if((dwLogging >= 2)||(lOutputLog > 0)){
> 		// Doing log based logging, so try to find the VXD and open
> 		// the shared logging file.
> 		InitDirectNetVxd();
> 
> 		// Do logging also based on shared memory file.
> 		InitMemLogString();	
> 	}
> 
77a400,405
> 	if(hLogFile){
> 		CloseHandle(hLogFile);
> 	}
> 	if(hLoggingVxd){
> 		CloseHandle(hLoggingVxd);
> 	}	
113a442,443
> 		if(bLiveLogging)
> 		{
116a447,457
> 		}
> 
> 		if(hLoggingVxd){
> 			// log to vxd
> 			VxdLogString( str );
> 		}
> 
> 		if(dwLogging >= 2){
> 			// log to shared file
> 			MemLogString( str );
> 		}
158c499
< 	WSPRINTF(cMsg+strlen( cMsg ), szFormat, argptr);
---
> 	WSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);
210c551
< 	WVSPRINTF(cMsg+strlen( cMsg ), szFormat, argptr);
---
> 	WVSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);
218a560,595
> /*
> **	LogPrintf copies a quick Log Entry to the
> **
> */
> 
> //  5/23/2000(RichGr): IA64: Change DWORD to DWORD_PTR.
> void LogPrintf(volatile DWORD_PTR dwDetail, ...)
> {
> 	CHAR  cMsg[1000];
> 	LPSTR szFormat;
> 
> 	va_list argptr;
> 
> 	if(lOutputLog < dwDetail){
> 		LeaveCriticalSection(&csDPF);
> 		return;
> 	}
> 
> 	//EnterCriticalSection(&csDPF);
> 
> 	va_start(argptr, dwDetail);
> 	szFormat = (LPSTR) va_arg(argptr, DWORD_PTR);
> 
> 	cMsg[0]=0;
> 
> 	WSPRINTF(cMsg,"%s: ",g_szModName);
> 
> 	WVSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);
> 
> 	MemLogString( (LPSTR) cMsg );
> 
> 	LeaveCriticalSection(&csDPF);
> 
> 	va_end(argptr);
> }
> 
225a603,604
> #define ASSERT_BREAK_SECTION "BreakOnAssert"
> #define ASSERT_BREAK_DEFAULT FALSE
248c627
<     if( bBreakOnAssert )
---
>     if( bBreakOnAssert || GetProfileIntA( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
317a697,717
> }
> 
> BOOL IsValidStringA( const CHAR * const szString )
> {
> 	const char *szTmpLoc = szString;
> 	
> 	if( szString == NULL )
> 	{
> 		return FALSE;
> 	}
> 
> 	_try
> 	{
> 		for( ; *szTmpLoc ; szTmpLoc++ );
> 	}
> 	_except( EXCEPTION_EXECUTE_HANDLER )
> 	{
> 		return FALSE;
> 	}
> 
> 	return TRUE;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dndbg.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
29a30,32
> 	#if defined( _WIN32 ) && !defined(WINNT) && defined(_X86_)
> 		#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
> 	#else
30a34
> 	#endif
102a107
> extern BOOL IsValidStringA( const CHAR * const swzString );
111a117
> extern void LogPrintf(volatile DWORD_PTR dwDetail, ...);
112a119
> #define DNVALID_STRING_A(a)		IsValidStringA(a)
127c134,138
< #define	LOGPF		DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
---
> #ifdef DPF_SUBCOMP_MASK
> 	#define DPFSC if(DPF_SUBCOMP_MASK & DPF_SUBCOMP_BIT)DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),if(DPF_SUBCOMP_MASK & DPF_SUBCOMP_BIT)DebugPrintf
> #else
> 	#define DPFSC DPF
> #endif
128a140,141
> #define	LOGPF		DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),LogPrintf
> 
133a147
> 	#define DNVALID_STRING_A(a)			(TRUE)
139a154
> 	#define DPFSC()
148,149c163,166
< #define WVSPRINTF wvsprintf
< #define STRLEN   strlen
---
> #define WVSPRINTF wvsprintfA
> #define STRLEN   lstrlenA
> 
> #define PROF_SECT "DirectPlay8"
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dneterrors.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20,23
> // vanceo - changed to stdio for printf
> //#include	<iostream.h>
> #include	<stdio.h>
> 
78a83,92
> 			// output to console
> 			case DPNERR_OUT_CONSOLE:
> 			{
> 				// Also see the change from <iostream.h> to <stdio.h> above
> 				#pragma TODO(vanceo, "Changed cout to printf so NT build environment will work, figure this out.")
> 				//cout << endl << pString << endl;
> 				printf("\n%s\n", pString);
> 				break;
> 			}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\guidutil.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
15c15
< #include <wchar.h>
---
> #include "stdio.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34,37
> #ifdef	_WIN64
> #define	MEMORY_CRC			0X5AA55AA55AA55AA5
> #define	GUARD_SIGNATURE		0x0F1E2D3C4B5A6978
> #else
35a40
> #endif	// _WIN64
40a46,52
> //
> // enumerated values to indicate how to report memory leaks
> //
> #define	MEMORY_LEAK_REPORT_NONE		0x00000000
> #define	MEMORY_LEAK_REPORT_DPF		0x00000001
> #define	MEMORY_LEAK_REPORT_DIALOG	0x00000002
> 
60a73
> #ifdef	_X86_
61a75,77
> #else
> #define	ASSERT( arg )	if ( arg == FALSE ) { DebugBreak(); }
> #endif
94a111,116
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
> static	HINSTANCE			g_hApplicationInstance;
> 
> //
103a126,128
> static int	DisplayCallStack( const char *const pszMsg,
> 							  const char *const pszTitle,
> 							  const char *const pCallStack );
121a147
> 	OSVERSIONINFO	OSVersionInfo;
122a149
> 
130a158,186
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
> 	// note application instance
> 	//
> 	g_hApplicationInstance = GetModuleHandle( NULL );
> 	if ( g_hApplicationInstance == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to GetModuleHandle: 0x%x", dwError );
> 		goto Failure;
> 	}
> 
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
> 	//
229a286,287
> 		switch ( DNGetOSType() )
> 		{
232a291,292
> 			case VER_PLATFORM_WIN32_NT:
> 			{
256a317,327
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
289a361,392
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetApplcationInstance - application instance
> //
> // Entry:		Nothing
> //
> // Exit:		Application instance
> // ------------------------------
> HINSTANCE	DNGetApplicationInstance( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_hApplicationInstance;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
360a464
> //#ifdef	_WIN32
389a494
> //#endif	// _WIN32
390a496,517
> 
> //#ifdef	_WIN64
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	if ( pTime1->Time < pTime2->Time )
> //	{
> //		iReturnValue = -1;
> //	}
> //	else
> //	{
> //		if ( pTime1->Time == pTime2->Time )
> //		{
> //			iReturnValue = 0;
> //		}
> //		else
> //		{
> //			iReturnValue = 1;
> //		}
> //	}
> //#endif	// _WIN64
> 
416a544
> #ifdef	_X86_
428a557,607
> 
> #else	// _X86_
> 
> /*
> #ifdef	_ALPHA_
> 	// debug me
> 	DebugBreak();
> 
> 	__asm{ mov	$t0, *pTime1
> 		   mov	$t1, *pTime2
> 		   addq	$t0, $t1
> 		   mov	*pTimeResult, $t0
> 	};
> #else	// _ALPHA_
> */
> 
> //#ifdef	_WIN32
> 	DWORD	dwTempLowTime;
> 
> 
> 	dwTempLowTime = pTime1->Time32.TimeLow;
> 	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow + pTime2->Time32.TimeLow;
> 	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh + pTime2->Time32.TimeHigh;
> 
> 	//
> 	// check for overflow in low 32-bits and increment high value if applicable
> 	//
> 	if ( pTimeResult->Time32.TimeLow < dwTempLowTime )
> 	{
> #pragma	BUGBUG( johnkan, "Test this!" )
> 		// debug me
> 		DebugBreak();
> 		pTimeResult->Time32.TimeHigh++;
> 	}
> //#endif	// _WIN32
> 
> //#ifdef	_WIN64
> //	DEBUG_ONLY( UINT_PTR	ReferenceTime );
> //
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	DEBUG_ONLY( ReferenceTime = pTime1->Time );
> //	*pTimeResult = pTime1->Time + pTime2->Time;
> //	DNASSERT( *pTimeResult >= ReferenceTime );
> //
> //#endif	// _WIN64
> 
> // #endif	// _ALPHA_
> 
> #endif	// _X86_
454a634,635
> #ifdef	_X86_
> 
466a648,694
> 
> #else	// _X86_
> 
> /*
> #ifdef	_ALPHA_
> 	// debug me
> 	DebugBreak();
> 
> 	mov		$t0, *pTime1
> 	mov		$t1, *pTime2
> 	addq	$t0, $t1
> 	mov		*pTimeResult, $t0
> #else	// _ALPHA_
> */
> 
> //#ifdef	_WIN32
> 	DWORD	dwTempLowTime;
> 
> 
> 	dwTempLowTime = pTime1->Time32.TimeLow;
> 	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow - pTime2->Time32.TimeLow;
> 	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh - pTime2->Time32.TimeHigh;
> 
> 	//
> 	// check for underflow in low 32-bits and decrement high value if applicable
> 	//
> 	if ( pTimeResult->Time32.TimeLow > dwTempLowTime )
> 	{
> #pragma	BUGBUG( johnkan, "Test this!" )
> 		// debug me
> 		DebugBreak();
> 
> 		pTimeResult->Time32.TimeHigh--;
> 	}
> //#endif	// _WIN32
> 
> //#ifdef	_WIN64
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	DNASSERT( pTime1->Time > pTime2->Time );
> //	pTimeResult = pTime1->Time - pTime2->Time;
> //#endif	// _WIN64
> 
> // #endif	// _ALPHA_
> 
> #endif	// _X86_
687a916,918
> 		void	NoteCurrentCallStack( void ) { m_CallStack.NoteCurrentCallStack(); }
> 		void	GetCallStack( char *const pBuffer ) const { m_CallStack.GetCallStackString( pBuffer ); }
> 
704a936
> 		CCallStack<DN_MEMORY_CALL_STACK_DEPTH>	m_CallStack;
795a1028
> 		pMemoryLink->NoteCurrentCallStack();
905a1139
> 	char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
939,940c1173,1184
< 			DPF( 0, "%s%s\n", "Memory Corruption!", MessageString );
< //					DNASSERT( FALSE );
---
> 			pMemoryLink->GetCallStack( CallStackBuffer );
> 			MessageReturn = DisplayCallStack( MessageString, "Memory Corruption!", CallStackBuffer );
> 			switch ( MessageReturn )
> 			{
> 				case IDABORT:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				case IDIGNORE:
> 				{
944a1189,1197
> 					break;
> 				}
> 
> 				case IDRETRY:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
975a1229
> 	DWORD		dwDisplayFlags;
976a1231
> 
979a1235
> 	fDisplayLeaks = TRUE;
982a1239,1240
> 	dwDisplayFlags = GetProfileIntA( PROF_SECT, "MemoryLeakOutput", MEMORY_LEAK_REPORT_DPF );
> 	
989a1248
> 		char		CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
1002,1003c1261
< 			DPF( 0, "%s%s\n", DialogTitle, LeakSizeString );
< //						DNASSERT( FALSE );
---
> 		pTemp->GetCallStack( CallStackBuffer );
1004a1263,1313
> 
> 		if ( ( dwDisplayFlags & MEMORY_LEAK_REPORT_DPF ) != 0 )
> 		{
> 			DPF( 0, "%s%s%s\n", DialogTitle, LeakSizeString, CallStackBuffer );
> 		}
> 
> 		if ( ( dwDisplayFlags & MEMORY_LEAK_REPORT_DIALOG ) != 0  )
> 		{
> 			if ( fDisplayLeaks != FALSE )
> 			{
> 				MessageReturn = DisplayCallStack( LeakSizeString, DialogTitle, CallStackBuffer );
> 				switch ( MessageReturn )
> 				{	
> 					//
> 					// stop application now
> 					//
> 					case IDABORT:
> 					{
> 						fDisplayLeaks = FALSE;
> 						break;
> 					}
> 
> 					//
> 					// display next leak
> 					//
> 					case IDIGNORE:
> 					{
> 						break;
> 					}
> 
> 					//
> 					// stop in the debugger
> 					//
> 					case IDRETRY:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 
> 					//
> 					// unknown
> 					//
> 					default:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 				}
> 			}
> 		}
> 
1017a1327,1470
> 
> 
> #if	defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
> //**********************************************************************
> //**
> //** THIS IS THE STACK TRACKING SECTION.  ONLY ADD FUNCTIONS HERE THAT ARE
> //** RELATED TO TRACKING THE CALL STACK!!
> //**
> //**********************************************************************
> 
> 
> ////**********************************************************************
> //// ------------------------------
> //// DNGetStackTop - return pointer to top of stack
> ////
> //// Entry:		Nothing
> ////
> //// Exit:		Pointer to top of stack
> //// ------------------------------
> //static void	*DNGetStackTop( void )
> //{
> //	void	*pReturn;
> //
> //	_asm	mov eax,dword ptr fs:[4]
> //	_asm	mov pReturn, eax
> //	return	pReturn;
> //}
> ////**********************************************************************
> //
> //
> ////**********************************************************************
> //// ------------------------------
> //// DNGetStackBottom - return pointer to bottom of call stack
> ////
> //// Entry:		Nothing
> ////
> //// Exit:		Pointer to bottom of call stack
> //// ------------------------------
> //static void	*DNGetStackBottom( void )
> //{
> //	void	*pReturn;
> //
> //	_asm	mov eax,dword ptr fs:[8]
> //	_asm	mov pReturn, eax
> //	return	pReturn;
> //}
> ////**********************************************************************
> 
> 
> ////**********************************************************************
> //// ------------------------------
> //// DNGetCallStack - get a call stack
> ////
> //// Entry:		Pointer to call stack array
> ////				Number of calls to report
> ////
> //// Exit:		Nothing
> //// ------------------------------
> //static	void	DNGetCallStack( const void **const pCallStack, const UINT_PTR Depth )
> //{
> //	void		**CallersEBP;
> //	void		*ReturnAddr;
> //	UINT_PTR	i,iCount;
> //	void		*StackTop;
> //	void		*StackBottom;
> //	static const	void	*min_dll_base = NULL;
> //
> //
> //	StackTop = DNGetStackTop();
> //	StackBottom = DNGetStackBottom();
> //	memset(	pCallStack, 0x00, sizeof( *pCallStack ) * Depth );
> //
> //	_asm
> //	{
> //		mov eax,[ebp]
> //		mov CallersEBP,eax
> //	}
> //
> //	__try
> //	{
> //		//
> //		// this code can generate exception if it steps back too far...
> //		//
> //		for ( i = 0, iCount = 0; i < Depth; iCount++ )
> //		{
> //			if ( ( CallersEBP < StackBottom ) || ( CallersEBP >= StackTop ) )
> //				break;
> //			ReturnAddr = CallersEBP[ 1 ];
> //			if ( ( iCount > 0 ) || ( ReturnAddr >= min_dll_base ) ) // iCount check skips memory_alloc_debug
> //				pCallStack[ i++ ] = ReturnAddr;
> //			CallersEBP = reinterpret_cast<void**>( *CallersEBP ); // get callers callers ebp
> //		}
> //	}
> //	__except( 1 )  // went too far back on the stack, fill up rest of array with zeros
> //	{
> //		DPF( 0, "Benign access violation creating return address stack." );
> //	}
> //}
> ////**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DisplayCallStack - display a call stack message box
> //
> // Entry:		Pointer to information string
> //				Pointer to title string
> //				Pointer to call stack string
> //
> // Exit:		Dialog return code
> // ------------------------------
> static int	DisplayCallStack( const char *const pszMsg, const char *const pszTitle, const char *const pCallStackString )
> {
> 	MSGBOXPARAMS	MessageBoxParams;
> 	char 			szStackTraceMsg[ CALLSTACK_BUFFER_SIZE ];
> 
> 
>     strcpy( szStackTraceMsg, pszMsg );
> 	strcat( szStackTraceMsg, pCallStackString );
> 
> 	//
> 	// display message box
> 	//
> 	memset( &MessageBoxParams, 0x00, sizeof( MessageBoxParams ) );
> 	MessageBoxParams.cbSize = sizeof( MessageBoxParams );
> 	MessageBoxParams.lpszText = szStackTraceMsg;
> 	MessageBoxParams.lpszCaption = pszTitle;
> 	MessageBoxParams.dwStyle = MB_ABORTRETRYIGNORE | MB_SETFOREGROUND | MB_TOPMOST | MB_DEFBUTTON2;
> 	MessageBoxParams.hInstance = NULL;
> 
> 	return MessageBoxIndirect( &MessageBoxParams );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> //**
> //** END OF CALL STACK TRACKING SECTION.
> //**
> //**********************************************************************
> #endif	// defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
> 
> 
> 
1112a1566
> 	static	BOOL	fDisplayCallStacks = TRUE;
1130a1585,1588
> 	if ( pCriticalSection->LockCount == 0 )
> 	{
> 		pCriticalSection->CallStack.NoteCurrentCallStack();
> 	}
1136a1595,1599
> 			if ( fDisplayCallStacks != FALSE )
> 			{
> 				char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
> 
> 
1141,1142c1604,1636
< 			    DPF( 0, "%s%s\n", "DNCritical section has been reentered!", "Check stack trace for function that originally held the lock." );
< //						DNASSERT( FALSE );
---
> 				pCriticalSection->CallStack.GetCallStackString( CallStackBuffer );
> 				switch ( DisplayCallStack( "Stack trace of function that originally held the lock:",
> 										   "DNCritical section has been reentered!",
> 										   CallStackBuffer ) )
> 				{
> 					//
> 					// don't display any more critical section warnings!
> 					//
> 					case IDABORT:
> 					{
> 						fDisplayCallStacks = FALSE;
> 						break;
> 					}
> 
> 					//
> 					// acknowledged
> 					//
> 					case IDIGNORE:
> 					{
> 						break;
> 					}
> 
> 					//
> 					// stop in debugger
> 					//
> 					case IDRETRY:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 				}
> 			}
> 
1175a1670
> 		memset( &pCriticalSection->CallStack, 0x00, sizeof( pCriticalSection->CallStack ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18,19
> #include	"CallStack.h"
> 
29a32,34
> #define	DN_MEMORY_CALL_STACK_DEPTH				12
> #define	DN_CRITICAL_SECTION_CALL_STACK_DEPTH	10
> 
53a59
> 	CCallStack< DN_CRITICAL_SECTION_CALL_STACK_DEPTH > 	CallStack;
85a92,101
> 
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
> HINSTANCE	DNGetApplicationInstance( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
41,42c41
< TARGETLIBS=
< # $(TARGETLIBS)
---
> TARGETLIBS=$(TARGETLIBS)
72a72
>         creg.cpp \
81c81
< C_DEFINES= $(C_DEFINES) /D_LIB /DWIN32 /D_MT /DCINTERFACE /DUNICODE
---
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\strutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21,22
> #undef DPF_MODNAME
> #define DPF_MODNAME "STR_WideToAnsi"
22,63c24,41
< // BUGBUG: [mgere] [xbox] UnicodeToMultiByteN and MultiByteToUnicodeN were Taken from nlsxlat.c
< 
< HRESULT
< UnicodeToMultiByteN(
<     OUT PCH MultiByteString,
<     IN ULONG MaxBytesInMultiByteString,
<     IN PWCH UnicodeString,
<     IN ULONG BytesInUnicodeString)
< 
< /*++
< 
< Routine Description:
< 
<     This functions converts the specified unicode source string into an
<     ansi string. The translation is done with respect to the
<     ANSI Code Page (ACP) loaded at boot time.
< 
< Arguments:
< 
<     MultiByteString - Returns an ansi string that is equivalent to the
<         unicode source string.  If the translation can not be done,
<         an error is returned.
< 
<     MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
<         written to MultiByteString.  If this causes MultiByteString to be a
<         truncated equivalent of UnicodeString, no error condition results.
< 
<     BytesInMultiByteString - Returns the number of bytes in the returned
<         ansi string pointed to by MultiByteString.
< 
<     UnicodeString - Supplies the unicode source string that is to be
<         converted to ansi.
< 
<     BytesInUnicodeString - The number of bytes in the the string pointed to by
<         UnicodeString.
< 
< Return Value:
< 
<     SUCCESS - The conversion was successful
< 
< --*/
< 
---
> //**********************************************************************
> // ------------------------------
> // WideToANSI - convert a wide string to an ANSI string
> //
> // Entry:		Pointer to source wide string
> //				Size of source string (in WCHAR units, -1 implies NULL-terminated)
> //				Pointer to ANSI string destination
> //				Pointer to size of ANSI destination
> //
> // Exit:		Error code:
> //				DPNERR_GENERIC = operation failed
> //				DPN_OK = operation succeded
> //				DPNERR_BUFFERTOOSMALL = destination buffer too small
> // ------------------------------
> HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
> 						const DWORD dwWCHARStringLength,
> 						char *const pString,
> 						DWORD *const pdwStringLength )
65,66c43,45
<     ULONG LoopCount;
<     ULONG CharsInUnicodeString;
---
> 	HRESULT	hr;
> 	int		iReturn;
> 	BOOL	fDefault;
68d46
<     CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);
70,71c48,50
<     LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
<                  CharsInUnicodeString : MaxBytesInMultiByteString;
---
> 	DNASSERT( pWCHARString != NULL );
> 	DNASSERT( pdwStringLength != NULL );
> 	DNASSERT( ( pString != NULL ) || ( &pdwStringLength == 0 ) );
73c52
<     while (LoopCount) {
---
> 	hr = DPN_OK;
75c54,77
<         *MultiByteString = (*UnicodeString < 256) ? (UCHAR)*UnicodeString : '?';
---
> 	fDefault = FALSE;
> 	iReturn = WideCharToMultiByte( CP_ACP,				// code page (default ANSI)
> 								   0,					// flags (none)
> 								   pWCHARString,		// pointer to WCHAR string
> 								   dwWCHARStringLength,	// size of WCHAR string
> 								   pString,				// pointer to destination ANSI string
> 								   *pdwStringLength,	// size of destination string
> 								   NULL,				// pointer to default for unmappable characters (none)
> 								   &fDefault			// pointer to flag indicating that default was used
> 								   );
> 	if ( iReturn == 0 )
> 	{
> 		hr = DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		if ( *pdwStringLength == 0 )
> 		{
> 			hr = DPNERR_BUFFERTOOSMALL;
> 		}
> 		else
> 		{
> 			DNASSERT( hr == DPN_OK );
> 		}
77,80c79,80
<         UnicodeString++;
<         MultiByteString++;
<         LoopCount--;
<     }
---
> 		*pdwStringLength = iReturn;
> 	}
82c82,88
<     return DPN_OK;
---
> 	//
> 	// if you hit this ASSERT it's because you've probably got ASCII text as your
> 	// input WCHAR string.  Double-check your input!!
> 	//
> 	DNASSERT( fDefault == FALSE );
> 
> 	return	hr;
83a90
> //**********************************************************************
86,132c93,110
< HRESULT
< MultiByteToUnicodeN(
<     OUT PWCH UnicodeString,
<     IN ULONG MaxBytesInUnicodeString,
<     IN PCH MultiByteString,
<     IN ULONG BytesInMultiByteString)
< 
< /*++
< 
< Routine Description:
< 
<     This functions converts the specified ansi source string into a
<     Unicode string. The translation is done with respect to the
<     ANSI Code Page (ACP) installed at boot time.  Single byte characters
<     in the range 0x00 - 0x7f are simply zero extended as a performance
<     enhancement.  In some far eastern code pages 0x5c is defined as the
<     Yen sign.  For system translation we always want to consider 0x5c
<     to be the backslash character.  We get this for free by zero extending.
< 
<     NOTE: This routine only supports precomposed Unicode characters.
< 
< Arguments:
< 
<     UnicodeString - Returns a unicode string that is equivalent to
<         the ansi source string.
< 
<     MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
<         written to UnicodeString.  If this causes UnicodeString to be a
<         truncated equivalent of MultiByteString, no error condition results.
< 
<     BytesInUnicodeString - Returns the number of bytes in the returned
<         unicode string pointed to by UnicodeString.
< 
<     MultiByteString - Supplies the ansi source string that is to be
<         converted to unicode.  For single-byte character sets, this address
<         CAN be the same as UnicodeString.
< 
<     BytesInMultiByteString - The number of bytes in the string pointed to
<         by MultiByteString.
< 
< Return Value:
< 
<     SUCCESS - The conversion was successful.
< 
< 
< --*/
< 
---
> //**********************************************************************
> // ------------------------------
> // ANSIToWide - convert an ANSI string to a wide string
> //
> // Entry:		Pointer to source multi-byte (ANSI) string
> //				Size of source string (-1 imples NULL-terminated)
> //				Pointer to multi-byte string destination
> //				Pointer to size of multi-byte destination (in WCHAR units)
> //
> // Exit:		Error code:
> //				DPNERR_GENERIC = operation failed
> //				DPN_OK = operation succeded
> //				DPNERR_BUFFERTOOSMALL = destination buffer too small
> // ------------------------------
> HRESULT	STR_AnsiToWide( const char *const pString,
> 						const DWORD dwStringLength,
> 						WCHAR *const pWCHARString,
> 						DWORD *const pdwWCHARStringLength )
134,135c112,113
<     ULONG LoopCount;
<     ULONG MaxCharsInUnicodeString;
---
> 	HRESULT	hr;
> 	int		iReturn;
137d114
<     MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);
139,140c116,118
<     LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
<                  MaxCharsInUnicodeString : BytesInMultiByteString;
---
> 	DNASSERT( pdwWCHARStringLength != 0 );
> 	DNASSERT( ( pWCHARString != NULL ) || ( pdwWCHARStringLength == 0 ) );
> 	DNASSERT( pString != NULL );
142c120,141
<     while (LoopCount) {
---
> 	hr = DPN_OK;
> 	iReturn = MultiByteToWideChar( CP_ACP,					// code page (default ANSI)
> 								   0,						// flags (none)
> 								   pString,					// pointer to multi-byte string			
> 								   dwStringLength,			// size of string (assume null-terminated)
> 								   pWCHARString,			// pointer to destination wide-char string
> 								   *pdwWCHARStringLength	// size of destination in WCHARs
> 								   );
> 	if ( iReturn == 0 )
> 	{
> 		hr = DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		if ( *pdwWCHARStringLength == 0 )
> 		{
> 			hr = DPNERR_BUFFERTOOSMALL;
> 		}
> 		else
> 		{
> 			DNASSERT( hr == DPN_OK );
> 		}
144c143,144
<         *UnicodeString = (WCHAR)(UCHAR)(*MultiByteString);
---
> 		*pdwWCHARStringLength = iReturn;
> 	}
146,151c146
<         UnicodeString++;
<         MultiByteString++;
<         LoopCount--;
<     }
< 
<     return DPN_OK;
---
> 	return	hr;
152a148
> //**********************************************************************
154a151
> 
174a172,174
> 	int rval;
> 	BOOL bDefault;
> 
182c182,192
< 	UnicodeToMultiByteN( lpStr, cchStr, (PWCH) lpWStr, cchStr*sizeof(WCHAR));
---
> 	// use the default code page (CP_ACP)
> 	// -1 indicates WStr must be null terminated
> 	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,
> 			NULL,&bDefault);
> 
> 	if (bDefault)
> 	{
> 		DPF(3,"!!! WARNING - used default string in WideToAnsi conversion.!!!");
> 		DPF(3,"!!! Possible bad unicode string - (you're not hiding ansi in there are you?) !!! ");
> 		return DPNERR_CONVERSION;
> 	}
188a199,205
> //	WideToAnsi
> //
> //	Convert a WCHAR (Wide) string to a CHAR (ANSI) string
> //
> //	CHAR	*pStr		CHAR string
> //	WCHAR	*pWStr		WCHAR string
> //	int		iStrSize	size (in bytes) of buffer pointed to by lpStr
189a207,249
> #define DPF_MODNAME "STR_AllocAndConvertToANSI"
> /*
>  ** GetAnsiString
>  *
>  *  CALLED BY: Everywhere
>  *
>  *  PARAMETERS: *ppszAnsi - pointer to string
>  *				lpszWide - string to copy
>  *
>  *  DESCRIPTION:	  handy utility function
>  *				allocs space for and converts lpszWide to ansi
>  *
>  *  RETURNS: string length
>  *
>  */
> HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide)
> {
> 	int iStrLen;
> 	BOOL bDefault;
> 	
> 	DNASSERT(ppszAnsi);
> 
> 	if (!lpszWide)
> 	{
> 		*ppszAnsi = NULL;
> 		return S_OK;
> 	}
> 
> 	*ppszAnsi = new char[wcslen(lpszWide)+1];
> 	if (!*ppszAnsi)	
> 	{
> 		DPF(0, "could not get ansi string -- out of memory");
> 		return E_OUTOFMEMORY;
> 	}
> 
> 	iStrLen = WideCharToMultiByte(CP_ACP,0,lpszWide,-1,*ppszAnsi,wcslen(lpszWide)+1,
> 			NULL,&bDefault);
> 
> 	return DPN_OK;
> } // OSAL_AllocAndConvertToANSI
> 
> 
> #undef DPF_MODNAME
208a269,270
> 	int rval;
> 
216c278
< 	MultiByteToUnicodeN( lpWStr, cchWStr*sizeof(WCHAR), (CHAR *) lpStr, cchWStr );
---
> 	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);
219a282
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\strutils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide);
21a23,31
> HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
> 						const DWORD dwWCHARStringLength,
> 						char *const pString,
> 						DWORD *const pdwStringLength );
> 
> HRESULT	STR_AnsiToWide( const char *const pString,
> 						const DWORD dwStringLength,
> 						WCHAR *const pWCHARString,
> 						DWORD *const pdwWCHARStringLength );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\appdesc.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38d37
< #include <wchar.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
70a71
> #include "DVoice.h"
101a103
> #include "Voice.h"
103c105,107
< #include <mmsystem.h>
---
> #include "dpnsdef.h"
> #include "dpnsvrq.h"
> #include "dpnsvlib.h"
183c187
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
206c210
< 	pDeviceInfo->lpVtbl->GetURLW(pDeviceInfo,DP8ABuffer,&DP8ASize);
---
> 	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer,&DP8ASize);
453c457
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
469c473
< 	pRemoteAddr->lpVtbl->GetURLW(pRemoteAddr,DP8ABuffer,&DP8ASize);
---
> 	pRemoteAddr->lpVtbl->GetURLA(pRemoteAddr,DP8ABuffer,&DP8ASize);
472c476
< 	pDeviceInfo->lpVtbl->GetURLW(pDeviceInfo,DP8ABuffer,&DP8ASize);
---
> 	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer,&DP8ASize);
1468a1473,1481
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
44a45
> #include "DVoice.h"
73a75,76
> #include "dvoice.h"
> #include "voice.h"
121a125
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
234a239,259
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
254a280
> 	pdnObject->pIDP8LobbiedApplication = NULL;
266a293,296
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
> 
295a326,332
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
626a664,666
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
894a935,939
> 	}
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(7,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\client.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
56d55
< #include <wchar.h>
94c93
< typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
108a109,110
> #include "DPLobby8.h"
> #include "DVoice.h"
133a136
> #include "DNMisc.h"
140a144
> #include "Voice.h"
142a147,149
> #include "dpnsdef.h"
> #include "dpnsvrq.h"
> #include "dpnsvlib.h"
144,145d150
< #include <mmsystem.h>
< #include <wchar.h>
174d178
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
801,803c805,809
< 		if ((hResultCode = DirectPlay8AddressCreate( &IID_IDirectPlay8Address,
<                                                      reinterpret_cast<void**>(&pIDevice),
<                                                      NULL)) != S_OK)
---
> 		if ((hResultCode = CoCreateInstance(CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>(&pIDevice))) != S_OK)
878a885,888
> 	if (dwFlags & DPNCONNECT_OKTOQUERYFORADDRESSING)
> 	{
> 		dwConnectFlags |= DPNCONNECT_OKTOQUERYFORADDRESSING;
> 	}
1420a1431,1435
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
> 
1984,1985c1999
< // BUGBUG [mgere] [xbox] Temporarily removed until a CoCreateGuid call is implemented
< //	CoCreateGuid(&pdnObject->dnApplicationDescription.guidInstance);	
---
> 	CoCreateGuid(&pdnObject->dnApplicationDescription.guidInstance);	
2057a2072,2080
> 	//	Inform DPNSVR of LISTENs
> 	//
> 	if( !(pdnObject->dnApplicationDescription.dwFlags & DPNSESSION_NODPNSVR) )
> 	{
> 		DPF(3,"Registering with DPNSVR");
> 		DNRegisterWithDPNSVR(pdnObject);
> 	}
> 
> 	//
3333c3356
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
3409,3411c3432,3436
< 		if ((hResultCode = DirectPlay8AddressCreate( &IID_IDirectPlay8Address,
<                                                      reinterpret_cast<void**>(&pIHost),
<                                                      NULL)) != S_OK)
---
> 		if ((hResultCode = CoCreateInstance(CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>(&pIHost))) != DPN_OK)
3438c3463
< 	pIHost->lpVtbl->GetURLW(pIHost,DP8ABuffer,&DP8ASize);
---
> 	pIHost->lpVtbl->GetURLA(pIHost,DP8ABuffer,&DP8ASize);
3442c3467
< 	pIDevice->lpVtbl->GetURLW(pIDevice,DP8ABuffer,&DP8ASize);
---
> 	pIDevice->lpVtbl->GetURLA(pIDevice,DP8ABuffer,&DP8ASize);
4085c4110
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
4088c4113,4181
< 	return DPNERR_UNSUPPORTED;
---
> 	DIRECTNETOBJECT		*pdnObject;
> 	HRESULT             hResultCode;
> 
> 	DPF(3,"Parameters: pInterface [0x%lx], pIDP8LobbiedApplication [0x%lx], dwFlags [0x%lx]",
> 			pInterface,pIDP8LobbiedApplication,dwFlags);
> 
> 	TRY
> 	{
>     	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
>     	DNASSERT(pdnObject != NULL);
> 
>     	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
>     	{
>     	    if( FAILED( hResultCode = DN_ValidateRegisterLobby( pInterface, pIDP8LobbiedApplication, dwFlags ) ) )
>     	    {
>     	        DPFERR( "Error validating register lobby params" );
>     	        DPF_EXIT( hResultCode );
>     	    }
>     	}
> 
>     	// Check to ensure message handler registered
>     	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
>     	{
>     		DPFERR( "Object is not initialized" );
>     		DPF_EXIT(DPNERR_UNINITIALIZED);
>     	}
> 
> 	}
> 	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
> 	{
> 	    DPFERR("Invalid object" );
> 	    DPF_EXIT(DPNERR_INVALIDOBJECT);
> 	}	
> 
> 	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
> 	DNASSERT(pdnObject != NULL);
> 
> 	if (dwFlags == DPNLOBBY_REGISTER)
> 	{
> 		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 		if (pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE)
> 		{
> 			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 			return(DPNERR_ALREADYINITIALIZED);
> 		}
> 				
> 		pIDP8LobbiedApplication->lpVtbl->AddRef(pIDP8LobbiedApplication);
> 
> 		pdnObject->pIDP8LobbiedApplication = pIDP8LobbiedApplication;
> 		pdnObject->dwFlags |= DN_OBJECT_FLAG_LOBBY_AWARE;
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	}
> 	else
> 	{
> 		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE))
> 		{
> 			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 			return(DPNERR_UNINITIALIZED);
> 		}
> 				
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release(pdnObject->pIDP8LobbiedApplication);
> 
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_LOBBY_AWARE);
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	}
> 
> 	return(DPN_OK);
4366a4460,4564
> }
> 
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DNRegisterWithDPNSVR"
> 
> HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject)
> {
> 	HRESULT					hResultCode;
> 	HRESULT					hrRegister;
> 	CAsyncOp				*pParent;
> 	CAsyncOp				*pAsyncOp;
> 	CBilink					*pBilink;
> 	SPGETADDRESSINFODATA	spInfo;
> #ifdef	DEBUG
> 	CHAR			DP8ABuffer[512];
> 	DWORD			DP8ASize;
> #endif
> 
> 	//
> 	//	Default error returned
> 	//
> 	hrRegister = DPNERR_GENERIC;
> 
> 	//
> 	//	Get LISTEN AsyncOp parent from DirectNet object and add a RefCount
> 	//
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	if (pdnObject->pListen == NULL)
> 	{
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 		goto Exit;
> 	}
> 	pdnObject->pListen->AddRef();
> 	pParent = pdnObject->pListen;
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	//
> 	//	Lock the parent so that the child bilink list doesn't change
> 	//
> 	pParent->Lock();
> 
> 	//
> 	//	Attempt to crack each child LISTEN and inform DPNSVR of the address
> 	//
> 	pBilink = pParent->m_bilinkChildren.GetNext();
> 	while (pBilink != &pParent->m_bilinkChildren)
> 	{
> 		pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
> 		DNASSERT(pAsyncOp->GetProtocolHandle() != NULL);
> 
> 		spInfo.hEndpoint = pAsyncOp->GetProtocolHandle();
> 		spInfo.pAddress = NULL;
> 		spInfo.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;
> 
> 		if (DNPGetListenAddressInfo(pAsyncOp->GetProtocolHandle(),&spInfo) == DPN_OK)
> 		{
> 			DNASSERT(spInfo.pAddress != NULL);
> #ifdef	DEBUG
> 			DP8ASize = 512;
> 			spInfo.pAddress->lpVtbl->GetURLA(spInfo.pAddress,DP8ABuffer,&DP8ASize);
> 			DPF(4,"Listen address [%s]",DP8ABuffer);
> 
> 			// We re-try the registration to catch the case where DPNSVR is shutting
> 			// down while we are trying to register.  Unlikely but has to be handled.
> 			//
> #endif
>             for( DWORD dwRetry = 0; dwRetry < DPNSVR_REGISTER_ATTEMPTS ; dwRetry ++ )
>             {
>     			hResultCode = DPNSVR_Register( &pdnObject->dnApplicationDescription, spInfo.pAddress );
>     			if( FAILED( hResultCode ) )
>     			{
>     				if( dwRetry < DPNSVR_REGISTER_ATTEMPTS )
>     				{
> 	    				DPF( 0, "Unable to register ourselves with DPNSVR hr=0x%x, retrying", hResultCode );    				
> 	    				Sleep( DPNSVR_REGISTER_SLEEP );    				
>     				}
>     				else
>     				{
> 	    				DPF( 0, "Unable to register ourselves with DPNSVR hr=0x%x", hResultCode );
> 	    			}
>     			}
>     			else
>     			{
>     				// Return DPN_OK if we succeed even once
>     				hrRegister = hResultCode;
>     				break;
>     			}
>             }
> 			
> 			spInfo.pAddress->lpVtbl->Release(spInfo.pAddress);
> 			spInfo.pAddress = NULL;
> 		}
> 
> 		pBilink = pBilink->GetNext();
> 	}
> 
> 	pParent->Unlock();
> 
> 	pParent->Release();
> 	pParent = NULL;
> 
> Exit:
> 	DPF(4,"Returning: [0x%lx]",hrRegister);
> 	return( hrRegister );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
195c195
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
205a206,207
> 
> HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
84d83
< #include <wchar.h>
86,91d84
< #define CompareGuid(a,b)                                         \
<     (memcmp((PVOID)(a), (PVOID)(b), sizeof(GUID)))
< 
< 
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
208,210c201,205
< 		if ((hResultCode = DirectPlay8AddressCreate( &IID_IDirectPlay8Address,
<                                                      reinterpret_cast<void**>(&pAddress),
<                                                      NULL)) != S_OK)
---
> 		if ((hResultCode = CoCreateInstance(CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>(&pAddress))) != S_OK)
219,220c214,215
< 		if ((hResultCode = pAddress->lpVtbl->BuildFromURLW(	pAddress,
< 															static_cast<WCHAR*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
---
> 		if ((hResultCode = pAddress->lpVtbl->BuildFromURLA(	pAddress,
> 															static_cast<char*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
662c657
< 	if (pguidInstance && CompareGuid(pguidInstance,&GUID_NULL))
---
> 	if (pguidInstance && !UuidIsNil(pguidInstance,&rpcStatus))
673c668
< 	if (pguidApplication && CompareGuid(pguidApplication,&GUID_NULL))
---
> 	if (pguidApplication && !UuidIsNil(pguidApplication,&rpcStatus))
830c825
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
855,856c850
< 				pAddress->lpVtbl->GetURLW(pAddress,NULL,&dwAddressSize);
< 				dwAddressSize = dwAddressSize * sizeof(WCHAR);
---
> 				pAddress->lpVtbl->GetURLA(pAddress,NULL,&dwAddressSize);
860c854
< 				pAddress->lpVtbl->GetURLW(pAddress,DP8ABuffer,&DP8ASize);
---
> 				pAddress->lpVtbl->GetURLA(pAddress,DP8ABuffer,&DP8ASize);
987,988c981,982
< 		if ((hResultCode = pAddress->lpVtbl->GetURLW(pAddress,
< 													static_cast<WCHAR*>(packedBuffer.GetTailAddress()),
---
> 		if ((hResultCode = pAddress->lpVtbl->GetURLA(pAddress,
> 													static_cast<char*>(packedBuffer.GetTailAddress()),
2061c2055
< 	WCHAR					DP8ABuffer[512];
---
> 	CHAR					DP8ABuffer[512];
2095c2089
< 		(*ppAddress)->lpVtbl->GetURLW(*ppAddress,DP8ABuffer,&DP8ASize);
---
> 		(*ppAddress)->lpVtbl->GetURLA(*ppAddress,DP8ABuffer,&DP8ASize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectNet"
> 
> /*
29a37,65
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "CORE"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectNet] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNetCore"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
158a159,160
> typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
195a198,205
> //
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> //
> #define MAX_VOICE_CLIENTS	32	
> 
241a252,253
> 	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
> 
261a274,278
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnet.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,62
> 
> #endif
> 
> #endif    // !_MAC
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40a41
> #include "DNMisc.h"
43c44
< //#include "CReg.h"
---
> #include "CReg.h"
55c56,65
< // BUGBUG: [xbox] [mgere] Removed since we don't support registry
---
> 	DWORD	dwAllAppLen;
> 	WCHAR	lpwszAllAppStr[DN_FLAG_STR_LEN+1];
> 
> 	dwAllAppLen = (DN_FLAG_STR_LEN + 1) * sizeof(WCHAR);
> 	if (RegQueryValueExW(hSPKey,DN_REG_KEYNAME_ALL_APPLICATIONS,NULL,NULL,(PBYTE)lpwszAllAppStr,&dwAllAppLen) != ERROR_SUCCESS)
> 		return(FALSE);
> 
> 	if (towupper(lpwszAllAppStr[0]) == L'N')
> 		return(TRUE);
> 
70,71c80
< // BUGBUG:  [mgere] [xbox] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
73c82,92
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
75c94,97
< 	GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
> //	CServiceProvider	*pSP;
83a106,108
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
> //	pSP = NULL;
88,89c113,118
< 	hResultCode = packedBuffer.AddToBack("DirectPlay8 TCP/IP Service Provider",(strlen("DirectPlay8 TCP/IP Service Provider")+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
91,92c120,147
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = static_cast<GUID*>(packedBuffer.GetTailAddress());
---
> 	//
> 	//	Set up to enumerate
> 	//
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(5,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
94,95c149,162
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	//
> 	//	Enumerate SP's !
> 	//
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(5,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
> 		{
> 			DPF(0,"Couldn't open subentry.  Skipping [%S]", pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
96a164,255
> 		//
> 		//	GUID
> 		//
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPF(0,"SubEntry.ReadGUID failed.  Skipping [%S]", pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		//
> 		//	Attempt to instantiate SP and initialize it, to ensure that it is in fact usable.
> 		//
> 		if (!(dwFlags & DPNENUMSERVICEPROVIDERS_ALL))
> 		{
> 			hResultCode = DN_SPEnsureLoaded(pdnObject,&guid,NULL);
> 			if (hResultCode != DPN_OK)
> 			{
> 				DPF(0,"Could not load SP.  Skipping [%S]", pwszKeyName);
> 				SubEntry.Close();
> 				dwEnumIndex++;
> 				dwKeyLen = dwMaxKeyLen;
> 				hResultCode = DPN_OK; // override return code
> 				continue;
> 			}
> 			else
> 			{
> 				DN_SPRelease(pdnObject,&guid);
> 			}
> 		}
> 
> 		//
> 		//	Friendly Name
> 		//
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(5,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		DPF(5,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = static_cast<GUID*>(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
> 	//
> 	//	Success ?
> 	//
100c259
< 		DPF(7,"Buffer too small");
---
> 		DPF(5,"Buffer too small");
103c262
< 		goto Exit;
---
> 		goto Failure;
107c266,267
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
> 		hResultCode = DPN_OK;
111a272,276
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
> 	DNFree(pwszFriendlyName);
> 	pwszFriendlyName = NULL;
> 
113c278
< 	DPF(3,"Returning: [0x%lx]",hResultCode);
---
> 	DPF(4,"Returning: [0x%lx]",hResultCode);
114a280,301
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
128,132d314
< // BUGBUG
< // [mgere] [xbox] Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
214,216c396,400
< 		if ((hResultCode = DirectPlay8SPCreate( IID_IDP8ServiceProvider,
<                                                 (LPVOID*)&pDNSP,
<                                                 NULL)) != DPN_OK)
---
> 		if ((hResultCode = CoCreateInstance(*lpguidSP,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDP8ServiceProvider,
> 											(LPVOID*)&pDNSP)) != DPN_OK)
280d463
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\migration.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
68a69,71
> #include "dpnsvrq.h"
> #include "dpnsdef.h"
> #include "dpnsvlib.h"
522a526,545
> 
> 	// Register with DPNSVR
> 	if( !(pdnObject->dnApplicationDescription.dwFlags & DPNSESSION_NODPNSVR) )
> 	{
> 		BOOL	fCoUninitialize = FALSE;
> 
> 		DPF( 7, "Asking for DPNSVR to start listening for us.." );
> 
> 		if (CoInitialize(NULL) == S_OK)
> 		{
> 			fCoUninitialize = TRUE;
> 		}
> 
> 		DNRegisterWithDPNSVR(pdnObject);
> 
> 		if (fCoUninitialize)
> 		{
> 			CoUninitialize();
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\ntentry.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
56,57d55
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
365,366c363
< 		hResultCode = m_pAddress->lpVtbl->GetURLW(m_pAddress,NULL,&dwURLSize);
< 		dwURLSize = dwURLSize * sizeof(WCHAR);
---
> 		hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,NULL,&dwURLSize);
378,379c375,376
< 				if ((hResultCode = m_pAddress->lpVtbl->GetURLW(m_pAddress,
< 						static_cast<WCHAR*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
---
> 				if ((hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,
> 						static_cast<char*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
455c452,456
< 		hResultCode = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, reinterpret_cast<PVOID*>( &pAddress ), NULL);
---
> 		hResultCode = CoCreateInstance(	CLSID_DirectPlay8Address,
> 										NULL,
> 										CLSCTX_INPROC_SERVER,
> 										IID_IDirectPlay8Address,
> 										reinterpret_cast<PVOID*>(&pAddress));
462c463
< 		hResultCode = pAddress->lpVtbl->BuildFromURLW(pAddress,reinterpret_cast<WCHAR*>(pBufferStart + pdnEntryInfo->dwURLOffset));
---
> 		hResultCode = pAddress->lpVtbl->BuildFromURLA(pAddress,reinterpret_cast<char*>(pBufferStart + pdnEntryInfo->dwURLOffset));
563d563
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29
> #include "DVoice.h"
51a53
> #include "voice.h"
54a57
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
171c174
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
179a183,189
>     if( pIDP8LobbiedApplication == NULL ||
>         !DNVALID_READPTR( pIDP8LobbiedApplication, sizeof( IDirectPlay8LobbiedApplication * ) ) )
>     {
>         DPFERR( "Invalid interface pointer specified for register lobby" );
>         return DPNERR_INVALIDPOINTER;
>     }
> 
886c896,898
< 			DPF( 0, "Cannot specify NULL Host address" );
---
> 		if ( !(dwFlags & DPNENUMHOSTS_OKTOQUERYFORADDRESSING) )
> 		{
> 			DPF( 0, "Cannot specify NULL Host address without specifying DPNENUMHOSTS_OKTOQUERYFORADDRESSING" );
887a900
> 		}
943c956
<     if( dwFlags & ~(DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
---
>     if( dwFlags & ~(DPNENUMHOSTS_OKTOQUERYFORADDRESSING | DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
1643c1656
<     if( dwFlags & ~(DPNCONNECT_SYNC) )
---
>     if( dwFlags & ~(DPNCONNECT_SYNC | DPNCONNECT_OKTOQUERYFORADDRESSING) )
1944c1957
<     if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD) )
---
>     if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD | DPNSESSION_NODPNSVR) )
2193a2207
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
41c41
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\peer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
64d63
< #include <wchar.h>
115c114
< typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\server.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
58d57
< #include <wchar.h>
107c106
< typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
41,42c41
< TARGETLIBS= \
< # $(TARGETLIBS) \
---
> TARGETLIBS=$(TARGETLIBS) \
45,47c44
<            ..\..\dnaddress\daytona\obj$(BUILD_ALT_DIR)\*\dpnaddr.lib \
<            ..\..\sp\wsock\daytona\obj$(BUILD_ALT_DIR)\*\dpnwsock.lib \
< !ifdef _BUILD_FOR_WIN2000
---
>            ..\..\dpnsvr\dpnsvlib\obj$(BUILD_ALT_DIR)\*\dpnsvlib.lib \
58,63d54
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<              $(SDK_LIB_PATH)\libcntpr.lib
< !endif
76c67
< INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\protocol;..\..\common
---
> INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\protocol;..\..\common;..\..\dpnsvr\dpnsvlib;..\..\dpnsvr\inc
77a69
> 
116a109
>          ..\voice.cpp \
128c121
< C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DUNICODE
---
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
134d126
< !ifdef _BUILD_FOR_WIN2000
136,138c128
< !else
< DLLENTRY=DllMain
< !endif
---
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "DVoice.h"
47a49
> #include "voice.h"
164a167,168
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
198a203,204
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
230a237,238
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
265a274,275
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
299a310,311
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
335a348,349
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
603a618,619
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addbase.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
251d250
< /* BUGBUG: [mgere] [xbox] Removed this function.
276d274
< */  return DPNERR_UNSUPPORTED;
287,288c285,344
< // BUGBUG: [mgere] [xbox] ANSI not supported
< 	return DPNERR_UNSUPPORTED;
---
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pszAddress == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer to address.  An address must be specified" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( !DNVALID_STRING_A( pszAddress ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid string specified for address" );
> 		DP8A_RETURN( DPNERR_INVALIDSTRING );
> 	}
> 
> 	DPF( DP8A_PARAMLEVEL, "pszAddress = %s", pszAddress );
> 
> 	WCHAR *szShadowBuffer = NULL;
> 
> 	DWORD dwStrSize = 0;
> 
> 	if( pszAddress != NULL )
> 	{
> 		dwStrSize = strlen(pszAddress)+1;
> 		
> 		szShadowBuffer = new WCHAR[dwStrSize];
> 
> 		if( szShadowBuffer == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto BUILDFROMURLW_RETURN;
> 		}
> 
> 		if( FAILED( hr = STR_jkAnsiToWide( szShadowBuffer, pszAddress, dwStrSize ) )  )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting URL to ANSI hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 			goto BUILDFROMURLW_RETURN;
> 		}
> 	}
> 
> 	hr = pdp8Address->SetURL( szShadowBuffer );
> 
> BUILDFROMURLW_RETURN:
> 
> 	if( szShadowBuffer )
> 		delete [] szShadowBuffer;
> 
> 	DP8A_RETURN( hr );	
391c447
<     hr = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, (void **) &lpdp8Address, NULL);
---
>     hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER  , IID_IDirectPlay8Address, (void **) &lpdp8Address );
431,432c487,553
< // BUGBUG: [mgere] [xbox] ANSI not supported.
< 	return DPNERR_UNSUPPORTED;
---
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pdwAddressSize == NULL ||
> 	   !DNVALID_WRITEPTR( pdwAddressSize, sizeof(DWORD) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for address size" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
> 	}
> 
> 	if( *pdwAddressSize > 0 &&
> 	   (pszAddress == NULL ||
> 	    !DNVALID_WRITEPTR( pszAddress, (*pdwAddressSize) ) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for address" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	DPF( DP8A_PARAMLEVEL, "pwszAddress = 0x%x pdwAddressSize = 0x%x (%u)",
> 	     pszAddress , pdwAddressSize, *pdwAddressSize );
> 
> 	WCHAR *szShadowBuffer = NULL;
> 
> 	if( *pdwAddressSize  != 0 )
> 	{
> 		szShadowBuffer = new WCHAR[*pdwAddressSize];
> 
> 		if( szShadowBuffer == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto GETURLW_RETURN;
> 		}
> 	}
> 	else
> 	{	
> 		szShadowBuffer= NULL;
> 	}
> 
> 	hr = pdp8Address->BuildURL( szShadowBuffer, pdwAddressSize );
> 
> 	if( hr == DPN_OK )
> 	{
> 		if( FAILED( hr = STR_jkWideToAnsi( pszAddress, szShadowBuffer, *pdwAddressSize ) ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting ANSI->WIDE hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 			goto GETURLW_RETURN;
> 		}
> 	}
> 	
> GETURLW_RETURN:
> 
> 	if( szShadowBuffer != NULL )
> 		delete [] szShadowBuffer;
> 
> 	DP8A_RETURN( hr );
847c968,969
< 	   dwDataType != DPNA_DATATYPE_BINARY )
---
> 	   dwDataType != DPNA_DATATYPE_BINARY &&
> 	   dwDataType != DPNA_DATATYPE_STRING_ANSI )
866a989,1002
> 	else if( dwDataType == DPNA_DATATYPE_STRING_ANSI )
> 	{
> 		if( !DNVALID_STRING_A( (const CHAR * const) pComponentData ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Invalid string component specified" );
> 			DP8A_RETURN( DPNERR_INVALIDSTRING );
> 		}
> 
> 		if( ((strlen( (const CHAR * const) pComponentData)+1)*sizeof(char)) != dwComponentSize )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "String size and component size don't match" );
> 			DP8A_RETURN( DPNERR_INVALIDPARAM );
> 		}
> 	}
960a1097,1528
> 
> #if 0
> // Use the following code to create ANSI versions of the core functions.  (If required)
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8A_GetComponentByNameW"
> STDMETHODIMP DP8A_GetComponentByNameW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType )
> {
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
> 	HRESULT hr;
> 	CHAR *szTag;
> 	DWORD dwComponentSize = 0,
> 	        dwDataType = 0,
> 	        dwNameLen = 0;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pwszTag == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer for tag" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( pdwComponentSize == NULL ||
> 	   !DNVALID_WRITEPTR( pdwComponentSize, sizeof(DWORD)) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid Pointer to data size" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( *pdwComponentSize > 0 &&
> 	   (pComponentBuffer == NULL || !DNVALID_WRITEPTR( pComponentBuffer, *pdwComponentSize ) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer to component data" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( pdwDataType == NULL ||
> 	   !DNVALID_READPTR( pdwDataType, sizeof(DWORD)) )	
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer to data type" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( !DNVALID_STRING_W( pwszTag ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid string specified for tag" );
> 		DP8A_RETURN( DPNERR_INVALIDSTRING );				
> 	}	
> 	
> 	DPF( DP8A_PARAMLEVEL, "pwszTag = 0x%x pComponentBuffer = 0x%x, pdwComponentSize = 0x%x (%u), pdwDataType = 0x%x",
> 		pwszTag, pComponentBuffer, pdwComponentSize, *pdwComponentSize, pdwDataType );
> 
> 	dwNameLen = wcslen(pwszTag)+1;
> 
> 	szTag = new char[dwNameLen];
> 
> 	if( szTag == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Error on memory allocation" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto GETCOMPONENT_RETURN;
> 	}
> 
> 	hr = WideToAnsi( szTag, pwszTag, dwNameLen );
> 	if( FAILED( hr ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Error converting key hr=0x%x", hr );
> 		hr = DPNERR_CONVERSION;		
> 		goto GETCOMPONENT_RETURN;
> 	}
> 
> 	hr = pdp8Address->GetElement( szTag, NULL, &dwComponentSize, &dwDataType );	
> 
> 	if( hr != DPNERR_BUFFERTOOSMALL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Error calling GetElement hr=0x%x", hr );
> 		goto GETCOMPONENT_RETURN;	
> 	}
> 
> 	if( dwDataType == DPNA_DATATYPE_STRING )
> 	{
> 		if( pComponentBuffer != NULL )
> 		{
> 			*pdwComponentSize /= 2;
> 			CHAR *szTmpComponent = new char[*pdwComponentSize];
> 
> 			if( szTmpComponent == NULL )
> 			{
> 				DPF( DP8A_ERRORLEVEL, "Error allocating memory for conversion hr" );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto GETCOMPONENT_RETURN;
> 			}
> 
> 			hr = pdp8Address->GetElement( szTag, szTmpComponent, pdwComponentSize, pdwDataType );			
> 
> 			if( hr == DPN_OK )
> 			{
> 				hr = AnsiToWide( (WCHAR *) pComponentBuffer, szTmpComponent, *pdwComponentSize );
> 
> 				*pdwComponentSize *= 2;			
> 	
> 				if( FAILED( hr ) )
> 				{
> 					delete [] szTmpComponent;
> 					DPF( DP8A_ERRORLEVEL, "Error converting from ANSI to WIDE hr=0x%x", hr );
> 					hr = DPNERR_CONVERSION;
> 					goto GETCOMPONENT_RETURN;
> 				}
> 			}
> 			else
> 			{
> 				*pdwComponentSize *= 2;			
> 			}
> 
> 			delete [] szTmpComponent;
> 
> 		}
> 		else
> 		{
> 			if( pdwComponentSize != NULL )
> 				*pdwComponentSize /= 2;
> 
> 			hr = pdp8Address->GetElement( szTag, pComponentBuffer, pdwComponentSize, pdwDataType );			
> 
> 			if( pdwComponentSize != NULL )
> 				*pdwComponentSize *= 2;
> 		}
> 	}
> 	else
> 	{
> 		hr = pdp8Address->GetElement( szTag, pComponentBuffer, pdwComponentSize, pdwDataType );				
> 	}
> 
> GETCOMPONENT_RETURN:
> 
> 	if( szTag != NULL )
> 		delete [] szTag;
> 		
> 	DP8A_RETURN( hr );
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8A_GetComponentByIndexW"
> STDMETHODIMP DP8A_GetComponentByIndexW( IDirectPlay8Address *pInterface,
> 	const DWORD dwComponentID, WCHAR * pwszTag, PDWORD pdwNameLen,
> 	void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType )
> {
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
> 	HRESULT hr;
> 	CHAR *szTag;
> 	DWORD dwNameLen = 0,
> 	        dwComponentSize = 0,
> 	        dwDataType = 0;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pdwNameLen == NULL || !DNVALID_WRITEPTR( pdwNameLen, sizeof(DWORD) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for pdwNameLen" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}	
> 
> 	if( *pdwNameLen != 0 &&
> 	   (pwszTag == NULL || !DNVALID_WRITEPTR( pwszTag, *pdwNameLen*sizeof(WCHAR) ) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for pwszTag" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( pdwComponentSize == NULL || !DNVALID_WRITEPTR( pdwComponentSize, sizeof(DWORD) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for pdwComponentSize" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( *pdwComponentSize != 0 &&
> 	   (pComponentBuffer == NULL || !DNVALID_WRITEPTR( pComponentBuffer, *pdwComponentSize ) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for pwszTag" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}	
> 
> 	if( pdwDataType == NULL || !DNVALID_WRITEPTR( pdwDataType, sizeof(DWORD) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for pdwDataType" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}	
> 
> 	if( pdwNameLen != NULL &&
> 	   *pdwNameLen > 0 )
> 	{
> 		szTag = new char[*pdwNameLen];
> 
> 		dwNameLen = *pdwNameLen;
> 	}
> 	else
> 	{
> 		szTag = NULL;
> 	}
> 
> 	hr = pdp8Address->GetElement( dwComponentID, szTag, &dwNameLen, NULL, &dwComponentSize, &dwDataType );	
> 
> 	if( hr != DPNERR_BUFFERTOOSMALL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Error calling GetElement hr=0x%x", hr );
> 		goto GETCOMPONENT_RETURN;	
> 	}
> 
> 	if( dwDataType == DPNA_DATATYPE_STRING )
> 	{
> 		if( pdwComponentSize != NULL && pComponentBuffer != NULL )
> 		{
> 			*pdwComponentSize /= 2;
> 			CHAR *szTmpComponent = new char[*pdwComponentSize];
> 
> 			if( szTmpComponent == NULL )
> 			{
> 				DPF( DP8A_ERRORLEVEL, "Error allocating memory for conversion hr" );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto GETCOMPONENT_RETURN;
> 			}
> 
> 			hr = pdp8Address->GetElement( dwComponentID, szTag, pdwNameLen, szTmpComponent, pdwComponentSize, pdwDataType );			
> 
> 			if( hr == DPN_OK )
> 			{
> 				hr = AnsiToWide( (WCHAR *) pComponentBuffer, szTmpComponent, *pdwComponentSize );
> 
> 				*pdwComponentSize *= 2;			
> 	
> 				if( FAILED( hr ) )
> 				{
> 					delete [] szTmpComponent;
> 					hr = DPNERR_CONVERSION;
> 					DPF( DP8A_ERRORLEVEL, "Error converting from ANSI to WIDE hr=0x%x", hr );
> 					goto GETCOMPONENT_RETURN;
> 				}
> 			}
> 			else
> 			{
> 				*pdwComponentSize *= 2;			
> 			}
> 
> 			delete [] szTmpComponent;
> 
> 		}
> 		else
> 		{
> 			if( pdwComponentSize != NULL )
> 				*pdwComponentSize /= 2;
> 
> 			hr = pdp8Address->GetElement( dwComponentID, szTag, pdwNameLen, pComponentBuffer, pdwComponentSize, pdwDataType );			
> 
> 			if( pdwComponentSize != NULL )
> 				*pdwComponentSize *= 2;
> 		}
> 	}
> 	else
> 	{
> 		hr = pdp8Address->GetElement( dwComponentID, szTag, pdwNameLen, pComponentBuffer, pdwComponentSize, pdwDataType );				
> 	}
> 
> 	if( hr == DPN_OK )
> 	{
> 		hr = AnsiToWide( pwszTag, szTag, *pdwNameLen );
> 
> 		if( FAILED( hr ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting tag ANSI to WIDE hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 		}
> 	}
> 
> GETCOMPONENT_RETURN:
> 
> 	if( szTag != NULL )
> 		delete [] szTag;
> 		
> 	DP8A_RETURN( hr );
> 
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8A_AddComponentW"
> STDMETHODIMP DP8A_AddComponentW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, const void * const pComponentData, const DWORD dwComponentSize, const DWORD dwDataType )
> {
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
> 	HRESULT hr;
> 	DWORD dwTmpLen;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pwszTag == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer for tag string" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( pComponentData == NULL ||
> 	   !DNVALID_READPTR( pComponentData, dwComponentSize ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for component" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( !DNVALID_STRING_W( pwszTag ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid string specified for tag" );
> 		DP8A_RETURN( DPNERR_INVALIDSTRING );
> 	}
> 
> 	if( dwDataType == DPNA_DATATYPE_STRING &&
> 	   dwDataType == DPNA_DATATYPE_DWORD &&
> 	   dwDataType == DPNA_DATATYPE_GUID &&
> 	   dwDataType != DPNA_DATATYPE_BINARY )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid datatype specified" );
> 		DP8A_RETURN( DPNERR_INVALIDPARAM );
> 	}
> 
> 	if( dwDataType == DPNA_DATATYPE_STRING )
> 	{
> 		if( !DNVALID_STRING_A( (const char * const)  pComponentData ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Invalid string component specified" );
> 			DP8A_RETURN( DPNERR_INVALIDSTRING );
> 		}
> 
> 		if( (wcslen( (const WCHAR * const) pComponentData)+1)*sizeof(WCHAR) != dwComponentSize )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "String size and component size don't match" );
> 			DP8A_RETURN( DPNERR_INVALIDPARAM );
> 		}
> 	}
> 	else if( dwDataType == DPNA_DATATYPE_DWORD )
> 	{
> 		if( dwComponentSize != sizeof( DWORD ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Invalid size for DWORD component" );
> 			DP8A_RETURN( DPNERR_INVALIDPARAM );
> 		}
> 	}
> 	else if( dwDataType == DPNA_DATATYPE_GUID )
> 	{
> 		if( dwComponentSize != sizeof( GUID ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Invalid size for GUID component" );
> 			DP8A_RETURN( DPNERR_INVALIDPARAM );
> 		}	
> 	}
> 
> 	DPF( DP8A_PARAMLEVEL, "pwszTag = %x pComponentData = 0x%x dwComponentSize = %d dwDataType = %d",
> 	     pwszTag, pComponentData, dwComponentSize, dwDataType );	
> 
> 	dwTmpLen = wcslen(pwszTag)+1;
> 
> 	CHAR *pszTmpTag = new char[dwTmpLen];
> 	CHAR *pszTmpConvert = NULL;
> 
> 	if( pszTmpTag == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Out of memory" );
> 		DP8A_RETURN( DPNERR_OUTOFMEMORY );
> 	}
> 
> 	hr = WideToAnsi( pszTmpTag, pwszTag, dwTmpLen );
> 
> 	if( FAILED( hr ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Bad string for tag" );
> 		DP8A_RETURN( DPNERR_CONVERSION );		
> 	}
> 
> 	if( dwDataType == DPNA_DATATYPE_STRING )
> 	{
> 		dwTmpLen = wcslen((WCHAR *) pComponentData)+1;
> 		CHAR *pszTmpConvert = new char[dwTmpLen];
> 
> 		if( pszTmpConvert == NULL )
> 		{
> 			delete [] pszTmpConvert;
> 			DPF( DP8A_ERRORLEVEL, "Out of memory" );
> 			DP8A_RETURN( DPNERR_OUTOFMEMORY );		
> 		}
> 
> 		hr = WideToAnsi( pszTmpConvert, (WCHAR *) pComponentData, dwTmpLen );
> 
> 		if( FAILED( hr ) )
> 		{
> 			delete [] pszTmpTag;
> 			delete [] pszTmpConvert;
> 			DPF( DP8A_ERRORLEVEL, "Bad string for component" );
> 			DP8A_RETURN( DPNERR_GENERIC );
> 		}
> 		
> 		hr = pdp8Address->SetElement( pszTmpTag, pszTmpConvert, dwTmpLen, dwDataType );
> 
> 		delete [] pszTmpConvert;
> 	}
> 	else
> 	{
> 		hr = pdp8Address->SetElement( pszTmpTag, pComponentData, dwComponentSize, dwDataType );
> 	}
> 
> 	delete [] pszTmpTag;
> 
> 	DP8A_RETURN( hr );
> }
> 
> 
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
36a37
> #include <stdio.h>
37a39
> #include "dplegacy.h"
39d40
< #include <wchar.h>
356a358,376
> 	case DPNA_DATATYPE_STRING_ANSI:
>         wszUnicodeString = new WCHAR[dwRealDataSize];
>         if( wszUnicodeString == NULL )
>         {
>             DPF( 0, "Error allocating memory for conversion" );
>             return DPNERR_OUTOFMEMORY;
>         }
> 
> 		hr = STR_jkAnsiToWide( wszUnicodeString, (const char * const) pvData, dwRealDataSize );
> 
> 		if( FAILED( hr ) )
> 		{
> 		    DPF( 0, "Error unable to convert element ANSI->Unicode 0x%x", hr );
>             return DPNERR_CONVERSION;
> 		}
> 		pvRealData = wszUnicodeString;
> 	    dwRealDataSize = dwDataSize*sizeof(WCHAR);
> 		dwRealDataType = DPNA_DATATYPE_STRING;
> 	    break;
380a401,412
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     hr= SetSP( &CLSID_DP8SP_IPX );
>                 }
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_MODEMPROVIDER ) == 0 )
>                 {
>                     hr = SetSP( &CLSID_DP8SP_MODEM );
>                 }
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_SERIALPROVIDER ) == 0 )
>                 {
>                     hr = SetSP( &CLSID_DP8SP_SERIAL );
>                 }
1317a1350,1415
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ADDRESSOBJECT::SetDirectPlay4Address"
> HRESULT DP8ADDRESSOBJECT::SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize )
> {
>     PBYTE pbCurrentLocation;
>     PDPADDRESS pdpAddressChunk;
>     LONG lRemaining;
>     HRESULT hr = DPN_OK;
>     DWORD dwCurrentChunkSize;
> 
> 	if( IsLocked() )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
> 		return DPNERR_NOTALLOWED;
> 	}
> 
>     // XBOX! This function will not be required on XBOX.  Have it return DPNERR_NOTSUPPORTED
>     ENTERLOCK();
> 
>     hr = Clear();
> 
>     if( FAILED( hr ) )
>     {
>         DPF( 0, "Failed to clear old address data hr=[0x%lx]", hr );
>         LEAVELOCK();
>         return hr;
>     }
> 
>     pbCurrentLocation = (PBYTE) pvDataBuffer;
>     lRemaining = dwDataSize;
> 
>     while( lRemaining > 0 )
>     {
>         pdpAddressChunk = (PDPADDRESS) pbCurrentLocation;
> 
>         if( sizeof( DPADDRESS ) > lRemaining )
>         {
>             DPF( 0, "Error parsing address, unexpected end of address" );
>             return DPNERR_INVALIDADDRESSFORMAT;
>         }
> 
>         dwCurrentChunkSize = sizeof( DPADDRESS ) + pdpAddressChunk->dwDataSize;
> 
>         if( ((LONG) (dwCurrentChunkSize + pdpAddressChunk->dwDataSize)) > lRemaining )
>         {
>             DPF( 0, "Error parsing address, unexpected end during data" );
>             return DPNERR_INVALIDADDRESSFORMAT;
>         }
> 
>         hr = AddDP4Element( pdpAddressChunk, this );
> 
>         if( FAILED( hr ) )
>         {
>             DPF( 0, "Error adding next element" );
>             break;
>         }
> 
>         lRemaining -= dwCurrentChunkSize;
> 
>         pbCurrentLocation += dwCurrentChunkSize;
>     }
> 
>     LEAVELOCK();
> 
>     return hr;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
125a126,127
>     HRESULT SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addparse.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
26c26
< #include <wchar.h>
---
> #include <stdio.h>
556,557d555
< // BUGBUG: [mgere] [xbox] Removed wtol temporarily until it is implemented on xbox
< //		dwTmpValue = _wtol( m_pwszCurrentValue );
558a557,558
> 		dwTmpValue = _wtol( m_pwszCurrentValue );
> 
565,566d564
< // BUGBUG: [mgere] [xbox] Removed swscanf temporarily until it is implemented on xbox
< /*
591d588
< */
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addtcp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
730a731,841
> #if 0
> // Use these functions to build ANSI versions of above
> typedef	STDMETHODIMP DP8ATCP_GetComponentByNameA( IDirectPlay8AddressIP *pInterface, const CHAR * const pszTag, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType );
> typedef	STDMETHODIMP DP8ATCP_GetComponentByIndexA( IDirectPlay8AddressIP *pInterface, const DWORD dwComponentID, CHAR * pszTag, PDWORD pdwNameLen, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType );
> typedef	STDMETHODIMP DP8ATCP_AddComponentA( IDirectPlay8AddressIP *pInterface, const CHAR * const pszTag, const void * const pComponentData, const DWORD dwComponentSize, const DWORD dwDataType );
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ATCP_BuildAddressW"
> STDMETHODIMP DP8ATCP_BuildAddressW( IDirectPlay8AddressIP *pInterface, const WCHAR * const pwszAddress, const USHORT usPort )
> {
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 	
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );
> 
> 	LPSTR pszShadowAddress = NULL;
> 
> 	if( pwszAddress != NULL )
> 	{
> 		pszShadowAddress = new char[wcslen(pwszAddress)+1];
> 
> 		if( pszShadowAddress == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Out of memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto BUILDADDRESSW_EXIT;
> 		}
> 
> 		hr = WideToAnsi( pszShadowAddress, pwszAddress, wcslen(pwszAddress)+1 );
> 
> 		if( FAILED( hr ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting Address to ANSI hr=0x%x", hr );
> 			hr = DPNERR_GENERIC;
> 			goto BUILDADDRESSW_EXIT;
> 		}
> 	}
> 
> 	hr = DP8ATCP_BuildAddressA( pInterface, pszShadowAddress, usPort );
> 
> BUILDADDRESSW_EXIT:
> 
> 	if( pszShadowAddress != NULL )
> 		delete [] pszShadowAddress;
> 
> 	return hr;
> 	
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ATCP_GetAddressW"
> STDMETHODIMP DP8ATCP_GetAddressW( IDirectPlay8AddressIP *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressLength, PUSHORT pusPort )
> {
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 	
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );
> 
> 	LPSTR pszShadowAddress = NULL;
> 	DWORD dwShadowAddressSize = 0;
> 
> 	if( pwszAddress != NULL && pdwAddressLength != NULL )
> 	{
> 		pszShadowAddress = new char[*pdwAddressLength];
> 
> 		if( pszShadowAddress == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Out of memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto GETADDRESSW_EXIT;
> 		}
> 	}
> 
> 	hr = DP8ATCP_GetAddressA( pInterface, pszShadowAddress, pdwAddressLength, pusPort );
> 
> 	if( hr == DPN_OK )
> 	{
> 		hr = AnsiToWide( pwszAddress, pszShadowAddress, *pdwAddressLength );
> 
> 		if( FAILED( hr ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Unable to convert name to Wide hr=0x%x", hr );
> 			goto GETADDRESSW_EXIT;
> 		}
> 	}
> 
> GETADDRESSW_EXIT:
> 
> 	if( pszShadowAddress != NULL )
> 		delete [] pszShadowAddress;
> 
> 	return hr;
> }
> 
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
31c31
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
24a25,31
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DPNAddress"
> 
> /*
31a39,67
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNAddress"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNAddress"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnaddr.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address \0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,61
> 
> #endif
> 
> #endif    // !_MAC
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
43c43
< !ifdef _BUILD_FOR_WIN2000
---
> 	   $(BASEDIR)\public\sdk\lib\*\wsock32.lib \
46d45
< 	   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib  \
53,60c52
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\winsockx.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib
< !endif
---
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
91a84
>          ..\dplegacy.cpp \
98c91
< C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DUNICODE
---
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
103d95
< !ifdef _BUILD_FOR_WIN2000
105,107c97
< !else
< DLLENTRY=DllMain
< !endif
---
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
63a64,75
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
> // {826F86D1-AE2C-4428-A66F-974381B25F5B}
> DEFINE_GUID(IID_IDirectPlay8AddressModem,
> 0x826f86d1, 0xae2c, 0x4428, 0xa6, 0x6f, 0x97, 0x43, 0x81, 0xb2, 0x5f, 0x5b);
> 
> // {59BE79FE-A96A-4710-9BD2-22A50E7B24BD}
> DEFINE_GUID(IID_IDirectPlay8AddressSerial,
> 0x59be79fe, 0xa96a, 0x4710, 0x9b, 0xd2, 0x22, 0xa5, 0xe, 0x7b, 0x24, 0xbd);
> 
71a84,86
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
> typedef struct IDirectPlay8AddressSerial  	*PDIRECTPLAY8ADDRESSSERIAL, *LPDIRECTPLAY8ADDRESSSERIAL;
> typedef struct IDirectPlay8AddressModem		*PDIRECTPLAY8ADDRESSMODEM, *LPDIRECTPLAY8ADDRESSMODEM;
87a103
> #define DPNA_DATATYPE_STRING_ANSI           0x00000005
348a365,400
> // values for baud rate
> #define DPNA_BAUD_RATE_110					L"110"
> #define DPNA_BAUD_RATE_300					L"300"
> #define DPNA_BAUD_RATE_600					L"600"
> #define DPNA_BAUD_RATE_1200					L"1200"
> #define DPNA_BAUD_RATE_2400					L"2400"
> #define DPNA_BAUD_RATE_4800					L"4800"
> #define DPNA_BAUD_RATE_9600					L"9600"
> #define DPNA_BAUD_RATE_14400				L"14400"
> #define DPNA_BAUD_RATE_19200				L"19200"
> #define DPNA_BAUD_RATE_38400				L"38400"
> #define DPNA_BAUD_RATE_56000				L"56000"
> #define DPNA_BAUD_RATE_57600				L"57600"
> #define DPNA_BAUD_RATE_115200				L"115200"
> #define DPNA_BAUD_RATE_128000				L"128000"
> #define DPNA_BAUD_RATE_256000				L"256000"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE					L"1"
> #define DPNA_STOP_BITS_ONE_FIVE				L"1.5"
> #define DPNA_STOP_BITS_TWO					L"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE					L"NONE"
> #define DPNA_PARITY_EVEN					L"EVEN"
> #define DPNA_PARITY_ODD						L"ODD"
> #define DPNA_PARITY_MARK					L"MARK"
> #define DPNA_PARITY_SPACE					L"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE				L"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF			L"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS				L"RTS"
> #define DPNA_FLOW_CONTROL_DTR				L"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR			L"RTSDTR"
> 
350a403,405
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
352a408,470
> //// ANSI DEFINITIONS
> 
> // Header
> #define DPNA_HEADER_A						"x-directplay:/"
> #define DPNA_SEPARATOR_KEYVALUE_A			'='
> #define DPNA_SEPARATOR_USERDATA_A			'#'
> #define DPNA_SEPARATOR_COMPONENT_A			';'
> #define DPNA_ESCAPECHAR_A					'%'
> 
> // key names for address components
> #define DPNA_KEY_APPLICATION_INSTANCE_A		"applicationinstance"
> #define DPNA_KEY_BAUD_A						"baud"
> #define DPNA_KEY_DEVICE_A					"device"
> #define DPNA_KEY_FLOWCONTROL_A				"flowcontrol"
> #define DPNA_KEY_HOSTNAME_A					"hostname"
> #define DPNA_KEY_PARITY_A					"parity"
> #define DPNA_KEY_PHONENUMBER_A				"phonenumber"
> #define DPNA_KEY_PORT_A						"port"
> #define DPNA_KEY_PROGRAM_A					"program"
> #define DPNA_KEY_PROVIDER_A					"provider"
> #define DPNA_KEY_STOPBITS_A					"stopbits"
> 
> // values for baud rate
> #define DPNA_BAUD_RATE_110_A				"110"
> #define DPNA_BAUD_RATE_300_A				"300"
> #define DPNA_BAUD_RATE_600_A				"600"
> #define DPNA_BAUD_RATE_1200_A				"1200"
> #define DPNA_BAUD_RATE_2400_A				"2400"
> #define DPNA_BAUD_RATE_4800_A				"4800"
> #define DPNA_BAUD_RATE_9600_A				"9600"
> #define DPNA_BAUD_RATE_14400_A				"14400"
> #define DPNA_BAUD_RATE_19200_A				"19200"
> #define DPNA_BAUD_RATE_38400_A				"38400"
> #define DPNA_BAUD_RATE_56000_A				"56000"
> #define DPNA_BAUD_RATE_57600_A				"57600"
> #define DPNA_BAUD_RATE_115200_A				"115200"
> #define DPNA_BAUD_RATE_128000_A				"128000"
> #define DPNA_BAUD_RATE_256000_A				"256000"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE_A				"1"
> #define DPNA_STOP_BITS_ONE_FIVE_A			"1.5"
> #define DPNA_STOP_BITS_TWO_A				"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE_A					"NONE"
> #define DPNA_PARITY_EVEN_A					"EVEN"
> #define DPNA_PARITY_ODD_A					"ODD"
> #define DPNA_PARITY_MARK_A					"MARK"
> #define DPNA_PARITY_SPACE_A					"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE_A			"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF_A 		"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS_A				"RTS"
> #define DPNA_FLOW_CONTROL_DTR_A				"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR_A			"RTSDTR"
> 
> // Shortcut values
> #define DPNA_VALUE_TCPIPPROVIDER_A          "IP"
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
> #define DPNA_VALUE_MODEMPROVIDER_A          "MODEM"
> #define DPNA_VALUE_SERIALPROVIDER_A         "SERIAL"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
99,100d98
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
148a147,155
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {6D4A3650-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_MODEM, 0x6d4a3650, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {743B5D60-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_SERIAL, 0x743b5d60, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
172a180,182
> typedef struct IDirectPlay8LobbiedApplication	*PDNLOBBIEDAPPLICATION;
> typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
> 
633a644
> #define	DPNCONNECT_OKTOQUERYFORADDRESSING	0x0001
638a650
> #define	DPNENUMHOSTS_OKTOQUERYFORADDRESSING	0x0001
737a750
> #define DPNSESSION_NODPNSVR					0x0040
804c817
< 	STDMETHOD(RegisterLobby)			(THIS_ PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
849c862
< 	STDMETHOD(RegisterLobby)			(THIS_ PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
899c912
< 	STDMETHOD(RegisterLobby)			(THIS_ PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpsp8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
53a54
> #define DPNSPF_OKTOQUERY			0x00000002		// OK for SP to ask the user for clarification on addresses
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\backend.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
202d201
< 				ASSERT(pMSD->hCommand == Handle);
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
107c107
< 	DNASSERT( ulFlags == 0 );
---
> 	DNASSERT( ( ulFlags & ~( DPNCONNECT_OKTOQUERYFORADDRESSING ) ) == 0 );
108a109,113
> 	if ( ( ulFlags & DPNCONNECT_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		ConnData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\enum.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
149c149,154
< 	DNASSERT( ( dwFlags & ~( DPNENUMHOSTS_NOBROADCASTFALLBACK ) ) == 0 );
---
> 	DNASSERT( ( dwFlags & ~( DPNENUMHOSTS_OKTOQUERYFORADDRESSING | DPNENUMHOSTS_NOBROADCASTFALLBACK ) ) == 0 );
> 	if ( ( dwFlags & DPNENUMHOSTS_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		EnumData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\initialize.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
352c352
< 		if((pSPD->hSendEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL){
---
> 		if((pSPD->hSendEvent = CreateEventA(NULL, FALSE, FALSE, NULL)) == NULL){
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
80c80
< C_DEFINES= $(C_DEFINES) /D_LIB /DWIN32 /D_MT /DCINTERFACE /DMICHAEL /DUNICODE
---
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE /DMICHAEL
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\timer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
549c549
< 	hWorkToDoSem=CreateSemaphore(NULL,0,65535,NULL);
---
> 	hWorkToDoSem=CreateSemaphoreA(NULL,0,65535,NULL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
195,196c195,225
< // BUGBUG: [mgere] [xbox]  Removed all code in here.  I don't believe it's necessary anymore and it was using some COM functions that we don't have.
< 	return S_OK;
---
>     HRESULT		hr;
>     HINSTANCE	hdll;
>     LPGPCLASSFACTORY	pcf;
> 
> 
>     pcf = (LPGPCLASSFACTORY) This;
> 
>     /*
>      * call CoLockObjectExternal
>      */
>     hr = E_UNEXPECTED;
>     hdll = LoadLibraryA( "OLE32.DLL" );
>     if( hdll != NULL )
>     {
>         PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;
> 
> 
> 		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, "CoLockObjectExternal" ) );
>         if( lpCoLockObjectExternal != NULL )
>         {
>             hr = lpCoLockObjectExternal( (LPUNKNOWN) This, fLock, TRUE );
>         }
>         else
>         {
>         }
>     }
>     else
>     {
>     }
> 
> 	return hr;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
30a38,66
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNSPWinsock"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectDPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNSPWinsock"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
114a116,135
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( dwDebugLevel, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> #include "resource.h"
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> #include "resource.h"
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a25
> #endif //_WIN32
3a27,34
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a36,51
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnwsock.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a60,142
> 
> #endif
> 
> #endif    // !_MAC
> 
> #ifdef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // TEXTINCLUDE
> //
> 
> 1 TEXTINCLUDE DISCARDABLE
> BEGIN
>     "resource.h\0"
> END
> 
> 2 TEXTINCLUDE DISCARDABLE
> BEGIN
>     "#include ""afxres.h""\r\n"
>     "\0"
> END
> 
> 3 TEXTINCLUDE DISCARDABLE
> BEGIN
>     "\r\n"
>     "\0"
> END
> 
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // Dialog
> //
> 
> IDD_IP_SETTINGS DIALOG DISCARDABLE  0, 0, 194, 66
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
> CAPTION "Enter host name"
> FONT 8, "MS Shell Dlg"
> BEGIN
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
> END
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // DESIGNINFO
> //
> 
> #ifdef APSTUDIO_INVOKED
> GUIDELINES DESIGNINFO DISCARDABLE
> BEGIN
>     IDD_IP_SETTINGS, DIALOG
>     BEGIN
>         LEFTMARGIN, 7
>         RIGHTMARGIN, 187
>         TOPMARGIN, 7
>         BOTTOMMARGIN, 59
>     END
> END
> #endif    // APSTUDIO_INVOKED
> 
> #endif    // English (U.S.) resources
> /////////////////////////////////////////////////////////////////////////////
> 
> 
> 
> #ifndef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 3 resource.
> //
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> #endif    // not APSTUDIO_INVOKED
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock1.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,42c1,67
< #define p_accept accept
< #define p_bind bind
< #define p_closesocket closesocket
< #define p_connect connect
< #define p_gethostbyaddr gethostbyaddr
< #define p_gethostbyname gethostbyname
< #define p_gethostname gethostname
< #define p_getpeername getpeername
< #define p_getprotobyname getprotobyname
< #define p_getprotobynumber getprotobynumber
< #define p_getservbyname getservbyname
< #define p_getservbyport getservbyport
< #define p_getsockname getsockname
< #define p_getsockopt getsockopt
< #define p_htonl htonl
< #define p_htons htons
< #define p_inet_addr inet_addr
< #define p_inet_ntoa inet_ntoa
< #define p_ioctlsocket ioctlsocket
< #define p_listen listen
< #define p_ntohl ntohl
< #define p_ntohs ntohs
< #define p_recv recv
< #define p_recvfrom recvfrom
< #define p_select select
< #define p_send send
< #define p_sendto sendto
< #define p_setsockopt setsockopt
< #define p_shutdown shutdown
< #define p_socket socket
< //#define p_WSAAsyncGetHostByAddr WSAAsyncGetHostByAddr
< //#define p_WSAAsyncGetHostByName WSAAsyncGetHostByName
< //#define p_WSAAsyncGetProtoByName WSAAsyncGetProtoByName
< //#define p_WSAAsyncGetProtoByNumber WSAAsyncGetProtoByNumber
< //#define p_WSAAsyncGetServByName WSAAsyncGetServByName
< //#define p_WSAAsyncGetServByPort WSAAsyncGetServByPort
< //#define p_WSAAsyncSelect WSAAsyncSelect
< //#define p_WSACancelAsyncRequest WSACancelAsyncRequest
< #define p_WSACleanup WSACleanup
< #define p_WSAGetLastError WSAGetLastError
< #define p_WSASetLastError WSASetLastError
< #define p_WSAStartup WSAStartup
---
> //
> // DWNSOCK1.INC	Macros for dynamically linking to WinSock 1.1
> //
> 
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	//
> 	// Function available in both versions
> 	//
> 	DYNAMICWINSOCK(accept, LPFN_ACCEPT);
> 	DYNAMICWINSOCK(bind, LPFN_BIND);
> 	DYNAMICWINSOCK(closesocket, LPFN_CLOSESOCKET);
> 	DYNAMICWINSOCK(connect, LPFN_CONNECT);
> 	DYNAMICWINSOCK(gethostbyaddr, LPFN_GETHOSTBYADDR);
> 	DYNAMICWINSOCK(gethostbyname, LPFN_GETHOSTBYNAME);
> 	DYNAMICWINSOCK(gethostname, LPFN_GETHOSTNAME);
> 	DYNAMICWINSOCK(getpeername, LPFN_GETPEERNAME);
> 	DYNAMICWINSOCK(getprotobyname, LPFN_GETPROTOBYNAME);
> 	DYNAMICWINSOCK(getprotobynumber, LPFN_GETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(getservbyname, LPFN_GETSERVBYNAME);
> 	DYNAMICWINSOCK(getservbyport, LPFN_GETSERVBYPORT);
> 	DYNAMICWINSOCK(getsockname, LPFN_GETSOCKNAME);
> 	DYNAMICWINSOCK(getsockopt, LPFN_GETSOCKOPT);
> 	DYNAMICWINSOCK(htonl, LPFN_HTONL);
> 	DYNAMICWINSOCK(htons, LPFN_HTONS);
> 	DYNAMICWINSOCK(inet_addr, LPFN_INET_ADDR);
> 	DYNAMICWINSOCK(inet_ntoa, LPFN_INET_NTOA);
> 	DYNAMICWINSOCK(ioctlsocket, LPFN_IOCTLSOCKET);
> 	DYNAMICWINSOCK(listen, LPFN_LISTEN);
> 	DYNAMICWINSOCK(ntohl, LPFN_NTOHL);
> 	DYNAMICWINSOCK(ntohs, LPFN_NTOHS);
> 	DYNAMICWINSOCK(recv, LPFN_RECV);
> 	DYNAMICWINSOCK(recvfrom, LPFN_RECVFROM);
> 	DYNAMICWINSOCK(select, LPFN_SELECT);
> 	DYNAMICWINSOCK(send, LPFN_SEND);
> 	DYNAMICWINSOCK(sendto, LPFN_SENDTO);
> 	DYNAMICWINSOCK(setsockopt, LPFN_SETSOCKOPT);
> 	DYNAMICWINSOCK(shutdown, LPFN_SHUTDOWN);
> 	DYNAMICWINSOCK(socket, LPFN_SOCKET);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByAddr, LPFN_WSAASYNCGETHOSTBYADDR);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByName, LPFN_WSAASYNCGETHOSTBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByName, LPFN_WSAASYNCGETPROTOBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByNumber, LPFN_WSAASYNCGETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(WSAAsyncGetServByName, LPFN_WSAASYNCGETSERVBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetServByPort, LPFN_WSAASYNCGETSERVBYPORT);
> 	DYNAMICWINSOCK(WSAAsyncSelect, LPFN_WSAASYNCSELECT);
> 	DYNAMICWINSOCK(WSACancelAsyncRequest, LPFN_WSACANCELASYNCREQUEST);
> 	DYNAMICWINSOCK(WSACleanup, LPFN_WSACLEANUP);
> 	DYNAMICWINSOCK(WSAGetLastError, LPFN_WSAGETLASTERROR);
> 	DYNAMICWINSOCK(WSASetLastError, LPFN_WSASETLASTERROR);
> 	DYNAMICWINSOCK(WSAStartup, LPFN_WSASTARTUP);
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock2.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,27c1,3
< #ifdef UNICODE
< //	#define p_WSAAddressToString				WSAAddressToStringW
< //	#define p_WSADuplicateSocket				WSADuplicateSocketW
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersW
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsW
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoW
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdW
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassW
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginW
< //	#define p_WSALookupServiceNext				WSALookupServiceNextW
< //	#define p_WSASetService						WSASetServiceW
< //	#define p_WSASocket							WSASocketW
< //	#define p_WSAStringToAddress				WSAStringToAddressW
< #else
< //	#define p_WSAAddressToString				WSAAddressToStringA
< //	#define p_WSADuplicateSocket				WSADuplicateSocketA
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersA
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsA
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoA
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdA
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassA
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginA
< //	#define p_WSALookupServiceNext				WSALookupServiceNextA
< //	#define p_WSASetService						WSASetServiceA
< //	#define p_WSASocket							WSASocketA
< //	#define p_WSAStringToAddress				WSAStringToAddressA
< #endif // UNICODE
---
> //
> // DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
> //
29,53c5,70
< //#define p_WSAAccept WSAAccept
< #define p_WSACloseEvent WSACloseEvent
< //#define p_WSAConnect WSAConnect
< #define p_WSACreateEvent WSACreateEvent
< #define p_WSAEnumNetworkEvents WSAEnumNetworkEvents
< #define p_WSAEventSelect WSAEventSelect
< #define p_WSAGetOverlappedResult WSAGetOverlappedResult
< //#define p_WSAGetQOSByName WSAGetQOSByName
< //#define p_WSAHtonl WSAHtonl
< //#define p_WSAHtons WSAHtons
< #define p_WSAIoctl WSAIoctl
< //#define p_WSAJoinLeaf WSAJoinLeaf
< //#define p_WSALookupServiceEnd WSALookupServiceEnd
< //#define p_WSANtohl WSANtohl
< //#define p_WSANtohs WSANtohs
< #define p_WSARecv WSARecv
< //#define p_WSARecvDisconnect WSARecvDisconnect
< #define p_WSARecvFrom WSARecvFrom
< //#define p_WSARemoveServiceClass WSARemoveServiceClass
< #define p_WSAResetEvent WSAResetEvent
< #define p_WSASend WSASend
< //#define p_WSASendDisconnect WSASendDisconnect
< #define p_WSASendTo WSASendTo
< #define p_WSASetEvent WSASetEvent
< #define p_WSAWaitForMultipleEvents WSAWaitForMultipleEvents
---
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	DYNAMICWINSOCK(WSAAccept, LPFN_WSAACCEPT);
> 	DYNAMICWINSOCK(WSAAddressToStringA, LPFN_WSAADDRESSTOSTRINGA);
> 	DYNAMICWINSOCK(WSAAddressToStringW, LPFN_WSAADDRESSTOSTRINGW);
> 	DYNAMICWINSOCK(WSACloseEvent, LPFN_WSACLOSEEVENT);
> 	DYNAMICWINSOCK(WSAConnect, LPFN_WSACONNECT);
> 	DYNAMICWINSOCK(WSACreateEvent, LPFN_WSACREATEEVENT);
> 	DYNAMICWINSOCK(WSADuplicateSocketA, LPFN_WSADUPLICATESOCKETA);
> 	DYNAMICWINSOCK(WSADuplicateSocketW, LPFN_WSADUPLICATESOCKETW);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersA, LPFN_WSAENUMNAMESPACEPROVIDERSA);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersW, LPFN_WSAENUMNAMESPACEPROVIDERSW);
> 	DYNAMICWINSOCK(WSAEnumNetworkEvents, LPFN_WSAENUMNETWORKEVENTS);
> 	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
> 	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
> 	DYNAMICWINSOCK(WSAEventSelect, LPFN_WSAEVENTSELECT);
> 	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
> 	DYNAMICWINSOCK(WSAGetQOSByName, LPFN_WSAGETQOSBYNAME);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoA, LPFN_WSAGETSERVICECLASSINFOA);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoW, LPFN_WSAGETSERVICECLASSINFOW);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdA, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdW, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW);
> 	DYNAMICWINSOCK(WSAHtonl, LPFN_WSAHTONL);
> 	DYNAMICWINSOCK(WSAHtons, LPFN_WSAHTONS);
> 	DYNAMICWINSOCK(WSAInstallServiceClassA, LPFN_WSAINSTALLSERVICECLASSA);
> 	DYNAMICWINSOCK(WSAInstallServiceClassW, LPFN_WSAINSTALLSERVICECLASSW);
> 	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
> 	DYNAMICWINSOCK(WSAJoinLeaf, LPFN_WSAJOINLEAF);
> 	DYNAMICWINSOCK(WSALookupServiceBeginA, LPFN_WSALOOKUPSERVICEBEGINA);
> 	DYNAMICWINSOCK(WSALookupServiceBeginW, LPFN_WSALOOKUPSERVICEBEGINW);
> 	DYNAMICWINSOCK(WSALookupServiceEnd, LPFN_WSALOOKUPSERVICEEND);
> 	DYNAMICWINSOCK(WSALookupServiceNextA, LPFN_WSALOOKUPSERVICENEXTA);
> 	DYNAMICWINSOCK(WSALookupServiceNextW, LPFN_WSALOOKUPSERVICENEXTW);
> 	DYNAMICWINSOCK(WSANtohl, LPFN_WSANTOHL);
> 	DYNAMICWINSOCK(WSANtohs, LPFN_WSANTOHS);
> 	DYNAMICWINSOCK(WSARecv, LPFN_WSARECV);
> 	DYNAMICWINSOCK(WSARecvDisconnect, LPFN_WSARECVDISCONNECT);
> 	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
> 	DYNAMICWINSOCK(WSARemoveServiceClass, LPFN_WSAREMOVESERVICECLASS);
> 	DYNAMICWINSOCK(WSAResetEvent, LPFN_WSARESETEVENT);
> 	DYNAMICWINSOCK(WSASend, LPFN_WSASEND);
> 	DYNAMICWINSOCK(WSASendDisconnect, LPFN_WSASENDDISCONNECT);
> 	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
> 	DYNAMICWINSOCK(WSASetEvent, LPFN_WSASETEVENT);
> 	DYNAMICWINSOCK(WSASetServiceA, LPFN_WSASETSERVICEA);
> 	DYNAMICWINSOCK(WSASetServiceW, LPFN_WSASETSERVICEW);
> 	DYNAMICWINSOCK(WSASocketA, LPFN_WSASOCKETA);
> 	DYNAMICWINSOCK(WSASocketW, LPFN_WSASOCKETW);
> 	DYNAMICWINSOCK(WSAStringToAddressA, LPFN_WSASTRINGTOADDRESSA);
> 	DYNAMICWINSOCK(WSAStringToAddressW, LPFN_WSASTRINGTOADDRESSW);
> 	DYNAMICWINSOCK(WSAWaitForMultipleEvents, LPFN_WSAWAITFORMULTIPLEEVENTS);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
101a103
> 	m_hActiveSettingsDialog( NULL ),
128a131
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
361a365,372
> 		//
> 		// cancel any active dialogs
> 		// if there are no dialogs, cancel the active command
> 		//
> 		if ( m_hActiveSettingsDialog != NULL )
> 		{
> 			StopSettingsDialog( m_hActiveSettingsDialog );
> 		}
364a376,382
> 	else
> 	{
> 		//
> 		// there should be no active dialog if there isn't an active command
> 		//
> 		DNASSERT( m_hActiveSettingsDialog == NULL );
> 	}
798a817,823
> 	if ( m_hActiveSettingsDialog != NULL )
> 	{
> 		StopSettingsDialog( m_hActiveSettingsDialog );
> 		Unlock();
> 	}
> 	else
> 	{
804a830
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
281a282,288
> 		// UI functions
> 		//
> 		virtual	HRESULT	ShowSettingsDialog( CThreadPool *const pThreadPool ) = 0;
> 		virtual	void	StopSettingsDialog( const HWND hDlg ) = 0;
> 		virtual	void	SettingsDialogComplete( const HRESULT hr ) = 0;
> 
> 		//
300a308,309
> 
> 		HWND			m_hActiveSettingsDialog;		// handle of active settings dialog
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
43a45
> #include	"IPXAddress.h"
80c82,83
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
98a102,103
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
113a119,120
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 ),
185a193,198
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
206a220,226
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
210a231,253
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
235a279,280
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
266a312,313
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
297a345,350
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
439a493,499
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
442a503,526
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
474a559,560
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
494a581,582
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
127a128,130
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
157a161
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
158a163
> 
192a198,200
> 
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
81a83
> const DWORD	g_dwIPBroadcastAddressSize = sizeof( g_IPBroadcastAddress );
101,103d102
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
< 
590c589
< 	hr = DirectPlay8AddressCreate( &IID_IDirectPlay8AddressIP, reinterpret_cast<void**>( &pIPAddress ), NULL);
---
> 	hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8AddressIP, reinterpret_cast<void**>( &pIPAddress ) );
740c739
< 	hr = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ), NULL);
---
> 	hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ) );
805c804
< 	hr = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ), NULL);
---
> 	hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ) );
870c869
< 	hr = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ), NULL);
---
> 	hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ) );
971,973d969
< // BUGBUG: [mgere] [xbox] No need to enum adapters anymore since we only have one.
< // need to complete the removal of this functionality at a later date.
< /*
1274d1269
< */	return DPNERR_UNSUPPORTED;
1454a1450,1455
> 	//
> 	// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1455a1457,1475
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1458a1479,1481
> 		case 2:
> 		default:
> 		{
1459a1483,1485
> 			break;
> 		}
> 	}
1529a1556,1561
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1530a1563,1581
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1533a1585,1587
> 		case 2:
> 		default:
> 		{
1534a1589,1591
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
38a40
> #include	"StrUtils.h"
50a53
> #include	"IPUI.h"
93a97
> 	memset( m_TempHostName, 0x00, sizeof( m_TempHostName ) );
115a120,341
> // CIPEndpoint::ShowSettingsDialog - show dialog for settings
> //
> // Entry:		Pointer to thread pool
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CIPEndpoint::ShowSettingsDialog( CThreadPool *const pThreadPool )
> {
> 	HRESULT	hr;
> 
> 
> 	DNASSERT( pThreadPool != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	AddRef();
> 	hr = pThreadPool->SpawnDialogThread( DisplayIPHostNameSettingsDialog, &m_hActiveSettingsDialog, this );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to start IP hostname dialog!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:	
> 	DecRef();
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::SettingsDialogComplete - dialog has completed
> //
> // Entry:		Error code for dialog
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::SettingsDialogComplete( const HRESULT hDialogResult )
> {
> 	HRESULT					hr;
> 	HRESULT					hTempResult;
> 	IDirectPlay8Address		*pBaseAddress;
> 	DWORD					dwTotalAddressBufferSize;
> 	char					*pTempAddressString;
> 	WCHAR					WCharHostName[ sizeof( m_TempHostName ) + 1 ];
> 	DWORD					dwWCharHostNameSize;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = hDialogResult;
> 	pBaseAddress = NULL;
> 
> 	pTempAddressString = NULL;
> 
> 	//
> 	// since the dialog is exiting, clear our handle to the dialog
> 	//
> 	m_hActiveSettingsDialog = NULL;
> 
> 	//
> 	// dialog failed, fail the user's command
> 	//
> 	if ( hr != DPN_OK )
> 	{
> 		if ( hr != DPNERR_USERCANCEL)
> 		{
> 			DPF( 0, "Failing endpoint hostname dialog!" );
> 			DisplayErrorCode( 0, hr );
> 
> 		}
> 
> 		goto Failure;
> 	}
> 
> 	//
> 	// The dialog completed OK, rebuild remote address and complete command
> 	//
> 
> 	//
> 	// get the base DNADDRESS
> 	//
> 	pBaseAddress = m_pRemoteMachineAddress->DP8AddressFromSocketAddress();
> 	if ( pBaseAddress == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "SettingsDialogComplete: Failed to get base address when completing IP hostname dialog!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// Add the new 'HOSTNAME' parameter to the address.  If the hostname is blank
> 	// and this is an enum, copy the broadcast hostname.
> 	//
> 	if ( ( m_TempHostName[ 0 ] == '\0' ) && ( m_EndpointType == ENDPOINT_TYPE_ENUM ) )
> 	{
> 		DNASSERT( sizeof( WCharHostName ) >= g_dwIPBroadcastAddressSize );
> 		memcpy( WCharHostName, g_IPBroadcastAddress, g_dwIPBroadcastAddressSize );
> 		dwWCharHostNameSize = g_dwIPBroadcastAddressSize;
> 	}
> 	else
> 	{
> 		dwWCharHostNameSize = LENGTHOF( WCharHostName );
> 		hr = STR_AnsiToWide( m_TempHostName, -1, WCharHostName, &dwWCharHostNameSize );
> 		DNASSERT( hr == DPN_OK );
> 		dwWCharHostNameSize *= sizeof( WCHAR );
> 	}
> 
> 	hr = IDirectPlay8Address_AddComponent( pBaseAddress, DPNA_KEY_HOSTNAME, WCharHostName, dwWCharHostNameSize, DPNA_DATATYPE_STRING );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "SettingsDialogComplete: Failed to add hostname to address!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// set the address
> 	//
> 	hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pBaseAddress, SP_ADDRESS_TYPE_HOST );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to rebuild DNADDRESS when completing IP hostname dialog!" );
> 		DNASSERT( FALSE );
> 		goto Failure;
> 	}
> 
> 	//
> 	// the remote machine address has been adjusted, finish the command
> 	//
> 	switch ( m_EndpointType )
> 	{
> 		case ENDPOINT_TYPE_ENUM:
> 		{
> 			hr = CompleteEnumQuery();
> 			if ( hr != DPN_OK )
> 			{
> 				DPF( 0, "Problem completing EnumQuery after asking user for hostname!" );
> 				DisplayDNError( 0, hr );
> 			}
> 
> 			break;
> 		}
> 
> 		case ENDPOINT_TYPE_CONNECT:
> 		{
> 			hr = CompleteConnect();
> 			if ( hr != DPN_OK )
> 			{
> 				DPF( 0, "Problem completing Connect after asking user for hostname!" );
> 				DisplayDNError( 0, hr );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			hr = DPNERR_GENERIC;
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pBaseAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DNASSERT( pTempAddressString == NULL );
> 	if ( pBaseAddress != NULL )
> 	{
> 		DNFree( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DecRef();
> 
> 	return;
> 
> Failure:
> 	//
> 	// close this endpoint
> 	//
> 	Close( hr );
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::StopSettingsDialog - stop an active settings dialog
> //
> // Entry:		Handle of dialog to close
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::StopSettingsDialog( const HWND hDlg)
> {
> 	StopIPHostNameSettingsDialog( hDlg );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
215a442
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
261,262d487
< 
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
22a23,24
> #define	TEMP_HOSTNAME_LENGTH	100
> 
52a55,67
> 		// UI functions
> 		//
> 		HRESULT		ShowSettingsDialog( CThreadPool *const pThreadPool );
> 		void		SettingsDialogComplete( const HRESULT hr );
> 		void		StopSettingsDialog( const HWND hDlg );
> 		void		SetTempHostName( const char *const pHostName, const UINT_PTR uHostNameLength )
> 		{
> 			DNASSERT( pHostName[ uHostNameLength ] == '\0' );
> 			DNASSERT( ( uHostNameLength + 1 ) <= LENGTHOF( m_TempHostName ) );
> 			memcpy( m_TempHostName, pHostName, ( uHostNameLength + 1 ) );
> 		}
> 
> 		//
69a85
> 		char		m_TempHostName[ TEMP_HOSTNAME_LENGTH ];
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
49a51
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
81a85
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
83a88
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
173a179,185
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
192a205,221
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
> 	
317a347,353
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
327a364,369
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
419a462,494
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
429a505,520
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
59a62,63
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
61a66
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\rsip.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38a39
> #include	"Registry.h"
510a512,515
> 
> 		hr = GetGatewayFromRegistry( reinterpret_cast<BYTE*>( gwipaddr ), sizeof( gwipaddr ) );
> 
> 		if(hr != DPN_OK){
512a518,520
> 		}
> 
> 		DPF(0,"Found suggested RSIP gateway in registry %s, running on Win95?\n",gwipaddr);
649d656
<         WCHAR wszIPHLPAPI[] = { wchar_t("IPHLPAPI.DLL") };
685c692
< 	hIpHlpApi = LoadLibrary(wszIPHLPAPI);
---
> 	hIpHlpApi = LoadLibrary("IPHLPAPI.DLL");
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
257a259,266
> 	
> 	//
> 	// Winsock 2 functionality always exists on WinNT.  If we're on Win9x, we can
> 	// only use Winsock2 interfaces for TCP.
> 	//
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) ||
> 		 ( ( LOWORD( GetWinsockVersion() ) >= 2 ) && ( m_pSPData->GetType() == TYPE_IP ) ) )
> 	{
258a268,272
> 	}
> 	else
> 	{
> 		m_pSendFunction = Winsock1Send;
> 	}
404a419,430
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( ( LOWORD( GetWinsockVersion() ) == 1 ) ||
> 			 ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_pSPData->GetType() == TYPE_IPX ) ) )
> 		{
> 			m_pSPData->GetThreadPool()->RemoveSocketPort( this );
> 		}
> 
833a860,872
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
835a875,971
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ),	// pointer to receive buffer
> 								pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize,		// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();
> 
> Exit:
> 	return;
> }
836a973,975
> 
> 
> //**********************************************************************
837a977,1122
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
864,865c1149,1150
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
876a1162,1164
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
929a1218,1220
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1003c1294,1295
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1017a1310,1312
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1075a1371,1372
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1109a1407,1408
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1154a1454,1455
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1720a2022,2028
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1765a2074,2137
> 			break;
> 		}
> 
> 		//
> 		// Win9x.
> 		// If this is not an IPX socket and Winsock 2 (or greater) is available,
> 		// call the Winsock 2 read function.  If this is IPX or we're stuck with
> 		// Winsock 1, inform the thread pool as such.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 
> 			if ( ( LOWORD( GetWinsockVersion() ) >= 2 ) &&
> 				 ( m_pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// we're using Winsock2, call for two outstanding reads per socket.
> 				//
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #1 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #2 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 			}
> 			else
> 			{
> 				DNASSERT( m_pSPData != NULL );
> 				hr = m_pSPData->GetThreadPool()->AddSocketPort( this );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Failed to add to active socket list!" );
> 					DisplayDNError( 0, hr );
> 					goto Failure;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2388a2761,2917
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
> 
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			goto Exit;
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();	
> 	DecRef();
> 
> 	return;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
238a239
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
244a246,248
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
287a292
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
43,44d42
<            ..\..\..\dnaddress\daytona\obj$(BUILD_ALT_DIR)\*\dpnaddr.lib \
< !ifdef _BUILD_FOR_WIN2000
47d44
< 	   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib \
54,61c51
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<            $(BASEDIR)\public\sdk\lib\*\winsockx.lib
< !endif
---
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
70a61,71
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
91a93
> 	 ..\DWinsock.cpp \
95a98,100
> 	 ..\IPUI.cpp \
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
98a104
>          ..\Registry.cpp \
112c118
< C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /DDNWSock_EXPORTS /DCINTERFACE /DUNICODE
---
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNWSock_EXPORTS /DCINTERFACE
114,115d119
< MSC_OPTIMIZATION=/Odi /Zi
< NTDEBUGTYPE=both
119d122
< !ifdef _BUILD_FOR_WIN2000
121,123c124
< !else
< DLLENTRY=DllMain
< !endif
---
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
104c104
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
122c122,123
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
158c159,160
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
241a244
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
242a246
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
245c249
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
252c256
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
279a284
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
47a49
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
223a227,256
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
> 			DPF( 8, "WinNT detected!" );
> 			break;
> 		}
> 
> 		//
> 		// Windows 95, 98
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DPF( 8, "Win9x detected!" );
> 			break;
> 		}
> 
> 		// other version (unsupported!)
> //		case VER_PLATFORM_WIN32_CE:
> 		case VER_PLATFORM_WIN32s:
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
577a611,616
> 		case TYPE_IPX:
> 		{
> 			pReturn = CreateIPXEndpoint( &EndpointPoolContext );
> 			break;
> 		}
> 
746a786,791
> 		case TYPE_IPX:
> 		{
> 			pReturn = CreateIPXAddress();
> 			break;
> 		}
> 
777a823,828
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
114a116,138
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
121a146,156
> //
> // structure passed to dialog threads
> //
> typedef	struct	_DIALOG_THREAD_PARAM
> {
> 	DIALOG_FUNCTION	*pDialogFunction;
> 	HWND			*phDialog;
> 	void			*pContext;
> 	CThreadPool		*pThisThreadPool;
> } DIALOG_THREAD_PARAM;
> 
226c261,268
< 	DEBUG_ONLY( 
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
228c270,271
< 	)
---
> 						break;
> 					}
229a273,280
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
236c287,294
< 	DEBUG_ONLY(
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
238c296,297
< 	)
---
> 						break;
> 					}
239a299,306
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
273a341,347
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
330a405,409
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( DNGetOSType() )
> 	{
333a413,414
> 		case VER_PLATFORM_WIN32_NT:
> 		{
339a421,447
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
368a477,478
> 	SYSTEM_INFO		SystemInfo;
> 	UINT_PTR		uDesiredThreads;
375a486,490
> 	//
> 	// get machine information
> 	//
> 	memset( &SystemInfo, 0x00, sizeof( SystemInfo ) );
> 	GetSystemInfo( &SystemInfo );
395a511,517
> 	uDesiredThreads = ( SystemInfo.dwNumberOfProcessors * 2 ) + 2;
> 	DNASSERT( uDesiredThreads != 0 );
> 	while ( uDesiredThreads > 0 )
> 	{
> 		uDesiredThreads--;
> 		StartNTCompletionThread();
> 	}
397,401d518
<     StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 
426a544,689
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	//
> 	// Win9x requires completion events for Winsock2.  Always allocate the events
> 	// even though the they might not be used because the network layer might
> 	// only support Winsock1.
> 	//
> 	DNASSERT( m_hWinsock2SendComplete == NULL );
> 	m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 										   TRUE,	// manual reset
> 										   FALSE,	// start unsignalled
> 										   NULL		// pointer to name (none)
> 										   );
> 	if ( m_hWinsock2SendComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Send!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 	m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 											  TRUE,		// manual reset
> 											  FALSE,	// start unsignalled
> 											  NULL		// pointer to name (none)
> 											  );
> 	if ( m_hWinsock2ReceiveComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Receive!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	m_iTotalThreadCount++;
> 	
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		m_iTotalThreadCount--;
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
535a799,800
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
556a822
> 	}
634a901,905
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
651a923,924
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
796a1070
> 	m_IPXReadIODataPool.Deinitialize();
844d1117
< 			
848a1122,1130
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			break;
> 		}
> 
> 		//
926a1209,1217
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1181a1473,1474
> 	switch ( DNGetOSType() )
> 	{
1184a1478,1479
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1201a1497,1525
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( m_JobQueue.SignalPendingJob() == FALSE )
> 			{
> 				hr = DPNERR_OUTOFMEMORY;
> 				DPF( 0, "Failed to signal pending job!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1312a1637,1638
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1319a1646
> 	}
1521a1849,1949
> // CThreadPool::SpawnDialogThread - start a secondary thread to display service
> //		provider UI.
> //
> // Entry:		Pointer to dialog function
> //				Pointer destination for copy of dialog handle
> //				Dialog context
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext )
> {
> 	HRESULT	hr;
> 	HANDLE	hDialogThread;
> 	DIALOG_THREAD_PARAM		*pThreadParam;
> 	DWORD	dwThreadID;
> 
> 
> 	DNASSERT( pDialogFunction != NULL );
> 	DNASSERT( phDialog != NULL );
> 	DNASSERT( pDialogContext != NULL );		// why would anyone not want a dialog context??
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pThreadParam = NULL;
> 
> 	//
> 	// create and initialize thread param
> 	//
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( DNMalloc( sizeof( *pThreadParam ) ) );
> 	if ( pThreadParam == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for dialog thread!" );
> 		goto Failure;
> 	}
> 
> 	pThreadParam->pDialogFunction = pDialogFunction;
> 	pThreadParam->phDialog = phDialog;
> 	pThreadParam->pContext = pDialogContext;
> 	pThreadParam->pThisThreadPool = this;
> 
> 	//
> 	// assume that a thread will be created
> 	//
> 	m_iTotalThreadCount++;
> 
> 	//
> 	// create thread
> 	//
> 	hDialogThread = CreateThread( NULL,					// pointer to security (none)
> 								  0,					// stack size (default)
> 								  DialogThreadProc,		// thread procedure
> 								  pThreadParam,			// thread param
> 								  0,					// creation flags (none)
> 								  &dwThreadID );		// pointer to thread ID
> 	if ( hDialogThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// decrement active thread count and report error
> 		//
> 		m_iTotalThreadCount--;
> 		
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to start dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		goto Failure;
> 	}
>   								
> 	if ( CloseHandle( hDialogThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing handle from create dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:
> 	if ( pThreadParam != NULL )
> 	{
> 		DNFree( pThreadParam );
> 		pThreadParam = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
1541a1970,1971
> 	switch ( DNGetOSType() )
> 	{
1542a1973,1982
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
1544a1985,1986
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1546a1989,1990
> 			break;
> 		}
1547a1992,2001
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1576a2031,2032
> 	switch ( DNGetOSType() )
> 	{
1577a2034,2041
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1583a2048,2049
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1623a2090,2102
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1703a2183,2330
> // CThreadPool::AddSocketPort - add a socket to the Win9x watch list
> //
> // Entry:		Pointer to SocketPort
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::AddSocketPort( CSocketPort *const pSocketPort )
> {
> 	HRESULT	hr;
> 	BOOL	fSocketAdded;
> 
> 	
> 	DNASSERT( pSocketPort != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	fSocketAdded = FALSE;
> 
> 	Lock();
> 
> 	//
> 	// We're capped by the number of sockets we can use for Winsock1.  Make
> 	// sure we don't allocate too many sockets.
> 	//
> 	if ( m_uReservedSocketCount == FD_SETSIZE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "There are too many sockets allocated on Winsock1!" );
> 		goto Failure;
> 	}
> 
> 	m_uReservedSocketCount++;
> 	
> 	DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 	m_pSocketPorts[ m_SocketSet.fd_count ] = pSocketPort;
> 	m_SocketSet.fd_array[ m_SocketSet.fd_count ] = pSocketPort->GetSocket();
> 	m_SocketSet.fd_count++;
> 	fSocketAdded = TRUE;
> 
> 	//
> 	// add a reference to note that this socket port is being used by the thread
> 	// pool
> 	//
> 	pSocketPort->AddRef();
> 
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when adding socket port to active list!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> Exit:
> 	Unlock();
> 	
> 	return	hr;
> 
> Failure:
> 	if ( fSocketAdded != FALSE )
> 	{
> 		AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
> 		m_SocketSet.fd_count--;
> 		m_pSocketPorts[ m_SocketSet.fd_count ] = NULL;
> 		m_SocketSet.fd_array[ m_SocketSet.fd_count ] = NULL;
> 		fSocketAdded = FALSE;
> 	}
> 
> 	m_uReservedSocketCount--;
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::RemoveSocketPort - remove a socket from the Win9x watch list
> //
> // Entry:		Pointer to socket port to remove
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::RemoveSocketPort( CSocketPort *const pSocketPort )
> {
> 	UINT_PTR	uIndex;
> 
> 
> 	DNASSERT( pSocketPort != NULL );
> 	
> 	Lock();
> 
> 	uIndex = m_SocketSet.fd_count;
> 	DNASSERT( uIndex != 0 );
> 	while ( uIndex != 0 )
> 	{
> 		uIndex--;
> 
> 		if ( m_pSocketPorts[ uIndex ] == pSocketPort )
> 		{
> 			m_uReservedSocketCount--;
> 			m_SocketSet.fd_count--;
> 
> 			memmove( &m_pSocketPorts[ uIndex ],
> 					 &m_pSocketPorts[ uIndex + 1 ],
> 					 ( sizeof( m_pSocketPorts[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			memmove( &m_SocketSet.fd_array[ uIndex ],
> 					 &m_SocketSet.fd_array[ uIndex + 1 ],
> 					 ( sizeof( m_SocketSet.fd_array[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			//
> 			// clear last entry which is now unused
> 			//
> 			memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) );
> 			memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) );
> 
> 			//
> 			// end the loop
> 			//
> 			uIndex = 0;
> 		}
> 	}
> 
> 	Unlock();
> 	
> 	pSocketPort->DecRef();
> 
> 	//
> 	// It's really not necessary to signal a new job here because there were
> 	// active sockets on the last iteration of the Win9x thread.  That means the
> 	// Win9x thread was in a polling mode to check for sockets and the next time
> 	// through it will notice that there is a missing socket.  By signalling the
> 	// job event we reduce the time needed for the thread to figure out that the
> 	// socket is gone.
> 	//
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when removeing socket port to active list!" );
> 	}
> }
> //**********************************************************************
> 
> 
> 
> //**********************************************************************
> // ------------------------------
1850a2478,3023
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 	
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> //	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> //	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 	
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 	
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		DWORD	dwWaitReturn;
> 
> 		
> 		//
> 		// Update the job time so we know how long to wait.  We can
> 		// only get here if a socket was just added to the socket list, or
> 		// we've been servicing sockets.
> 		//
> 		DNTimeGet( &CurrentTime );
> 		if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 		{
> 			pThisThreadPool->LockTimerData();
> 			CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																		   &CoreData.NextTimerJobTime );
> 			if ( CoreData.fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 			}
> 			pThisThreadPool->UnlockTimerData();
> 		}
> 
> 		DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 		dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 
> 		//
> 		// Check for Winsock1 sockets.  If there are some around, do a quick poll
> 		// of them to check of I/O before entering the main Winsock2 loop for
> 		// the real timing.
> 		//
> 		pThisThreadPool->Lock();
> 		if ( pSocketSet->fd_count != 0 )
> 		{
> 			pThisThreadPool->Unlock();
> 
> 			pThisThreadPool->CheckWinsock1IO( pSocketSet );
> 			
> 			//
> 			// since there are Winsock1 sockets active, don't spend a lot of
> 			// time waiting for something to happen for Winsock2
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				dwMaxWaitTime = SelectTimeslice;
> 			}
> 		}
> 		else
> 		{
> 			pThisThreadPool->Unlock();
> 		}
> 
> 
> 		//
> 		// Check Winsock2 sockets.
> 		//
> 		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> 												 CoreData.hWaitHandles,					// handles to wait on
> 												 FALSE,									// don't wait for all to be signalled
> 												 dwMaxWaitTime,							// wait timeout
> 												 TRUE									// we're alertable for APCs
> 												 );
> 		switch ( dwWaitReturn )
> 		{
> 			//
> 			// timeout, don't do anything, we'll probably process timer jobs on
> 			// the next loop
> 			//
> 			case WAIT_TIMEOUT:
> 			{
> 				break;
> 			}
> 
> 			//
> 			// New job.  Account for the time spent in the wait.  Don't
> 			// account for time after the job is complete because it's
> 			// possible that the job was an job submission which will want
> 			// to reset the wait time.
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 			{
> 				DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 				pThisThreadPool->ProcessWin9xJob( &CoreData );
> 				break;
> 			}
> 
> 			//
> 			// SP closing
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 			{
> 				DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 				fLooping = FALSE;
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 send complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending write list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Failed to reset Winsock2 send event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> 				pThisThreadPool->CompleteOutstandingSends();
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 receive complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending read list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Failed to reset Winsock2 receive event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> 				pThisThreadPool->CompleteOutstandingReceives();
> 				break;
> 			}
> 
> 			//
> 			// There are I/O completion routines scheduled on this thread.
> 			// This is not a good thing!
> 			//
> 			case WAIT_IO_COMPLETION:
> 			{
> 				DPF( 1, "WARNING: APC was serviced on the Win9x IO service thread!  What is the application doing??" );
> 				break;
> 			}
> 
> 			//
> 			// wait failed
> 			//
> 			case WAIT_FAILED:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Wait failed!" );
> 				DisplayDNError( 0, dwError );
> 				break;
> 			}
> 
> 			//
> 			// problem
> 			//
> 			default:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Unknown problem in wait!" );
> 				DisplayDNError( 0, dwError );
> 				DNASSERT( FALSE );
> 				break;
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
1878a3052,3084
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			DPF( 0, "Failed to initialize COM!" );
> 			break;
> 		}
> 	}
> 
> 	//
2008a3215,3216
> 	CoUninitialize();
> 
2160a3369,3718
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::DialogThreadProc - thread proc for spawning dialogs
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> // ------------------------------
> DWORD WINAPI	CThreadPool::DialogThreadProc( void *pParam )
> {
> 	const DIALOG_THREAD_PARAM	*pThreadParam;
> 
> 
> 	//
> 	// Initialize COM.  If this fails, we'll have problems later.
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
> 	DNASSERT( pParam != NULL );
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( pParam );
> 	
> 	pThreadParam->pDialogFunction( pThreadParam->phDialog, pThreadParam->pContext );
> 
> 	pThreadParam->pThisThreadPool->DecrementActiveThreadCount();
> 	DNFree( pParam );
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// Remove and process a single job from the list.  If there is no job, skip
> 	// to the end of the function.
> 	//
> 	pJobInfo = GetWorkItem();
> 
> 	if ( pJobInfo == NULL )
> 	{
> 		goto Exit;
> 	}
> 
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> 
> Exit:
> 	return;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CheckWinsock1IO - check the IO status for Winsock1 sockets
> //
> // Entry:		Pointer to sockets to watch
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CheckWinsock1IO( const FD_SET *const pWinsock1Sockets )
> {
> static	const TIMEVAL	SelectNoTime = { 0 };
> 	INT			iSelectReturn;
> 	FD_SET		ReadSocketSet;
> 	FD_SET		WriteSocketSet;
> 	FD_SET		ErrorSocketSet;
> 
> 
> 	//
> 	// Make a local copy of all of the sockets.  This isn't totally
> 	// efficient, but it works.  Multiplying by active socket count will
> 	// spend half the time in the integer multiply.
> 	//
> 	Lock();
> 	memcpy( &ReadSocketSet, pWinsock1Sockets, sizeof( ReadSocketSet ) );
> 	memcpy( &WriteSocketSet, pWinsock1Sockets, sizeof( WriteSocketSet ) );
> 	memcpy( &ErrorSocketSet, pWinsock1Sockets, sizeof( ErrorSocketSet ) );
> 	Unlock();
> 
> 	//
> 	// Don't check write sockets here because it's very likely that they're ready
> 	// for service but have no outgoing data and will thrash
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  &ReadSocketSet,	// sockets to check for read
> 							  NULL,				// sockets to check for write (none)
> 							  &ErrorSocketSet,	// sockets to check for error
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// select got pissed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// WSAENOTSOCK = This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting all sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing read service and error service.
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 			ServiceWinsock1Sockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Since writes are likely to be ready, check for them separately
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  NULL,				// sockets to check for read (don't check reads)
> 							  &WriteSocketSet,	// sockets to check for write
> 							  NULL,				// sockets to check for error (don't check errors)
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// select got pissed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// this socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting write sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing write service
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 			break;
> 		}
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ServiceWinsock1Sockets - service requests on Winsock1 sockets ports
> //
> // Entry:		Pointer to set of sockets
> //				Pointer to service function
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction )
> {
> 	UINT_PTR	uWaitingSocketCount;
> 	UINT_PTR	uSocketPortCount;
> 	CSocketPort	*pSocketPorts[ FD_SETSIZE ];
> 
> 
> 	uSocketPortCount = 0;
> 	uWaitingSocketCount = pSocketSet->fd_count;
> 	
> 	Lock();
> 	while ( uWaitingSocketCount > 0 )
> 	{
> 		UINT_PTR	uIdx;
> 
> 
> 		uWaitingSocketCount--;
> 		uIdx = m_SocketSet.fd_count;
> 		while ( uIdx != 0 )
> 		{
> 			uIdx--;
> 			if ( pSocketSet->fd_array[ uWaitingSocketCount ] == m_SocketSet.fd_array[ uIdx ] )
> 			{
> 				//
> 				// this socket is still available, add a reference to the socket
> 				// port and keep it around to be processed outside of the lock
> 				//
> 				pSocketPorts[ uSocketPortCount ] = m_pSocketPorts[ uIdx ];
> 				pSocketPorts[ uSocketPortCount ]->AddRef();
> 				uSocketPortCount++;
> 				uIdx = 0;
> 			}
> 		}
> 	}
> 	Unlock();
> 
> 	while ( uSocketPortCount != 0 )
> 	{
> 		uSocketPortCount--;
> 		
> 		//
> 		// call the service function and remove the reference
> 		//
> 		(pSocketPorts[ uSocketPortCount ]->*pServiceFunction)();
> 		pSocketPorts[ uSocketPortCount ]->DecRef();
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
65a67
> typedef	void	DIALOG_FUNCTION( HWND *const phDialog, void *const pDialogContext );
97c99,100
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
143a147
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
148a153
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
155a161,163
> 		HRESULT	AddSocketPort( CSocketPort *const pSocketPort );
> 		void	RemoveSocketPort( CSocketPort *const pSocketPort );
> 
166a175,176
> 		HRESULT	SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext );
> 
199a210
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
264a276
> 		HRESULT	Win9xInit( void );
274a287,288
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
275a290
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
277a293
> 		static	DWORD WINAPI	DialogThreadProc( void *pParam );
283c299,302
< 		void	ServiceSockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );
---
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
> 
> 		void	CheckWinsock1IO( const FD_SET *const pWinsock1Sockets );
> 		void	ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
13a14,15
> #include <WSIPX.h>
> 
71c73,102
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
> 	DNSP_QueryInterface,
> 	DNSP_AddRef,
> 	DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Close,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
132a164,220
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to pointer to SP interface
> //				Pointer to pointer to associated SP data
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP, CSPData **const ppSPData )
> {
> 	HRESULT 	hr;
> 	CSPData		*pSPData;
> 
> 
> 	DNASSERT( ppiDNSP != NULL );
> 	DNASSERT( ppSPData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pSPData = NULL;
> 	*ppiDNSP = NULL;
> 	*ppSPData = NULL;
> 
> 	//
> 	// create main data class
> 	//
> 	hr = CreateSPData( &pSPData, &CLSID_DP8SP_IPX, TYPE_IPX, &ipxInterface );
> 	if ( hr != DPN_OK )
> 	{
> 		DNASSERT( pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( pSPData != NULL );
> 	*ppiDNSP = pSPData->COMInterface();
> 	*ppSPData = pSPData;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( pSPData != NULL )
> 	{
> 		pSPData->DecRef();
> 		pSPData = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
219a308,310
> 	//
> 	// we can either create an IPX instance or an IP instance
> 	//
225a317,320
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP, &pSPData );
> 	}
266c361
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return ( IsEqualCLSID( rclsid, CLSID_DP8SP_TCPIP ) || IsEqualCLSID( rclsid, CLSID_DP8SP_IPX ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
22a24
> #include	"DWinsock.h"
48,51d49
< // provides us winsock1/2 support
< #include "dwnsock1.inc"
< #include "dwnsock2.inc"
< 
78a77,78
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
> 
103a104
> 	INT		iVersion;
129c130
< 	// initialize Winsock
---
> 	// initialize the bindings to Winsock
131,137c132,133
< 	WORD wVersionRequested;
< 	WSADATA wsaData;
< 	int nRet;
< 
< 	wVersionRequested = MAKEWORD(2,2);
< 	nRet = p_WSAStartup(wVersionRequested, &wsaData);
< 	if (nRet || wVersionRequested != wsaData.wVersion)
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
139,141c135,137
< 		DPF( 0, "Problem starting winsock!" );
< 	    fReturn = FALSE;
< 	    goto Failure;
---
> 		DPF( 0, "Problem binding dynamic winsock functions!" );
> 		fReturn = FALSE;
> 		goto Failure;
143d138
< 
145a141,142
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
155c152,160
< 		p_WSACleanup();
---
> 		BOOL	fFreeReturn;
> 
> 
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 		if ( fFreeReturn == FALSE )
> 		{
> 			DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 		}
> 
185a191,193
> 	BOOL	fFreeReturn;
> 
> 
189c197,201
< 	p_WSACleanup();
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 	if ( fFreeReturn == FALSE )
> 	{
> 		DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 	}
196a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
197a223
> 
283a310
> 	INT_PTR iWinsockVersion;
293a321
> 	iWinsockVersion = GetWinsockVersion();
306c334
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize();
458d485
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
47a48,49
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22
> #include	<WSIPX.h>
93,94d93
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
164a164,167
>  	switch ( pSPData->GetType() )
> 	{
> 		case TYPE_IP:
> 		{
166a170,185
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			DPF( 9, "Attempting to create IPX datagram socket." );
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
231a251
> 		case TYPE_IPX:
316a337
> 	IDirectPlay8Address		*pSPOnlyAddress;
324c345
< 	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );
---
> 	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );
340a362
> 	pSPOnlyAddress = NULL;
378a401,448
> 		HRESULT	hTempResult;
> 		GUID	SPGuid;
> 
> 
> 		//
> 		// get the SP
> 		//
> 		hTempResult = IDirectPlay8Address_GetSP( pDeviceAddress, &SPGuid );
> 		switch ( hTempResult )
> 		{
> 			//
> 			// no problem
> 			//
> 			case DPN_OK:
> 			{
> 				DNASSERT( hr == DPNERR_PENDING );
> 				break;
> 			}
> 
> 			//
> 			// pass these errors throug
> 			//
> 			case DPNERR_OUTOFMEMORY:
> 			{
> 				hr = hTempResult;
> 				goto Failure;
> 				break;
> 			}
> 
> 			//
> 			// remap other errors to addressing errors
> 			//
> 			default:
> 			{
> 				hr = DPNERR_ADDRESSING;
> 				goto Failure;
> 				break;
> 			}
> 		}
> 
> 		//
> 		// The host address is NULL, if we're using TCPIP and we're not allowed to query,
> 		// use the broadcast address.  If we're on IPX, use the broadcast address.
> 		//
> 		if ( ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
> 		{
380a451,498
> 		}
>         else
>         {
> 			HRESULT	hTempResult;
> 
> 
> 			//
> 			// Need to build address with just the SP guid.  Get it from the
> 			// device address.
> 			//
> 			DNASSERT( pSPOnlyAddress == NULL );
> 			hTempResult = CoCreateInstance( CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>( &pSPOnlyAddress ) );
> 			if ( hTempResult != S_OK )
> 			{
> 				DPF( 0, "Failed to create SP-Only address when non was supplied!" );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			hTempResult = IDirectPlay8Address_SetSP( pSPOnlyAddress, &SPGuid );
> 			switch ( hTempResult )
> 			{
> 				//
> 				// set SP, no problem
> 				//
> 				case DPN_OK:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// failed to set SP, map error to an addressing error
> 				//
> 				default:
> 				{
> 					hr = DPNERR_ADDRESSING;
> 					goto Failure;
> 
> 					break;
> 				}
> 			}
> 
> 			pHostAddress = pSPOnlyAddress;
> 		}
512a631,663
> 			if ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) != 0 ) &&
> 				 ( pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// Copy the connect data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since the dialog is being popped, this command is in progress,
> 				// not pending.
> 				//
> 				DNASSERT( pSPData != NULL );
> 
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				pEndpoint->CopyEnumQueryData( pEnumQueryData );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for enum query!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove our reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
526a678,679
> 			}
> 
599a753,758
> 	if ( pSPOnlyAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pSPOnlyAddress );
> 		pSPOnlyAddress = NULL;
> 	}
> 
770c929
< 	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
---
> 	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
974a1134,1162
> 			if ( ( pConnectData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
> 			{
> 				//
> 				// Copy the connect data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since a dialog is being displayed, the command is in-progress,
> 				// not pending.
> 				//
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				pEndpoint->CopyConnectData( pConnectData );
> 				if ( ( hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() ) ) != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for connect!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove our reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
975a1164,1165
> 			}
> 
1232c1422
< 	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
---
> 	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
1438a1629,1661
> 			if ( ( pListenData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
> 			{
> 				//
> 				// Copy the listen data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since this endpoint is being handed off to another thread,
> 				// make sure it's in the unbound list.  Since a dialog is being
> 				// displayed, the command state is in progress, not pending.
> 				//
> 				DNASSERT( pSPData != NULL );
> 
> 				pEndpoint->CopyListenData( pListenData );
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for listen!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove out reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
1439a1663,1664
> 			}
> 
2400a2626,2637
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2617a2855,2866
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\06121445.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\dndbg.c	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dndbg.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dneterrors.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\guidutil.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	1ece02cc	6bb05875
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\appdesc.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\client.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\connect.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\migration.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\ntentry.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\peer.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\server.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addbase.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\addparse.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addtcp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpsp8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\backend.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\protocol\connect.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\protocol\enum.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\initialize.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\timer.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\classfac.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock1.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock2.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\rsip.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.def	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
-- 83 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\callstack.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\memlog.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\dnmisc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\dpguid.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04241015.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04261045.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05010945.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05021600.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05031030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05081300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05091400.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05111530.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05121300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05151130.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05161345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05221345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05231030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06021030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06121345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\lastsync.bat	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\dplegacy.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\dplegacy.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dpnsvr\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvlib.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvlib.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvrq.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvrq.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpnsvr.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpsvr8.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpsvr8.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\proctbl.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\proctbl.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\inc\dpnsdef.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\inc\dpnsvmsg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\inc\dplobby8.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\classfac.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\comstuff.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dllmain.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dnlobby.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplapp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplapp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplclient.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplclient.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplcommon.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplcommon.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconnect.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconnect.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplmsgq.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplmsgq.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby8int.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplparam.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplparam.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplproc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplproc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplreg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplreg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\globals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\handles.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\handles.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\contextfixedpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\registry.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\registry.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 193 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
3a4
>       lobby \
5c6,7
<       core
---
>       core \
>       dpnsvr 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
29a37,65
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "UNKNOWN_MODULE"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectNet] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNetDebug"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dndbg.c)---()---()---()---()---()---()---()---()---()---()  
.  
.  
30a31
> #include "memlog.h"
36a38,183
> /*******************************************************************************
> 	Debug Logging to VXD.  In order to get this logging, DNET.VXD must be
> 	installed on the system.  This service is only available in the Win9x code
> 	base and can be installed by added the following to the system.ini file
> 	in the 386Enh section
> 
> 	[386Enh]
> 	device=dnet.vxd
> 
> 	This will enable a set of command under the debugger for dumping the
> 	log when broken into the debugger.  The commands can be initiated by
> 	typing .dnet at the ## prompt in the debugger.
> ==============================================================================*/
> /*
> BOOL DeviceIoControl(
> HANDLE hDevice, 			// handle to device of interest
> DWORD dwIoControlCode, 		// control code of operation to perform
> LPVOID lpInBuffer, 			// pointer to buffer to supply input data
> DWORD nInBufferSize, 		// size of input buffer
> LPVOID lpOutBuffer, 		// pointer to buffer to receive output data
> DWORD nOutBufferSize, 		// size of output buffer
> LPDWORD lpBytesReturned, 	// pointer to variable to receive output byte count
> LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
> );
> */
> 
> #define MAX_STRING       240
> #define LOG_SIZE         2000
> #define FIRST_DEBUG_PROC 100
> 
> #define OPEN_DEBUGLOG 	(FIRST_DEBUG_PROC)
> #define WRITE_DEBUGLOG 	(FIRST_DEBUG_PROC+1)
> #define WRITE_STATS     (FIRST_DEBUG_PROC+2)
> #define WSPRINTF		wsprintfA
> 
> typedef struct _LOGENTRY {
> 	CHAR	debuglevel;
> 	CHAR    str[1];
> } LOGENTRY, *PLOGENTRY;
> 
> typedef struct {
> 	UINT	nLogEntries;
> 	UINT    nCharsPerLine;
> } IN_LOGINIT, *PIN_LOGINIT;
> 
> typedef struct {
> 	UINT    hr;
> } OUT_LOGINIT, *POUT_LOGINIT;
> 
> typedef struct {
> 	CHAR	debuglevel;
> 	CHAR    str[1];
> } IN_LOGWRITE, *PIN_LOGWRITE;
> 
> typedef struct {
> 	UINT	hr;
> } OUT_LOGWRITE, *POUT_LOGWRITE;
> 
> 
> HANDLE hLoggingVxd=0;
> HANDLE hLogMutex=0;
> HANDLE hLogFile=0;
> PSHARED_LOG_FILE pLogFile=0;
> 
> /*===========================================================================
> 
> 	Debug Support.
> 
> 	Logging:
> 	========
> 
> 	Debug Logging and playback is designed to operate on both Win9x and
> 	Windows NT (Windows 2000).  On Win9x, a support VXD is used to extend
> 	the kernel debugger.  The VXD (DNET.VXD) is used for both logging and
> 	playback of debug buffers.  In addition to the debug VXD there is also
> 	logging to a shared file.  The shared file logging is played back with
> 	the DNLOG.EXE utility and can be played back on either Windows2000 or
> 	Win9x.
> 
> 	Debug support for dumping structures on Win9x is supported only in the
> 	DNET.VXD component.  Dumping of structures internal to DPLAY can only
> 	be done from the context of a DPLAY thread.  This is because the
> 	addresses are only valid in that context.  Under NT there is (will be)
> 	a debug extension for dumping internal structures.
> 
> 	Debug Logging is controlled by settings in the win.ini file.  Under
> 	the section heading [DirectPlay8].  There are 2 settings:
> 
> 	Debug=9
> 
> 	controls the debug level.  All messages, at or below that debug level
> 	are printed.
> 
> 	The second setting (logging).  If not specified, all debugs are spewed
> 	through the standard DebugPrint and will appear on in DEVSTUDIO if
> 	it is up, or on the kernel debugger if it is running.
> 
> 	log = 0 {no debug output}
> 	log = 1	{spew to console only}
> 	log = 2 {spew to log only}
> 	log = 3 {spew to console and log}
> 
> 	example win.ini...
> 
> 	[DirectPlay8]
> 	Debug=7		; lots of spew
> 	log=2		; don't spew to debug window
> 
> 	[DirectPlay8]
> 	Debug=0		; only fatal errors spewed to debug window
> 
> 	Asserts:
> 	========
> 	Asserts are used to validate assumptions in the code.  For example
> 	if you know that the variable jojo should be > 700 and are depending
> 	on it in subsequent code, you SHOULD put an assert before the code
> 	that acts on that assumption.  The assert would look like:
> 
> 	ASSERT(jojo>700);
> 
> 	Asserts generally will produce 3 lines of debug spew to highlight the
> 	breaking of the assumption.  For testing, you might want to set the
> 	system to break in on asserts.  This is done in the [DirectPlay8] section
> 	of win.ini by setting BreakOnAssert=TRUE
> 
> 	e.g.
> 
> 	[DirectPlay8]
> 	Debug=0
> 	BreakOnAssert=TRUE
> 	Verbose=1
> 
> 	Debug Breaks:
> 	=============
> 	When something really severe happens and you want the system to break in
> 	so that you can debug it later, you should put a debug break in the code
> 	path.  Some people use the philosophy that all code paths must be
> 	verified by hand tracing each one in the debugger.  If you abide by this
> 	you should place a DEBUG_BREAK() in every code path and remove them
> 	from the source as you trace each.  When you have good coverage but
> 	some unhit paths (error conditions) you should force those paths in
> 	the debugger.
> 
> 
> ===========================================================================*/
> 
39c186,193
< DWORD lDebugLevel = 1;	
---
> 
> DWORD lDebugLevel = 0;	
> 
> DWORD dwLogging   = 1;	// 0 => No debug spew
> 						// 1 => Spew to console only (default)
> 						// 2 => Spew to log only
> 						// 3 => Spew to console and log
> 
41d194
< DWORD bVerbose = FALSE;	// if TRUE, all file/line/module information is printed and logged.
42a196,202
> // if TRUE, all file/line/module information is printed and logged.
> DWORD bVerbose = FALSE;	
> BOOL  bLiveLogging = FALSE;
> 
> // if TRUE messages printed with the LOGPF will be logged, if FALSE they're ignored
> DWORD  lOutputLog = 0;
> 
63a224,347
> // open up a channel to the DirectNet VXD (DNET.VXD) that will allows
> // the log to be written to the VxD through DeviceIoControl calls.  The
> // log in this case is accessible in the Win9x kernel debugger through
> // the .dnet debugger extensions.
> void InitDirectNetVxd(void)
> {
> 	IN_LOGINIT In;
> 	OUT_LOGINIT Out;
> 	UINT cbRet;
> 
> 	// note we rely on the system automatically closing this
> 	// handle for us when the user mode application exits.
> 	hLoggingVxd = CreateFileA("\\\\.\\DNET",0,0,0,0,0,0);
> 
> 	if(hLoggingVxd != INVALID_HANDLE_VALUE){
> 
> 		In.nCharsPerLine=MAX_STRING;
> 		In.nLogEntries=5000;
> 		DeviceIoControl(hLoggingVxd,
> 						OPEN_DEBUGLOG,
> 						&In,sizeof(In),
> 						&Out, sizeof(Out),
> 						&cbRet, NULL);
> 	} else {
> 		hLoggingVxd=0;
> 	}
> }
> 
> // Write a string to the log in the debug support VxD.  This only
> // operates on Win9x, when the DNET.VXD is installed.
> static void VxdLogString( LPSTR str )
> {
> 	char logstring[MAX_STRING+sizeof(LOGENTRY)];
> 	int  i=0;
> 	PLOGENTRY pLogEntry=(PLOGENTRY)&logstring;
> 	UINT rc;
> 	UINT cbRet;
> 	int maxlen = MAX_STRING+sizeof(LOGENTRY);
> 
> 	if(hLoggingVxd && str){
> 		while(str[i] && i < maxlen)
> 			i++;
> 		pLogEntry->debuglevel=0;
> 		memcpy(pLogEntry->str,str,i+1);
> 		DeviceIoControl(hLoggingVxd,WRITE_DEBUGLOG,pLogEntry,i+sizeof(LOGENTRY), &rc, sizeof(rc), &cbRet, NULL);
> 	}
> }
> 
> // Create a shared file for logging information on the fly
> // This support allows the current log to be dumped from the
> // user mode DPLOG.EXE application.  This is useful when debugging
> // in MSSTUDIO or in NTSD.  When the DPLOG.EXE is invoke, note that
> // the application will get halted until the log is completely dumped
> // so it is best to dump the log to a file.
> static BOOL InitMemLogString(VOID)
> {
> 	static BOOL inited = FALSE;
> 
> 	if(!inited){
> 		hLogFile=CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, DPLOG_SIZE, BASE_LOG_FILENAME);
> 		hLogMutex=CreateMutexA(NULL,FALSE,BASE_LOG_MUTEXNAME);
> 		pLogFile=(PSHARED_LOG_FILE)MapViewOfFile(hLogFile, FILE_MAP_ALL_ACCESS,0,0,0);
> 
> 		if(!hLogFile || !hLogMutex || !pLogFile){
> 			if(hLogFile){
> 				CloseHandle(hLogFile);
> 				hLogFile=0;
> 			}
> 			if(hLogMutex){
> 				CloseHandle(hLogMutex);
> 				hLogMutex=0;
> 			}
> 			if(pLogFile){
> 				UnmapViewOfFile(pLogFile);
> 				pLogFile=NULL;
> 			}
> 			return FALSE;
> 		} else {
> 			inited = TRUE;
> 			pLogFile->nEntries = DPLOG_NUMENTRIES;
> 			pLogFile->cbLine   = DPLOG_ENTRYSIZE;
> 			pLogFile->iWrite   = 0;
> 			pLogFile->cInUse   = 0;
> 		}
> 	}
> 	return TRUE;
> }
> 
> // Log a string to a shared file.  This file can be dumped using the
> // DPLOG.EXE utility.
> static void MemLogString(LPSTR str)
> {
> 	PLOG_ENTRY pEntry;
> 	DWORD cbCopy;
> 
> 	if(!hLogFile){
> 		if(!InitMemLogString()){
> 			return;
> 		}
> 	}
> 
> 	WaitForSingleObject(hLogMutex,INFINITE);
> 
> 	pEntry=(PLOG_ENTRY)(((PUCHAR)(pLogFile+1))+(pLogFile->iWrite*(sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)));
> 	pEntry->hThread=GetCurrentThreadId();
> 	pEntry->tLogged=timeGetTime();
> 	pEntry->DebugLevel=0;
> 
> 	cbCopy=strlen(str)+1;
> 	if(cbCopy > DPLOG_ENTRYSIZE){
> 		str[DPLOG_ENTRYSIZE]=0;
> 		cbCopy=DPLOG_ENTRYSIZE;
> 	}
> 	memcpy(pEntry->str, str, cbCopy);
> 
> 	if(pLogFile->iWrite+1 > pLogFile->cInUse){
> 		pLogFile->cInUse=pLogFile->iWrite+1;
> 	}
> 
> 	pLogFile->iWrite = (pLogFile->iWrite+1) % pLogFile->nEntries;
> 	ReleaseMutex(hLogMutex);
> 
> }
> 
66a351,352
> 	DWORD lSpecificLevel;
> 
70a357,392
>     lDebugLevel = (signed int) GetProfileIntA( PROF_SECT, "debug", 0 );
>     lSpecificLevel = (signed int) GetProfileIntA( PROF_SECT, DPF_MODULE_NAME, -1);
>     if(lSpecificLevel != -1){
>     	lDebugLevel = lSpecificLevel;
>     }
>     dwLogging   = (signed int) GetProfileIntA( PROF_SECT, "log" , 0);
>     bBreakOnAssert = (signed int) GetProfileIntA( PROF_SECT, "BreakOnAssert", 0);
>     bVerbose = (signed int) GetProfileIntA( PROF_SECT, "Verbose", 0);
> 
>     lOutputLog = (signed int) GetProfileIntA( PROF_SECT, "OutputLog", 0);
> 
> 	switch(dwLogging){
> 		case 0:
> 			bLiveLogging=FALSE;
> 			break;
> 		case 1:
> 			bLiveLogging=TRUE;
> 			break;
> 		case 2:
> 			bLiveLogging=FALSE;
> 			break;
> 		case 3:
> 			bLiveLogging=TRUE;
> 			break;
> 		default:
> 			break;
> 	}
> 	if((dwLogging >= 2)||(lOutputLog > 0)){
> 		// Doing log based logging, so try to find the VXD and open
> 		// the shared logging file.
> 		InitDirectNetVxd();
> 
> 		// Do logging also based on shared memory file.
> 		InitMemLogString();	
> 	}
> 
77a400,405
> 	if(hLogFile){
> 		CloseHandle(hLogFile);
> 	}
> 	if(hLoggingVxd){
> 		CloseHandle(hLoggingVxd);
> 	}	
113a442,443
> 		if(bLiveLogging)
> 		{
116a447,457
> 		}
> 
> 		if(hLoggingVxd){
> 			// log to vxd
> 			VxdLogString( str );
> 		}
> 
> 		if(dwLogging >= 2){
> 			// log to shared file
> 			MemLogString( str );
> 		}
158c499
< 	WSPRINTF(cMsg+strlen( cMsg ), szFormat, argptr);
---
> 	WSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);
210c551
< 	WVSPRINTF(cMsg+strlen( cMsg ), szFormat, argptr);
---
> 	WVSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);
218a560,595
> /*
> **	LogPrintf copies a quick Log Entry to the
> **
> */
> 
> //  5/23/2000(RichGr): IA64: Change DWORD to DWORD_PTR.
> void LogPrintf(volatile DWORD_PTR dwDetail, ...)
> {
> 	CHAR  cMsg[1000];
> 	LPSTR szFormat;
> 
> 	va_list argptr;
> 
> 	if(lOutputLog < dwDetail){
> 		LeaveCriticalSection(&csDPF);
> 		return;
> 	}
> 
> 	//EnterCriticalSection(&csDPF);
> 
> 	va_start(argptr, dwDetail);
> 	szFormat = (LPSTR) va_arg(argptr, DWORD_PTR);
> 
> 	cMsg[0]=0;
> 
> 	WSPRINTF(cMsg,"%s: ",g_szModName);
> 
> 	WVSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);
> 
> 	MemLogString( (LPSTR) cMsg );
> 
> 	LeaveCriticalSection(&csDPF);
> 
> 	va_end(argptr);
> }
> 
225a603,604
> #define ASSERT_BREAK_SECTION "BreakOnAssert"
> #define ASSERT_BREAK_DEFAULT FALSE
248c627
<     if( bBreakOnAssert )
---
>     if( bBreakOnAssert || GetProfileIntA( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
317a697,717
> }
> 
> BOOL IsValidStringA( const CHAR * const szString )
> {
> 	const char *szTmpLoc = szString;
> 	
> 	if( szString == NULL )
> 	{
> 		return FALSE;
> 	}
> 
> 	_try
> 	{
> 		for( ; *szTmpLoc ; szTmpLoc++ );
> 	}
> 	_except( EXCEPTION_EXECUTE_HANDLER )
> 	{
> 		return FALSE;
> 	}
> 
> 	return TRUE;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dndbg.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
29a30,32
> 	#if defined( _WIN32 ) && !defined(WINNT) && defined(_X86_)
> 		#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
> 	#else
30a34
> 	#endif
102a107
> extern BOOL IsValidStringA( const CHAR * const swzString );
111a117
> extern void LogPrintf(volatile DWORD_PTR dwDetail, ...);
112a119
> #define DNVALID_STRING_A(a)		IsValidStringA(a)
127c134,138
< #define	LOGPF		DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
---
> #ifdef DPF_SUBCOMP_MASK
> 	#define DPFSC if(DPF_SUBCOMP_MASK & DPF_SUBCOMP_BIT)DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),if(DPF_SUBCOMP_MASK & DPF_SUBCOMP_BIT)DebugPrintf
> #else
> 	#define DPFSC DPF
> #endif
128a140,141
> #define	LOGPF		DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),LogPrintf
> 
133a147
> 	#define DNVALID_STRING_A(a)			(TRUE)
139a154
> 	#define DPFSC()
148,149c163,166
< #define WVSPRINTF wvsprintf
< #define STRLEN   strlen
---
> #define WVSPRINTF wvsprintfA
> #define STRLEN   lstrlenA
> 
> #define PROF_SECT "DirectPlay8"
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dneterrors.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20,23
> // vanceo - changed to stdio for printf
> //#include	<iostream.h>
> #include	<stdio.h>
> 
78a83,92
> 			// output to console
> 			case DPNERR_OUT_CONSOLE:
> 			{
> 				// Also see the change from <iostream.h> to <stdio.h> above
> 				#pragma TODO(vanceo, "Changed cout to printf so NT build environment will work, figure this out.")
> 				//cout << endl << pString << endl;
> 				printf("\n%s\n", pString);
> 				break;
> 			}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\guidutil.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
15c15
< #include <wchar.h>
---
> #include "stdio.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34,37
> #ifdef	_WIN64
> #define	MEMORY_CRC			0X5AA55AA55AA55AA5
> #define	GUARD_SIGNATURE		0x0F1E2D3C4B5A6978
> #else
35a40
> #endif	// _WIN64
40a46,52
> //
> // enumerated values to indicate how to report memory leaks
> //
> #define	MEMORY_LEAK_REPORT_NONE		0x00000000
> #define	MEMORY_LEAK_REPORT_DPF		0x00000001
> #define	MEMORY_LEAK_REPORT_DIALOG	0x00000002
> 
60a73
> #ifdef	_X86_
61a75,77
> #else
> #define	ASSERT( arg )	if ( arg == FALSE ) { DebugBreak(); }
> #endif
94a111,116
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
> static	HINSTANCE			g_hApplicationInstance;
> 
> //
103a126,128
> static int	DisplayCallStack( const char *const pszMsg,
> 							  const char *const pszTitle,
> 							  const char *const pCallStack );
121a147
> 	OSVERSIONINFO	OSVersionInfo;
122a149
> 
130a158,186
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
> 	// note application instance
> 	//
> 	g_hApplicationInstance = GetModuleHandle( NULL );
> 	if ( g_hApplicationInstance == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to GetModuleHandle: 0x%x", dwError );
> 		goto Failure;
> 	}
> 
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
> 	//
229a286,287
> 		switch ( DNGetOSType() )
> 		{
232a291,292
> 			case VER_PLATFORM_WIN32_NT:
> 			{
256a317,327
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
289a361,392
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetApplcationInstance - application instance
> //
> // Entry:		Nothing
> //
> // Exit:		Application instance
> // ------------------------------
> HINSTANCE	DNGetApplicationInstance( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_hApplicationInstance;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
360a464
> //#ifdef	_WIN32
389a494
> //#endif	// _WIN32
390a496,517
> 
> //#ifdef	_WIN64
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	if ( pTime1->Time < pTime2->Time )
> //	{
> //		iReturnValue = -1;
> //	}
> //	else
> //	{
> //		if ( pTime1->Time == pTime2->Time )
> //		{
> //			iReturnValue = 0;
> //		}
> //		else
> //		{
> //			iReturnValue = 1;
> //		}
> //	}
> //#endif	// _WIN64
> 
416a544
> #ifdef	_X86_
428a557,607
> 
> #else	// _X86_
> 
> /*
> #ifdef	_ALPHA_
> 	// debug me
> 	DebugBreak();
> 
> 	__asm{ mov	$t0, *pTime1
> 		   mov	$t1, *pTime2
> 		   addq	$t0, $t1
> 		   mov	*pTimeResult, $t0
> 	};
> #else	// _ALPHA_
> */
> 
> //#ifdef	_WIN32
> 	DWORD	dwTempLowTime;
> 
> 
> 	dwTempLowTime = pTime1->Time32.TimeLow;
> 	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow + pTime2->Time32.TimeLow;
> 	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh + pTime2->Time32.TimeHigh;
> 
> 	//
> 	// check for overflow in low 32-bits and increment high value if applicable
> 	//
> 	if ( pTimeResult->Time32.TimeLow < dwTempLowTime )
> 	{
> #pragma	BUGBUG( johnkan, "Test this!" )
> 		// debug me
> 		DebugBreak();
> 		pTimeResult->Time32.TimeHigh++;
> 	}
> //#endif	// _WIN32
> 
> //#ifdef	_WIN64
> //	DEBUG_ONLY( UINT_PTR	ReferenceTime );
> //
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	DEBUG_ONLY( ReferenceTime = pTime1->Time );
> //	*pTimeResult = pTime1->Time + pTime2->Time;
> //	DNASSERT( *pTimeResult >= ReferenceTime );
> //
> //#endif	// _WIN64
> 
> // #endif	// _ALPHA_
> 
> #endif	// _X86_
454a634,635
> #ifdef	_X86_
> 
466a648,694
> 
> #else	// _X86_
> 
> /*
> #ifdef	_ALPHA_
> 	// debug me
> 	DebugBreak();
> 
> 	mov		$t0, *pTime1
> 	mov		$t1, *pTime2
> 	addq	$t0, $t1
> 	mov		*pTimeResult, $t0
> #else	// _ALPHA_
> */
> 
> //#ifdef	_WIN32
> 	DWORD	dwTempLowTime;
> 
> 
> 	dwTempLowTime = pTime1->Time32.TimeLow;
> 	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow - pTime2->Time32.TimeLow;
> 	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh - pTime2->Time32.TimeHigh;
> 
> 	//
> 	// check for underflow in low 32-bits and decrement high value if applicable
> 	//
> 	if ( pTimeResult->Time32.TimeLow > dwTempLowTime )
> 	{
> #pragma	BUGBUG( johnkan, "Test this!" )
> 		// debug me
> 		DebugBreak();
> 
> 		pTimeResult->Time32.TimeHigh--;
> 	}
> //#endif	// _WIN32
> 
> //#ifdef	_WIN64
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	DNASSERT( pTime1->Time > pTime2->Time );
> //	pTimeResult = pTime1->Time - pTime2->Time;
> //#endif	// _WIN64
> 
> // #endif	// _ALPHA_
> 
> #endif	// _X86_
687a916,918
> 		void	NoteCurrentCallStack( void ) { m_CallStack.NoteCurrentCallStack(); }
> 		void	GetCallStack( char *const pBuffer ) const { m_CallStack.GetCallStackString( pBuffer ); }
> 
704a936
> 		CCallStack<DN_MEMORY_CALL_STACK_DEPTH>	m_CallStack;
795a1028
> 		pMemoryLink->NoteCurrentCallStack();
905a1139
> 	char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
939,940c1173,1184
< 			DPF( 0, "%s%s\n", "Memory Corruption!", MessageString );
< //					DNASSERT( FALSE );
---
> 			pMemoryLink->GetCallStack( CallStackBuffer );
> 			MessageReturn = DisplayCallStack( MessageString, "Memory Corruption!", CallStackBuffer );
> 			switch ( MessageReturn )
> 			{
> 				case IDABORT:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				case IDIGNORE:
> 				{
944a1189,1197
> 					break;
> 				}
> 
> 				case IDRETRY:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
975a1229
> 	DWORD		dwDisplayFlags;
976a1231
> 
979a1235
> 	fDisplayLeaks = TRUE;
982a1239,1240
> 	dwDisplayFlags = GetProfileIntA( PROF_SECT, "MemoryLeakOutput", MEMORY_LEAK_REPORT_DPF );
> 	
989a1248
> 		char		CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
1002,1003c1261
< 			DPF( 0, "%s%s\n", DialogTitle, LeakSizeString );
< //						DNASSERT( FALSE );
---
> 		pTemp->GetCallStack( CallStackBuffer );
1004a1263,1313
> 
> 		if ( ( dwDisplayFlags & MEMORY_LEAK_REPORT_DPF ) != 0 )
> 		{
> 			DPF( 0, "%s%s%s\n", DialogTitle, LeakSizeString, CallStackBuffer );
> 		}
> 
> 		if ( ( dwDisplayFlags & MEMORY_LEAK_REPORT_DIALOG ) != 0  )
> 		{
> 			if ( fDisplayLeaks != FALSE )
> 			{
> 				MessageReturn = DisplayCallStack( LeakSizeString, DialogTitle, CallStackBuffer );
> 				switch ( MessageReturn )
> 				{	
> 					//
> 					// stop application now
> 					//
> 					case IDABORT:
> 					{
> 						fDisplayLeaks = FALSE;
> 						break;
> 					}
> 
> 					//
> 					// display next leak
> 					//
> 					case IDIGNORE:
> 					{
> 						break;
> 					}
> 
> 					//
> 					// stop in the debugger
> 					//
> 					case IDRETRY:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 
> 					//
> 					// unknown
> 					//
> 					default:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 				}
> 			}
> 		}
> 
1017a1327,1470
> 
> 
> #if	defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
> //**********************************************************************
> //**
> //** THIS IS THE STACK TRACKING SECTION.  ONLY ADD FUNCTIONS HERE THAT ARE
> //** RELATED TO TRACKING THE CALL STACK!!
> //**
> //**********************************************************************
> 
> 
> ////**********************************************************************
> //// ------------------------------
> //// DNGetStackTop - return pointer to top of stack
> ////
> //// Entry:		Nothing
> ////
> //// Exit:		Pointer to top of stack
> //// ------------------------------
> //static void	*DNGetStackTop( void )
> //{
> //	void	*pReturn;
> //
> //	_asm	mov eax,dword ptr fs:[4]
> //	_asm	mov pReturn, eax
> //	return	pReturn;
> //}
> ////**********************************************************************
> //
> //
> ////**********************************************************************
> //// ------------------------------
> //// DNGetStackBottom - return pointer to bottom of call stack
> ////
> //// Entry:		Nothing
> ////
> //// Exit:		Pointer to bottom of call stack
> //// ------------------------------
> //static void	*DNGetStackBottom( void )
> //{
> //	void	*pReturn;
> //
> //	_asm	mov eax,dword ptr fs:[8]
> //	_asm	mov pReturn, eax
> //	return	pReturn;
> //}
> ////**********************************************************************
> 
> 
> ////**********************************************************************
> //// ------------------------------
> //// DNGetCallStack - get a call stack
> ////
> //// Entry:		Pointer to call stack array
> ////				Number of calls to report
> ////
> //// Exit:		Nothing
> //// ------------------------------
> //static	void	DNGetCallStack( const void **const pCallStack, const UINT_PTR Depth )
> //{
> //	void		**CallersEBP;
> //	void		*ReturnAddr;
> //	UINT_PTR	i,iCount;
> //	void		*StackTop;
> //	void		*StackBottom;
> //	static const	void	*min_dll_base = NULL;
> //
> //
> //	StackTop = DNGetStackTop();
> //	StackBottom = DNGetStackBottom();
> //	memset(	pCallStack, 0x00, sizeof( *pCallStack ) * Depth );
> //
> //	_asm
> //	{
> //		mov eax,[ebp]
> //		mov CallersEBP,eax
> //	}
> //
> //	__try
> //	{
> //		//
> //		// this code can generate exception if it steps back too far...
> //		//
> //		for ( i = 0, iCount = 0; i < Depth; iCount++ )
> //		{
> //			if ( ( CallersEBP < StackBottom ) || ( CallersEBP >= StackTop ) )
> //				break;
> //			ReturnAddr = CallersEBP[ 1 ];
> //			if ( ( iCount > 0 ) || ( ReturnAddr >= min_dll_base ) ) // iCount check skips memory_alloc_debug
> //				pCallStack[ i++ ] = ReturnAddr;
> //			CallersEBP = reinterpret_cast<void**>( *CallersEBP ); // get callers callers ebp
> //		}
> //	}
> //	__except( 1 )  // went too far back on the stack, fill up rest of array with zeros
> //	{
> //		DPF( 0, "Benign access violation creating return address stack." );
> //	}
> //}
> ////**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DisplayCallStack - display a call stack message box
> //
> // Entry:		Pointer to information string
> //				Pointer to title string
> //				Pointer to call stack string
> //
> // Exit:		Dialog return code
> // ------------------------------
> static int	DisplayCallStack( const char *const pszMsg, const char *const pszTitle, const char *const pCallStackString )
> {
> 	MSGBOXPARAMS	MessageBoxParams;
> 	char 			szStackTraceMsg[ CALLSTACK_BUFFER_SIZE ];
> 
> 
>     strcpy( szStackTraceMsg, pszMsg );
> 	strcat( szStackTraceMsg, pCallStackString );
> 
> 	//
> 	// display message box
> 	//
> 	memset( &MessageBoxParams, 0x00, sizeof( MessageBoxParams ) );
> 	MessageBoxParams.cbSize = sizeof( MessageBoxParams );
> 	MessageBoxParams.lpszText = szStackTraceMsg;
> 	MessageBoxParams.lpszCaption = pszTitle;
> 	MessageBoxParams.dwStyle = MB_ABORTRETRYIGNORE | MB_SETFOREGROUND | MB_TOPMOST | MB_DEFBUTTON2;
> 	MessageBoxParams.hInstance = NULL;
> 
> 	return MessageBoxIndirect( &MessageBoxParams );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> //**
> //** END OF CALL STACK TRACKING SECTION.
> //**
> //**********************************************************************
> #endif	// defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
> 
> 
> 
1112a1566
> 	static	BOOL	fDisplayCallStacks = TRUE;
1130a1585,1588
> 	if ( pCriticalSection->LockCount == 0 )
> 	{
> 		pCriticalSection->CallStack.NoteCurrentCallStack();
> 	}
1136a1595,1599
> 			if ( fDisplayCallStacks != FALSE )
> 			{
> 				char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
> 
> 
1141,1142c1604,1636
< 			    DPF( 0, "%s%s\n", "DNCritical section has been reentered!", "Check stack trace for function that originally held the lock." );
< //						DNASSERT( FALSE );
---
> 				pCriticalSection->CallStack.GetCallStackString( CallStackBuffer );
> 				switch ( DisplayCallStack( "Stack trace of function that originally held the lock:",
> 										   "DNCritical section has been reentered!",
> 										   CallStackBuffer ) )
> 				{
> 					//
> 					// don't display any more critical section warnings!
> 					//
> 					case IDABORT:
> 					{
> 						fDisplayCallStacks = FALSE;
> 						break;
> 					}
> 
> 					//
> 					// acknowledged
> 					//
> 					case IDIGNORE:
> 					{
> 						break;
> 					}
> 
> 					//
> 					// stop in debugger
> 					//
> 					case IDRETRY:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 				}
> 			}
> 
1175a1670
> 		memset( &pCriticalSection->CallStack, 0x00, sizeof( pCriticalSection->CallStack ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18,19
> #include	"CallStack.h"
> 
29a32,34
> #define	DN_MEMORY_CALL_STACK_DEPTH				12
> #define	DN_CRITICAL_SECTION_CALL_STACK_DEPTH	10
> 
53a59
> 	CCallStack< DN_CRITICAL_SECTION_CALL_STACK_DEPTH > 	CallStack;
85a92,101
> 
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
> HINSTANCE	DNGetApplicationInstance( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
41,42c41
< TARGETLIBS=
< # $(TARGETLIBS)
---
> TARGETLIBS=$(TARGETLIBS)
72a72
>         creg.cpp \
81c81
< C_DEFINES= $(C_DEFINES) /D_LIB /DWIN32 /D_MT /DCINTERFACE /DUNICODE
---
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\appdesc.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38d37
< #include <wchar.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
70a71
> #include "DVoice.h"
101a103
> #include "Voice.h"
103c105,107
< #include <mmsystem.h>
---
> #include "dpnsdef.h"
> #include "dpnsvrq.h"
> #include "dpnsvlib.h"
183c187
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
206c210
< 	pDeviceInfo->lpVtbl->GetURLW(pDeviceInfo,DP8ABuffer,&DP8ASize);
---
> 	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer,&DP8ASize);
453c457
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
469c473
< 	pRemoteAddr->lpVtbl->GetURLW(pRemoteAddr,DP8ABuffer,&DP8ASize);
---
> 	pRemoteAddr->lpVtbl->GetURLA(pRemoteAddr,DP8ABuffer,&DP8ASize);
472c476
< 	pDeviceInfo->lpVtbl->GetURLW(pDeviceInfo,DP8ABuffer,&DP8ASize);
---
> 	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer,&DP8ASize);
1468a1473,1481
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
44a45
> #include "DVoice.h"
73a75,76
> #include "dvoice.h"
> #include "voice.h"
121a125
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
234a239,259
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
> 
254a280
> 	pdnObject->pIDP8LobbiedApplication = NULL;
266a293,296
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
> 
295a326,332
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
626a664,666
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
894a935,939
> 	}
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(7,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\client.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
56d55
< #include <wchar.h>
94c93
< typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
108a109,110
> #include "DPLobby8.h"
> #include "DVoice.h"
133a136
> #include "DNMisc.h"
140a144
> #include "Voice.h"
142a147,149
> #include "dpnsdef.h"
> #include "dpnsvrq.h"
> #include "dpnsvlib.h"
144,145d150
< #include <mmsystem.h>
< #include <wchar.h>
174d178
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
801,803c805,809
< 		if ((hResultCode = DirectPlay8AddressCreate( &IID_IDirectPlay8Address,
<                                                      reinterpret_cast<void**>(&pIDevice),
<                                                      NULL)) != S_OK)
---
> 		if ((hResultCode = CoCreateInstance(CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>(&pIDevice))) != S_OK)
878a885,888
> 	if (dwFlags & DPNCONNECT_OKTOQUERYFORADDRESSING)
> 	{
> 		dwConnectFlags |= DPNCONNECT_OKTOQUERYFORADDRESSING;
> 	}
1420a1431,1435
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
> 
1984,1985c1999
< // BUGBUG [mgere] [xbox] Temporarily removed until a CoCreateGuid call is implemented
< //	CoCreateGuid(&pdnObject->dnApplicationDescription.guidInstance);	
---
> 	CoCreateGuid(&pdnObject->dnApplicationDescription.guidInstance);	
2057a2072,2080
> 	//	Inform DPNSVR of LISTENs
> 	//
> 	if( !(pdnObject->dnApplicationDescription.dwFlags & DPNSESSION_NODPNSVR) )
> 	{
> 		DPF(3,"Registering with DPNSVR");
> 		DNRegisterWithDPNSVR(pdnObject);
> 	}
> 
> 	//
3333c3356
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
3409,3411c3432,3436
< 		if ((hResultCode = DirectPlay8AddressCreate( &IID_IDirectPlay8Address,
<                                                      reinterpret_cast<void**>(&pIHost),
<                                                      NULL)) != S_OK)
---
> 		if ((hResultCode = CoCreateInstance(CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>(&pIHost))) != DPN_OK)
3438c3463
< 	pIHost->lpVtbl->GetURLW(pIHost,DP8ABuffer,&DP8ASize);
---
> 	pIHost->lpVtbl->GetURLA(pIHost,DP8ABuffer,&DP8ASize);
3442c3467
< 	pIDevice->lpVtbl->GetURLW(pIDevice,DP8ABuffer,&DP8ASize);
---
> 	pIDevice->lpVtbl->GetURLA(pIDevice,DP8ABuffer,&DP8ASize);
4085c4110
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
4088c4113,4181
< 	return DPNERR_UNSUPPORTED;
---
> 	DIRECTNETOBJECT		*pdnObject;
> 	HRESULT             hResultCode;
> 
> 	DPF(3,"Parameters: pInterface [0x%lx], pIDP8LobbiedApplication [0x%lx], dwFlags [0x%lx]",
> 			pInterface,pIDP8LobbiedApplication,dwFlags);
> 
> 	TRY
> 	{
>     	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
>     	DNASSERT(pdnObject != NULL);
> 
>     	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
>     	{
>     	    if( FAILED( hResultCode = DN_ValidateRegisterLobby( pInterface, pIDP8LobbiedApplication, dwFlags ) ) )
>     	    {
>     	        DPFERR( "Error validating register lobby params" );
>     	        DPF_EXIT( hResultCode );
>     	    }
>     	}
> 
>     	// Check to ensure message handler registered
>     	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
>     	{
>     		DPFERR( "Object is not initialized" );
>     		DPF_EXIT(DPNERR_UNINITIALIZED);
>     	}
> 
> 	}
> 	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
> 	{
> 	    DPFERR("Invalid object" );
> 	    DPF_EXIT(DPNERR_INVALIDOBJECT);
> 	}	
> 
> 	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
> 	DNASSERT(pdnObject != NULL);
> 
> 	if (dwFlags == DPNLOBBY_REGISTER)
> 	{
> 		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 		if (pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE)
> 		{
> 			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 			return(DPNERR_ALREADYINITIALIZED);
> 		}
> 				
> 		pIDP8LobbiedApplication->lpVtbl->AddRef(pIDP8LobbiedApplication);
> 
> 		pdnObject->pIDP8LobbiedApplication = pIDP8LobbiedApplication;
> 		pdnObject->dwFlags |= DN_OBJECT_FLAG_LOBBY_AWARE;
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	}
> 	else
> 	{
> 		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE))
> 		{
> 			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 			return(DPNERR_UNINITIALIZED);
> 		}
> 				
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release(pdnObject->pIDP8LobbiedApplication);
> 
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_LOBBY_AWARE);
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	}
> 
> 	return(DPN_OK);
4366a4460,4564
> }
> 
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DNRegisterWithDPNSVR"
> 
> HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject)
> {
> 	HRESULT					hResultCode;
> 	HRESULT					hrRegister;
> 	CAsyncOp				*pParent;
> 	CAsyncOp				*pAsyncOp;
> 	CBilink					*pBilink;
> 	SPGETADDRESSINFODATA	spInfo;
> #ifdef	DEBUG
> 	CHAR			DP8ABuffer[512];
> 	DWORD			DP8ASize;
> #endif
> 
> 	//
> 	//	Default error returned
> 	//
> 	hrRegister = DPNERR_GENERIC;
> 
> 	//
> 	//	Get LISTEN AsyncOp parent from DirectNet object and add a RefCount
> 	//
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	if (pdnObject->pListen == NULL)
> 	{
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 		goto Exit;
> 	}
> 	pdnObject->pListen->AddRef();
> 	pParent = pdnObject->pListen;
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	//
> 	//	Lock the parent so that the child bilink list doesn't change
> 	//
> 	pParent->Lock();
> 
> 	//
> 	//	Attempt to crack each child LISTEN and inform DPNSVR of the address
> 	//
> 	pBilink = pParent->m_bilinkChildren.GetNext();
> 	while (pBilink != &pParent->m_bilinkChildren)
> 	{
> 		pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
> 		DNASSERT(pAsyncOp->GetProtocolHandle() != NULL);
> 
> 		spInfo.hEndpoint = pAsyncOp->GetProtocolHandle();
> 		spInfo.pAddress = NULL;
> 		spInfo.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;
> 
> 		if (DNPGetListenAddressInfo(pAsyncOp->GetProtocolHandle(),&spInfo) == DPN_OK)
> 		{
> 			DNASSERT(spInfo.pAddress != NULL);
> #ifdef	DEBUG
> 			DP8ASize = 512;
> 			spInfo.pAddress->lpVtbl->GetURLA(spInfo.pAddress,DP8ABuffer,&DP8ASize);
> 			DPF(4,"Listen address [%s]",DP8ABuffer);
> 
> 			// We re-try the registration to catch the case where DPNSVR is shutting
> 			// down while we are trying to register.  Unlikely but has to be handled.
> 			//
> #endif
>             for( DWORD dwRetry = 0; dwRetry < DPNSVR_REGISTER_ATTEMPTS ; dwRetry ++ )
>             {
>     			hResultCode = DPNSVR_Register( &pdnObject->dnApplicationDescription, spInfo.pAddress );
>     			if( FAILED( hResultCode ) )
>     			{
>     				if( dwRetry < DPNSVR_REGISTER_ATTEMPTS )
>     				{
> 	    				DPF( 0, "Unable to register ourselves with DPNSVR hr=0x%x, retrying", hResultCode );    				
> 	    				Sleep( DPNSVR_REGISTER_SLEEP );    				
>     				}
>     				else
>     				{
> 	    				DPF( 0, "Unable to register ourselves with DPNSVR hr=0x%x", hResultCode );
> 	    			}
>     			}
>     			else
>     			{
>     				// Return DPN_OK if we succeed even once
>     				hrRegister = hResultCode;
>     				break;
>     			}
>             }
> 			
> 			spInfo.pAddress->lpVtbl->Release(spInfo.pAddress);
> 			spInfo.pAddress = NULL;
> 		}
> 
> 		pBilink = pBilink->GetNext();
> 	}
> 
> 	pParent->Unlock();
> 
> 	pParent->Release();
> 	pParent = NULL;
> 
> Exit:
> 	DPF(4,"Returning: [0x%lx]",hrRegister);
> 	return( hrRegister );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
195c195
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
205a206,207
> 
> HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
84d83
< #include <wchar.h>
86,91d84
< #define CompareGuid(a,b)                                         \
<     (memcmp((PVOID)(a), (PVOID)(b), sizeof(GUID)))
< 
< 
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
208,210c201,205
< 		if ((hResultCode = DirectPlay8AddressCreate( &IID_IDirectPlay8Address,
<                                                      reinterpret_cast<void**>(&pAddress),
<                                                      NULL)) != S_OK)
---
> 		if ((hResultCode = CoCreateInstance(CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>(&pAddress))) != S_OK)
219,220c214,215
< 		if ((hResultCode = pAddress->lpVtbl->BuildFromURLW(	pAddress,
< 															static_cast<WCHAR*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
---
> 		if ((hResultCode = pAddress->lpVtbl->BuildFromURLA(	pAddress,
> 															static_cast<char*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
662c657
< 	if (pguidInstance && CompareGuid(pguidInstance,&GUID_NULL))
---
> 	if (pguidInstance && !UuidIsNil(pguidInstance,&rpcStatus))
673c668
< 	if (pguidApplication && CompareGuid(pguidApplication,&GUID_NULL))
---
> 	if (pguidApplication && !UuidIsNil(pguidApplication,&rpcStatus))
830c825
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
855,856c850
< 				pAddress->lpVtbl->GetURLW(pAddress,NULL,&dwAddressSize);
< 				dwAddressSize = dwAddressSize * sizeof(WCHAR);
---
> 				pAddress->lpVtbl->GetURLA(pAddress,NULL,&dwAddressSize);
860c854
< 				pAddress->lpVtbl->GetURLW(pAddress,DP8ABuffer,&DP8ASize);
---
> 				pAddress->lpVtbl->GetURLA(pAddress,DP8ABuffer,&DP8ASize);
987,988c981,982
< 		if ((hResultCode = pAddress->lpVtbl->GetURLW(pAddress,
< 													static_cast<WCHAR*>(packedBuffer.GetTailAddress()),
---
> 		if ((hResultCode = pAddress->lpVtbl->GetURLA(pAddress,
> 													static_cast<char*>(packedBuffer.GetTailAddress()),
2061c2055
< 	WCHAR					DP8ABuffer[512];
---
> 	CHAR					DP8ABuffer[512];
2095c2089
< 		(*ppAddress)->lpVtbl->GetURLW(*ppAddress,DP8ABuffer,&DP8ASize);
---
> 		(*ppAddress)->lpVtbl->GetURLA(*ppAddress,DP8ABuffer,&DP8ASize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectNet"
> 
> /*
29a37,65
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "CORE"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectNet] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNetCore"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
158a159,160
> typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
195a198,205
> //
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> //
> #define MAX_VOICE_CLIENTS	32	
> 
241a252,253
> 	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
> 
261a274,278
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnet.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,62
> 
> #endif
> 
> #endif    // !_MAC
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40a41
> #include "DNMisc.h"
43c44
< //#include "CReg.h"
---
> #include "CReg.h"
55c56,65
< // BUGBUG: [xbox] [mgere] Removed since we don't support registry
---
> 	DWORD	dwAllAppLen;
> 	WCHAR	lpwszAllAppStr[DN_FLAG_STR_LEN+1];
> 
> 	dwAllAppLen = (DN_FLAG_STR_LEN + 1) * sizeof(WCHAR);
> 	if (RegQueryValueExW(hSPKey,DN_REG_KEYNAME_ALL_APPLICATIONS,NULL,NULL,(PBYTE)lpwszAllAppStr,&dwAllAppLen) != ERROR_SUCCESS)
> 		return(FALSE);
> 
> 	if (towupper(lpwszAllAppStr[0]) == L'N')
> 		return(TRUE);
> 
70,71c80
< // BUGBUG:  [mgere] [xbox] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
73c82,92
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
75c94,97
< 	GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
> //	CServiceProvider	*pSP;
83a106,108
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
> //	pSP = NULL;
88,89c113,118
< 	hResultCode = packedBuffer.AddToBack("DirectPlay8 TCP/IP Service Provider",(strlen("DirectPlay8 TCP/IP Service Provider")+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
91,92c120,147
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = static_cast<GUID*>(packedBuffer.GetTailAddress());
---
> 	//
> 	//	Set up to enumerate
> 	//
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(5,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
94,95c149,162
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	//
> 	//	Enumerate SP's !
> 	//
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(5,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,FALSE))
> 		{
> 			DPF(0,"Couldn't open subentry.  Skipping [%S]", pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
96a164,255
> 		//
> 		//	GUID
> 		//
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPF(0,"SubEntry.ReadGUID failed.  Skipping [%S]", pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		//
> 		//	Attempt to instantiate SP and initialize it, to ensure that it is in fact usable.
> 		//
> 		if (!(dwFlags & DPNENUMSERVICEPROVIDERS_ALL))
> 		{
> 			hResultCode = DN_SPEnsureLoaded(pdnObject,&guid,NULL);
> 			if (hResultCode != DPN_OK)
> 			{
> 				DPF(0,"Could not load SP.  Skipping [%S]", pwszKeyName);
> 				SubEntry.Close();
> 				dwEnumIndex++;
> 				dwKeyLen = dwMaxKeyLen;
> 				hResultCode = DPN_OK; // override return code
> 				continue;
> 			}
> 			else
> 			{
> 				DN_SPRelease(pdnObject,&guid);
> 			}
> 		}
> 
> 		//
> 		//	Friendly Name
> 		//
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(5,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		DPF(5,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = static_cast<GUID*>(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
> 	//
> 	//	Success ?
> 	//
100c259
< 		DPF(7,"Buffer too small");
---
> 		DPF(5,"Buffer too small");
103c262
< 		goto Exit;
---
> 		goto Failure;
107c266,267
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
> 		hResultCode = DPN_OK;
111a272,276
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
> 	DNFree(pwszFriendlyName);
> 	pwszFriendlyName = NULL;
> 
113c278
< 	DPF(3,"Returning: [0x%lx]",hResultCode);
---
> 	DPF(4,"Returning: [0x%lx]",hResultCode);
114a280,301
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
128,132d314
< // BUGBUG
< // [mgere] [xbox] Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
214,216c396,400
< 		if ((hResultCode = DirectPlay8SPCreate( IID_IDP8ServiceProvider,
<                                                 (LPVOID*)&pDNSP,
<                                                 NULL)) != DPN_OK)
---
> 		if ((hResultCode = CoCreateInstance(*lpguidSP,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDP8ServiceProvider,
> 											(LPVOID*)&pDNSP)) != DPN_OK)
280d463
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\migration.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
68a69,71
> #include "dpnsvrq.h"
> #include "dpnsdef.h"
> #include "dpnsvlib.h"
522a526,545
> 
> 	// Register with DPNSVR
> 	if( !(pdnObject->dnApplicationDescription.dwFlags & DPNSESSION_NODPNSVR) )
> 	{
> 		BOOL	fCoUninitialize = FALSE;
> 
> 		DPF( 7, "Asking for DPNSVR to start listening for us.." );
> 
> 		if (CoInitialize(NULL) == S_OK)
> 		{
> 			fCoUninitialize = TRUE;
> 		}
> 
> 		DNRegisterWithDPNSVR(pdnObject);
> 
> 		if (fCoUninitialize)
> 		{
> 			CoUninitialize();
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\ntentry.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
56,57d55
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
365,366c363
< 		hResultCode = m_pAddress->lpVtbl->GetURLW(m_pAddress,NULL,&dwURLSize);
< 		dwURLSize = dwURLSize * sizeof(WCHAR);
---
> 		hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,NULL,&dwURLSize);
378,379c375,376
< 				if ((hResultCode = m_pAddress->lpVtbl->GetURLW(m_pAddress,
< 						static_cast<WCHAR*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
---
> 				if ((hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,
> 						static_cast<char*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
455c452,456
< 		hResultCode = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, reinterpret_cast<PVOID*>( &pAddress ), NULL);
---
> 		hResultCode = CoCreateInstance(	CLSID_DirectPlay8Address,
> 										NULL,
> 										CLSCTX_INPROC_SERVER,
> 										IID_IDirectPlay8Address,
> 										reinterpret_cast<PVOID*>(&pAddress));
462c463
< 		hResultCode = pAddress->lpVtbl->BuildFromURLW(pAddress,reinterpret_cast<WCHAR*>(pBufferStart + pdnEntryInfo->dwURLOffset));
---
> 		hResultCode = pAddress->lpVtbl->BuildFromURLA(pAddress,reinterpret_cast<char*>(pBufferStart + pdnEntryInfo->dwURLOffset));
563d563
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29
> #include "DVoice.h"
51a53
> #include "voice.h"
54a57
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
171c174
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
179a183,189
>     if( pIDP8LobbiedApplication == NULL ||
>         !DNVALID_READPTR( pIDP8LobbiedApplication, sizeof( IDirectPlay8LobbiedApplication * ) ) )
>     {
>         DPFERR( "Invalid interface pointer specified for register lobby" );
>         return DPNERR_INVALIDPOINTER;
>     }
> 
886c896,898
< 			DPF( 0, "Cannot specify NULL Host address" );
---
> 		if ( !(dwFlags & DPNENUMHOSTS_OKTOQUERYFORADDRESSING) )
> 		{
> 			DPF( 0, "Cannot specify NULL Host address without specifying DPNENUMHOSTS_OKTOQUERYFORADDRESSING" );
887a900
> 		}
943c956
<     if( dwFlags & ~(DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
---
>     if( dwFlags & ~(DPNENUMHOSTS_OKTOQUERYFORADDRESSING | DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
1643c1656
<     if( dwFlags & ~(DPNCONNECT_SYNC) )
---
>     if( dwFlags & ~(DPNCONNECT_SYNC | DPNCONNECT_OKTOQUERYFORADDRESSING) )
1944c1957
<     if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD) )
---
>     if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD | DPNSESSION_NODPNSVR) )
2193a2207
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
41c41
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\peer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
64d63
< #include <wchar.h>
115c114
< typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\server.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
58d57
< #include <wchar.h>
107c106
< typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
41,42c41
< TARGETLIBS= \
< # $(TARGETLIBS) \
---
> TARGETLIBS=$(TARGETLIBS) \
45,46c44,52
<            ..\..\dnaddress\daytona\obj$(BUILD_ALT_DIR)\*\dpnaddr.lib \
<            ..\..\sp\wsock\daytona\obj$(BUILD_ALT_DIR)\*\dpnwsock.lib \
---
>            ..\..\dpnsvr\dpnsvlib\obj$(BUILD_ALT_DIR)\*\dpnsvlib.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
48,50c54
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<              $(SDK_LIB_PATH)\libcntpr.lib
---
> 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
63c67
< INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\protocol;..\..\common
---
> INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\protocol;..\..\common;..\..\dpnsvr\dpnsvlib;..\..\dpnsvr\inc
64a69
> 
103a109
>          ..\voice.cpp \
115c121
< C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DUNICODE
---
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
121c127
< DLLENTRY=DllMain
---
> DLLENTRY=_DllMainCRTStartup
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "DVoice.h"
47a49
> #include "voice.h"
164a167,168
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
198a203,204
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
230a237,238
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
265a274,275
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
299a310,311
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
335a348,349
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
603a618,619
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addbase.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
251d250
< /* BUGBUG: [mgere] [xbox] Removed this function.
276d274
< */  return DPNERR_UNSUPPORTED;
287,288c285,344
< // BUGBUG: [mgere] [xbox] ANSI not supported
< 	return DPNERR_UNSUPPORTED;
---
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pszAddress == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer to address.  An address must be specified" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( !DNVALID_STRING_A( pszAddress ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid string specified for address" );
> 		DP8A_RETURN( DPNERR_INVALIDSTRING );
> 	}
> 
> 	DPF( DP8A_PARAMLEVEL, "pszAddress = %s", pszAddress );
> 
> 	WCHAR *szShadowBuffer = NULL;
> 
> 	DWORD dwStrSize = 0;
> 
> 	if( pszAddress != NULL )
> 	{
> 		dwStrSize = strlen(pszAddress)+1;
> 		
> 		szShadowBuffer = new WCHAR[dwStrSize];
> 
> 		if( szShadowBuffer == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto BUILDFROMURLW_RETURN;
> 		}
> 
> 		if( FAILED( hr = STR_jkAnsiToWide( szShadowBuffer, pszAddress, dwStrSize ) )  )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting URL to ANSI hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 			goto BUILDFROMURLW_RETURN;
> 		}
> 	}
> 
> 	hr = pdp8Address->SetURL( szShadowBuffer );
> 
> BUILDFROMURLW_RETURN:
> 
> 	if( szShadowBuffer )
> 		delete [] szShadowBuffer;
> 
> 	DP8A_RETURN( hr );	
391c447
<     hr = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, (void **) &lpdp8Address, NULL);
---
>     hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER  , IID_IDirectPlay8Address, (void **) &lpdp8Address );
431,432c487,553
< // BUGBUG: [mgere] [xbox] ANSI not supported.
< 	return DPNERR_UNSUPPORTED;
---
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pdwAddressSize == NULL ||
> 	   !DNVALID_WRITEPTR( pdwAddressSize, sizeof(DWORD) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for address size" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
> 	}
> 
> 	if( *pdwAddressSize > 0 &&
> 	   (pszAddress == NULL ||
> 	    !DNVALID_WRITEPTR( pszAddress, (*pdwAddressSize) ) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for address" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	DPF( DP8A_PARAMLEVEL, "pwszAddress = 0x%x pdwAddressSize = 0x%x (%u)",
> 	     pszAddress , pdwAddressSize, *pdwAddressSize );
> 
> 	WCHAR *szShadowBuffer = NULL;
> 
> 	if( *pdwAddressSize  != 0 )
> 	{
> 		szShadowBuffer = new WCHAR[*pdwAddressSize];
> 
> 		if( szShadowBuffer == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto GETURLW_RETURN;
> 		}
> 	}
> 	else
> 	{	
> 		szShadowBuffer= NULL;
> 	}
> 
> 	hr = pdp8Address->BuildURL( szShadowBuffer, pdwAddressSize );
> 
> 	if( hr == DPN_OK )
> 	{
> 		if( FAILED( hr = STR_jkWideToAnsi( pszAddress, szShadowBuffer, *pdwAddressSize ) ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting ANSI->WIDE hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 			goto GETURLW_RETURN;
> 		}
> 	}
> 	
> GETURLW_RETURN:
> 
> 	if( szShadowBuffer != NULL )
> 		delete [] szShadowBuffer;
> 
> 	DP8A_RETURN( hr );
847c968,969
< 	   dwDataType != DPNA_DATATYPE_BINARY )
---
> 	   dwDataType != DPNA_DATATYPE_BINARY &&
> 	   dwDataType != DPNA_DATATYPE_STRING_ANSI )
866a989,1002
> 	else if( dwDataType == DPNA_DATATYPE_STRING_ANSI )
> 	{
> 		if( !DNVALID_STRING_A( (const CHAR * const) pComponentData ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Invalid string component specified" );
> 			DP8A_RETURN( DPNERR_INVALIDSTRING );
> 		}
> 
> 		if( ((strlen( (const CHAR * const) pComponentData)+1)*sizeof(char)) != dwComponentSize )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "String size and component size don't match" );
> 			DP8A_RETURN( DPNERR_INVALIDPARAM );
> 		}
> 	}
960a1097,1528
> 
> #if 0
> // Use the following code to create ANSI versions of the core functions.  (If required)
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8A_GetComponentByNameW"
> STDMETHODIMP DP8A_GetComponentByNameW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType )
> {
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
> 	HRESULT hr;
> 	CHAR *szTag;
> 	DWORD dwComponentSize = 0,
> 	        dwDataType = 0,
> 	        dwNameLen = 0;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pwszTag == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer for tag" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( pdwComponentSize == NULL ||
> 	   !DNVALID_WRITEPTR( pdwComponentSize, sizeof(DWORD)) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid Pointer to data size" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( *pdwComponentSize > 0 &&
> 	   (pComponentBuffer == NULL || !DNVALID_WRITEPTR( pComponentBuffer, *pdwComponentSize ) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer to component data" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( pdwDataType == NULL ||
> 	   !DNVALID_READPTR( pdwDataType, sizeof(DWORD)) )	
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer to data type" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( !DNVALID_STRING_W( pwszTag ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid string specified for tag" );
> 		DP8A_RETURN( DPNERR_INVALIDSTRING );				
> 	}	
> 	
> 	DPF( DP8A_PARAMLEVEL, "pwszTag = 0x%x pComponentBuffer = 0x%x, pdwComponentSize = 0x%x (%u), pdwDataType = 0x%x",
> 		pwszTag, pComponentBuffer, pdwComponentSize, *pdwComponentSize, pdwDataType );
> 
> 	dwNameLen = wcslen(pwszTag)+1;
> 
> 	szTag = new char[dwNameLen];
> 
> 	if( szTag == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Error on memory allocation" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto GETCOMPONENT_RETURN;
> 	}
> 
> 	hr = WideToAnsi( szTag, pwszTag, dwNameLen );
> 	if( FAILED( hr ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Error converting key hr=0x%x", hr );
> 		hr = DPNERR_CONVERSION;		
> 		goto GETCOMPONENT_RETURN;
> 	}
> 
> 	hr = pdp8Address->GetElement( szTag, NULL, &dwComponentSize, &dwDataType );	
> 
> 	if( hr != DPNERR_BUFFERTOOSMALL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Error calling GetElement hr=0x%x", hr );
> 		goto GETCOMPONENT_RETURN;	
> 	}
> 
> 	if( dwDataType == DPNA_DATATYPE_STRING )
> 	{
> 		if( pComponentBuffer != NULL )
> 		{
> 			*pdwComponentSize /= 2;
> 			CHAR *szTmpComponent = new char[*pdwComponentSize];
> 
> 			if( szTmpComponent == NULL )
> 			{
> 				DPF( DP8A_ERRORLEVEL, "Error allocating memory for conversion hr" );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto GETCOMPONENT_RETURN;
> 			}
> 
> 			hr = pdp8Address->GetElement( szTag, szTmpComponent, pdwComponentSize, pdwDataType );			
> 
> 			if( hr == DPN_OK )
> 			{
> 				hr = AnsiToWide( (WCHAR *) pComponentBuffer, szTmpComponent, *pdwComponentSize );
> 
> 				*pdwComponentSize *= 2;			
> 	
> 				if( FAILED( hr ) )
> 				{
> 					delete [] szTmpComponent;
> 					DPF( DP8A_ERRORLEVEL, "Error converting from ANSI to WIDE hr=0x%x", hr );
> 					hr = DPNERR_CONVERSION;
> 					goto GETCOMPONENT_RETURN;
> 				}
> 			}
> 			else
> 			{
> 				*pdwComponentSize *= 2;			
> 			}
> 
> 			delete [] szTmpComponent;
> 
> 		}
> 		else
> 		{
> 			if( pdwComponentSize != NULL )
> 				*pdwComponentSize /= 2;
> 
> 			hr = pdp8Address->GetElement( szTag, pComponentBuffer, pdwComponentSize, pdwDataType );			
> 
> 			if( pdwComponentSize != NULL )
> 				*pdwComponentSize *= 2;
> 		}
> 	}
> 	else
> 	{
> 		hr = pdp8Address->GetElement( szTag, pComponentBuffer, pdwComponentSize, pdwDataType );				
> 	}
> 
> GETCOMPONENT_RETURN:
> 
> 	if( szTag != NULL )
> 		delete [] szTag;
> 		
> 	DP8A_RETURN( hr );
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8A_GetComponentByIndexW"
> STDMETHODIMP DP8A_GetComponentByIndexW( IDirectPlay8Address *pInterface,
> 	const DWORD dwComponentID, WCHAR * pwszTag, PDWORD pdwNameLen,
> 	void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType )
> {
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
> 	HRESULT hr;
> 	CHAR *szTag;
> 	DWORD dwNameLen = 0,
> 	        dwComponentSize = 0,
> 	        dwDataType = 0;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pdwNameLen == NULL || !DNVALID_WRITEPTR( pdwNameLen, sizeof(DWORD) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for pdwNameLen" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}	
> 
> 	if( *pdwNameLen != 0 &&
> 	   (pwszTag == NULL || !DNVALID_WRITEPTR( pwszTag, *pdwNameLen*sizeof(WCHAR) ) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for pwszTag" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( pdwComponentSize == NULL || !DNVALID_WRITEPTR( pdwComponentSize, sizeof(DWORD) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for pdwComponentSize" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( *pdwComponentSize != 0 &&
> 	   (pComponentBuffer == NULL || !DNVALID_WRITEPTR( pComponentBuffer, *pdwComponentSize ) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for pwszTag" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}	
> 
> 	if( pdwDataType == NULL || !DNVALID_WRITEPTR( pdwDataType, sizeof(DWORD) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for pdwDataType" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}	
> 
> 	if( pdwNameLen != NULL &&
> 	   *pdwNameLen > 0 )
> 	{
> 		szTag = new char[*pdwNameLen];
> 
> 		dwNameLen = *pdwNameLen;
> 	}
> 	else
> 	{
> 		szTag = NULL;
> 	}
> 
> 	hr = pdp8Address->GetElement( dwComponentID, szTag, &dwNameLen, NULL, &dwComponentSize, &dwDataType );	
> 
> 	if( hr != DPNERR_BUFFERTOOSMALL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Error calling GetElement hr=0x%x", hr );
> 		goto GETCOMPONENT_RETURN;	
> 	}
> 
> 	if( dwDataType == DPNA_DATATYPE_STRING )
> 	{
> 		if( pdwComponentSize != NULL && pComponentBuffer != NULL )
> 		{
> 			*pdwComponentSize /= 2;
> 			CHAR *szTmpComponent = new char[*pdwComponentSize];
> 
> 			if( szTmpComponent == NULL )
> 			{
> 				DPF( DP8A_ERRORLEVEL, "Error allocating memory for conversion hr" );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto GETCOMPONENT_RETURN;
> 			}
> 
> 			hr = pdp8Address->GetElement( dwComponentID, szTag, pdwNameLen, szTmpComponent, pdwComponentSize, pdwDataType );			
> 
> 			if( hr == DPN_OK )
> 			{
> 				hr = AnsiToWide( (WCHAR *) pComponentBuffer, szTmpComponent, *pdwComponentSize );
> 
> 				*pdwComponentSize *= 2;			
> 	
> 				if( FAILED( hr ) )
> 				{
> 					delete [] szTmpComponent;
> 					hr = DPNERR_CONVERSION;
> 					DPF( DP8A_ERRORLEVEL, "Error converting from ANSI to WIDE hr=0x%x", hr );
> 					goto GETCOMPONENT_RETURN;
> 				}
> 			}
> 			else
> 			{
> 				*pdwComponentSize *= 2;			
> 			}
> 
> 			delete [] szTmpComponent;
> 
> 		}
> 		else
> 		{
> 			if( pdwComponentSize != NULL )
> 				*pdwComponentSize /= 2;
> 
> 			hr = pdp8Address->GetElement( dwComponentID, szTag, pdwNameLen, pComponentBuffer, pdwComponentSize, pdwDataType );			
> 
> 			if( pdwComponentSize != NULL )
> 				*pdwComponentSize *= 2;
> 		}
> 	}
> 	else
> 	{
> 		hr = pdp8Address->GetElement( dwComponentID, szTag, pdwNameLen, pComponentBuffer, pdwComponentSize, pdwDataType );				
> 	}
> 
> 	if( hr == DPN_OK )
> 	{
> 		hr = AnsiToWide( pwszTag, szTag, *pdwNameLen );
> 
> 		if( FAILED( hr ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting tag ANSI to WIDE hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 		}
> 	}
> 
> GETCOMPONENT_RETURN:
> 
> 	if( szTag != NULL )
> 		delete [] szTag;
> 		
> 	DP8A_RETURN( hr );
> 
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8A_AddComponentW"
> STDMETHODIMP DP8A_AddComponentW( IDirectPlay8Address *pInterface, const WCHAR * const pwszTag, const void * const pComponentData, const DWORD dwComponentSize, const DWORD dwDataType )
> {
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (PDP8ADDRESSOBJECT) GET_OBJECT_FROM_INTERFACE( pInterface );
> 	HRESULT hr;
> 	DWORD dwTmpLen;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pwszTag == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer for tag string" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( pComponentData == NULL ||
> 	   !DNVALID_READPTR( pComponentData, dwComponentSize ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for component" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( !DNVALID_STRING_W( pwszTag ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid string specified for tag" );
> 		DP8A_RETURN( DPNERR_INVALIDSTRING );
> 	}
> 
> 	if( dwDataType == DPNA_DATATYPE_STRING &&
> 	   dwDataType == DPNA_DATATYPE_DWORD &&
> 	   dwDataType == DPNA_DATATYPE_GUID &&
> 	   dwDataType != DPNA_DATATYPE_BINARY )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid datatype specified" );
> 		DP8A_RETURN( DPNERR_INVALIDPARAM );
> 	}
> 
> 	if( dwDataType == DPNA_DATATYPE_STRING )
> 	{
> 		if( !DNVALID_STRING_A( (const char * const)  pComponentData ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Invalid string component specified" );
> 			DP8A_RETURN( DPNERR_INVALIDSTRING );
> 		}
> 
> 		if( (wcslen( (const WCHAR * const) pComponentData)+1)*sizeof(WCHAR) != dwComponentSize )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "String size and component size don't match" );
> 			DP8A_RETURN( DPNERR_INVALIDPARAM );
> 		}
> 	}
> 	else if( dwDataType == DPNA_DATATYPE_DWORD )
> 	{
> 		if( dwComponentSize != sizeof( DWORD ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Invalid size for DWORD component" );
> 			DP8A_RETURN( DPNERR_INVALIDPARAM );
> 		}
> 	}
> 	else if( dwDataType == DPNA_DATATYPE_GUID )
> 	{
> 		if( dwComponentSize != sizeof( GUID ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Invalid size for GUID component" );
> 			DP8A_RETURN( DPNERR_INVALIDPARAM );
> 		}	
> 	}
> 
> 	DPF( DP8A_PARAMLEVEL, "pwszTag = %x pComponentData = 0x%x dwComponentSize = %d dwDataType = %d",
> 	     pwszTag, pComponentData, dwComponentSize, dwDataType );	
> 
> 	dwTmpLen = wcslen(pwszTag)+1;
> 
> 	CHAR *pszTmpTag = new char[dwTmpLen];
> 	CHAR *pszTmpConvert = NULL;
> 
> 	if( pszTmpTag == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Out of memory" );
> 		DP8A_RETURN( DPNERR_OUTOFMEMORY );
> 	}
> 
> 	hr = WideToAnsi( pszTmpTag, pwszTag, dwTmpLen );
> 
> 	if( FAILED( hr ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Bad string for tag" );
> 		DP8A_RETURN( DPNERR_CONVERSION );		
> 	}
> 
> 	if( dwDataType == DPNA_DATATYPE_STRING )
> 	{
> 		dwTmpLen = wcslen((WCHAR *) pComponentData)+1;
> 		CHAR *pszTmpConvert = new char[dwTmpLen];
> 
> 		if( pszTmpConvert == NULL )
> 		{
> 			delete [] pszTmpConvert;
> 			DPF( DP8A_ERRORLEVEL, "Out of memory" );
> 			DP8A_RETURN( DPNERR_OUTOFMEMORY );		
> 		}
> 
> 		hr = WideToAnsi( pszTmpConvert, (WCHAR *) pComponentData, dwTmpLen );
> 
> 		if( FAILED( hr ) )
> 		{
> 			delete [] pszTmpTag;
> 			delete [] pszTmpConvert;
> 			DPF( DP8A_ERRORLEVEL, "Bad string for component" );
> 			DP8A_RETURN( DPNERR_GENERIC );
> 		}
> 		
> 		hr = pdp8Address->SetElement( pszTmpTag, pszTmpConvert, dwTmpLen, dwDataType );
> 
> 		delete [] pszTmpConvert;
> 	}
> 	else
> 	{
> 		hr = pdp8Address->SetElement( pszTmpTag, pComponentData, dwComponentSize, dwDataType );
> 	}
> 
> 	delete [] pszTmpTag;
> 
> 	DP8A_RETURN( hr );
> }
> 
> 
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
36a37
> #include <stdio.h>
37a39
> #include "dplegacy.h"
39d40
< #include <wchar.h>
356a358,376
> 	case DPNA_DATATYPE_STRING_ANSI:
>         wszUnicodeString = new WCHAR[dwRealDataSize];
>         if( wszUnicodeString == NULL )
>         {
>             DPF( 0, "Error allocating memory for conversion" );
>             return DPNERR_OUTOFMEMORY;
>         }
> 
> 		hr = STR_jkAnsiToWide( wszUnicodeString, (const char * const) pvData, dwRealDataSize );
> 
> 		if( FAILED( hr ) )
> 		{
> 		    DPF( 0, "Error unable to convert element ANSI->Unicode 0x%x", hr );
>             return DPNERR_CONVERSION;
> 		}
> 		pvRealData = wszUnicodeString;
> 	    dwRealDataSize = dwDataSize*sizeof(WCHAR);
> 		dwRealDataType = DPNA_DATATYPE_STRING;
> 	    break;
380a401,412
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     hr= SetSP( &CLSID_DP8SP_IPX );
>                 }
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_MODEMPROVIDER ) == 0 )
>                 {
>                     hr = SetSP( &CLSID_DP8SP_MODEM );
>                 }
>                 else if( wcscmp( (const WCHAR * const) pvRealData, DPNA_VALUE_SERIALPROVIDER ) == 0 )
>                 {
>                     hr = SetSP( &CLSID_DP8SP_SERIAL );
>                 }
1317a1350,1415
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ADDRESSOBJECT::SetDirectPlay4Address"
> HRESULT DP8ADDRESSOBJECT::SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize )
> {
>     PBYTE pbCurrentLocation;
>     PDPADDRESS pdpAddressChunk;
>     LONG lRemaining;
>     HRESULT hr = DPN_OK;
>     DWORD dwCurrentChunkSize;
> 
> 	if( IsLocked() )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
> 		return DPNERR_NOTALLOWED;
> 	}
> 
>     // XBOX! This function will not be required on XBOX.  Have it return DPNERR_NOTSUPPORTED
>     ENTERLOCK();
> 
>     hr = Clear();
> 
>     if( FAILED( hr ) )
>     {
>         DPF( 0, "Failed to clear old address data hr=[0x%lx]", hr );
>         LEAVELOCK();
>         return hr;
>     }
> 
>     pbCurrentLocation = (PBYTE) pvDataBuffer;
>     lRemaining = dwDataSize;
> 
>     while( lRemaining > 0 )
>     {
>         pdpAddressChunk = (PDPADDRESS) pbCurrentLocation;
> 
>         if( sizeof( DPADDRESS ) > lRemaining )
>         {
>             DPF( 0, "Error parsing address, unexpected end of address" );
>             return DPNERR_INVALIDADDRESSFORMAT;
>         }
> 
>         dwCurrentChunkSize = sizeof( DPADDRESS ) + pdpAddressChunk->dwDataSize;
> 
>         if( ((LONG) (dwCurrentChunkSize + pdpAddressChunk->dwDataSize)) > lRemaining )
>         {
>             DPF( 0, "Error parsing address, unexpected end during data" );
>             return DPNERR_INVALIDADDRESSFORMAT;
>         }
> 
>         hr = AddDP4Element( pdpAddressChunk, this );
> 
>         if( FAILED( hr ) )
>         {
>             DPF( 0, "Error adding next element" );
>             break;
>         }
> 
>         lRemaining -= dwCurrentChunkSize;
> 
>         pbCurrentLocation += dwCurrentChunkSize;
>     }
> 
>     LEAVELOCK();
> 
>     return hr;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
125a126,127
>     HRESULT SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addparse.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
26c26
< #include <wchar.h>
---
> #include <stdio.h>
556,557d555
< // BUGBUG: [mgere] [xbox] Removed wtol temporarily until it is implemented on xbox
< //		dwTmpValue = _wtol( m_pwszCurrentValue );
558a557,558
> 		dwTmpValue = _wtol( m_pwszCurrentValue );
> 
565,566d564
< // BUGBUG: [mgere] [xbox] Removed swscanf temporarily until it is implemented on xbox
< /*
591d588
< */
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addtcp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
730a731,841
> #if 0
> // Use these functions to build ANSI versions of above
> typedef	STDMETHODIMP DP8ATCP_GetComponentByNameA( IDirectPlay8AddressIP *pInterface, const CHAR * const pszTag, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType );
> typedef	STDMETHODIMP DP8ATCP_GetComponentByIndexA( IDirectPlay8AddressIP *pInterface, const DWORD dwComponentID, CHAR * pszTag, PDWORD pdwNameLen, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType );
> typedef	STDMETHODIMP DP8ATCP_AddComponentA( IDirectPlay8AddressIP *pInterface, const CHAR * const pszTag, const void * const pComponentData, const DWORD dwComponentSize, const DWORD dwDataType );
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ATCP_BuildAddressW"
> STDMETHODIMP DP8ATCP_BuildAddressW( IDirectPlay8AddressIP *pInterface, const WCHAR * const pwszAddress, const USHORT usPort )
> {
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 	
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );
> 
> 	LPSTR pszShadowAddress = NULL;
> 
> 	if( pwszAddress != NULL )
> 	{
> 		pszShadowAddress = new char[wcslen(pwszAddress)+1];
> 
> 		if( pszShadowAddress == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Out of memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto BUILDADDRESSW_EXIT;
> 		}
> 
> 		hr = WideToAnsi( pszShadowAddress, pwszAddress, wcslen(pwszAddress)+1 );
> 
> 		if( FAILED( hr ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting Address to ANSI hr=0x%x", hr );
> 			hr = DPNERR_GENERIC;
> 			goto BUILDADDRESSW_EXIT;
> 		}
> 	}
> 
> 	hr = DP8ATCP_BuildAddressA( pInterface, pszShadowAddress, usPort );
> 
> BUILDADDRESSW_EXIT:
> 
> 	if( pszShadowAddress != NULL )
> 		delete [] pszShadowAddress;
> 
> 	return hr;
> 	
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ATCP_GetAddressW"
> STDMETHODIMP DP8ATCP_GetAddressW( IDirectPlay8AddressIP *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressLength, PUSHORT pusPort )
> {
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 	
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );
> 
> 	LPSTR pszShadowAddress = NULL;
> 	DWORD dwShadowAddressSize = 0;
> 
> 	if( pwszAddress != NULL && pdwAddressLength != NULL )
> 	{
> 		pszShadowAddress = new char[*pdwAddressLength];
> 
> 		if( pszShadowAddress == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Out of memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto GETADDRESSW_EXIT;
> 		}
> 	}
> 
> 	hr = DP8ATCP_GetAddressA( pInterface, pszShadowAddress, pdwAddressLength, pusPort );
> 
> 	if( hr == DPN_OK )
> 	{
> 		hr = AnsiToWide( pwszAddress, pszShadowAddress, *pdwAddressLength );
> 
> 		if( FAILED( hr ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Unable to convert name to Wide hr=0x%x", hr );
> 			goto GETADDRESSW_EXIT;
> 		}
> 	}
> 
> GETADDRESSW_EXIT:
> 
> 	if( pszShadowAddress != NULL )
> 		delete [] pszShadowAddress;
> 
> 	return hr;
> }
> 
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
31c31
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
24a25,31
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DPNAddress"
> 
> /*
31a39,67
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNAddress"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNAddress"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnaddr.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address \0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,61
> 
> #endif
> 
> #endif    // !_MAC
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
43,46c43,52
< 	   $(BASEDIR)\public\sdk\lib\*\winsockx.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib
---
> 	   $(BASEDIR)\public\sdk\lib\*\wsock32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
77a84
>          ..\dplegacy.cpp \
84c91
< C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DUNICODE
---
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
89c96
< DLLENTRY=DllMain
---
> DLLENTRY=_DllMainCRTStartup
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
63a64,75
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
> // {826F86D1-AE2C-4428-A66F-974381B25F5B}
> DEFINE_GUID(IID_IDirectPlay8AddressModem,
> 0x826f86d1, 0xae2c, 0x4428, 0xa6, 0x6f, 0x97, 0x43, 0x81, 0xb2, 0x5f, 0x5b);
> 
> // {59BE79FE-A96A-4710-9BD2-22A50E7B24BD}
> DEFINE_GUID(IID_IDirectPlay8AddressSerial,
> 0x59be79fe, 0xa96a, 0x4710, 0x9b, 0xd2, 0x22, 0xa5, 0xe, 0x7b, 0x24, 0xbd);
> 
71a84,86
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
> typedef struct IDirectPlay8AddressSerial  	*PDIRECTPLAY8ADDRESSSERIAL, *LPDIRECTPLAY8ADDRESSSERIAL;
> typedef struct IDirectPlay8AddressModem		*PDIRECTPLAY8ADDRESSMODEM, *LPDIRECTPLAY8ADDRESSMODEM;
87a103
> #define DPNA_DATATYPE_STRING_ANSI           0x00000005
348a365,400
> // values for baud rate
> #define DPNA_BAUD_RATE_110					L"110"
> #define DPNA_BAUD_RATE_300					L"300"
> #define DPNA_BAUD_RATE_600					L"600"
> #define DPNA_BAUD_RATE_1200					L"1200"
> #define DPNA_BAUD_RATE_2400					L"2400"
> #define DPNA_BAUD_RATE_4800					L"4800"
> #define DPNA_BAUD_RATE_9600					L"9600"
> #define DPNA_BAUD_RATE_14400				L"14400"
> #define DPNA_BAUD_RATE_19200				L"19200"
> #define DPNA_BAUD_RATE_38400				L"38400"
> #define DPNA_BAUD_RATE_56000				L"56000"
> #define DPNA_BAUD_RATE_57600				L"57600"
> #define DPNA_BAUD_RATE_115200				L"115200"
> #define DPNA_BAUD_RATE_128000				L"128000"
> #define DPNA_BAUD_RATE_256000				L"256000"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE					L"1"
> #define DPNA_STOP_BITS_ONE_FIVE				L"1.5"
> #define DPNA_STOP_BITS_TWO					L"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE					L"NONE"
> #define DPNA_PARITY_EVEN					L"EVEN"
> #define DPNA_PARITY_ODD						L"ODD"
> #define DPNA_PARITY_MARK					L"MARK"
> #define DPNA_PARITY_SPACE					L"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE				L"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF			L"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS				L"RTS"
> #define DPNA_FLOW_CONTROL_DTR				L"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR			L"RTSDTR"
> 
350a403,405
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
352a408,470
> //// ANSI DEFINITIONS
> 
> // Header
> #define DPNA_HEADER_A						"x-directplay:/"
> #define DPNA_SEPARATOR_KEYVALUE_A			'='
> #define DPNA_SEPARATOR_USERDATA_A			'#'
> #define DPNA_SEPARATOR_COMPONENT_A			';'
> #define DPNA_ESCAPECHAR_A					'%'
> 
> // key names for address components
> #define DPNA_KEY_APPLICATION_INSTANCE_A		"applicationinstance"
> #define DPNA_KEY_BAUD_A						"baud"
> #define DPNA_KEY_DEVICE_A					"device"
> #define DPNA_KEY_FLOWCONTROL_A				"flowcontrol"
> #define DPNA_KEY_HOSTNAME_A					"hostname"
> #define DPNA_KEY_PARITY_A					"parity"
> #define DPNA_KEY_PHONENUMBER_A				"phonenumber"
> #define DPNA_KEY_PORT_A						"port"
> #define DPNA_KEY_PROGRAM_A					"program"
> #define DPNA_KEY_PROVIDER_A					"provider"
> #define DPNA_KEY_STOPBITS_A					"stopbits"
> 
> // values for baud rate
> #define DPNA_BAUD_RATE_110_A				"110"
> #define DPNA_BAUD_RATE_300_A				"300"
> #define DPNA_BAUD_RATE_600_A				"600"
> #define DPNA_BAUD_RATE_1200_A				"1200"
> #define DPNA_BAUD_RATE_2400_A				"2400"
> #define DPNA_BAUD_RATE_4800_A				"4800"
> #define DPNA_BAUD_RATE_9600_A				"9600"
> #define DPNA_BAUD_RATE_14400_A				"14400"
> #define DPNA_BAUD_RATE_19200_A				"19200"
> #define DPNA_BAUD_RATE_38400_A				"38400"
> #define DPNA_BAUD_RATE_56000_A				"56000"
> #define DPNA_BAUD_RATE_57600_A				"57600"
> #define DPNA_BAUD_RATE_115200_A				"115200"
> #define DPNA_BAUD_RATE_128000_A				"128000"
> #define DPNA_BAUD_RATE_256000_A				"256000"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE_A				"1"
> #define DPNA_STOP_BITS_ONE_FIVE_A			"1.5"
> #define DPNA_STOP_BITS_TWO_A				"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE_A					"NONE"
> #define DPNA_PARITY_EVEN_A					"EVEN"
> #define DPNA_PARITY_ODD_A					"ODD"
> #define DPNA_PARITY_MARK_A					"MARK"
> #define DPNA_PARITY_SPACE_A					"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE_A			"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF_A 		"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS_A				"RTS"
> #define DPNA_FLOW_CONTROL_DTR_A				"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR_A			"RTSDTR"
> 
> // Shortcut values
> #define DPNA_VALUE_TCPIPPROVIDER_A          "IP"
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
> #define DPNA_VALUE_MODEMPROVIDER_A          "MODEM"
> #define DPNA_VALUE_SERIALPROVIDER_A         "SERIAL"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
99,100d98
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
148a147,155
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {6D4A3650-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_MODEM, 0x6d4a3650, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {743B5D60-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_SERIAL, 0x743b5d60, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
172a180,182
> typedef struct IDirectPlay8LobbiedApplication	*PDNLOBBIEDAPPLICATION;
> typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
> 
633a644
> #define	DPNCONNECT_OKTOQUERYFORADDRESSING	0x0001
638a650
> #define	DPNENUMHOSTS_OKTOQUERYFORADDRESSING	0x0001
737a750
> #define DPNSESSION_NODPNSVR					0x0040
804c817
< 	STDMETHOD(RegisterLobby)			(THIS_ PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
849c862
< 	STDMETHOD(RegisterLobby)			(THIS_ PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
899c912
< 	STDMETHOD(RegisterLobby)			(THIS_ PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpsp8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
53a54
> #define DPNSPF_OKTOQUERY			0x00000002		// OK for SP to ask the user for clarification on addresses
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\backend.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
202d201
< 				ASSERT(pMSD->hCommand == Handle);
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
107c107
< 	DNASSERT( ulFlags == 0 );
---
> 	DNASSERT( ( ulFlags & ~( DPNCONNECT_OKTOQUERYFORADDRESSING ) ) == 0 );
108a109,113
> 	if ( ( ulFlags & DPNCONNECT_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		ConnData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\enum.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
149c149,154
< 	DNASSERT( ( dwFlags & ~( DPNENUMHOSTS_NOBROADCASTFALLBACK ) ) == 0 );
---
> 	DNASSERT( ( dwFlags & ~( DPNENUMHOSTS_OKTOQUERYFORADDRESSING | DPNENUMHOSTS_NOBROADCASTFALLBACK ) ) == 0 );
> 	if ( ( dwFlags & DPNENUMHOSTS_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		EnumData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\initialize.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
352c352
< 		if((pSPD->hSendEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL){
---
> 		if((pSPD->hSendEvent = CreateEventA(NULL, FALSE, FALSE, NULL)) == NULL){
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
80c80
< C_DEFINES= $(C_DEFINES) /D_LIB /DWIN32 /D_MT /DCINTERFACE /DMICHAEL /DUNICODE
---
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE /DMICHAEL
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\timer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
549c549
< 	hWorkToDoSem=CreateSemaphore(NULL,0,65535,NULL);
---
> 	hWorkToDoSem=CreateSemaphoreA(NULL,0,65535,NULL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
195,196c195,225
< // BUGBUG: [mgere] [xbox]  Removed all code in here.  I don't believe it's necessary anymore and it was using some COM functions that we don't have.
< 	return S_OK;
---
>     HRESULT		hr;
>     HINSTANCE	hdll;
>     LPGPCLASSFACTORY	pcf;
> 
> 
>     pcf = (LPGPCLASSFACTORY) This;
> 
>     /*
>      * call CoLockObjectExternal
>      */
>     hr = E_UNEXPECTED;
>     hdll = LoadLibraryA( "OLE32.DLL" );
>     if( hdll != NULL )
>     {
>         PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;
> 
> 
> 		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, "CoLockObjectExternal" ) );
>         if( lpCoLockObjectExternal != NULL )
>         {
>             hr = lpCoLockObjectExternal( (LPUNKNOWN) This, fLock, TRUE );
>         }
>         else
>         {
>         }
>     }
>     else
>     {
>     }
> 
> 	return hr;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
30a38,66
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNSPWinsock"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectDPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNSPWinsock"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
114a116,135
> 					);
> 			break;
> 		}
> 
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( dwDebugLevel, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,23
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> #include "resource.h"
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> #include "resource.h"
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a25
> #endif //_WIN32
3a27,34
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a36,51
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnwsock.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a60,142
> 
> #endif
> 
> #endif    // !_MAC
> 
> #ifdef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // TEXTINCLUDE
> //
> 
> 1 TEXTINCLUDE DISCARDABLE
> BEGIN
>     "resource.h\0"
> END
> 
> 2 TEXTINCLUDE DISCARDABLE
> BEGIN
>     "#include ""afxres.h""\r\n"
>     "\0"
> END
> 
> 3 TEXTINCLUDE DISCARDABLE
> BEGIN
>     "\r\n"
>     "\0"
> END
> 
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // Dialog
> //
> 
> IDD_IP_SETTINGS DIALOG DISCARDABLE  0, 0, 194, 66
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION |
>     WS_SYSMENU
> CAPTION "Enter host name"
> FONT 8, "MS Shell Dlg"
> BEGIN
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
> END
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // DESIGNINFO
> //
> 
> #ifdef APSTUDIO_INVOKED
> GUIDELINES DESIGNINFO DISCARDABLE
> BEGIN
>     IDD_IP_SETTINGS, DIALOG
>     BEGIN
>         LEFTMARGIN, 7
>         RIGHTMARGIN, 187
>         TOPMARGIN, 7
>         BOTTOMMARGIN, 59
>     END
> END
> #endif    // APSTUDIO_INVOKED
> 
> #endif    // English (U.S.) resources
> /////////////////////////////////////////////////////////////////////////////
> 
> 
> 
> #ifndef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 3 resource.
> //
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> #endif    // not APSTUDIO_INVOKED
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock1.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,42c1,67
< #define p_accept accept
< #define p_bind bind
< #define p_closesocket closesocket
< #define p_connect connect
< #define p_gethostbyaddr gethostbyaddr
< #define p_gethostbyname gethostbyname
< #define p_gethostname gethostname
< #define p_getpeername getpeername
< #define p_getprotobyname getprotobyname
< #define p_getprotobynumber getprotobynumber
< #define p_getservbyname getservbyname
< #define p_getservbyport getservbyport
< #define p_getsockname getsockname
< #define p_getsockopt getsockopt
< #define p_htonl htonl
< #define p_htons htons
< #define p_inet_addr inet_addr
< #define p_inet_ntoa inet_ntoa
< #define p_ioctlsocket ioctlsocket
< #define p_listen listen
< #define p_ntohl ntohl
< #define p_ntohs ntohs
< #define p_recv recv
< #define p_recvfrom recvfrom
< #define p_select select
< #define p_send send
< #define p_sendto sendto
< #define p_setsockopt setsockopt
< #define p_shutdown shutdown
< #define p_socket socket
< //#define p_WSAAsyncGetHostByAddr WSAAsyncGetHostByAddr
< //#define p_WSAAsyncGetHostByName WSAAsyncGetHostByName
< //#define p_WSAAsyncGetProtoByName WSAAsyncGetProtoByName
< //#define p_WSAAsyncGetProtoByNumber WSAAsyncGetProtoByNumber
< //#define p_WSAAsyncGetServByName WSAAsyncGetServByName
< //#define p_WSAAsyncGetServByPort WSAAsyncGetServByPort
< //#define p_WSAAsyncSelect WSAAsyncSelect
< //#define p_WSACancelAsyncRequest WSACancelAsyncRequest
< #define p_WSACleanup WSACleanup
< #define p_WSAGetLastError WSAGetLastError
< #define p_WSASetLastError WSASetLastError
< #define p_WSAStartup WSAStartup
---
> //
> // DWNSOCK1.INC	Macros for dynamically linking to WinSock 1.1
> //
> 
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	//
> 	// Function available in both versions
> 	//
> 	DYNAMICWINSOCK(accept, LPFN_ACCEPT);
> 	DYNAMICWINSOCK(bind, LPFN_BIND);
> 	DYNAMICWINSOCK(closesocket, LPFN_CLOSESOCKET);
> 	DYNAMICWINSOCK(connect, LPFN_CONNECT);
> 	DYNAMICWINSOCK(gethostbyaddr, LPFN_GETHOSTBYADDR);
> 	DYNAMICWINSOCK(gethostbyname, LPFN_GETHOSTBYNAME);
> 	DYNAMICWINSOCK(gethostname, LPFN_GETHOSTNAME);
> 	DYNAMICWINSOCK(getpeername, LPFN_GETPEERNAME);
> 	DYNAMICWINSOCK(getprotobyname, LPFN_GETPROTOBYNAME);
> 	DYNAMICWINSOCK(getprotobynumber, LPFN_GETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(getservbyname, LPFN_GETSERVBYNAME);
> 	DYNAMICWINSOCK(getservbyport, LPFN_GETSERVBYPORT);
> 	DYNAMICWINSOCK(getsockname, LPFN_GETSOCKNAME);
> 	DYNAMICWINSOCK(getsockopt, LPFN_GETSOCKOPT);
> 	DYNAMICWINSOCK(htonl, LPFN_HTONL);
> 	DYNAMICWINSOCK(htons, LPFN_HTONS);
> 	DYNAMICWINSOCK(inet_addr, LPFN_INET_ADDR);
> 	DYNAMICWINSOCK(inet_ntoa, LPFN_INET_NTOA);
> 	DYNAMICWINSOCK(ioctlsocket, LPFN_IOCTLSOCKET);
> 	DYNAMICWINSOCK(listen, LPFN_LISTEN);
> 	DYNAMICWINSOCK(ntohl, LPFN_NTOHL);
> 	DYNAMICWINSOCK(ntohs, LPFN_NTOHS);
> 	DYNAMICWINSOCK(recv, LPFN_RECV);
> 	DYNAMICWINSOCK(recvfrom, LPFN_RECVFROM);
> 	DYNAMICWINSOCK(select, LPFN_SELECT);
> 	DYNAMICWINSOCK(send, LPFN_SEND);
> 	DYNAMICWINSOCK(sendto, LPFN_SENDTO);
> 	DYNAMICWINSOCK(setsockopt, LPFN_SETSOCKOPT);
> 	DYNAMICWINSOCK(shutdown, LPFN_SHUTDOWN);
> 	DYNAMICWINSOCK(socket, LPFN_SOCKET);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByAddr, LPFN_WSAASYNCGETHOSTBYADDR);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByName, LPFN_WSAASYNCGETHOSTBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByName, LPFN_WSAASYNCGETPROTOBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByNumber, LPFN_WSAASYNCGETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(WSAAsyncGetServByName, LPFN_WSAASYNCGETSERVBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetServByPort, LPFN_WSAASYNCGETSERVBYPORT);
> 	DYNAMICWINSOCK(WSAAsyncSelect, LPFN_WSAASYNCSELECT);
> 	DYNAMICWINSOCK(WSACancelAsyncRequest, LPFN_WSACANCELASYNCREQUEST);
> 	DYNAMICWINSOCK(WSACleanup, LPFN_WSACLEANUP);
> 	DYNAMICWINSOCK(WSAGetLastError, LPFN_WSAGETLASTERROR);
> 	DYNAMICWINSOCK(WSASetLastError, LPFN_WSASETLASTERROR);
> 	DYNAMICWINSOCK(WSAStartup, LPFN_WSASTARTUP);
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock2.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,27c1,3
< #ifdef UNICODE
< //	#define p_WSAAddressToString				WSAAddressToStringW
< //	#define p_WSADuplicateSocket				WSADuplicateSocketW
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersW
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsW
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoW
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdW
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassW
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginW
< //	#define p_WSALookupServiceNext				WSALookupServiceNextW
< //	#define p_WSASetService						WSASetServiceW
< //	#define p_WSASocket							WSASocketW
< //	#define p_WSAStringToAddress				WSAStringToAddressW
< #else
< //	#define p_WSAAddressToString				WSAAddressToStringA
< //	#define p_WSADuplicateSocket				WSADuplicateSocketA
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersA
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsA
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoA
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdA
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassA
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginA
< //	#define p_WSALookupServiceNext				WSALookupServiceNextA
< //	#define p_WSASetService						WSASetServiceA
< //	#define p_WSASocket							WSASocketA
< //	#define p_WSAStringToAddress				WSAStringToAddressA
< #endif // UNICODE
---
> //
> // DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
> //
29,53c5,70
< //#define p_WSAAccept WSAAccept
< #define p_WSACloseEvent WSACloseEvent
< //#define p_WSAConnect WSAConnect
< #define p_WSACreateEvent WSACreateEvent
< #define p_WSAEnumNetworkEvents WSAEnumNetworkEvents
< #define p_WSAEventSelect WSAEventSelect
< #define p_WSAGetOverlappedResult WSAGetOverlappedResult
< //#define p_WSAGetQOSByName WSAGetQOSByName
< //#define p_WSAHtonl WSAHtonl
< //#define p_WSAHtons WSAHtons
< #define p_WSAIoctl WSAIoctl
< //#define p_WSAJoinLeaf WSAJoinLeaf
< //#define p_WSALookupServiceEnd WSALookupServiceEnd
< //#define p_WSANtohl WSANtohl
< //#define p_WSANtohs WSANtohs
< #define p_WSARecv WSARecv
< //#define p_WSARecvDisconnect WSARecvDisconnect
< #define p_WSARecvFrom WSARecvFrom
< //#define p_WSARemoveServiceClass WSARemoveServiceClass
< #define p_WSAResetEvent WSAResetEvent
< #define p_WSASend WSASend
< //#define p_WSASendDisconnect WSASendDisconnect
< #define p_WSASendTo WSASendTo
< #define p_WSASetEvent WSASetEvent
< #define p_WSAWaitForMultipleEvents WSAWaitForMultipleEvents
---
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	DYNAMICWINSOCK(WSAAccept, LPFN_WSAACCEPT);
> 	DYNAMICWINSOCK(WSAAddressToStringA, LPFN_WSAADDRESSTOSTRINGA);
> 	DYNAMICWINSOCK(WSAAddressToStringW, LPFN_WSAADDRESSTOSTRINGW);
> 	DYNAMICWINSOCK(WSACloseEvent, LPFN_WSACLOSEEVENT);
> 	DYNAMICWINSOCK(WSAConnect, LPFN_WSACONNECT);
> 	DYNAMICWINSOCK(WSACreateEvent, LPFN_WSACREATEEVENT);
> 	DYNAMICWINSOCK(WSADuplicateSocketA, LPFN_WSADUPLICATESOCKETA);
> 	DYNAMICWINSOCK(WSADuplicateSocketW, LPFN_WSADUPLICATESOCKETW);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersA, LPFN_WSAENUMNAMESPACEPROVIDERSA);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersW, LPFN_WSAENUMNAMESPACEPROVIDERSW);
> 	DYNAMICWINSOCK(WSAEnumNetworkEvents, LPFN_WSAENUMNETWORKEVENTS);
> 	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
> 	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
> 	DYNAMICWINSOCK(WSAEventSelect, LPFN_WSAEVENTSELECT);
> 	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
> 	DYNAMICWINSOCK(WSAGetQOSByName, LPFN_WSAGETQOSBYNAME);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoA, LPFN_WSAGETSERVICECLASSINFOA);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoW, LPFN_WSAGETSERVICECLASSINFOW);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdA, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdW, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW);
> 	DYNAMICWINSOCK(WSAHtonl, LPFN_WSAHTONL);
> 	DYNAMICWINSOCK(WSAHtons, LPFN_WSAHTONS);
> 	DYNAMICWINSOCK(WSAInstallServiceClassA, LPFN_WSAINSTALLSERVICECLASSA);
> 	DYNAMICWINSOCK(WSAInstallServiceClassW, LPFN_WSAINSTALLSERVICECLASSW);
> 	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
> 	DYNAMICWINSOCK(WSAJoinLeaf, LPFN_WSAJOINLEAF);
> 	DYNAMICWINSOCK(WSALookupServiceBeginA, LPFN_WSALOOKUPSERVICEBEGINA);
> 	DYNAMICWINSOCK(WSALookupServiceBeginW, LPFN_WSALOOKUPSERVICEBEGINW);
> 	DYNAMICWINSOCK(WSALookupServiceEnd, LPFN_WSALOOKUPSERVICEEND);
> 	DYNAMICWINSOCK(WSALookupServiceNextA, LPFN_WSALOOKUPSERVICENEXTA);
> 	DYNAMICWINSOCK(WSALookupServiceNextW, LPFN_WSALOOKUPSERVICENEXTW);
> 	DYNAMICWINSOCK(WSANtohl, LPFN_WSANTOHL);
> 	DYNAMICWINSOCK(WSANtohs, LPFN_WSANTOHS);
> 	DYNAMICWINSOCK(WSARecv, LPFN_WSARECV);
> 	DYNAMICWINSOCK(WSARecvDisconnect, LPFN_WSARECVDISCONNECT);
> 	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
> 	DYNAMICWINSOCK(WSARemoveServiceClass, LPFN_WSAREMOVESERVICECLASS);
> 	DYNAMICWINSOCK(WSAResetEvent, LPFN_WSARESETEVENT);
> 	DYNAMICWINSOCK(WSASend, LPFN_WSASEND);
> 	DYNAMICWINSOCK(WSASendDisconnect, LPFN_WSASENDDISCONNECT);
> 	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
> 	DYNAMICWINSOCK(WSASetEvent, LPFN_WSASETEVENT);
> 	DYNAMICWINSOCK(WSASetServiceA, LPFN_WSASETSERVICEA);
> 	DYNAMICWINSOCK(WSASetServiceW, LPFN_WSASETSERVICEW);
> 	DYNAMICWINSOCK(WSASocketA, LPFN_WSASOCKETA);
> 	DYNAMICWINSOCK(WSASocketW, LPFN_WSASOCKETW);
> 	DYNAMICWINSOCK(WSAStringToAddressA, LPFN_WSASTRINGTOADDRESSA);
> 	DYNAMICWINSOCK(WSAStringToAddressW, LPFN_WSASTRINGTOADDRESSW);
> 	DYNAMICWINSOCK(WSAWaitForMultipleEvents, LPFN_WSAWAITFORMULTIPLEEVENTS);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
101a103
> 	m_hActiveSettingsDialog( NULL ),
128a131
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
361a365,372
> 		//
> 		// cancel any active dialogs
> 		// if there are no dialogs, cancel the active command
> 		//
> 		if ( m_hActiveSettingsDialog != NULL )
> 		{
> 			StopSettingsDialog( m_hActiveSettingsDialog );
> 		}
364a376,382
> 	else
> 	{
> 		//
> 		// there should be no active dialog if there isn't an active command
> 		//
> 		DNASSERT( m_hActiveSettingsDialog == NULL );
> 	}
798a817,823
> 	if ( m_hActiveSettingsDialog != NULL )
> 	{
> 		StopSettingsDialog( m_hActiveSettingsDialog );
> 		Unlock();
> 	}
> 	else
> 	{
804a830
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
281a282,288
> 		// UI functions
> 		//
> 		virtual	HRESULT	ShowSettingsDialog( CThreadPool *const pThreadPool ) = 0;
> 		virtual	void	StopSettingsDialog( const HWND hDlg ) = 0;
> 		virtual	void	SettingsDialogComplete( const HRESULT hr ) = 0;
> 
> 		//
300a308,309
> 
> 		HWND			m_hActiveSettingsDialog;		// handle of active settings dialog
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
43a45
> #include	"IPXAddress.h"
80c82,83
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
98a102,103
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
113a119,120
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
>     m_dwWin9xBytesReceived( 0 ),
185a193,198
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
206a220,226
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
210a231,253
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
235a279,280
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
266a312,313
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
297a345,350
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
439a493,499
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
442a503,526
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
474a559,560
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
494a581,582
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
127a128,130
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
157a161
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
158a163
> 
192a198,200
> 
> 		INT		m_Win9xReceiveWSAReturn;		
> 		DWORD	m_dwWin9xBytesReceived;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
81a83
> const DWORD	g_dwIPBroadcastAddressSize = sizeof( g_IPBroadcastAddress );
101,103d102
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
< 
590c589
< 	hr = DirectPlay8AddressCreate( &IID_IDirectPlay8AddressIP, reinterpret_cast<void**>( &pIPAddress ), NULL);
---
> 	hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8AddressIP, reinterpret_cast<void**>( &pIPAddress ) );
740c739
< 	hr = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ), NULL);
---
> 	hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ) );
805c804
< 	hr = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ), NULL);
---
> 	hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ) );
870c869
< 	hr = DirectPlay8AddressCreate( &IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ), NULL);
---
> 	hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ) );
971,973d969
< // BUGBUG: [mgere] [xbox] No need to enum adapters anymore since we only have one.
< // need to complete the removal of this functionality at a later date.
< /*
1274d1269
< */	return DPNERR_UNSUPPORTED;
1454a1450,1455
> 	//
> 	// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1455a1457,1475
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1458a1479,1481
> 		case 2:
> 		default:
> 		{
1459a1483,1485
> 			break;
> 		}
> 	}
1529a1556,1561
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1530a1563,1581
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1533a1585,1587
> 		case 2:
> 		default:
> 		{
1534a1589,1591
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
38a40
> #include	"StrUtils.h"
50a53
> #include	"IPUI.h"
93a97
> 	memset( m_TempHostName, 0x00, sizeof( m_TempHostName ) );
115a120,341
> // CIPEndpoint::ShowSettingsDialog - show dialog for settings
> //
> // Entry:		Pointer to thread pool
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CIPEndpoint::ShowSettingsDialog( CThreadPool *const pThreadPool )
> {
> 	HRESULT	hr;
> 
> 
> 	DNASSERT( pThreadPool != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	AddRef();
> 	hr = pThreadPool->SpawnDialogThread( DisplayIPHostNameSettingsDialog, &m_hActiveSettingsDialog, this );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to start IP hostname dialog!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:	
> 	DecRef();
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::SettingsDialogComplete - dialog has completed
> //
> // Entry:		Error code for dialog
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::SettingsDialogComplete( const HRESULT hDialogResult )
> {
> 	HRESULT					hr;
> 	HRESULT					hTempResult;
> 	IDirectPlay8Address		*pBaseAddress;
> 	DWORD					dwTotalAddressBufferSize;
> 	char					*pTempAddressString;
> 	WCHAR					WCharHostName[ sizeof( m_TempHostName ) + 1 ];
> 	DWORD					dwWCharHostNameSize;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = hDialogResult;
> 	pBaseAddress = NULL;
> 
> 	pTempAddressString = NULL;
> 
> 	//
> 	// since the dialog is exiting, clear our handle to the dialog
> 	//
> 	m_hActiveSettingsDialog = NULL;
> 
> 	//
> 	// dialog failed, fail the user's command
> 	//
> 	if ( hr != DPN_OK )
> 	{
> 		if ( hr != DPNERR_USERCANCEL)
> 		{
> 			DPF( 0, "Failing endpoint hostname dialog!" );
> 			DisplayErrorCode( 0, hr );
> 
> 		}
> 
> 		goto Failure;
> 	}
> 
> 	//
> 	// The dialog completed OK, rebuild remote address and complete command
> 	//
> 
> 	//
> 	// get the base DNADDRESS
> 	//
> 	pBaseAddress = m_pRemoteMachineAddress->DP8AddressFromSocketAddress();
> 	if ( pBaseAddress == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "SettingsDialogComplete: Failed to get base address when completing IP hostname dialog!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// Add the new 'HOSTNAME' parameter to the address.  If the hostname is blank
> 	// and this is an enum, copy the broadcast hostname.
> 	//
> 	if ( ( m_TempHostName[ 0 ] == '\0' ) && ( m_EndpointType == ENDPOINT_TYPE_ENUM ) )
> 	{
> 		DNASSERT( sizeof( WCharHostName ) >= g_dwIPBroadcastAddressSize );
> 		memcpy( WCharHostName, g_IPBroadcastAddress, g_dwIPBroadcastAddressSize );
> 		dwWCharHostNameSize = g_dwIPBroadcastAddressSize;
> 	}
> 	else
> 	{
> 		dwWCharHostNameSize = LENGTHOF( WCharHostName );
> 		hr = STR_AnsiToWide( m_TempHostName, -1, WCharHostName, &dwWCharHostNameSize );
> 		DNASSERT( hr == DPN_OK );
> 		dwWCharHostNameSize *= sizeof( WCHAR );
> 	}
> 
> 	hr = IDirectPlay8Address_AddComponent( pBaseAddress, DPNA_KEY_HOSTNAME, WCharHostName, dwWCharHostNameSize, DPNA_DATATYPE_STRING );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "SettingsDialogComplete: Failed to add hostname to address!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// set the address
> 	//
> 	hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pBaseAddress, SP_ADDRESS_TYPE_HOST );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to rebuild DNADDRESS when completing IP hostname dialog!" );
> 		DNASSERT( FALSE );
> 		goto Failure;
> 	}
> 
> 	//
> 	// the remote machine address has been adjusted, finish the command
> 	//
> 	switch ( m_EndpointType )
> 	{
> 		case ENDPOINT_TYPE_ENUM:
> 		{
> 			hr = CompleteEnumQuery();
> 			if ( hr != DPN_OK )
> 			{
> 				DPF( 0, "Problem completing EnumQuery after asking user for hostname!" );
> 				DisplayDNError( 0, hr );
> 			}
> 
> 			break;
> 		}
> 
> 		case ENDPOINT_TYPE_CONNECT:
> 		{
> 			hr = CompleteConnect();
> 			if ( hr != DPN_OK )
> 			{
> 				DPF( 0, "Problem completing Connect after asking user for hostname!" );
> 				DisplayDNError( 0, hr );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			hr = DPNERR_GENERIC;
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pBaseAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DNASSERT( pTempAddressString == NULL );
> 	if ( pBaseAddress != NULL )
> 	{
> 		DNFree( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DecRef();
> 
> 	return;
> 
> Failure:
> 	//
> 	// close this endpoint
> 	//
> 	Close( hr );
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::StopSettingsDialog - stop an active settings dialog
> //
> // Entry:		Handle of dialog to close
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::StopSettingsDialog( const HWND hDlg)
> {
> 	StopIPHostNameSettingsDialog( hDlg );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
215a442
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
261,262d487
< 
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
22a23,24
> #define	TEMP_HOSTNAME_LENGTH	100
> 
52a55,67
> 		// UI functions
> 		//
> 		HRESULT		ShowSettingsDialog( CThreadPool *const pThreadPool );
> 		void		SettingsDialogComplete( const HRESULT hr );
> 		void		StopSettingsDialog( const HWND hDlg );
> 		void		SetTempHostName( const char *const pHostName, const UINT_PTR uHostNameLength )
> 		{
> 			DNASSERT( pHostName[ uHostNameLength ] == '\0' );
> 			DNASSERT( ( uHostNameLength + 1 ) <= LENGTHOF( m_TempHostName ) );
> 			memcpy( m_TempHostName, pHostName, ( uHostNameLength + 1 ) );
> 		}
> 
> 		//
69a85
> 		char		m_TempHostName[ TEMP_HOSTNAME_LENGTH ];
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
49a51
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
81a85
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
83a88
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
173a179,185
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
192a205,221
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
> 	
317a347,353
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
327a364,369
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
419a462,494
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	return	g_pIPXAddressPool->Get();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
429a505,520
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
59a62,63
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
61a66
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\rsip.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38a39
> #include	"Registry.h"
510a512,515
> 
> 		hr = GetGatewayFromRegistry( reinterpret_cast<BYTE*>( gwipaddr ), sizeof( gwipaddr ) );
> 
> 		if(hr != DPN_OK){
512a518,520
> 		}
> 
> 		DPF(0,"Found suggested RSIP gateway in registry %s, running on Win95?\n",gwipaddr);
649d656
<         WCHAR wszIPHLPAPI[] = { wchar_t("IPHLPAPI.DLL") };
685c692
< 	hIpHlpApi = LoadLibrary(wszIPHLPAPI);
---
> 	hIpHlpApi = LoadLibrary("IPHLPAPI.DLL");
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
257a259,266
> 	
> 	//
> 	// Winsock 2 functionality always exists on WinNT.  If we're on Win9x, we can
> 	// only use Winsock2 interfaces for TCP.
> 	//
> 	if ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) ||
> 		 ( ( LOWORD( GetWinsockVersion() ) >= 2 ) && ( m_pSPData->GetType() == TYPE_IP ) ) )
> 	{
258a268,272
> 	}
> 	else
> 	{
> 		m_pSendFunction = Winsock1Send;
> 	}
404a419,430
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( ( LOWORD( GetWinsockVersion() ) == 1 ) ||
> 			 ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_pSPData->GetType() == TYPE_IPX ) ) )
> 		{
> 			m_pSPData->GetThreadPool()->RemoveSocketPort( this );
> 		}
> 
833a860,872
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
835a875,971
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ),	// pointer to receive buffer
> 								pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize,		// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();
> 
> Exit:
> 	return;
> }
836a973,975
> 
> 
> //**********************************************************************
837a977,1122
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
864,865c1149,1150
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
876a1162,1164
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
929a1218,1220
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1003c1294,1295
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1017a1310,1312
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1075a1371,1372
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1109a1407,1408
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1154a1454,1455
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
1720a2022,2028
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1765a2074,2137
> 			break;
> 		}
> 
> 		//
> 		// Win9x.
> 		// If this is not an IPX socket and Winsock 2 (or greater) is available,
> 		// call the Winsock 2 read function.  If this is IPX or we're stuck with
> 		// Winsock 1, inform the thread pool as such.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 
> 			if ( ( LOWORD( GetWinsockVersion() ) >= 2 ) &&
> 				 ( m_pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// we're using Winsock2, call for two outstanding reads per socket.
> 				//
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #1 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #2 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 			}
> 			else
> 			{
> 				DNASSERT( m_pSPData != NULL );
> 				hr = m_pSPData->GetThreadPool()->AddSocketPort( this );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Failed to add to active socket list!" );
> 					DisplayDNError( 0, hr );
> 					goto Failure;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2388a2761,2917
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
> 
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			goto Exit;
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = pReadData->m_dwWin9xBytesReceived;
> 					ProcessReceivedData( pReadData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();	
> 	DecRef();
> 
> 	return;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
238a239
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
244a246,248
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
287a292
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
43,47c43,51
<            ..\..\..\dnaddress\daytona\obj$(BUILD_ALT_DIR)\*\dpnaddr.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<            $(BASEDIR)\public\sdk\lib\*\winsockx.lib
---
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
56a61,71
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
77a93
> 	 ..\DWinsock.cpp \
81a98,100
> 	 ..\IPUI.cpp \
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
84a104
>          ..\Registry.cpp \
98c118
< C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /DDNWSock_EXPORTS /DCINTERFACE /DUNICODE
---
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNWSock_EXPORTS /DCINTERFACE
100,101d119
< MSC_OPTIMIZATION=/Odi /Zi
< NTDEBUGTYPE=both
105c123
< DLLENTRY=DllMain
---
> DLLENTRY=_DllMainCRTStartup
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
104c104
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
122c122,123
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
158c159,160
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
241a244
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
242a246
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
245c249
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
252c256
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
279a284
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
47a49
> #include	"IPXAddress.h"
53a56
> #include	"IPXEndpt.h"
223a227,256
> 	switch ( DNGetOSType() )
> 	{
> 		//
> 		// Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
> 			DPF( 8, "WinNT detected!" );
> 			break;
> 		}
> 
> 		//
> 		// Windows 95, 98
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DPF( 8, "Win9x detected!" );
> 			break;
> 		}
> 
> 		// other version (unsupported!)
> //		case VER_PLATFORM_WIN32_CE:
> 		case VER_PLATFORM_WIN32s:
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
577a611,616
> 		case TYPE_IPX:
> 		{
> 			pReturn = CreateIPXEndpoint( &EndpointPoolContext );
> 			break;
> 		}
> 
746a786,791
> 		case TYPE_IPX:
> 		{
> 			pReturn = CreateIPXAddress();
> 			break;
> 		}
> 
777a823,828
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
114a116,138
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
121a146,156
> //
> // structure passed to dialog threads
> //
> typedef	struct	_DIALOG_THREAD_PARAM
> {
> 	DIALOG_FUNCTION	*pDialogFunction;
> 	HWND			*phDialog;
> 	void			*pContext;
> 	CThreadPool		*pThisThreadPool;
> } DIALOG_THREAD_PARAM;
> 
226c261,268
< 	DEBUG_ONLY( 
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
228c270,271
< 	)
---
> 						break;
> 					}
229a273,280
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
236c287,294
< 	DEBUG_ONLY(
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( DNGetOSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
238c296,297
< 	)
---
> 						break;
> 					}
239a299,306
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
273a341,347
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
330a405,409
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( DNGetOSType() )
> 	{
333a413,414
> 		case VER_PLATFORM_WIN32_NT:
> 		{
339a421,447
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
368a477,478
> 	SYSTEM_INFO		SystemInfo;
> 	UINT_PTR		uDesiredThreads;
375a486,490
> 	//
> 	// get machine information
> 	//
> 	memset( &SystemInfo, 0x00, sizeof( SystemInfo ) );
> 	GetSystemInfo( &SystemInfo );
395a511,517
> 	uDesiredThreads = ( SystemInfo.dwNumberOfProcessors * 2 ) + 2;
> 	DNASSERT( uDesiredThreads != 0 );
> 	while ( uDesiredThreads > 0 )
> 	{
> 		uDesiredThreads--;
> 		StartNTCompletionThread();
> 	}
397,401d518
<     StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 
426a544,689
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT	hr;
> 	HANDLE	hThread;
> 	DWORD	dwThreadID;
> 	WIN9X_THREAD_DATA	*pInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	//
> 	// Win9x requires completion events for Winsock2.  Always allocate the events
> 	// even though the they might not be used because the network layer might
> 	// only support Winsock1.
> 	//
> 	DNASSERT( m_hWinsock2SendComplete == NULL );
> 	m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 										   TRUE,	// manual reset
> 										   FALSE,	// start unsignalled
> 										   NULL		// pointer to name (none)
> 										   );
> 	if ( m_hWinsock2SendComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Send!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 	m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 											  TRUE,		// manual reset
> 											  FALSE,	// start unsignalled
> 											  NULL		// pointer to name (none)
> 											  );
> 	if ( m_hWinsock2ReceiveComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Receive!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	//
> 	// create main worker thread to handle everything
> 	//
> 	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
> 	if ( pInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pInput, 0x00, sizeof( *pInput ) );
> 	pInput->pThisThreadPool = this;
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	m_iTotalThreadCount++;
> 	
> 	//
> 	// create one worker thread and boost its priority
> 	//
> 	hThread = CreateThread( NULL,			// pointer to security attributes (none)
> 							0,				// stack size (default)
> 							Win9xThread,	// pointer to thread function
> 							pInput,			// pointer to input parameter
> 							0,				// let it run
> 							&dwThreadID		// pointer to destination of thread ID
> 							);
> 	if ( hThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		m_iTotalThreadCount--;
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		DNASSERT( pInput != NULL );
> 		DNFree( pInput );
> 		goto Failure;
> 	}
> 
> 	DPF( 8, "Creating Win9x thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, m_iTotalThreadCount, m_iNTCompletionThreadCount );
> 	DNASSERT( hThread != NULL );
> 	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of Win9x read thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> 	if ( CloseHandle( hThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing Win9x thread hanle!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
535a799,800
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{	
556a822
> 	}
634a901,905
> 
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
> 		pReadData->m_dwWin9xBytesReceived = 0;
651a923,924
> 		DNASSERT( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
796a1070
> 	m_IPXReadIODataPool.Deinitialize();
844d1117
< 			
848a1122,1130
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			break;
> 		}
> 
> 		//
926a1209,1217
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1181a1473,1474
> 	switch ( DNGetOSType() )
> 	{
1184a1478,1479
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1201a1497,1525
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( m_JobQueue.SignalPendingJob() == FALSE )
> 			{
> 				hr = DPNERR_OUTOFMEMORY;
> 				DPF( 0, "Failed to signal pending job!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1312a1637,1638
> 	if ( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
1319a1646
> 	}
1521a1849,1949
> // CThreadPool::SpawnDialogThread - start a secondary thread to display service
> //		provider UI.
> //
> // Entry:		Pointer to dialog function
> //				Pointer destination for copy of dialog handle
> //				Dialog context
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext )
> {
> 	HRESULT	hr;
> 	HANDLE	hDialogThread;
> 	DIALOG_THREAD_PARAM		*pThreadParam;
> 	DWORD	dwThreadID;
> 
> 
> 	DNASSERT( pDialogFunction != NULL );
> 	DNASSERT( phDialog != NULL );
> 	DNASSERT( pDialogContext != NULL );		// why would anyone not want a dialog context??
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pThreadParam = NULL;
> 
> 	//
> 	// create and initialize thread param
> 	//
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( DNMalloc( sizeof( *pThreadParam ) ) );
> 	if ( pThreadParam == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for dialog thread!" );
> 		goto Failure;
> 	}
> 
> 	pThreadParam->pDialogFunction = pDialogFunction;
> 	pThreadParam->phDialog = phDialog;
> 	pThreadParam->pContext = pDialogContext;
> 	pThreadParam->pThisThreadPool = this;
> 
> 	//
> 	// assume that a thread will be created
> 	//
> 	m_iTotalThreadCount++;
> 
> 	//
> 	// create thread
> 	//
> 	hDialogThread = CreateThread( NULL,					// pointer to security (none)
> 								  0,					// stack size (default)
> 								  DialogThreadProc,		// thread procedure
> 								  pThreadParam,			// thread param
> 								  0,					// creation flags (none)
> 								  &dwThreadID );		// pointer to thread ID
> 	if ( hDialogThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// decrement active thread count and report error
> 		//
> 		m_iTotalThreadCount--;
> 		
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to start dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		goto Failure;
> 	}
>   								
> 	if ( CloseHandle( hDialogThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing handle from create dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:
> 	if ( pThreadParam != NULL )
> 	{
> 		DNFree( pThreadParam );
> 		pThreadParam = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
1541a1970,1971
> 	switch ( DNGetOSType() )
> 	{
1542a1973,1982
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( m_iNTCompletionThreadCount == 0 );
> 			break;
> 		}
> 
> 		//
1544a1985,1986
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1546a1989,1990
> 			break;
> 		}
1547a1992,2001
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1576a2031,2032
> 	switch ( DNGetOSType() )
> 	{
1577a2034,2041
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1583a2048,2049
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1623a2090,2102
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1703a2183,2330
> // CThreadPool::AddSocketPort - add a socket to the Win9x watch list
> //
> // Entry:		Pointer to SocketPort
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::AddSocketPort( CSocketPort *const pSocketPort )
> {
> 	HRESULT	hr;
> 	BOOL	fSocketAdded;
> 
> 	
> 	DNASSERT( pSocketPort != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	fSocketAdded = FALSE;
> 
> 	Lock();
> 
> 	//
> 	// We're capped by the number of sockets we can use for Winsock1.  Make
> 	// sure we don't allocate too many sockets.
> 	//
> 	if ( m_uReservedSocketCount == FD_SETSIZE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "There are too many sockets allocated on Winsock1!" );
> 		goto Failure;
> 	}
> 
> 	m_uReservedSocketCount++;
> 	
> 	DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 	m_pSocketPorts[ m_SocketSet.fd_count ] = pSocketPort;
> 	m_SocketSet.fd_array[ m_SocketSet.fd_count ] = pSocketPort->GetSocket();
> 	m_SocketSet.fd_count++;
> 	fSocketAdded = TRUE;
> 
> 	//
> 	// add a reference to note that this socket port is being used by the thread
> 	// pool
> 	//
> 	pSocketPort->AddRef();
> 
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when adding socket port to active list!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> Exit:
> 	Unlock();
> 	
> 	return	hr;
> 
> Failure:
> 	if ( fSocketAdded != FALSE )
> 	{
> 		AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
> 		m_SocketSet.fd_count--;
> 		m_pSocketPorts[ m_SocketSet.fd_count ] = NULL;
> 		m_SocketSet.fd_array[ m_SocketSet.fd_count ] = NULL;
> 		fSocketAdded = FALSE;
> 	}
> 
> 	m_uReservedSocketCount--;
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::RemoveSocketPort - remove a socket from the Win9x watch list
> //
> // Entry:		Pointer to socket port to remove
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::RemoveSocketPort( CSocketPort *const pSocketPort )
> {
> 	UINT_PTR	uIndex;
> 
> 
> 	DNASSERT( pSocketPort != NULL );
> 	
> 	Lock();
> 
> 	uIndex = m_SocketSet.fd_count;
> 	DNASSERT( uIndex != 0 );
> 	while ( uIndex != 0 )
> 	{
> 		uIndex--;
> 
> 		if ( m_pSocketPorts[ uIndex ] == pSocketPort )
> 		{
> 			m_uReservedSocketCount--;
> 			m_SocketSet.fd_count--;
> 
> 			memmove( &m_pSocketPorts[ uIndex ],
> 					 &m_pSocketPorts[ uIndex + 1 ],
> 					 ( sizeof( m_pSocketPorts[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			memmove( &m_SocketSet.fd_array[ uIndex ],
> 					 &m_SocketSet.fd_array[ uIndex + 1 ],
> 					 ( sizeof( m_SocketSet.fd_array[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			//
> 			// clear last entry which is now unused
> 			//
> 			memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) );
> 			memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) );
> 
> 			//
> 			// end the loop
> 			//
> 			uIndex = 0;
> 		}
> 	}
> 
> 	Unlock();
> 	
> 	pSocketPort->DecRef();
> 
> 	//
> 	// It's really not necessary to signal a new job here because there were
> 	// active sockets on the last iteration of the Win9x thread.  That means the
> 	// Win9x thread was in a polling mode to check for sockets and the next time
> 	// through it will notice that there is a missing socket.  By signalling the
> 	// job event we reduce the time needed for the thread to figure out that the
> 	// socket is gone.
> 	//
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when removeing socket port to active list!" );
> 	}
> }
> //**********************************************************************
> 
> 
> 
> //**********************************************************************
> // ------------------------------
1850a2478,3023
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwWin9xBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					default:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwWin9xBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::Win9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::Win9xThread( void *pParam )
> {
> #pragma	BUGBUG( johnkan, "Hard-coded constant for Winsock1 of 10ms for write polling!" )
> static const DWORD		SelectTimeslice = 10;
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 	
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> //	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> //	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 	
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 	
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		DWORD	dwWaitReturn;
> 
> 		
> 		//
> 		// Update the job time so we know how long to wait.  We can
> 		// only get here if a socket was just added to the socket list, or
> 		// we've been servicing sockets.
> 		//
> 		DNTimeGet( &CurrentTime );
> 		if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 		{
> 			pThisThreadPool->LockTimerData();
> 			CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																		   &CoreData.NextTimerJobTime );
> 			if ( CoreData.fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 			}
> 			pThisThreadPool->UnlockTimerData();
> 		}
> 
> 		DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 		dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 
> 		//
> 		// Check for Winsock1 sockets.  If there are some around, do a quick poll
> 		// of them to check of I/O before entering the main Winsock2 loop for
> 		// the real timing.
> 		//
> 		pThisThreadPool->Lock();
> 		if ( pSocketSet->fd_count != 0 )
> 		{
> 			pThisThreadPool->Unlock();
> 
> 			pThisThreadPool->CheckWinsock1IO( pSocketSet );
> 			
> 			//
> 			// since there are Winsock1 sockets active, don't spend a lot of
> 			// time waiting for something to happen for Winsock2
> 			//
> 			if ( SelectTimeslice < dwMaxWaitTime )
> 			{
> 				dwMaxWaitTime = SelectTimeslice;
> 			}
> 		}
> 		else
> 		{
> 			pThisThreadPool->Unlock();
> 		}
> 
> 
> 		//
> 		// Check Winsock2 sockets.
> 		//
> 		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> 												 CoreData.hWaitHandles,					// handles to wait on
> 												 FALSE,									// don't wait for all to be signalled
> 												 dwMaxWaitTime,							// wait timeout
> 												 TRUE									// we're alertable for APCs
> 												 );
> 		switch ( dwWaitReturn )
> 		{
> 			//
> 			// timeout, don't do anything, we'll probably process timer jobs on
> 			// the next loop
> 			//
> 			case WAIT_TIMEOUT:
> 			{
> 				break;
> 			}
> 
> 			//
> 			// New job.  Account for the time spent in the wait.  Don't
> 			// account for time after the job is complete because it's
> 			// possible that the job was an job submission which will want
> 			// to reset the wait time.
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 			{
> 				DPF( 8, "WorkThread has a pending job with no Winsock1 sockets active!" );
> 				pThisThreadPool->ProcessWin9xJob( &CoreData );
> 				break;
> 			}
> 
> 			//
> 			// SP closing
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 			{
> 				DPF( 8, "WorkThread exit because SP closing with no Winsock1 sockets active!" );
> 				fLooping = FALSE;
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 send complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending write list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Failed to reset Winsock2 send event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> 				pThisThreadPool->CompleteOutstandingSends();
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 receive complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending read list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Failed to reset Winsock2 receive event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> 				pThisThreadPool->CompleteOutstandingReceives();
> 				break;
> 			}
> 
> 			//
> 			// There are I/O completion routines scheduled on this thread.
> 			// This is not a good thing!
> 			//
> 			case WAIT_IO_COMPLETION:
> 			{
> 				DPF( 1, "WARNING: APC was serviced on the Win9x IO service thread!  What is the application doing??" );
> 				break;
> 			}
> 
> 			//
> 			// wait failed
> 			//
> 			case WAIT_FAILED:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Wait failed!" );
> 				DisplayDNError( 0, dwError );
> 				break;
> 			}
> 
> 			//
> 			// problem
> 			//
> 			default:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Unknown problem in wait!" );
> 				DisplayDNError( 0, dwError );
> 				DNASSERT( FALSE );
> 				break;
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
1878a3052,3084
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			DPF( 0, "Failed to initialize COM!" );
> 			break;
> 		}
> 	}
> 
> 	//
2008a3215,3216
> 	CoUninitialize();
> 
2160a3369,3718
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::DialogThreadProc - thread proc for spawning dialogs
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> // ------------------------------
> DWORD WINAPI	CThreadPool::DialogThreadProc( void *pParam )
> {
> 	const DIALOG_THREAD_PARAM	*pThreadParam;
> 
> 
> 	//
> 	// Initialize COM.  If this fails, we'll have problems later.
> 	//
> 	switch ( CoInitialize( NULL ) )
> 	{
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM sucks!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
> 	DNASSERT( pParam != NULL );
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( pParam );
> 	
> 	pThreadParam->pDialogFunction( pThreadParam->phDialog, pThreadParam->pContext );
> 
> 	pThreadParam->pThisThreadPool->DecrementActiveThreadCount();
> 	DNFree( pParam );
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// Remove and process a single job from the list.  If there is no job, skip
> 	// to the end of the function.
> 	//
> 	pJobInfo = GetWorkItem();
> 
> 	if ( pJobInfo == NULL )
> 	{
> 		goto Exit;
> 	}
> 
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> 
> Exit:
> 	return;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CheckWinsock1IO - check the IO status for Winsock1 sockets
> //
> // Entry:		Pointer to sockets to watch
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CheckWinsock1IO( const FD_SET *const pWinsock1Sockets )
> {
> static	const TIMEVAL	SelectNoTime = { 0 };
> 	INT			iSelectReturn;
> 	FD_SET		ReadSocketSet;
> 	FD_SET		WriteSocketSet;
> 	FD_SET		ErrorSocketSet;
> 
> 
> 	//
> 	// Make a local copy of all of the sockets.  This isn't totally
> 	// efficient, but it works.  Multiplying by active socket count will
> 	// spend half the time in the integer multiply.
> 	//
> 	Lock();
> 	memcpy( &ReadSocketSet, pWinsock1Sockets, sizeof( ReadSocketSet ) );
> 	memcpy( &WriteSocketSet, pWinsock1Sockets, sizeof( WriteSocketSet ) );
> 	memcpy( &ErrorSocketSet, pWinsock1Sockets, sizeof( ErrorSocketSet ) );
> 	Unlock();
> 
> 	//
> 	// Don't check write sockets here because it's very likely that they're ready
> 	// for service but have no outgoing data and will thrash
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  &ReadSocketSet,	// sockets to check for read
> 							  NULL,				// sockets to check for write (none)
> 							  &ErrorSocketSet,	// sockets to check for error
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// select got pissed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// WSAENOTSOCK = This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting all sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing read service and error service.
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 			ServiceWinsock1Sockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Since writes are likely to be ready, check for them separately
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  NULL,				// sockets to check for read (don't check reads)
> 							  &WriteSocketSet,	// sockets to check for write
> 							  NULL,				// sockets to check for error (don't check errors)
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// select got pissed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// this socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting write sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing write service
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 			break;
> 		}
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ServiceWinsock1Sockets - service requests on Winsock1 sockets ports
> //
> // Entry:		Pointer to set of sockets
> //				Pointer to service function
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction )
> {
> 	UINT_PTR	uWaitingSocketCount;
> 	UINT_PTR	uSocketPortCount;
> 	CSocketPort	*pSocketPorts[ FD_SETSIZE ];
> 
> 
> 	uSocketPortCount = 0;
> 	uWaitingSocketCount = pSocketSet->fd_count;
> 	
> 	Lock();
> 	while ( uWaitingSocketCount > 0 )
> 	{
> 		UINT_PTR	uIdx;
> 
> 
> 		uWaitingSocketCount--;
> 		uIdx = m_SocketSet.fd_count;
> 		while ( uIdx != 0 )
> 		{
> 			uIdx--;
> 			if ( pSocketSet->fd_array[ uWaitingSocketCount ] == m_SocketSet.fd_array[ uIdx ] )
> 			{
> 				//
> 				// this socket is still available, add a reference to the socket
> 				// port and keep it around to be processed outside of the lock
> 				//
> 				pSocketPorts[ uSocketPortCount ] = m_pSocketPorts[ uIdx ];
> 				pSocketPorts[ uSocketPortCount ]->AddRef();
> 				uSocketPortCount++;
> 				uIdx = 0;
> 			}
> 		}
> 	}
> 	Unlock();
> 
> 	while ( uSocketPortCount != 0 )
> 	{
> 		uSocketPortCount--;
> 		
> 		//
> 		// call the service function and remove the reference
> 		//
> 		(pSocketPorts[ uSocketPortCount ]->*pServiceFunction)();
> 		pSocketPorts[ uSocketPortCount ]->DecRef();
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
65a67
> typedef	void	DIALOG_FUNCTION( HWND *const phDialog, void *const pDialogContext );
97c99,100
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( DNGetOSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
143a147
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
148a153
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( DNGetOSType() == VER_PLATFORM_WIN32_NT ) );
155a161,163
> 		HRESULT	AddSocketPort( CSocketPort *const pSocketPort );
> 		void	RemoveSocketPort( CSocketPort *const pSocketPort );
> 
166a175,176
> 		HRESULT	SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext );
> 
199a210
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
264a276
> 		HRESULT	Win9xInit( void );
274a287,288
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
275a290
> 		static	DWORD WINAPI	Win9xThread( void *pParam );
277a293
> 		static	DWORD WINAPI	DialogThreadProc( void *pParam );
283c299,302
< 		void	ServiceSockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );
---
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
> 
> 		void	CheckWinsock1IO( const FD_SET *const pWinsock1Sockets );
> 		void	ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
13a14,15
> #include <WSIPX.h>
> 
71c73,102
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
> 	DNSP_QueryInterface,
> 	DNSP_AddRef,
> 	DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Close,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
132a164,220
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to pointer to SP interface
> //				Pointer to pointer to associated SP data
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP, CSPData **const ppSPData )
> {
> 	HRESULT 	hr;
> 	CSPData		*pSPData;
> 
> 
> 	DNASSERT( ppiDNSP != NULL );
> 	DNASSERT( ppSPData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pSPData = NULL;
> 	*ppiDNSP = NULL;
> 	*ppSPData = NULL;
> 
> 	//
> 	// create main data class
> 	//
> 	hr = CreateSPData( &pSPData, &CLSID_DP8SP_IPX, TYPE_IPX, &ipxInterface );
> 	if ( hr != DPN_OK )
> 	{
> 		DNASSERT( pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( pSPData != NULL );
> 	*ppiDNSP = pSPData->COMInterface();
> 	*ppSPData = pSPData;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( pSPData != NULL )
> 	{
> 		pSPData->DecRef();
> 		pSPData = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
219a308,310
> 	//
> 	// we can either create an IPX instance or an IP instance
> 	//
225a317,320
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP, &pSPData );
> 	}
266c361
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return ( IsEqualCLSID( rclsid, CLSID_DP8SP_TCPIP ) || IsEqualCLSID( rclsid, CLSID_DP8SP_IPX ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
22a24
> #include	"DWinsock.h"
48,51d49
< // provides us winsock1/2 support
< #include "dwnsock1.inc"
< #include "dwnsock2.inc"
< 
78a77,78
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
> 
103a104
> 	INT		iVersion;
129c130
< 	// initialize Winsock
---
> 	// initialize the bindings to Winsock
131,137c132,133
< 	WORD wVersionRequested;
< 	WSADATA wsaData;
< 	int nRet;
< 
< 	wVersionRequested = MAKEWORD(2,2);
< 	nRet = p_WSAStartup(wVersionRequested, &wsaData);
< 	if (nRet || wVersionRequested != wsaData.wVersion)
---
> 	iVersion = DWSInitWinSock( &g_dwsState );
> 	if ( iVersion == 0 )	// failure
139,141c135,137
< 		DPF( 0, "Problem starting winsock!" );
< 	    fReturn = FALSE;
< 	    goto Failure;
---
> 		DPF( 0, "Problem binding dynamic winsock functions!" );
> 		fReturn = FALSE;
> 		goto Failure;
143d138
< 
145a141,142
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
155c152,160
< 		p_WSACleanup();
---
> 		BOOL	fFreeReturn;
> 
> 
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 		if ( fFreeReturn == FALSE )
> 		{
> 			DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 		}
> 
185a191,193
> 	BOOL	fFreeReturn;
> 
> 
189c197,201
< 	p_WSACleanup();
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 	if ( fFreeReturn == FALSE )
> 	{
> 		DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 	}
196a209,221
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
197a223
> 
283a310
> 	INT_PTR iWinsockVersion;
293a321
> 	iWinsockVersion = GetWinsockVersion();
306c334
< 			hr = g_pThreadPool->Initialize(  );
---
> 			hr = g_pThreadPool->Initialize();
458d485
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
47a48,49
> INT		GetWinsockVersion( void );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22
> #include	<WSIPX.h>
93,94d93
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
164a164,167
>  	switch ( pSPData->GetType() )
> 	{
> 		case TYPE_IP:
> 		{
166a170,185
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			DPF( 9, "Attempting to create IPX datagram socket." );
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
231a251
> 		case TYPE_IPX:
316a337
> 	IDirectPlay8Address		*pSPOnlyAddress;
324c345
< 	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );
---
> 	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );
340a362
> 	pSPOnlyAddress = NULL;
378a401,448
> 		HRESULT	hTempResult;
> 		GUID	SPGuid;
> 
> 
> 		//
> 		// get the SP
> 		//
> 		hTempResult = IDirectPlay8Address_GetSP( pDeviceAddress, &SPGuid );
> 		switch ( hTempResult )
> 		{
> 			//
> 			// no problem
> 			//
> 			case DPN_OK:
> 			{
> 				DNASSERT( hr == DPNERR_PENDING );
> 				break;
> 			}
> 
> 			//
> 			// pass these errors throug
> 			//
> 			case DPNERR_OUTOFMEMORY:
> 			{
> 				hr = hTempResult;
> 				goto Failure;
> 				break;
> 			}
> 
> 			//
> 			// remap other errors to addressing errors
> 			//
> 			default:
> 			{
> 				hr = DPNERR_ADDRESSING;
> 				goto Failure;
> 				break;
> 			}
> 		}
> 
> 		//
> 		// The host address is NULL, if we're using TCPIP and we're not allowed to query,
> 		// use the broadcast address.  If we're on IPX, use the broadcast address.
> 		//
> 		if ( ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
> 		{
380a451,498
> 		}
>         else
>         {
> 			HRESULT	hTempResult;
> 
> 
> 			//
> 			// Need to build address with just the SP guid.  Get it from the
> 			// device address.
> 			//
> 			DNASSERT( pSPOnlyAddress == NULL );
> 			hTempResult = CoCreateInstance( CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>( &pSPOnlyAddress ) );
> 			if ( hTempResult != S_OK )
> 			{
> 				DPF( 0, "Failed to create SP-Only address when non was supplied!" );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			hTempResult = IDirectPlay8Address_SetSP( pSPOnlyAddress, &SPGuid );
> 			switch ( hTempResult )
> 			{
> 				//
> 				// set SP, no problem
> 				//
> 				case DPN_OK:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// failed to set SP, map error to an addressing error
> 				//
> 				default:
> 				{
> 					hr = DPNERR_ADDRESSING;
> 					goto Failure;
> 
> 					break;
> 				}
> 			}
> 
> 			pHostAddress = pSPOnlyAddress;
> 		}
512a631,663
> 			if ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) != 0 ) &&
> 				 ( pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// Copy the connect data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since the dialog is being popped, this command is in progress,
> 				// not pending.
> 				//
> 				DNASSERT( pSPData != NULL );
> 
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				pEndpoint->CopyEnumQueryData( pEnumQueryData );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for enum query!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove our reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
526a678,679
> 			}
> 
599a753,758
> 	if ( pSPOnlyAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pSPOnlyAddress );
> 		pSPOnlyAddress = NULL;
> 	}
> 
770c929
< 	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
---
> 	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
974a1134,1162
> 			if ( ( pConnectData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
> 			{
> 				//
> 				// Copy the connect data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since a dialog is being displayed, the command is in-progress,
> 				// not pending.
> 				//
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				pEndpoint->CopyConnectData( pConnectData );
> 				if ( ( hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() ) ) != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for connect!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove our reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
975a1164,1165
> 			}
> 
1232c1422
< 	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
---
> 	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
1438a1629,1661
> 			if ( ( pListenData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
> 			{
> 				//
> 				// Copy the listen data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since this endpoint is being handed off to another thread,
> 				// make sure it's in the unbound list.  Since a dialog is being
> 				// displayed, the command state is in progress, not pending.
> 				//
> 				DNASSERT( pSPData != NULL );
> 
> 				pEndpoint->CopyListenData( pListenData );
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for listen!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove out reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
1439a1663,1664
> 			}
> 
2400a2626,2637
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2617a2855,2866
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\07261030.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\comutil.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\comutil.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\dndbg.c	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dndbg.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dneterrors.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\guidutil.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	1ece02cc	6bb05875
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\packbuff.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\packbuff.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\strutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\strutils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\appdesc.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\client.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\connect.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dllmain.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.def	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dnet.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\migration.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\msghandler.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\ntentry.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\peer.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\server.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\worker.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addbase.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addparse.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addtcp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dllmain.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.def	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpsp8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\connect.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\enum.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\initialize.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\timer.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock1.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock2.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\locals.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\locals.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\rsip.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.def	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 97 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\callstack.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\memlog.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\dnmisc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\dpguid.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04241015.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04261045.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05010945.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05021600.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05031030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05081300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05091400.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05111530.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05121300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05151130.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05161345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05221345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05231030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06021030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06121345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06121445.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06141200.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06191100.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\07171100.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\lastsync.bat	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\dplegacy.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\dplegacy.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\connect.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\directnet.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\directplay8core.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dnaddress.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dndbg.txt	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dnregister.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dp8context.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dp8protocol.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpaddress.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpclassinfo.xls	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpcustombuild.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplay8.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplay8.xls	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplobby8.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpnsvr.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpv8dmo.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoice.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoice.mpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoicenote.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\hostmigration.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\lobby8update.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\nametable.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\nametbl.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\rfc1738.txt	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\spintf.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\usercb.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\winsockspwireprotocol.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvlib.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvlib.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvrq.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvrq.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpnsvr.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpsvr8.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpsvr8.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\proctbl.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\proctbl.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\inc\dpnsdef.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\inc\dpnsvmsg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\inc\dplobby8.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\classfac.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\comstuff.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dllmain.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dnlobby.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplapp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplapp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplclient.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplclient.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplcommon.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplcommon.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconnect.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconnect.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconset.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconset.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplmsgq.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplmsgq.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby8int.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplparam.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplparam.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplproc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplproc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplreg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplreg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\globals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\handles.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\handles.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\contextfixedpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\handletable.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\handletable.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\registry.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\registry.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 227 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
3a4
>       lobby \
5c6,7
<       core
---
>       core \
>       dpnsvr 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\comutil.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include "creg.h"
23a25
> #include <stdlib.h>
38c40
<     WCHAR                   wszFileName[_MAX_PATH];
---
>     CHAR                    szFileName[_MAX_PATH];
122c124
<     hr = COM_GetDLLName( clsid, pEntry->wszFileName, &dwSize );
---
>     hr = COM_GetDLLName( clsid, pEntry->szFileName, &dwSize );
130c132
<     pEntry->hDLL = LoadLibraryW( pEntry->wszFileName );
---
>     pEntry->hDLL = LoadLibraryA( pEntry->szFileName );
164c166
< HRESULT COM_GetDLLName( GUID guidCLSID, WCHAR *wszPath, DWORD *pdwSize )
---
> HRESULT COM_GetDLLName( GUID guidCLSID, CHAR *szPath, DWORD *pdwSize )
166,170c168,170
< // BUGBUG: [mgere] [xbox] These com wrapper functions will only be called to
< // retrieve the wsock com object, so I hard coded the dpwsock.dll to always
< // return from this function.
< //
<     WCHAR wszDLL[] = L"dpnwsock.dll";
---
>     CRegistry cregRoot;
>     CRegistry cregCLSID;
>     CRegistry cregInProc;
172c172,177
<     wcscpy( wszPath, wszDLL);
---
>     HRESULT hr;
>     BOOL fSuccess;
>     WCHAR *wszTmpPath = NULL;
>     DWORD dwTmpSize = 0;
>     int res;
>     BOOL fDefault;
174c179
<     return S_OK;
---
>     fSuccess = cregRoot.Open( HKEY_CLASSES_ROOT, L"CLSID", TRUE, FALSE );
175a181,245
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening HKEY_CLASSES_ROOT\\CLSID" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     fSuccess = cregCLSID.Open( cregRoot, &guidCLSID, TRUE, FALSE );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening specified CLSID" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     fSuccess = cregInProc.Open( cregCLSID, L"InprocServer32", TRUE, FALSE );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening inprocserver key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     cregCLSID.Close();
>     cregRoot.Close();
> 
>     fSuccess = cregInProc.ReadString( L"", wszTmpPath, pdwSize );
> 
>     if( !*pdwSize )
>     {
>         DPF( 0, "Error opening default key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     wszTmpPath = new WCHAR[*pdwSize];
> 
>     fSuccess = cregInProc.ReadString( L"", wszTmpPath, pdwSize );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening default key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     if( FAILED( hr = STR_jkWideToAnsi(szPath,wszTmpPath, *pdwSize ) ) )
>     {
>         DPF( 0, "Error converting path to DLL to ANSI hr=0x%x", hr );
>         hr = E_FAIL;
>     }
> 
>     delete [] wszTmpPath;
> 
>     return hr;
> 
> COM_GETDLLNAME_ERROR:
> 
>     if( wszTmpPath )
>         delete [] wszTmpPath;
> 
>     return hr;
> 
192c262
< // BUGBUG: [mgere] [xbox] Added this temporarily
---
>     hr = CoCreateInstance( rclsid, pUnkOuter, dwClsContext, riid, ppv );
194,195c264,265
< COM_Init();
< 
---
>     if( hr == CO_E_NOTINITIALIZED )
>     {
217a288,291
> 
>         return hr;
> 
>     }
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\comutil.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21c21
< HRESULT COM_GetDLLName( GUID guidCLSID, WCHAR *szPath, DWORD *pdwSize );
---
> HRESULT COM_GetDLLName( GUID guidCLSID, CHAR *szPath, DWORD *pdwSize );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
29a37,65
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "UNKNOWN_MODULE"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectNet] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNetDebug"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dndbg.c)---()---()---()---()---()---()---()---()---()---()  
.  
.  
32a33
> #include "memlog.h"
38a40,185
> /*******************************************************************************
> 	Debug Logging to VXD.  In order to get this logging, DNET.VXD must be
> 	installed on the system.  This service is only available in the Win9x code
> 	base and can be installed by added the following to the system.ini file
> 	in the 386Enh section
> 
> 	[386Enh]
> 	device=dnet.vxd
> 
> 	This will enable a set of command under the debugger for dumping the
> 	log when broken into the debugger.  The commands can be initiated by
> 	typing .dnet at the ## prompt in the debugger.
> ==============================================================================*/
> /*
> BOOL DeviceIoControl(
> HANDLE hDevice, 			// handle to device of interest
> DWORD dwIoControlCode, 		// control code of operation to perform
> LPVOID lpInBuffer, 			// pointer to buffer to supply input data
> DWORD nInBufferSize, 		// size of input buffer
> LPVOID lpOutBuffer, 		// pointer to buffer to receive output data
> DWORD nOutBufferSize, 		// size of output buffer
> LPDWORD lpBytesReturned, 	// pointer to variable to receive output byte count
> LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
> );
> */
> 
> #define MAX_STRING       240
> #define LOG_SIZE         2000
> #define FIRST_DEBUG_PROC 100
> 
> #define OPEN_DEBUGLOG 	(FIRST_DEBUG_PROC)
> #define WRITE_DEBUGLOG 	(FIRST_DEBUG_PROC+1)
> #define WRITE_STATS     (FIRST_DEBUG_PROC+2)
> #define WSPRINTF		wsprintfA
> 
> typedef struct _LOGENTRY {
> 	CHAR	debuglevel;
> 	CHAR    str[1];
> } LOGENTRY, *PLOGENTRY;
> 
> typedef struct {
> 	UINT	nLogEntries;
> 	UINT    nCharsPerLine;
> } IN_LOGINIT, *PIN_LOGINIT;
> 
> typedef struct {
> 	UINT    hr;
> } OUT_LOGINIT, *POUT_LOGINIT;
> 
> typedef struct {
> 	CHAR	debuglevel;
> 	CHAR    str[1];
> } IN_LOGWRITE, *PIN_LOGWRITE;
> 
> typedef struct {
> 	UINT	hr;
> } OUT_LOGWRITE, *POUT_LOGWRITE;
> 
> 
> HANDLE hLoggingVxd=0;
> HANDLE hLogMutex=0;
> HANDLE hLogFile=0;
> PSHARED_LOG_FILE pLogFile=0;
> 
> /*===========================================================================
> 
> 	Debug Support.
> 
> 	Logging:
> 	========
> 
> 	Debug Logging and playback is designed to operate on both Win9x and
> 	Windows NT (Windows 2000).  On Win9x, a support VXD is used to extend
> 	the kernel debugger.  The VXD (DNET.VXD) is used for both logging and
> 	playback of debug buffers.  In addition to the debug VXD there is also
> 	logging to a shared file.  The shared file logging is played back with
> 	the DNLOG.EXE utility and can be played back on either Windows2000 or
> 	Win9x.
> 
> 	Debug support for dumping structures on Win9x is supported only in the
> 	DNET.VXD component.  Dumping of structures internal to DPLAY can only
> 	be done from the context of a DPLAY thread.  This is because the
> 	addresses are only valid in that context.  Under NT there is (will be)
> 	a debug extension for dumping internal structures.
> 
> 	Debug Logging is controlled by settings in the win.ini file.  Under
> 	the section heading [DirectPlay8].  There are 2 settings:
> 
> 	Debug=9
> 
> 	controls the debug level.  All messages, at or below that debug level
> 	are printed.
> 
> 	The second setting (logging).  If not specified, all debugs are spewed
> 	through the standard DebugPrint and will appear on in DEVSTUDIO if
> 	it is up, or on the kernel debugger if it is running.
> 
> 	log = 0 {no debug output}
> 	log = 1	{spew to console only}
> 	log = 2 {spew to log only}
> 	log = 3 {spew to console and log}
> 
> 	example win.ini...
> 
> 	[DirectPlay8]
> 	Debug=7		; lots of spew
> 	log=2		; don't spew to debug window
> 
> 	[DirectPlay8]
> 	Debug=0		; only fatal errors spewed to debug window
> 
> 	Asserts:
> 	========
> 	Asserts are used to validate assumptions in the code.  For example
> 	if you know that the variable jojo should be > 700 and are depending
> 	on it in subsequent code, you SHOULD put an assert before the code
> 	that acts on that assumption.  The assert would look like:
> 
> 	ASSERT(jojo>700);
> 
> 	Asserts generally will produce 3 lines of debug spew to highlight the
> 	breaking of the assumption.  For testing, you might want to set the
> 	system to break in on asserts.  This is done in the [DirectPlay8] section
> 	of win.ini by setting BreakOnAssert=TRUE
> 
> 	e.g.
> 
> 	[DirectPlay8]
> 	Debug=0
> 	BreakOnAssert=TRUE
> 	Verbose=1
> 
> 	Debug Breaks:
> 	=============
> 	When something really severe happens and you want the system to break in
> 	so that you can debug it later, you should put a debug break in the code
> 	path.  Some people use the philosophy that all code paths must be
> 	verified by hand tracing each one in the debugger.  If you abide by this
> 	you should place a DEBUG_BREAK() in every code path and remove them
> 	from the source as you trace each.  When you have good coverage but
> 	some unhit paths (error conditions) you should force those paths in
> 	the debugger.
> 
> 
> ===========================================================================*/
> 
41c188,195
< DWORD lDebugLevel = 1;	
---
> 
> DWORD lDebugLevel = 0;	
> 
> DWORD dwLogging   = 1;	// 0 => No debug spew
> 						// 1 => Spew to console only (default)
> 						// 2 => Spew to log only
> 						// 3 => Spew to console and log
> 
43d196
< DWORD bVerbose = FALSE;	// if TRUE, all file/line/module information is printed and logged.
44a198,204
> // if TRUE, all file/line/module information is printed and logged.
> DWORD bVerbose = FALSE;	
> BOOL  bLiveLogging = FALSE;
> 
> // if TRUE messages printed with the LOGPF will be logged, if FALSE they're ignored
> DWORD  lOutputLog = 0;
> 
54a215,218
> //  7/24/00(RichGr) - IA64: If g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS,
> //     we're running under Win9x.
> DWORD       g_dwPlatformId;
> 
65a230,353
> // open up a channel to the DirectNet VXD (DNET.VXD) that will allows
> // the log to be written to the VxD through DeviceIoControl calls.  The
> // log in this case is accessible in the Win9x kernel debugger through
> // the .dnet debugger extensions.
> void InitDirectNetVxd(void)
> {
> 	IN_LOGINIT In;
> 	OUT_LOGINIT Out;
> 	UINT cbRet;
> 
> 	// note we rely on the system automatically closing this
> 	// handle for us when the user mode application exits.
> 	hLoggingVxd = CreateFileA("\\\\.\\DNET",0,0,0,0,0,0);
> 
> 	if(hLoggingVxd != INVALID_HANDLE_VALUE){
> 
> 		In.nCharsPerLine=MAX_STRING;
> 		In.nLogEntries=5000;
> 		DeviceIoControl(hLoggingVxd,
> 						OPEN_DEBUGLOG,
> 						&In,sizeof(In),
> 						&Out, sizeof(Out),
> 						&cbRet, NULL);
> 	} else {
> 		hLoggingVxd=0;
> 	}
> }
> 
> // Write a string to the log in the debug support VxD.  This only
> // operates on Win9x, when the DNET.VXD is installed.
> static void VxdLogString( LPSTR str )
> {
> 	char logstring[MAX_STRING+sizeof(LOGENTRY)];
> 	int  i=0;
> 	PLOGENTRY pLogEntry=(PLOGENTRY)&logstring;
> 	UINT rc;
> 	UINT cbRet;
> 	int maxlen = MAX_STRING+sizeof(LOGENTRY);
> 
> 	if(hLoggingVxd && str){
> 		while(str[i] && i < maxlen)
> 			i++;
> 		pLogEntry->debuglevel=0;
> 		memcpy(pLogEntry->str,str,i+1);
> 		DeviceIoControl(hLoggingVxd,WRITE_DEBUGLOG,pLogEntry,i+sizeof(LOGENTRY), &rc, sizeof(rc), &cbRet, NULL);
> 	}
> }
> 
> // Create a shared file for logging information on the fly
> // This support allows the current log to be dumped from the
> // user mode DPLOG.EXE application.  This is useful when debugging
> // in MSSTUDIO or in NTSD.  When the DPLOG.EXE is invoke, note that
> // the application will get halted until the log is completely dumped
> // so it is best to dump the log to a file.
> static BOOL InitMemLogString(VOID)
> {
> 	static BOOL inited = FALSE;
> 
> 	if(!inited){
> 		hLogFile=CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, DPLOG_SIZE, BASE_LOG_FILENAME);
> 		hLogMutex=CreateMutexA(NULL,FALSE,BASE_LOG_MUTEXNAME);
> 		pLogFile=(PSHARED_LOG_FILE)MapViewOfFile(hLogFile, FILE_MAP_ALL_ACCESS,0,0,0);
> 
> 		if(!hLogFile || !hLogMutex || !pLogFile){
> 			if(hLogFile){
> 				CloseHandle(hLogFile);
> 				hLogFile=0;
> 			}
> 			if(hLogMutex){
> 				CloseHandle(hLogMutex);
> 				hLogMutex=0;
> 			}
> 			if(pLogFile){
> 				UnmapViewOfFile(pLogFile);
> 				pLogFile=NULL;
> 			}
> 			return FALSE;
> 		} else {
> 			inited = TRUE;
> 			pLogFile->nEntries = DPLOG_NUMENTRIES;
> 			pLogFile->cbLine   = DPLOG_ENTRYSIZE;
> 			pLogFile->iWrite   = 0;
> 			pLogFile->cInUse   = 0;
> 		}
> 	}
> 	return TRUE;
> }
> 
> // Log a string to a shared file.  This file can be dumped using the
> // DPLOG.EXE utility.
> static void MemLogString(LPSTR str)
> {
> 	PLOG_ENTRY pEntry;
> 	DWORD cbCopy;
> 
> 	if(!hLogFile){
> 		if(!InitMemLogString()){
> 			return;
> 		}
> 	}
> 
> 	WaitForSingleObject(hLogMutex,INFINITE);
> 
> 	pEntry=(PLOG_ENTRY)(((PUCHAR)(pLogFile+1))+(pLogFile->iWrite*(sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)));
> 	pEntry->hThread=GetCurrentThreadId();
> 	pEntry->tLogged=timeGetTime();
> 	pEntry->DebugLevel=0;
> 
> 	cbCopy=strlen(str)+1;
> 	if(cbCopy > DPLOG_ENTRYSIZE){
> 		str[DPLOG_ENTRYSIZE]=0;
> 		cbCopy=DPLOG_ENTRYSIZE;
> 	}
> 	memcpy(pEntry->str, str, cbCopy);
> 
> 	if(pLogFile->iWrite+1 > pLogFile->cInUse){
> 		pLogFile->cInUse=pLogFile->iWrite+1;
> 	}
> 
> 	pLogFile->iWrite = (pLogFile->iWrite+1) % pLogFile->nEntries;
> 	ReleaseMutex(hLogMutex);
> 
> }
> 
68a357,360
> 	DWORD           lSpecificLevel;
>     OSVERSIONINFO   OSVersionInfo = {0};
> 
> 
72a365,406
>     lDebugLevel = (signed int) GetProfileIntA( PROF_SECT, "debug", 0 );
>     lSpecificLevel = (signed int) GetProfileIntA( PROF_SECT, DPF_MODULE_NAME, -1);
>     if(lSpecificLevel != -1){
>     	lDebugLevel = lSpecificLevel;
>     }
>     dwLogging   = (signed int) GetProfileIntA( PROF_SECT, "log" , 0);
>     bBreakOnAssert = (signed int) GetProfileIntA( PROF_SECT, "BreakOnAssert", 0);
>     bVerbose = (signed int) GetProfileIntA( PROF_SECT, "Verbose", 0);
> 
>     lOutputLog = (signed int) GetProfileIntA( PROF_SECT, "OutputLog", 0);
> 
> 	switch(dwLogging){
> 		case 0:
> 			bLiveLogging=FALSE;
> 			break;
> 		case 1:
> 			bLiveLogging=TRUE;
> 			break;
> 		case 2:
> 			bLiveLogging=FALSE;
> 			break;
> 		case 3:
> 			bLiveLogging=TRUE;
> 			break;
> 		default:
> 			break;
> 	}
> 	if((dwLogging >= 2)||(lOutputLog > 0)){
> 		// Doing log based logging, so try to find the VXD and open
> 		// the shared logging file.
> 		InitDirectNetVxd();
> 
> 		// Do logging also based on shared memory file.
> 		InitMemLogString();	
> 	}
> 
> //  7/24/00(RichGr) - IA64: Detect whether we're running under Win9x.  Get the Windows version.
> //     If dwPlatformId == VER_PLATFORM_WIN32_WINDOWS, that's Win9x.
>     OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
>     GetVersionEx(&OSVersionInfo);
>     g_dwPlatformId = OSVersionInfo.dwPlatformId;
> 
73a408
> 
79a415,420
> 	if(hLogFile){
> 		CloseHandle(hLogFile);
> 	}
> 	if(hLoggingVxd){
> 		CloseHandle(hLoggingVxd);
> 	}	
128a470,471
> 		if(bLiveLogging)
> 		{
131a475,485
> 		}
> 
> 		if(hLoggingVxd){
> 			// log to vxd
> 			VxdLogString( str );
> 		}
> 
> 		if(dwLogging >= 2){
> 			// log to shared file
> 			MemLogString( str );
> 		}
135c489,491
< //  5/23/2000(RichGr): IA64: Change DWORD to DWORD_PTR.
---
> // 05/23/2000(RichGr): IA64: Change DWORD to DWORD_PTR.
> // 07/16/2000(jchauvin): IA64:  Added %p parsing to change back to %x for Win9x machines
> 
137a494
> 	CHAR  cTemp[MAX_PATH];
139c496
< 
---
>     char  *psz = NULL;
141a499
> 
154a513,523
> //  7/24/00(RichGr) - IA64: If g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS,
> //     we're running under Win9x and need to replace %p with %x.
>     if (g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
>     {
>         strcpy(cTemp, szFormat);                // Copy to a local string that we can modify.
> 	    szFormat = cTemp;					    // Point szFormat at the local string
> 
>         while (psz = strstr(szFormat, "%p"))    // Look for each "%p".
>            *(psz+1) = 'x';                      // Substitute 'x' for 'p'.  Don't try to expand 
>     }
> 
173c542
< 	WSPRINTF(cMsg+strlen( cMsg ), szFormat, argptr);
---
> 	WSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);
184a554,555
> // 07/16/2000(jchauvin): IA64:  Added %p parsing to change back to %x for Win9x machines
> 
187a559
> 	CHAR  cTemp[MAX_PATH];
189c561
< 
---
>     char  *psz = NULL;
191a564
> 
206a580,590
> //  7/24/00(RichGr) - IA64: If g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS,
> //     we're running under Win9x and need to replace %p with %x.
>     if (g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
>     {
>         strcpy(cTemp, szFormat);                // Copy to a local string that we can modify.
> 	    szFormat = cTemp;					    // Point szFormat at the local string
> 
>         while (psz = strstr(szFormat, "%p"))    // Look for each "%p".
>            *(psz+1) = 'x';                      // Substitute 'x' for 'p'.  Don't try to expand 
>     }
> 
225c609
< 	WVSPRINTF(cMsg+strlen( cMsg ), szFormat, argptr);
---
> 	WVSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);
233a618,668
> /*
> **	LogPrintf copies a quick Log Entry to the
> **
> */
> 
> //  5/23/2000(RichGr): IA64: Change DWORD to DWORD_PTR.
> // 07/16/2000(jchauvin): IA64:  Added %p parsing to change back to %x for Win9x machines
> void LogPrintf(volatile DWORD_PTR dwDetail, ...)
> {
> 	CHAR  cMsg[1000];
> 	CHAR  cTemp[MAX_PATH];
> 	LPSTR szFormat;
>     char  *psz = NULL;
> 	va_list argptr;
> 
> 
> 	if(lOutputLog < dwDetail){
> 		LeaveCriticalSection(&csDPF);
> 		return;
> 	}
> 
> 	//EnterCriticalSection(&csDPF);
> 
> 	va_start(argptr, dwDetail);
> 	szFormat = (LPSTR) va_arg(argptr, DWORD_PTR);
> 
> 
> 	cMsg[0]=0;
> 
> //  7/24/00(RichGr) - IA64: If g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS,
> //     we're running under Win9x and need to replace %p with %x.
>     if (g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
>     {
>         strcpy(cTemp, szFormat);                // Copy to a local string that we can modify.
> 	    szFormat = cTemp;				        // Point szFormat at the local string
> 
>         while (psz = strstr(szFormat, "%p"))    // Look for each "%p".
>             *(psz+1) = 'x';                     // Substitute 'x' for 'p'.  Don't try to expand 
>     }
> 
> 	WSPRINTF(cMsg,"%s: ",g_szModName);
> 
> 	WVSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);
> 
> 	MemLogString( (LPSTR) cMsg );
> 
> 	LeaveCriticalSection(&csDPF);
> 
> 	va_end(argptr);
> }
> 
240a676,677
> #define ASSERT_BREAK_SECTION "BreakOnAssert"
> #define ASSERT_BREAK_DEFAULT FALSE
263c700
<     if( bBreakOnAssert )
---
>     if( bBreakOnAssert || GetProfileIntA( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
332a770,790
> }
> 
> BOOL IsValidStringA( const CHAR * const szString )
> {
> 	const char *szTmpLoc = szString;
> 	
> 	if( szString == NULL )
> 	{
> 		return FALSE;
> 	}
> 
> 	_try
> 	{
> 		for( ; *szTmpLoc ; szTmpLoc++ );
> 	}
> 	_except( EXCEPTION_EXECUTE_HANDLER )
> 	{
> 		return FALSE;
> 	}
> 
> 	return TRUE;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dndbg.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
29a30,32
> 	#if defined( _WIN32 ) && !defined(WINNT) && defined(_X86_)
> 		#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
> 	#else
30a34
> 	#endif
102a107
> extern BOOL IsValidStringA( const CHAR * const swzString );
111a117
> extern void LogPrintf(volatile DWORD_PTR dwDetail, ...);
112a119
> #define DNVALID_STRING_A(a)		IsValidStringA(a)
127c134,138
< #define	LOGPF		DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
---
> #ifdef DPF_SUBCOMP_MASK
> 	#define DPFSC if(DPF_SUBCOMP_MASK & DPF_SUBCOMP_BIT)DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),if(DPF_SUBCOMP_MASK & DPF_SUBCOMP_BIT)DebugPrintf
> #else
> 	#define DPFSC DPF
> #endif
128a140,141
> #define	LOGPF		DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),LogPrintf
> 
133a147
> 	#define DNVALID_STRING_A(a)			(TRUE)
139a154
> 	#define DPFSC()
148,149c163,166
< #define WVSPRINTF wvsprintf
< #define STRLEN   strlen
---
> #define WVSPRINTF wvsprintfA
> #define STRLEN   lstrlenA
> 
> #define PROF_SECT "DirectPlay8"
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dneterrors.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20,23
> // vanceo - changed to stdio for printf
> //#include	<iostream.h>
> #include	<stdio.h>
> 
78a83,92
> 			// output to console
> 			case DPNERR_OUT_CONSOLE:
> 			{
> 				// Also see the change from <iostream.h> to <stdio.h> above
> 				#pragma TODO(vanceo, "Changed cout to printf so NT build environment will work, figure this out.")
> 				//cout << endl << pString << endl;
> 				printf("\n%s\n", pString);
> 				break;
> 			}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\guidutil.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
15c15
< #include <wchar.h>
---
> #include "stdio.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34,37
> #ifdef	_WIN64
> #define	MEMORY_CRC			0X5AA55AA55AA55AA5
> #define	GUARD_SIGNATURE		0x0F1E2D3C4B5A6978
> #else
35a40
> #endif	// _WIN64
40a46,52
> //
> // enumerated values to indicate how to report memory leaks
> //
> #define	MEMORY_LEAK_REPORT_NONE		0x00000000
> #define	MEMORY_LEAK_REPORT_DPF		0x00000001
> #define	MEMORY_LEAK_REPORT_DIALOG	0x00000002
> 
60a73
> #ifdef	_X86_
61a75,77
> #else
> #define	ASSERT( arg )	if ( arg == FALSE ) { DebugBreak(); }
> #endif
94a111,116
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
> static	HINSTANCE			g_hApplicationInstance;
> 
> //
103a126,128
> static int	DisplayCallStack( const char *const pszMsg,
> 							  const char *const pszTitle,
> 							  const char *const pCallStack );
121a147
> 	OSVERSIONINFO	OSVersionInfo;
122a149
> 
130a158,186
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
> 	// note application instance
> 	//
> 	g_hApplicationInstance = GetModuleHandle( NULL );
> 	if ( g_hApplicationInstance == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to GetModuleHandle: 0x%x", dwError );
> 		goto Failure;
> 	}
> 
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
> 	//
229a286,287
> 		switch ( DNGetOSType() )
> 		{
232a291,292
> 			case VER_PLATFORM_WIN32_NT:
> 			{
256a317,327
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
289a361,392
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetApplcationInstance - application instance
> //
> // Entry:		Nothing
> //
> // Exit:		Application instance
> // ------------------------------
> HINSTANCE	DNGetApplicationInstance( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_hApplicationInstance;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
360a464
> //#ifdef	_WIN32
389a494
> //#endif	// _WIN32
390a496,517
> 
> //#ifdef	_WIN64
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	if ( pTime1->Time < pTime2->Time )
> //	{
> //		iReturnValue = -1;
> //	}
> //	else
> //	{
> //		if ( pTime1->Time == pTime2->Time )
> //		{
> //			iReturnValue = 0;
> //		}
> //		else
> //		{
> //			iReturnValue = 1;
> //		}
> //	}
> //#endif	// _WIN64
> 
416a544
> #ifdef	_X86_
428a557,607
> 
> #else	// _X86_
> 
> /*
> #ifdef	_ALPHA_
> 	// debug me
> 	DebugBreak();
> 
> 	__asm{ mov	$t0, *pTime1
> 		   mov	$t1, *pTime2
> 		   addq	$t0, $t1
> 		   mov	*pTimeResult, $t0
> 	};
> #else	// _ALPHA_
> */
> 
> //#ifdef	_WIN32
> 	DWORD	dwTempLowTime;
> 
> 
> 	dwTempLowTime = pTime1->Time32.TimeLow;
> 	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow + pTime2->Time32.TimeLow;
> 	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh + pTime2->Time32.TimeHigh;
> 
> 	//
> 	// check for overflow in low 32-bits and increment high value if applicable
> 	//
> 	if ( pTimeResult->Time32.TimeLow < dwTempLowTime )
> 	{
> #pragma	BUGBUG( johnkan, "Test this!" )
> 		// debug me
> 		DebugBreak();
> 		pTimeResult->Time32.TimeHigh++;
> 	}
> //#endif	// _WIN32
> 
> //#ifdef	_WIN64
> //	DEBUG_ONLY( UINT_PTR	ReferenceTime );
> //
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	DEBUG_ONLY( ReferenceTime = pTime1->Time );
> //	*pTimeResult = pTime1->Time + pTime2->Time;
> //	DNASSERT( *pTimeResult >= ReferenceTime );
> //
> //#endif	// _WIN64
> 
> // #endif	// _ALPHA_
> 
> #endif	// _X86_
454a634,635
> #ifdef	_X86_
> 
466a648,694
> 
> #else	// _X86_
> 
> /*
> #ifdef	_ALPHA_
> 	// debug me
> 	DebugBreak();
> 
> 	mov		$t0, *pTime1
> 	mov		$t1, *pTime2
> 	addq	$t0, $t1
> 	mov		*pTimeResult, $t0
> #else	// _ALPHA_
> */
> 
> //#ifdef	_WIN32
> 	DWORD	dwTempLowTime;
> 
> 
> 	dwTempLowTime = pTime1->Time32.TimeLow;
> 	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow - pTime2->Time32.TimeLow;
> 	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh - pTime2->Time32.TimeHigh;
> 
> 	//
> 	// check for underflow in low 32-bits and decrement high value if applicable
> 	//
> 	if ( pTimeResult->Time32.TimeLow > dwTempLowTime )
> 	{
> #pragma	BUGBUG( johnkan, "Test this!" )
> 		// debug me
> 		DebugBreak();
> 
> 		pTimeResult->Time32.TimeHigh--;
> 	}
> //#endif	// _WIN32
> 
> //#ifdef	_WIN64
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	DNASSERT( pTime1->Time > pTime2->Time );
> //	pTimeResult = pTime1->Time - pTime2->Time;
> //#endif	// _WIN64
> 
> // #endif	// _ALPHA_
> 
> #endif	// _X86_
687a916,918
> 		void	NoteCurrentCallStack( void ) { m_CallStack.NoteCurrentCallStack(); }
> 		void	GetCallStack( char *const pBuffer ) const { m_CallStack.GetCallStackString( pBuffer ); }
> 
706a938
> 		CCallStack<DN_MEMORY_CALL_STACK_DEPTH>	m_CallStack;
797a1030
> 		pMemoryLink->NoteCurrentCallStack();
907a1141
> 	char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
941,942c1175,1186
< 			DPF( 0, "%s%s\n", "Memory Corruption!", MessageString );
< //					DNASSERT( FALSE );
---
> 			pMemoryLink->GetCallStack( CallStackBuffer );
> 			MessageReturn = DisplayCallStack( MessageString, "Memory Corruption!", CallStackBuffer );
> 			switch ( MessageReturn )
> 			{
> 				case IDABORT:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				case IDIGNORE:
> 				{
946a1191,1199
> 					break;
> 				}
> 
> 				case IDRETRY:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
977a1231
> 	DWORD		dwDisplayFlags;
978a1233
> 
981a1237
> 	fDisplayLeaks = TRUE;
984a1241,1242
> 	dwDisplayFlags = GetProfileIntA( PROF_SECT, "MemoryLeakOutput", MEMORY_LEAK_REPORT_DPF );
> 	
991a1250
> 		char		CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
1004,1005c1263
< 			DPF( 0, "%s%s\n", DialogTitle, LeakSizeString );
< //						DNASSERT( FALSE );
---
> 		pTemp->GetCallStack( CallStackBuffer );
1006a1265,1315
> 
> 		if ( ( dwDisplayFlags & MEMORY_LEAK_REPORT_DPF ) != 0 )
> 		{
> 			DPF( 0, "%s%s%s\n", DialogTitle, LeakSizeString, CallStackBuffer );
> 		}
> 
> 		if ( ( dwDisplayFlags & MEMORY_LEAK_REPORT_DIALOG ) != 0  )
> 		{
> 			if ( fDisplayLeaks != FALSE )
> 			{
> 				MessageReturn = DisplayCallStack( LeakSizeString, DialogTitle, CallStackBuffer );
> 				switch ( MessageReturn )
> 				{	
> 					//
> 					// stop application now
> 					//
> 					case IDABORT:
> 					{
> 						fDisplayLeaks = FALSE;
> 						break;
> 					}
> 
> 					//
> 					// display next leak
> 					//
> 					case IDIGNORE:
> 					{
> 						break;
> 					}
> 
> 					//
> 					// stop in the debugger
> 					//
> 					case IDRETRY:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 
> 					//
> 					// unknown
> 					//
> 					default:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 				}
> 			}
> 		}
> 
1019a1329,1472
> 
> 
> #if	defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
> //**********************************************************************
> //**
> //** THIS IS THE STACK TRACKING SECTION.  ONLY ADD FUNCTIONS HERE THAT ARE
> //** RELATED TO TRACKING THE CALL STACK!!
> //**
> //**********************************************************************
> 
> 
> ////**********************************************************************
> //// ------------------------------
> //// DNGetStackTop - return pointer to top of stack
> ////
> //// Entry:		Nothing
> ////
> //// Exit:		Pointer to top of stack
> //// ------------------------------
> //static void	*DNGetStackTop( void )
> //{
> //	void	*pReturn;
> //
> //	_asm	mov eax,dword ptr fs:[4]
> //	_asm	mov pReturn, eax
> //	return	pReturn;
> //}
> ////**********************************************************************
> //
> //
> ////**********************************************************************
> //// ------------------------------
> //// DNGetStackBottom - return pointer to bottom of call stack
> ////
> //// Entry:		Nothing
> ////
> //// Exit:		Pointer to bottom of call stack
> //// ------------------------------
> //static void	*DNGetStackBottom( void )
> //{
> //	void	*pReturn;
> //
> //	_asm	mov eax,dword ptr fs:[8]
> //	_asm	mov pReturn, eax
> //	return	pReturn;
> //}
> ////**********************************************************************
> 
> 
> ////**********************************************************************
> //// ------------------------------
> //// DNGetCallStack - get a call stack
> ////
> //// Entry:		Pointer to call stack array
> ////				Number of calls to report
> ////
> //// Exit:		Nothing
> //// ------------------------------
> //static	void	DNGetCallStack( const void **const pCallStack, const UINT_PTR Depth )
> //{
> //	void		**CallersEBP;
> //	void		*ReturnAddr;
> //	UINT_PTR	i,iCount;
> //	void		*StackTop;
> //	void		*StackBottom;
> //	static const	void	*min_dll_base = NULL;
> //
> //
> //	StackTop = DNGetStackTop();
> //	StackBottom = DNGetStackBottom();
> //	memset(	pCallStack, 0x00, sizeof( *pCallStack ) * Depth );
> //
> //	_asm
> //	{
> //		mov eax,[ebp]
> //		mov CallersEBP,eax
> //	}
> //
> //	__try
> //	{
> //		//
> //		// this code can generate exception if it steps back too far...
> //		//
> //		for ( i = 0, iCount = 0; i < Depth; iCount++ )
> //		{
> //			if ( ( CallersEBP < StackBottom ) || ( CallersEBP >= StackTop ) )
> //				break;
> //			ReturnAddr = CallersEBP[ 1 ];
> //			if ( ( iCount > 0 ) || ( ReturnAddr >= min_dll_base ) ) // iCount check skips memory_alloc_debug
> //				pCallStack[ i++ ] = ReturnAddr;
> //			CallersEBP = reinterpret_cast<void**>( *CallersEBP ); // get callers callers ebp
> //		}
> //	}
> //	__except( 1 )  // went too far back on the stack, fill up rest of array with zeros
> //	{
> //		DPF( 0, "Benign access violation creating return address stack." );
> //	}
> //}
> ////**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DisplayCallStack - display a call stack message box
> //
> // Entry:		Pointer to information string
> //				Pointer to title string
> //				Pointer to call stack string
> //
> // Exit:		Dialog return code
> // ------------------------------
> static int	DisplayCallStack( const char *const pszMsg, const char *const pszTitle, const char *const pCallStackString )
> {
> 	MSGBOXPARAMS	MessageBoxParams;
> 	char 			szStackTraceMsg[ CALLSTACK_BUFFER_SIZE ];
> 
> 
>     strcpy( szStackTraceMsg, pszMsg );
> 	strcat( szStackTraceMsg, pCallStackString );
> 
> 	//
> 	// display message box
> 	//
> 	memset( &MessageBoxParams, 0x00, sizeof( MessageBoxParams ) );
> 	MessageBoxParams.cbSize = sizeof( MessageBoxParams );
> 	MessageBoxParams.lpszText = szStackTraceMsg;
> 	MessageBoxParams.lpszCaption = pszTitle;
> 	MessageBoxParams.dwStyle = MB_ABORTRETRYIGNORE | MB_SETFOREGROUND | MB_TOPMOST | MB_DEFBUTTON2;
> 	MessageBoxParams.hInstance = NULL;
> 
> 	return MessageBoxIndirect( &MessageBoxParams );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> //**
> //** END OF CALL STACK TRACKING SECTION.
> //**
> //**********************************************************************
> #endif	// defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
> 
> 
> 
1114a1568
> 	static	BOOL	fDisplayCallStacks = TRUE;
1132a1587,1590
> 	if ( pCriticalSection->LockCount == 0 )
> 	{
> 		pCriticalSection->CallStack.NoteCurrentCallStack();
> 	}
1138a1597,1601
> 			if ( fDisplayCallStacks != FALSE )
> 			{
> 				char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
> 
> 
1143,1144c1606,1638
< 			    DPF( 0, "%s%s\n", "DNCritical section has been reentered!", "Check stack trace for function that originally held the lock." );
< //						DNASSERT( FALSE );
---
> 				pCriticalSection->CallStack.GetCallStackString( CallStackBuffer );
> 				switch ( DisplayCallStack( "Stack trace of function that originally held the lock:",
> 										   "DNCritical section has been reentered!",
> 										   CallStackBuffer ) )
> 				{
> 					//
> 					// don't display any more critical section warnings!
> 					//
> 					case IDABORT:
> 					{
> 						fDisplayCallStacks = FALSE;
> 						break;
> 					}
> 
> 					//
> 					// acknowledged
> 					//
> 					case IDIGNORE:
> 					{
> 						break;
> 					}
> 
> 					//
> 					// stop in debugger
> 					//
> 					case IDRETRY:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 				}
> 			}
> 
1177a1672
> 		memset( &pCriticalSection->CallStack, 0x00, sizeof( pCriticalSection->CallStack ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18,19
> #include	"CallStack.h"
> 
29a32,34
> #define	DN_MEMORY_CALL_STACK_DEPTH				12
> #define	DN_CRITICAL_SECTION_CALL_STACK_DEPTH	10
> 
53a59
> 	CCallStack< DN_CRITICAL_SECTION_CALL_STACK_DEPTH > 	CallStack;
85a92,101
> 
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
> HINSTANCE	DNGetApplicationInstance( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\packbuff.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
136a137,207
> // CPackedBuffer::AddStringToBack
> //
> // Entry:		Pointer to source string
> //
> // Exit:		Error Code:	DPN_OK					if able to add
> //							DPNERR_BUFFERTOOSMALL	if buffer is full
> // ------------------------------
> 
> HRESULT CPackedBuffer::AddStringToBack( const char *const pszString )
> {
> 	HRESULT	hr;
> 	DWORD	dwStringSize;
> 	DWORD	dwBufferSize;
> 
> 
> 	DNASSERT( pszString != NULL );
> 	
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	dwStringSize = 0;
> 	hr = STR_AnsiToWide( pszString,
> 						 -1,
> 						 NULL,
> 						 &dwStringSize );
> 	if ( hr != DPNERR_BUFFERTOOSMALL )
> 	{
> 		DNASSERT( hr != DPN_OK );
> 		goto Failure;
> 	}
> 	
> 	dwBufferSize = dwStringSize * sizeof( WCHAR );
> 	m_dwRequired += dwBufferSize;
> 	if ( !m_bBufferTooSmall )
> 	{
> 		if (m_dwRemaining >= dwBufferSize)
> 		{
> 			m_pTail -= dwBufferSize;
> 			m_dwRemaining -= dwBufferSize;
> 			hr = STR_AnsiToWide( pszString,
> 								 -1,
> 								 reinterpret_cast<WCHAR*>( m_pTail ),
> 								 &dwStringSize );
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			DNASSERT( ( dwStringSize * sizeof( WCHAR ) ) == dwBufferSize );
> 		}
> 		else
> 		{
> 			m_bBufferTooSmall = TRUE;
> 		}
> 	}
> 
> 	if ( m_bBufferTooSmall )
> 	{
> 		hr = DPNERR_BUFFERTOOSMALL;
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	goto Exit;
> }
> //**********************************************************************
> // ------------------------------
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\packbuff.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62a63
> 	HRESULT	AddStringToBack( const char *const pszString );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2c17,26
< TARGETTYPE=LIBRARY
---
> 
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
3a28
> TARGETTYPE=LIBRARY
5,9d29
< !ifdef _BUILD_FOR_WIN2000
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< LINKER_FLAGS=-align:32
< !endif
11c31,35
< INCLUDES=..\inc
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
13c37,41
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS)
15c43,47
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
17,18c49,52
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> INCLUDES=$(DXROOT)\inc;..\inc
> 
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
21d54
< MSC_WARNING_LEVEL=/W3 /WX
22a56,62
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
31a72
>         creg.cpp \
36c77,88
< TARGETLIBS=
---
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE
> MSC_OPTIMIZATION=/Odi /Zi
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
> 
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\strutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include "DNetErrors.h"
20a22,23
> #undef DPF_MODNAME
> #define DPF_MODNAME "STR_WideToAnsi"
22c25,48
< // BUGBUG: [mgere] [xbox] UnicodeToMultiByteN and MultiByteToUnicodeN were Taken from nlsxlat.c
---
> //**********************************************************************
> // ------------------------------
> // WideToANSI - convert a wide string to an ANSI string
> //
> // Entry:		Pointer to source wide string
> //				Size of source string (in WCHAR units, -1 implies NULL-terminated)
> //				Pointer to ANSI string destination
> //				Pointer to size of ANSI destination
> //
> // Exit:		Error code:
> //				DPNERR_GENERIC = operation failed
> //				DPN_OK = operation succeded
> //				DPNERR_BUFFERTOOSMALL = destination buffer too small
> // ------------------------------
> HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
> 						const DWORD dwWCHARStringLength,
> 						char *const pString,
> 						DWORD *const pdwStringLength )
> {
> 	HRESULT	hr;
> 	int		iReturn;
> 	BOOL	fDefault;
> 	char	cMilleniumHackBuffer;	
> 	char	*pMilleniumHackBuffer;
24,29d49
< HRESULT
< UnicodeToMultiByteN(
<     OUT PCH MultiByteString,
<     IN ULONG MaxBytesInMultiByteString,
<     IN PWCH UnicodeString,
<     IN ULONG BytesInUnicodeString)
31c51,53
< /*++
---
> 	DNASSERT( pWCHARString != NULL );
> 	DNASSERT( pdwStringLength != NULL );
> 	DNASSERT( ( pString != NULL ) || ( *pdwStringLength == 0 ) );
33c55,60
< Routine Description:
---
> 	//
> 	// Initialize.  A hack needs to be implemented because their paramter
> 	// validation is screwed and when you pass zero for a destination size, you
> 	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
> 	//
> 	hr = DPN_OK;
35,37c62,69
<     This functions converts the specified unicode source string into an
<     ansi string. The translation is done with respect to the
<     ANSI Code Page (ACP) loaded at boot time.
---
> 	if ( *pdwStringLength == 0 )
> 	{
> 		pMilleniumHackBuffer = &cMilleniumHackBuffer;
> 	}
> 	else
> 	{
> 		pMilleniumHackBuffer = pString;
> 	}
39c71,83
< Arguments:
---
> 	fDefault = FALSE;
> 	iReturn = WideCharToMultiByte( CP_ACP,					// code page (default ANSI)
> 								   0,						// flags (none)
> 								   pWCHARString,			// pointer to WCHAR string
> 								   dwWCHARStringLength,		// size of WCHAR string
> 								   pMilleniumHackBuffer,	// pointer to destination ANSI string
> 								   *pdwStringLength,		// size of destination string
> 								   NULL,					// pointer to default for unmappable characters (none)
> 								   &fDefault				// pointer to flag indicating that default was used
> 								   );
> 	if ( iReturn == 0 )
> 	{
> 		DWORD	dwError;
41,43d84
<     MultiByteString - Returns an ansi string that is equivalent to the
<         unicode source string.  If the translation can not be done,
<         an error is returned.
45,47c86,100
<     MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
<         written to MultiByteString.  If this causes MultiByteString to be a
<         truncated equivalent of UnicodeString, no error condition results.
---
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to convert WCHAR to multi-byte!" );
> 		DisplayDNError( 0, dwError );
> 		hr = DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		if ( *pdwStringLength == 0 )
> 		{
> 			hr = DPNERR_BUFFERTOOSMALL;
> 		}
> 		else
> 		{
> 			DNASSERT( hr == DPN_OK );
> 		}
49,50c102,103
<     BytesInMultiByteString - Returns the number of bytes in the returned
<         ansi string pointed to by MultiByteString.
---
> 		*pdwStringLength = iReturn;
> 	}
52,53c105,109
<     UnicodeString - Supplies the unicode source string that is to be
<         converted to ansi.
---
> 	//
> 	// if you hit this ASSERT it's because you've probably got ASCII text as your
> 	// input WCHAR string.  Double-check your input!!
> 	//
> 	DNASSERT( fDefault == FALSE );
55,56c111,113
<     BytesInUnicodeString - The number of bytes in the the string pointed to by
<         UnicodeString.
---
> 	return	hr;
> }
> //**********************************************************************
58d114
< Return Value:
60,63c116,133
<     SUCCESS - The conversion was successful
< 
< --*/
< 
---
> //**********************************************************************
> // ------------------------------
> // ANSIToWide - convert an ANSI string to a wide string
> //
> // Entry:		Pointer to source multi-byte (ANSI) string
> //				Size of source string (-1 imples NULL-terminated)
> //				Pointer to multi-byte string destination
> //				Pointer to size of multi-byte destination (in WCHAR units)
> //
> // Exit:		Error code:
> //				DPNERR_GENERIC = operation failed
> //				DPN_OK = operation succeded
> //				DPNERR_BUFFERTOOSMALL = destination buffer too small
> // ------------------------------
> HRESULT	STR_AnsiToWide( const char *const pString,
> 						const DWORD dwStringLength,
> 						WCHAR *const pWCHARString,
> 						DWORD *const pdwWCHARStringLength )
65,66c135,138
<     ULONG LoopCount;
<     ULONG CharsInUnicodeString;
---
> 	HRESULT	hr;
> 	int		iReturn;
> 	WCHAR	MilleniumHackBuffer;
> 	WCHAR	*pMilleniumHackBuffer;
68d139
<     CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);
70,71c141,143
<     LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
<                  CharsInUnicodeString : MaxBytesInMultiByteString;
---
> 	DNASSERT( pString != NULL );
> 	DNASSERT( pdwWCHARStringLength != NULL );
> 	DNASSERT( ( pWCHARString != NULL ) || ( *pdwWCHARStringLength == 0 ) );
73c145,150
<     while (LoopCount) {
---
> 	//
> 	// Initialize.  A hack needs to be implemented because their paramter
> 	// validation is screwed and when you pass zero for a destination size, you
> 	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
> 	//
> 	hr = DPN_OK;
75c152,170
<         *MultiByteString = (*UnicodeString < 256) ? (UCHAR)*UnicodeString : '?';
---
> 	if ( *pdwWCHARStringLength == 0 )
> 	{
> 		pMilleniumHackBuffer = &MilleniumHackBuffer;
> 	}
> 	else
> 	{
> 		pMilleniumHackBuffer = pWCHARString;
> 	}
> 	
> 	iReturn = MultiByteToWideChar( CP_ACP,					// code page (default ANSI)
> 								   0,						// flags (none)
> 								   pString,					// pointer to multi-byte string			
> 								   dwStringLength,			// size of string (assume null-terminated)
> 								   pMilleniumHackBuffer,	// pointer to destination wide-char string
> 								   *pdwWCHARStringLength	// size of destination in WCHARs
> 								   );
> 	if ( iReturn == 0 )
> 	{
> 		DWORD	dwError;
77,80d171
<         UnicodeString++;
<         MultiByteString++;
<         LoopCount--;
<     }
82,83c173,187
<     return DPN_OK;
< }
---
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to convert multi-byte to WCHAR!" );
> 		DisplayDNError( 0, dwError );
> 		hr = DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		if ( *pdwWCHARStringLength == 0 )
> 		{
> 			hr = DPNERR_BUFFERTOOSMALL;
> 		}
> 		else
> 		{
> 			DNASSERT( hr == DPN_OK );
> 		}
84a189,190
> 		*pdwWCHARStringLength = iReturn;
> 	}
86,151c192
< HRESULT
< MultiByteToUnicodeN(
<     OUT PWCH UnicodeString,
<     IN ULONG MaxBytesInUnicodeString,
<     IN PCH MultiByteString,
<     IN ULONG BytesInMultiByteString)
< 
< /*++
< 
< Routine Description:
< 
<     This functions converts the specified ansi source string into a
<     Unicode string. The translation is done with respect to the
<     ANSI Code Page (ACP) installed at boot time.  Single byte characters
<     in the range 0x00 - 0x7f are simply zero extended as a performance
<     enhancement.  In some far eastern code pages 0x5c is defined as the
<     Yen sign.  For system translation we always want to consider 0x5c
<     to be the backslash character.  We get this for free by zero extending.
< 
<     NOTE: This routine only supports precomposed Unicode characters.
< 
< Arguments:
< 
<     UnicodeString - Returns a unicode string that is equivalent to
<         the ansi source string.
< 
<     MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
<         written to UnicodeString.  If this causes UnicodeString to be a
<         truncated equivalent of MultiByteString, no error condition results.
< 
<     BytesInUnicodeString - Returns the number of bytes in the returned
<         unicode string pointed to by UnicodeString.
< 
<     MultiByteString - Supplies the ansi source string that is to be
<         converted to unicode.  For single-byte character sets, this address
<         CAN be the same as UnicodeString.
< 
<     BytesInMultiByteString - The number of bytes in the string pointed to
<         by MultiByteString.
< 
< Return Value:
< 
<     SUCCESS - The conversion was successful.
< 
< 
< --*/
< 
< {
<     ULONG LoopCount;
<     ULONG MaxCharsInUnicodeString;
< 
<     MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);
< 
<     LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
<                  MaxCharsInUnicodeString : BytesInMultiByteString;
< 
<     while (LoopCount) {
< 
<         *UnicodeString = (WCHAR)(UCHAR)(*MultiByteString);
< 
<         UnicodeString++;
<         MultiByteString++;
<         LoopCount--;
<     }
< 
<     return DPN_OK;
---
> 	return	hr;
152a194
> //**********************************************************************
154a197
> 
174a218,220
> 	int rval;
> 	BOOL bDefault = FALSE;
> 
182c228,238
< 	UnicodeToMultiByteN( lpStr, cchStr, (PWCH) lpWStr, cchStr*sizeof(WCHAR));
---
> 	// use the default code page (CP_ACP)
> 	// -1 indicates WStr must be null terminated
> 	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,
> 			NULL,&bDefault);
> 
> 	if (bDefault)
> 	{
> 		DPF(3,"!!! WARNING - used default string in WideToAnsi conversion.!!!");
> 		DPF(3,"!!! Possible bad unicode string - (you're not hiding ansi in there are you?) !!! ");
> 		return DPNERR_CONVERSION;
> 	}
188a245,251
> //	WideToAnsi
> //
> //	Convert a WCHAR (Wide) string to a CHAR (ANSI) string
> //
> //	CHAR	*pStr		CHAR string
> //	WCHAR	*pWStr		WCHAR string
> //	int		iStrSize	size (in bytes) of buffer pointed to by lpStr
189a253,295
> #define DPF_MODNAME "STR_AllocAndConvertToANSI"
> /*
>  ** GetAnsiString
>  *
>  *  CALLED BY: Everywhere
>  *
>  *  PARAMETERS: *ppszAnsi - pointer to string
>  *				lpszWide - string to copy
>  *
>  *  DESCRIPTION:	  handy utility function
>  *				allocs space for and converts lpszWide to ansi
>  *
>  *  RETURNS: string length
>  *
>  */
> HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide)
> {
> 	int iStrLen;
> 	BOOL bDefault;
> 	
> 	DNASSERT(ppszAnsi);
> 
> 	if (!lpszWide)
> 	{
> 		*ppszAnsi = NULL;
> 		return S_OK;
> 	}
> 
> 	*ppszAnsi = new char[wcslen(lpszWide)+1];
> 	if (!*ppszAnsi)	
> 	{
> 		DPF(0, "could not get ansi string -- out of memory");
> 		return E_OUTOFMEMORY;
> 	}
> 
> 	iStrLen = WideCharToMultiByte(CP_ACP,0,lpszWide,-1,*ppszAnsi,wcslen(lpszWide)+1,
> 			NULL,&bDefault);
> 
> 	return DPN_OK;
> } // OSAL_AllocAndConvertToANSI
> 
> 
> #undef DPF_MODNAME
208a315,316
> 	int rval;
> 
216c324
< 	MultiByteToUnicodeN( lpWStr, cchWStr*sizeof(WCHAR), (CHAR *) lpStr, cchWStr );
---
> 	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);
219a328
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\strutils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide);
21a23,31
> HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
> 						const DWORD dwWCHARStringLength,
> 						char *const pString,
> 						DWORD *const pdwStringLength );
> 
> HRESULT	STR_AnsiToWide( const char *const pString,
> 						const DWORD dwStringLength,
> 						WCHAR *const pWCHARString,
> 						DWORD *const pdwWCHARStringLength );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\appdesc.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38d37
< #include <wchar.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
87a88
> #include "DVoice.h"
120a122
> #include "Voice.h"
122c124,126
< #include <mmsystem.h>
---
> #include "dpnsdef.h"
> #include "dpnsvrq.h"
> #include "dpnsvlib.h"
185,186c189
< // BUGBUG: [mgere] [xbox] Completely removed this function since Xbox doesn't have multiple adapters.
< /*
---
> 
299d301
< */
380,381c382
< // BUGBUG: [mgere] [xbox] Need to figure out what to do with this.  We can't enumerate adapters.
< /*
---
> 
431c432
< */
---
> 
489c490
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
511c512
< 	pDeviceInfo->lpVtbl->GetURLW(pDeviceInfo,DP8ABuffer,&DP8ASize);
---
> 	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer,&DP8ASize);
630d630
< // BUGBUG: [mgere] [xbox] This shouldn't be needed since we don't have multiple adapters.
1168c1168
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1184c1184
< 	pRemoteAddr->lpVtbl->GetURLW(pRemoteAddr,DP8ABuffer,&DP8ASize);
---
> 	pRemoteAddr->lpVtbl->GetURLA(pRemoteAddr,DP8ABuffer,&DP8ASize);
1187c1187
< 	pDeviceInfo->lpVtbl->GetURLW(pDeviceInfo,DP8ABuffer,&DP8ASize);
---
> 	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer,&DP8ASize);
1787a1788,1800
> 		if (dwMsgId == DN_MSG_INTERNAL_VOICE_SEND)
> 		{
> 			DNASSERT(pdnBufferDesc != NULL);
> 			pSendOpData->BufferDesc[0].pBufferData = pdnBufferDesc->pBufferData;
> 			pSendOpData->BufferDesc[0].dwBufferSize = pdnBufferDesc->dwBufferSize;
> 			pSendOpData->BufferDesc[1].pBufferData = NULL;
> 			pSendOpData->BufferDesc[1].dwBufferSize = 0;
> 			pSendOpData->dwNumBuffers = 1;
> 
> 			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO );
> 		}
> 		else
> 		{
1803a1817
> 		}
2148a2163,2175
> 		if (dwMsgId == DN_MSG_INTERNAL_VOICE_SEND)
> 		{
> 			DNASSERT(pdnBufferDesc != NULL);
> 			pSendOpData->BufferDesc[0].pBufferData = pdnBufferDesc->pBufferData;
> 			pSendOpData->BufferDesc[0].dwBufferSize = pdnBufferDesc->dwBufferSize;
> 			pSendOpData->BufferDesc[1].pBufferData = NULL;
> 			pSendOpData->BufferDesc[1].dwBufferSize = 0;
> 			pSendOpData->dwNumBuffers = 1;
> 
> 			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO );
> 		}
> 		else
> 		{
2164a2192
> 		}
2649a2678,2686
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
125,126c125
< // BUGBUG: [mgere] [xbox] Removed (see cpp file)
< /*
---
> 
132c131
< */
---
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
54a55
> #include "DVoice.h"
84a86,87
> #include "dvoice.h"
> #include "voice.h"
86a90
> #include "dplobby8.h"
132a137
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
246a252,271
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
250c275,276
< 			riid != IID_IUnknown )
---
> 			riid != IID_IUnknown &&
> 			riid != IID_IDirectPlayVoiceTransport )
259a286
> 			riid != IID_IDirectPlayVoiceTransport &&
269c296,297
< 			riid != IID_IUnknown )
---
> 			riid != IID_IUnknown &&
> 			riid != IID_IDirectPlayVoiceTransport )
304a333,334
> 	pdnObject->pIDP8LobbiedApplication = NULL;
> 	pdnObject->dpnhLobbyConnection = NULL;
325a356,358
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
357a391,397
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
714a755,757
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
804a848,853
> 	if( pdnObject->pIDP8LobbiedApplication)
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release( pdnObject->pIDP8LobbiedApplication );
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 	}
> 
970a1020,1024
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(7,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
> 	}
984c1038
< 	{
---
> 	{
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\client.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
64d63
< #include <wchar.h>
102c101
< typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
145a146,147
> #include "DPLobby8.h"
> #include "DVoice.h"
171a174
> #include "DNMisc.h"
178a182
> #include "Voice.h"
180a185,187
> #include "dpnsdef.h"
> #include "dpnsvrq.h"
> #include "dpnsvlib.h"
182,183d188
< #include <mmsystem.h>
< #include <wchar.h>
603a609,617
> 	pdnObject->dpnhLobbyConnection = NULL;
> 
> 	// Release our hold on the lobbiedapplication
> 	if( pdnObject->pIDP8LobbiedApplication) 
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release(pdnObject->pIDP8LobbiedApplication);
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 	}
> 
1129a1144,1147
> 	if (dwFlags & DPNCONNECT_OKTOQUERYFORADDRESSING)
> 	{
> 		dwConnectFlags |= DPNCONNECT_OKTOQUERYFORADDRESSING;
> 	}
1226d1243
< // BUGBUG: [mgere] [xbox] Set breakpoint here and see if it ever gets in here.
1242,1244d1258
< // BUGBUG: [mgere] [xbox] I know this is busted.  Remove this whole section about enumerating adapters
< // and check if it's ok.
< /*
1275d1288
< */
1807a1821,1833
> 	//	Update Lobby status
> 	//
> 	if (fWasConnected)
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_DISCONNECTED);
> 	}
> 
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
> 
> 	//
1982c2008
< 	{
---
> 	{
2367,2368d2392
< // BUGBUG [mgere] [xbox] Temporarily removed until a CoCreateGuid call is implemented
< #ifdef _BUILD_FOR_WIN2000
2374d2397
< #endif
2437a2461,2469
> 	//	Inform DPNSVR of LISTENs
> 	//
> 	if( !(pdnObject->dnApplicationDescription.dwFlags & DPNSESSION_NODPNSVR) )
> 	{
> 		DPF(3,"Registering with DPNSVR");
> 		DNRegisterWithDPNSVR(pdnObject);
> 	}
> 
> 	//
2546a2579,2583
> 	//	Update Lobby status
> 	//
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_CONNECTED);
> 
> 	//
3727c3764
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
3840c3877
< 	pIHost->lpVtbl->GetURLW(pIHost,DP8ABuffer,&DP8ASize);
---
> 	pIHost->lpVtbl->GetURLA(pIHost,DP8ABuffer,&DP8ASize);
3844c3881
< 	pIDevice->lpVtbl->GetURLW(pIDevice,DP8ABuffer,&DP8ASize);
---
> 	pIDevice->lpVtbl->GetURLA(pIDevice,DP8ABuffer,&DP8ASize);
3899c3936
< 	//
---
> 	//
3917d3953
< // BUGBUG: [mgere] [xbox] Set breakpoint here and see if it ever gets in here.
3933,3935d3968
< // BUGBUG: [mgere] [xbox] I know this is busted.  Remove this whole section about enumerating adapters
< // and check if it's ok.
< /*
3967d3999
< */
4548c4580
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
4551c4583,4652
< 	return DPNERR_UNSUPPORTED;
---
> 	DIRECTNETOBJECT		*pdnObject;
> 	HRESULT             hResultCode;
> 
> 	DPF(3,"Parameters: pInterface [0x%p], pIDP8LobbiedApplication [0x%p], dwFlags [0x%lx]",
> 			pInterface,pIDP8LobbiedApplication,dwFlags);
> 
> 	TRY
> 	{
>     	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
>     	DNASSERT(pdnObject != NULL);
> 
>     	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
>     	{
>     	    if( FAILED( hResultCode = DN_ValidateRegisterLobby( pInterface, pIDP8LobbiedApplication, dwFlags ) ) )
>     	    {
>     	        DPFERR( "Error validating register lobby params" );
>     	        DPF_EXIT( hResultCode );
>     	    }
>     	}
> 
>     	// Check to ensure message handler registered
>     	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
>     	{
>     		DPFERR( "Object is not initialized" );
>     		DPF_EXIT(DPNERR_UNINITIALIZED);
>     	}
> 
> 	}
> 	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
> 	{
> 	    DPFERR("Invalid object" );
> 	    DPF_EXIT(DPNERR_INVALIDOBJECT);
> 	}	
> 
> 	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
> 	DNASSERT(pdnObject != NULL);
> 
> 	if (dwFlags == DPNLOBBY_REGISTER)
> 	{
> 		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 		if (pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE)
> 		{
> 			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 			return(DPNERR_ALREADYINITIALIZED);
> 		}
> 				
> 		pIDP8LobbiedApplication->lpVtbl->AddRef(pIDP8LobbiedApplication);
> 
> 		pdnObject->pIDP8LobbiedApplication = pIDP8LobbiedApplication;
> 		pdnObject->dpnhLobbyConnection = dpnhLobbyConnection;
> 		pdnObject->dwFlags |= DN_OBJECT_FLAG_LOBBY_AWARE;
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	}
> 	else
> 	{
> 		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE))
> 		{
> 			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 			return(DPNERR_UNINITIALIZED);
> 		}
> 				
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release(pdnObject->pIDP8LobbiedApplication);
> 		pdnObject->dpnhLobbyConnection = NULL;
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_LOBBY_AWARE);
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	}
> 
> 	return(DPN_OK);
4553a4655,4677
> #undef DPF_MODNAME
> #define DPF_MODNAME "DNNotifyLobbyClientOfSettings"
> // 
> // DNNotifyLobbyClientOfSettings
> //
> // This function sends a connection settings update to the lobby client informing it that the lobby 
> // client settings have changed.  
> //
> HRESULT DNNotifyLobbyClientOfSettings(
> 	DIRECTNETOBJECT * const pdnObject,
> 	IDirectPlay8LobbiedApplication *pdpLobbiedApp, 
> 	DPNHANDLE dpnConnection, 
> 	IDirectPlay8Address *pHostAddress, 
> 	IDirectPlay8Address *pConnectFromAddress )
> {
> 	HRESULT						hResultCode = DPN_OK;
> 	DPL_CONNECTION_SETTINGS		dplConnectionSettings;
> 	BOOL						fIsHost = FALSE;
> 	CPackedBuffer				packBuffer;
> 	PBYTE						pBuffer = NULL;
> 	BOOL						fINCriticalSection = FALSE;
> 	CNameTableEntry				*pNTEntry = NULL;
> 	DWORD						dwIndex;
4554a4679,4824
> 	fIsHost = DN_CHECK_LOCALHOST( pdnObject );
> 
> 	ZeroMemory( &dplConnectionSettings, sizeof( DPL_CONNECTION_SETTINGS ) );
> 	dplConnectionSettings.dwSize = sizeof( DPL_CONNECTION_SETTINGS );
> 	dplConnectionSettings.dwFlags = (fIsHost) ? DPLCONNECTSETTINGS_HOST : 0;
> 
> 	// Lock the object while we make a copy of the app desc.  
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	fINCriticalSection = TRUE;
> 	
> 	packBuffer.Initialize(NULL, 0 );
> 
> 	// Determine the size of buffer
> 	hResultCode = DNPackApplicationDesc( &pdnObject->dnApplicationDescription, &packBuffer );
> 
> 	if( hResultCode != DPNERR_BUFFERTOOSMALL ) 
> 	{
> 		DPF( 0, "Error getting app desc size hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	pBuffer = new BYTE[packBuffer.GetSizeRequired()];
> 
> 	if( !pBuffer )
> 	{
> 		DPF( 0, "Error allocating memory for buffer" );
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	packBuffer.Initialize(pBuffer,packBuffer.GetSizeRequired());
> 
> 	hResultCode = DNPackApplicationDesc( &pdnObject->dnApplicationDescription, &packBuffer );
> 
> 	if( FAILED( hResultCode ) )
> 	{
> 		DPF( 0, "Error packing app desc hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	fINCriticalSection = FALSE;
> 
> 	memcpy( &dplConnectionSettings.dpnAppDesc, pBuffer, sizeof( DPN_APPLICATION_DESC ) );
> 
> 	hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pNTEntry );
> 
> 	if( FAILED( hResultCode ) )
> 	{
> 		DPF( 0, "Error getting local player hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	// Make sure player name isn't changed while we are working with the entry
> 	pNTEntry->Lock();
> 	if( pNTEntry->GetName() )
> 	{
> 		dplConnectionSettings.pwszPlayerName = new WCHAR[wcslen(pNTEntry->GetName())+1];
> 
> 		if( !dplConnectionSettings.pwszPlayerName )
> 		{
> 			pNTEntry->Unlock();
> 			DPF( 0, "Error allocating memory" );
> 			goto NOTIFY_EXIT;
> 		}
> 		
> 		wcscpy( dplConnectionSettings.pwszPlayerName, pNTEntry->GetName() );
> 	}
> 	else
> 	{
> 		dplConnectionSettings.pwszPlayerName = NULL;		
> 	}
> 	pNTEntry->Unlock();
> 
> 	// Release our reference
> 	pNTEntry->Release();
> 
> 	// Host address field
> 	if( fIsHost )
> 	{
> 		dplConnectionSettings.pdp8HostAddress = NULL;
> 
> 		hResultCode = DNGetHostAddressHelper( pdnObject, dplConnectionSettings.ppdp8DeviceAddresses, &dplConnectionSettings.cNumDeviceAddresses );
> 
> 		if( hResultCode != DPNERR_BUFFERTOOSMALL )
> 		{
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			DPF( 0, "Could not get host addresses for lobby update hr=0x%x", hResultCode );
> 			goto NOTIFY_EXIT;
> 		}
> 
> 		dplConnectionSettings.ppdp8DeviceAddresses = new IDirectPlay8Address*[dplConnectionSettings.cNumDeviceAddresses];
> 
> 		if( !dplConnectionSettings.ppdp8DeviceAddresses )
> 		{
> 			DPF( 0, "Error allocating memory" );
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			hResultCode = DPNERR_OUTOFMEMORY;
> 			goto NOTIFY_EXIT;
> 		}
> 
> 		hResultCode = DNGetHostAddressHelper( pdnObject, dplConnectionSettings.ppdp8DeviceAddresses, &dplConnectionSettings.cNumDeviceAddresses );
> 
> 		if( FAILED( hResultCode ) )
> 		{
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			DPF( 0, "Could not get host addresses for lobby update hr=0x%x", hResultCode );
> 			goto NOTIFY_EXIT;
> 		}
> 	}
> 	else
> 	{
> 		dplConnectionSettings.pdp8HostAddress = pHostAddress;
> 		dplConnectionSettings.ppdp8DeviceAddresses = &pConnectFromAddress;
> 		dplConnectionSettings.cNumDeviceAddresses = 1;	
> 	}
> 
> 	// Update the settings
> 	hResultCode = pdpLobbiedApp->lpVtbl->SetConnectionSettings( pdpLobbiedApp, dpnConnection, &dplConnectionSettings, 0 );
> 
> NOTIFY_EXIT:
> 
> 	if( dplConnectionSettings.ppdp8DeviceAddresses && fIsHost )
> 	{
> 		for( dwIndex = 0; dwIndex < dplConnectionSettings.cNumDeviceAddresses; dwIndex++ )
> 		{
> 			dplConnectionSettings.ppdp8DeviceAddresses[dwIndex]->lpVtbl->Release( dplConnectionSettings.ppdp8DeviceAddresses[dwIndex] );
> 		}
> 
> 		delete [] dplConnectionSettings.ppdp8DeviceAddresses;
> 	}
> 
> 	if( dplConnectionSettings.pwszPlayerName )
> 		delete [] dplConnectionSettings.pwszPlayerName;
> 
> 	if( fINCriticalSection ) 
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	if( pBuffer )
> 		delete [] pBuffer;
> 
> 	return hResultCode;
> 
> }
> 
> 
4555a4826,4906
> #define DPF_MODNAME "DNUpdateLobbyStatus"
> 
> HRESULT DNUpdateLobbyStatus(DIRECTNETOBJECT *const pdnObject,
> 							const DWORD dwStatus)
> {
> 	HRESULT		hResultCode;
> 	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
> 	DPNHANDLE dpnhLobbyConnection = NULL;
> 	IDirectPlay8Address *pHostAddress = NULL;
> 	IDirectPlay8Address *pConnectFromAddress = NULL;
> 
> 	DPF(4,"Parameters: dwStatus [0x%lx]",dwStatus);
> 
> 	DNASSERT(pdnObject != NULL);
> 
> 	pIDP8LobbiedApplication = NULL;
> 
> 	//
> 	//	Get lobbied application interface, if it exists and other settings we need
> 	//
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE) && (pdnObject->pIDP8LobbiedApplication))
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->AddRef(pdnObject->pIDP8LobbiedApplication);
> 		pIDP8LobbiedApplication = pdnObject->pIDP8LobbiedApplication;
> 		dpnhLobbyConnection = pdnObject->dpnhLobbyConnection;
> 
> 		pConnectFromAddress = pdnObject->pIDP8ADevice;
> 		pHostAddress = pdnObject->pConnectAddress;
> 
> 		if( pConnectFromAddress )
> 		{
> 			pConnectFromAddress->lpVtbl->AddRef( pConnectFromAddress );			
> 		}
> 
> 		if( pHostAddress )
> 		{
> 			pHostAddress->lpVtbl->AddRef( pHostAddress );
> 		}
> 	}
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	//
> 	//	Update status and release object
> 	//
> 	if (pIDP8LobbiedApplication)
> 	{
> 		// If we are about to do a connection notification
> 		// we send the updated connection settings.  
> 		// 
> 		// This gives lobby client full picture. 
> 		//
> 		if( dwStatus == DPLSESSION_CONNECTED )
> 		{
> 			DNNotifyLobbyClientOfSettings(pdnObject, pIDP8LobbiedApplication, dpnhLobbyConnection, pHostAddress, pConnectFromAddress );
> 		}
> 
> 		pIDP8LobbiedApplication->lpVtbl->UpdateStatus(pIDP8LobbiedApplication,dpnhLobbyConnection,dwStatus,0);
> 
> 		pIDP8LobbiedApplication->lpVtbl->Release(pIDP8LobbiedApplication);
> 		pIDP8LobbiedApplication = NULL;
> 
> 		if( pHostAddress )
> 		{
> 			pHostAddress->lpVtbl->Release( pHostAddress );
> 		}		
> 
> 		if( pConnectFromAddress )
> 		{
> 			pConnectFromAddress->lpVtbl->Release( pConnectFromAddress );
> 		}
> 	}
> 
> 	hResultCode = DPN_OK;
> 
> 	DPF(4,"Returning: [0x%lx]",hResultCode);
> 	return(hResultCode);
> }
> 
> 						
> #undef DPF_MODNAME
4896a5248,5376
> }
> 
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DNRegisterWithDPNSVR"
> 
> HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject)
> {
> 	HRESULT					hResultCode;
> 	HRESULT					hrRegister;
> 	CAsyncOp				*pListenParent;
> 	CAsyncOp				*pListenSP;
> 	CAsyncOp				*pListen;
> 	CBilink					*pBilinkSP;
> 	CBilink					*pBilink;
> 	SPGETADDRESSINFODATA	spInfo;
> #ifdef	DEBUG
> 	CHAR			DP8ABuffer[512];
> 	DWORD			DP8ASize;
> #endif
> 
> 	DPF(4,"Parameters: (none)");
> 
> 	pListenParent = NULL;
> 	pListenSP = NULL;
> 	pListen = NULL;
> 
> 	//
> 	//	Default error returned
> 	//
> 	hrRegister = DPNERR_GENERIC;
> 
> 	//
> 	//	Get LISTEN AsyncOp parent from DirectNet object and add a RefCount
> 	//
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	if (pdnObject->pListen == NULL)
> 	{
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 		goto Exit;
> 	}
> 	pdnObject->pListen->AddRef();
> 	pListenParent = pdnObject->pListen;
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	//
> 	//	Lock the parent so that the child bilink list doesn't change
> 	//
> 	pListenParent->Lock();
> 
> 	//
> 	//	Locate each child (LISTEN SP parent) and then each actual LISTEN
> 	//
> 	pBilinkSP = pListenParent->m_bilinkParent.GetNext();
> 	while (pBilinkSP != &pListenParent->m_bilinkParent)
> 	{
> 		pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);
> 
> 		//
> 		//	Lock the SP parent so that the child bilink doesn't change
> 		//
> 		pListenSP->Lock();
> 
> 		pBilink = pListenSP->m_bilinkParent.GetNext();
> 		while (pBilink != &pListenSP->m_bilinkParent)
> 		{
> 			pListen = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
> 
> 			DNASSERT(pListen->GetProtocolHandle() != NULL);
> 
> 			spInfo.hEndpoint = pListen->GetProtocolHandle();
> 			spInfo.pAddress = NULL;
> 			spInfo.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;
> 
> 			if (DNPGetListenAddressInfo(pListen->GetProtocolHandle(),&spInfo) == DPN_OK)
> 			{
> 				DNASSERT(spInfo.pAddress != NULL);
> #ifdef	DEBUG
> 				DP8ASize = 512;
> 				spInfo.pAddress->lpVtbl->GetURLA(spInfo.pAddress,DP8ABuffer,&DP8ASize);
> 				DPF(4,"Listen address [%s]",DP8ABuffer);
> 
> 				// We re-try the registration to catch the case where DPNSVR is shutting
> 				// down while we are trying to register.  Unlikely but has to be handled.
> 				//
> #endif
> 	            for( DWORD dwRetry = 0; dwRetry < DPNSVR_REGISTER_ATTEMPTS ; dwRetry ++ )
> 		        {
>     				hResultCode = DPNSVR_Register( &pdnObject->dnApplicationDescription, spInfo.pAddress );
> 	    			if( FAILED( hResultCode ) )
> 					{
>     					if( dwRetry < DPNSVR_REGISTER_ATTEMPTS )
>     					{
> 	    					DPF( 0, "Unable to register ourselves with DPNSVR hr=0x%x, retrying", hResultCode );    				
> 	    					Sleep( DPNSVR_REGISTER_SLEEP );    				
> 	    				}
> 						else
>     					{
> 	    					DPF( 0, "Unable to register ourselves with DPNSVR hr=0x%x", hResultCode );
> 	    				}
> 	    			}
> 					else
>     				{
>     					// Return DPN_OK if we succeed even once
>     					hrRegister = hResultCode;
>     					break;
> 	    			}
> 		        }
> 			
> 				spInfo.pAddress->lpVtbl->Release(spInfo.pAddress);
> 				spInfo.pAddress = NULL;
> 
> 			}
> 			pBilink = pBilink->GetNext();
> 		}
> 
> 		pListenSP->Unlock();
> 
> 		pBilinkSP = pBilinkSP->GetNext();
> 	}
> 
> 	pListenParent->Unlock();
> 
> 	pListenParent->Release();
> 	pListenParent = NULL;
> 
> Exit:
> 	DPF(4,"Returning: [0x%lx]",hrRegister);
> 	return( hrRegister );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
198c198,199
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  const DPNHANDLE dpnhLobbyConnection, 
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
200a202,204
> HRESULT DNUpdateLobbyStatus(DIRECTNETOBJECT *const pdnObject,
> 							const DWORD dwStatus);
> 
208a213,214
> 
> HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
74a75
> #include "DPLobby8.h"
102d102
< #include <wchar.h>
106,109d105
< #define CompareGuid(a,b)                                         \
<     (memcmp((PVOID)(a), (PVOID)(b), sizeof(GUID)))
< 
< 
177c173
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
250,251c246,247
< 		if ((hResultCode = pAddress->lpVtbl->BuildFromURLW(	pAddress,
< 															static_cast<WCHAR*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
---
> 		if ((hResultCode = pAddress->lpVtbl->BuildFromURLA(	pAddress,
> 															static_cast<char*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
278c274
< 		pAddress->lpVtbl->GetURLW(pAddress,DP8ABuffer,&DP8ASize);
---
> 		pAddress->lpVtbl->GetURLA(pAddress,DP8ABuffer,&DP8ASize);
798c794
< 	if (pguidInstance && CompareGuid(pguidInstance,&GUID_NULL))
---
> 	if (pguidInstance && !UuidIsNil(pguidInstance,&rpcStatus))
811c807
< 	if (pguidApplication && CompareGuid(pguidApplication,&GUID_NULL))
---
> 	if (pguidApplication && !UuidIsNil(pguidApplication,&rpcStatus))
1137c1133
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
1162,1163c1158
< 				pAddress->lpVtbl->GetURLW(pAddress,NULL,&dwAddressSize);
< 				dwAddressSize = dwAddressSize * sizeof(WCHAR);
---
> 				pAddress->lpVtbl->GetURLA(pAddress,NULL,&dwAddressSize);
1167c1162
< 				pAddress->lpVtbl->GetURLW(pAddress,DP8ABuffer,&DP8ASize);
---
> 				pAddress->lpVtbl->GetURLA(pAddress,DP8ABuffer,&DP8ASize);
1294,1295c1289,1290
< 		if ((hResultCode = pAddress->lpVtbl->GetURLW(pAddress,
< 													static_cast<WCHAR*>(packedBuffer.GetTailAddress()),
---
> 		if ((hResultCode = pAddress->lpVtbl->GetURLA(pAddress,
> 													static_cast<char*>(packedBuffer.GetTailAddress()),
1638a1634,1638
> 	//	Update Lobby status
> 	//
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_CONNECTED);
> 
> 	//
1923a1924,1932
> 	if (fWasConnected)
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_DISCONNECTED);
> 	}
> 	else
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_COULDNOTCONNECT);
> 	}
> 
2768c2777
< 	WCHAR					DP8ABuffer[512];
---
> 	CHAR					DP8ABuffer[512];
2802c2811
< 		(*ppAddress)->lpVtbl->GetURLW(*ppAddress,DP8ABuffer,&DP8ASize);
---
> 		(*ppAddress)->lpVtbl->GetURLA(*ppAddress,DP8ABuffer,&DP8ASize);
2825c2834
< 	WCHAR					DP8ABuffer[512];
---
> 	CHAR					DP8ABuffer[512];
2852c2861
< 		(*ppAddress)->lpVtbl->GetURLW(*ppAddress,DP8ABuffer,&DP8ASize);
---
> 		(*ppAddress)->lpVtbl->GetURLA(*ppAddress,DP8ABuffer,&DP8ASize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectNet"
> 
> /*
29a37,65
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "CORE"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectNet] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNetCore"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dllmain.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "creg.h"
42a44,180
> #undef DPF_MODNAME
> #define DPF_MODNAME "RegisterDefaultSettings"
> //
> // RegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT RegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create app sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		return DPN_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "UnRegisterDefaultSettings"
> //
> // UnRegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT UnRegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot remove app, does not exist" );
> 	}
> 	else
> 	{
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_SP_SUB)[1] ) )
> 		{
> 			DPFERR( "Cannot remove cp sub-key, could have elements" );
> 		}
> 	}
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Client.1", L"DirectPlay8Client Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Client, L"DirectPlay8.Client") )
> 	{
> 		DPFERR( "Could not register dp8 client object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Server.1", L"DirectPlay8Server Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Server, L"DirectPlay8.Server") )
> 	{
> 		DPFERR( "Could not register dp8 Server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Peer.1", L"DirectPlay8Peer Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Peer, L"DirectPlay8.Peer") )
> 	{
> 		DPFERR( "Could not register dp8 client object" );
> 		fFailed = TRUE;
> 	}
> 
> 
> 	if( FAILED( hr = RegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Could not register default settings hr = 0x%x", hr );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Client) )
> 	{
> 		DPF( 0, "Failed to unregister client object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Server) )
> 	{
> 		DPF( 0, "Failed to unregister server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Peer) )
> 	{
> 		DPF( 0, "Failed to unregister peer object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = UnRegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Failed to remove default settings hr=0x%x", hr );
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
98a99,101
> #define DN_REG_LOCAL_SP_ROOT				L"Software\\Microsoft\\DirectPlay8"
> #define DN_REG_LOCAL_SP_SUB					L"\\Service Providers"
> #define DN_REG_LOCAL_SP_SUBKEY				DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB
99a103,107
> #define	DN_REG_KEYNAME_ADAPTER_LIST			L"Adapter List"
> #define	DN_REG_KEYNAME_ALL_APPLICATIONS		L"All Applications"
> #define	DN_REG_KEYNAME_FRIENDLY_NAME		L"Friendly Name"
> #define DN_REG_KEYNAME_GUID					L"GUID"
> 
120a129,130
> typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
157a168,175
> //
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> //
> #define MAX_VOICE_CLIENTS	32	
> 
226a245,249
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 
234a258,264
> 	// Lobby additions
> 	IDirectPlay8Address		*pConnectAddress;		// Connect Address (cached) for clients
> 	DPNHANDLE				dpnhLobbyConnection;	// Lobby Connection to update
> 
> 	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
> 	
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
5a6,8
> 	DllRegisterServer	PRIVATE
> 	DllUnregisterServer	PRIVATE
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnet.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,62
> 
> #endif
> 
> #endif    // !_MAC
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
42a43
> #include "DNMisc.h"
44a46
> #include "CReg.h"
57c59,68
< // BUGBUG: [xbox] [mgere] Removed since we don't support registry
---
> 	DWORD	dwAllAppLen;
> 	WCHAR	lpwszAllAppStr[DN_FLAG_STR_LEN+1];
> 
> 	dwAllAppLen = (DN_FLAG_STR_LEN + 1) * sizeof(WCHAR);
> 	if (RegQueryValueExW(hSPKey,DN_REG_KEYNAME_ALL_APPLICATIONS,NULL,NULL,(PBYTE)lpwszAllAppStr,&dwAllAppLen) != ERROR_SUCCESS)
> 		return(FALSE);
> 
> 	if (towupper(lpwszAllAppStr[0]) == L'N')
> 		return(TRUE);
> 
72,73c83
< // BUGBUG:  [mgere] [xbox] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
75c85,95
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
77,78c97,100
<     WCHAR wszSP[] = L"DirectPlay8 TCP/IP Service Provider";
< 	GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
> //	CServiceProvider	*pSP;
86a109,112
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
> //	pSP = NULL;
> 
90,91c116,121
< 	hResultCode = packedBuffer.AddToBack(wszSP,(wcslen(wszSP)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,TRUE,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
93,94c123,150
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = static_cast<GUID*>(packedBuffer.GetTailAddress());
---
> 	//
> 	//	Set up to enumerate
> 	//
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(5,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
96,97c152,165
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	//
> 	//	Enumerate SP's !
> 	//
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(5,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,TRUE,FALSE))
> 		{
> 			DPF(0,"Couldn't open subentry.  Skipping [%S]", pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
98a167,258
> 		//
> 		//	GUID
> 		//
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPF(0,"SubEntry.ReadGUID failed.  Skipping [%S]", pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		//
> 		//	Attempt to instantiate SP and initialize it, to ensure that it is in fact usable.
> 		//
> 		if (!(dwFlags & DPNENUMSERVICEPROVIDERS_ALL))
> 		{
> 			hResultCode = DN_SPEnsureLoaded(pdnObject,&guid,NULL);
> 			if (hResultCode != DPN_OK)
> 			{
> 				DPF(0,"Could not load SP.  Skipping [%S]", pwszKeyName);
> 				SubEntry.Close();
> 				dwEnumIndex++;
> 				dwKeyLen = dwMaxKeyLen;
> 				hResultCode = DPN_OK; // override return code
> 				continue;
> 			}
> 			else
> 			{
> //				DN_SPRelease(pdnObject,&guid);
> 			}
> 		}
> 
> 		//
> 		//	Friendly Name
> 		//
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(5,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		DPF(5,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = static_cast<GUID*>(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
> 	//
> 	//	Success ?
> 	//
104c264
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
106c266
< 		goto Exit;
---
> 		goto Failure;
110c270,271
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
> 		hResultCode = DPN_OK;
114a276,280
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
> 	DNFree(pwszFriendlyName);
> 	pwszFriendlyName = NULL;
> 
117a284,305
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
131,135d318
< // BUGBUG
< // [mgere] [xbox] Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
157c340
< 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,TRUE,FALSE))
186c369
< 		if (!SubEntry.Open(RegistryEntry,lpwszKeyName,FALSE))
---
> 		if (!SubEntry.Open(RegistryEntry,lpwszKeyName,TRUE,FALSE))
285d467
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\migration.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
73a74,76
> #include "dpnsvrq.h"
> #include "dpnsdef.h"
> #include "dpnsvlib.h"
638a642,661
> 
> 	// Register with DPNSVR
> 	if( !(pdnObject->dnApplicationDescription.dwFlags & DPNSESSION_NODPNSVR) )
> 	{
> 		BOOL	fCoUninitialize = FALSE;
> 
> 		DPF( 7, "Asking for DPNSVR to start listening for us.." );
> 
> 		if (COM_CoInitialize(NULL) == S_OK)
> 		{
> 			fCoUninitialize = TRUE;
> 		}
> 
> 		DNRegisterWithDPNSVR(pdnObject);
> 
> 		if (fCoUninitialize)
> 		{
> 			COM_CoUninitialize();
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\msghandler.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
39a40,41
> #include "DPAddr.h"
> #include "DVoice.h"
60a63
> #include "Voice.h"
509c512,516
<                     // BUGBUG: [mgere] [xbox] Used to be Voice_Receive() but voice not supported on Xbox
---
> 			hResultCode = Voice_Receive(pdnObject,
> 										pConnection->GetDPNID(),
> 										0,
> 										pvData,
> 										dwDataSize);
1035c1042
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1051c1058
< 	pHostAddress->lpVtbl->GetURLW(pHostAddress,DP8ABuffer,&DP8ASize);
---
> 	pHostAddress->lpVtbl->GetURLA(pHostAddress,DP8ABuffer,&DP8ASize);
1055c1062
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
1086c1093
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1102c1109
< 	pHostAddress->lpVtbl->GetURLW(pHostAddress,DP8ABuffer,&DP8ASize);
---
> 	pHostAddress->lpVtbl->GetURLA(pHostAddress,DP8ABuffer,&DP8ASize);
1106c1113
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
1135c1142
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1151c1158
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\ntentry.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
366,367c366
< 		hResultCode = m_pAddress->lpVtbl->GetURLW(m_pAddress,NULL,&dwURLSize);
< 		dwURLSize = dwURLSize * sizeof(WCHAR);
---
> 		hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,NULL,&dwURLSize);
379,380c378,379
< 				if ((hResultCode = m_pAddress->lpVtbl->GetURLW(m_pAddress,
< 						static_cast<WCHAR*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
---
> 				if ((hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,
> 						static_cast<char*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
467c466
< 		hResultCode = pAddress->lpVtbl->BuildFromURLW(pAddress,reinterpret_cast<WCHAR*>(pBufferStart + pdnEntryInfo->dwURLOffset));
---
> 		hResultCode = pAddress->lpVtbl->BuildFromURLA(pAddress,reinterpret_cast<char*>(pBufferStart + pdnEntryInfo->dwURLOffset));
569d567
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
36a37
> #include "DVoice.h"
59a61
> #include "voice.h"
62a65
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
179c182
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
187a191,197
>     if( pIDP8LobbiedApplication == NULL ||
>         !DNVALID_READPTR( pIDP8LobbiedApplication, sizeof( IDirectPlay8LobbiedApplication * ) ) )
>     {
>         DPFERR( "Invalid interface pointer specified for register lobby" );
>         return DPNERR_INVALIDPOINTER;
>     }
> 
942c952
<     if( dwFlags & ~(DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
---
>     if( dwFlags & ~(DPNENUMHOSTS_OKTOQUERYFORADDRESSING | DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
1661c1671
<     if( dwFlags & ~(DPNCONNECT_SYNC) )
---
>     if( dwFlags & ~(DPNCONNECT_SYNC | DPNCONNECT_OKTOQUERYFORADDRESSING) )
1977c1987
<     if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD) )
---
>     if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD | DPNSESSION_NODPNSVR) )
2226a2237
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
41c41
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\peer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
68d67
< #include <wchar.h>
119c118
< typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\server.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61d60
< #include <wchar.h>
110c109
< typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2,3c17,27
< TARGETPATHLIB=$(BASEDIR)\public\sdk\lib
< TARGETTYPE=DYNLINK
---
> DLLDEF=..\dnet.def
> UMTYPE=windows
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
4a29
> TARGETTYPE=DYNLINK
6,14c31,35
< !ifdef _BUILD_FOR_WIN2000
< UMTYPE=windows
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
16c37
< INCLUDES=..\;..\..\inc;..\..\protocol;..\..\common
---
> PASS1_PUBLISH={ $(O)\dpnet.lib = $(SDK_LIB_PATH)\dpnet.lib}
18c39,56
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
> 	   ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
>            ..\..\protocol\obj$(BUILD_ALT_DIR)\*\protocol.lib \
>            ..\..\dpnsvr\dpnsvlib\obj$(BUILD_ALT_DIR)\*\dpnsvlib.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
20d57
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
22,23c59,60
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
26c63,67
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28c69
< DLLDEF=..\dnet.def
---
> INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\protocol;..\..\common;..\..\dpnsvr\dpnsvlib;..\..\dpnsvr\inc
29a71,78
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
61a111
>          ..\voice.cpp \
68a119,126
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
71,92c129,131
< TARGETLIBS= \
< 	   ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
<            ..\..\protocol\obj$(BUILD_ALT_DIR)\*\protocol.lib \
<            $(BASEDIR)\public\sdk\lib\*\dpnaddr.lib \
<            ..\..\sp\wsock\daytona\obj$(BUILD_ALT_DIR)\*\dpnwsock.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<              $(SDK_LIB_PATH)\libcntpr.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38a39
> #include "DVoice.h"
48a50
> #include "voice.h"
165a168,169
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
199a204,205
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
232a239,240
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
267a276,277
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
302a313,314
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
338a351,352
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
606a621,622
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\worker.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
44a45
> #include "DVoice.h"
65a67
> #include "Voice.h"
586c588,592
<                     // BUGBUG: [mgere] [xbox] Removed Voice_Receive()
---
> 			hResultCode = Voice_Receive(pdnObject,
> 										pConnection->GetDPNID(),
> 										0,
> 										pvData,
> 										dwDataSize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addbase.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
260d259
< /* BUGBUG: [mgere] [xbox] Removed this function.
291d289
< */  return DPNERR_UNSUPPORTED;
302,303c300,359
< // BUGBUG: [mgere] [xbox] ANSI not supported
< 	return DPNERR_UNSUPPORTED;
---
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pszAddress == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer to address.  An address must be specified" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( !DNVALID_STRING_A( pszAddress ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid string specified for address" );
> 		DP8A_RETURN( DPNERR_INVALIDSTRING );
> 	}
> 
> 	DPF( DP8A_PARAMLEVEL, "pszAddress = %s", pszAddress );
> 
> 	WCHAR *szShadowBuffer = NULL;
> 
> 	DWORD dwStrSize = 0;
> 
> 	if( pszAddress != NULL )
> 	{
> 		dwStrSize = strlen(pszAddress)+1;
> 		
> 		szShadowBuffer = new WCHAR[dwStrSize];
> 
> 		if( szShadowBuffer == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto BUILDFROMURLW_RETURN;
> 		}
> 
> 		if( FAILED( hr = STR_jkAnsiToWide( szShadowBuffer, pszAddress, dwStrSize ) )  )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting URL to ANSI hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 			goto BUILDFROMURLW_RETURN;
> 		}
> 	}
> 
> 	hr = pdp8Address->SetURL( szShadowBuffer );
> 
> BUILDFROMURLW_RETURN:
> 
> 	if( szShadowBuffer )
> 		delete [] szShadowBuffer;
> 
> 	DP8A_RETURN( hr );	
446,447c502,568
< // BUGBUG: [mgere] [xbox] ANSI not supported.
< 	return DPNERR_UNSUPPORTED;
---
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pdwAddressSize == NULL ||
> 	   !DNVALID_WRITEPTR( pdwAddressSize, sizeof(DWORD) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for address size" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
> 	}
> 
> 	if( *pdwAddressSize > 0 &&
> 	   (pszAddress == NULL ||
> 	    !DNVALID_WRITEPTR( pszAddress, (*pdwAddressSize) ) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for address" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	DPF( DP8A_PARAMLEVEL, "pwszAddress = 0x%x pdwAddressSize = 0x%x (%u)",
> 	     pszAddress , pdwAddressSize, *pdwAddressSize );
> 
> 	WCHAR *szShadowBuffer = NULL;
> 
> 	if( *pdwAddressSize  != 0 )
> 	{
> 		szShadowBuffer = new WCHAR[*pdwAddressSize];
> 
> 		if( szShadowBuffer == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto GETURLW_RETURN;
> 		}
> 	}
> 	else
> 	{	
> 		szShadowBuffer= NULL;
> 	}
> 
> 	hr = pdp8Address->BuildURL( szShadowBuffer, pdwAddressSize );
> 
> 	if( hr == DPN_OK )
> 	{
> 		if( FAILED( hr = STR_jkWideToAnsi( pszAddress, szShadowBuffer, *pdwAddressSize ) ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting ANSI->WIDE hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 			goto GETURLW_RETURN;
> 		}
> 	}
> 	
> GETURLW_RETURN:
> 
> 	if( szShadowBuffer != NULL )
> 		delete [] szShadowBuffer;
> 
> 	DP8A_RETURN( hr );
862c983,984
< 	   dwDataType != DPNA_DATATYPE_BINARY )
---
> 	   dwDataType != DPNA_DATATYPE_BINARY &&
> 	   dwDataType != DPNA_DATATYPE_STRING_ANSI )
876a999,1012
> 		{
> 			DPF( DP8A_ERRORLEVEL, "String size and component size don't match" );
> 			DP8A_RETURN( DPNERR_INVALIDPARAM );
> 		}
> 	}
> 	else if( dwDataType == DPNA_DATATYPE_STRING_ANSI )
> 	{
> 		if( !DNVALID_STRING_A( (const CHAR * const) pComponentData ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Invalid string component specified" );
> 			DP8A_RETURN( DPNERR_INVALIDSTRING );
> 		}
> 
> 		if( ((strlen( (const CHAR * const) pComponentData)+1)*sizeof(char)) != dwComponentSize )
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
47a48
> #include <stdio.h>
48a50
> #include "dplegacy.h"
50d51
< #include <wchar.h>
398a400,418
> 	case DPNA_DATATYPE_STRING_ANSI:
>         wszUnicodeString = new WCHAR[dwRealDataSize];
>         if( wszUnicodeString == NULL )
>         {
>             DPF( 0, "Error allocating memory for conversion" );
>             return DPNERR_OUTOFMEMORY;
>         }
> 
> 		hr = STR_jkAnsiToWide( wszUnicodeString, (const char * const) pvData, dwRealDataSize );
> 
> 		if( FAILED( hr ) )
> 		{
> 		    DPF( 0, "Error unable to convert element ANSI->Unicode 0x%x", hr );
>             return DPNERR_CONVERSION;
> 		}
> 		pvRealData = wszUnicodeString;
> 	    dwRealDataSize = dwDataSize*sizeof(WCHAR);
> 		dwRealDataType = DPNA_DATATYPE_STRING;
> 	    break;
422a443,454
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     hr= SetSP( &CLSID_DP8SP_IPX );
>                 }
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_MODEMPROVIDER ) == 0 )
>                 {
>                     hr = SetSP( &CLSID_DP8SP_MODEM );
>                 }
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_SERIALPROVIDER ) == 0 )
>                 {
>                     hr = SetSP( &CLSID_DP8SP_SERIAL );
>                 }
1369a1402,1470
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ADDRESSOBJECT::SetDirectPlay4Address"
> HRESULT DP8ADDRESSOBJECT::SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize )
> {
>     PBYTE pbCurrentLocation;
>     PDPADDRESS pdpAddressChunk;
>     LONG lRemaining;
>     HRESULT hr = DPN_OK;
>     DWORD dwCurrentChunkSize;
>     DWORD dwNumElementsParsed = 0;
> 
> 	if( IsLocked() )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
> 		return DPNERR_NOTALLOWED;
> 	}
> 
>     // XBOX! This function will not be required on XBOX.  Have it return DPNERR_NOTSUPPORTED
>     ENTERLOCK();
> 
>     hr = Clear();
> 
>     if( FAILED( hr ) )
>     {
>         DPF( 0, "Failed to clear old address data hr=[0x%lx]", hr );
>         LEAVELOCK();
>         return hr;
>     }
> 
>     pbCurrentLocation = (PBYTE) pvDataBuffer;
>     lRemaining = dwDataSize;
> 
>     while( lRemaining > 0 )
>     {
>         pdpAddressChunk = (PDPADDRESS) pbCurrentLocation;
> 
>         if( sizeof( DPADDRESS ) > lRemaining )
>         {
>             DPF( 0, "Error parsing address, unexpected end of address" );
> 			LEAVELOCK();
>             return DPNERR_INVALIDADDRESSFORMAT;
>         }
> 
>         dwCurrentChunkSize = sizeof( DPADDRESS ) + pdpAddressChunk->dwDataSize;
> 
>         if( ((LONG) dwCurrentChunkSize) > lRemaining )
>         {
>             DPF( 0, "Error parsing address, unexpected end during data" );
> 			LEAVELOCK();
>             return DPNERR_INVALIDADDRESSFORMAT;
>         }
> 
>         hr = AddDP4Element( pdpAddressChunk, this );
> 
>         if( FAILED( hr ) )
>         {
>             DPF( 0, "Error adding next element" );
>             break;
>         }
> 
>         lRemaining -= dwCurrentChunkSize;
> 
>         pbCurrentLocation += dwCurrentChunkSize;
>     }
> 
>     LEAVELOCK();
> 
>     return hr;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
140a141,142
>     HRESULT SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addparse.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
27c27
< #include <wchar.h>
---
> #include <stdio.h>
569d568
< // BUGBUG: [mgere] [xbox] Removed wtol temporarily until it is implemented on xbox
571d569
< #ifdef _BUILD_FOR_WIN2000
573d570
< #endif
581,582d577
< // BUGBUG: [mgere] [xbox] Removed swscanf temporarily until it is implemented on xbox
< #ifdef _BUILD_FOR_WIN2000
607d601
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addtcp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
730a731,841
> #if 0
> // Use these functions to build ANSI versions of above
> typedef	STDMETHODIMP DP8ATCP_GetComponentByNameA( IDirectPlay8AddressIP *pInterface, const CHAR * const pszTag, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType );
> typedef	STDMETHODIMP DP8ATCP_GetComponentByIndexA( IDirectPlay8AddressIP *pInterface, const DWORD dwComponentID, CHAR * pszTag, PDWORD pdwNameLen, void * pComponentBuffer, PDWORD pdwComponentSize, PDWORD pdwDataType );
> typedef	STDMETHODIMP DP8ATCP_AddComponentA( IDirectPlay8AddressIP *pInterface, const CHAR * const pszTag, const void * const pComponentData, const DWORD dwComponentSize, const DWORD dwDataType );
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ATCP_BuildAddressW"
> STDMETHODIMP DP8ATCP_BuildAddressW( IDirectPlay8AddressIP *pInterface, const WCHAR * const pwszAddress, const USHORT usPort )
> {
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 	
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );
> 
> 	LPSTR pszShadowAddress = NULL;
> 
> 	if( pwszAddress != NULL )
> 	{
> 		pszShadowAddress = new char[wcslen(pwszAddress)+1];
> 
> 		if( pszShadowAddress == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Out of memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto BUILDADDRESSW_EXIT;
> 		}
> 
> 		hr = WideToAnsi( pszShadowAddress, pwszAddress, wcslen(pwszAddress)+1 );
> 
> 		if( FAILED( hr ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting Address to ANSI hr=0x%x", hr );
> 			hr = DPNERR_GENERIC;
> 			goto BUILDADDRESSW_EXIT;
> 		}
> 	}
> 
> 	hr = DP8ATCP_BuildAddressA( pInterface, pszShadowAddress, usPort );
> 
> BUILDADDRESSW_EXIT:
> 
> 	if( pszShadowAddress != NULL )
> 		delete [] pszShadowAddress;
> 
> 	return hr;
> 	
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ATCP_GetAddressW"
> STDMETHODIMP DP8ATCP_GetAddressW( IDirectPlay8AddressIP *pInterface, WCHAR * pwszAddress, PDWORD pdwAddressLength, PUSHORT pusPort )
> {
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 	
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );
> 
> 	LPSTR pszShadowAddress = NULL;
> 	DWORD dwShadowAddressSize = 0;
> 
> 	if( pwszAddress != NULL && pdwAddressLength != NULL )
> 	{
> 		pszShadowAddress = new char[*pdwAddressLength];
> 
> 		if( pszShadowAddress == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Out of memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto GETADDRESSW_EXIT;
> 		}
> 	}
> 
> 	hr = DP8ATCP_GetAddressA( pInterface, pszShadowAddress, pdwAddressLength, pusPort );
> 
> 	if( hr == DPN_OK )
> 	{
> 		hr = AnsiToWide( pwszAddress, pszShadowAddress, *pdwAddressLength );
> 
> 		if( FAILED( hr ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Unable to convert name to Wide hr=0x%x", hr );
> 			goto GETADDRESSW_EXIT;
> 		}
> 	}
> 
> GETADDRESSW_EXIT:
> 
> 	if( pszShadowAddress != NULL )
> 		delete [] pszShadowAddress;
> 
> 	return hr;
> }
> 
> #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
34c34
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
24a25,31
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DPNAddress"
> 
> /*
31a39,67
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNAddress"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNAddress"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dllmain.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
29a30
> #include "creg.h"
38a40,87
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8Address.Address.1", L"DirectPlay8Address Object", 
> 							  L"dpnaddr.dll", CLSID_DirectPlay8Address, L"DirectPlay8Address.Address") )
> 	{
> 		DPFERR( "Could not register address object" );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Address) )
> 	{
> 		DPF( 0, "Failed to unregister server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
5a6,8
> 	DirectPlay8AddressCreate	@1
> 	DllRegisterServer	PRIVATE
> 	DllUnregisterServer PRIVATE
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnaddr.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address \0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,61
> 
> #endif
> 
> #endif    // !_MAC
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2,3c17,27
< TARGETPATHLIB=$(BASEDIR)\public\sdk\lib
< TARGETTYPE=DYNLINK
---
> DLLDEF=..\dnadd.def
> UMTYPE=windows
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
4a29
> TARGETTYPE=DYNLINK
6,14c31,35
< !ifdef _BUILD_FOR_WIN2000
< UMTYPE=windows
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
16c37
< INCLUDES=..\;..\..\inc;..\..\common
---
> PASS1_PUBLISH={ $(O)\dpnaddr.lib = $(SDK_LIB_PATH)\dpnaddr.lib}
18c39,54
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
>            ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\wsock32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
20d55
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
22,23c57,58
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
26c61,65
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28c67
< DLLDEF=..\dnadd.def
---
> INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\common
29a69,76
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
38a86
>          ..\dplegacy.cpp \
40a89,95
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
> 
> USER_C_FLAGS=-nologo -W3
43,62c98,100
< TARGETLIBS= \
<            ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\winsockx.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
63a64,75
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
> // {826F86D1-AE2C-4428-A66F-974381B25F5B}
> DEFINE_GUID(IID_IDirectPlay8AddressModem,
> 0x826f86d1, 0xae2c, 0x4428, 0xa6, 0x6f, 0x97, 0x43, 0x81, 0xb2, 0x5f, 0x5b);
> 
> // {59BE79FE-A96A-4710-9BD2-22A50E7B24BD}
> DEFINE_GUID(IID_IDirectPlay8AddressSerial,
> 0x59be79fe, 0xa96a, 0x4710, 0x9b, 0xd2, 0x22, 0xa5, 0xe, 0x7b, 0x24, 0xbd);
> 
71a84,86
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
> typedef struct IDirectPlay8AddressSerial  	*PDIRECTPLAY8ADDRESSSERIAL, *LPDIRECTPLAY8ADDRESSSERIAL;
> typedef struct IDirectPlay8AddressModem		*PDIRECTPLAY8ADDRESSMODEM, *LPDIRECTPLAY8ADDRESSMODEM;
87a103
> #define DPNA_DATATYPE_STRING_ANSI           0x00000005
348a365,417
> // values for baud rate
> #define DPNA_BAUD_RATE_110					110
> #define DPNA_BAUD_RATE_300					300
> #define DPNA_BAUD_RATE_600					600
> #define DPNA_BAUD_RATE_1200					1200
> #define DPNA_BAUD_RATE_2400					2400
> #define DPNA_BAUD_RATE_4800					4800
> #define DPNA_BAUD_RATE_9600					9600
> #define DPNA_BAUD_RATE_14400				14400
> #define DPNA_BAUD_RATE_19200				19200
> #define DPNA_BAUD_RATE_38400				38400
> #define DPNA_BAUD_RATE_56000				56000
> #define DPNA_BAUD_RATE_57600				57600
> #define DPNA_BAUD_RATE_115200				115200
> #define DPNA_BAUD_RATE_128000				128000
> #define DPNA_BAUD_RATE_256000				256000
> 
> //// values for baud rate
> //#define DPNA_BAUD_RATE_110					L"110"
> //#define DPNA_BAUD_RATE_300					L"300"
> //#define DPNA_BAUD_RATE_600					L"600"
> //#define DPNA_BAUD_RATE_1200					L"1200"
> //#define DPNA_BAUD_RATE_2400					L"2400"
> //#define DPNA_BAUD_RATE_4800					L"4800"
> //#define DPNA_BAUD_RATE_9600					L"9600"
> //#define DPNA_BAUD_RATE_14400				L"14400"
> //#define DPNA_BAUD_RATE_19200				L"19200"
> //#define DPNA_BAUD_RATE_38400				L"38400"
> //#define DPNA_BAUD_RATE_56000				L"56000"
> //#define DPNA_BAUD_RATE_57600				L"57600"
> //#define DPNA_BAUD_RATE_115200				L"115200"
> //#define DPNA_BAUD_RATE_128000				L"128000"
> //#define DPNA_BAUD_RATE_256000				L"256000"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE					L"1"
> #define DPNA_STOP_BITS_ONE_FIVE				L"1.5"
> #define DPNA_STOP_BITS_TWO					L"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE					L"NONE"
> #define DPNA_PARITY_EVEN					L"EVEN"
> #define DPNA_PARITY_ODD						L"ODD"
> #define DPNA_PARITY_MARK					L"MARK"
> #define DPNA_PARITY_SPACE					L"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE				L"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF			L"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS				L"RTS"
> #define DPNA_FLOW_CONTROL_DTR				L"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR			L"RTSDTR"
> 
350a420,422
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
352a425,487
> //// ANSI DEFINITIONS
> 
> // Header
> #define DPNA_HEADER_A						"x-directplay:/"
> #define DPNA_SEPARATOR_KEYVALUE_A			'='
> #define DPNA_SEPARATOR_USERDATA_A			'#'
> #define DPNA_SEPARATOR_COMPONENT_A			';'
> #define DPNA_ESCAPECHAR_A					'%'
> 
> // key names for address components
> #define DPNA_KEY_APPLICATION_INSTANCE_A		"applicationinstance"
> #define DPNA_KEY_BAUD_A						"baud"
> #define DPNA_KEY_DEVICE_A					"device"
> #define DPNA_KEY_FLOWCONTROL_A				"flowcontrol"
> #define DPNA_KEY_HOSTNAME_A					"hostname"
> #define DPNA_KEY_PARITY_A					"parity"
> #define DPNA_KEY_PHONENUMBER_A				"phonenumber"
> #define DPNA_KEY_PORT_A						"port"
> #define DPNA_KEY_PROGRAM_A					"program"
> #define DPNA_KEY_PROVIDER_A					"provider"
> #define DPNA_KEY_STOPBITS_A					"stopbits"
> 
> //// values for baud rate
> //#define DPNA_BAUD_RATE_110_A				"110"
> //#define DPNA_BAUD_RATE_300_A				"300"
> //#define DPNA_BAUD_RATE_600_A				"600"
> //#define DPNA_BAUD_RATE_1200_A				"1200"
> //#define DPNA_BAUD_RATE_2400_A				"2400"
> //#define DPNA_BAUD_RATE_4800_A				"4800"
> //#define DPNA_BAUD_RATE_9600_A				"9600"
> //#define DPNA_BAUD_RATE_14400_A				"14400"
> //#define DPNA_BAUD_RATE_19200_A				"19200"
> //#define DPNA_BAUD_RATE_38400_A				"38400"
> //#define DPNA_BAUD_RATE_56000_A				"56000"
> //#define DPNA_BAUD_RATE_57600_A				"57600"
> //#define DPNA_BAUD_RATE_115200_A				"115200"
> //#define DPNA_BAUD_RATE_128000_A				"128000"
> //#define DPNA_BAUD_RATE_256000_A				"256000"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE_A				"1"
> #define DPNA_STOP_BITS_ONE_FIVE_A			"1.5"
> #define DPNA_STOP_BITS_TWO_A				"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE_A					"NONE"
> #define DPNA_PARITY_EVEN_A					"EVEN"
> #define DPNA_PARITY_ODD_A					"ODD"
> #define DPNA_PARITY_MARK_A					"MARK"
> #define DPNA_PARITY_SPACE_A					"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE_A			"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF_A 		"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS_A				"RTS"
> #define DPNA_FLOW_CONTROL_DTR_A				"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR_A			"RTSDTR"
> 
> // Shortcut values
> #define DPNA_VALUE_TCPIPPROVIDER_A          "IP"
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
> #define DPNA_VALUE_MODEMPROVIDER_A          "MODEM"
> #define DPNA_VALUE_SERIALPROVIDER_A         "SERIAL"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
111,112d110
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
153a152,160
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {6D4A3650-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_MODEM, 0x6d4a3650, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {743B5D60-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_SERIAL, 0x743b5d60, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
177a185,187
> typedef struct IDirectPlay8LobbiedApplication	*PDNLOBBIEDAPPLICATION;
> typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
> 
665a676
> #define	DPNCONNECT_OKTOQUERYFORADDRESSING	0x0001
670a682
> #define	DPNENUMHOSTS_OKTOQUERYFORADDRESSING	0x0001
779a792
> #define DPNSESSION_NODPNSVR					0x0040
860c873
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
905c918
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
955c968
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpsp8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
56a57
> #define DPNSPF_OKTOQUERY			0x00000002		// OK for SP to ask the user for clarification on addresses
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
105c105
< 	DNASSERT( ulFlags == 0 );
---
> 	DNASSERT( ( ulFlags & ~( DPNCONNECT_OKTOQUERYFORADDRESSING ) ) == 0 );
106a107,111
> 	if ( ( ulFlags & DPNCONNECT_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		ConnData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\enum.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
117a118,122
> 	if ( ( dwFlags & DPNENUMHOSTS_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		EnumData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\initialize.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
351c351
< 		if((pSPD->hSendEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL){
---
> 		if((pSPD->hSendEvent = CreateEventA(NULL, FALSE, FALSE, NULL)) == NULL){
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2c17,26
< TARGETTYPE=LIBRARY
---
> 
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
3a28
> TARGETTYPE=LIBRARY
5,9d29
< !ifdef _BUILD_FOR_WIN2000
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< LINKER_FLAGS=-align:32
< !endif
11c31,35
< INCLUDES=..\common;..\inc;..\dnaddress
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
13c37,41
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE -DMICHAEL
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS)
15d42
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
17,18c44,55
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> 
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
> 
> INCLUDES=$(DXROOT)\inc;..\common;..\inc;..\dnaddress
> 
> 
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
21c58,63
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
34c76,78
< USE_NOLIBS=1
---
> #
> # Next specify options for the compiler.
> #
36c80,86
< TARGETLIBS=
---
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE /DMICHAEL
> MSC_OPTIMIZATION=/Odi /Zi
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\timer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
575c575
< 	hWorkToDoSem=CreateSemaphore(NULL,0,65535,NULL);
---
> 	hWorkToDoSem=CreateSemaphoreA(NULL,0,65535,NULL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
198,199c198,228
< // BUGBUG: [mgere] [xbox]  Removed all code in here.  I don't believe it's necessary anymore and it was using some COM functions that we don't have.
< 	return S_OK;
---
>     HRESULT		hr;
>     HINSTANCE	hdll;
>     LPGPCLASSFACTORY	pcf;
> 
> 
>     pcf = (LPGPCLASSFACTORY) This;
> 
>     /*
>      * call CoLockObjectExternal
>      */
>     hr = E_UNEXPECTED;
>     hdll = LoadLibraryA( "OLE32.DLL" );
>     if( hdll != NULL )
>     {
>         PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;
> 
> 
> 		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, "CoLockObjectExternal" ) );
>         if( lpCoLockObjectExternal != NULL )
>         {
>             hr = lpCoLockObjectExternal( (LPUNKNOWN) This, fLock, TRUE );
>         }
>         else
>         {
>         }
>     }
>     else
>     {
>     }
> 
> 	return hr;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
30a38,66
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNSPWinsock"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectDPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNSPWinsock"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
120a122,141
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( dwDebugLevel, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
> 					);
> 			break;
> 		}
> 
144,145d164
< // BUGBUG: [mgere] [xbox] Must convert this to unicode
< /*
193d211
< */
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> #include "resource.h"
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #include "windows.h"
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnwsock.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,153
> 
> #endif
> 
> #endif    // !_MAC
> 
> 
> 
> #ifdef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // TEXTINCLUDE
> //
> 
> 1 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "resource.h\0"
> END
> 
> 2 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "#include ""afxres.h""\r\n"
>     "\0"
> END
> 
> 3 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "\r\n"
>     "\0"
> END
> 
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // Dialog
> //
> 
> IDD_IP_SETTINGS DIALOG DISCARDABLE  0, 0, 194, 66
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION | 
>     WS_SYSMENU
> CAPTION "Enter host name"
> FONT 8, "MS Shell Dlg"
> BEGIN
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
> END
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // DESIGNINFO
> //
> 
> #ifdef APSTUDIO_INVOKED
> GUIDELINES DESIGNINFO DISCARDABLE 
> BEGIN
>     IDD_IP_SETTINGS, DIALOG
>     BEGIN
>         LEFTMARGIN, 7
>         RIGHTMARGIN, 187
>         TOPMARGIN, 7
>         BOTTOMMARGIN, 59
>     END
> END
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // String Table
> //
> 
> STRINGTABLE DISCARDABLE 
> BEGIN
>     IDS_FRIENDLYNAME_IPX    "DirectPlay8 IPX Service Provider"
>     IDS_FRIENDLYNAME_TCPIP  "DirectPlay8 TCP/IP Service Provider"
> END
> 
> #endif    // English (U.S.) resources
> /////////////////////////////////////////////////////////////////////////////
> 
> 
> 
> #ifndef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 3 resource.
> //
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> #endif    // not APSTUDIO_INVOKED
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock1.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,42c1,67
< #define p_accept accept
< #define p_bind bind
< #define p_closesocket closesocket
< #define p_connect connect
< #define p_gethostbyaddr gethostbyaddr
< #define p_gethostbyname gethostbyname
< #define p_gethostname gethostname
< #define p_getpeername getpeername
< #define p_getprotobyname getprotobyname
< #define p_getprotobynumber getprotobynumber
< #define p_getservbyname getservbyname
< #define p_getservbyport getservbyport
< #define p_getsockname getsockname
< #define p_getsockopt getsockopt
< #define p_htonl htonl
< #define p_htons htons
< #define p_inet_addr inet_addr
< #define p_inet_ntoa inet_ntoa
< #define p_ioctlsocket ioctlsocket
< #define p_listen listen
< #define p_ntohl ntohl
< #define p_ntohs ntohs
< #define p_recv recv
< #define p_recvfrom recvfrom
< #define p_select select
< #define p_send send
< #define p_sendto sendto
< #define p_setsockopt setsockopt
< #define p_shutdown shutdown
< #define p_socket socket
< //#define p_WSAAsyncGetHostByAddr WSAAsyncGetHostByAddr
< //#define p_WSAAsyncGetHostByName WSAAsyncGetHostByName
< //#define p_WSAAsyncGetProtoByName WSAAsyncGetProtoByName
< //#define p_WSAAsyncGetProtoByNumber WSAAsyncGetProtoByNumber
< //#define p_WSAAsyncGetServByName WSAAsyncGetServByName
< //#define p_WSAAsyncGetServByPort WSAAsyncGetServByPort
< //#define p_WSAAsyncSelect WSAAsyncSelect
< //#define p_WSACancelAsyncRequest WSACancelAsyncRequest
< #define p_WSACleanup WSACleanup
< #define p_WSAGetLastError WSAGetLastError
< #define p_WSASetLastError WSASetLastError
< #define p_WSAStartup WSAStartup
---
> //
> // DWNSOCK1.INC	Macros for dynamically linking to WinSock 1.1
> //
> 
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	//
> 	// Function available in both versions
> 	//
> 	DYNAMICWINSOCK(accept, LPFN_ACCEPT);
> 	DYNAMICWINSOCK(bind, LPFN_BIND);
> 	DYNAMICWINSOCK(closesocket, LPFN_CLOSESOCKET);
> 	DYNAMICWINSOCK(connect, LPFN_CONNECT);
> 	DYNAMICWINSOCK(gethostbyaddr, LPFN_GETHOSTBYADDR);
> 	DYNAMICWINSOCK(gethostbyname, LPFN_GETHOSTBYNAME);
> 	DYNAMICWINSOCK(gethostname, LPFN_GETHOSTNAME);
> 	DYNAMICWINSOCK(getpeername, LPFN_GETPEERNAME);
> 	DYNAMICWINSOCK(getprotobyname, LPFN_GETPROTOBYNAME);
> 	DYNAMICWINSOCK(getprotobynumber, LPFN_GETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(getservbyname, LPFN_GETSERVBYNAME);
> 	DYNAMICWINSOCK(getservbyport, LPFN_GETSERVBYPORT);
> 	DYNAMICWINSOCK(getsockname, LPFN_GETSOCKNAME);
> 	DYNAMICWINSOCK(getsockopt, LPFN_GETSOCKOPT);
> 	DYNAMICWINSOCK(htonl, LPFN_HTONL);
> 	DYNAMICWINSOCK(htons, LPFN_HTONS);
> 	DYNAMICWINSOCK(inet_addr, LPFN_INET_ADDR);
> 	DYNAMICWINSOCK(inet_ntoa, LPFN_INET_NTOA);
> 	DYNAMICWINSOCK(ioctlsocket, LPFN_IOCTLSOCKET);
> 	DYNAMICWINSOCK(listen, LPFN_LISTEN);
> 	DYNAMICWINSOCK(ntohl, LPFN_NTOHL);
> 	DYNAMICWINSOCK(ntohs, LPFN_NTOHS);
> 	DYNAMICWINSOCK(recv, LPFN_RECV);
> 	DYNAMICWINSOCK(recvfrom, LPFN_RECVFROM);
> 	DYNAMICWINSOCK(select, LPFN_SELECT);
> 	DYNAMICWINSOCK(send, LPFN_SEND);
> 	DYNAMICWINSOCK(sendto, LPFN_SENDTO);
> 	DYNAMICWINSOCK(setsockopt, LPFN_SETSOCKOPT);
> 	DYNAMICWINSOCK(shutdown, LPFN_SHUTDOWN);
> 	DYNAMICWINSOCK(socket, LPFN_SOCKET);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByAddr, LPFN_WSAASYNCGETHOSTBYADDR);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByName, LPFN_WSAASYNCGETHOSTBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByName, LPFN_WSAASYNCGETPROTOBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByNumber, LPFN_WSAASYNCGETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(WSAAsyncGetServByName, LPFN_WSAASYNCGETSERVBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetServByPort, LPFN_WSAASYNCGETSERVBYPORT);
> 	DYNAMICWINSOCK(WSAAsyncSelect, LPFN_WSAASYNCSELECT);
> 	DYNAMICWINSOCK(WSACancelAsyncRequest, LPFN_WSACANCELASYNCREQUEST);
> 	DYNAMICWINSOCK(WSACleanup, LPFN_WSACLEANUP);
> 	DYNAMICWINSOCK(WSAGetLastError, LPFN_WSAGETLASTERROR);
> 	DYNAMICWINSOCK(WSASetLastError, LPFN_WSASETLASTERROR);
> 	DYNAMICWINSOCK(WSAStartup, LPFN_WSASTARTUP);
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock2.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,27c1,3
< #ifdef UNICODE
< //	#define p_WSAAddressToString				WSAAddressToStringW
< //	#define p_WSADuplicateSocket				WSADuplicateSocketW
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersW
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsW
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoW
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdW
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassW
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginW
< //	#define p_WSALookupServiceNext				WSALookupServiceNextW
< //	#define p_WSASetService						WSASetServiceW
< //	#define p_WSASocket							WSASocketW
< //	#define p_WSAStringToAddress				WSAStringToAddressW
< #else
< //	#define p_WSAAddressToString				WSAAddressToStringA
< //	#define p_WSADuplicateSocket				WSADuplicateSocketA
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersA
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsA
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoA
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdA
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassA
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginA
< //	#define p_WSALookupServiceNext				WSALookupServiceNextA
< //	#define p_WSASetService						WSASetServiceA
< //	#define p_WSASocket							WSASocketA
< //	#define p_WSAStringToAddress				WSAStringToAddressA
< #endif // UNICODE
---
> //
> // DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
> //
29,53c5,70
< //#define p_WSAAccept WSAAccept
< #define p_WSACloseEvent WSACloseEvent
< //#define p_WSAConnect WSAConnect
< #define p_WSACreateEvent WSACreateEvent
< #define p_WSAEnumNetworkEvents WSAEnumNetworkEvents
< #define p_WSAEventSelect WSAEventSelect
< #define p_WSAGetOverlappedResult WSAGetOverlappedResult
< //#define p_WSAGetQOSByName WSAGetQOSByName
< //#define p_WSAHtonl WSAHtonl
< //#define p_WSAHtons WSAHtons
< #define p_WSAIoctl WSAIoctl
< //#define p_WSAJoinLeaf WSAJoinLeaf
< //#define p_WSALookupServiceEnd WSALookupServiceEnd
< //#define p_WSANtohl WSANtohl
< //#define p_WSANtohs WSANtohs
< #define p_WSARecv WSARecv
< //#define p_WSARecvDisconnect WSARecvDisconnect
< #define p_WSARecvFrom WSARecvFrom
< //#define p_WSARemoveServiceClass WSARemoveServiceClass
< #define p_WSAResetEvent WSAResetEvent
< #define p_WSASend WSASend
< //#define p_WSASendDisconnect WSASendDisconnect
< #define p_WSASendTo WSASendTo
< #define p_WSASetEvent WSASetEvent
< #define p_WSAWaitForMultipleEvents WSAWaitForMultipleEvents
---
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	DYNAMICWINSOCK(WSAAccept, LPFN_WSAACCEPT);
> 	DYNAMICWINSOCK(WSAAddressToStringA, LPFN_WSAADDRESSTOSTRINGA);
> 	DYNAMICWINSOCK(WSAAddressToStringW, LPFN_WSAADDRESSTOSTRINGW);
> 	DYNAMICWINSOCK(WSACloseEvent, LPFN_WSACLOSEEVENT);
> 	DYNAMICWINSOCK(WSAConnect, LPFN_WSACONNECT);
> 	DYNAMICWINSOCK(WSACreateEvent, LPFN_WSACREATEEVENT);
> 	DYNAMICWINSOCK(WSADuplicateSocketA, LPFN_WSADUPLICATESOCKETA);
> 	DYNAMICWINSOCK(WSADuplicateSocketW, LPFN_WSADUPLICATESOCKETW);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersA, LPFN_WSAENUMNAMESPACEPROVIDERSA);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersW, LPFN_WSAENUMNAMESPACEPROVIDERSW);
> 	DYNAMICWINSOCK(WSAEnumNetworkEvents, LPFN_WSAENUMNETWORKEVENTS);
> 	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
> 	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
> 	DYNAMICWINSOCK(WSAEventSelect, LPFN_WSAEVENTSELECT);
> 	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
> 	DYNAMICWINSOCK(WSAGetQOSByName, LPFN_WSAGETQOSBYNAME);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoA, LPFN_WSAGETSERVICECLASSINFOA);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoW, LPFN_WSAGETSERVICECLASSINFOW);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdA, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdW, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW);
> 	DYNAMICWINSOCK(WSAHtonl, LPFN_WSAHTONL);
> 	DYNAMICWINSOCK(WSAHtons, LPFN_WSAHTONS);
> 	DYNAMICWINSOCK(WSAInstallServiceClassA, LPFN_WSAINSTALLSERVICECLASSA);
> 	DYNAMICWINSOCK(WSAInstallServiceClassW, LPFN_WSAINSTALLSERVICECLASSW);
> 	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
> 	DYNAMICWINSOCK(WSAJoinLeaf, LPFN_WSAJOINLEAF);
> 	DYNAMICWINSOCK(WSALookupServiceBeginA, LPFN_WSALOOKUPSERVICEBEGINA);
> 	DYNAMICWINSOCK(WSALookupServiceBeginW, LPFN_WSALOOKUPSERVICEBEGINW);
> 	DYNAMICWINSOCK(WSALookupServiceEnd, LPFN_WSALOOKUPSERVICEEND);
> 	DYNAMICWINSOCK(WSALookupServiceNextA, LPFN_WSALOOKUPSERVICENEXTA);
> 	DYNAMICWINSOCK(WSALookupServiceNextW, LPFN_WSALOOKUPSERVICENEXTW);
> 	DYNAMICWINSOCK(WSANtohl, LPFN_WSANTOHL);
> 	DYNAMICWINSOCK(WSANtohs, LPFN_WSANTOHS);
> 	DYNAMICWINSOCK(WSARecv, LPFN_WSARECV);
> 	DYNAMICWINSOCK(WSARecvDisconnect, LPFN_WSARECVDISCONNECT);
> 	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
> 	DYNAMICWINSOCK(WSARemoveServiceClass, LPFN_WSAREMOVESERVICECLASS);
> 	DYNAMICWINSOCK(WSAResetEvent, LPFN_WSARESETEVENT);
> 	DYNAMICWINSOCK(WSASend, LPFN_WSASEND);
> 	DYNAMICWINSOCK(WSASendDisconnect, LPFN_WSASENDDISCONNECT);
> 	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
> 	DYNAMICWINSOCK(WSASetEvent, LPFN_WSASETEVENT);
> 	DYNAMICWINSOCK(WSASetServiceA, LPFN_WSASETSERVICEA);
> 	DYNAMICWINSOCK(WSASetServiceW, LPFN_WSASETSERVICEW);
> 	DYNAMICWINSOCK(WSASocketA, LPFN_WSASOCKETA);
> 	DYNAMICWINSOCK(WSASocketW, LPFN_WSASOCKETW);
> 	DYNAMICWINSOCK(WSAStringToAddressA, LPFN_WSASTRINGTOADDRESSA);
> 	DYNAMICWINSOCK(WSAStringToAddressW, LPFN_WSASTRINGTOADDRESSW);
> 	DYNAMICWINSOCK(WSAWaitForMultipleEvents, LPFN_WSAWAITFORMULTIPLEEVENTS);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
102a104
> 	m_hActiveSettingsDialog( NULL ),
129a132
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
362a366,373
> 		//
> 		// cancel any active dialogs
> 		// if there are no dialogs, cancel the active command
> 		//
> 		if ( m_hActiveSettingsDialog != NULL )
> 		{
> 			StopSettingsDialog( m_hActiveSettingsDialog );
> 		}
365a377,383
> 	else
> 	{
> 		//
> 		// there should be no active dialog if there isn't an active command
> 		//
> 		DNASSERT( m_hActiveSettingsDialog == NULL );
> 	}
847a866,872
> 	if ( m_hActiveSettingsDialog != NULL )
> 	{
> 		StopSettingsDialog( m_hActiveSettingsDialog );
> 		Unlock();
> 	}
> 	else
> 	{
853a879
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
290a291,297
> 		// UI functions
> 		//
> 		virtual	HRESULT	ShowSettingsDialog( CThreadPool *const pThreadPool ) = 0;
> 		virtual	void	StopSettingsDialog( const HWND hDlg ) = 0;
> 		virtual	void	SettingsDialogComplete( const HRESULT hr ) = 0;
> 
> 		//
309a317,318
> 
> 		HWND			m_hActiveSettingsDialog;		// handle of active settings dialog
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
44a46
> #include	"IPXAddress.h"
81c83,84
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
99a103,104
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
114a120
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
188a195,200
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
209a222,228
> 	switch ( OSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
213a233,255
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
238a281,282
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
271a316,317
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
302a349,354
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
444a497,503
> 	switch ( OSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
447a507,530
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
479a563,564
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
500a586,587
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
87a88,90
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
117a121
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
118a123
> 
148a154
> 		INT		m_Win9xReceiveWSAReturn;		
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
84a86
> const DWORD	g_dwIPBroadcastAddressSize = sizeof( g_IPBroadcastAddress );
978,980d979
< // BUGBUG: [mgere] [xbox] No need to enum adapters anymore since we only have one.
< // need to complete the removal of this functionality at a later date.
< /*
1300d1298
< */	return DPNERR_UNSUPPORTED;
1480a1479,1484
> 	//
> 	// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1481a1486,1504
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1484a1508,1510
> 		case 2:
> 		default:
> 		{
1485a1512,1514
> 			break;
> 		}
> 	}
1555a1585,1590
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1556a1592,1610
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1559a1614,1616
> 		case 2:
> 		default:
> 		{
1560a1618,1620
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
38a40
> #include	"StrUtils.h"
51a54
> #include	"IPUI.h"
94a98
> 	memset( m_TempHostName, 0x00, sizeof( m_TempHostName ) );
116a121,342
> // CIPEndpoint::ShowSettingsDialog - show dialog for settings
> //
> // Entry:		Pointer to thread pool
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CIPEndpoint::ShowSettingsDialog( CThreadPool *const pThreadPool )
> {
> 	HRESULT	hr;
> 
> 
> 	DNASSERT( pThreadPool != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	AddRef();
> 	hr = pThreadPool->SpawnDialogThread( DisplayIPHostNameSettingsDialog, &m_hActiveSettingsDialog, this );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to start IP hostname dialog!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:	
> 	DecRef();
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::SettingsDialogComplete - dialog has completed
> //
> // Entry:		Error code for dialog
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::SettingsDialogComplete( const HRESULT hDialogResult )
> {
> 	HRESULT					hr;
> 	HRESULT					hTempResult;
> 	IDirectPlay8Address		*pBaseAddress;
> 	DWORD					dwTotalAddressBufferSize;
> 	char					*pTempAddressString;
> 	WCHAR					WCharHostName[ sizeof( m_TempHostName ) + 1 ];
> 	DWORD					dwWCharHostNameSize;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = hDialogResult;
> 	pBaseAddress = NULL;
> 
> 	pTempAddressString = NULL;
> 
> 	//
> 	// since the dialog is exiting, clear our handle to the dialog
> 	//
> 	m_hActiveSettingsDialog = NULL;
> 
> 	//
> 	// dialog failed, fail the user's command
> 	//
> 	if ( hr != DPN_OK )
> 	{
> 		if ( hr != DPNERR_USERCANCEL)
> 		{
> 			DPF( 0, "Failing endpoint hostname dialog!" );
> 			DisplayErrorCode( 0, hr );
> 
> 		}
> 
> 		goto Failure;
> 	}
> 
> 	//
> 	// The dialog completed OK, rebuild remote address and complete command
> 	//
> 
> 	//
> 	// get the base DNADDRESS
> 	//
> 	pBaseAddress = m_pRemoteMachineAddress->DP8AddressFromSocketAddress();
> 	if ( pBaseAddress == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "SettingsDialogComplete: Failed to get base address when completing IP hostname dialog!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// Add the new 'HOSTNAME' parameter to the address.  If the hostname is blank
> 	// and this is an enum, copy the broadcast hostname.
> 	//
> 	if ( ( m_TempHostName[ 0 ] == '\0' ) && ( m_EndpointType == ENDPOINT_TYPE_ENUM ) )
> 	{
> 		DNASSERT( sizeof( WCharHostName ) >= g_dwIPBroadcastAddressSize );
> 		memcpy( WCharHostName, g_IPBroadcastAddress, g_dwIPBroadcastAddressSize );
> 		dwWCharHostNameSize = g_dwIPBroadcastAddressSize;
> 	}
> 	else
> 	{
> 		dwWCharHostNameSize = LENGTHOF( WCharHostName );
> 		hr = STR_AnsiToWide( m_TempHostName, -1, WCharHostName, &dwWCharHostNameSize );
> 		DNASSERT( hr == DPN_OK );
> 		dwWCharHostNameSize *= sizeof( WCHAR );
> 	}
> 
> 	hr = IDirectPlay8Address_AddComponent( pBaseAddress, DPNA_KEY_HOSTNAME, WCharHostName, dwWCharHostNameSize, DPNA_DATATYPE_STRING );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "SettingsDialogComplete: Failed to add hostname to address!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// set the address
> 	//
> 	hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pBaseAddress, SP_ADDRESS_TYPE_HOST );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to rebuild DNADDRESS when completing IP hostname dialog!" );
> 		DNASSERT( FALSE );
> 		goto Failure;
> 	}
> 
> 	//
> 	// the remote machine address has been adjusted, finish the command
> 	//
> 	switch ( m_EndpointType )
> 	{
> 		case ENDPOINT_TYPE_ENUM:
> 		{
> 			hr = CompleteEnumQuery();
> 			if ( hr != DPN_OK )
> 			{
> 				DPF( 0, "Problem completing EnumQuery after asking user for hostname!" );
> 				DisplayDNError( 0, hr );
> 			}
> 
> 			break;
> 		}
> 
> 		case ENDPOINT_TYPE_CONNECT:
> 		{
> 			hr = CompleteConnect();
> 			if ( hr != DPN_OK )
> 			{
> 				DPF( 0, "Problem completing Connect after asking user for hostname!" );
> 				DisplayDNError( 0, hr );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			hr = DPNERR_GENERIC;
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pBaseAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DNASSERT( pTempAddressString == NULL );
> 	if ( pBaseAddress != NULL )
> 	{
> 		DNFree( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DecRef();
> 
> 	return;
> 
> Failure:
> 	//
> 	// close this endpoint
> 	//
> 	Close( hr );
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::StopSettingsDialog - stop an active settings dialog
> //
> // Entry:		Handle of dialog to close
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::StopSettingsDialog( const HWND hDlg)
> {
> 	StopIPHostNameSettingsDialog( hDlg );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
216a443
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
262,263d488
< 
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
22a23,24
> #define	TEMP_HOSTNAME_LENGTH	100
> 
52a55,67
> 		// UI functions
> 		//
> 		HRESULT		ShowSettingsDialog( CThreadPool *const pThreadPool );
> 		void		SettingsDialogComplete( const HRESULT hr );
> 		void		StopSettingsDialog( const HWND hDlg );
> 		void		SetTempHostName( const char *const pHostName, const UINT_PTR uHostNameLength )
> 		{
> 			DNASSERT( pHostName[ uHostNameLength ] == '\0' );
> 			DNASSERT( ( uHostNameLength + 1 ) <= LENGTHOF( m_TempHostName ) );
> 			memcpy( m_TempHostName, pHostName, ( uHostNameLength + 1 ) );
> 		}
> 
> 		//
69a85
> 		char		m_TempHostName[ TEMP_HOSTNAME_LENGTH ];
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\locals.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62a63,67
> //
> // OS version
> //
> UINT_PTR	g_uOSType;
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\locals.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
103a104,108
> //
> // OS version
> //
> extern	UINT_PTR	g_uOSType;
> 
105a111,125
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // OSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OSType
> // ------------------------------
> inline UINT_PTR	OSType( void )
> {
> 	return	g_uOSType;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
50a52
> #include	"IPXAddress.h"
54a57
> #include	"IPXEndpt.h"
82a86
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
84a89
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
174a180,186
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
193a206,222
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
> 	
318a348,354
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
328a365,370
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
399a442
> 
428a472,515
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	CIPXAddress	*pReturnAddress;
> 
> 	
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	
> 	DNEnterCriticalSection( &g_AddressLock );
> 	pReturnAddress = g_pIPXAddressPool->Get();
> 	DNLeaveCriticalSection( &g_AddressLock );
> 
> 	return	pReturnAddress;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	
> 	DNEnterCriticalSection( &g_AddressLock );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> 	DNLeaveCriticalSection( &g_AddressLock );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
438a526,541
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
59a62,63
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
61a66
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\rsip.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40a41
> #include	"Registry.h"
512a514,517
> 
> 		hr = GetGatewayFromRegistry( reinterpret_cast<BYTE*>( gwipaddr ), sizeof( gwipaddr ) );
> 
> 		if(hr != DPN_OK){
514a520,522
> 		}
> 
> 		DPF(0,"Found suggested RSIP gateway in registry %s, running on Win95?\n",gwipaddr);
651d658
<         WCHAR wszIPHLPAPI[] = L"IPHLPAPI.DLL";
687c694
< 	hIpHlpApi = LoadLibrary(wszIPHLPAPI);
---
> 	hIpHlpApi = LoadLibrary("IPHLPAPI.DLL");
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
258a260,267
> 	
> 	//
> 	// Winsock 2 functionality always exists on WinNT.  If we're on Win9x, we can
> 	// only use Winsock2 interfaces for TCP.
> 	//
> 	if ( ( OSType() == VER_PLATFORM_WIN32_NT ) ||
> 		 ( ( LOWORD( GetWinsockVersion() ) >= 2 ) && ( m_pSPData->GetType() == TYPE_IP ) ) )
> 	{
259a269,273
> 	}
> 	else
> 	{
> 		m_pSendFunction = Winsock1Send;
> 	}
405a420,431
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( ( LOWORD( GetWinsockVersion() ) == 1 ) ||
> 			 ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_pSPData->GetType() == TYPE_IPX ) ) )
> 		{
> 			m_pSPData->GetThreadPool()->RemoveSocketPort( this );
> 		}
> 
836a863,875
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
838a878,974
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ),	// pointer to receive buffer
> 								pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize,		// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();
> 
> Exit:
> 	return;
> }
839a976,978
> 
> 
> //**********************************************************************
840a980,1125
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
867,868c1152,1153
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( OSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
874a1160,1168
> 	// lock the 'pending operation' list over the call to Winsock to prevent the
> 	// operation from being completed while it's being set up.
> 	//
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->LockWriteData();
> 	}
> 	
> 	//
880a1175,1177
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
892a1190,1194
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->UnlockWriteData();
> 	}
> 
933a1236,1238
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1007c1312,1313
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( OSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1016a1323,1331
> 	// lock the 'pending operation' list over the call to Winsock to prevent the
> 	// operation from being completed while it's being set up.
> 	//
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->LockReadData();
> 	}
> 
> 	//
1022a1338,1340
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1033a1352,1357
> 	
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->UnlockReadData();
> 	}
> 
1080a1405,1406
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1114a1441,1442
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1159a1488,1489
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
1730a2061,2067
> 	switch ( OSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1775a2113,2176
> 			break;
> 		}
> 
> 		//
> 		// Win9x.
> 		// If this is not an IPX socket and Winsock 2 (or greater) is available,
> 		// call the Winsock 2 read function.  If this is IPX or we're stuck with
> 		// Winsock 1, inform the thread pool as such.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 
> 			if ( ( LOWORD( GetWinsockVersion() ) >= 2 ) &&
> 				 ( m_pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// we're using Winsock2, call for two outstanding reads per socket.
> 				//
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #1 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #2 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 			}
> 			else
> 			{
> 				DNASSERT( m_pSPData != NULL );
> 				hr = m_pSPData->GetThreadPool()->AddSocketPort( this );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Failed to add to active socket list!" );
> 					DisplayDNError( 0, hr );
> 					goto Failure;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
1975d2375
< 
2413a2814,2971
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
> 
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			goto Exit;
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = pReadData->m_dwOverlappedBytesReceived;
> 					pReadData->m_dwOverlappedBytesReceived = 0;
> 					ProcessReceivedData( pReadData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();	
> 	DecRef();
> 
> 	return;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
239a240
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
245a247,249
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
288a293
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,3c1,5
< TARGETNAME=dpnwsock
< TARGETTYPE=DYNLINK
< TARGETPATH=obj
---
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
5c7,17
< !ifdef _BUILD_FOR_WIN2000
---
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
> TARGETNAME=dpnwsock
> DLLDEF=..\wsocksp.def
7,13d18
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
15c20,26
< INCLUDES=..\..\;..\..\..\inc;..\..\..\common;..\..\..\..\dnaddress
---
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
17c28,29
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> TARGETPATH=obj
> TARGETTYPE=DYNLINK
19c31,35
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
21,22c37,58
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
>            ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
> 
> #
> # If a debug mode is selected, make sure we include the defines to make the
> # logging code operate.
> #
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
25c61,71
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
27c73,77
< DLLDEF=..\wsocksp.def
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28a79,88
> INCLUDES=$(DXROOT)\inc;..\..\..\inc;..\..\..\common;..\..\..\dnaddress
> 
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
32a93
> 	 ..\DWinsock.cpp \
36a98,100
> 	 ..\IPUI.cpp \
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
39a104
>          ..\Registry.cpp \
48a114,116
> #
> # Next specify options for the compiler.
> #
49a118,120
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNWSock_EXPORTS /DCINTERFACE
> 
> USER_C_FLAGS=-nologo -W3
52,72c123,124
< TARGETLIBS= \
<            ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
<            $(BASEDIR)\public\sdk\lib\*\dpnaddr.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<            $(BASEDIR)\public\sdk\lib\*\winsockx.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
104c104
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
122c122,123
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
158c159,160
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
241a244
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
242a246
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
245c249
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
252c256
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
279a284
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
48a50
> #include	"IPXAddress.h"
54a57
> #include	"IPXEndpt.h"
224a228,257
> 	switch ( OSType() )
> 	{
> 		//
> 		// Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
> 			DPF( 8, "WinNT detected!" );
> 			break;
> 		}
> 
> 		//
> 		// Windows 95, 98
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DPF( 8, "Win9x detected!" );
> 			break;
> 		}
> 
> 		// other version (unsupported!)
> //		case VER_PLATFORM_WIN32_CE:
> 		case VER_PLATFORM_WIN32s:
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
578a612,617
> 		case TYPE_IPX:
> 		{
> 			pReturn = CreateIPXEndpoint( &EndpointPoolContext );
> 			break;
> 		}
> 
747a787,792
> 		case TYPE_IPX:
> 		{
> 			pReturn = CreateIPXAddress();
> 			break;
> 		}
> 
778a824,829
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
121a123,145
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> //	DWORD		dwActiveSocketCount;				// count of active sockets
> //	CSocketPort	*pSocketPorts[ FD_SETSIZE ];		// list of socket ports associated with sockets
> //	FD_SET		Sockets;							// set of sockets
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
128a153,163
> //
> // structure passed to dialog threads
> //
> typedef	struct	_DIALOG_THREAD_PARAM
> {
> 	DIALOG_FUNCTION	*pDialogFunction;
> 	HWND			*phDialog;
> 	void			*pContext;
> 	CThreadPool		*pThisThreadPool;
> } DIALOG_THREAD_PARAM;
> 
233c268,275
< 	DEBUG_ONLY( 
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( OSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
235c277,278
< 	)
---
> 						break;
> 					}
236a280,287
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
243c294,301
< 	DEBUG_ONLY(
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( OSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
245c303,304
< 	)
---
> 						break;
> 					}
246a306,313
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
280a348,354
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
337a412,416
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( OSType() )
> 	{
340a420,421
> 		case VER_PLATFORM_WIN32_NT:
> 		{
346a428,454
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
375a484,485
> 	SYSTEM_INFO		SystemInfo;
> 	UINT_PTR		uDesiredThreads;
382a493,497
> 	//
> 	// get machine information
> 	//
> 	memset( &SystemInfo, 0x00, sizeof( SystemInfo ) );
> 	GetSystemInfo( &SystemInfo );
402a518,524
> 	uDesiredThreads = ( SystemInfo.dwNumberOfProcessors * 2 ) + 2;
> 	DNASSERT( uDesiredThreads != 0 );
> 	while ( uDesiredThreads > 0 )
> 	{
> 		uDesiredThreads--;
> 		StartNTCompletionThread();
> 	}
404,408d525
<     StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 
433a551,786
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT				hr;
> 	HANDLE				hPrimaryThread;
> 	HANDLE				hSecondaryThread;
> 	DWORD				dwPrimaryThreadID;
> 	DWORD				dwSecondaryThreadID;
> 	WIN9X_THREAD_DATA	*pPrimaryThreadInput;
> 	WIN9X_THREAD_DATA	*pSecondaryThreadInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	hPrimaryThread = NULL;
> 	hSecondaryThread = NULL;
> 	pPrimaryThreadInput = NULL;
> 	pSecondaryThreadInput = NULL;
> 
> 	//
> 	// Win9x requires completion events for Winsock2.  Always allocate the
> 	// events even though the they might not be used.
> 	//
> 	DNASSERT( m_hWinsock2SendComplete == NULL );
> 	m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 										   TRUE,	// manual reset
> 										   FALSE,	// start unsignalled
> 										   NULL		// pointer to name (none)
> 										   );
> 	if ( m_hWinsock2SendComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Send!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 	m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 											  TRUE,		// manual reset
> 											  FALSE,	// start unsignalled
> 											  NULL		// pointer to name (none)
> 											  );
> 	if ( m_hWinsock2ReceiveComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Receive!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	//
> 	// create parameters to worker threads
> 	//
> 	pPrimaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pPrimaryThreadInput ) ) );
> 	if ( pPrimaryThreadInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for primary Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	pSecondaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pSecondaryThreadInput ) ) );
> 	if ( pSecondaryThreadInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for secondary Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pPrimaryThreadInput, 0x00, sizeof( *pPrimaryThreadInput ) );
> 	pPrimaryThreadInput->pThisThreadPool = this;
> 	
> 	DBG_CASSERT( sizeof( *pPrimaryThreadInput ) == sizeof( *pSecondaryThreadInput ) );
> 	memcpy( pSecondaryThreadInput, pPrimaryThreadInput, sizeof( *pSecondaryThreadInput ) );
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	IncrementActiveThreadCount();
> 	
> 	//
> 	// Create one worker thread and boost its priority.  If the primary thread
> 	// can be created and boosted, create a secondary thread.  Do not create a
> 	// secondary thread if the primary could not be boosted because the system
> 	// is probably low on resources.
> 	//
> 	hPrimaryThread = CreateThread( NULL,					// pointer to security attributes (none)
> 								   0,						// stack size (default)
> 								   PrimaryWin9xThread,		// pointer to thread function
> 								   pPrimaryThreadInput,		// pointer to input parameter
> 								   0,						// let it run
> 								   &dwPrimaryThreadID		// pointer to destination of thread ID
> 								   );
> 	if ( hPrimaryThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		DecrementActiveThreadCount();
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		goto Failure;
> 	}
> 	pPrimaryThreadInput = NULL;
> 
> 
> 	DPF( 8, "Created primary Win9x thread: 0x%x\tTotal Thread Count: %d", dwPrimaryThreadID, ThreadCount() );
> 	DNASSERT( hPrimaryThread != NULL );
> 	if ( SetThreadPriority( hPrimaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of primary Win9x read thread!  Not starting secondary thread" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 	else
> 	{
> 		//
> 		// primary thread was created and boosted, create a secondary thread
> 		//
> 		IncrementActiveThreadCount();
> 		hSecondaryThread = CreateThread( NULL,						// pointer to security attributes (none)
> 										 0,							// stack size (default)
> 										 SecondaryWin9xThread,		// pointer to thread function
> 										 pSecondaryThreadInput,		// pointer to input parameter
> 										 0,							// let it run
> 										 &dwSecondaryThreadID		// pointer to destination of thread ID
> 										 );
> 		if ( hSecondaryThread != NULL )
> 		{
> 			DPF( 8, "Created secondary Win9x thread: 0x%x\tTotal Thread Count: %d", dwSecondaryThreadID, ThreadCount() );
> 			
> 			pSecondaryThreadInput = NULL;
> 			DNASSERT( hSecondaryThread != NULL );
> 			if ( SetThreadPriority( hSecondaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to boost priority of secondary Win9x thread!" );
> 				DisplayErrorCode( 0, dwError );
> 			}
> 		}
> 		else
> 		{
> 			//
> 			// thread startup failed, decrement active thread count
> 			//
> 			DecrementActiveThreadCount();
> 		}
> 	}
> 
> 
> Exit:
> 	if ( pPrimaryThreadInput != NULL )
> 	{
> 		DNFree( pPrimaryThreadInput );
> 		pPrimaryThreadInput = NULL;
> 	}
> 
> 	if ( pSecondaryThreadInput != NULL )
> 	{
> 		DNFree( pSecondaryThreadInput );
> 		pSecondaryThreadInput = NULL;
> 	}
> 
> 	if ( hPrimaryThread != NULL )
> 	{
> 		if ( CloseHandle( hPrimaryThread ) == FALSE )
> 		{
> 			DWORD	dwError;
> 
> 
> 			dwError = GetLastError();
> 			DPF( 0, "Problem closing Win9x thread hanle!" );
> 			DisplayErrorCode( 0, dwError );
> 		}
> 
> 		hPrimaryThread = NULL;
> 	}
> 
> 	if ( hSecondaryThread != NULL )
> 	{
> 		if ( CloseHandle( hSecondaryThread ) == FALSE )
> 		{
> 			DWORD	dwError;
> 
> 
> 			dwError = GetLastError();
> 			DPF( 0, "Problem closing Win9x thread hanle!" );
> 			DisplayErrorCode( 0, dwError );
> 		}
> 
> 		hSecondaryThread = NULL;
> 	}
> 
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
532a886,887
> 	if ( OSType() == VER_PLATFORM_WIN32_NT )
> 	{	
553a909
> 	}
629a986,989
> 
> 		DNASSERT( ( OSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
647a1008,1009
> 		DNASSERT( ( OSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
792a1155
> 	m_IPXReadIODataPool.Deinitialize();
840d1202
< 			
844a1207,1215
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			break;
> 		}
> 
> 		//
922a1294,1302
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1177a1558,1559
> 	switch ( OSType() )
> 	{
1180a1563,1564
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1197a1582,1610
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( m_JobQueue.SignalPendingJob() == FALSE )
> 			{
> 				hr = DPNERR_OUTOFMEMORY;
> 				DPF( 0, "Failed to signal pending job!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1308a1722,1723
> 	if ( OSType() == VER_PLATFORM_WIN32_NT )
> 	{
1315a1731
> 	}
1517a1934,2034
> // CThreadPool::SpawnDialogThread - start a secondary thread to display service
> //		provider UI.
> //
> // Entry:		Pointer to dialog function
> //				Pointer destination for copy of dialog handle
> //				Dialog context
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext )
> {
> 	HRESULT	hr;
> 	HANDLE	hDialogThread;
> 	DIALOG_THREAD_PARAM		*pThreadParam;
> 	DWORD	dwThreadID;
> 
> 
> 	DNASSERT( pDialogFunction != NULL );
> 	DNASSERT( phDialog != NULL );
> 	DNASSERT( pDialogContext != NULL );		// why would anyone not want a dialog context??
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pThreadParam = NULL;
> 
> 	//
> 	// create and initialize thread param
> 	//
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( DNMalloc( sizeof( *pThreadParam ) ) );
> 	if ( pThreadParam == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for dialog thread!" );
> 		goto Failure;
> 	}
> 
> 	pThreadParam->pDialogFunction = pDialogFunction;
> 	pThreadParam->phDialog = phDialog;
> 	pThreadParam->pContext = pDialogContext;
> 	pThreadParam->pThisThreadPool = this;
> 
> 	//
> 	// assume that a thread will be created
> 	//
> 	IncrementActiveThreadCount();
> 
> 	//
> 	// create thread
> 	//
> 	hDialogThread = CreateThread( NULL,					// pointer to security (none)
> 								  0,					// stack size (default)
> 								  DialogThreadProc,		// thread procedure
> 								  pThreadParam,			// thread param
> 								  0,					// creation flags (none)
> 								  &dwThreadID );		// pointer to thread ID
> 	if ( hDialogThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// decrement active thread count and report error
> 		//
> 		DecrementActiveThreadCount();
> 		
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to start dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		goto Failure;
> 	}
>   								
> 	if ( CloseHandle( hDialogThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing handle from create dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:
> 	if ( pThreadParam != NULL )
> 	{
> 		DNFree( pThreadParam );
> 		pThreadParam = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
1537a2055,2056
> 	switch ( OSType() )
> 	{
1538a2058,2067
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( NTCompletionThreadCount() == 0 );
> 			break;
> 		}
> 
> 		//
1540a2070,2071
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1542a2074,2075
> 			break;
> 		}
1543a2077,2086
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1572a2116,2117
> 	switch ( OSType() )
> 	{
1573a2119,2126
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1579a2133,2134
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1619a2175,2187
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1699a2268,2415
> // CThreadPool::AddSocketPort - add a socket to the Win9x watch list
> //
> // Entry:		Pointer to SocketPort
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::AddSocketPort( CSocketPort *const pSocketPort )
> {
> 	HRESULT	hr;
> 	BOOL	fSocketAdded;
> 
> 	
> 	DNASSERT( pSocketPort != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	fSocketAdded = FALSE;
> 
> 	Lock();
> 
> 	//
> 	// We're capped by the number of sockets we can use for Winsock1.  Make
> 	// sure we don't allocate too many sockets.
> 	//
> 	if ( m_uReservedSocketCount == FD_SETSIZE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "There are too many sockets allocated on Winsock1!" );
> 		goto Failure;
> 	}
> 
> 	m_uReservedSocketCount++;
> 	
> 	DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 	m_pSocketPorts[ m_SocketSet.fd_count ] = pSocketPort;
> 	m_SocketSet.fd_array[ m_SocketSet.fd_count ] = pSocketPort->GetSocket();
> 	m_SocketSet.fd_count++;
> 	fSocketAdded = TRUE;
> 
> 	//
> 	// add a reference to note that this socket port is being used by the thread
> 	// pool
> 	//
> 	pSocketPort->AddRef();
> 
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when adding socket port to active list!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> Exit:
> 	Unlock();
> 	
> 	return	hr;
> 
> Failure:
> 	if ( fSocketAdded != FALSE )
> 	{
> 		AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
> 		m_SocketSet.fd_count--;
> 		m_pSocketPorts[ m_SocketSet.fd_count ] = NULL;
> 		m_SocketSet.fd_array[ m_SocketSet.fd_count ] = NULL;
> 		fSocketAdded = FALSE;
> 	}
> 
> 	m_uReservedSocketCount--;
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::RemoveSocketPort - remove a socket from the Win9x watch list
> //
> // Entry:		Pointer to socket port to remove
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::RemoveSocketPort( CSocketPort *const pSocketPort )
> {
> 	UINT_PTR	uIndex;
> 
> 
> 	DNASSERT( pSocketPort != NULL );
> 	
> 	Lock();
> 
> 	uIndex = m_SocketSet.fd_count;
> 	DNASSERT( uIndex != 0 );
> 	while ( uIndex != 0 )
> 	{
> 		uIndex--;
> 
> 		if ( m_pSocketPorts[ uIndex ] == pSocketPort )
> 		{
> 			m_uReservedSocketCount--;
> 			m_SocketSet.fd_count--;
> 
> 			memmove( &m_pSocketPorts[ uIndex ],
> 					 &m_pSocketPorts[ uIndex + 1 ],
> 					 ( sizeof( m_pSocketPorts[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			memmove( &m_SocketSet.fd_array[ uIndex ],
> 					 &m_SocketSet.fd_array[ uIndex + 1 ],
> 					 ( sizeof( m_SocketSet.fd_array[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			//
> 			// clear last entry which is now unused
> 			//
> 			memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) );
> 			memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) );
> 
> 			//
> 			// end the loop
> 			//
> 			uIndex = 0;
> 		}
> 	}
> 
> 	Unlock();
> 	
> 	pSocketPort->DecRef();
> 
> 	//
> 	// It's really not necessary to signal a new job here because there were
> 	// active sockets on the last iteration of the Win9x thread.  That means the
> 	// Win9x thread was in a polling mode to check for sockets and the next time
> 	// through it will notice that there is a missing socket.  By signalling the
> 	// job event we reduce the time needed for the thread to figure out that the
> 	// socket is gone.
> 	//
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when removeing socket port to active list!" );
> 	}
> }
> //**********************************************************************
> 
> 
> 
> //**********************************************************************
> // ------------------------------
1846a2563,3383
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwOverlappedBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				//
> 				// Overlapped results will complete with success and zero bytes
> 				// transferred when the overlapped structure is checked BEFORE
> 				// the operation has really been subnitted.  This is a possibility
> 				// with the current code.  To combat this, check the sent bytes
> 				// for zero (we'll never send zero bytes).
> 				//
> 				if ( pWriteIOData->m_dwOverlappedBytesSent == 0 )
> 				{
> 					goto SkipSendCompletion;
> 				}
> 
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 				pWriteIOData->m_dwOverlappedBytesSent = 0;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					//
> 					// WSAENOTSOCK = the socket has been closed, most likely
> 					// as a result of a command completing or being cancelled.
> 					//
> 					case WSAENOTSOCK:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_USERCANCEL;
> 						break;
> 					}
> 
> 					//
> 					// other error, stop and look
> 					//
> 					default:
> 					{
> 						INT3;
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwOverlappedBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				//
> 				// Overlapped results will complete with success and zero bytes
> 				// transferred when the overlapped structure is checked BEFORE
> 				// the operation has really been subnitted.  This is a possibility
> 				// with the current code.  To combat this, check the received bytes
> 				// for zero (the return when the overlapped request was checked before
> 				// it was sent) and check the return address (it's possible that someone
> 				// really sent zero bytes).
> 				//
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				if ( ( pReadIOData->m_dwOverlappedBytesReceived != 0 ) &&
> 					 ( pReadIOData->m_pSourceSocketAddress->IsUndefinedHostAddress() == FALSE ) )
> 				{
> 					pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 				}
> 				else
> 				{
> 					goto SkipReceiveCompletion;
> 				}
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::PrimaryWin9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::PrimaryWin9xThread( void *pParam )
> {
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 	
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Primary Win9x thread failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> //	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> //	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 	
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 	
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		DWORD	dwWaitReturn;
> 
> 		
> 		//
> 		// Update the job time so we know how long to wait.  We can
> 		// only get here if a socket was just added to the socket list, or
> 		// we've been servicing sockets.
> 		//
> 		DNTimeGet( &CurrentTime );
> 		if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 		{
> 			pThisThreadPool->LockTimerData();
> 			CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																		   &CoreData.NextTimerJobTime );
> 			if ( CoreData.fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 			}
> 			pThisThreadPool->UnlockTimerData();
> 		}
> 
> 		DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 		dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 
> 		//
> 		// Check for Winsock1 sockets.  If there are some around, do a quick poll
> 		// of them to check of I/O before entering the main Winsock2 loop for
> 		// the real timing.
> 		//
> 		pThisThreadPool->Lock();
> 		if ( pSocketSet->fd_count != 0 )
> 		{
> 			pThisThreadPool->Unlock();
> 
> 			pThisThreadPool->CheckWinsock1IO( pSocketSet );
> 			
> 			//
> 			// since there are Winsock1 sockets active, don't spend a lot of
> 			// time waiting for something to happen for Winsock2
> 			//
> 			if ( g_dwSelectTimeSlice < dwMaxWaitTime )
> 			{
> 				dwMaxWaitTime = g_dwSelectTimeSlice;
> 			}
> 		}
> 		else
> 		{
> 			pThisThreadPool->Unlock();
> 		}
> 
> 
> 		//
> 		// Check Winsock2 sockets.
> 		//
> 		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> 												 CoreData.hWaitHandles,					// handles to wait on
> 												 FALSE,									// don't wait for all to be signalled
> 												 dwMaxWaitTime,							// wait timeout
> 												 TRUE									// we're alertable for APCs
> 												 );
> 		switch ( dwWaitReturn )
> 		{
> 			//
> 			// timeout, don't do anything, we'll probably process timer jobs on
> 			// the next loop
> 			//
> 			case WAIT_TIMEOUT:
> 			{
> 				break;
> 			}
> 
> 			//
> 			// New job.  Account for the time spent in the wait.  Don't
> 			// account for time after the job is complete because it's
> 			// possible that the job was an job submission which will want
> 			// to reset the wait time.
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 			{
> 				DPF( 8, "Primary Win9x thread has a pending job!" );
> 				pThisThreadPool->ProcessWin9xJob( &CoreData );
> 				break;
> 			}
> 
> 			//
> 			// SP closing
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 			{
> 				DPF( 8, "Primary Win9x thread exit because SP closing!" );
> 				fLooping = FALSE;
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 send complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending write list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Primary Win9x thread failed to reset Winsock2 send event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nPrimary Win9x thread servicing sends!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingSends();
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 receive complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending read list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Primary Win9x thread failed to reset Winsock2 receive event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nPrimary Win9x thread servicing receives!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingReceives();
> 				break;
> 			}
> 
> 			//
> 			// There are I/O completion routines scheduled on this thread.
> 			// This is not a good thing!
> 			//
> 			case WAIT_IO_COMPLETION:
> 			{
> 				DPF( 1, "WARNING: APC was serviced on the primary Win9x IO service thread!  What is the application doing??" );
> 				break;
> 			}
> 
> 			//
> 			// wait failed
> 			//
> 			case WAIT_FAILED:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Primary Win9x thread wait failed!" );
> 				DisplayDNError( 0, dwError );
> 				break;
> 			}
> 
> 			//
> 			// problem
> 			//
> 			default:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Primary Win9x thread unknown problem in wait!" );
> 				DisplayDNError( 0, dwError );
> 				DNASSERT( FALSE );
> 				break;
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	COM_CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::SecondaryWin9xThread - secondary thread to handle only Win9x
> //		I/O so developers get bit faster with multithreading issues if they're
> //		developing on Win9x.  This thread will only handle Winsock2 based TCP
> //		I/O.  Winsock 1 is not deemed important enough to hack the rest of the
> //		code to work with two threads.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::SecondaryWin9xThread( void *pParam )
> {
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 
> 	
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Secondary Win9x thread failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 	
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 	
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		DWORD	dwWaitReturn;
> 
> 		
> 		//
> 		// Check Winsock2 sockets.
> 		//
> 		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> 												 CoreData.hWaitHandles,					// handles to wait on
> 												 FALSE,									// don't wait for all to be signalled
> 												 INFINITE,								// wait timeout (forever)
> 												 TRUE									// we're alertable for APCs
> 												 );
> 		switch ( dwWaitReturn )
> 		{
> 			//
> 			// timeout, shouldn't ever be here!!
> 			//
> 			case WAIT_TIMEOUT:
> 			{
> 				INT3;
> 				break;
> 			}
> 
> 			//
> 			// New job.  This is the secondary thread and is only used to handle
> 			// Winsock2 I/O.  Ignore this event and sleep to cause the proper
> 			// work thread to handle the event.
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 			{
> 				DPF( 8, "Secondary Win9x thread sleeping on job notification!" );
> 				SleepEx( 0, TRUE );
> 				break;
> 			}
> 
> 			//
> 			// SP closing
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 			{
> 				DPF( 8, "Secondary Win9x thread exit because SP closing!" );
> 				fLooping = FALSE;
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 send complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending write list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Secondary Win9x thread failed to reset Winsock2 send event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nSecondary Win9x thread servicing sends!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingSends();
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 receive complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending read list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Secondary Win9x thead failed to reset Winsock2 receive event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nSecondary Win9x thread servicing receives!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingReceives();
> 				break;
> 			}
> 
> 			//
> 			// There are I/O completion routines scheduled on this thread.
> 			// This is not a good thing!
> 			//
> 			case WAIT_IO_COMPLETION:
> 			{
> 				DPF( 1, "WARNING: APC was serviced on the secondary Win9x IO service thread!  What is the application doing??" );
> 				break;
> 			}
> 
> 			//
> 			// wait failed
> 			//
> 			case WAIT_FAILED:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Secondary Win9x thread wait failed!" );
> 				DisplayDNError( 0, dwError );
> 				break;
> 			}
> 
> 			//
> 			// problem
> 			//
> 			default:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Secondary Win9x thread unknown problem in wait!" );
> 				DisplayDNError( 0, dwError );
> 				DNASSERT( FALSE );
> 				break;
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	COM_CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2190a3728,4085
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::DialogThreadProc - thread proc for spawning dialogs
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> // ------------------------------
> DWORD WINAPI	CThreadPool::DialogThreadProc( void *pParam )
> {
> 	const DIALOG_THREAD_PARAM	*pThreadParam;
> 
> 
> 	//
> 	// Initialize COM.  If this fails, we'll have problems later.
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
> 	DNASSERT( pParam != NULL );
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( pParam );
> 	
> 	pThreadParam->pDialogFunction( pThreadParam->phDialog, pThreadParam->pContext );
> 
> 	pThreadParam->pThisThreadPool->DecrementActiveThreadCount();
> 	DNFree( pParam );
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// Remove and process a single job from the list.  If there is no job, skip
> 	// to the end of the function.
> 	//
> 	pJobInfo = GetWorkItem();
> 
> 	if ( pJobInfo == NULL )
> 	{
> 		goto Exit;
> 	}
> 
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> 
> Exit:
> 	return;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CheckWinsock1IO - check the IO status for Winsock1 sockets
> //
> // Entry:		Pointer to sockets to watch
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CheckWinsock1IO( const FD_SET *const pWinsock1Sockets )
> {
> static	const TIMEVAL	SelectNoTime = { 0 };
> 	INT			iSelectReturn;
> 	FD_SET		ReadSocketSet;
> 	FD_SET		WriteSocketSet;
> 	FD_SET		ErrorSocketSet;
> 
> 
> 	//
> 	// Make a local copy of all of the sockets.  This isn't totally
> 	// efficient, but it works.  Multiplying by active socket count will
> 	// spend half the time in the integer multiply.
> 	//
> 	Lock();
> 	memcpy( &ReadSocketSet, pWinsock1Sockets, sizeof( ReadSocketSet ) );
> 	memcpy( &WriteSocketSet, pWinsock1Sockets, sizeof( WriteSocketSet ) );
> 	memcpy( &ErrorSocketSet, pWinsock1Sockets, sizeof( ErrorSocketSet ) );
> 	Unlock();
> 
> 	//
> 	// Don't check write sockets here because it's very likely that they're ready
> 	// for service but have no outgoing data and will thrash
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  &ReadSocketSet,	// sockets to check for read
> 							  NULL,				// sockets to check for write (none)
> 							  &ErrorSocketSet,	// sockets to check for error
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// select got pissed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// WSAENOTSOCK = This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// WSAEINTR = this operation was interrupted
> 				//
> 				case WSAEINTR:
> 				{
> 					DPF( 1, "Winsock1 reporting interrupted operation when selecting read or error sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting read or error sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing read service and error service.
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 			ServiceWinsock1Sockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Since writes are likely to be ready, check for them separately
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  NULL,				// sockets to check for read (don't check reads)
> 							  &WriteSocketSet,	// sockets to check for write
> 							  NULL,				// sockets to check for error (don't check errors)
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout, no write sockets are ready for service
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// select failed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// this socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting write sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing write service
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 			break;
> 		}
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ServiceWinsock1Sockets - service requests on Winsock1 sockets ports
> //
> // Entry:		Pointer to set of sockets
> //				Pointer to service function
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction )
> {
> 	UINT_PTR	uWaitingSocketCount;
> 	UINT_PTR	uSocketPortCount;
> 	CSocketPort	*pSocketPorts[ FD_SETSIZE ];
> 
> 
> 	uSocketPortCount = 0;
> 	uWaitingSocketCount = pSocketSet->fd_count;
> 	
> 	Lock();
> 	while ( uWaitingSocketCount > 0 )
> 	{
> 		UINT_PTR	uIdx;
> 
> 
> 		uWaitingSocketCount--;
> 		uIdx = m_SocketSet.fd_count;
> 		while ( uIdx != 0 )
> 		{
> 			uIdx--;
> 			if ( pSocketSet->fd_array[ uWaitingSocketCount ] == m_SocketSet.fd_array[ uIdx ] )
> 			{
> 				//
> 				// this socket is still available, add a reference to the socket
> 				// port and keep it around to be processed outside of the lock
> 				//
> 				pSocketPorts[ uSocketPortCount ] = m_pSocketPorts[ uIdx ];
> 				pSocketPorts[ uSocketPortCount ]->AddRef();
> 				uSocketPortCount++;
> 				uIdx = 0;
> 			}
> 		}
> 	}
> 	Unlock();
> 
> 	while ( uSocketPortCount != 0 )
> 	{
> 		uSocketPortCount--;
> 		
> 		//
> 		// call the service function and remove the reference
> 		//
> 		(pSocketPorts[ uSocketPortCount ]->*pServiceFunction)();
> 		pSocketPorts[ uSocketPortCount ]->DecRef();
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
52a53
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
65a67
> typedef	void	DIALOG_FUNCTION( HWND *const phDialog, void *const pDialogContext );
102c104,105
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( OSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
148a152
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( OSType() == VER_PLATFORM_WIN32_NT ) );
153a158
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( OSType() == VER_PLATFORM_WIN32_NT ) );
161a167,169
> 		HRESULT	AddSocketPort( CSocketPort *const pSocketPort );
> 		void	RemoveSocketPort( CSocketPort *const pSocketPort );
> 
172a181,183
> 		HRESULT	SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext );
> 
> 		
224a236
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
283a296
> 		HRESULT	Win9xInit( void );
293a307,308
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
294a310,311
> 		static	DWORD WINAPI	PrimaryWin9xThread( void *pParam );
> 		static	DWORD WINAPI	SecondaryWin9xThread( void *pParam );
296a314
> 		static	DWORD WINAPI	DialogThreadProc( void *pParam );
301a320,323
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
> 
> 		void	CheckWinsock1IO( const FD_SET *const pWinsock1Sockets );
> 		void	ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
13a14,15
> #include <WSIPX.h>
> 
39a42
> #include	"Creg.h"
40a44,47
> #include	"strutils.h"
> 
> #include	"resource.h"
> 
50a58,66
> #define DN_REG_LOCAL_SP_ROOT				L"Software\\Microsoft\\DirectPlay8"
> #define DN_REG_LOCAL_SP_SUB					L"\\Service Providers"
> #define DN_REG_LOCAL_SP_SUBKEY				DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB
> #define DN_REG_LOCAL_WSOCK_IPX_ROOT			L"\\DPNSPWinsockIPX"
> #define DN_REG_LOCAL_WSOCK_TCPIP_ROOT		L"\\DPNSPWinsockTCP"
> #define	DN_REG_KEYNAME_ALL_APPLICATIONS		L"All Applications"
> #define	DN_REG_KEYNAME_FRIENDLY_NAME		L"Friendly Name"
> #define DN_REG_KEYNAME_GUID					L"GUID"
> 
73c89,118
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
> 	DNSP_QueryInterface,
> 	DNSP_AddRef,
> 	DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Close,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
134a180,236
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to pointer to SP interface
> //				Pointer to pointer to associated SP data
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP, CSPData **const ppSPData )
> {
> 	HRESULT 	hr;
> 	CSPData		*pSPData;
> 
> 
> 	DNASSERT( ppiDNSP != NULL );
> 	DNASSERT( ppSPData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pSPData = NULL;
> 	*ppiDNSP = NULL;
> 	*ppSPData = NULL;
> 
> 	//
> 	// create main data class
> 	//
> 	hr = CreateSPData( &pSPData, &CLSID_DP8SP_IPX, TYPE_IPX, &ipxInterface );
> 	if ( hr != DPN_OK )
> 	{
> 		DNASSERT( pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( pSPData != NULL );
> 	*ppiDNSP = pSPData->COMInterface();
> 	*ppSPData = pSPData;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( pSPData != NULL )
> 	{
> 		pSPData->DecRef();
> 		pSPData = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
221a324,326
> 	//
> 	// we can either create an IPX instance or an IP instance
> 	//
227a333,336
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP, &pSPData );
> 	}
268c377
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return ( IsEqualCLSID( rclsid, CLSID_DP8SP_TCPIP ) || IsEqualCLSID( rclsid, CLSID_DP8SP_IPX ) );
359a469,719
> #define MAX_RESOURCE_STRING_LENGTH		_MAX_PATH
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "CDPVACMI::LoadAndAllocString"
> HRESULT LoadAndAllocString( UINT uiResourceID, wchar_t **lpswzString )
> {
> 	int length;
> 	HRESULT hr;
> 
> 	if( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
> 		wchar_t wszTmpBuffer[MAX_RESOURCE_STRING_LENGTH];	
> 		
> 		length = LoadStringW( g_hDLLInstance, uiResourceID, wszTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
> 
> 		if( length == 0 )
> 		{
> 			hr = GetLastError();		
> 			
> 			DPF( 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
> 			*lpswzString = NULL;
> 
> 			return hr;
> 		}
> 		else
> 		{
> 			*lpswzString = new wchar_t[length+1];
> 
> 			if( *lpswzString == NULL )
> 			{
> 				DPF( 0, "Alloc failure" );
> 				return DPNERR_OUTOFMEMORY;
> 			}
> 
> 			wcscpy( *lpswzString, wszTmpBuffer );
> 
> 			return DPN_OK;
> 		}
> 	}
> 	else
> 	{
> 		char szTmpBuffer[MAX_RESOURCE_STRING_LENGTH];
> 		
> 		length = LoadStringA( g_hDLLInstance, uiResourceID, szTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
> 
> 		if( length == 0 )
> 		{
> 			hr = GetLastError();		
> 			
> 			DPF( 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
> 			*lpswzString = NULL;
> 
> 			return hr;
> 		}
> 		else
> 		{
> 			*lpswzString = new wchar_t[length+1];
> 
> 			if( *lpswzString == NULL )
> 			{
> 				DPF( 0, "Alloc failure" );
> 				return DPNERR_OUTOFMEMORY;
> 			}
> 
> 			if( STR_jkAnsiToWide( *lpswzString, szTmpBuffer, length+1 ) == 0 )
> 			{
> 				hr = GetLastError();
> 				
> 				DPF( 0, "Unable to upconvert from ansi to unicode hr=0x%x", hr );
> 				return hr;
> 			}
> 
> 			return DPN_OK;
> 		}
> 		
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "RegisterDefaultSettings"
> //
> // RegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT RegisterDefaultSettings()
> {
> 	CRegistry creg;
> 	WCHAR *wszFriendlyName = NULL;
> 	HRESULT hr;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB DN_REG_LOCAL_WSOCK_IPX_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create IPX sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 
> 	creg.WriteString( DN_REG_KEYNAME_ALL_APPLICATIONS, L"Y" );
> 
> 	hr = LoadAndAllocString( IDS_FRIENDLYNAME_IPX, &wszFriendlyName );
> 
> 	if( FAILED( hr ) )
> 	{
> 		DPF( 0, "Could not load IPX name hr=0x%x", hr );
> 		return hr;
> 	}
> 
> 	// Load from resource file
> 	creg.WriteString( DN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );
> 
> 	delete [] wszFriendlyName;
> 
> 	creg.WriteGUID( DN_REG_KEYNAME_GUID, CLSID_DP8SP_IPX );
> 
> 	creg.Close();
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB DN_REG_LOCAL_WSOCK_TCPIP_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create TCPIP sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 
> 	creg.WriteString( DN_REG_KEYNAME_ALL_APPLICATIONS, L"Y" );
> 
> 	hr = LoadAndAllocString( IDS_FRIENDLYNAME_TCPIP, &wszFriendlyName );
> 
> 	if( FAILED( hr ) )
> 	{
> 		DPF( 0, "Could not load IPX name hr=0x%x", hr );
> 		return hr;
> 	}
> 
> 	// Load from resource file
> 	creg.WriteString( DN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );
> 
> 	delete [] wszFriendlyName;
> 
> 	creg.WriteGUID( DN_REG_KEYNAME_GUID, CLSID_DP8SP_TCPIP );
> 
> 	creg.Close();
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "UnRegisterDefaultSettings"
> //
> // UnRegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT UnRegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot remove app, does not exist" );
> 	}
> 	else
> 	{
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_WSOCK_IPX_ROOT)[1] ) )
> 		{
> 			DPFERR( "Cannot remove IPX sub-key, could have elements" );
> 		}
> 
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_WSOCK_TCPIP_ROOT)[1] ) )
> 		{
> 			DPFERR( "Cannot remove TCPIP sub-key, could have elements" );
> 		}
> 
> 	}
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8SPWSock.IPX.1", L"DirectPlay8 WSock IPX Provider Object", 
> 							  L"dpnwsock.dll", CLSID_DP8SP_IPX, L"DirectPlay8SPWSock.IPX") )
> 	{
> 		DPFERR( "Could not register dp8 IPX object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8SPWSock.TCPIP.1", L"DirectPlay8 WSock TCPIP Provider Object", 
> 							  L"dpnwsock.dll", CLSID_DP8SP_TCPIP, L"DirectPlay8SPWSock.TCPIP") )
> 	{
> 		DPFERR( "Could not register dp8 IP object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = RegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Could not register default settings hr = 0x%x", hr );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DP8SP_IPX) )
> 	{
> 		DPF( 0, "Failed to unregister IPX object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DP8SP_TCPIP) )
> 	{
> 		DPF( 0, "Failed to unregister IP object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = UnRegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Failed to remove default settings hr=0x%x", hr );
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
22a24
> #include	"DWinsock.h"
50,53d51
< // provides us winsock1/2 support
< #include "dwnsock1.inc"
< #include "dwnsock2.inc"
< 
80a79,80
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
> 
83a84
> static DWORD_PTR	OverrideWinsockVersion( void );
91a93,158
> // OverrideWinsockVersion - override the Winsock version used by the SP
> //
> // Entry:		Nothing
> //
> // Exit:		Max Winsock version to ask for
> // ------------------------------
> static DWORD_PTR	OverrideWinsockVersion( void )
> {
> 	DWORD_PTR	WinsockVersion;
> 
> 
> 	//
> 	// check for override for OS version and Winsock version
> 	//
> 	g_uOSType = DNGetOSType();
> 	WinsockVersion = 2;
> 
> 	switch ( GetProfileInt( "DirectPlay8", "WinsockVersion", 0 ) )
> 	{
> 		//
> 		// Use Winsock1.  If this is an NT machine, fake it into
> 		// thinking it's Win9x.
> 		//
> 		case 1:
> 		{
> 			if ( g_uOSType == VER_PLATFORM_WIN32_NT )
> 			{
> 				g_uOSType = VER_PLATFORM_WIN32_WINDOWS;
> 			}
> 			WinsockVersion = 1;
> 				
> 			break;
> 		}
> 
> 		//
> 		// Use Winsock2.  If this is an NT machine, fake it into
> 		// thinking it's Win9x.
> 		//
> 		case 2:
> 		{
> 			if ( g_uOSType == VER_PLATFORM_WIN32_NT )
> 			{
> 				g_uOSType = VER_PLATFORM_WIN32_WINDOWS;
> 			}
> 			DNASSERT( WinsockVersion == 2 );
> 
> 			break;
> 		}
> 
> 		//
> 		// OS default
> 		//
> 		default:
> 		{
> 			DNASSERT( WinsockVersion == 2 );
> 			break;
> 		}
> 	}
> 
> 	return	WinsockVersion;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
105a173,174
> 	INT			iVersion;
> 	DWORD_PTR	MaxWinsockVersion;
115a185,186
> 	MaxWinsockVersion = OverrideWinsockVersion();
> 
131c202
< 	// initialize Winsock
---
> 	// initialize the bindings to Winsock
133,139c204,205
< 	WORD wVersionRequested;
< 	WSADATA wsaData;
< 	int nRet;
< 
< 	wVersionRequested = MAKEWORD(2,2);
< 	nRet = p_WSAStartup(wVersionRequested, &wsaData);
< 	if (nRet || wVersionRequested != wsaData.wVersion)
---
> 	iVersion = DWSInitWinSock( &g_dwsState, MaxWinsockVersion );
> 	if ( iVersion == 0 )	// failure
141,143c207,209
< 		DPF( 0, "Problem starting winsock!" );
< 	    fReturn = FALSE;
< 	    goto Failure;
---
> 		DPF( 0, "Problem binding dynamic winsock functions!" );
> 		fReturn = FALSE;
> 		goto Failure;
145d210
< 
147a213,214
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
157c224,232
< 		p_WSACleanup();
---
> 		BOOL	fFreeReturn;
> 
> 
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 		if ( fFreeReturn == FALSE )
> 		{
> 			DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 		}
> 
187a263,265
> 	BOOL	fFreeReturn;
> 
> 
191c269,273
< 	p_WSACleanup();
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 	if ( fFreeReturn == FALSE )
> 	{
> 		DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 	}
198a281,293
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
199a295
> 
285a382
> 	INT_PTR iWinsockVersion;
295a393
> 	iWinsockVersion = GetWinsockVersion();
590a689,745
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // AddNetworkAdapterToBuffer - add a network address to a packed buffer
> //
> // Entry:		Pointer to packed buffer
> //				Pointer to adapter name
> //				Pointer to adapter guid
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	AddNetworkAdapterToBuffer( CPackedBuffer *const pPackedBuffer,
> 								   const char *const pAdapterName,
> 								   const GUID *const pAdapterGUID )
> {
> 	HRESULT	hr;
> 	DPN_SERVICE_PROVIDER_INFO	AdapterInfo;
> 
> 
> 	DNASSERT( pPackedBuffer != NULL );
> 	DNASSERT( pAdapterName != NULL );
> 	DNASSERT( pAdapterGUID != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	memset( &AdapterInfo, 0x00, sizeof( AdapterInfo ) );
> 	DNASSERT( AdapterInfo.dwFlags == 0 );
> 
> 	hr = pPackedBuffer->AddToBack( pAdapterGUID, sizeof( *pAdapterGUID ) );
> 	if ( ( hr != DPNERR_BUFFERTOOSMALL ) && ( hr != DPN_OK ) )
> 	{
> 		DPF( 0, "Failed to add socket address to buffer!" );
> 		goto Failure;
> 	}
> 	AdapterInfo.pGuid = static_cast<GUID*>( pPackedBuffer->GetTailAddress() );
> 
> 	pPackedBuffer->AddStringToBack( pAdapterName );
> 	if ( ( hr != DPNERR_BUFFERTOOSMALL ) && ( hr != DPN_OK ) )
> 	{
> 		DPF( 0, "Failed to add adapter name to buffer!" );
> 		goto Failure;
> 	}
> 	AdapterInfo.pwszName = static_cast<WCHAR*>( pPackedBuffer->GetTailAddress() );
> 
> 	pPackedBuffer->AddToFront( &AdapterInfo, sizeof( AdapterInfo ) );
> 
> Exit:
> 	return	hr;
> 
> Failure:
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
48a49,50
> INT		GetWinsockVersion( void );
> 
59a62,65
> 
> HRESULT	AddNetworkAdapterToBuffer( CPackedBuffer *const pPackedBuffer,
> 								   const char *const pAdapterName,
> 								   const GUID *const pAdapterGUID );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22
> #include	<WSIPX.h>
94,95d94
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
165a165,168
>  	switch ( pSPData->GetType() )
> 	{
> 		case TYPE_IP:
> 		{
167a171,186
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			DPF( 9, "Attempting to create IPX datagram socket." );
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
232a252
> 		case TYPE_IPX:
318a339
> 	IDirectPlay8Address		*pSPOnlyAddress;
326c347
< 	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );
---
> 	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );
341a363
> 	pSPOnlyAddress = NULL;
380a403,450
> 		HRESULT	hTempResult;
> 		GUID	SPGuid;
> 
> 
> 		//
> 		// get the SP
> 		//
> 		hTempResult = IDirectPlay8Address_GetSP( pDeviceAddress, &SPGuid );
> 		switch ( hTempResult )
> 		{
> 			//
> 			// no problem
> 			//
> 			case DPN_OK:
> 			{
> 				DNASSERT( hr == DPNERR_PENDING );
> 				break;
> 			}
> 
> 			//
> 			// pass these errors throug
> 			//
> 			case DPNERR_OUTOFMEMORY:
> 			{
> 				hr = hTempResult;
> 				goto Failure;
> 				break;
> 			}
> 
> 			//
> 			// remap other errors to addressing errors
> 			//
> 			default:
> 			{
> 				hr = DPNERR_ADDRESSING;
> 				goto Failure;
> 				break;
> 			}
> 		}
> 
> 		//
> 		// The host address is NULL, if we're using TCPIP and we're not allowed to query,
> 		// use the broadcast address.  If we're on IPX, use the broadcast address.
> 		//
> 		if ( ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
> 		{
382a453,500
> 		}
>         else
>         {
> 			HRESULT	hTempResult;
> 
> 
> 			//
> 			// Need to build address with just the SP guid.  Get it from the
> 			// device address.
> 			//
> 			DNASSERT( pSPOnlyAddress == NULL );
> 			hTempResult = COM_CoCreateInstance( CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>( &pSPOnlyAddress ) );
> 			if ( hTempResult != S_OK )
> 			{
> 				DPF( 0, "Failed to create SP-Only address when non was supplied!" );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			hTempResult = IDirectPlay8Address_SetSP( pSPOnlyAddress, &SPGuid );
> 			switch ( hTempResult )
> 			{
> 				//
> 				// set SP, no problem
> 				//
> 				case DPN_OK:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// failed to set SP, map error to an addressing error
> 				//
> 				default:
> 				{
> 					hr = DPNERR_ADDRESSING;
> 					goto Failure;
> 
> 					break;
> 				}
> 			}
> 
> 			pHostAddress = pSPOnlyAddress;
> 		}
514a633,665
> 			if ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) != 0 ) &&
> 				 ( pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// Copy the connect data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since the dialog is being popped, this command is in progress,
> 				// not pending.
> 				//
> 				DNASSERT( pSPData != NULL );
> 
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				pEndpoint->CopyEnumQueryData( pEnumQueryData );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for enum query!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove our reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
528a680,681
> 			}
> 
607a761,766
> 	if ( pSPOnlyAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pSPOnlyAddress );
> 		pSPOnlyAddress = NULL;
> 	}
> 
780c939
< 	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
---
> 	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
986a1146,1174
> 			if ( ( pConnectData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
> 			{
> 				//
> 				// Copy the connect data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since a dialog is being displayed, the command is in-progress,
> 				// not pending.
> 				//
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				pEndpoint->CopyConnectData( pConnectData );
> 				if ( ( hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() ) ) != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for connect!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove our reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
987a1176,1177
> 			}
> 
1251c1441
< 	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
---
> 	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
1457a1648,1680
> 			if ( ( pListenData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
> 			{
> 				//
> 				// Copy the listen data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since this endpoint is being handed off to another thread,
> 				// make sure it's in the unbound list.  Since a dialog is being
> 				// displayed, the command state is in progress, not pending.
> 				//
> 				DNASSERT( pSPData != NULL );
> 
> 				pEndpoint->CopyListenData( pListenData );
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for listen!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove out reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
1458a1682,1683
> 			}
> 
2425a2651,2662
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2642a2880,2891
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
6a7,8
>   DllRegisterServer PRIVATE
>   DllUnregisterServer PRIVATE
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\07281500.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\comutil.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\comutil.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\dndbg.c	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dndbg.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dneterrors.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\guidutil.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	1ece02cc	6bb05875
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\packbuff.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\packbuff.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\strutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\strutils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\appdesc.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\client.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\connect.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dllmain.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.def	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dnet.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\migration.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\msghandler.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\ntentry.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\peer.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\server.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\worker.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addbase.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addparse.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dllmain.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.def	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpsp8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\connect.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\enum.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\initialize.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\timer.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock1.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock2.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\locals.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\locals.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\rsip.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.def	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 96 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\callstack.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\memlog.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\dnmisc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\dpguid.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04241015.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04261045.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05010945.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05021600.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05031030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05081300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05091400.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05111530.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05121300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05151130.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05161345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05221345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05231030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06021030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06121345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06121445.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06141200.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06191100.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\07171100.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\07261030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\lastsync.bat	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\dplegacy.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\dplegacy.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\connect.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\directnet.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\directplay8core.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dnaddress.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dndbg.txt	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dnregister.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dp8context.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dp8protocol.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpaddress.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpclassinfo.xls	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpcustombuild.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplay8.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplay8.xls	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplobby8.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpnsvr.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpv8dmo.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoice.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoice.mpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoicenote.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\hostmigration.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\lobby8update.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\nametable.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\nametbl.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\rfc1738.txt	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\spintf.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\usercb.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\winsockspwireprotocol.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvlib.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvlib.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvrq.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvrq.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpnsvr.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpsvr8.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpsvr8.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\proctbl.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\proctbl.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\inc\dpnsdef.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\inc\dpnsvmsg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\inc\dplobby8.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\classfac.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\comstuff.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dllmain.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dnlobby.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplapp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplapp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplclient.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplclient.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplcommon.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplcommon.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconnect.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconnect.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconset.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconset.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplmsgq.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplmsgq.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby8int.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplparam.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplparam.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplproc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplproc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplreg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplreg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\globals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\handles.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\handles.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\contextfixedpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\handletable.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\handletable.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\registry.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\registry.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 228 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
3a4
>       lobby \
5c6,7
<       core
---
>       core \
>       dpnsvr 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\comutil.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include "creg.h"
23a25
> #include <stdlib.h>
38c40
<     WCHAR                   wszFileName[_MAX_PATH];
---
>     CHAR                    szFileName[_MAX_PATH];
122c124
<     hr = COM_GetDLLName( clsid, pEntry->wszFileName, &dwSize );
---
>     hr = COM_GetDLLName( clsid, pEntry->szFileName, &dwSize );
130c132
<     pEntry->hDLL = LoadLibraryW( pEntry->wszFileName );
---
>     pEntry->hDLL = LoadLibraryA( pEntry->szFileName );
164c166
< HRESULT COM_GetDLLName( GUID guidCLSID, WCHAR *wszPath, DWORD *pdwSize )
---
> HRESULT COM_GetDLLName( GUID guidCLSID, CHAR *szPath, DWORD *pdwSize )
166,170c168,170
< // BUGBUG: [mgere] [xbox] These com wrapper functions will only be called to
< // retrieve the wsock com object, so I hard coded the dpwsock.dll to always
< // return from this function.
< //
<     WCHAR wszDLL[] = L"dpnwsock.dll";
---
>     CRegistry cregRoot;
>     CRegistry cregCLSID;
>     CRegistry cregInProc;
172c172,177
<     wcscpy( wszPath, wszDLL);
---
>     HRESULT hr;
>     BOOL fSuccess;
>     WCHAR *wszTmpPath = NULL;
>     DWORD dwTmpSize = 0;
>     int res;
>     BOOL fDefault;
174c179
<     return S_OK;
---
>     fSuccess = cregRoot.Open( HKEY_CLASSES_ROOT, L"CLSID", TRUE, FALSE );
175a181,245
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening HKEY_CLASSES_ROOT\\CLSID" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     fSuccess = cregCLSID.Open( cregRoot, &guidCLSID, TRUE, FALSE );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening specified CLSID" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     fSuccess = cregInProc.Open( cregCLSID, L"InprocServer32", TRUE, FALSE );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening inprocserver key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     cregCLSID.Close();
>     cregRoot.Close();
> 
>     fSuccess = cregInProc.ReadString( L"", wszTmpPath, pdwSize );
> 
>     if( !*pdwSize )
>     {
>         DPF( 0, "Error opening default key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     wszTmpPath = new WCHAR[*pdwSize];
> 
>     fSuccess = cregInProc.ReadString( L"", wszTmpPath, pdwSize );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening default key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     if( FAILED( hr = STR_jkWideToAnsi(szPath,wszTmpPath, *pdwSize ) ) )
>     {
>         DPF( 0, "Error converting path to DLL to ANSI hr=0x%x", hr );
>         hr = E_FAIL;
>     }
> 
>     delete [] wszTmpPath;
> 
>     return hr;
> 
> COM_GETDLLNAME_ERROR:
> 
>     if( wszTmpPath )
>         delete [] wszTmpPath;
> 
>     return hr;
> 
192c262
< // BUGBUG: [mgere] [xbox] Added this temporarily
---
>     hr = CoCreateInstance( rclsid, pUnkOuter, dwClsContext, riid, ppv );
194,195c264,265
< COM_Init();
< 
---
>     if( hr == CO_E_NOTINITIALIZED )
>     {
217a288,291
> 
>         return hr;
> 
>     }
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\comutil.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21c21
< HRESULT COM_GetDLLName( GUID guidCLSID, WCHAR *szPath, DWORD *pdwSize );
---
> HRESULT COM_GetDLLName( GUID guidCLSID, CHAR *szPath, DWORD *pdwSize );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
29a37,65
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "UNKNOWN_MODULE"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectNet] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNetDebug"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dndbg.c)---()---()---()---()---()---()---()---()---()---()  
.  
.  
32a33
> #include "memlog.h"
38a40,185
> /*******************************************************************************
> 	Debug Logging to VXD.  In order to get this logging, DNET.VXD must be
> 	installed on the system.  This service is only available in the Win9x code
> 	base and can be installed by added the following to the system.ini file
> 	in the 386Enh section
> 
> 	[386Enh]
> 	device=dnet.vxd
> 
> 	This will enable a set of command under the debugger for dumping the
> 	log when broken into the debugger.  The commands can be initiated by
> 	typing .dnet at the ## prompt in the debugger.
> ==============================================================================*/
> /*
> BOOL DeviceIoControl(
> HANDLE hDevice, 			// handle to device of interest
> DWORD dwIoControlCode, 		// control code of operation to perform
> LPVOID lpInBuffer, 			// pointer to buffer to supply input data
> DWORD nInBufferSize, 		// size of input buffer
> LPVOID lpOutBuffer, 		// pointer to buffer to receive output data
> DWORD nOutBufferSize, 		// size of output buffer
> LPDWORD lpBytesReturned, 	// pointer to variable to receive output byte count
> LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
> );
> */
> 
> #define MAX_STRING       240
> #define LOG_SIZE         2000
> #define FIRST_DEBUG_PROC 100
> 
> #define OPEN_DEBUGLOG 	(FIRST_DEBUG_PROC)
> #define WRITE_DEBUGLOG 	(FIRST_DEBUG_PROC+1)
> #define WRITE_STATS     (FIRST_DEBUG_PROC+2)
> #define WSPRINTF		wsprintfA
> 
> typedef struct _LOGENTRY {
> 	CHAR	debuglevel;
> 	CHAR    str[1];
> } LOGENTRY, *PLOGENTRY;
> 
> typedef struct {
> 	UINT	nLogEntries;
> 	UINT    nCharsPerLine;
> } IN_LOGINIT, *PIN_LOGINIT;
> 
> typedef struct {
> 	UINT    hr;
> } OUT_LOGINIT, *POUT_LOGINIT;
> 
> typedef struct {
> 	CHAR	debuglevel;
> 	CHAR    str[1];
> } IN_LOGWRITE, *PIN_LOGWRITE;
> 
> typedef struct {
> 	UINT	hr;
> } OUT_LOGWRITE, *POUT_LOGWRITE;
> 
> 
> HANDLE hLoggingVxd=0;
> HANDLE hLogMutex=0;
> HANDLE hLogFile=0;
> PSHARED_LOG_FILE pLogFile=0;
> 
> /*===========================================================================
> 
> 	Debug Support.
> 
> 	Logging:
> 	========
> 
> 	Debug Logging and playback is designed to operate on both Win9x and
> 	Windows NT (Windows 2000).  On Win9x, a support VXD is used to extend
> 	the kernel debugger.  The VXD (DNET.VXD) is used for both logging and
> 	playback of debug buffers.  In addition to the debug VXD there is also
> 	logging to a shared file.  The shared file logging is played back with
> 	the DNLOG.EXE utility and can be played back on either Windows2000 or
> 	Win9x.
> 
> 	Debug support for dumping structures on Win9x is supported only in the
> 	DNET.VXD component.  Dumping of structures internal to DPLAY can only
> 	be done from the context of a DPLAY thread.  This is because the
> 	addresses are only valid in that context.  Under NT there is (will be)
> 	a debug extension for dumping internal structures.
> 
> 	Debug Logging is controlled by settings in the win.ini file.  Under
> 	the section heading [DirectPlay8].  There are 2 settings:
> 
> 	Debug=9
> 
> 	controls the debug level.  All messages, at or below that debug level
> 	are printed.
> 
> 	The second setting (logging).  If not specified, all debugs are spewed
> 	through the standard DebugPrint and will appear on in DEVSTUDIO if
> 	it is up, or on the kernel debugger if it is running.
> 
> 	log = 0 {no debug output}
> 	log = 1	{spew to console only}
> 	log = 2 {spew to log only}
> 	log = 3 {spew to console and log}
> 
> 	example win.ini...
> 
> 	[DirectPlay8]
> 	Debug=7		; lots of spew
> 	log=2		; don't spew to debug window
> 
> 	[DirectPlay8]
> 	Debug=0		; only fatal errors spewed to debug window
> 
> 	Asserts:
> 	========
> 	Asserts are used to validate assumptions in the code.  For example
> 	if you know that the variable jojo should be > 700 and are depending
> 	on it in subsequent code, you SHOULD put an assert before the code
> 	that acts on that assumption.  The assert would look like:
> 
> 	ASSERT(jojo>700);
> 
> 	Asserts generally will produce 3 lines of debug spew to highlight the
> 	breaking of the assumption.  For testing, you might want to set the
> 	system to break in on asserts.  This is done in the [DirectPlay8] section
> 	of win.ini by setting BreakOnAssert=TRUE
> 
> 	e.g.
> 
> 	[DirectPlay8]
> 	Debug=0
> 	BreakOnAssert=TRUE
> 	Verbose=1
> 
> 	Debug Breaks:
> 	=============
> 	When something really severe happens and you want the system to break in
> 	so that you can debug it later, you should put a debug break in the code
> 	path.  Some people use the philosophy that all code paths must be
> 	verified by hand tracing each one in the debugger.  If you abide by this
> 	you should place a DEBUG_BREAK() in every code path and remove them
> 	from the source as you trace each.  When you have good coverage but
> 	some unhit paths (error conditions) you should force those paths in
> 	the debugger.
> 
> 
> ===========================================================================*/
> 
41c188,195
< DWORD lDebugLevel = 1;	
---
> 
> DWORD lDebugLevel = 0;	
> 
> DWORD dwLogging   = 1;	// 0 => No debug spew
> 						// 1 => Spew to console only (default)
> 						// 2 => Spew to log only
> 						// 3 => Spew to console and log
> 
43d196
< DWORD bVerbose = FALSE;	// if TRUE, all file/line/module information is printed and logged.
44a198,204
> // if TRUE, all file/line/module information is printed and logged.
> DWORD bVerbose = FALSE;	
> BOOL  bLiveLogging = FALSE;
> 
> // if TRUE messages printed with the LOGPF will be logged, if FALSE they're ignored
> DWORD  lOutputLog = 0;
> 
54a215,218
> //  7/24/00(RichGr) - IA64: If g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS,
> //     we're running under Win9x.
> DWORD       g_dwPlatformId;
> 
65a230,353
> // open up a channel to the DirectNet VXD (DNET.VXD) that will allows
> // the log to be written to the VxD through DeviceIoControl calls.  The
> // log in this case is accessible in the Win9x kernel debugger through
> // the .dnet debugger extensions.
> void InitDirectNetVxd(void)
> {
> 	IN_LOGINIT In;
> 	OUT_LOGINIT Out;
> 	UINT cbRet;
> 
> 	// note we rely on the system automatically closing this
> 	// handle for us when the user mode application exits.
> 	hLoggingVxd = CreateFileA("\\\\.\\DNET",0,0,0,0,0,0);
> 
> 	if(hLoggingVxd != INVALID_HANDLE_VALUE){
> 
> 		In.nCharsPerLine=MAX_STRING;
> 		In.nLogEntries=5000;
> 		DeviceIoControl(hLoggingVxd,
> 						OPEN_DEBUGLOG,
> 						&In,sizeof(In),
> 						&Out, sizeof(Out),
> 						&cbRet, NULL);
> 	} else {
> 		hLoggingVxd=0;
> 	}
> }
> 
> // Write a string to the log in the debug support VxD.  This only
> // operates on Win9x, when the DNET.VXD is installed.
> static void VxdLogString( LPSTR str )
> {
> 	char logstring[MAX_STRING+sizeof(LOGENTRY)];
> 	int  i=0;
> 	PLOGENTRY pLogEntry=(PLOGENTRY)&logstring;
> 	UINT rc;
> 	UINT cbRet;
> 	int maxlen = MAX_STRING+sizeof(LOGENTRY);
> 
> 	if(hLoggingVxd && str){
> 		while(str[i] && i < maxlen)
> 			i++;
> 		pLogEntry->debuglevel=0;
> 		memcpy(pLogEntry->str,str,i+1);
> 		DeviceIoControl(hLoggingVxd,WRITE_DEBUGLOG,pLogEntry,i+sizeof(LOGENTRY), &rc, sizeof(rc), &cbRet, NULL);
> 	}
> }
> 
> // Create a shared file for logging information on the fly
> // This support allows the current log to be dumped from the
> // user mode DPLOG.EXE application.  This is useful when debugging
> // in MSSTUDIO or in NTSD.  When the DPLOG.EXE is invoke, note that
> // the application will get halted until the log is completely dumped
> // so it is best to dump the log to a file.
> static BOOL InitMemLogString(VOID)
> {
> 	static BOOL inited = FALSE;
> 
> 	if(!inited){
> 		hLogFile=CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, DPLOG_SIZE, BASE_LOG_FILENAME);
> 		hLogMutex=CreateMutexA(NULL,FALSE,BASE_LOG_MUTEXNAME);
> 		pLogFile=(PSHARED_LOG_FILE)MapViewOfFile(hLogFile, FILE_MAP_ALL_ACCESS,0,0,0);
> 
> 		if(!hLogFile || !hLogMutex || !pLogFile){
> 			if(hLogFile){
> 				CloseHandle(hLogFile);
> 				hLogFile=0;
> 			}
> 			if(hLogMutex){
> 				CloseHandle(hLogMutex);
> 				hLogMutex=0;
> 			}
> 			if(pLogFile){
> 				UnmapViewOfFile(pLogFile);
> 				pLogFile=NULL;
> 			}
> 			return FALSE;
> 		} else {
> 			inited = TRUE;
> 			pLogFile->nEntries = DPLOG_NUMENTRIES;
> 			pLogFile->cbLine   = DPLOG_ENTRYSIZE;
> 			pLogFile->iWrite   = 0;
> 			pLogFile->cInUse   = 0;
> 		}
> 	}
> 	return TRUE;
> }
> 
> // Log a string to a shared file.  This file can be dumped using the
> // DPLOG.EXE utility.
> static void MemLogString(LPSTR str)
> {
> 	PLOG_ENTRY pEntry;
> 	DWORD cbCopy;
> 
> 	if(!hLogFile){
> 		if(!InitMemLogString()){
> 			return;
> 		}
> 	}
> 
> 	WaitForSingleObject(hLogMutex,INFINITE);
> 
> 	pEntry=(PLOG_ENTRY)(((PUCHAR)(pLogFile+1))+(pLogFile->iWrite*(sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)));
> 	pEntry->hThread=GetCurrentThreadId();
> 	pEntry->tLogged=timeGetTime();
> 	pEntry->DebugLevel=0;
> 
> 	cbCopy=strlen(str)+1;
> 	if(cbCopy > DPLOG_ENTRYSIZE){
> 		str[DPLOG_ENTRYSIZE]=0;
> 		cbCopy=DPLOG_ENTRYSIZE;
> 	}
> 	memcpy(pEntry->str, str, cbCopy);
> 
> 	if(pLogFile->iWrite+1 > pLogFile->cInUse){
> 		pLogFile->cInUse=pLogFile->iWrite+1;
> 	}
> 
> 	pLogFile->iWrite = (pLogFile->iWrite+1) % pLogFile->nEntries;
> 	ReleaseMutex(hLogMutex);
> 
> }
> 
68a357,360
> 	DWORD           lSpecificLevel;
>     OSVERSIONINFO   OSVersionInfo = {0};
> 
> 
72a365,406
>     lDebugLevel = (signed int) GetProfileIntA( PROF_SECT, "debug", 0 );
>     lSpecificLevel = (signed int) GetProfileIntA( PROF_SECT, DPF_MODULE_NAME, -1);
>     if(lSpecificLevel != -1){
>     	lDebugLevel = lSpecificLevel;
>     }
>     dwLogging   = (signed int) GetProfileIntA( PROF_SECT, "log" , 0);
>     bBreakOnAssert = (signed int) GetProfileIntA( PROF_SECT, "BreakOnAssert", 0);
>     bVerbose = (signed int) GetProfileIntA( PROF_SECT, "Verbose", 0);
> 
>     lOutputLog = (signed int) GetProfileIntA( PROF_SECT, "OutputLog", 0);
> 
> 	switch(dwLogging){
> 		case 0:
> 			bLiveLogging=FALSE;
> 			break;
> 		case 1:
> 			bLiveLogging=TRUE;
> 			break;
> 		case 2:
> 			bLiveLogging=FALSE;
> 			break;
> 		case 3:
> 			bLiveLogging=TRUE;
> 			break;
> 		default:
> 			break;
> 	}
> 	if((dwLogging >= 2)||(lOutputLog > 0)){
> 		// Doing log based logging, so try to find the VXD and open
> 		// the shared logging file.
> 		InitDirectNetVxd();
> 
> 		// Do logging also based on shared memory file.
> 		InitMemLogString();	
> 	}
> 
> //  7/24/00(RichGr) - IA64: Detect whether we're running under Win9x.  Get the Windows version.
> //     If dwPlatformId == VER_PLATFORM_WIN32_WINDOWS, that's Win9x.
>     OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
>     GetVersionEx(&OSVersionInfo);
>     g_dwPlatformId = OSVersionInfo.dwPlatformId;
> 
73a408
> 
79a415,420
> 	if(hLogFile){
> 		CloseHandle(hLogFile);
> 	}
> 	if(hLoggingVxd){
> 		CloseHandle(hLoggingVxd);
> 	}	
128a470,471
> 		if(bLiveLogging)
> 		{
131a475,485
> 		}
> 
> 		if(hLoggingVxd){
> 			// log to vxd
> 			VxdLogString( str );
> 		}
> 
> 		if(dwLogging >= 2){
> 			// log to shared file
> 			MemLogString( str );
> 		}
135c489,491
< //  5/23/2000(RichGr): IA64: Change DWORD to DWORD_PTR.
---
> // 05/23/2000(RichGr): IA64: Change DWORD to DWORD_PTR.
> // 07/16/2000(jchauvin): IA64:  Added %p parsing to change back to %x for Win9x machines
> 
137a494
> 	CHAR  cTemp[MAX_PATH];
139c496
< 
---
>     char  *psz = NULL;
141a499
> 
154a513,523
> //  7/24/00(RichGr) - IA64: If g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS,
> //     we're running under Win9x and need to replace %p with %x.
>     if (g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
>     {
>         strcpy(cTemp, szFormat);                // Copy to a local string that we can modify.
> 	    szFormat = cTemp;					    // Point szFormat at the local string
> 
>         while (psz = strstr(szFormat, "%p"))    // Look for each "%p".
>            *(psz+1) = 'x';                      // Substitute 'x' for 'p'.  Don't try to expand 
>     }
> 
173c542
< 	WSPRINTF(cMsg+strlen( cMsg ), szFormat, argptr);
---
> 	WSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);
184a554,555
> // 07/16/2000(jchauvin): IA64:  Added %p parsing to change back to %x for Win9x machines
> 
187a559
> 	CHAR  cTemp[MAX_PATH];
189c561
< 
---
>     char  *psz = NULL;
191a564
> 
206a580,590
> //  7/24/00(RichGr) - IA64: If g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS,
> //     we're running under Win9x and need to replace %p with %x.
>     if (g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
>     {
>         strcpy(cTemp, szFormat);                // Copy to a local string that we can modify.
> 	    szFormat = cTemp;					    // Point szFormat at the local string
> 
>         while (psz = strstr(szFormat, "%p"))    // Look for each "%p".
>            *(psz+1) = 'x';                      // Substitute 'x' for 'p'.  Don't try to expand 
>     }
> 
225c609
< 	WVSPRINTF(cMsg+strlen( cMsg ), szFormat, argptr);
---
> 	WVSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);
233a618,668
> /*
> **	LogPrintf copies a quick Log Entry to the
> **
> */
> 
> //  5/23/2000(RichGr): IA64: Change DWORD to DWORD_PTR.
> // 07/16/2000(jchauvin): IA64:  Added %p parsing to change back to %x for Win9x machines
> void LogPrintf(volatile DWORD_PTR dwDetail, ...)
> {
> 	CHAR  cMsg[1000];
> 	CHAR  cTemp[MAX_PATH];
> 	LPSTR szFormat;
>     char  *psz = NULL;
> 	va_list argptr;
> 
> 
> 	if(lOutputLog < dwDetail){
> 		LeaveCriticalSection(&csDPF);
> 		return;
> 	}
> 
> 	//EnterCriticalSection(&csDPF);
> 
> 	va_start(argptr, dwDetail);
> 	szFormat = (LPSTR) va_arg(argptr, DWORD_PTR);
> 
> 
> 	cMsg[0]=0;
> 
> //  7/24/00(RichGr) - IA64: If g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS,
> //     we're running under Win9x and need to replace %p with %x.
>     if (g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
>     {
>         strcpy(cTemp, szFormat);                // Copy to a local string that we can modify.
> 	    szFormat = cTemp;				        // Point szFormat at the local string
> 
>         while (psz = strstr(szFormat, "%p"))    // Look for each "%p".
>             *(psz+1) = 'x';                     // Substitute 'x' for 'p'.  Don't try to expand 
>     }
> 
> 	WSPRINTF(cMsg,"%s: ",g_szModName);
> 
> 	WVSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);
> 
> 	MemLogString( (LPSTR) cMsg );
> 
> 	LeaveCriticalSection(&csDPF);
> 
> 	va_end(argptr);
> }
> 
240a676,677
> #define ASSERT_BREAK_SECTION "BreakOnAssert"
> #define ASSERT_BREAK_DEFAULT FALSE
263c700
<     if( bBreakOnAssert )
---
>     if( bBreakOnAssert || GetProfileIntA( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
332a770,790
> }
> 
> BOOL IsValidStringA( const CHAR * const szString )
> {
> 	const char *szTmpLoc = szString;
> 	
> 	if( szString == NULL )
> 	{
> 		return FALSE;
> 	}
> 
> 	_try
> 	{
> 		for( ; *szTmpLoc ; szTmpLoc++ );
> 	}
> 	_except( EXCEPTION_EXECUTE_HANDLER )
> 	{
> 		return FALSE;
> 	}
> 
> 	return TRUE;
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dndbg.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
29a30,32
> 	#if defined( _WIN32 ) && !defined(WINNT) && defined(_X86_)
> 		#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
> 	#else
30a34
> 	#endif
102a107
> extern BOOL IsValidStringA( const CHAR * const swzString );
111a117
> extern void LogPrintf(volatile DWORD_PTR dwDetail, ...);
112a119
> #define DNVALID_STRING_A(a)		IsValidStringA(a)
127c134,138
< #define	LOGPF		DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
---
> #ifdef DPF_SUBCOMP_MASK
> 	#define DPFSC if(DPF_SUBCOMP_MASK & DPF_SUBCOMP_BIT)DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),if(DPF_SUBCOMP_MASK & DPF_SUBCOMP_BIT)DebugPrintf
> #else
> 	#define DPFSC DPF
> #endif
128a140,141
> #define	LOGPF		DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),LogPrintf
> 
133a147
> 	#define DNVALID_STRING_A(a)			(TRUE)
139a154
> 	#define DPFSC()
148,149c163,166
< #define WVSPRINTF wvsprintf
< #define STRLEN   strlen
---
> #define WVSPRINTF wvsprintfA
> #define STRLEN   lstrlenA
> 
> #define PROF_SECT "DirectPlay8"
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dneterrors.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20,23
> // vanceo - changed to stdio for printf
> //#include	<iostream.h>
> #include	<stdio.h>
> 
78a83,92
> 			// output to console
> 			case DPNERR_OUT_CONSOLE:
> 			{
> 				// Also see the change from <iostream.h> to <stdio.h> above
> 				#pragma TODO(vanceo, "Changed cout to printf so NT build environment will work, figure this out.")
> 				//cout << endl << pString << endl;
> 				printf("\n%s\n", pString);
> 				break;
> 			}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\guidutil.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
15c15
< #include <wchar.h>
---
> #include "stdio.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34,37
> #ifdef	_WIN64
> #define	MEMORY_CRC			0X5AA55AA55AA55AA5
> #define	GUARD_SIGNATURE		0x0F1E2D3C4B5A6978
> #else
35a40
> #endif	// _WIN64
40a46,52
> //
> // enumerated values to indicate how to report memory leaks
> //
> #define	MEMORY_LEAK_REPORT_NONE		0x00000000
> #define	MEMORY_LEAK_REPORT_DPF		0x00000001
> #define	MEMORY_LEAK_REPORT_DIALOG	0x00000002
> 
60a73
> #ifdef	_X86_
61a75,77
> #else
> #define	ASSERT( arg )	if ( arg == FALSE ) { DebugBreak(); }
> #endif
94a111,116
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
> static	HINSTANCE			g_hApplicationInstance;
> 
> //
103a126,128
> static int	DisplayCallStack( const char *const pszMsg,
> 							  const char *const pszTitle,
> 							  const char *const pCallStack );
121a147
> 	OSVERSIONINFO	OSVersionInfo;
122a149
> 
130a158,186
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
> 	// note application instance
> 	//
> 	g_hApplicationInstance = GetModuleHandle( NULL );
> 	if ( g_hApplicationInstance == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to GetModuleHandle: 0x%x", dwError );
> 		goto Failure;
> 	}
> 
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
> 	//
229a286,287
> 		switch ( DNGetOSType() )
> 		{
232a291,292
> 			case VER_PLATFORM_WIN32_NT:
> 			{
256a317,327
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
289a361,392
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetApplcationInstance - application instance
> //
> // Entry:		Nothing
> //
> // Exit:		Application instance
> // ------------------------------
> HINSTANCE	DNGetApplicationInstance( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_hApplicationInstance;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
360a464
> //#ifdef	_WIN32
389a494
> //#endif	// _WIN32
390a496,517
> 
> //#ifdef	_WIN64
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	if ( pTime1->Time < pTime2->Time )
> //	{
> //		iReturnValue = -1;
> //	}
> //	else
> //	{
> //		if ( pTime1->Time == pTime2->Time )
> //		{
> //			iReturnValue = 0;
> //		}
> //		else
> //		{
> //			iReturnValue = 1;
> //		}
> //	}
> //#endif	// _WIN64
> 
416a544
> #ifdef	_X86_
428a557,607
> 
> #else	// _X86_
> 
> /*
> #ifdef	_ALPHA_
> 	// debug me
> 	DebugBreak();
> 
> 	__asm{ mov	$t0, *pTime1
> 		   mov	$t1, *pTime2
> 		   addq	$t0, $t1
> 		   mov	*pTimeResult, $t0
> 	};
> #else	// _ALPHA_
> */
> 
> //#ifdef	_WIN32
> 	DWORD	dwTempLowTime;
> 
> 
> 	dwTempLowTime = pTime1->Time32.TimeLow;
> 	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow + pTime2->Time32.TimeLow;
> 	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh + pTime2->Time32.TimeHigh;
> 
> 	//
> 	// check for overflow in low 32-bits and increment high value if applicable
> 	//
> 	if ( pTimeResult->Time32.TimeLow < dwTempLowTime )
> 	{
> #pragma	BUGBUG( johnkan, "Test this!" )
> 		// debug me
> 		DebugBreak();
> 		pTimeResult->Time32.TimeHigh++;
> 	}
> //#endif	// _WIN32
> 
> //#ifdef	_WIN64
> //	DEBUG_ONLY( UINT_PTR	ReferenceTime );
> //
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	DEBUG_ONLY( ReferenceTime = pTime1->Time );
> //	*pTimeResult = pTime1->Time + pTime2->Time;
> //	DNASSERT( *pTimeResult >= ReferenceTime );
> //
> //#endif	// _WIN64
> 
> // #endif	// _ALPHA_
> 
> #endif	// _X86_
454a634,635
> #ifdef	_X86_
> 
466a648,694
> 
> #else	// _X86_
> 
> /*
> #ifdef	_ALPHA_
> 	// debug me
> 	DebugBreak();
> 
> 	mov		$t0, *pTime1
> 	mov		$t1, *pTime2
> 	addq	$t0, $t1
> 	mov		*pTimeResult, $t0
> #else	// _ALPHA_
> */
> 
> //#ifdef	_WIN32
> 	DWORD	dwTempLowTime;
> 
> 
> 	dwTempLowTime = pTime1->Time32.TimeLow;
> 	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow - pTime2->Time32.TimeLow;
> 	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh - pTime2->Time32.TimeHigh;
> 
> 	//
> 	// check for underflow in low 32-bits and decrement high value if applicable
> 	//
> 	if ( pTimeResult->Time32.TimeLow > dwTempLowTime )
> 	{
> #pragma	BUGBUG( johnkan, "Test this!" )
> 		// debug me
> 		DebugBreak();
> 
> 		pTimeResult->Time32.TimeHigh--;
> 	}
> //#endif	// _WIN32
> 
> //#ifdef	_WIN64
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	DNASSERT( pTime1->Time > pTime2->Time );
> //	pTimeResult = pTime1->Time - pTime2->Time;
> //#endif	// _WIN64
> 
> // #endif	// _ALPHA_
> 
> #endif	// _X86_
687a916,918
> 		void	NoteCurrentCallStack( void ) { m_CallStack.NoteCurrentCallStack(); }
> 		void	GetCallStack( char *const pBuffer ) const { m_CallStack.GetCallStackString( pBuffer ); }
> 
706a938
> 		CCallStack<DN_MEMORY_CALL_STACK_DEPTH>	m_CallStack;
797a1030
> 		pMemoryLink->NoteCurrentCallStack();
907a1141
> 	char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
941,942c1175,1186
< 			DPF( 0, "%s%s\n", "Memory Corruption!", MessageString );
< //					DNASSERT( FALSE );
---
> 			pMemoryLink->GetCallStack( CallStackBuffer );
> 			MessageReturn = DisplayCallStack( MessageString, "Memory Corruption!", CallStackBuffer );
> 			switch ( MessageReturn )
> 			{
> 				case IDABORT:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				case IDIGNORE:
> 				{
946a1191,1199
> 					break;
> 				}
> 
> 				case IDRETRY:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
977a1231
> 	DWORD		dwDisplayFlags;
978a1233
> 
981a1237
> 	fDisplayLeaks = TRUE;
984a1241,1242
> 	dwDisplayFlags = GetProfileIntA( PROF_SECT, "MemoryLeakOutput", MEMORY_LEAK_REPORT_DPF );
> 	
991a1250
> 		char		CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
1004,1005c1263
< 			DPF( 0, "%s%s\n", DialogTitle, LeakSizeString );
< //						DNASSERT( FALSE );
---
> 		pTemp->GetCallStack( CallStackBuffer );
1006a1265,1315
> 
> 		if ( ( dwDisplayFlags & MEMORY_LEAK_REPORT_DPF ) != 0 )
> 		{
> 			DPF( 0, "%s%s%s\n", DialogTitle, LeakSizeString, CallStackBuffer );
> 		}
> 
> 		if ( ( dwDisplayFlags & MEMORY_LEAK_REPORT_DIALOG ) != 0  )
> 		{
> 			if ( fDisplayLeaks != FALSE )
> 			{
> 				MessageReturn = DisplayCallStack( LeakSizeString, DialogTitle, CallStackBuffer );
> 				switch ( MessageReturn )
> 				{	
> 					//
> 					// stop application now
> 					//
> 					case IDABORT:
> 					{
> 						fDisplayLeaks = FALSE;
> 						break;
> 					}
> 
> 					//
> 					// display next leak
> 					//
> 					case IDIGNORE:
> 					{
> 						break;
> 					}
> 
> 					//
> 					// stop in the debugger
> 					//
> 					case IDRETRY:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 
> 					//
> 					// unknown
> 					//
> 					default:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 				}
> 			}
> 		}
> 
1019a1329,1472
> 
> 
> #if	defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
> //**********************************************************************
> //**
> //** THIS IS THE STACK TRACKING SECTION.  ONLY ADD FUNCTIONS HERE THAT ARE
> //** RELATED TO TRACKING THE CALL STACK!!
> //**
> //**********************************************************************
> 
> 
> ////**********************************************************************
> //// ------------------------------
> //// DNGetStackTop - return pointer to top of stack
> ////
> //// Entry:		Nothing
> ////
> //// Exit:		Pointer to top of stack
> //// ------------------------------
> //static void	*DNGetStackTop( void )
> //{
> //	void	*pReturn;
> //
> //	_asm	mov eax,dword ptr fs:[4]
> //	_asm	mov pReturn, eax
> //	return	pReturn;
> //}
> ////**********************************************************************
> //
> //
> ////**********************************************************************
> //// ------------------------------
> //// DNGetStackBottom - return pointer to bottom of call stack
> ////
> //// Entry:		Nothing
> ////
> //// Exit:		Pointer to bottom of call stack
> //// ------------------------------
> //static void	*DNGetStackBottom( void )
> //{
> //	void	*pReturn;
> //
> //	_asm	mov eax,dword ptr fs:[8]
> //	_asm	mov pReturn, eax
> //	return	pReturn;
> //}
> ////**********************************************************************
> 
> 
> ////**********************************************************************
> //// ------------------------------
> //// DNGetCallStack - get a call stack
> ////
> //// Entry:		Pointer to call stack array
> ////				Number of calls to report
> ////
> //// Exit:		Nothing
> //// ------------------------------
> //static	void	DNGetCallStack( const void **const pCallStack, const UINT_PTR Depth )
> //{
> //	void		**CallersEBP;
> //	void		*ReturnAddr;
> //	UINT_PTR	i,iCount;
> //	void		*StackTop;
> //	void		*StackBottom;
> //	static const	void	*min_dll_base = NULL;
> //
> //
> //	StackTop = DNGetStackTop();
> //	StackBottom = DNGetStackBottom();
> //	memset(	pCallStack, 0x00, sizeof( *pCallStack ) * Depth );
> //
> //	_asm
> //	{
> //		mov eax,[ebp]
> //		mov CallersEBP,eax
> //	}
> //
> //	__try
> //	{
> //		//
> //		// this code can generate exception if it steps back too far...
> //		//
> //		for ( i = 0, iCount = 0; i < Depth; iCount++ )
> //		{
> //			if ( ( CallersEBP < StackBottom ) || ( CallersEBP >= StackTop ) )
> //				break;
> //			ReturnAddr = CallersEBP[ 1 ];
> //			if ( ( iCount > 0 ) || ( ReturnAddr >= min_dll_base ) ) // iCount check skips memory_alloc_debug
> //				pCallStack[ i++ ] = ReturnAddr;
> //			CallersEBP = reinterpret_cast<void**>( *CallersEBP ); // get callers callers ebp
> //		}
> //	}
> //	__except( 1 )  // went too far back on the stack, fill up rest of array with zeros
> //	{
> //		DPF( 0, "Benign access violation creating return address stack." );
> //	}
> //}
> ////**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DisplayCallStack - display a call stack message box
> //
> // Entry:		Pointer to information string
> //				Pointer to title string
> //				Pointer to call stack string
> //
> // Exit:		Dialog return code
> // ------------------------------
> static int	DisplayCallStack( const char *const pszMsg, const char *const pszTitle, const char *const pCallStackString )
> {
> 	MSGBOXPARAMS	MessageBoxParams;
> 	char 			szStackTraceMsg[ CALLSTACK_BUFFER_SIZE ];
> 
> 
>     strcpy( szStackTraceMsg, pszMsg );
> 	strcat( szStackTraceMsg, pCallStackString );
> 
> 	//
> 	// display message box
> 	//
> 	memset( &MessageBoxParams, 0x00, sizeof( MessageBoxParams ) );
> 	MessageBoxParams.cbSize = sizeof( MessageBoxParams );
> 	MessageBoxParams.lpszText = szStackTraceMsg;
> 	MessageBoxParams.lpszCaption = pszTitle;
> 	MessageBoxParams.dwStyle = MB_ABORTRETRYIGNORE | MB_SETFOREGROUND | MB_TOPMOST | MB_DEFBUTTON2;
> 	MessageBoxParams.hInstance = NULL;
> 
> 	return MessageBoxIndirect( &MessageBoxParams );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> //**
> //** END OF CALL STACK TRACKING SECTION.
> //**
> //**********************************************************************
> #endif	// defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
> 
> 
> 
1114a1568
> 	static	BOOL	fDisplayCallStacks = TRUE;
1132a1587,1590
> 	if ( pCriticalSection->LockCount == 0 )
> 	{
> 		pCriticalSection->CallStack.NoteCurrentCallStack();
> 	}
1138a1597,1601
> 			if ( fDisplayCallStacks != FALSE )
> 			{
> 				char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
> 
> 
1143,1144c1606,1638
< 			    DPF( 0, "%s%s\n", "DNCritical section has been reentered!", "Check stack trace for function that originally held the lock." );
< //						DNASSERT( FALSE );
---
> 				pCriticalSection->CallStack.GetCallStackString( CallStackBuffer );
> 				switch ( DisplayCallStack( "Stack trace of function that originally held the lock:",
> 										   "DNCritical section has been reentered!",
> 										   CallStackBuffer ) )
> 				{
> 					//
> 					// don't display any more critical section warnings!
> 					//
> 					case IDABORT:
> 					{
> 						fDisplayCallStacks = FALSE;
> 						break;
> 					}
> 
> 					//
> 					// acknowledged
> 					//
> 					case IDIGNORE:
> 					{
> 						break;
> 					}
> 
> 					//
> 					// stop in debugger
> 					//
> 					case IDRETRY:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 				}
> 			}
> 
1177a1672
> 		memset( &pCriticalSection->CallStack, 0x00, sizeof( pCriticalSection->CallStack ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18,19
> #include	"CallStack.h"
> 
29a32,34
> #define	DN_MEMORY_CALL_STACK_DEPTH				12
> #define	DN_CRITICAL_SECTION_CALL_STACK_DEPTH	10
> 
53a59
> 	CCallStack< DN_CRITICAL_SECTION_CALL_STACK_DEPTH > 	CallStack;
85a92,101
> 
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
> HINSTANCE	DNGetApplicationInstance( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\packbuff.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
136a137,207
> // CPackedBuffer::AddStringToBack
> //
> // Entry:		Pointer to source string
> //
> // Exit:		Error Code:	DPN_OK					if able to add
> //							DPNERR_BUFFERTOOSMALL	if buffer is full
> // ------------------------------
> 
> HRESULT CPackedBuffer::AddStringToBack( const char *const pszString )
> {
> 	HRESULT	hr;
> 	DWORD	dwStringSize;
> 	DWORD	dwBufferSize;
> 
> 
> 	DNASSERT( pszString != NULL );
> 	
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	dwStringSize = 0;
> 	hr = STR_AnsiToWide( pszString,
> 						 -1,
> 						 NULL,
> 						 &dwStringSize );
> 	if ( hr != DPNERR_BUFFERTOOSMALL )
> 	{
> 		DNASSERT( hr != DPN_OK );
> 		goto Failure;
> 	}
> 	
> 	dwBufferSize = dwStringSize * sizeof( WCHAR );
> 	m_dwRequired += dwBufferSize;
> 	if ( !m_bBufferTooSmall )
> 	{
> 		if (m_dwRemaining >= dwBufferSize)
> 		{
> 			m_pTail -= dwBufferSize;
> 			m_dwRemaining -= dwBufferSize;
> 			hr = STR_AnsiToWide( pszString,
> 								 -1,
> 								 reinterpret_cast<WCHAR*>( m_pTail ),
> 								 &dwStringSize );
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			DNASSERT( ( dwStringSize * sizeof( WCHAR ) ) == dwBufferSize );
> 		}
> 		else
> 		{
> 			m_bBufferTooSmall = TRUE;
> 		}
> 	}
> 
> 	if ( m_bBufferTooSmall )
> 	{
> 		hr = DPNERR_BUFFERTOOSMALL;
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	goto Exit;
> }
> //**********************************************************************
> // ------------------------------
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\packbuff.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62a63
> 	HRESULT	AddStringToBack( const char *const pszString );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2c17,26
< TARGETTYPE=LIBRARY
---
> 
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
3a28
> TARGETTYPE=LIBRARY
5,9d29
< !ifdef _BUILD_FOR_WIN2000
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< LINKER_FLAGS=-align:32
< !endif
11c31,35
< INCLUDES=..\inc
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
13c37,41
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS)
15c43,47
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
17,18c49,52
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> INCLUDES=$(DXROOT)\inc;..\inc
> 
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
21d54
< MSC_WARNING_LEVEL=/W3 /WX
22a56,62
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
31a72
>         creg.cpp \
36c77,88
< TARGETLIBS=
---
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE
> MSC_OPTIMIZATION=/Odi /Zi
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
> 
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\strutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include "DNetErrors.h"
20a22,23
> #undef DPF_MODNAME
> #define DPF_MODNAME "STR_WideToAnsi"
22c25,48
< // BUGBUG: [mgere] [xbox] UnicodeToMultiByteN and MultiByteToUnicodeN were Taken from nlsxlat.c
---
> //**********************************************************************
> // ------------------------------
> // WideToANSI - convert a wide string to an ANSI string
> //
> // Entry:		Pointer to source wide string
> //				Size of source string (in WCHAR units, -1 implies NULL-terminated)
> //				Pointer to ANSI string destination
> //				Pointer to size of ANSI destination
> //
> // Exit:		Error code:
> //				DPNERR_GENERIC = operation failed
> //				DPN_OK = operation succeded
> //				DPNERR_BUFFERTOOSMALL = destination buffer too small
> // ------------------------------
> HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
> 						const DWORD dwWCHARStringLength,
> 						char *const pString,
> 						DWORD *const pdwStringLength )
> {
> 	HRESULT	hr;
> 	int		iReturn;
> 	BOOL	fDefault;
> 	char	cMilleniumHackBuffer;	
> 	char	*pMilleniumHackBuffer;
24,29d49
< HRESULT
< UnicodeToMultiByteN(
<     OUT PCH MultiByteString,
<     IN ULONG MaxBytesInMultiByteString,
<     IN PWCH UnicodeString,
<     IN ULONG BytesInUnicodeString)
31c51,53
< /*++
---
> 	DNASSERT( pWCHARString != NULL );
> 	DNASSERT( pdwStringLength != NULL );
> 	DNASSERT( ( pString != NULL ) || ( *pdwStringLength == 0 ) );
33c55,60
< Routine Description:
---
> 	//
> 	// Initialize.  A hack needs to be implemented because their paramter
> 	// validation is screwed and when you pass zero for a destination size, you
> 	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
> 	//
> 	hr = DPN_OK;
35,37c62,69
<     This functions converts the specified unicode source string into an
<     ansi string. The translation is done with respect to the
<     ANSI Code Page (ACP) loaded at boot time.
---
> 	if ( *pdwStringLength == 0 )
> 	{
> 		pMilleniumHackBuffer = &cMilleniumHackBuffer;
> 	}
> 	else
> 	{
> 		pMilleniumHackBuffer = pString;
> 	}
39c71,83
< Arguments:
---
> 	fDefault = FALSE;
> 	iReturn = WideCharToMultiByte( CP_ACP,					// code page (default ANSI)
> 								   0,						// flags (none)
> 								   pWCHARString,			// pointer to WCHAR string
> 								   dwWCHARStringLength,		// size of WCHAR string
> 								   pMilleniumHackBuffer,	// pointer to destination ANSI string
> 								   *pdwStringLength,		// size of destination string
> 								   NULL,					// pointer to default for unmappable characters (none)
> 								   &fDefault				// pointer to flag indicating that default was used
> 								   );
> 	if ( iReturn == 0 )
> 	{
> 		DWORD	dwError;
41,43d84
<     MultiByteString - Returns an ansi string that is equivalent to the
<         unicode source string.  If the translation can not be done,
<         an error is returned.
45,47c86,100
<     MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
<         written to MultiByteString.  If this causes MultiByteString to be a
<         truncated equivalent of UnicodeString, no error condition results.
---
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to convert WCHAR to multi-byte!" );
> 		DisplayDNError( 0, dwError );
> 		hr = DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		if ( *pdwStringLength == 0 )
> 		{
> 			hr = DPNERR_BUFFERTOOSMALL;
> 		}
> 		else
> 		{
> 			DNASSERT( hr == DPN_OK );
> 		}
49,50c102,103
<     BytesInMultiByteString - Returns the number of bytes in the returned
<         ansi string pointed to by MultiByteString.
---
> 		*pdwStringLength = iReturn;
> 	}
52,53c105,109
<     UnicodeString - Supplies the unicode source string that is to be
<         converted to ansi.
---
> 	//
> 	// if you hit this ASSERT it's because you've probably got ASCII text as your
> 	// input WCHAR string.  Double-check your input!!
> 	//
> 	DNASSERT( fDefault == FALSE );
55,56c111,113
<     BytesInUnicodeString - The number of bytes in the the string pointed to by
<         UnicodeString.
---
> 	return	hr;
> }
> //**********************************************************************
58d114
< Return Value:
60,63c116,133
<     SUCCESS - The conversion was successful
< 
< --*/
< 
---
> //**********************************************************************
> // ------------------------------
> // ANSIToWide - convert an ANSI string to a wide string
> //
> // Entry:		Pointer to source multi-byte (ANSI) string
> //				Size of source string (-1 imples NULL-terminated)
> //				Pointer to multi-byte string destination
> //				Pointer to size of multi-byte destination (in WCHAR units)
> //
> // Exit:		Error code:
> //				DPNERR_GENERIC = operation failed
> //				DPN_OK = operation succeded
> //				DPNERR_BUFFERTOOSMALL = destination buffer too small
> // ------------------------------
> HRESULT	STR_AnsiToWide( const char *const pString,
> 						const DWORD dwStringLength,
> 						WCHAR *const pWCHARString,
> 						DWORD *const pdwWCHARStringLength )
65,66c135,138
<     ULONG LoopCount;
<     ULONG CharsInUnicodeString;
---
> 	HRESULT	hr;
> 	int		iReturn;
> 	WCHAR	MilleniumHackBuffer;
> 	WCHAR	*pMilleniumHackBuffer;
68d139
<     CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);
70,71c141,143
<     LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
<                  CharsInUnicodeString : MaxBytesInMultiByteString;
---
> 	DNASSERT( pString != NULL );
> 	DNASSERT( pdwWCHARStringLength != NULL );
> 	DNASSERT( ( pWCHARString != NULL ) || ( *pdwWCHARStringLength == 0 ) );
73c145,150
<     while (LoopCount) {
---
> 	//
> 	// Initialize.  A hack needs to be implemented because their paramter
> 	// validation is screwed and when you pass zero for a destination size, you
> 	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
> 	//
> 	hr = DPN_OK;
75c152,170
<         *MultiByteString = (*UnicodeString < 256) ? (UCHAR)*UnicodeString : '?';
---
> 	if ( *pdwWCHARStringLength == 0 )
> 	{
> 		pMilleniumHackBuffer = &MilleniumHackBuffer;
> 	}
> 	else
> 	{
> 		pMilleniumHackBuffer = pWCHARString;
> 	}
> 	
> 	iReturn = MultiByteToWideChar( CP_ACP,					// code page (default ANSI)
> 								   0,						// flags (none)
> 								   pString,					// pointer to multi-byte string			
> 								   dwStringLength,			// size of string (assume null-terminated)
> 								   pMilleniumHackBuffer,	// pointer to destination wide-char string
> 								   *pdwWCHARStringLength	// size of destination in WCHARs
> 								   );
> 	if ( iReturn == 0 )
> 	{
> 		DWORD	dwError;
77,80d171
<         UnicodeString++;
<         MultiByteString++;
<         LoopCount--;
<     }
82,83c173,187
<     return DPN_OK;
< }
---
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to convert multi-byte to WCHAR!" );
> 		DisplayDNError( 0, dwError );
> 		hr = DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		if ( *pdwWCHARStringLength == 0 )
> 		{
> 			hr = DPNERR_BUFFERTOOSMALL;
> 		}
> 		else
> 		{
> 			DNASSERT( hr == DPN_OK );
> 		}
84a189,190
> 		*pdwWCHARStringLength = iReturn;
> 	}
86,151c192
< HRESULT
< MultiByteToUnicodeN(
<     OUT PWCH UnicodeString,
<     IN ULONG MaxBytesInUnicodeString,
<     IN PCH MultiByteString,
<     IN ULONG BytesInMultiByteString)
< 
< /*++
< 
< Routine Description:
< 
<     This functions converts the specified ansi source string into a
<     Unicode string. The translation is done with respect to the
<     ANSI Code Page (ACP) installed at boot time.  Single byte characters
<     in the range 0x00 - 0x7f are simply zero extended as a performance
<     enhancement.  In some far eastern code pages 0x5c is defined as the
<     Yen sign.  For system translation we always want to consider 0x5c
<     to be the backslash character.  We get this for free by zero extending.
< 
<     NOTE: This routine only supports precomposed Unicode characters.
< 
< Arguments:
< 
<     UnicodeString - Returns a unicode string that is equivalent to
<         the ansi source string.
< 
<     MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
<         written to UnicodeString.  If this causes UnicodeString to be a
<         truncated equivalent of MultiByteString, no error condition results.
< 
<     BytesInUnicodeString - Returns the number of bytes in the returned
<         unicode string pointed to by UnicodeString.
< 
<     MultiByteString - Supplies the ansi source string that is to be
<         converted to unicode.  For single-byte character sets, this address
<         CAN be the same as UnicodeString.
< 
<     BytesInMultiByteString - The number of bytes in the string pointed to
<         by MultiByteString.
< 
< Return Value:
< 
<     SUCCESS - The conversion was successful.
< 
< 
< --*/
< 
< {
<     ULONG LoopCount;
<     ULONG MaxCharsInUnicodeString;
< 
<     MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);
< 
<     LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
<                  MaxCharsInUnicodeString : BytesInMultiByteString;
< 
<     while (LoopCount) {
< 
<         *UnicodeString = (WCHAR)(UCHAR)(*MultiByteString);
< 
<         UnicodeString++;
<         MultiByteString++;
<         LoopCount--;
<     }
< 
<     return DPN_OK;
---
> 	return	hr;
152a194
> //**********************************************************************
154a197
> 
174a218,220
> 	int rval;
> 	BOOL bDefault = FALSE;
> 
182c228,238
< 	UnicodeToMultiByteN( lpStr, cchStr, (PWCH) lpWStr, cchStr*sizeof(WCHAR));
---
> 	// use the default code page (CP_ACP)
> 	// -1 indicates WStr must be null terminated
> 	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,
> 			NULL,&bDefault);
> 
> 	if (bDefault)
> 	{
> 		DPF(3,"!!! WARNING - used default string in WideToAnsi conversion.!!!");
> 		DPF(3,"!!! Possible bad unicode string - (you're not hiding ansi in there are you?) !!! ");
> 		return DPNERR_CONVERSION;
> 	}
188a245,251
> //	WideToAnsi
> //
> //	Convert a WCHAR (Wide) string to a CHAR (ANSI) string
> //
> //	CHAR	*pStr		CHAR string
> //	WCHAR	*pWStr		WCHAR string
> //	int		iStrSize	size (in bytes) of buffer pointed to by lpStr
189a253,295
> #define DPF_MODNAME "STR_AllocAndConvertToANSI"
> /*
>  ** GetAnsiString
>  *
>  *  CALLED BY: Everywhere
>  *
>  *  PARAMETERS: *ppszAnsi - pointer to string
>  *				lpszWide - string to copy
>  *
>  *  DESCRIPTION:	  handy utility function
>  *				allocs space for and converts lpszWide to ansi
>  *
>  *  RETURNS: string length
>  *
>  */
> HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide)
> {
> 	int iStrLen;
> 	BOOL bDefault;
> 	
> 	DNASSERT(ppszAnsi);
> 
> 	if (!lpszWide)
> 	{
> 		*ppszAnsi = NULL;
> 		return S_OK;
> 	}
> 
> 	*ppszAnsi = new char[wcslen(lpszWide)+1];
> 	if (!*ppszAnsi)	
> 	{
> 		DPF(0, "could not get ansi string -- out of memory");
> 		return E_OUTOFMEMORY;
> 	}
> 
> 	iStrLen = WideCharToMultiByte(CP_ACP,0,lpszWide,-1,*ppszAnsi,wcslen(lpszWide)+1,
> 			NULL,&bDefault);
> 
> 	return DPN_OK;
> } // OSAL_AllocAndConvertToANSI
> 
> 
> #undef DPF_MODNAME
208a315,316
> 	int rval;
> 
216c324
< 	MultiByteToUnicodeN( lpWStr, cchWStr*sizeof(WCHAR), (CHAR *) lpStr, cchWStr );
---
> 	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);
219a328
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\strutils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide);
21a23,31
> HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
> 						const DWORD dwWCHARStringLength,
> 						char *const pString,
> 						DWORD *const pdwStringLength );
> 
> HRESULT	STR_AnsiToWide( const char *const pString,
> 						const DWORD dwStringLength,
> 						WCHAR *const pWCHARString,
> 						DWORD *const pdwWCHARStringLength );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\appdesc.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38d37
< #include <wchar.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
88a89
> #include "DVoice.h"
121a123
> #include "Voice.h"
123c125,127
< #include <mmsystem.h>
---
> #include "dpnsdef.h"
> #include "dpnsvrq.h"
> #include "dpnsvlib.h"
186,187c190
< // BUGBUG: [mgere] [xbox] Completely removed this function since Xbox doesn't have multiple adapters.
< /*
---
> 
300d302
< */
381,382c383
< // BUGBUG: [mgere] [xbox] Need to figure out what to do with this.  We can't enumerate adapters.
< /*
---
> 
436c437
< */
---
> 
494c495
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
516c517
< 	pDeviceInfo->lpVtbl->GetURLW(pDeviceInfo,DP8ABuffer,&DP8ASize);
---
> 	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer,&DP8ASize);
635d635
< // BUGBUG: [mgere] [xbox] This shouldn't be needed since we don't have multiple adapters.
1173c1173
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1189c1189
< 	pRemoteAddr->lpVtbl->GetURLW(pRemoteAddr,DP8ABuffer,&DP8ASize);
---
> 	pRemoteAddr->lpVtbl->GetURLA(pRemoteAddr,DP8ABuffer,&DP8ASize);
1192c1192
< 	pDeviceInfo->lpVtbl->GetURLW(pDeviceInfo,DP8ABuffer,&DP8ASize);
---
> 	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer,&DP8ASize);
1792a1793,1805
> 		if (dwMsgId == DN_MSG_INTERNAL_VOICE_SEND)
> 		{
> 			DNASSERT(pdnBufferDesc != NULL);
> 			pSendOpData->BufferDesc[0].pBufferData = pdnBufferDesc->pBufferData;
> 			pSendOpData->BufferDesc[0].dwBufferSize = pdnBufferDesc->dwBufferSize;
> 			pSendOpData->BufferDesc[1].pBufferData = NULL;
> 			pSendOpData->BufferDesc[1].dwBufferSize = 0;
> 			pSendOpData->dwNumBuffers = 1;
> 
> 			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO );
> 		}
> 		else
> 		{
1808a1822
> 		}
2153a2168,2180
> 		if (dwMsgId == DN_MSG_INTERNAL_VOICE_SEND)
> 		{
> 			DNASSERT(pdnBufferDesc != NULL);
> 			pSendOpData->BufferDesc[0].pBufferData = pdnBufferDesc->pBufferData;
> 			pSendOpData->BufferDesc[0].dwBufferSize = pdnBufferDesc->dwBufferSize;
> 			pSendOpData->BufferDesc[1].pBufferData = NULL;
> 			pSendOpData->BufferDesc[1].dwBufferSize = 0;
> 			pSendOpData->dwNumBuffers = 1;
> 
> 			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO );
> 		}
> 		else
> 		{
2169a2197
> 		}
2654a2683,2691
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
125,126c125
< // BUGBUG: [mgere] [xbox] Removed (see cpp file)
< /*
---
> 
132c131
< */
---
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
55a56
> #include "DVoice.h"
85a87,88
> #include "dvoice.h"
> #include "voice.h"
87a91
> #include "dplobby8.h"
133a138
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
247a253,272
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
251c276,277
< 			riid != IID_IUnknown )
---
> 			riid != IID_IUnknown &&
> 			riid != IID_IDirectPlayVoiceTransport )
260a287
> 			riid != IID_IDirectPlayVoiceTransport &&
270c297,298
< 			riid != IID_IUnknown )
---
> 			riid != IID_IUnknown &&
> 			riid != IID_IDirectPlayVoiceTransport )
305a334,335
> 	pdnObject->pIDP8LobbiedApplication = NULL;
> 	pdnObject->dpnhLobbyConnection = NULL;
326a357,359
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
358a392,398
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
715a756,758
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
805a849,854
> 	if( pdnObject->pIDP8LobbiedApplication)
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release( pdnObject->pIDP8LobbiedApplication );
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 	}
> 
971a1021,1025
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(7,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
> 	}
985c1039
< 	{
---
> 	{
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\client.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
64d63
< #include <wchar.h>
102c101
< typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
149a150,151
> #include "DPLobby8.h"
> #include "DVoice.h"
175a178
> #include "DNMisc.h"
182a186
> #include "Voice.h"
184a189,191
> #include "dpnsdef.h"
> #include "dpnsvrq.h"
> #include "dpnsvlib.h"
186,187d192
< #include <mmsystem.h>
< #include <wchar.h>
607a613,621
> 	pdnObject->dpnhLobbyConnection = NULL;
> 
> 	// Release our hold on the lobbiedapplication
> 	if( pdnObject->pIDP8LobbiedApplication) 
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release(pdnObject->pIDP8LobbiedApplication);
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 	}
> 
1138a1153,1156
> 	if (dwFlags & DPNCONNECT_OKTOQUERYFORADDRESSING)
> 	{
> 		dwConnectFlags |= DPNCONNECT_OKTOQUERYFORADDRESSING;
> 	}
1235d1252
< // BUGBUG: [mgere] [xbox] Set breakpoint here and see if it ever gets in here.
1251,1253d1267
< // BUGBUG: [mgere] [xbox] I know this is busted.  Remove this whole section about enumerating adapters
< // and check if it's ok.
< /*
1284d1297
< */
1881a1895,1907
> 	//	Update Lobby status
> 	//
> 	if (fWasConnected)
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_DISCONNECTED);
> 	}
> 
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
> 
> 	//
2056c2082
< 	{
---
> 	{
2443,2444d2468
< // BUGBUG [mgere] [xbox] Temporarily removed until a CoCreateGuid call is implemented
< #ifdef _BUILD_FOR_WIN2000
2450d2473
< #endif
2513a2537,2545
> 	//	Inform DPNSVR of LISTENs
> 	//
> 	if( !(pdnObject->dnApplicationDescription.dwFlags & DPNSESSION_NODPNSVR) )
> 	{
> 		DPF(3,"Registering with DPNSVR");
> 		DNRegisterWithDPNSVR(pdnObject);
> 	}
> 
> 	//
2622a2655,2659
> 	//	Update Lobby status
> 	//
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_CONNECTED);
> 
> 	//
3875c3912
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
3988c4025
< 	pIHost->lpVtbl->GetURLW(pIHost,DP8ABuffer,&DP8ASize);
---
> 	pIHost->lpVtbl->GetURLA(pIHost,DP8ABuffer,&DP8ASize);
3992c4029
< 	pIDevice->lpVtbl->GetURLW(pIDevice,DP8ABuffer,&DP8ASize);
---
> 	pIDevice->lpVtbl->GetURLA(pIDevice,DP8ABuffer,&DP8ASize);
4047c4084
< 	//
---
> 	//
4065d4101
< // BUGBUG: [mgere] [xbox] Set breakpoint here and see if it ever gets in here.
4081,4083d4116
< // BUGBUG: [mgere] [xbox] I know this is busted.  Remove this whole section about enumerating adapters
< // and check if it's ok.
< /*
4115d4147
< */
4696c4728
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
4699c4731,4800
< 	return DPNERR_UNSUPPORTED;
---
> 	DIRECTNETOBJECT		*pdnObject;
> 	HRESULT             hResultCode;
> 
> 	DPF(3,"Parameters: pInterface [0x%p], pIDP8LobbiedApplication [0x%p], dwFlags [0x%lx]",
> 			pInterface,pIDP8LobbiedApplication,dwFlags);
> 
> 	TRY
> 	{
>     	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
>     	DNASSERT(pdnObject != NULL);
> 
>     	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
>     	{
>     	    if( FAILED( hResultCode = DN_ValidateRegisterLobby( pInterface, pIDP8LobbiedApplication, dwFlags ) ) )
>     	    {
>     	        DPFERR( "Error validating register lobby params" );
>     	        DPF_EXIT( hResultCode );
>     	    }
>     	}
> 
>     	// Check to ensure message handler registered
>     	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
>     	{
>     		DPFERR( "Object is not initialized" );
>     		DPF_EXIT(DPNERR_UNINITIALIZED);
>     	}
> 
> 	}
> 	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
> 	{
> 	    DPFERR("Invalid object" );
> 	    DPF_EXIT(DPNERR_INVALIDOBJECT);
> 	}	
> 
> 	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
> 	DNASSERT(pdnObject != NULL);
> 
> 	if (dwFlags == DPNLOBBY_REGISTER)
> 	{
> 		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 		if (pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE)
> 		{
> 			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 			return(DPNERR_ALREADYINITIALIZED);
> 		}
> 				
> 		pIDP8LobbiedApplication->lpVtbl->AddRef(pIDP8LobbiedApplication);
> 
> 		pdnObject->pIDP8LobbiedApplication = pIDP8LobbiedApplication;
> 		pdnObject->dpnhLobbyConnection = dpnhLobbyConnection;
> 		pdnObject->dwFlags |= DN_OBJECT_FLAG_LOBBY_AWARE;
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	}
> 	else
> 	{
> 		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE))
> 		{
> 			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 			return(DPNERR_UNINITIALIZED);
> 		}
> 				
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release(pdnObject->pIDP8LobbiedApplication);
> 		pdnObject->dpnhLobbyConnection = NULL;
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_LOBBY_AWARE);
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	}
> 
> 	return(DPN_OK);
4701a4803,4825
> #undef DPF_MODNAME
> #define DPF_MODNAME "DNNotifyLobbyClientOfSettings"
> // 
> // DNNotifyLobbyClientOfSettings
> //
> // This function sends a connection settings update to the lobby client informing it that the lobby 
> // client settings have changed.  
> //
> HRESULT DNNotifyLobbyClientOfSettings(
> 	DIRECTNETOBJECT * const pdnObject,
> 	IDirectPlay8LobbiedApplication *pdpLobbiedApp, 
> 	DPNHANDLE dpnConnection, 
> 	IDirectPlay8Address *pHostAddress, 
> 	IDirectPlay8Address *pConnectFromAddress )
> {
> 	HRESULT						hResultCode = DPN_OK;
> 	DPL_CONNECTION_SETTINGS		dplConnectionSettings;
> 	BOOL						fIsHost = FALSE;
> 	CPackedBuffer				packBuffer;
> 	PBYTE						pBuffer = NULL;
> 	BOOL						fINCriticalSection = FALSE;
> 	CNameTableEntry				*pNTEntry = NULL;
> 	DWORD						dwIndex;
4702a4827,4972
> 	fIsHost = DN_CHECK_LOCALHOST( pdnObject );
> 
> 	ZeroMemory( &dplConnectionSettings, sizeof( DPL_CONNECTION_SETTINGS ) );
> 	dplConnectionSettings.dwSize = sizeof( DPL_CONNECTION_SETTINGS );
> 	dplConnectionSettings.dwFlags = (fIsHost) ? DPLCONNECTSETTINGS_HOST : 0;
> 
> 	// Lock the object while we make a copy of the app desc.  
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	fINCriticalSection = TRUE;
> 	
> 	packBuffer.Initialize(NULL, 0 );
> 
> 	// Determine the size of buffer
> 	hResultCode = DNPackApplicationDesc( &pdnObject->dnApplicationDescription, &packBuffer );
> 
> 	if( hResultCode != DPNERR_BUFFERTOOSMALL ) 
> 	{
> 		DPF( 0, "Error getting app desc size hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	pBuffer = new BYTE[packBuffer.GetSizeRequired()];
> 
> 	if( !pBuffer )
> 	{
> 		DPF( 0, "Error allocating memory for buffer" );
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	packBuffer.Initialize(pBuffer,packBuffer.GetSizeRequired());
> 
> 	hResultCode = DNPackApplicationDesc( &pdnObject->dnApplicationDescription, &packBuffer );
> 
> 	if( FAILED( hResultCode ) )
> 	{
> 		DPF( 0, "Error packing app desc hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	fINCriticalSection = FALSE;
> 
> 	memcpy( &dplConnectionSettings.dpnAppDesc, pBuffer, sizeof( DPN_APPLICATION_DESC ) );
> 
> 	hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pNTEntry );
> 
> 	if( FAILED( hResultCode ) )
> 	{
> 		DPF( 0, "Error getting local player hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	// Make sure player name isn't changed while we are working with the entry
> 	pNTEntry->Lock();
> 	if( pNTEntry->GetName() )
> 	{
> 		dplConnectionSettings.pwszPlayerName = new WCHAR[wcslen(pNTEntry->GetName())+1];
> 
> 		if( !dplConnectionSettings.pwszPlayerName )
> 		{
> 			pNTEntry->Unlock();
> 			DPF( 0, "Error allocating memory" );
> 			goto NOTIFY_EXIT;
> 		}
> 		
> 		wcscpy( dplConnectionSettings.pwszPlayerName, pNTEntry->GetName() );
> 	}
> 	else
> 	{
> 		dplConnectionSettings.pwszPlayerName = NULL;		
> 	}
> 	pNTEntry->Unlock();
> 
> 	// Release our reference
> 	pNTEntry->Release();
> 
> 	// Host address field
> 	if( fIsHost )
> 	{
> 		dplConnectionSettings.pdp8HostAddress = NULL;
> 
> 		hResultCode = DNGetHostAddressHelper( pdnObject, dplConnectionSettings.ppdp8DeviceAddresses, &dplConnectionSettings.cNumDeviceAddresses );
> 
> 		if( hResultCode != DPNERR_BUFFERTOOSMALL )
> 		{
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			DPF( 0, "Could not get host addresses for lobby update hr=0x%x", hResultCode );
> 			goto NOTIFY_EXIT;
> 		}
> 
> 		dplConnectionSettings.ppdp8DeviceAddresses = new IDirectPlay8Address*[dplConnectionSettings.cNumDeviceAddresses];
> 
> 		if( !dplConnectionSettings.ppdp8DeviceAddresses )
> 		{
> 			DPF( 0, "Error allocating memory" );
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			hResultCode = DPNERR_OUTOFMEMORY;
> 			goto NOTIFY_EXIT;
> 		}
> 
> 		hResultCode = DNGetHostAddressHelper( pdnObject, dplConnectionSettings.ppdp8DeviceAddresses, &dplConnectionSettings.cNumDeviceAddresses );
> 
> 		if( FAILED( hResultCode ) )
> 		{
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			DPF( 0, "Could not get host addresses for lobby update hr=0x%x", hResultCode );
> 			goto NOTIFY_EXIT;
> 		}
> 	}
> 	else
> 	{
> 		dplConnectionSettings.pdp8HostAddress = pHostAddress;
> 		dplConnectionSettings.ppdp8DeviceAddresses = &pConnectFromAddress;
> 		dplConnectionSettings.cNumDeviceAddresses = 1;	
> 	}
> 
> 	// Update the settings
> 	hResultCode = pdpLobbiedApp->lpVtbl->SetConnectionSettings( pdpLobbiedApp, dpnConnection, &dplConnectionSettings, 0 );
> 
> NOTIFY_EXIT:
> 
> 	if( dplConnectionSettings.ppdp8DeviceAddresses && fIsHost )
> 	{
> 		for( dwIndex = 0; dwIndex < dplConnectionSettings.cNumDeviceAddresses; dwIndex++ )
> 		{
> 			dplConnectionSettings.ppdp8DeviceAddresses[dwIndex]->lpVtbl->Release( dplConnectionSettings.ppdp8DeviceAddresses[dwIndex] );
> 		}
> 
> 		delete [] dplConnectionSettings.ppdp8DeviceAddresses;
> 	}
> 
> 	if( dplConnectionSettings.pwszPlayerName )
> 		delete [] dplConnectionSettings.pwszPlayerName;
> 
> 	if( fINCriticalSection ) 
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	if( pBuffer )
> 		delete [] pBuffer;
> 
> 	return hResultCode;
> 
> }
> 
> 
4703a4974,5054
> #define DPF_MODNAME "DNUpdateLobbyStatus"
> 
> HRESULT DNUpdateLobbyStatus(DIRECTNETOBJECT *const pdnObject,
> 							const DWORD dwStatus)
> {
> 	HRESULT		hResultCode;
> 	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
> 	DPNHANDLE dpnhLobbyConnection = NULL;
> 	IDirectPlay8Address *pHostAddress = NULL;
> 	IDirectPlay8Address *pConnectFromAddress = NULL;
> 
> 	DPF(4,"Parameters: dwStatus [0x%lx]",dwStatus);
> 
> 	DNASSERT(pdnObject != NULL);
> 
> 	pIDP8LobbiedApplication = NULL;
> 
> 	//
> 	//	Get lobbied application interface, if it exists and other settings we need
> 	//
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE) && (pdnObject->pIDP8LobbiedApplication))
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->AddRef(pdnObject->pIDP8LobbiedApplication);
> 		pIDP8LobbiedApplication = pdnObject->pIDP8LobbiedApplication;
> 		dpnhLobbyConnection = pdnObject->dpnhLobbyConnection;
> 
> 		pConnectFromAddress = pdnObject->pIDP8ADevice;
> 		pHostAddress = pdnObject->pConnectAddress;
> 
> 		if( pConnectFromAddress )
> 		{
> 			pConnectFromAddress->lpVtbl->AddRef( pConnectFromAddress );			
> 		}
> 
> 		if( pHostAddress )
> 		{
> 			pHostAddress->lpVtbl->AddRef( pHostAddress );
> 		}
> 	}
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	//
> 	//	Update status and release object
> 	//
> 	if (pIDP8LobbiedApplication)
> 	{
> 		// If we are about to do a connection notification
> 		// we send the updated connection settings.  
> 		// 
> 		// This gives lobby client full picture. 
> 		//
> 		if( dwStatus == DPLSESSION_CONNECTED )
> 		{
> 			DNNotifyLobbyClientOfSettings(pdnObject, pIDP8LobbiedApplication, dpnhLobbyConnection, pHostAddress, pConnectFromAddress );
> 		}
> 
> 		pIDP8LobbiedApplication->lpVtbl->UpdateStatus(pIDP8LobbiedApplication,dpnhLobbyConnection,dwStatus,0);
> 
> 		pIDP8LobbiedApplication->lpVtbl->Release(pIDP8LobbiedApplication);
> 		pIDP8LobbiedApplication = NULL;
> 
> 		if( pHostAddress )
> 		{
> 			pHostAddress->lpVtbl->Release( pHostAddress );
> 		}		
> 
> 		if( pConnectFromAddress )
> 		{
> 			pConnectFromAddress->lpVtbl->Release( pConnectFromAddress );
> 		}
> 	}
> 
> 	hResultCode = DPN_OK;
> 
> 	DPF(4,"Returning: [0x%lx]",hResultCode);
> 	return(hResultCode);
> }
> 
> 						
> #undef DPF_MODNAME
5044a5396,5524
> }
> 
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DNRegisterWithDPNSVR"
> 
> HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject)
> {
> 	HRESULT					hResultCode;
> 	HRESULT					hrRegister;
> 	CAsyncOp				*pListenParent;
> 	CAsyncOp				*pListenSP;
> 	CAsyncOp				*pListen;
> 	CBilink					*pBilinkSP;
> 	CBilink					*pBilink;
> 	SPGETADDRESSINFODATA	spInfo;
> #ifdef	DEBUG
> 	CHAR			DP8ABuffer[512];
> 	DWORD			DP8ASize;
> #endif
> 
> 	DPF(4,"Parameters: (none)");
> 
> 	pListenParent = NULL;
> 	pListenSP = NULL;
> 	pListen = NULL;
> 
> 	//
> 	//	Default error returned
> 	//
> 	hrRegister = DPNERR_GENERIC;
> 
> 	//
> 	//	Get LISTEN AsyncOp parent from DirectNet object and add a RefCount
> 	//
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	if (pdnObject->pListen == NULL)
> 	{
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 		goto Exit;
> 	}
> 	pdnObject->pListen->AddRef();
> 	pListenParent = pdnObject->pListen;
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	//
> 	//	Lock the parent so that the child bilink list doesn't change
> 	//
> 	pListenParent->Lock();
> 
> 	//
> 	//	Locate each child (LISTEN SP parent) and then each actual LISTEN
> 	//
> 	pBilinkSP = pListenParent->m_bilinkParent.GetNext();
> 	while (pBilinkSP != &pListenParent->m_bilinkParent)
> 	{
> 		pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);
> 
> 		//
> 		//	Lock the SP parent so that the child bilink doesn't change
> 		//
> 		pListenSP->Lock();
> 
> 		pBilink = pListenSP->m_bilinkParent.GetNext();
> 		while (pBilink != &pListenSP->m_bilinkParent)
> 		{
> 			pListen = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
> 
> 			DNASSERT(pListen->GetProtocolHandle() != NULL);
> 
> 			spInfo.hEndpoint = pListen->GetProtocolHandle();
> 			spInfo.pAddress = NULL;
> 			spInfo.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;
> 
> 			if (DNPGetListenAddressInfo(pListen->GetProtocolHandle(),&spInfo) == DPN_OK)
> 			{
> 				DNASSERT(spInfo.pAddress != NULL);
> #ifdef	DEBUG
> 				DP8ASize = 512;
> 				spInfo.pAddress->lpVtbl->GetURLA(spInfo.pAddress,DP8ABuffer,&DP8ASize);
> 				DPF(4,"Listen address [%s]",DP8ABuffer);
> 
> 				// We re-try the registration to catch the case where DPNSVR is shutting
> 				// down while we are trying to register.  Unlikely but has to be handled.
> 				//
> #endif
> 	            for( DWORD dwRetry = 0; dwRetry < DPNSVR_REGISTER_ATTEMPTS ; dwRetry ++ )
> 		        {
>     				hResultCode = DPNSVR_Register( &pdnObject->dnApplicationDescription, spInfo.pAddress );
> 	    			if( FAILED( hResultCode ) )
> 					{
>     					if( dwRetry < DPNSVR_REGISTER_ATTEMPTS )
>     					{
> 	    					DPF( 0, "Unable to register ourselves with DPNSVR hr=0x%x, retrying", hResultCode );    				
> 	    					Sleep( DPNSVR_REGISTER_SLEEP );    				
> 	    				}
> 						else
>     					{
> 	    					DPF( 0, "Unable to register ourselves with DPNSVR hr=0x%x", hResultCode );
> 	    				}
> 	    			}
> 					else
>     				{
>     					// Return DPN_OK if we succeed even once
>     					hrRegister = hResultCode;
>     					break;
> 	    			}
> 		        }
> 			
> 				spInfo.pAddress->lpVtbl->Release(spInfo.pAddress);
> 				spInfo.pAddress = NULL;
> 
> 			}
> 			pBilink = pBilink->GetNext();
> 		}
> 
> 		pListenSP->Unlock();
> 
> 		pBilinkSP = pBilinkSP->GetNext();
> 	}
> 
> 	pListenParent->Unlock();
> 
> 	pListenParent->Release();
> 	pListenParent = NULL;
> 
> Exit:
> 	DPF(4,"Returning: [0x%lx]",hrRegister);
> 	return( hrRegister );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
199c199
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
201a202,204
> HRESULT DNUpdateLobbyStatus(DIRECTNETOBJECT *const pdnObject,
> 							const DWORD dwStatus);
> 
209a213,214
> 
> HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
74a75
> #include "DPLobby8.h"
102d102
< #include <wchar.h>
106,109d105
< #define CompareGuid(a,b)                                         \
<     (memcmp((PVOID)(a), (PVOID)(b), sizeof(GUID)))
< 
< 
177c173
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
250,251c246,247
< 		if ((hResultCode = pAddress->lpVtbl->BuildFromURLW(	pAddress,
< 															static_cast<WCHAR*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
---
> 		if ((hResultCode = pAddress->lpVtbl->BuildFromURLA(	pAddress,
> 															static_cast<char*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
278c274
< 		pAddress->lpVtbl->GetURLW(pAddress,DP8ABuffer,&DP8ASize);
---
> 		pAddress->lpVtbl->GetURLA(pAddress,DP8ABuffer,&DP8ASize);
798c794
< 	if (pguidInstance && CompareGuid(pguidInstance,&GUID_NULL))
---
> 	if (pguidInstance && !UuidIsNil(pguidInstance,&rpcStatus))
811c807
< 	if (pguidApplication && CompareGuid(pguidApplication,&GUID_NULL))
---
> 	if (pguidApplication && !UuidIsNil(pguidApplication,&rpcStatus))
1137c1133
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
1162,1163c1158
< 				pAddress->lpVtbl->GetURLW(pAddress,NULL,&dwAddressSize);
< 				dwAddressSize = dwAddressSize * sizeof(WCHAR);
---
> 				pAddress->lpVtbl->GetURLA(pAddress,NULL,&dwAddressSize);
1167c1162
< 				pAddress->lpVtbl->GetURLW(pAddress,DP8ABuffer,&DP8ASize);
---
> 				pAddress->lpVtbl->GetURLA(pAddress,DP8ABuffer,&DP8ASize);
1294,1295c1289,1290
< 		if ((hResultCode = pAddress->lpVtbl->GetURLW(pAddress,
< 													static_cast<WCHAR*>(packedBuffer.GetTailAddress()),
---
> 		if ((hResultCode = pAddress->lpVtbl->GetURLA(pAddress,
> 													static_cast<char*>(packedBuffer.GetTailAddress()),
1638a1634,1638
> 	//	Update Lobby status
> 	//
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_CONNECTED);
> 
> 	//
1923a1924,1932
> 	if (fWasConnected)
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_DISCONNECTED);
> 	}
> 	else
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_COULDNOTCONNECT);
> 	}
> 
2768c2777
< 	WCHAR					DP8ABuffer[512];
---
> 	CHAR					DP8ABuffer[512];
2802c2811
< 		(*ppAddress)->lpVtbl->GetURLW(*ppAddress,DP8ABuffer,&DP8ASize);
---
> 		(*ppAddress)->lpVtbl->GetURLA(*ppAddress,DP8ABuffer,&DP8ASize);
2825c2834
< 	WCHAR					DP8ABuffer[512];
---
> 	CHAR					DP8ABuffer[512];
2852c2861
< 		(*ppAddress)->lpVtbl->GetURLW(*ppAddress,DP8ABuffer,&DP8ASize);
---
> 		(*ppAddress)->lpVtbl->GetURLA(*ppAddress,DP8ABuffer,&DP8ASize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectNet"
> 
> /*
29a37,65
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "CORE"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectNet] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNetCore"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dllmain.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "creg.h"
42a44,180
> #undef DPF_MODNAME
> #define DPF_MODNAME "RegisterDefaultSettings"
> //
> // RegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT RegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create app sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		return DPN_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "UnRegisterDefaultSettings"
> //
> // UnRegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT UnRegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot remove app, does not exist" );
> 	}
> 	else
> 	{
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_SP_SUB)[1] ) )
> 		{
> 			DPFERR( "Cannot remove cp sub-key, could have elements" );
> 		}
> 	}
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Client.1", L"DirectPlay8Client Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Client, L"DirectPlay8.Client") )
> 	{
> 		DPFERR( "Could not register dp8 client object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Server.1", L"DirectPlay8Server Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Server, L"DirectPlay8.Server") )
> 	{
> 		DPFERR( "Could not register dp8 Server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Peer.1", L"DirectPlay8Peer Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Peer, L"DirectPlay8.Peer") )
> 	{
> 		DPFERR( "Could not register dp8 client object" );
> 		fFailed = TRUE;
> 	}
> 
> 
> 	if( FAILED( hr = RegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Could not register default settings hr = 0x%x", hr );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Client) )
> 	{
> 		DPF( 0, "Failed to unregister client object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Server) )
> 	{
> 		DPF( 0, "Failed to unregister server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Peer) )
> 	{
> 		DPF( 0, "Failed to unregister peer object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = UnRegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Failed to remove default settings hr=0x%x", hr );
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
98a99,101
> #define DN_REG_LOCAL_SP_ROOT				L"Software\\Microsoft\\DirectPlay8"
> #define DN_REG_LOCAL_SP_SUB					L"\\Service Providers"
> #define DN_REG_LOCAL_SP_SUBKEY				DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB
99a103,107
> #define	DN_REG_KEYNAME_ADAPTER_LIST			L"Adapter List"
> #define	DN_REG_KEYNAME_ALL_APPLICATIONS		L"All Applications"
> #define	DN_REG_KEYNAME_FRIENDLY_NAME		L"Friendly Name"
> #define DN_REG_KEYNAME_GUID					L"GUID"
> 
120a129,130
> typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
157a168,175
> //
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> //
> #define MAX_VOICE_CLIENTS	32	
> 
226a245,249
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 
234a258
> 	// Lobby additions
235a260,263
> 	DPNHANDLE				dpnhLobbyConnection;	// Lobby Connection to update
> 
> 	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
5a6,8
> 	DllRegisterServer	PRIVATE
> 	DllUnregisterServer	PRIVATE
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnet.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,62
> 
> #endif
> 
> #endif    // !_MAC
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
42a43
> #include "DNMisc.h"
44a46
> #include "CReg.h"
57c59,68
< // BUGBUG: [xbox] [mgere] Removed since we don't support registry
---
> 	DWORD	dwAllAppLen;
> 	WCHAR	lpwszAllAppStr[DN_FLAG_STR_LEN+1];
> 
> 	dwAllAppLen = (DN_FLAG_STR_LEN + 1) * sizeof(WCHAR);
> 	if (RegQueryValueExW(hSPKey,DN_REG_KEYNAME_ALL_APPLICATIONS,NULL,NULL,(PBYTE)lpwszAllAppStr,&dwAllAppLen) != ERROR_SUCCESS)
> 		return(FALSE);
> 
> 	if (towupper(lpwszAllAppStr[0]) == L'N')
> 		return(TRUE);
> 
72,73c83
< // BUGBUG:  [mgere] [xbox] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
75c85,95
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
77,78c97,100
<     WCHAR wszSP[] = L"DirectPlay8 TCP/IP Service Provider";
< 	GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
> //	CServiceProvider	*pSP;
86a109,112
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
> //	pSP = NULL;
> 
90,91c116,121
< 	hResultCode = packedBuffer.AddToBack(wszSP,(wcslen(wszSP)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,TRUE,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
93,94c123,150
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = static_cast<GUID*>(packedBuffer.GetTailAddress());
---
> 	//
> 	//	Set up to enumerate
> 	//
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(5,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
96,97c152,165
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	//
> 	//	Enumerate SP's !
> 	//
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(5,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,TRUE,FALSE))
> 		{
> 			DPF(0,"Couldn't open subentry.  Skipping [%S]", pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
98a167,258
> 		//
> 		//	GUID
> 		//
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPF(0,"SubEntry.ReadGUID failed.  Skipping [%S]", pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		//
> 		//	Attempt to instantiate SP and initialize it, to ensure that it is in fact usable.
> 		//
> 		if (!(dwFlags & DPNENUMSERVICEPROVIDERS_ALL))
> 		{
> 			hResultCode = DN_SPEnsureLoaded(pdnObject,&guid,NULL);
> 			if (hResultCode != DPN_OK)
> 			{
> 				DPF(0,"Could not load SP.  Skipping [%S]", pwszKeyName);
> 				SubEntry.Close();
> 				dwEnumIndex++;
> 				dwKeyLen = dwMaxKeyLen;
> 				hResultCode = DPN_OK; // override return code
> 				continue;
> 			}
> 			else
> 			{
> //				DN_SPRelease(pdnObject,&guid);
> 			}
> 		}
> 
> 		//
> 		//	Friendly Name
> 		//
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(5,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		DPF(5,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = static_cast<GUID*>(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
> 	//
> 	//	Success ?
> 	//
104c264
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
106c266
< 		goto Exit;
---
> 		goto Failure;
110c270,271
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
> 		hResultCode = DPN_OK;
114a276,280
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
> 	DNFree(pwszFriendlyName);
> 	pwszFriendlyName = NULL;
> 
117a284,305
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
131,135d318
< // BUGBUG
< // [mgere] [xbox] Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
157c340
< 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,TRUE,FALSE))
186c369
< 		if (!SubEntry.Open(RegistryEntry,lpwszKeyName,FALSE))
---
> 		if (!SubEntry.Open(RegistryEntry,lpwszKeyName,TRUE,FALSE))
285d467
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\migration.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
73a74,76
> #include "dpnsvrq.h"
> #include "dpnsdef.h"
> #include "dpnsvlib.h"
638a642,661
> 
> 	// Register with DPNSVR
> 	if( !(pdnObject->dnApplicationDescription.dwFlags & DPNSESSION_NODPNSVR) )
> 	{
> 		BOOL	fCoUninitialize = FALSE;
> 
> 		DPF( 7, "Asking for DPNSVR to start listening for us.." );
> 
> 		if (COM_CoInitialize(NULL) == S_OK)
> 		{
> 			fCoUninitialize = TRUE;
> 		}
> 
> 		DNRegisterWithDPNSVR(pdnObject);
> 
> 		if (fCoUninitialize)
> 		{
> 			COM_CoUninitialize();
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\msghandler.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40a41
> #include "DVoice.h"
61a63
> #include "Voice.h"
510c512,516
<                     // BUGBUG: [mgere] [xbox] Used to be Voice_Receive() but voice not supported on Xbox
---
> 			hResultCode = Voice_Receive(pdnObject,
> 										pConnection->GetDPNID(),
> 										0,
> 										pvData,
> 										dwDataSize);
1036c1042
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1052c1058
< 	pHostAddress->lpVtbl->GetURLW(pHostAddress,DP8ABuffer,&DP8ASize);
---
> 	pHostAddress->lpVtbl->GetURLA(pHostAddress,DP8ABuffer,&DP8ASize);
1056c1062
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
1087c1093
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1103c1109
< 	pHostAddress->lpVtbl->GetURLW(pHostAddress,DP8ABuffer,&DP8ASize);
---
> 	pHostAddress->lpVtbl->GetURLA(pHostAddress,DP8ABuffer,&DP8ASize);
1107c1113
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
1136c1142
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1152c1158
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\ntentry.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
399,400c399
< 		hResultCode = m_pAddress->lpVtbl->GetURLW(m_pAddress,NULL,&dwURLSize);
< 		dwURLSize = dwURLSize * sizeof(WCHAR);
---
> 		hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,NULL,&dwURLSize);
412,413c411,412
< 				if ((hResultCode = m_pAddress->lpVtbl->GetURLW(m_pAddress,
< 						static_cast<WCHAR*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
---
> 				if ((hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,
> 						static_cast<char*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
500c499
< 		hResultCode = pAddress->lpVtbl->BuildFromURLW(pAddress,reinterpret_cast<WCHAR*>(pBufferStart + pdnEntryInfo->dwURLOffset));
---
> 		hResultCode = pAddress->lpVtbl->BuildFromURLA(pAddress,reinterpret_cast<char*>(pBufferStart + pdnEntryInfo->dwURLOffset));
602d600
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
39a40
> #include "DVoice.h"
62a64
> #include "voice.h"
65a68
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
182c185
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
190a194,200
>     if( pIDP8LobbiedApplication == NULL ||
>         !DNVALID_READPTR( pIDP8LobbiedApplication, sizeof( IDirectPlay8LobbiedApplication * ) ) )
>     {
>         DPFERR( "Invalid interface pointer specified for register lobby" );
>         return DPNERR_INVALIDPOINTER;
>     }
> 
945c955
<     if( dwFlags & ~(DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
---
>     if( dwFlags & ~(DPNENUMHOSTS_OKTOQUERYFORADDRESSING | DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
1664c1674
<     if( dwFlags & ~(DPNCONNECT_SYNC) )
---
>     if( dwFlags & ~(DPNCONNECT_SYNC | DPNCONNECT_OKTOQUERYFORADDRESSING) )
1980c1990
<     if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD) )
---
>     if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD | DPNSESSION_NODPNSVR) )
2229a2240
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
41c41
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\peer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
68d67
< #include <wchar.h>
119c118
< typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\server.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61d60
< #include <wchar.h>
110c109
< typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2,3c17,27
< TARGETPATHLIB=$(BASEDIR)\public\sdk\lib
< TARGETTYPE=DYNLINK
---
> DLLDEF=..\dnet.def
> UMTYPE=windows
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
4a29
> TARGETTYPE=DYNLINK
6,14c31,35
< !ifdef _BUILD_FOR_WIN2000
< UMTYPE=windows
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
16c37
< INCLUDES=..\;..\..\inc;..\..\protocol;..\..\common
---
> PASS1_PUBLISH={ $(O)\dpnet.lib = $(SDK_LIB_PATH)\dpnet.lib}
18c39,56
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
> 	   ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
>            ..\..\protocol\obj$(BUILD_ALT_DIR)\*\protocol.lib \
>            ..\..\dpnsvr\dpnsvlib\obj$(BUILD_ALT_DIR)\*\dpnsvlib.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
20d57
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
22,23c59,60
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
26c63,67
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28c69
< DLLDEF=..\dnet.def
---
> INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\protocol;..\..\common;..\..\dpnsvr\dpnsvlib;..\..\dpnsvr\inc
29a71,78
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
61a111
>          ..\voice.cpp \
68a119,126
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
71,92c129,131
< TARGETLIBS= \
< 	   ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
<            ..\..\protocol\obj$(BUILD_ALT_DIR)\*\protocol.lib \
<            $(BASEDIR)\public\sdk\lib\*\dpnaddr.lib \
<            ..\..\sp\wsock\daytona\obj$(BUILD_ALT_DIR)\*\dpnwsock.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<              $(SDK_LIB_PATH)\libcntpr.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38a39
> #include "DVoice.h"
48a50
> #include "voice.h"
165a168,169
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
199a204,205
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
232a239,240
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
267a276,277
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
302a313,314
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
338a351,352
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
606a621,622
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\worker.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
44a45
> #include "DVoice.h"
65a67
> #include "Voice.h"
586c588,592
<                     // BUGBUG: [mgere] [xbox] Removed Voice_Receive()
---
> 			hResultCode = Voice_Receive(pdnObject,
> 										pConnection->GetDPNID(),
> 										0,
> 										pvData,
> 										dwDataSize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addbase.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
260d259
< /* BUGBUG: [mgere] [xbox] Removed this function.
291d289
< */  return DPNERR_UNSUPPORTED;
302,303c300,359
< // BUGBUG: [mgere] [xbox] ANSI not supported
< 	return DPNERR_UNSUPPORTED;
---
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pszAddress == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer to address.  An address must be specified" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( !DNVALID_STRING_A( pszAddress ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid string specified for address" );
> 		DP8A_RETURN( DPNERR_INVALIDSTRING );
> 	}
> 
> 	DPF( DP8A_PARAMLEVEL, "pszAddress = %s", pszAddress );
> 
> 	WCHAR *szShadowBuffer = NULL;
> 
> 	DWORD dwStrSize = 0;
> 
> 	if( pszAddress != NULL )
> 	{
> 		dwStrSize = strlen(pszAddress)+1;
> 		
> 		szShadowBuffer = new WCHAR[dwStrSize];
> 
> 		if( szShadowBuffer == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto BUILDFROMURLW_RETURN;
> 		}
> 
> 		if( FAILED( hr = STR_jkAnsiToWide( szShadowBuffer, pszAddress, dwStrSize ) )  )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting URL to ANSI hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 			goto BUILDFROMURLW_RETURN;
> 		}
> 	}
> 
> 	hr = pdp8Address->SetURL( szShadowBuffer );
> 
> BUILDFROMURLW_RETURN:
> 
> 	if( szShadowBuffer )
> 		delete [] szShadowBuffer;
> 
> 	DP8A_RETURN( hr );	
446,447c502,568
< // BUGBUG: [mgere] [xbox] ANSI not supported.
< 	return DPNERR_UNSUPPORTED;
---
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pdwAddressSize == NULL ||
> 	   !DNVALID_WRITEPTR( pdwAddressSize, sizeof(DWORD) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for address size" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
> 	}
> 
> 	if( *pdwAddressSize > 0 &&
> 	   (pszAddress == NULL ||
> 	    !DNVALID_WRITEPTR( pszAddress, (*pdwAddressSize) ) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for address" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	DPF( DP8A_PARAMLEVEL, "pwszAddress = 0x%x pdwAddressSize = 0x%x (%u)",
> 	     pszAddress , pdwAddressSize, *pdwAddressSize );
> 
> 	WCHAR *szShadowBuffer = NULL;
> 
> 	if( *pdwAddressSize  != 0 )
> 	{
> 		szShadowBuffer = new WCHAR[*pdwAddressSize];
> 
> 		if( szShadowBuffer == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto GETURLW_RETURN;
> 		}
> 	}
> 	else
> 	{	
> 		szShadowBuffer= NULL;
> 	}
> 
> 	hr = pdp8Address->BuildURL( szShadowBuffer, pdwAddressSize );
> 
> 	if( hr == DPN_OK )
> 	{
> 		if( FAILED( hr = STR_jkWideToAnsi( pszAddress, szShadowBuffer, *pdwAddressSize ) ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting ANSI->WIDE hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 			goto GETURLW_RETURN;
> 		}
> 	}
> 	
> GETURLW_RETURN:
> 
> 	if( szShadowBuffer != NULL )
> 		delete [] szShadowBuffer;
> 
> 	DP8A_RETURN( hr );
862c983,984
< 	   dwDataType != DPNA_DATATYPE_BINARY )
---
> 	   dwDataType != DPNA_DATATYPE_BINARY &&
> 	   dwDataType != DPNA_DATATYPE_STRING_ANSI )
876a999,1012
> 		{
> 			DPF( DP8A_ERRORLEVEL, "String size and component size don't match" );
> 			DP8A_RETURN( DPNERR_INVALIDPARAM );
> 		}
> 	}
> 	else if( dwDataType == DPNA_DATATYPE_STRING_ANSI )
> 	{
> 		if( !DNVALID_STRING_A( (const CHAR * const) pComponentData ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Invalid string component specified" );
> 			DP8A_RETURN( DPNERR_INVALIDSTRING );
> 		}
> 
> 		if( ((strlen( (const CHAR * const) pComponentData)+1)*sizeof(char)) != dwComponentSize )
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
47a48
> #include <stdio.h>
48a50
> #include "dplegacy.h"
50d51
< #include <wchar.h>
398a400,418
> 	case DPNA_DATATYPE_STRING_ANSI:
>         wszUnicodeString = new WCHAR[dwRealDataSize];
>         if( wszUnicodeString == NULL )
>         {
>             DPF( 0, "Error allocating memory for conversion" );
>             return DPNERR_OUTOFMEMORY;
>         }
> 
> 		hr = STR_jkAnsiToWide( wszUnicodeString, (const char * const) pvData, dwRealDataSize );
> 
> 		if( FAILED( hr ) )
> 		{
> 		    DPF( 0, "Error unable to convert element ANSI->Unicode 0x%x", hr );
>             return DPNERR_CONVERSION;
> 		}
> 		pvRealData = wszUnicodeString;
> 	    dwRealDataSize = dwDataSize*sizeof(WCHAR);
> 		dwRealDataType = DPNA_DATATYPE_STRING;
> 	    break;
422a443,454
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     hr= SetSP( &CLSID_DP8SP_IPX );
>                 }
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_MODEMPROVIDER ) == 0 )
>                 {
>                     hr = SetSP( &CLSID_DP8SP_MODEM );
>                 }
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_SERIALPROVIDER ) == 0 )
>                 {
>                     hr = SetSP( &CLSID_DP8SP_SERIAL );
>                 }
1369a1402,1470
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ADDRESSOBJECT::SetDirectPlay4Address"
> HRESULT DP8ADDRESSOBJECT::SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize )
> {
>     PBYTE pbCurrentLocation;
>     PDPADDRESS pdpAddressChunk;
>     LONG lRemaining;
>     HRESULT hr = DPN_OK;
>     DWORD dwCurrentChunkSize;
>     DWORD dwNumElementsParsed = 0;
> 
> 	if( IsLocked() )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
> 		return DPNERR_NOTALLOWED;
> 	}
> 
>     // XBOX! This function will not be required on XBOX.  Have it return DPNERR_NOTSUPPORTED
>     ENTERLOCK();
> 
>     hr = Clear();
> 
>     if( FAILED( hr ) )
>     {
>         DPF( 0, "Failed to clear old address data hr=[0x%lx]", hr );
>         LEAVELOCK();
>         return hr;
>     }
> 
>     pbCurrentLocation = (PBYTE) pvDataBuffer;
>     lRemaining = dwDataSize;
> 
>     while( lRemaining > 0 )
>     {
>         pdpAddressChunk = (PDPADDRESS) pbCurrentLocation;
> 
>         if( sizeof( DPADDRESS ) > lRemaining )
>         {
>             DPF( 0, "Error parsing address, unexpected end of address" );
> 			LEAVELOCK();
>             return DPNERR_INVALIDADDRESSFORMAT;
>         }
> 
>         dwCurrentChunkSize = sizeof( DPADDRESS ) + pdpAddressChunk->dwDataSize;
> 
>         if( ((LONG) dwCurrentChunkSize) > lRemaining )
>         {
>             DPF( 0, "Error parsing address, unexpected end during data" );
> 			LEAVELOCK();
>             return DPNERR_INVALIDADDRESSFORMAT;
>         }
> 
>         hr = AddDP4Element( pdpAddressChunk, this );
> 
>         if( FAILED( hr ) )
>         {
>             DPF( 0, "Error adding next element" );
>             break;
>         }
> 
>         lRemaining -= dwCurrentChunkSize;
> 
>         pbCurrentLocation += dwCurrentChunkSize;
>     }
> 
>     LEAVELOCK();
> 
>     return hr;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
140a141,142
>     HRESULT SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addparse.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
27c27
< #include <wchar.h>
---
> #include <stdio.h>
569d568
< // BUGBUG: [mgere] [xbox] Removed wtol temporarily until it is implemented on xbox
571d569
< #ifdef _BUILD_FOR_WIN2000
573d570
< #endif
581,582d577
< // BUGBUG: [mgere] [xbox] Removed swscanf temporarily until it is implemented on xbox
< #ifdef _BUILD_FOR_WIN2000
607d601
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
34c34
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
24a25,31
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DPNAddress"
> 
> /*
31a39,67
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNAddress"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNAddress"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dllmain.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
29a30
> #include "creg.h"
38a40,87
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8Address.Address.1", L"DirectPlay8Address Object", 
> 							  L"dpnaddr.dll", CLSID_DirectPlay8Address, L"DirectPlay8Address.Address") )
> 	{
> 		DPFERR( "Could not register address object" );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Address) )
> 	{
> 		DPF( 0, "Failed to unregister server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
5a6,8
> 	DirectPlay8AddressCreate	@1
> 	DllRegisterServer	PRIVATE
> 	DllUnregisterServer PRIVATE
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnaddr.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address \0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,61
> 
> #endif
> 
> #endif    // !_MAC
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2,3c17,27
< TARGETPATHLIB=$(BASEDIR)\public\sdk\lib
< TARGETTYPE=DYNLINK
---
> DLLDEF=..\dnadd.def
> UMTYPE=windows
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
4a29
> TARGETTYPE=DYNLINK
6,14c31,35
< !ifdef _BUILD_FOR_WIN2000
< UMTYPE=windows
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
16c37
< INCLUDES=..\;..\..\inc;..\..\common
---
> PASS1_PUBLISH={ $(O)\dpnaddr.lib = $(SDK_LIB_PATH)\dpnaddr.lib}
18c39,54
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
>            ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\wsock32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
20d55
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
22,23c57,58
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
26c61,65
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28c67
< DLLDEF=..\dnadd.def
---
> INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\common
29a69,76
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
38a86
>          ..\dplegacy.cpp \
40a89,95
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
> 
> USER_C_FLAGS=-nologo -W3
43,62c98,100
< TARGETLIBS= \
<            ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\winsockx.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
63a64,75
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
> // {826F86D1-AE2C-4428-A66F-974381B25F5B}
> DEFINE_GUID(IID_IDirectPlay8AddressModem,
> 0x826f86d1, 0xae2c, 0x4428, 0xa6, 0x6f, 0x97, 0x43, 0x81, 0xb2, 0x5f, 0x5b);
> 
> // {59BE79FE-A96A-4710-9BD2-22A50E7B24BD}
> DEFINE_GUID(IID_IDirectPlay8AddressSerial,
> 0x59be79fe, 0xa96a, 0x4710, 0x9b, 0xd2, 0x22, 0xa5, 0xe, 0x7b, 0x24, 0xbd);
> 
71a84,86
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
> typedef struct IDirectPlay8AddressSerial  	*PDIRECTPLAY8ADDRESSSERIAL, *LPDIRECTPLAY8ADDRESSSERIAL;
> typedef struct IDirectPlay8AddressModem		*PDIRECTPLAY8ADDRESSMODEM, *LPDIRECTPLAY8ADDRESSMODEM;
87a103
> #define DPNA_DATATYPE_STRING_ANSI           0x00000005
348a365,417
> // values for baud rate
> #define DPNA_BAUD_RATE_110					110
> #define DPNA_BAUD_RATE_300					300
> #define DPNA_BAUD_RATE_600					600
> #define DPNA_BAUD_RATE_1200					1200
> #define DPNA_BAUD_RATE_2400					2400
> #define DPNA_BAUD_RATE_4800					4800
> #define DPNA_BAUD_RATE_9600					9600
> #define DPNA_BAUD_RATE_14400				14400
> #define DPNA_BAUD_RATE_19200				19200
> #define DPNA_BAUD_RATE_38400				38400
> #define DPNA_BAUD_RATE_56000				56000
> #define DPNA_BAUD_RATE_57600				57600
> #define DPNA_BAUD_RATE_115200				115200
> #define DPNA_BAUD_RATE_128000				128000
> #define DPNA_BAUD_RATE_256000				256000
> 
> //// values for baud rate
> //#define DPNA_BAUD_RATE_110					L"110"
> //#define DPNA_BAUD_RATE_300					L"300"
> //#define DPNA_BAUD_RATE_600					L"600"
> //#define DPNA_BAUD_RATE_1200					L"1200"
> //#define DPNA_BAUD_RATE_2400					L"2400"
> //#define DPNA_BAUD_RATE_4800					L"4800"
> //#define DPNA_BAUD_RATE_9600					L"9600"
> //#define DPNA_BAUD_RATE_14400				L"14400"
> //#define DPNA_BAUD_RATE_19200				L"19200"
> //#define DPNA_BAUD_RATE_38400				L"38400"
> //#define DPNA_BAUD_RATE_56000				L"56000"
> //#define DPNA_BAUD_RATE_57600				L"57600"
> //#define DPNA_BAUD_RATE_115200				L"115200"
> //#define DPNA_BAUD_RATE_128000				L"128000"
> //#define DPNA_BAUD_RATE_256000				L"256000"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE					L"1"
> #define DPNA_STOP_BITS_ONE_FIVE				L"1.5"
> #define DPNA_STOP_BITS_TWO					L"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE					L"NONE"
> #define DPNA_PARITY_EVEN					L"EVEN"
> #define DPNA_PARITY_ODD						L"ODD"
> #define DPNA_PARITY_MARK					L"MARK"
> #define DPNA_PARITY_SPACE					L"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE				L"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF			L"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS				L"RTS"
> #define DPNA_FLOW_CONTROL_DTR				L"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR			L"RTSDTR"
> 
350a420,422
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
352a425,487
> //// ANSI DEFINITIONS
> 
> // Header
> #define DPNA_HEADER_A						"x-directplay:/"
> #define DPNA_SEPARATOR_KEYVALUE_A			'='
> #define DPNA_SEPARATOR_USERDATA_A			'#'
> #define DPNA_SEPARATOR_COMPONENT_A			';'
> #define DPNA_ESCAPECHAR_A					'%'
> 
> // key names for address components
> #define DPNA_KEY_APPLICATION_INSTANCE_A		"applicationinstance"
> #define DPNA_KEY_BAUD_A						"baud"
> #define DPNA_KEY_DEVICE_A					"device"
> #define DPNA_KEY_FLOWCONTROL_A				"flowcontrol"
> #define DPNA_KEY_HOSTNAME_A					"hostname"
> #define DPNA_KEY_PARITY_A					"parity"
> #define DPNA_KEY_PHONENUMBER_A				"phonenumber"
> #define DPNA_KEY_PORT_A						"port"
> #define DPNA_KEY_PROGRAM_A					"program"
> #define DPNA_KEY_PROVIDER_A					"provider"
> #define DPNA_KEY_STOPBITS_A					"stopbits"
> 
> //// values for baud rate
> //#define DPNA_BAUD_RATE_110_A				"110"
> //#define DPNA_BAUD_RATE_300_A				"300"
> //#define DPNA_BAUD_RATE_600_A				"600"
> //#define DPNA_BAUD_RATE_1200_A				"1200"
> //#define DPNA_BAUD_RATE_2400_A				"2400"
> //#define DPNA_BAUD_RATE_4800_A				"4800"
> //#define DPNA_BAUD_RATE_9600_A				"9600"
> //#define DPNA_BAUD_RATE_14400_A				"14400"
> //#define DPNA_BAUD_RATE_19200_A				"19200"
> //#define DPNA_BAUD_RATE_38400_A				"38400"
> //#define DPNA_BAUD_RATE_56000_A				"56000"
> //#define DPNA_BAUD_RATE_57600_A				"57600"
> //#define DPNA_BAUD_RATE_115200_A				"115200"
> //#define DPNA_BAUD_RATE_128000_A				"128000"
> //#define DPNA_BAUD_RATE_256000_A				"256000"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE_A				"1"
> #define DPNA_STOP_BITS_ONE_FIVE_A			"1.5"
> #define DPNA_STOP_BITS_TWO_A				"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE_A					"NONE"
> #define DPNA_PARITY_EVEN_A					"EVEN"
> #define DPNA_PARITY_ODD_A					"ODD"
> #define DPNA_PARITY_MARK_A					"MARK"
> #define DPNA_PARITY_SPACE_A					"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE_A			"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF_A 		"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS_A				"RTS"
> #define DPNA_FLOW_CONTROL_DTR_A				"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR_A			"RTSDTR"
> 
> // Shortcut values
> #define DPNA_VALUE_TCPIPPROVIDER_A          "IP"
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
> #define DPNA_VALUE_MODEMPROVIDER_A          "MODEM"
> #define DPNA_VALUE_SERIALPROVIDER_A         "SERIAL"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
111,112d110
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
153a152,160
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {6D4A3650-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_MODEM, 0x6d4a3650, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {743B5D60-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_SERIAL, 0x743b5d60, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
177a185,187
> typedef struct IDirectPlay8LobbiedApplication	*PDNLOBBIEDAPPLICATION;
> typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
> 
665a676
> #define	DPNCONNECT_OKTOQUERYFORADDRESSING	0x0001
670a682
> #define	DPNENUMHOSTS_OKTOQUERYFORADDRESSING	0x0001
779a792
> #define DPNSESSION_NODPNSVR					0x0040
860c873
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
905c918
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
955c968
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpsp8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
56a57
> #define DPNSPF_OKTOQUERY			0x00000002		// OK for SP to ask the user for clarification on addresses
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
105c105
< 	DNASSERT( ulFlags == 0 );
---
> 	DNASSERT( ( ulFlags & ~( DPNCONNECT_OKTOQUERYFORADDRESSING ) ) == 0 );
106a107,111
> 	if ( ( ulFlags & DPNCONNECT_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		ConnData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\enum.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
117a118,122
> 	if ( ( dwFlags & DPNENUMHOSTS_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		EnumData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\initialize.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
351c351
< 		if((pSPD->hSendEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL){
---
> 		if((pSPD->hSendEvent = CreateEventA(NULL, FALSE, FALSE, NULL)) == NULL){
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2c17,26
< TARGETTYPE=LIBRARY
---
> 
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
3a28
> TARGETTYPE=LIBRARY
5,9d29
< !ifdef _BUILD_FOR_WIN2000
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< LINKER_FLAGS=-align:32
< !endif
11c31,35
< INCLUDES=..\common;..\inc;..\dnaddress
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
13c37,41
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE -DMICHAEL
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS)
15d42
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
17,18c44,55
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> 
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
> 
> INCLUDES=$(DXROOT)\inc;..\common;..\inc;..\dnaddress
> 
> 
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
21c58,63
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
34c76,78
< USE_NOLIBS=1
---
> #
> # Next specify options for the compiler.
> #
36c80,86
< TARGETLIBS=
---
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE /DMICHAEL
> MSC_OPTIMIZATION=/Odi /Zi
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\timer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
575c575
< 	hWorkToDoSem=CreateSemaphore(NULL,0,65535,NULL);
---
> 	hWorkToDoSem=CreateSemaphoreA(NULL,0,65535,NULL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
198,199c198,228
< // BUGBUG: [mgere] [xbox]  Removed all code in here.  I don't believe it's necessary anymore and it was using some COM functions that we don't have.
< 	return S_OK;
---
>     HRESULT		hr;
>     HINSTANCE	hdll;
>     LPGPCLASSFACTORY	pcf;
> 
> 
>     pcf = (LPGPCLASSFACTORY) This;
> 
>     /*
>      * call CoLockObjectExternal
>      */
>     hr = E_UNEXPECTED;
>     hdll = LoadLibraryA( "OLE32.DLL" );
>     if( hdll != NULL )
>     {
>         PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;
> 
> 
> 		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, "CoLockObjectExternal" ) );
>         if( lpCoLockObjectExternal != NULL )
>         {
>             hr = lpCoLockObjectExternal( (LPUNKNOWN) This, fLock, TRUE );
>         }
>         else
>         {
>         }
>     }
>     else
>     {
>     }
> 
> 	return hr;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
30a38,66
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNSPWinsock"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectDPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNSPWinsock"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
120a122,141
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( dwDebugLevel, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
> 					);
> 			break;
> 		}
> 
144,145d164
< // BUGBUG: [mgere] [xbox] Must convert this to unicode
< /*
193d211
< */
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> #include "resource.h"
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #include "windows.h"
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnwsock.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,153
> 
> #endif
> 
> #endif    // !_MAC
> 
> 
> 
> #ifdef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // TEXTINCLUDE
> //
> 
> 1 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "resource.h\0"
> END
> 
> 2 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "#include ""afxres.h""\r\n"
>     "\0"
> END
> 
> 3 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "\r\n"
>     "\0"
> END
> 
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // Dialog
> //
> 
> IDD_IP_SETTINGS DIALOG DISCARDABLE  0, 0, 194, 66
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION | 
>     WS_SYSMENU
> CAPTION "Enter host name"
> FONT 8, "MS Shell Dlg"
> BEGIN
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
> END
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // DESIGNINFO
> //
> 
> #ifdef APSTUDIO_INVOKED
> GUIDELINES DESIGNINFO DISCARDABLE 
> BEGIN
>     IDD_IP_SETTINGS, DIALOG
>     BEGIN
>         LEFTMARGIN, 7
>         RIGHTMARGIN, 187
>         TOPMARGIN, 7
>         BOTTOMMARGIN, 59
>     END
> END
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // String Table
> //
> 
> STRINGTABLE DISCARDABLE 
> BEGIN
>     IDS_FRIENDLYNAME_IPX    "DirectPlay8 IPX Service Provider"
>     IDS_FRIENDLYNAME_TCPIP  "DirectPlay8 TCP/IP Service Provider"
> END
> 
> #endif    // English (U.S.) resources
> /////////////////////////////////////////////////////////////////////////////
> 
> 
> 
> #ifndef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 3 resource.
> //
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> #endif    // not APSTUDIO_INVOKED
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock1.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,42c1,67
< #define p_accept accept
< #define p_bind bind
< #define p_closesocket closesocket
< #define p_connect connect
< #define p_gethostbyaddr gethostbyaddr
< #define p_gethostbyname gethostbyname
< #define p_gethostname gethostname
< #define p_getpeername getpeername
< #define p_getprotobyname getprotobyname
< #define p_getprotobynumber getprotobynumber
< #define p_getservbyname getservbyname
< #define p_getservbyport getservbyport
< #define p_getsockname getsockname
< #define p_getsockopt getsockopt
< #define p_htonl htonl
< #define p_htons htons
< #define p_inet_addr inet_addr
< #define p_inet_ntoa inet_ntoa
< #define p_ioctlsocket ioctlsocket
< #define p_listen listen
< #define p_ntohl ntohl
< #define p_ntohs ntohs
< #define p_recv recv
< #define p_recvfrom recvfrom
< #define p_select select
< #define p_send send
< #define p_sendto sendto
< #define p_setsockopt setsockopt
< #define p_shutdown shutdown
< #define p_socket socket
< //#define p_WSAAsyncGetHostByAddr WSAAsyncGetHostByAddr
< //#define p_WSAAsyncGetHostByName WSAAsyncGetHostByName
< //#define p_WSAAsyncGetProtoByName WSAAsyncGetProtoByName
< //#define p_WSAAsyncGetProtoByNumber WSAAsyncGetProtoByNumber
< //#define p_WSAAsyncGetServByName WSAAsyncGetServByName
< //#define p_WSAAsyncGetServByPort WSAAsyncGetServByPort
< //#define p_WSAAsyncSelect WSAAsyncSelect
< //#define p_WSACancelAsyncRequest WSACancelAsyncRequest
< #define p_WSACleanup WSACleanup
< #define p_WSAGetLastError WSAGetLastError
< #define p_WSASetLastError WSASetLastError
< #define p_WSAStartup WSAStartup
---
> //
> // DWNSOCK1.INC	Macros for dynamically linking to WinSock 1.1
> //
> 
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	//
> 	// Function available in both versions
> 	//
> 	DYNAMICWINSOCK(accept, LPFN_ACCEPT);
> 	DYNAMICWINSOCK(bind, LPFN_BIND);
> 	DYNAMICWINSOCK(closesocket, LPFN_CLOSESOCKET);
> 	DYNAMICWINSOCK(connect, LPFN_CONNECT);
> 	DYNAMICWINSOCK(gethostbyaddr, LPFN_GETHOSTBYADDR);
> 	DYNAMICWINSOCK(gethostbyname, LPFN_GETHOSTBYNAME);
> 	DYNAMICWINSOCK(gethostname, LPFN_GETHOSTNAME);
> 	DYNAMICWINSOCK(getpeername, LPFN_GETPEERNAME);
> 	DYNAMICWINSOCK(getprotobyname, LPFN_GETPROTOBYNAME);
> 	DYNAMICWINSOCK(getprotobynumber, LPFN_GETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(getservbyname, LPFN_GETSERVBYNAME);
> 	DYNAMICWINSOCK(getservbyport, LPFN_GETSERVBYPORT);
> 	DYNAMICWINSOCK(getsockname, LPFN_GETSOCKNAME);
> 	DYNAMICWINSOCK(getsockopt, LPFN_GETSOCKOPT);
> 	DYNAMICWINSOCK(htonl, LPFN_HTONL);
> 	DYNAMICWINSOCK(htons, LPFN_HTONS);
> 	DYNAMICWINSOCK(inet_addr, LPFN_INET_ADDR);
> 	DYNAMICWINSOCK(inet_ntoa, LPFN_INET_NTOA);
> 	DYNAMICWINSOCK(ioctlsocket, LPFN_IOCTLSOCKET);
> 	DYNAMICWINSOCK(listen, LPFN_LISTEN);
> 	DYNAMICWINSOCK(ntohl, LPFN_NTOHL);
> 	DYNAMICWINSOCK(ntohs, LPFN_NTOHS);
> 	DYNAMICWINSOCK(recv, LPFN_RECV);
> 	DYNAMICWINSOCK(recvfrom, LPFN_RECVFROM);
> 	DYNAMICWINSOCK(select, LPFN_SELECT);
> 	DYNAMICWINSOCK(send, LPFN_SEND);
> 	DYNAMICWINSOCK(sendto, LPFN_SENDTO);
> 	DYNAMICWINSOCK(setsockopt, LPFN_SETSOCKOPT);
> 	DYNAMICWINSOCK(shutdown, LPFN_SHUTDOWN);
> 	DYNAMICWINSOCK(socket, LPFN_SOCKET);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByAddr, LPFN_WSAASYNCGETHOSTBYADDR);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByName, LPFN_WSAASYNCGETHOSTBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByName, LPFN_WSAASYNCGETPROTOBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByNumber, LPFN_WSAASYNCGETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(WSAAsyncGetServByName, LPFN_WSAASYNCGETSERVBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetServByPort, LPFN_WSAASYNCGETSERVBYPORT);
> 	DYNAMICWINSOCK(WSAAsyncSelect, LPFN_WSAASYNCSELECT);
> 	DYNAMICWINSOCK(WSACancelAsyncRequest, LPFN_WSACANCELASYNCREQUEST);
> 	DYNAMICWINSOCK(WSACleanup, LPFN_WSACLEANUP);
> 	DYNAMICWINSOCK(WSAGetLastError, LPFN_WSAGETLASTERROR);
> 	DYNAMICWINSOCK(WSASetLastError, LPFN_WSASETLASTERROR);
> 	DYNAMICWINSOCK(WSAStartup, LPFN_WSASTARTUP);
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock2.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,27c1,3
< #ifdef UNICODE
< //	#define p_WSAAddressToString				WSAAddressToStringW
< //	#define p_WSADuplicateSocket				WSADuplicateSocketW
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersW
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsW
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoW
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdW
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassW
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginW
< //	#define p_WSALookupServiceNext				WSALookupServiceNextW
< //	#define p_WSASetService						WSASetServiceW
< //	#define p_WSASocket							WSASocketW
< //	#define p_WSAStringToAddress				WSAStringToAddressW
< #else
< //	#define p_WSAAddressToString				WSAAddressToStringA
< //	#define p_WSADuplicateSocket				WSADuplicateSocketA
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersA
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsA
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoA
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdA
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassA
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginA
< //	#define p_WSALookupServiceNext				WSALookupServiceNextA
< //	#define p_WSASetService						WSASetServiceA
< //	#define p_WSASocket							WSASocketA
< //	#define p_WSAStringToAddress				WSAStringToAddressA
< #endif // UNICODE
---
> //
> // DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
> //
29,53c5,70
< //#define p_WSAAccept WSAAccept
< #define p_WSACloseEvent WSACloseEvent
< //#define p_WSAConnect WSAConnect
< #define p_WSACreateEvent WSACreateEvent
< #define p_WSAEnumNetworkEvents WSAEnumNetworkEvents
< #define p_WSAEventSelect WSAEventSelect
< #define p_WSAGetOverlappedResult WSAGetOverlappedResult
< //#define p_WSAGetQOSByName WSAGetQOSByName
< //#define p_WSAHtonl WSAHtonl
< //#define p_WSAHtons WSAHtons
< #define p_WSAIoctl WSAIoctl
< //#define p_WSAJoinLeaf WSAJoinLeaf
< //#define p_WSALookupServiceEnd WSALookupServiceEnd
< //#define p_WSANtohl WSANtohl
< //#define p_WSANtohs WSANtohs
< #define p_WSARecv WSARecv
< //#define p_WSARecvDisconnect WSARecvDisconnect
< #define p_WSARecvFrom WSARecvFrom
< //#define p_WSARemoveServiceClass WSARemoveServiceClass
< #define p_WSAResetEvent WSAResetEvent
< #define p_WSASend WSASend
< //#define p_WSASendDisconnect WSASendDisconnect
< #define p_WSASendTo WSASendTo
< #define p_WSASetEvent WSASetEvent
< #define p_WSAWaitForMultipleEvents WSAWaitForMultipleEvents
---
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	DYNAMICWINSOCK(WSAAccept, LPFN_WSAACCEPT);
> 	DYNAMICWINSOCK(WSAAddressToStringA, LPFN_WSAADDRESSTOSTRINGA);
> 	DYNAMICWINSOCK(WSAAddressToStringW, LPFN_WSAADDRESSTOSTRINGW);
> 	DYNAMICWINSOCK(WSACloseEvent, LPFN_WSACLOSEEVENT);
> 	DYNAMICWINSOCK(WSAConnect, LPFN_WSACONNECT);
> 	DYNAMICWINSOCK(WSACreateEvent, LPFN_WSACREATEEVENT);
> 	DYNAMICWINSOCK(WSADuplicateSocketA, LPFN_WSADUPLICATESOCKETA);
> 	DYNAMICWINSOCK(WSADuplicateSocketW, LPFN_WSADUPLICATESOCKETW);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersA, LPFN_WSAENUMNAMESPACEPROVIDERSA);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersW, LPFN_WSAENUMNAMESPACEPROVIDERSW);
> 	DYNAMICWINSOCK(WSAEnumNetworkEvents, LPFN_WSAENUMNETWORKEVENTS);
> 	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
> 	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
> 	DYNAMICWINSOCK(WSAEventSelect, LPFN_WSAEVENTSELECT);
> 	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
> 	DYNAMICWINSOCK(WSAGetQOSByName, LPFN_WSAGETQOSBYNAME);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoA, LPFN_WSAGETSERVICECLASSINFOA);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoW, LPFN_WSAGETSERVICECLASSINFOW);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdA, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdW, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW);
> 	DYNAMICWINSOCK(WSAHtonl, LPFN_WSAHTONL);
> 	DYNAMICWINSOCK(WSAHtons, LPFN_WSAHTONS);
> 	DYNAMICWINSOCK(WSAInstallServiceClassA, LPFN_WSAINSTALLSERVICECLASSA);
> 	DYNAMICWINSOCK(WSAInstallServiceClassW, LPFN_WSAINSTALLSERVICECLASSW);
> 	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
> 	DYNAMICWINSOCK(WSAJoinLeaf, LPFN_WSAJOINLEAF);
> 	DYNAMICWINSOCK(WSALookupServiceBeginA, LPFN_WSALOOKUPSERVICEBEGINA);
> 	DYNAMICWINSOCK(WSALookupServiceBeginW, LPFN_WSALOOKUPSERVICEBEGINW);
> 	DYNAMICWINSOCK(WSALookupServiceEnd, LPFN_WSALOOKUPSERVICEEND);
> 	DYNAMICWINSOCK(WSALookupServiceNextA, LPFN_WSALOOKUPSERVICENEXTA);
> 	DYNAMICWINSOCK(WSALookupServiceNextW, LPFN_WSALOOKUPSERVICENEXTW);
> 	DYNAMICWINSOCK(WSANtohl, LPFN_WSANTOHL);
> 	DYNAMICWINSOCK(WSANtohs, LPFN_WSANTOHS);
> 	DYNAMICWINSOCK(WSARecv, LPFN_WSARECV);
> 	DYNAMICWINSOCK(WSARecvDisconnect, LPFN_WSARECVDISCONNECT);
> 	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
> 	DYNAMICWINSOCK(WSARemoveServiceClass, LPFN_WSAREMOVESERVICECLASS);
> 	DYNAMICWINSOCK(WSAResetEvent, LPFN_WSARESETEVENT);
> 	DYNAMICWINSOCK(WSASend, LPFN_WSASEND);
> 	DYNAMICWINSOCK(WSASendDisconnect, LPFN_WSASENDDISCONNECT);
> 	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
> 	DYNAMICWINSOCK(WSASetEvent, LPFN_WSASETEVENT);
> 	DYNAMICWINSOCK(WSASetServiceA, LPFN_WSASETSERVICEA);
> 	DYNAMICWINSOCK(WSASetServiceW, LPFN_WSASETSERVICEW);
> 	DYNAMICWINSOCK(WSASocketA, LPFN_WSASOCKETA);
> 	DYNAMICWINSOCK(WSASocketW, LPFN_WSASOCKETW);
> 	DYNAMICWINSOCK(WSAStringToAddressA, LPFN_WSASTRINGTOADDRESSA);
> 	DYNAMICWINSOCK(WSAStringToAddressW, LPFN_WSASTRINGTOADDRESSW);
> 	DYNAMICWINSOCK(WSAWaitForMultipleEvents, LPFN_WSAWAITFORMULTIPLEEVENTS);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
102a104
> 	m_hActiveSettingsDialog( NULL ),
129a132
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
362a366,373
> 		//
> 		// cancel any active dialogs
> 		// if there are no dialogs, cancel the active command
> 		//
> 		if ( m_hActiveSettingsDialog != NULL )
> 		{
> 			StopSettingsDialog( m_hActiveSettingsDialog );
> 		}
365a377,383
> 	else
> 	{
> 		//
> 		// there should be no active dialog if there isn't an active command
> 		//
> 		DNASSERT( m_hActiveSettingsDialog == NULL );
> 	}
847a866,872
> 	if ( m_hActiveSettingsDialog != NULL )
> 	{
> 		StopSettingsDialog( m_hActiveSettingsDialog );
> 		Unlock();
> 	}
> 	else
> 	{
853a879
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
290a291,297
> 		// UI functions
> 		//
> 		virtual	HRESULT	ShowSettingsDialog( CThreadPool *const pThreadPool ) = 0;
> 		virtual	void	StopSettingsDialog( const HWND hDlg ) = 0;
> 		virtual	void	SettingsDialogComplete( const HRESULT hr ) = 0;
> 
> 		//
309a317,318
> 
> 		HWND			m_hActiveSettingsDialog;		// handle of active settings dialog
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
44a46
> #include	"IPXAddress.h"
81c83,84
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
99a103,104
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
114a120
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
188a195,200
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
209a222,228
> 	switch ( OSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
213a233,255
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
238a281,282
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
271a316,317
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
302a349,354
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
444a497,503
> 	switch ( OSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
447a507,530
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
479a563,564
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
500a586,587
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
87a88,90
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
117a121
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
118a123
> 
148a154
> 		INT		m_Win9xReceiveWSAReturn;		
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
84a86
> const DWORD	g_dwIPBroadcastAddressSize = sizeof( g_IPBroadcastAddress );
978,980d979
< // BUGBUG: [mgere] [xbox] No need to enum adapters anymore since we only have one.
< // need to complete the removal of this functionality at a later date.
< /*
1300d1298
< */	return DPNERR_UNSUPPORTED;
1480a1479,1484
> 	//
> 	// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1481a1486,1504
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1484a1508,1510
> 		case 2:
> 		default:
> 		{
1485a1512,1514
> 			break;
> 		}
> 	}
1555a1585,1590
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1556a1592,1610
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1559a1614,1616
> 		case 2:
> 		default:
> 		{
1560a1618,1620
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
38a40
> #include	"StrUtils.h"
51a54
> #include	"IPUI.h"
94a98
> 	memset( m_TempHostName, 0x00, sizeof( m_TempHostName ) );
116a121,342
> // CIPEndpoint::ShowSettingsDialog - show dialog for settings
> //
> // Entry:		Pointer to thread pool
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CIPEndpoint::ShowSettingsDialog( CThreadPool *const pThreadPool )
> {
> 	HRESULT	hr;
> 
> 
> 	DNASSERT( pThreadPool != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	AddRef();
> 	hr = pThreadPool->SpawnDialogThread( DisplayIPHostNameSettingsDialog, &m_hActiveSettingsDialog, this );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to start IP hostname dialog!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:	
> 	DecRef();
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::SettingsDialogComplete - dialog has completed
> //
> // Entry:		Error code for dialog
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::SettingsDialogComplete( const HRESULT hDialogResult )
> {
> 	HRESULT					hr;
> 	HRESULT					hTempResult;
> 	IDirectPlay8Address		*pBaseAddress;
> 	DWORD					dwTotalAddressBufferSize;
> 	char					*pTempAddressString;
> 	WCHAR					WCharHostName[ sizeof( m_TempHostName ) + 1 ];
> 	DWORD					dwWCharHostNameSize;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = hDialogResult;
> 	pBaseAddress = NULL;
> 
> 	pTempAddressString = NULL;
> 
> 	//
> 	// since the dialog is exiting, clear our handle to the dialog
> 	//
> 	m_hActiveSettingsDialog = NULL;
> 
> 	//
> 	// dialog failed, fail the user's command
> 	//
> 	if ( hr != DPN_OK )
> 	{
> 		if ( hr != DPNERR_USERCANCEL)
> 		{
> 			DPF( 0, "Failing endpoint hostname dialog!" );
> 			DisplayErrorCode( 0, hr );
> 
> 		}
> 
> 		goto Failure;
> 	}
> 
> 	//
> 	// The dialog completed OK, rebuild remote address and complete command
> 	//
> 
> 	//
> 	// get the base DNADDRESS
> 	//
> 	pBaseAddress = m_pRemoteMachineAddress->DP8AddressFromSocketAddress();
> 	if ( pBaseAddress == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "SettingsDialogComplete: Failed to get base address when completing IP hostname dialog!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// Add the new 'HOSTNAME' parameter to the address.  If the hostname is blank
> 	// and this is an enum, copy the broadcast hostname.
> 	//
> 	if ( ( m_TempHostName[ 0 ] == '\0' ) && ( m_EndpointType == ENDPOINT_TYPE_ENUM ) )
> 	{
> 		DNASSERT( sizeof( WCharHostName ) >= g_dwIPBroadcastAddressSize );
> 		memcpy( WCharHostName, g_IPBroadcastAddress, g_dwIPBroadcastAddressSize );
> 		dwWCharHostNameSize = g_dwIPBroadcastAddressSize;
> 	}
> 	else
> 	{
> 		dwWCharHostNameSize = LENGTHOF( WCharHostName );
> 		hr = STR_AnsiToWide( m_TempHostName, -1, WCharHostName, &dwWCharHostNameSize );
> 		DNASSERT( hr == DPN_OK );
> 		dwWCharHostNameSize *= sizeof( WCHAR );
> 	}
> 
> 	hr = IDirectPlay8Address_AddComponent( pBaseAddress, DPNA_KEY_HOSTNAME, WCharHostName, dwWCharHostNameSize, DPNA_DATATYPE_STRING );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "SettingsDialogComplete: Failed to add hostname to address!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// set the address
> 	//
> 	hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pBaseAddress, SP_ADDRESS_TYPE_HOST );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to rebuild DNADDRESS when completing IP hostname dialog!" );
> 		DNASSERT( FALSE );
> 		goto Failure;
> 	}
> 
> 	//
> 	// the remote machine address has been adjusted, finish the command
> 	//
> 	switch ( m_EndpointType )
> 	{
> 		case ENDPOINT_TYPE_ENUM:
> 		{
> 			hr = CompleteEnumQuery();
> 			if ( hr != DPN_OK )
> 			{
> 				DPF( 0, "Problem completing EnumQuery after asking user for hostname!" );
> 				DisplayDNError( 0, hr );
> 			}
> 
> 			break;
> 		}
> 
> 		case ENDPOINT_TYPE_CONNECT:
> 		{
> 			hr = CompleteConnect();
> 			if ( hr != DPN_OK )
> 			{
> 				DPF( 0, "Problem completing Connect after asking user for hostname!" );
> 				DisplayDNError( 0, hr );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			hr = DPNERR_GENERIC;
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pBaseAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DNASSERT( pTempAddressString == NULL );
> 	if ( pBaseAddress != NULL )
> 	{
> 		DNFree( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DecRef();
> 
> 	return;
> 
> Failure:
> 	//
> 	// close this endpoint
> 	//
> 	Close( hr );
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::StopSettingsDialog - stop an active settings dialog
> //
> // Entry:		Handle of dialog to close
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::StopSettingsDialog( const HWND hDlg)
> {
> 	StopIPHostNameSettingsDialog( hDlg );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
216a443
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
262,263d488
< 
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
22a23,24
> #define	TEMP_HOSTNAME_LENGTH	100
> 
52a55,67
> 		// UI functions
> 		//
> 		HRESULT		ShowSettingsDialog( CThreadPool *const pThreadPool );
> 		void		SettingsDialogComplete( const HRESULT hr );
> 		void		StopSettingsDialog( const HWND hDlg );
> 		void		SetTempHostName( const char *const pHostName, const UINT_PTR uHostNameLength )
> 		{
> 			DNASSERT( pHostName[ uHostNameLength ] == '\0' );
> 			DNASSERT( ( uHostNameLength + 1 ) <= LENGTHOF( m_TempHostName ) );
> 			memcpy( m_TempHostName, pHostName, ( uHostNameLength + 1 ) );
> 		}
> 
> 		//
69a85
> 		char		m_TempHostName[ TEMP_HOSTNAME_LENGTH ];
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\locals.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62a63,67
> //
> // OS version
> //
> UINT_PTR	g_uOSType;
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\locals.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
103a104,108
> //
> // OS version
> //
> extern	UINT_PTR	g_uOSType;
> 
105a111,125
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // OSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OSType
> // ------------------------------
> inline UINT_PTR	OSType( void )
> {
> 	return	g_uOSType;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
50a52
> #include	"IPXAddress.h"
54a57
> #include	"IPXEndpt.h"
82a86
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
84a89
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
174a180,186
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
193a206,222
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
> 	
318a348,354
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
328a365,370
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
399a442
> 
428a472,515
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	CIPXAddress	*pReturnAddress;
> 
> 	
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	
> 	DNEnterCriticalSection( &g_AddressLock );
> 	pReturnAddress = g_pIPXAddressPool->Get();
> 	DNLeaveCriticalSection( &g_AddressLock );
> 
> 	return	pReturnAddress;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	
> 	DNEnterCriticalSection( &g_AddressLock );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> 	DNLeaveCriticalSection( &g_AddressLock );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
438a526,541
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
59a62,63
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
61a66
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\rsip.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40a41
> #include	"Registry.h"
512a514,517
> 
> 		hr = GetGatewayFromRegistry( reinterpret_cast<BYTE*>( gwipaddr ), sizeof( gwipaddr ) );
> 
> 		if(hr != DPN_OK){
514a520,522
> 		}
> 
> 		DPF(0,"Found suggested RSIP gateway in registry %s, running on Win95?\n",gwipaddr);
651d658
<         WCHAR wszIPHLPAPI[] = L"IPHLPAPI.DLL";
687c694
< 	hIpHlpApi = LoadLibrary(wszIPHLPAPI);
---
> 	hIpHlpApi = LoadLibrary("IPHLPAPI.DLL");
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
258a260,267
> 	
> 	//
> 	// Winsock 2 functionality always exists on WinNT.  If we're on Win9x, we can
> 	// only use Winsock2 interfaces for TCP.
> 	//
> 	if ( ( OSType() == VER_PLATFORM_WIN32_NT ) ||
> 		 ( ( LOWORD( GetWinsockVersion() ) >= 2 ) && ( m_pSPData->GetType() == TYPE_IP ) ) )
> 	{
259a269,273
> 	}
> 	else
> 	{
> 		m_pSendFunction = Winsock1Send;
> 	}
405a420,431
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( ( LOWORD( GetWinsockVersion() ) == 1 ) ||
> 			 ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_pSPData->GetType() == TYPE_IPX ) ) )
> 		{
> 			m_pSPData->GetThreadPool()->RemoveSocketPort( this );
> 		}
> 
836a863,875
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
838a878,974
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ),	// pointer to receive buffer
> 								pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize,		// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();
> 
> Exit:
> 	return;
> }
839a976,978
> 
> 
> //**********************************************************************
840a980,1125
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
867,868c1152,1153
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( OSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
874a1160,1168
> 	// lock the 'pending operation' list over the call to Winsock to prevent the
> 	// operation from being completed while it's being set up.
> 	//
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->LockWriteData();
> 	}
> 	
> 	//
880a1175,1177
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
892a1190,1194
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->UnlockWriteData();
> 	}
> 
933a1236,1238
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1007c1312,1313
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( OSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1016a1323,1331
> 	// lock the 'pending operation' list over the call to Winsock to prevent the
> 	// operation from being completed while it's being set up.
> 	//
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->LockReadData();
> 	}
> 
> 	//
1022a1338,1340
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1033a1352,1357
> 	
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->UnlockReadData();
> 	}
> 
1080a1405,1406
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1114a1441,1442
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1159a1488,1489
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
1730a2061,2067
> 	switch ( OSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1775a2113,2176
> 			break;
> 		}
> 
> 		//
> 		// Win9x.
> 		// If this is not an IPX socket and Winsock 2 (or greater) is available,
> 		// call the Winsock 2 read function.  If this is IPX or we're stuck with
> 		// Winsock 1, inform the thread pool as such.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 
> 			if ( ( LOWORD( GetWinsockVersion() ) >= 2 ) &&
> 				 ( m_pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// we're using Winsock2, call for two outstanding reads per socket.
> 				//
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #1 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #2 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 			}
> 			else
> 			{
> 				DNASSERT( m_pSPData != NULL );
> 				hr = m_pSPData->GetThreadPool()->AddSocketPort( this );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Failed to add to active socket list!" );
> 					DisplayDNError( 0, hr );
> 					goto Failure;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
1975d2375
< 
2413a2814,2971
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
> 
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			goto Exit;
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = pReadData->m_dwOverlappedBytesReceived;
> 					pReadData->m_dwOverlappedBytesReceived = 0;
> 					ProcessReceivedData( pReadData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();	
> 	DecRef();
> 
> 	return;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
239a240
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
245a247,249
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
288a293
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,3c1,5
< TARGETNAME=dpnwsock
< TARGETTYPE=DYNLINK
< TARGETPATH=obj
---
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
5c7,17
< !ifdef _BUILD_FOR_WIN2000
---
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
> TARGETNAME=dpnwsock
> DLLDEF=..\wsocksp.def
7,13d18
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
15c20,26
< INCLUDES=..\..\;..\..\..\inc;..\..\..\common;..\..\..\..\dnaddress
---
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
17c28,29
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> TARGETPATH=obj
> TARGETTYPE=DYNLINK
19c31,35
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
21,22c37,58
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
>            ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
> 
> #
> # If a debug mode is selected, make sure we include the defines to make the
> # logging code operate.
> #
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
25c61,71
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
27c73,77
< DLLDEF=..\wsocksp.def
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28a79,88
> INCLUDES=$(DXROOT)\inc;..\..\..\inc;..\..\..\common;..\..\..\dnaddress
> 
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
32a93
> 	 ..\DWinsock.cpp \
36a98,100
> 	 ..\IPUI.cpp \
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
39a104
>          ..\Registry.cpp \
48a114,116
> #
> # Next specify options for the compiler.
> #
49a118,120
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNWSock_EXPORTS /DCINTERFACE
> 
> USER_C_FLAGS=-nologo -W3
52,72c123,124
< TARGETLIBS= \
<            ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
<            $(BASEDIR)\public\sdk\lib\*\dpnaddr.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<            $(BASEDIR)\public\sdk\lib\*\winsockx.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
104c104
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
122c122,123
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
158c159,160
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
241a244
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
242a246
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
245c249
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
252c256
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
279a284
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
48a50
> #include	"IPXAddress.h"
54a57
> #include	"IPXEndpt.h"
224a228,257
> 	switch ( OSType() )
> 	{
> 		//
> 		// Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
> 			DPF( 8, "WinNT detected!" );
> 			break;
> 		}
> 
> 		//
> 		// Windows 95, 98
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DPF( 8, "Win9x detected!" );
> 			break;
> 		}
> 
> 		// other version (unsupported!)
> //		case VER_PLATFORM_WIN32_CE:
> 		case VER_PLATFORM_WIN32s:
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
584a618,623
> 		case TYPE_IPX:
> 		{
> 			pReturn = CreateIPXEndpoint( &EndpointPoolContext );
> 			break;
> 		}
> 
753a793,798
> 		case TYPE_IPX:
> 		{
> 			pReturn = CreateIPXAddress();
> 			break;
> 		}
> 
784a830,835
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
121a123,142
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
128a150,160
> //
> // structure passed to dialog threads
> //
> typedef	struct	_DIALOG_THREAD_PARAM
> {
> 	DIALOG_FUNCTION	*pDialogFunction;
> 	HWND			*phDialog;
> 	void			*pContext;
> 	CThreadPool		*pThisThreadPool;
> } DIALOG_THREAD_PARAM;
> 
233c265,272
< 	DEBUG_ONLY( 
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( OSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
235c274,275
< 	)
---
> 						break;
> 					}
236a277,284
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
243c291,298
< 	DEBUG_ONLY(
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( OSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
245c300,301
< 	)
---
> 						break;
> 					}
246a303,310
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
280a345,351
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
337a409,413
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( OSType() )
> 	{
340a417,418
> 		case VER_PLATFORM_WIN32_NT:
> 		{
346a425,451
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
375a481,482
> 	SYSTEM_INFO		SystemInfo;
> 	UINT_PTR		uDesiredThreads;
382a490,494
> 	//
> 	// get machine information
> 	//
> 	memset( &SystemInfo, 0x00, sizeof( SystemInfo ) );
> 	GetSystemInfo( &SystemInfo );
402a515,521
> 	uDesiredThreads = ( SystemInfo.dwNumberOfProcessors * 2 ) + 2;
> 	DNASSERT( uDesiredThreads != 0 );
> 	while ( uDesiredThreads > 0 )
> 	{
> 		uDesiredThreads--;
> 		StartNTCompletionThread();
> 	}
404,408d522
<     StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 
433a548,783
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT				hr;
> 	HANDLE				hPrimaryThread;
> 	HANDLE				hSecondaryThread;
> 	DWORD				dwPrimaryThreadID;
> 	DWORD				dwSecondaryThreadID;
> 	WIN9X_THREAD_DATA	*pPrimaryThreadInput;
> 	WIN9X_THREAD_DATA	*pSecondaryThreadInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	hPrimaryThread = NULL;
> 	hSecondaryThread = NULL;
> 	pPrimaryThreadInput = NULL;
> 	pSecondaryThreadInput = NULL;
> 
> 	//
> 	// Win9x requires completion events for Winsock2.  Always allocate the
> 	// events even though the they might not be used.
> 	//
> 	DNASSERT( m_hWinsock2SendComplete == NULL );
> 	m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 										   TRUE,	// manual reset
> 										   FALSE,	// start unsignalled
> 										   NULL		// pointer to name (none)
> 										   );
> 	if ( m_hWinsock2SendComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Send!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 	m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 											  TRUE,		// manual reset
> 											  FALSE,	// start unsignalled
> 											  NULL		// pointer to name (none)
> 											  );
> 	if ( m_hWinsock2ReceiveComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Receive!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	//
> 	// create parameters to worker threads
> 	//
> 	pPrimaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pPrimaryThreadInput ) ) );
> 	if ( pPrimaryThreadInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for primary Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	pSecondaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pSecondaryThreadInput ) ) );
> 	if ( pSecondaryThreadInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for secondary Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pPrimaryThreadInput, 0x00, sizeof( *pPrimaryThreadInput ) );
> 	pPrimaryThreadInput->pThisThreadPool = this;
> 	
> 	DBG_CASSERT( sizeof( *pPrimaryThreadInput ) == sizeof( *pSecondaryThreadInput ) );
> 	memcpy( pSecondaryThreadInput, pPrimaryThreadInput, sizeof( *pSecondaryThreadInput ) );
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	IncrementActiveThreadCount();
> 	
> 	//
> 	// Create one worker thread and boost its priority.  If the primary thread
> 	// can be created and boosted, create a secondary thread.  Do not create a
> 	// secondary thread if the primary could not be boosted because the system
> 	// is probably low on resources.
> 	//
> 	hPrimaryThread = CreateThread( NULL,					// pointer to security attributes (none)
> 								   0,						// stack size (default)
> 								   PrimaryWin9xThread,		// pointer to thread function
> 								   pPrimaryThreadInput,		// pointer to input parameter
> 								   0,						// let it run
> 								   &dwPrimaryThreadID		// pointer to destination of thread ID
> 								   );
> 	if ( hPrimaryThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		DecrementActiveThreadCount();
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		goto Failure;
> 	}
> 	pPrimaryThreadInput = NULL;
> 
> 
> 	DPF( 8, "Created primary Win9x thread: 0x%x\tTotal Thread Count: %d", dwPrimaryThreadID, ThreadCount() );
> 	DNASSERT( hPrimaryThread != NULL );
> 	if ( SetThreadPriority( hPrimaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of primary Win9x read thread!  Not starting secondary thread" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 	else
> 	{
> 		//
> 		// primary thread was created and boosted, create a secondary thread
> 		//
> 		IncrementActiveThreadCount();
> 		hSecondaryThread = CreateThread( NULL,						// pointer to security attributes (none)
> 										 0,							// stack size (default)
> 										 SecondaryWin9xThread,		// pointer to thread function
> 										 pSecondaryThreadInput,		// pointer to input parameter
> 										 0,							// let it run
> 										 &dwSecondaryThreadID		// pointer to destination of thread ID
> 										 );
> 		if ( hSecondaryThread != NULL )
> 		{
> 			DPF( 8, "Created secondary Win9x thread: 0x%x\tTotal Thread Count: %d", dwSecondaryThreadID, ThreadCount() );
> 			
> 			pSecondaryThreadInput = NULL;
> 			DNASSERT( hSecondaryThread != NULL );
> 			if ( SetThreadPriority( hSecondaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to boost priority of secondary Win9x thread!" );
> 				DisplayErrorCode( 0, dwError );
> 			}
> 		}
> 		else
> 		{
> 			//
> 			// thread startup failed, decrement active thread count
> 			//
> 			DecrementActiveThreadCount();
> 		}
> 	}
> 
> 
> Exit:
> 	if ( pPrimaryThreadInput != NULL )
> 	{
> 		DNFree( pPrimaryThreadInput );
> 		pPrimaryThreadInput = NULL;
> 	}
> 
> 	if ( pSecondaryThreadInput != NULL )
> 	{
> 		DNFree( pSecondaryThreadInput );
> 		pSecondaryThreadInput = NULL;
> 	}
> 
> 	if ( hPrimaryThread != NULL )
> 	{
> 		if ( CloseHandle( hPrimaryThread ) == FALSE )
> 		{
> 			DWORD	dwError;
> 
> 
> 			dwError = GetLastError();
> 			DPF( 0, "Problem closing Win9x thread hanle!" );
> 			DisplayErrorCode( 0, dwError );
> 		}
> 
> 		hPrimaryThread = NULL;
> 	}
> 
> 	if ( hSecondaryThread != NULL )
> 	{
> 		if ( CloseHandle( hSecondaryThread ) == FALSE )
> 		{
> 			DWORD	dwError;
> 
> 
> 			dwError = GetLastError();
> 			DPF( 0, "Problem closing Win9x thread hanle!" );
> 			DisplayErrorCode( 0, dwError );
> 		}
> 
> 		hSecondaryThread = NULL;
> 	}
> 
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
532a883,884
> 	if ( OSType() == VER_PLATFORM_WIN32_NT )
> 	{	
553a906
> 	}
629a983,986
> 
> 		DNASSERT( ( OSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
647a1005,1006
> 		DNASSERT( ( OSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
791a1151
> 	m_IPXReadIODataPool.Deinitialize();
839d1198
< 			
843a1203,1211
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			break;
> 		}
> 
> 		//
921a1290,1298
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1176a1554,1555
> 	switch ( OSType() )
> 	{
1179a1559,1560
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1196a1578,1606
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( m_JobQueue.SignalPendingJob() == FALSE )
> 			{
> 				hr = DPNERR_OUTOFMEMORY;
> 				DPF( 0, "Failed to signal pending job!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1307a1718,1719
> 	if ( OSType() == VER_PLATFORM_WIN32_NT )
> 	{
1314a1727
> 	}
1516a1930,2030
> // CThreadPool::SpawnDialogThread - start a secondary thread to display service
> //		provider UI.
> //
> // Entry:		Pointer to dialog function
> //				Pointer destination for copy of dialog handle
> //				Dialog context
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext )
> {
> 	HRESULT	hr;
> 	HANDLE	hDialogThread;
> 	DIALOG_THREAD_PARAM		*pThreadParam;
> 	DWORD	dwThreadID;
> 
> 
> 	DNASSERT( pDialogFunction != NULL );
> 	DNASSERT( phDialog != NULL );
> 	DNASSERT( pDialogContext != NULL );		// why would anyone not want a dialog context??
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pThreadParam = NULL;
> 
> 	//
> 	// create and initialize thread param
> 	//
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( DNMalloc( sizeof( *pThreadParam ) ) );
> 	if ( pThreadParam == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for dialog thread!" );
> 		goto Failure;
> 	}
> 
> 	pThreadParam->pDialogFunction = pDialogFunction;
> 	pThreadParam->phDialog = phDialog;
> 	pThreadParam->pContext = pDialogContext;
> 	pThreadParam->pThisThreadPool = this;
> 
> 	//
> 	// assume that a thread will be created
> 	//
> 	IncrementActiveThreadCount();
> 
> 	//
> 	// create thread
> 	//
> 	hDialogThread = CreateThread( NULL,					// pointer to security (none)
> 								  0,					// stack size (default)
> 								  DialogThreadProc,		// thread procedure
> 								  pThreadParam,			// thread param
> 								  0,					// creation flags (none)
> 								  &dwThreadID );		// pointer to thread ID
> 	if ( hDialogThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// decrement active thread count and report error
> 		//
> 		DecrementActiveThreadCount();
> 		
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to start dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		goto Failure;
> 	}
>   								
> 	if ( CloseHandle( hDialogThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing handle from create dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:
> 	if ( pThreadParam != NULL )
> 	{
> 		DNFree( pThreadParam );
> 		pThreadParam = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
1536a2051,2052
> 	switch ( OSType() )
> 	{
1537a2054,2063
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( NTCompletionThreadCount() == 0 );
> 			break;
> 		}
> 
> 		//
1539a2066,2067
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1541a2070,2071
> 			break;
> 		}
1542a2073,2082
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1571a2112,2113
> 	switch ( OSType() )
> 	{
1572a2115,2122
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1578a2129,2130
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1618a2171,2183
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1698a2264,2410
> // CThreadPool::AddSocketPort - add a socket to the Win9x watch list
> //
> // Entry:		Pointer to SocketPort
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::AddSocketPort( CSocketPort *const pSocketPort )
> {
> 	HRESULT	hr;
> 	BOOL	fSocketAdded;
> 
> 	
> 	DNASSERT( pSocketPort != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	fSocketAdded = FALSE;
> 
> 	Lock();
> 
> 	//
> 	// We're capped by the number of sockets we can use for Winsock1.  Make
> 	// sure we don't allocate too many sockets.
> 	//
> 	if ( m_uReservedSocketCount == FD_SETSIZE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "There are too many sockets allocated on Winsock1!" );
> 		goto Failure;
> 	}
> 
> 	m_uReservedSocketCount++;
> 	
> 	DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 	m_pSocketPorts[ m_SocketSet.fd_count ] = pSocketPort;
> 	m_SocketSet.fd_array[ m_SocketSet.fd_count ] = pSocketPort->GetSocket();
> 	m_SocketSet.fd_count++;
> 	fSocketAdded = TRUE;
> 
> 	//
> 	// add a reference to note that this socket port is being used by the thread
> 	// pool
> 	//
> 	pSocketPort->AddRef();
> 
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when adding socket port to active list!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> Exit:
> 	Unlock();
> 	
> 	return	hr;
> 
> Failure:
> 	if ( fSocketAdded != FALSE )
> 	{
> 		AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
> 		m_SocketSet.fd_count--;
> 		m_pSocketPorts[ m_SocketSet.fd_count ] = NULL;
> 		m_SocketSet.fd_array[ m_SocketSet.fd_count ] = NULL;
> 		fSocketAdded = FALSE;
> 	}
> 
> 	m_uReservedSocketCount--;
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::RemoveSocketPort - remove a socket from the Win9x watch list
> //
> // Entry:		Pointer to socket port to remove
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::RemoveSocketPort( CSocketPort *const pSocketPort )
> {
> 	UINT_PTR	uIndex;
> 
> 
> 	DNASSERT( pSocketPort != NULL );
> 	
> 	Lock();
> 
> 	uIndex = m_SocketSet.fd_count;
> 	DNASSERT( uIndex != 0 );
> 	while ( uIndex != 0 )
> 	{
> 		uIndex--;
> 
> 		if ( m_pSocketPorts[ uIndex ] == pSocketPort )
> 		{
> 			m_uReservedSocketCount--;
> 			m_SocketSet.fd_count--;
> 
> 			memmove( &m_pSocketPorts[ uIndex ],
> 					 &m_pSocketPorts[ uIndex + 1 ],
> 					 ( sizeof( m_pSocketPorts[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			memmove( &m_SocketSet.fd_array[ uIndex ],
> 					 &m_SocketSet.fd_array[ uIndex + 1 ],
> 					 ( sizeof( m_SocketSet.fd_array[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			//
> 			// clear last entry which is now unused
> 			//
> 			memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) );
> 			memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) );
> 
> 			//
> 			// end the loop
> 			//
> 			uIndex = 0;
> 		}
> 	}
> 
> 	Unlock();
> 	
> 	pSocketPort->DecRef();
> 
> 	//
> 	// It's really not necessary to signal a new job here because there were
> 	// active sockets on the last iteration of the Win9x thread.  That means the
> 	// Win9x thread was in a polling mode to check for sockets and the next time
> 	// through it will notice that there is a missing socket.  By signalling the
> 	// job event we reduce the time needed for the thread to figure out that the
> 	// socket is gone.
> 	//
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when removeing socket port to active list!" );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
1842a2555,3375
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwOverlappedBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				//
> 				// Overlapped results will complete with success and zero bytes
> 				// transferred when the overlapped structure is checked BEFORE
> 				// the operation has really been subnitted.  This is a possibility
> 				// with the current code.  To combat this, check the sent bytes
> 				// for zero (we'll never send zero bytes).
> 				//
> 				if ( pWriteIOData->m_dwOverlappedBytesSent == 0 )
> 				{
> 					goto SkipSendCompletion;
> 				}
> 
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 				pWriteIOData->m_dwOverlappedBytesSent = 0;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					//
> 					// WSAENOTSOCK = the socket has been closed, most likely
> 					// as a result of a command completing or being cancelled.
> 					//
> 					case WSAENOTSOCK:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_USERCANCEL;
> 						break;
> 					}
> 
> 					//
> 					// other error, stop and look
> 					//
> 					default:
> 					{
> 						INT3;
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwOverlappedBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				//
> 				// Overlapped results will complete with success and zero bytes
> 				// transferred when the overlapped structure is checked BEFORE
> 				// the operation has really been subnitted.  This is a possibility
> 				// with the current code.  To combat this, check the received bytes
> 				// for zero (the return when the overlapped request was checked before
> 				// it was sent) and check the return address (it's possible that someone
> 				// really sent zero bytes).
> 				//
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				if ( ( pReadIOData->m_dwOverlappedBytesReceived != 0 ) &&
> 					 ( pReadIOData->m_pSourceSocketAddress->IsUndefinedHostAddress() == FALSE ) )
> 				{
> 					pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 				}
> 				else
> 				{
> 					goto SkipReceiveCompletion;
> 				}
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::PrimaryWin9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::PrimaryWin9xThread( void *pParam )
> {
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 	
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Primary Win9x thread failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> //	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> //	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 	
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 	
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		DWORD	dwWaitReturn;
> 
> 		
> 		//
> 		// Update the job time so we know how long to wait.  We can
> 		// only get here if a socket was just added to the socket list, or
> 		// we've been servicing sockets.
> 		//
> 		DNTimeGet( &CurrentTime );
> 		if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 		{
> 			pThisThreadPool->LockTimerData();
> 			CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																		   &CoreData.NextTimerJobTime );
> 			if ( CoreData.fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 			}
> 			pThisThreadPool->UnlockTimerData();
> 		}
> 
> 		DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 		dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 
> 		//
> 		// Check for Winsock1 sockets.  If there are some around, do a quick poll
> 		// of them to check of I/O before entering the main Winsock2 loop for
> 		// the real timing.
> 		//
> 		pThisThreadPool->Lock();
> 		if ( pSocketSet->fd_count != 0 )
> 		{
> 			pThisThreadPool->Unlock();
> 
> 			pThisThreadPool->CheckWinsock1IO( pSocketSet );
> 			
> 			//
> 			// since there are Winsock1 sockets active, don't spend a lot of
> 			// time waiting for something to happen for Winsock2
> 			//
> 			if ( g_dwSelectTimeSlice < dwMaxWaitTime )
> 			{
> 				dwMaxWaitTime = g_dwSelectTimeSlice;
> 			}
> 		}
> 		else
> 		{
> 			pThisThreadPool->Unlock();
> 		}
> 
> 
> 		//
> 		// Check Winsock2 sockets.
> 		//
> 		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> 												 CoreData.hWaitHandles,					// handles to wait on
> 												 FALSE,									// don't wait for all to be signalled
> 												 dwMaxWaitTime,							// wait timeout
> 												 TRUE									// we're alertable for APCs
> 												 );
> 		switch ( dwWaitReturn )
> 		{
> 			//
> 			// timeout, don't do anything, we'll probably process timer jobs on
> 			// the next loop
> 			//
> 			case WAIT_TIMEOUT:
> 			{
> 				break;
> 			}
> 
> 			//
> 			// New job.  Account for the time spent in the wait.  Don't
> 			// account for time after the job is complete because it's
> 			// possible that the job was an job submission which will want
> 			// to reset the wait time.
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 			{
> 				DPF( 8, "Primary Win9x thread has a pending job!" );
> 				pThisThreadPool->ProcessWin9xJob( &CoreData );
> 				break;
> 			}
> 
> 			//
> 			// SP closing
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 			{
> 				DPF( 8, "Primary Win9x thread exit because SP closing!" );
> 				fLooping = FALSE;
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 send complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending write list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Primary Win9x thread failed to reset Winsock2 send event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nPrimary Win9x thread servicing sends!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingSends();
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 receive complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending read list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Primary Win9x thread failed to reset Winsock2 receive event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nPrimary Win9x thread servicing receives!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingReceives();
> 				break;
> 			}
> 
> 			//
> 			// There are I/O completion routines scheduled on this thread.
> 			// This is not a good thing!
> 			//
> 			case WAIT_IO_COMPLETION:
> 			{
> 				DPF( 1, "WARNING: APC was serviced on the primary Win9x IO service thread!  What is the application doing??" );
> 				break;
> 			}
> 
> 			//
> 			// wait failed
> 			//
> 			case WAIT_FAILED:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Primary Win9x thread wait failed!" );
> 				DisplayDNError( 0, dwError );
> 				break;
> 			}
> 
> 			//
> 			// problem
> 			//
> 			default:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Primary Win9x thread unknown problem in wait!" );
> 				DisplayDNError( 0, dwError );
> 				DNASSERT( FALSE );
> 				break;
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	COM_CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::SecondaryWin9xThread - secondary thread to handle only Win9x
> //		I/O so developers get bit faster with multithreading issues if they're
> //		developing on Win9x.  This thread will only handle Winsock2 based TCP
> //		I/O.  Winsock 1 is not deemed important enough to hack the rest of the
> //		code to work with two threads.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::SecondaryWin9xThread( void *pParam )
> {
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 
> 	
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Secondary Win9x thread failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 	
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 	
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		DWORD	dwWaitReturn;
> 
> 		
> 		//
> 		// Check Winsock2 sockets.
> 		//
> 		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> 												 CoreData.hWaitHandles,					// handles to wait on
> 												 FALSE,									// don't wait for all to be signalled
> 												 INFINITE,								// wait timeout (forever)
> 												 TRUE									// we're alertable for APCs
> 												 );
> 		switch ( dwWaitReturn )
> 		{
> 			//
> 			// timeout, shouldn't ever be here!!
> 			//
> 			case WAIT_TIMEOUT:
> 			{
> 				INT3;
> 				break;
> 			}
> 
> 			//
> 			// New job.  This is the secondary thread and is only used to handle
> 			// Winsock2 I/O.  Ignore this event and sleep to cause the proper
> 			// work thread to handle the event.
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 			{
> 				DPF( 8, "Secondary Win9x thread sleeping on job notification!" );
> 				SleepEx( 0, TRUE );
> 				break;
> 			}
> 
> 			//
> 			// SP closing
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 			{
> 				DPF( 8, "Secondary Win9x thread exit because SP closing!" );
> 				fLooping = FALSE;
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 send complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending write list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Secondary Win9x thread failed to reset Winsock2 send event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nSecondary Win9x thread servicing sends!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingSends();
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 receive complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending read list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Secondary Win9x thead failed to reset Winsock2 receive event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nSecondary Win9x thread servicing receives!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingReceives();
> 				break;
> 			}
> 
> 			//
> 			// There are I/O completion routines scheduled on this thread.
> 			// This is not a good thing!
> 			//
> 			case WAIT_IO_COMPLETION:
> 			{
> 				DPF( 1, "WARNING: APC was serviced on the secondary Win9x IO service thread!  What is the application doing??" );
> 				break;
> 			}
> 
> 			//
> 			// wait failed
> 			//
> 			case WAIT_FAILED:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Secondary Win9x thread wait failed!" );
> 				DisplayDNError( 0, dwError );
> 				break;
> 			}
> 
> 			//
> 			// problem
> 			//
> 			default:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Secondary Win9x thread unknown problem in wait!" );
> 				DisplayDNError( 0, dwError );
> 				DNASSERT( FALSE );
> 				break;
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	COM_CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2186a3720,4077
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::DialogThreadProc - thread proc for spawning dialogs
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> // ------------------------------
> DWORD WINAPI	CThreadPool::DialogThreadProc( void *pParam )
> {
> 	const DIALOG_THREAD_PARAM	*pThreadParam;
> 
> 
> 	//
> 	// Initialize COM.  If this fails, we'll have problems later.
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
> 	DNASSERT( pParam != NULL );
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( pParam );
> 	
> 	pThreadParam->pDialogFunction( pThreadParam->phDialog, pThreadParam->pContext );
> 
> 	pThreadParam->pThisThreadPool->DecrementActiveThreadCount();
> 	DNFree( pParam );
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// Remove and process a single job from the list.  If there is no job, skip
> 	// to the end of the function.
> 	//
> 	pJobInfo = GetWorkItem();
> 
> 	if ( pJobInfo == NULL )
> 	{
> 		goto Exit;
> 	}
> 
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> 
> Exit:
> 	return;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CheckWinsock1IO - check the IO status for Winsock1 sockets
> //
> // Entry:		Pointer to sockets to watch
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CheckWinsock1IO( const FD_SET *const pWinsock1Sockets )
> {
> static	const TIMEVAL	SelectNoTime = { 0 };
> 	INT			iSelectReturn;
> 	FD_SET		ReadSocketSet;
> 	FD_SET		WriteSocketSet;
> 	FD_SET		ErrorSocketSet;
> 
> 
> 	//
> 	// Make a local copy of all of the sockets.  This isn't totally
> 	// efficient, but it works.  Multiplying by active socket count will
> 	// spend half the time in the integer multiply.
> 	//
> 	Lock();
> 	memcpy( &ReadSocketSet, pWinsock1Sockets, sizeof( ReadSocketSet ) );
> 	memcpy( &WriteSocketSet, pWinsock1Sockets, sizeof( WriteSocketSet ) );
> 	memcpy( &ErrorSocketSet, pWinsock1Sockets, sizeof( ErrorSocketSet ) );
> 	Unlock();
> 
> 	//
> 	// Don't check write sockets here because it's very likely that they're ready
> 	// for service but have no outgoing data and will thrash
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  &ReadSocketSet,	// sockets to check for read
> 							  NULL,				// sockets to check for write (none)
> 							  &ErrorSocketSet,	// sockets to check for error
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// select got pissed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// WSAENOTSOCK = This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// WSAEINTR = this operation was interrupted
> 				//
> 				case WSAEINTR:
> 				{
> 					DPF( 1, "Winsock1 reporting interrupted operation when selecting read or error sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting read or error sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing read service and error service.
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 			ServiceWinsock1Sockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Since writes are likely to be ready, check for them separately
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  NULL,				// sockets to check for read (don't check reads)
> 							  &WriteSocketSet,	// sockets to check for write
> 							  NULL,				// sockets to check for error (don't check errors)
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout, no write sockets are ready for service
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// select failed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// this socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting write sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing write service
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 			break;
> 		}
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ServiceWinsock1Sockets - service requests on Winsock1 sockets ports
> //
> // Entry:		Pointer to set of sockets
> //				Pointer to service function
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction )
> {
> 	UINT_PTR	uWaitingSocketCount;
> 	UINT_PTR	uSocketPortCount;
> 	CSocketPort	*pSocketPorts[ FD_SETSIZE ];
> 
> 
> 	uSocketPortCount = 0;
> 	uWaitingSocketCount = pSocketSet->fd_count;
> 	
> 	Lock();
> 	while ( uWaitingSocketCount > 0 )
> 	{
> 		UINT_PTR	uIdx;
> 
> 
> 		uWaitingSocketCount--;
> 		uIdx = m_SocketSet.fd_count;
> 		while ( uIdx != 0 )
> 		{
> 			uIdx--;
> 			if ( pSocketSet->fd_array[ uWaitingSocketCount ] == m_SocketSet.fd_array[ uIdx ] )
> 			{
> 				//
> 				// this socket is still available, add a reference to the socket
> 				// port and keep it around to be processed outside of the lock
> 				//
> 				pSocketPorts[ uSocketPortCount ] = m_pSocketPorts[ uIdx ];
> 				pSocketPorts[ uSocketPortCount ]->AddRef();
> 				uSocketPortCount++;
> 				uIdx = 0;
> 			}
> 		}
> 	}
> 	Unlock();
> 
> 	while ( uSocketPortCount != 0 )
> 	{
> 		uSocketPortCount--;
> 		
> 		//
> 		// call the service function and remove the reference
> 		//
> 		(pSocketPorts[ uSocketPortCount ]->*pServiceFunction)();
> 		pSocketPorts[ uSocketPortCount ]->DecRef();
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
50a51
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
63a65
> typedef	void	DIALOG_FUNCTION( HWND *const phDialog, void *const pDialogContext );
100c102,103
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( OSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
146a150
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( OSType() == VER_PLATFORM_WIN32_NT ) );
151a156
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( OSType() == VER_PLATFORM_WIN32_NT ) );
159a165,167
> 		HRESULT	AddSocketPort( CSocketPort *const pSocketPort );
> 		void	RemoveSocketPort( CSocketPort *const pSocketPort );
> 
170a179,181
> 		HRESULT	SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext );
> 
> 		
222a234
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
276a289
> 		HRESULT	Win9xInit( void );
286a300,301
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
287a303,304
> 		static	DWORD WINAPI	PrimaryWin9xThread( void *pParam );
> 		static	DWORD WINAPI	SecondaryWin9xThread( void *pParam );
289a307
> 		static	DWORD WINAPI	DialogThreadProc( void *pParam );
294a313,316
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
> 
> 		void	CheckWinsock1IO( const FD_SET *const pWinsock1Sockets );
> 		void	ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
13a14,15
> #include <WSIPX.h>
> 
39a42
> #include	"Creg.h"
40a44,47
> #include	"strutils.h"
> 
> #include	"resource.h"
> 
50a58,66
> #define DN_REG_LOCAL_SP_ROOT				L"Software\\Microsoft\\DirectPlay8"
> #define DN_REG_LOCAL_SP_SUB					L"\\Service Providers"
> #define DN_REG_LOCAL_SP_SUBKEY				DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB
> #define DN_REG_LOCAL_WSOCK_IPX_ROOT			L"\\DPNSPWinsockIPX"
> #define DN_REG_LOCAL_WSOCK_TCPIP_ROOT		L"\\DPNSPWinsockTCP"
> #define	DN_REG_KEYNAME_ALL_APPLICATIONS		L"All Applications"
> #define	DN_REG_KEYNAME_FRIENDLY_NAME		L"Friendly Name"
> #define DN_REG_KEYNAME_GUID					L"GUID"
> 
73c89,118
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
> 	DNSP_QueryInterface,
> 	DNSP_AddRef,
> 	DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Close,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
134a180,236
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to pointer to SP interface
> //				Pointer to pointer to associated SP data
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP, CSPData **const ppSPData )
> {
> 	HRESULT 	hr;
> 	CSPData		*pSPData;
> 
> 
> 	DNASSERT( ppiDNSP != NULL );
> 	DNASSERT( ppSPData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pSPData = NULL;
> 	*ppiDNSP = NULL;
> 	*ppSPData = NULL;
> 
> 	//
> 	// create main data class
> 	//
> 	hr = CreateSPData( &pSPData, &CLSID_DP8SP_IPX, TYPE_IPX, &ipxInterface );
> 	if ( hr != DPN_OK )
> 	{
> 		DNASSERT( pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( pSPData != NULL );
> 	*ppiDNSP = pSPData->COMInterface();
> 	*ppSPData = pSPData;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( pSPData != NULL )
> 	{
> 		pSPData->DecRef();
> 		pSPData = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
221a324,326
> 	//
> 	// we can either create an IPX instance or an IP instance
> 	//
227a333,336
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP, &pSPData );
> 	}
268c377
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return ( IsEqualCLSID( rclsid, CLSID_DP8SP_TCPIP ) || IsEqualCLSID( rclsid, CLSID_DP8SP_IPX ) );
359a469,719
> #define MAX_RESOURCE_STRING_LENGTH		_MAX_PATH
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "CDPVACMI::LoadAndAllocString"
> HRESULT LoadAndAllocString( UINT uiResourceID, wchar_t **lpswzString )
> {
> 	int length;
> 	HRESULT hr;
> 
> 	if( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
> 		wchar_t wszTmpBuffer[MAX_RESOURCE_STRING_LENGTH];	
> 		
> 		length = LoadStringW( g_hDLLInstance, uiResourceID, wszTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
> 
> 		if( length == 0 )
> 		{
> 			hr = GetLastError();		
> 			
> 			DPF( 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
> 			*lpswzString = NULL;
> 
> 			return hr;
> 		}
> 		else
> 		{
> 			*lpswzString = new wchar_t[length+1];
> 
> 			if( *lpswzString == NULL )
> 			{
> 				DPF( 0, "Alloc failure" );
> 				return DPNERR_OUTOFMEMORY;
> 			}
> 
> 			wcscpy( *lpswzString, wszTmpBuffer );
> 
> 			return DPN_OK;
> 		}
> 	}
> 	else
> 	{
> 		char szTmpBuffer[MAX_RESOURCE_STRING_LENGTH];
> 		
> 		length = LoadStringA( g_hDLLInstance, uiResourceID, szTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
> 
> 		if( length == 0 )
> 		{
> 			hr = GetLastError();		
> 			
> 			DPF( 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
> 			*lpswzString = NULL;
> 
> 			return hr;
> 		}
> 		else
> 		{
> 			*lpswzString = new wchar_t[length+1];
> 
> 			if( *lpswzString == NULL )
> 			{
> 				DPF( 0, "Alloc failure" );
> 				return DPNERR_OUTOFMEMORY;
> 			}
> 
> 			if( STR_jkAnsiToWide( *lpswzString, szTmpBuffer, length+1 ) == 0 )
> 			{
> 				hr = GetLastError();
> 				
> 				DPF( 0, "Unable to upconvert from ansi to unicode hr=0x%x", hr );
> 				return hr;
> 			}
> 
> 			return DPN_OK;
> 		}
> 		
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "RegisterDefaultSettings"
> //
> // RegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT RegisterDefaultSettings()
> {
> 	CRegistry creg;
> 	WCHAR *wszFriendlyName = NULL;
> 	HRESULT hr;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB DN_REG_LOCAL_WSOCK_IPX_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create IPX sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 
> 	creg.WriteString( DN_REG_KEYNAME_ALL_APPLICATIONS, L"Y" );
> 
> 	hr = LoadAndAllocString( IDS_FRIENDLYNAME_IPX, &wszFriendlyName );
> 
> 	if( FAILED( hr ) )
> 	{
> 		DPF( 0, "Could not load IPX name hr=0x%x", hr );
> 		return hr;
> 	}
> 
> 	// Load from resource file
> 	creg.WriteString( DN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );
> 
> 	delete [] wszFriendlyName;
> 
> 	creg.WriteGUID( DN_REG_KEYNAME_GUID, CLSID_DP8SP_IPX );
> 
> 	creg.Close();
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB DN_REG_LOCAL_WSOCK_TCPIP_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create TCPIP sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 
> 	creg.WriteString( DN_REG_KEYNAME_ALL_APPLICATIONS, L"Y" );
> 
> 	hr = LoadAndAllocString( IDS_FRIENDLYNAME_TCPIP, &wszFriendlyName );
> 
> 	if( FAILED( hr ) )
> 	{
> 		DPF( 0, "Could not load IPX name hr=0x%x", hr );
> 		return hr;
> 	}
> 
> 	// Load from resource file
> 	creg.WriteString( DN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );
> 
> 	delete [] wszFriendlyName;
> 
> 	creg.WriteGUID( DN_REG_KEYNAME_GUID, CLSID_DP8SP_TCPIP );
> 
> 	creg.Close();
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "UnRegisterDefaultSettings"
> //
> // UnRegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT UnRegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot remove app, does not exist" );
> 	}
> 	else
> 	{
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_WSOCK_IPX_ROOT)[1] ) )
> 		{
> 			DPFERR( "Cannot remove IPX sub-key, could have elements" );
> 		}
> 
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_WSOCK_TCPIP_ROOT)[1] ) )
> 		{
> 			DPFERR( "Cannot remove TCPIP sub-key, could have elements" );
> 		}
> 
> 	}
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8SPWSock.IPX.1", L"DirectPlay8 WSock IPX Provider Object", 
> 							  L"dpnwsock.dll", CLSID_DP8SP_IPX, L"DirectPlay8SPWSock.IPX") )
> 	{
> 		DPFERR( "Could not register dp8 IPX object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8SPWSock.TCPIP.1", L"DirectPlay8 WSock TCPIP Provider Object", 
> 							  L"dpnwsock.dll", CLSID_DP8SP_TCPIP, L"DirectPlay8SPWSock.TCPIP") )
> 	{
> 		DPFERR( "Could not register dp8 IP object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = RegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Could not register default settings hr = 0x%x", hr );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DP8SP_IPX) )
> 	{
> 		DPF( 0, "Failed to unregister IPX object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DP8SP_TCPIP) )
> 	{
> 		DPF( 0, "Failed to unregister IP object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = UnRegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Failed to remove default settings hr=0x%x", hr );
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
22a24
> #include	"DWinsock.h"
50,53d51
< // provides us winsock1/2 support
< #include "dwnsock1.inc"
< #include "dwnsock2.inc"
< 
80a79,80
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
> 
83a84
> static DWORD_PTR	OverrideWinsockVersion( void );
91a93,158
> // OverrideWinsockVersion - override the Winsock version used by the SP
> //
> // Entry:		Nothing
> //
> // Exit:		Max Winsock version to ask for
> // ------------------------------
> static DWORD_PTR	OverrideWinsockVersion( void )
> {
> 	DWORD_PTR	WinsockVersion;
> 
> 
> 	//
> 	// check for override for OS version and Winsock version
> 	//
> 	g_uOSType = DNGetOSType();
> 	WinsockVersion = 2;
> 
> 	switch ( GetProfileInt( "DirectPlay8", "WinsockVersion", 0 ) )
> 	{
> 		//
> 		// Use Winsock1.  If this is an NT machine, fake it into
> 		// thinking it's Win9x.
> 		//
> 		case 1:
> 		{
> 			if ( g_uOSType == VER_PLATFORM_WIN32_NT )
> 			{
> 				g_uOSType = VER_PLATFORM_WIN32_WINDOWS;
> 			}
> 			WinsockVersion = 1;
> 				
> 			break;
> 		}
> 
> 		//
> 		// Use Winsock2.  If this is an NT machine, fake it into
> 		// thinking it's Win9x.
> 		//
> 		case 2:
> 		{
> 			if ( g_uOSType == VER_PLATFORM_WIN32_NT )
> 			{
> 				g_uOSType = VER_PLATFORM_WIN32_WINDOWS;
> 			}
> 			DNASSERT( WinsockVersion == 2 );
> 
> 			break;
> 		}
> 
> 		//
> 		// OS default
> 		//
> 		default:
> 		{
> 			DNASSERT( WinsockVersion == 2 );
> 			break;
> 		}
> 	}
> 
> 	return	WinsockVersion;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
105a173,174
> 	INT			iVersion;
> 	DWORD_PTR	MaxWinsockVersion;
115a185,186
> 	MaxWinsockVersion = OverrideWinsockVersion();
> 
131c202
< 	// initialize Winsock
---
> 	// initialize the bindings to Winsock
133,139c204,205
< 	WORD wVersionRequested;
< 	WSADATA wsaData;
< 	int nRet;
< 
< 	wVersionRequested = MAKEWORD(2,2);
< 	nRet = p_WSAStartup(wVersionRequested, &wsaData);
< 	if (nRet || wVersionRequested != wsaData.wVersion)
---
> 	iVersion = DWSInitWinSock( &g_dwsState, MaxWinsockVersion );
> 	if ( iVersion == 0 )	// failure
141,143c207,209
< 		DPF( 0, "Problem starting winsock!" );
< 	    fReturn = FALSE;
< 	    goto Failure;
---
> 		DPF( 0, "Problem binding dynamic winsock functions!" );
> 		fReturn = FALSE;
> 		goto Failure;
145d210
< 
147a213,214
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
157c224,232
< 		p_WSACleanup();
---
> 		BOOL	fFreeReturn;
> 
> 
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 		if ( fFreeReturn == FALSE )
> 		{
> 			DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 		}
> 
187a263,265
> 	BOOL	fFreeReturn;
> 
> 
191c269,273
< 	p_WSACleanup();
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 	if ( fFreeReturn == FALSE )
> 	{
> 		DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 	}
198a281,293
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
199a295
> 
285a382
> 	INT_PTR iWinsockVersion;
295a393
> 	iWinsockVersion = GetWinsockVersion();
589a688,744
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // AddNetworkAdapterToBuffer - add a network address to a packed buffer
> //
> // Entry:		Pointer to packed buffer
> //				Pointer to adapter name
> //				Pointer to adapter guid
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	AddNetworkAdapterToBuffer( CPackedBuffer *const pPackedBuffer,
> 								   const char *const pAdapterName,
> 								   const GUID *const pAdapterGUID )
> {
> 	HRESULT	hr;
> 	DPN_SERVICE_PROVIDER_INFO	AdapterInfo;
> 
> 
> 	DNASSERT( pPackedBuffer != NULL );
> 	DNASSERT( pAdapterName != NULL );
> 	DNASSERT( pAdapterGUID != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	memset( &AdapterInfo, 0x00, sizeof( AdapterInfo ) );
> 	DNASSERT( AdapterInfo.dwFlags == 0 );
> 
> 	hr = pPackedBuffer->AddToBack( pAdapterGUID, sizeof( *pAdapterGUID ) );
> 	if ( ( hr != DPNERR_BUFFERTOOSMALL ) && ( hr != DPN_OK ) )
> 	{
> 		DPF( 0, "Failed to add socket address to buffer!" );
> 		goto Failure;
> 	}
> 	AdapterInfo.pGuid = static_cast<GUID*>( pPackedBuffer->GetTailAddress() );
> 
> 	pPackedBuffer->AddStringToBack( pAdapterName );
> 	if ( ( hr != DPNERR_BUFFERTOOSMALL ) && ( hr != DPN_OK ) )
> 	{
> 		DPF( 0, "Failed to add adapter name to buffer!" );
> 		goto Failure;
> 	}
> 	AdapterInfo.pwszName = static_cast<WCHAR*>( pPackedBuffer->GetTailAddress() );
> 
> 	pPackedBuffer->AddToFront( &AdapterInfo, sizeof( AdapterInfo ) );
> 
> Exit:
> 	return	hr;
> 
> Failure:
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
48a49,50
> INT		GetWinsockVersion( void );
> 
59a62,65
> 
> HRESULT	AddNetworkAdapterToBuffer( CPackedBuffer *const pPackedBuffer,
> 								   const char *const pAdapterName,
> 								   const GUID *const pAdapterGUID );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22
> #include	<WSIPX.h>
94,95d94
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
166a166,169
>  	switch ( pSPData->GetType() )
> 	{
> 		case TYPE_IP:
> 		{
168a172,187
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			DPF( 9, "Attempting to create IPX datagram socket." );
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
233a253
> 		case TYPE_IPX:
319a340
> 	IDirectPlay8Address		*pSPOnlyAddress;
328c349
< 	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );
---
> 	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );
343a365
> 	pSPOnlyAddress = NULL;
382a405,452
> 		HRESULT	hTempResult;
> 		GUID	SPGuid;
> 
> 
> 		//
> 		// get the SP
> 		//
> 		hTempResult = IDirectPlay8Address_GetSP( pDeviceAddress, &SPGuid );
> 		switch ( hTempResult )
> 		{
> 			//
> 			// no problem
> 			//
> 			case DPN_OK:
> 			{
> 				DNASSERT( hr == DPNERR_PENDING );
> 				break;
> 			}
> 
> 			//
> 			// pass these errors throug
> 			//
> 			case DPNERR_OUTOFMEMORY:
> 			{
> 				hr = hTempResult;
> 				goto Failure;
> 				break;
> 			}
> 
> 			//
> 			// remap other errors to addressing errors
> 			//
> 			default:
> 			{
> 				hr = DPNERR_ADDRESSING;
> 				goto Failure;
> 				break;
> 			}
> 		}
> 
> 		//
> 		// The host address is NULL, if we're using TCPIP and we're not allowed to query,
> 		// use the broadcast address.  If we're on IPX, use the broadcast address.
> 		//
> 		if ( ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
> 		{
384a455,502
> 		}
>         else
>         {
> 			HRESULT	hTempResult;
> 
> 
> 			//
> 			// Need to build address with just the SP guid.  Get it from the
> 			// device address.
> 			//
> 			DNASSERT( pSPOnlyAddress == NULL );
> 			hTempResult = COM_CoCreateInstance( CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>( &pSPOnlyAddress ) );
> 			if ( hTempResult != S_OK )
> 			{
> 				DPF( 0, "Failed to create SP-Only address when non was supplied!" );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			hTempResult = IDirectPlay8Address_SetSP( pSPOnlyAddress, &SPGuid );
> 			switch ( hTempResult )
> 			{
> 				//
> 				// set SP, no problem
> 				//
> 				case DPN_OK:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// failed to set SP, map error to an addressing error
> 				//
> 				default:
> 				{
> 					hr = DPNERR_ADDRESSING;
> 					goto Failure;
> 
> 					break;
> 				}
> 			}
> 
> 			pHostAddress = pSPOnlyAddress;
> 		}
516a635,667
> 			if ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) != 0 ) &&
> 				 ( pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// Copy the connect data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since the dialog is being popped, this command is in progress,
> 				// not pending.
> 				//
> 				DNASSERT( pSPData != NULL );
> 
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				pEndpoint->CopyEnumQueryData( pEnumQueryData );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for enum query!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove our reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
530a682,683
> 			}
> 
609a763,768
> 	if ( pSPOnlyAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pSPOnlyAddress );
> 		pSPOnlyAddress = NULL;
> 	}
> 
783c942
< 	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
---
> 	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
989a1149,1177
> 			if ( ( pConnectData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
> 			{
> 				//
> 				// Copy the connect data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since a dialog is being displayed, the command is in-progress,
> 				// not pending.
> 				//
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				pEndpoint->CopyConnectData( pConnectData );
> 				if ( ( hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() ) ) != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for connect!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove our reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
990a1179,1180
> 			}
> 
1256c1446
< 	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
---
> 	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
1462a1653,1685
> 			if ( ( pListenData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
> 			{
> 				//
> 				// Copy the listen data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since this endpoint is being handed off to another thread,
> 				// make sure it's in the unbound list.  Since a dialog is being
> 				// displayed, the command state is in progress, not pending.
> 				//
> 				DNASSERT( pSPData != NULL );
> 
> 				pEndpoint->CopyListenData( pListenData );
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for listen!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove out reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
1463a1687,1688
> 			}
> 
2431a2657,2668
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2648a2886,2897
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
6a7,8
>   DllRegisterServer PRIVATE
>   DllUnregisterServer PRIVATE
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\07311100.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\comutil.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\comutil.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dbginfo.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dneterrors.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\guidutil.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	1ece02cc	6bb05875
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\packbuff.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\packbuff.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\strutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\strutils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\appdesc.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\client.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\connect.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dllmain.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.def	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dnet.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\migration.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\msghandler.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\ntentry.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\peer.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\server.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\user.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\worker.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addbase.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addparse.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dllmain.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.def	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpsp8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\connect.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\enum.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\initialize.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\timer.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dbginfo.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock1.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock2.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\locals.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\locals.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\rsip.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.def	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 93 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\callstack.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\memlog.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\dnmisc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\dpguid.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04241015.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04261045.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05010945.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05021600.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05031030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05081300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05091400.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05111530.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05121300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05151130.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05161345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05221345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05231030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06021030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06121345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06121445.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06141200.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06191100.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\07171100.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\07261030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\07281500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\lastsync.bat	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\dplegacy.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\dplegacy.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\connect.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\directnet.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\directplay8core.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dnaddress.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dndbg.txt	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dnregister.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dp8context.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dp8protocol.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpaddress.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpclassinfo.xls	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpcustombuild.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplay8.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplay8.xls	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplobby8.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpnsvr.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpv8dmo.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoice.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoice.mpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoicenote.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\hostmigration.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\lobby8update.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\nametable.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\nametbl.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\rfc1738.txt	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\spintf.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\usercb.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\winsockspwireprotocol.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvlib.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvlib.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvrq.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvrq.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpnsvr.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpsvr8.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpsvr8.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\proctbl.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\proctbl.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\inc\dpnsdef.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\inc\dpnsvmsg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\inc\dplobby8.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\classfac.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\comstuff.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dllmain.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dnlobby.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplapp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplapp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplclient.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplclient.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplcommon.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplcommon.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconnect.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconnect.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconset.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconset.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplmsgq.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplmsgq.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby8int.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplparam.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplparam.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplproc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplproc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplreg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplreg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\globals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\handles.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\handles.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\contextfixedpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\handletable.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\handletable.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\registry.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\registry.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 229 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
3a4
>       lobby \
5c6,7
<       core
---
>       core \
>       dpnsvr 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\comutil.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include "creg.h"
23a25
> #include <stdlib.h>
38c40
<     WCHAR                   wszFileName[_MAX_PATH];
---
>     CHAR                    szFileName[_MAX_PATH];
122c124
<     hr = COM_GetDLLName( clsid, pEntry->wszFileName, &dwSize );
---
>     hr = COM_GetDLLName( clsid, pEntry->szFileName, &dwSize );
130c132
<     pEntry->hDLL = LoadLibraryW( pEntry->wszFileName );
---
>     pEntry->hDLL = LoadLibraryA( pEntry->szFileName );
164c166
< HRESULT COM_GetDLLName( GUID guidCLSID, WCHAR *wszPath, DWORD *pdwSize )
---
> HRESULT COM_GetDLLName( GUID guidCLSID, CHAR *szPath, DWORD *pdwSize )
166,170c168,170
< // BUGBUG: [mgere] [xbox] These com wrapper functions will only be called to
< // retrieve the wsock com object, so I hard coded the dpwsock.dll to always
< // return from this function.
< //
<     WCHAR wszDLL[] = L"dpnwsock.dll";
---
>     CRegistry cregRoot;
>     CRegistry cregCLSID;
>     CRegistry cregInProc;
172c172,177
<     wcscpy( wszPath, wszDLL);
---
>     HRESULT hr;
>     BOOL fSuccess;
>     WCHAR *wszTmpPath = NULL;
>     DWORD dwTmpSize = 0;
>     int res;
>     BOOL fDefault;
174c179
<     return S_OK;
---
>     fSuccess = cregRoot.Open( HKEY_CLASSES_ROOT, L"CLSID", TRUE, FALSE );
175a181,245
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening HKEY_CLASSES_ROOT\\CLSID" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     fSuccess = cregCLSID.Open( cregRoot, &guidCLSID, TRUE, FALSE );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening specified CLSID" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     fSuccess = cregInProc.Open( cregCLSID, L"InprocServer32", TRUE, FALSE );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening inprocserver key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     cregCLSID.Close();
>     cregRoot.Close();
> 
>     fSuccess = cregInProc.ReadString( L"", wszTmpPath, pdwSize );
> 
>     if( !*pdwSize )
>     {
>         DPF( 0, "Error opening default key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     wszTmpPath = new WCHAR[*pdwSize];
> 
>     fSuccess = cregInProc.ReadString( L"", wszTmpPath, pdwSize );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening default key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     if( FAILED( hr = STR_jkWideToAnsi(szPath,wszTmpPath, *pdwSize ) ) )
>     {
>         DPF( 0, "Error converting path to DLL to ANSI hr=0x%x", hr );
>         hr = E_FAIL;
>     }
> 
>     delete [] wszTmpPath;
> 
>     return hr;
> 
> COM_GETDLLNAME_ERROR:
> 
>     if( wszTmpPath )
>         delete [] wszTmpPath;
> 
>     return hr;
> 
192c262
< // BUGBUG: [mgere] [xbox] Added this temporarily
---
>     hr = CoCreateInstance( rclsid, pUnkOuter, dwClsContext, riid, ppv );
194,195c264,265
< COM_Init();
< 
---
>     if( hr == CO_E_NOTINITIALIZED )
>     {
217a288,291
> 
>         return hr;
> 
>     }
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\comutil.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21c21
< HRESULT COM_GetDLLName( GUID guidCLSID, WCHAR *szPath, DWORD *pdwSize );
---
> HRESULT COM_GetDLLName( GUID guidCLSID, CHAR *szPath, DWORD *pdwSize );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
29a37,65
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "UNKNOWN_MODULE"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectNet] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNetDebug"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dneterrors.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20,23
> // vanceo - changed to stdio for printf
> //#include	<iostream.h>
> #include	<stdio.h>
> 
78a83,92
> 			// output to console
> 			case DPNERR_OUT_CONSOLE:
> 			{
> 				// Also see the change from <iostream.h> to <stdio.h> above
> 				#pragma TODO(vanceo, "Changed cout to printf so NT build environment will work, figure this out.")
> 				//cout << endl << pString << endl;
> 				printf("\n%s\n", pString);
> 				break;
> 			}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\guidutil.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
15c15
< #include <wchar.h>
---
> #include "stdio.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34,37
> #ifdef	_WIN64
> #define	MEMORY_CRC			0X5AA55AA55AA55AA5
> #define	GUARD_SIGNATURE		0x0F1E2D3C4B5A6978
> #else
35a40
> #endif	// _WIN64
40a46,52
> //
> // enumerated values to indicate how to report memory leaks
> //
> #define	MEMORY_LEAK_REPORT_NONE		0x00000000
> #define	MEMORY_LEAK_REPORT_DPF		0x00000001
> #define	MEMORY_LEAK_REPORT_DIALOG	0x00000002
> 
60a73
> #ifdef	_X86_
61a75,77
> #else
> #define	ASSERT( arg )	if ( arg == FALSE ) { DebugBreak(); }
> #endif
94a111,116
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
> static	HINSTANCE			g_hApplicationInstance;
> 
> //
103a126,128
> static int	DisplayCallStack( const char *const pszMsg,
> 							  const char *const pszTitle,
> 							  const char *const pCallStack );
121a147
> 	OSVERSIONINFO	OSVersionInfo;
122a149
> 
130a158,186
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
> 	// note application instance
> 	//
> 	g_hApplicationInstance = GetModuleHandle( NULL );
> 	if ( g_hApplicationInstance == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to GetModuleHandle: 0x%x", dwError );
> 		goto Failure;
> 	}
> 
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
> 	//
229a286,287
> 		switch ( DNGetOSType() )
> 		{
232a291,292
> 			case VER_PLATFORM_WIN32_NT:
> 			{
257a318,328
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
290a362,393
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetApplcationInstance - application instance
> //
> // Entry:		Nothing
> //
> // Exit:		Application instance
> // ------------------------------
> HINSTANCE	DNGetApplicationInstance( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_hApplicationInstance;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
361a465
> //#ifdef	_WIN32
390a495
> //#endif	// _WIN32
391a497,518
> 
> //#ifdef	_WIN64
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	if ( pTime1->Time < pTime2->Time )
> //	{
> //		iReturnValue = -1;
> //	}
> //	else
> //	{
> //		if ( pTime1->Time == pTime2->Time )
> //		{
> //			iReturnValue = 0;
> //		}
> //		else
> //		{
> //			iReturnValue = 1;
> //		}
> //	}
> //#endif	// _WIN64
> 
417a545
> #ifdef	_X86_
429a558,608
> 
> #else	// _X86_
> 
> /*
> #ifdef	_ALPHA_
> 	// debug me
> 	DebugBreak();
> 
> 	__asm{ mov	$t0, *pTime1
> 		   mov	$t1, *pTime2
> 		   addq	$t0, $t1
> 		   mov	*pTimeResult, $t0
> 	};
> #else	// _ALPHA_
> */
> 
> //#ifdef	_WIN32
> 	DWORD	dwTempLowTime;
> 
> 
> 	dwTempLowTime = pTime1->Time32.TimeLow;
> 	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow + pTime2->Time32.TimeLow;
> 	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh + pTime2->Time32.TimeHigh;
> 
> 	//
> 	// check for overflow in low 32-bits and increment high value if applicable
> 	//
> 	if ( pTimeResult->Time32.TimeLow < dwTempLowTime )
> 	{
> #pragma	BUGBUG( johnkan, "Test this!" )
> 		// debug me
> 		DebugBreak();
> 		pTimeResult->Time32.TimeHigh++;
> 	}
> //#endif	// _WIN32
> 
> //#ifdef	_WIN64
> //	DEBUG_ONLY( UINT_PTR	ReferenceTime );
> //
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	DEBUG_ONLY( ReferenceTime = pTime1->Time );
> //	*pTimeResult = pTime1->Time + pTime2->Time;
> //	DNASSERT( *pTimeResult >= ReferenceTime );
> //
> //#endif	// _WIN64
> 
> // #endif	// _ALPHA_
> 
> #endif	// _X86_
455a635,636
> #ifdef	_X86_
> 
467a649,695
> 
> #else	// _X86_
> 
> /*
> #ifdef	_ALPHA_
> 	// debug me
> 	DebugBreak();
> 
> 	mov		$t0, *pTime1
> 	mov		$t1, *pTime2
> 	addq	$t0, $t1
> 	mov		*pTimeResult, $t0
> #else	// _ALPHA_
> */
> 
> //#ifdef	_WIN32
> 	DWORD	dwTempLowTime;
> 
> 
> 	dwTempLowTime = pTime1->Time32.TimeLow;
> 	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow - pTime2->Time32.TimeLow;
> 	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh - pTime2->Time32.TimeHigh;
> 
> 	//
> 	// check for underflow in low 32-bits and decrement high value if applicable
> 	//
> 	if ( pTimeResult->Time32.TimeLow > dwTempLowTime )
> 	{
> #pragma	BUGBUG( johnkan, "Test this!" )
> 		// debug me
> 		DebugBreak();
> 
> 		pTimeResult->Time32.TimeHigh--;
> 	}
> //#endif	// _WIN32
> 
> //#ifdef	_WIN64
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	DNASSERT( pTime1->Time > pTime2->Time );
> //	pTimeResult = pTime1->Time - pTime2->Time;
> //#endif	// _WIN64
> 
> // #endif	// _ALPHA_
> 
> #endif	// _X86_
688a917,919
> 		void	NoteCurrentCallStack( void ) { m_CallStack.NoteCurrentCallStack(); }
> 		void	GetCallStack( char *const pBuffer ) const { m_CallStack.GetCallStackString( pBuffer ); }
> 
707a939
> 		CCallStack<DN_MEMORY_CALL_STACK_DEPTH>	m_CallStack;
798a1031
> 		pMemoryLink->NoteCurrentCallStack();
908a1142
> 	char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
943,944c1177,1188
< 			DPF( 0, "%s%s\n", "Memory Corruption!", MessageString );
< //					DNASSERT( FALSE );
---
> 			pMemoryLink->GetCallStack( CallStackBuffer );
> 			MessageReturn = DisplayCallStack( MessageString, "Memory Corruption!", CallStackBuffer );
> 			switch ( MessageReturn )
> 			{
> 				case IDABORT:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				case IDIGNORE:
> 				{
948a1193,1201
> 					break;
> 				}
> 
> 				case IDRETRY:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
979a1233
> 	DWORD		dwDisplayFlags;
980a1235
> 
983a1239
> 	fDisplayLeaks = TRUE;
986a1243,1244
> 	dwDisplayFlags = GetProfileIntA( PROF_SECT, "MemoryLeakOutput", MEMORY_LEAK_REPORT_DPF );
> 	
993a1252
> 		char		CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
1007,1008c1266
< 			DPF( 0, "%s%s\n", DialogTitle, LeakSizeString );
< //						DNASSERT( FALSE );
---
> 		pTemp->GetCallStack( CallStackBuffer );
1009a1268,1318
> 
> 		if ( ( dwDisplayFlags & MEMORY_LEAK_REPORT_DPF ) != 0 )
> 		{
> 			DPF( 0, "%s%s%s\n", DialogTitle, LeakSizeString, CallStackBuffer );
> 		}
> 
> 		if ( ( dwDisplayFlags & MEMORY_LEAK_REPORT_DIALOG ) != 0  )
> 		{
> 			if ( fDisplayLeaks != FALSE )
> 			{
> 				MessageReturn = DisplayCallStack( LeakSizeString, DialogTitle, CallStackBuffer );
> 				switch ( MessageReturn )
> 				{	
> 					//
> 					// stop application now
> 					//
> 					case IDABORT:
> 					{
> 						fDisplayLeaks = FALSE;
> 						break;
> 					}
> 
> 					//
> 					// display next leak
> 					//
> 					case IDIGNORE:
> 					{
> 						break;
> 					}
> 
> 					//
> 					// stop in the debugger
> 					//
> 					case IDRETRY:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 
> 					//
> 					// unknown
> 					//
> 					default:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 				}
> 			}
> 		}
> 
1022a1332,1475
> 
> 
> #if	defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
> //**********************************************************************
> //**
> //** THIS IS THE STACK TRACKING SECTION.  ONLY ADD FUNCTIONS HERE THAT ARE
> //** RELATED TO TRACKING THE CALL STACK!!
> //**
> //**********************************************************************
> 
> 
> ////**********************************************************************
> //// ------------------------------
> //// DNGetStackTop - return pointer to top of stack
> ////
> //// Entry:		Nothing
> ////
> //// Exit:		Pointer to top of stack
> //// ------------------------------
> //static void	*DNGetStackTop( void )
> //{
> //	void	*pReturn;
> //
> //	_asm	mov eax,dword ptr fs:[4]
> //	_asm	mov pReturn, eax
> //	return	pReturn;
> //}
> ////**********************************************************************
> //
> //
> ////**********************************************************************
> //// ------------------------------
> //// DNGetStackBottom - return pointer to bottom of call stack
> ////
> //// Entry:		Nothing
> ////
> //// Exit:		Pointer to bottom of call stack
> //// ------------------------------
> //static void	*DNGetStackBottom( void )
> //{
> //	void	*pReturn;
> //
> //	_asm	mov eax,dword ptr fs:[8]
> //	_asm	mov pReturn, eax
> //	return	pReturn;
> //}
> ////**********************************************************************
> 
> 
> ////**********************************************************************
> //// ------------------------------
> //// DNGetCallStack - get a call stack
> ////
> //// Entry:		Pointer to call stack array
> ////				Number of calls to report
> ////
> //// Exit:		Nothing
> //// ------------------------------
> //static	void	DNGetCallStack( const void **const pCallStack, const UINT_PTR Depth )
> //{
> //	void		**CallersEBP;
> //	void		*ReturnAddr;
> //	UINT_PTR	i,iCount;
> //	void		*StackTop;
> //	void		*StackBottom;
> //	static const	void	*min_dll_base = NULL;
> //
> //
> //	StackTop = DNGetStackTop();
> //	StackBottom = DNGetStackBottom();
> //	memset(	pCallStack, 0x00, sizeof( *pCallStack ) * Depth );
> //
> //	_asm
> //	{
> //		mov eax,[ebp]
> //		mov CallersEBP,eax
> //	}
> //
> //	__try
> //	{
> //		//
> //		// this code can generate exception if it steps back too far...
> //		//
> //		for ( i = 0, iCount = 0; i < Depth; iCount++ )
> //		{
> //			if ( ( CallersEBP < StackBottom ) || ( CallersEBP >= StackTop ) )
> //				break;
> //			ReturnAddr = CallersEBP[ 1 ];
> //			if ( ( iCount > 0 ) || ( ReturnAddr >= min_dll_base ) ) // iCount check skips memory_alloc_debug
> //				pCallStack[ i++ ] = ReturnAddr;
> //			CallersEBP = reinterpret_cast<void**>( *CallersEBP ); // get callers callers ebp
> //		}
> //	}
> //	__except( 1 )  // went too far back on the stack, fill up rest of array with zeros
> //	{
> //		DPF( 0, "Benign access violation creating return address stack." );
> //	}
> //}
> ////**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DisplayCallStack - display a call stack message box
> //
> // Entry:		Pointer to information string
> //				Pointer to title string
> //				Pointer to call stack string
> //
> // Exit:		Dialog return code
> // ------------------------------
> static int	DisplayCallStack( const char *const pszMsg, const char *const pszTitle, const char *const pCallStackString )
> {
> 	MSGBOXPARAMS	MessageBoxParams;
> 	char 			szStackTraceMsg[ CALLSTACK_BUFFER_SIZE ];
> 
> 
>     strcpy( szStackTraceMsg, pszMsg );
> 	strcat( szStackTraceMsg, pCallStackString );
> 
> 	//
> 	// display message box
> 	//
> 	memset( &MessageBoxParams, 0x00, sizeof( MessageBoxParams ) );
> 	MessageBoxParams.cbSize = sizeof( MessageBoxParams );
> 	MessageBoxParams.lpszText = szStackTraceMsg;
> 	MessageBoxParams.lpszCaption = pszTitle;
> 	MessageBoxParams.dwStyle = MB_ABORTRETRYIGNORE | MB_SETFOREGROUND | MB_TOPMOST | MB_DEFBUTTON2;
> 	MessageBoxParams.hInstance = NULL;
> 
> 	return MessageBoxIndirect( &MessageBoxParams );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> //**
> //** END OF CALL STACK TRACKING SECTION.
> //**
> //**********************************************************************
> #endif	// defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
> 
> 
> 
1117a1571
> 	static	BOOL	fDisplayCallStacks = TRUE;
1135a1590,1593
> 	if ( pCriticalSection->LockCount == 0 )
> 	{
> 		pCriticalSection->CallStack.NoteCurrentCallStack();
> 	}
1141a1600,1604
> 			if ( fDisplayCallStacks != FALSE )
> 			{
> 				char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
> 
> 
1146,1147c1609,1641
< 			    DPF( 0, "%s%s\n", "DNCritical section has been reentered!", "Check stack trace for function that originally held the lock." );
< //						DNASSERT( FALSE );
---
> 				pCriticalSection->CallStack.GetCallStackString( CallStackBuffer );
> 				switch ( DisplayCallStack( "Stack trace of function that originally held the lock:",
> 										   "DNCritical section has been reentered!",
> 										   CallStackBuffer ) )
> 				{
> 					//
> 					// don't display any more critical section warnings!
> 					//
> 					case IDABORT:
> 					{
> 						fDisplayCallStacks = FALSE;
> 						break;
> 					}
> 
> 					//
> 					// acknowledged
> 					//
> 					case IDIGNORE:
> 					{
> 						break;
> 					}
> 
> 					//
> 					// stop in debugger
> 					//
> 					case IDRETRY:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 				}
> 			}
> 
1180a1675
> 		memset( &pCriticalSection->CallStack, 0x00, sizeof( pCriticalSection->CallStack ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18,19
> #include	"CallStack.h"
> 
29a32,34
> #define	DN_MEMORY_CALL_STACK_DEPTH				12
> #define	DN_CRITICAL_SECTION_CALL_STACK_DEPTH	10
> 
53a59
> 	CCallStack< DN_CRITICAL_SECTION_CALL_STACK_DEPTH > 	CallStack;
85a92,101
> 
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
> HINSTANCE	DNGetApplicationInstance( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\packbuff.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
136a137,207
> // CPackedBuffer::AddStringToBack
> //
> // Entry:		Pointer to source string
> //
> // Exit:		Error Code:	DPN_OK					if able to add
> //							DPNERR_BUFFERTOOSMALL	if buffer is full
> // ------------------------------
> 
> HRESULT CPackedBuffer::AddStringToBack( const char *const pszString )
> {
> 	HRESULT	hr;
> 	DWORD	dwStringSize;
> 	DWORD	dwBufferSize;
> 
> 
> 	DNASSERT( pszString != NULL );
> 	
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	dwStringSize = 0;
> 	hr = STR_AnsiToWide( pszString,
> 						 -1,
> 						 NULL,
> 						 &dwStringSize );
> 	if ( hr != DPNERR_BUFFERTOOSMALL )
> 	{
> 		DNASSERT( hr != DPN_OK );
> 		goto Failure;
> 	}
> 	
> 	dwBufferSize = dwStringSize * sizeof( WCHAR );
> 	m_dwRequired += dwBufferSize;
> 	if ( !m_bBufferTooSmall )
> 	{
> 		if (m_dwRemaining >= dwBufferSize)
> 		{
> 			m_pTail -= dwBufferSize;
> 			m_dwRemaining -= dwBufferSize;
> 			hr = STR_AnsiToWide( pszString,
> 								 -1,
> 								 reinterpret_cast<WCHAR*>( m_pTail ),
> 								 &dwStringSize );
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			DNASSERT( ( dwStringSize * sizeof( WCHAR ) ) == dwBufferSize );
> 		}
> 		else
> 		{
> 			m_bBufferTooSmall = TRUE;
> 		}
> 	}
> 
> 	if ( m_bBufferTooSmall )
> 	{
> 		hr = DPNERR_BUFFERTOOSMALL;
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	goto Exit;
> }
> //**********************************************************************
> // ------------------------------
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\packbuff.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62a63
> 	HRESULT	AddStringToBack( const char *const pszString );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2c17,26
< TARGETTYPE=LIBRARY
---
> 
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
3a28
> TARGETTYPE=LIBRARY
5,9d29
< !ifdef _BUILD_FOR_WIN2000
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< LINKER_FLAGS=-align:32
< !endif
11c31,35
< INCLUDES=..\inc
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
13c37,41
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS)
15c43,47
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
17,18c49,52
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> INCLUDES=$(DXROOT)\inc;..\inc
> 
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
21d54
< MSC_WARNING_LEVEL=/W3 /WX
22a56,62
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
31a72
>         creg.cpp \
36c77,88
< TARGETLIBS=
---
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE
> MSC_OPTIMIZATION=/Odi /Zi
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
> 
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\strutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include "DNetErrors.h"
20a22,23
> #undef DPF_MODNAME
> #define DPF_MODNAME "STR_WideToAnsi"
22c25,48
< // BUGBUG: [mgere] [xbox] UnicodeToMultiByteN and MultiByteToUnicodeN were Taken from nlsxlat.c
---
> //**********************************************************************
> // ------------------------------
> // WideToANSI - convert a wide string to an ANSI string
> //
> // Entry:		Pointer to source wide string
> //				Size of source string (in WCHAR units, -1 implies NULL-terminated)
> //				Pointer to ANSI string destination
> //				Pointer to size of ANSI destination
> //
> // Exit:		Error code:
> //				DPNERR_GENERIC = operation failed
> //				DPN_OK = operation succeded
> //				DPNERR_BUFFERTOOSMALL = destination buffer too small
> // ------------------------------
> HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
> 						const DWORD dwWCHARStringLength,
> 						char *const pString,
> 						DWORD *const pdwStringLength )
> {
> 	HRESULT	hr;
> 	int		iReturn;
> 	BOOL	fDefault;
> 	char	cMilleniumHackBuffer;	
> 	char	*pMilleniumHackBuffer;
24,29d49
< HRESULT
< UnicodeToMultiByteN(
<     OUT PCH MultiByteString,
<     IN ULONG MaxBytesInMultiByteString,
<     IN PWCH UnicodeString,
<     IN ULONG BytesInUnicodeString)
31c51,53
< /*++
---
> 	DNASSERT( pWCHARString != NULL );
> 	DNASSERT( pdwStringLength != NULL );
> 	DNASSERT( ( pString != NULL ) || ( *pdwStringLength == 0 ) );
33c55,60
< Routine Description:
---
> 	//
> 	// Initialize.  A hack needs to be implemented because their paramter
> 	// validation is screwed and when you pass zero for a destination size, you
> 	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
> 	//
> 	hr = DPN_OK;
35,37c62,69
<     This functions converts the specified unicode source string into an
<     ansi string. The translation is done with respect to the
<     ANSI Code Page (ACP) loaded at boot time.
---
> 	if ( *pdwStringLength == 0 )
> 	{
> 		pMilleniumHackBuffer = &cMilleniumHackBuffer;
> 	}
> 	else
> 	{
> 		pMilleniumHackBuffer = pString;
> 	}
39c71,83
< Arguments:
---
> 	fDefault = FALSE;
> 	iReturn = WideCharToMultiByte( CP_ACP,					// code page (default ANSI)
> 								   0,						// flags (none)
> 								   pWCHARString,			// pointer to WCHAR string
> 								   dwWCHARStringLength,		// size of WCHAR string
> 								   pMilleniumHackBuffer,	// pointer to destination ANSI string
> 								   *pdwStringLength,		// size of destination string
> 								   NULL,					// pointer to default for unmappable characters (none)
> 								   &fDefault				// pointer to flag indicating that default was used
> 								   );
> 	if ( iReturn == 0 )
> 	{
> 		DWORD	dwError;
41,43d84
<     MultiByteString - Returns an ansi string that is equivalent to the
<         unicode source string.  If the translation can not be done,
<         an error is returned.
45,47c86,100
<     MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
<         written to MultiByteString.  If this causes MultiByteString to be a
<         truncated equivalent of UnicodeString, no error condition results.
---
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to convert WCHAR to multi-byte!" );
> 		DisplayDNError( 0, dwError );
> 		hr = DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		if ( *pdwStringLength == 0 )
> 		{
> 			hr = DPNERR_BUFFERTOOSMALL;
> 		}
> 		else
> 		{
> 			DNASSERT( hr == DPN_OK );
> 		}
49,50c102,103
<     BytesInMultiByteString - Returns the number of bytes in the returned
<         ansi string pointed to by MultiByteString.
---
> 		*pdwStringLength = iReturn;
> 	}
52,53c105,109
<     UnicodeString - Supplies the unicode source string that is to be
<         converted to ansi.
---
> 	//
> 	// if you hit this ASSERT it's because you've probably got ASCII text as your
> 	// input WCHAR string.  Double-check your input!!
> 	//
> 	DNASSERT( fDefault == FALSE );
55,56c111,113
<     BytesInUnicodeString - The number of bytes in the the string pointed to by
<         UnicodeString.
---
> 	return	hr;
> }
> //**********************************************************************
58d114
< Return Value:
60,63c116,133
<     SUCCESS - The conversion was successful
< 
< --*/
< 
---
> //**********************************************************************
> // ------------------------------
> // ANSIToWide - convert an ANSI string to a wide string
> //
> // Entry:		Pointer to source multi-byte (ANSI) string
> //				Size of source string (-1 imples NULL-terminated)
> //				Pointer to multi-byte string destination
> //				Pointer to size of multi-byte destination (in WCHAR units)
> //
> // Exit:		Error code:
> //				DPNERR_GENERIC = operation failed
> //				DPN_OK = operation succeded
> //				DPNERR_BUFFERTOOSMALL = destination buffer too small
> // ------------------------------
> HRESULT	STR_AnsiToWide( const char *const pString,
> 						const DWORD dwStringLength,
> 						WCHAR *const pWCHARString,
> 						DWORD *const pdwWCHARStringLength )
65,66c135,138
<     ULONG LoopCount;
<     ULONG CharsInUnicodeString;
---
> 	HRESULT	hr;
> 	int		iReturn;
> 	WCHAR	MilleniumHackBuffer;
> 	WCHAR	*pMilleniumHackBuffer;
68d139
<     CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);
70,71c141,143
<     LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
<                  CharsInUnicodeString : MaxBytesInMultiByteString;
---
> 	DNASSERT( pString != NULL );
> 	DNASSERT( pdwWCHARStringLength != NULL );
> 	DNASSERT( ( pWCHARString != NULL ) || ( *pdwWCHARStringLength == 0 ) );
73c145,150
<     while (LoopCount) {
---
> 	//
> 	// Initialize.  A hack needs to be implemented because their paramter
> 	// validation is screwed and when you pass zero for a destination size, you
> 	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
> 	//
> 	hr = DPN_OK;
75c152,170
<         *MultiByteString = (*UnicodeString < 256) ? (UCHAR)*UnicodeString : '?';
---
> 	if ( *pdwWCHARStringLength == 0 )
> 	{
> 		pMilleniumHackBuffer = &MilleniumHackBuffer;
> 	}
> 	else
> 	{
> 		pMilleniumHackBuffer = pWCHARString;
> 	}
> 	
> 	iReturn = MultiByteToWideChar( CP_ACP,					// code page (default ANSI)
> 								   0,						// flags (none)
> 								   pString,					// pointer to multi-byte string			
> 								   dwStringLength,			// size of string (assume null-terminated)
> 								   pMilleniumHackBuffer,	// pointer to destination wide-char string
> 								   *pdwWCHARStringLength	// size of destination in WCHARs
> 								   );
> 	if ( iReturn == 0 )
> 	{
> 		DWORD	dwError;
77,80d171
<         UnicodeString++;
<         MultiByteString++;
<         LoopCount--;
<     }
82,83c173,187
<     return DPN_OK;
< }
---
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to convert multi-byte to WCHAR!" );
> 		DisplayDNError( 0, dwError );
> 		hr = DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		if ( *pdwWCHARStringLength == 0 )
> 		{
> 			hr = DPNERR_BUFFERTOOSMALL;
> 		}
> 		else
> 		{
> 			DNASSERT( hr == DPN_OK );
> 		}
84a189,190
> 		*pdwWCHARStringLength = iReturn;
> 	}
86,151c192
< HRESULT
< MultiByteToUnicodeN(
<     OUT PWCH UnicodeString,
<     IN ULONG MaxBytesInUnicodeString,
<     IN PCH MultiByteString,
<     IN ULONG BytesInMultiByteString)
< 
< /*++
< 
< Routine Description:
< 
<     This functions converts the specified ansi source string into a
<     Unicode string. The translation is done with respect to the
<     ANSI Code Page (ACP) installed at boot time.  Single byte characters
<     in the range 0x00 - 0x7f are simply zero extended as a performance
<     enhancement.  In some far eastern code pages 0x5c is defined as the
<     Yen sign.  For system translation we always want to consider 0x5c
<     to be the backslash character.  We get this for free by zero extending.
< 
<     NOTE: This routine only supports precomposed Unicode characters.
< 
< Arguments:
< 
<     UnicodeString - Returns a unicode string that is equivalent to
<         the ansi source string.
< 
<     MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
<         written to UnicodeString.  If this causes UnicodeString to be a
<         truncated equivalent of MultiByteString, no error condition results.
< 
<     BytesInUnicodeString - Returns the number of bytes in the returned
<         unicode string pointed to by UnicodeString.
< 
<     MultiByteString - Supplies the ansi source string that is to be
<         converted to unicode.  For single-byte character sets, this address
<         CAN be the same as UnicodeString.
< 
<     BytesInMultiByteString - The number of bytes in the string pointed to
<         by MultiByteString.
< 
< Return Value:
< 
<     SUCCESS - The conversion was successful.
< 
< 
< --*/
< 
< {
<     ULONG LoopCount;
<     ULONG MaxCharsInUnicodeString;
< 
<     MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);
< 
<     LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
<                  MaxCharsInUnicodeString : BytesInMultiByteString;
< 
<     while (LoopCount) {
< 
<         *UnicodeString = (WCHAR)(UCHAR)(*MultiByteString);
< 
<         UnicodeString++;
<         MultiByteString++;
<         LoopCount--;
<     }
< 
<     return DPN_OK;
---
> 	return	hr;
152a194
> //**********************************************************************
154a197
> 
174a218,220
> 	int rval;
> 	BOOL bDefault = FALSE;
> 
182c228,238
< 	UnicodeToMultiByteN( lpStr, cchStr, (PWCH) lpWStr, cchStr*sizeof(WCHAR));
---
> 	// use the default code page (CP_ACP)
> 	// -1 indicates WStr must be null terminated
> 	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,
> 			NULL,&bDefault);
> 
> 	if (bDefault)
> 	{
> 		DPF(3,"!!! WARNING - used default string in WideToAnsi conversion.!!!");
> 		DPF(3,"!!! Possible bad unicode string - (you're not hiding ansi in there are you?) !!! ");
> 		return DPNERR_CONVERSION;
> 	}
188a245,251
> //	WideToAnsi
> //
> //	Convert a WCHAR (Wide) string to a CHAR (ANSI) string
> //
> //	CHAR	*pStr		CHAR string
> //	WCHAR	*pWStr		WCHAR string
> //	int		iStrSize	size (in bytes) of buffer pointed to by lpStr
189a253,295
> #define DPF_MODNAME "STR_AllocAndConvertToANSI"
> /*
>  ** GetAnsiString
>  *
>  *  CALLED BY: Everywhere
>  *
>  *  PARAMETERS: *ppszAnsi - pointer to string
>  *				lpszWide - string to copy
>  *
>  *  DESCRIPTION:	  handy utility function
>  *				allocs space for and converts lpszWide to ansi
>  *
>  *  RETURNS: string length
>  *
>  */
> HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide)
> {
> 	int iStrLen;
> 	BOOL bDefault;
> 	
> 	DNASSERT(ppszAnsi);
> 
> 	if (!lpszWide)
> 	{
> 		*ppszAnsi = NULL;
> 		return S_OK;
> 	}
> 
> 	*ppszAnsi = new char[wcslen(lpszWide)+1];
> 	if (!*ppszAnsi)	
> 	{
> 		DPF(0, "could not get ansi string -- out of memory");
> 		return E_OUTOFMEMORY;
> 	}
> 
> 	iStrLen = WideCharToMultiByte(CP_ACP,0,lpszWide,-1,*ppszAnsi,wcslen(lpszWide)+1,
> 			NULL,&bDefault);
> 
> 	return DPN_OK;
> } // OSAL_AllocAndConvertToANSI
> 
> 
> #undef DPF_MODNAME
208a315,316
> 	int rval;
> 
216c324
< 	MultiByteToUnicodeN( lpWStr, cchWStr*sizeof(WCHAR), (CHAR *) lpStr, cchWStr );
---
> 	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);
219a328
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\strutils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide);
21a23,31
> HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
> 						const DWORD dwWCHARStringLength,
> 						char *const pString,
> 						DWORD *const pdwStringLength );
> 
> HRESULT	STR_AnsiToWide( const char *const pString,
> 						const DWORD dwStringLength,
> 						WCHAR *const pWCHARString,
> 						DWORD *const pdwWCHARStringLength );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\appdesc.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
38d37
< #include <wchar.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
94a95
> #include "DVoice.h"
127a129
> #include "Voice.h"
129c131,133
< #include <mmsystem.h>
---
> #include "dpnsdef.h"
> #include "dpnsvrq.h"
> #include "dpnsvlib.h"
192,193c196
< // BUGBUG: [mgere] [xbox] Completely removed this function since Xbox doesn't have multiple adapters.
< /*
---
> 
306d308
< */
387,388c389
< // BUGBUG: [mgere] [xbox] Need to figure out what to do with this.  We can't enumerate adapters.
< /*
---
> 
442c443
< */
---
> 
500c501
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
522c523
< 	pDeviceInfo->lpVtbl->GetURLW(pDeviceInfo,DP8ABuffer,&DP8ASize);
---
> 	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer,&DP8ASize);
641d641
< // BUGBUG: [mgere] [xbox] This shouldn't be needed since we don't have multiple adapters.
1135c1135
< 		//	generate a completion for the buffer.
---
> 		//	generate a completion for the buffer.
1180,1181c1180,1181
< 	WCHAR			DP8ABuffer[512];
< 	WCHAR			DP8ABuffer2[512];
---
> 	CHAR			DP8ABuffer[512];
> 	CHAR			DP8ABuffer2[512];
1197c1197
< 	pRemoteAddr->lpVtbl->GetURLW(pRemoteAddr,DP8ABuffer,&DP8ASize);
---
> 	pRemoteAddr->lpVtbl->GetURLA(pRemoteAddr,DP8ABuffer,&DP8ASize);
1200c1200
< 	pDeviceInfo->lpVtbl->GetURLW(pDeviceInfo,DP8ABuffer2,&DP8ASize);
---
> 	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer2,&DP8ASize);
1854a1855,1867
> 		if (dwMsgId == DN_MSG_INTERNAL_VOICE_SEND)
> 		{
> 			DNASSERT(pdnBufferDesc != NULL);
> 			pSendOpData->BufferDesc[0].pBufferData = pdnBufferDesc->pBufferData;
> 			pSendOpData->BufferDesc[0].dwBufferSize = pdnBufferDesc->dwBufferSize;
> 			pSendOpData->BufferDesc[1].pBufferData = NULL;
> 			pSendOpData->BufferDesc[1].dwBufferSize = 0;
> 			pSendOpData->dwNumBuffers = 1;
> 
> 			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO );
> 		}
> 		else
> 		{
1870a1884
> 		}
2233a2248,2260
> 		if (dwMsgId == DN_MSG_INTERNAL_VOICE_SEND)
> 		{
> 			DNASSERT(pdnBufferDesc != NULL);
> 			pSendOpData->BufferDesc[0].pBufferData = pdnBufferDesc->pBufferData;
> 			pSendOpData->BufferDesc[0].dwBufferSize = pdnBufferDesc->dwBufferSize;
> 			pSendOpData->BufferDesc[1].pBufferData = NULL;
> 			pSendOpData->BufferDesc[1].dwBufferSize = 0;
> 			pSendOpData->dwNumBuffers = 1;
> 
> 			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO );
> 		}
> 		else
> 		{
2249a2277
> 		}
2763a2792,2800
> 
> 				break;
> 			}
> 
> 		case DN_MSG_INTERNAL_VOICE_SEND:
> 			{
> 				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");
> 
> 				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
125,126c125
< // BUGBUG: [mgere] [xbox] Removed (see cpp file)
< /*
---
> 
132c131
< */
---
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
57a58
> #include "DVoice.h"
87a89,90
> #include "dvoice.h"
> #include "voice.h"
89a93
> #include "dplobby8.h"
135a140
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
249a255,274
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
253c278,279
< 			riid != IID_IUnknown )
---
> 			riid != IID_IUnknown &&
> 			riid != IID_IDirectPlayVoiceTransport )
262a289
> 			riid != IID_IDirectPlayVoiceTransport &&
272c299,300
< 			riid != IID_IUnknown )
---
> 			riid != IID_IUnknown &&
> 			riid != IID_IDirectPlayVoiceTransport )
307a336,337
> 	pdnObject->pIDP8LobbiedApplication = NULL;
> 	pdnObject->dpnhLobbyConnection = NULL;
329a360,362
> 	// Voice Additions
>     pdnObject->lpDxVoiceNotifyClient = NULL;	
>     pdnObject->lpDxVoiceNotifyServer = NULL;
361a395,401
> 	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
> 	{
> 		DPFERR("DNInitializeCriticalSection() failed");
> 		DNCF_FreeObject(pdnObject);
> 		return(E_OUTOFMEMORY);
> 	}
> 
737a778,780
> 	// Voice Critical Section
> 	DNDeleteCriticalSection(&pdnObject->csVoice);
> 
834a878,883
> 	if( pdnObject->pIDP8LobbiedApplication)
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release( pdnObject->pIDP8LobbiedApplication );
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 	}
> 
1000a1050,1054
> 	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
> 	{
> 		DPF(7,"riid = IID_IDirectPlayVoiceTransport");
> 		lpVtbl = &DN_VoiceTbl;
> 	}
1014c1068
< 	{
---
> 	{
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\client.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
64d63
< #include <wchar.h>
102c101
< typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
156a157,158
> #include "DPLobby8.h"
> #include "DVoice.h"
184a187
> #include "DNMisc.h"
191a195
> #include "Voice.h"
193a198,200
> #include "dpnsdef.h"
> #include "dpnsvrq.h"
> #include "dpnsvlib.h"
195,196d201
< #include <mmsystem.h>
< #include <wchar.h>
639a645,653
> 	pdnObject->dpnhLobbyConnection = NULL;
> 
> 	// Release our hold on the lobbiedapplication
> 	if( pdnObject->pIDP8LobbiedApplication) 
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release(pdnObject->pIDP8LobbiedApplication);
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 	}
> 
1170a1185,1188
> 	if (dwFlags & DPNCONNECT_OKTOQUERYFORADDRESSING)
> 	{
> 		dwConnectFlags |= DPNCONNECT_OKTOQUERYFORADDRESSING;
> 	}
1277d1294
< // BUGBUG: [mgere] [xbox] Set breakpoint here and see if it ever gets in here.
1293,1295d1309
< // BUGBUG: [mgere] [xbox] I know this is busted.  Remove this whole section about enumerating adapters
< // and check if it's ok.
< /*
1326d1339
< */
1927a1941,1953
> 	//	Update Lobby status
> 	//
> 	if (fWasConnected)
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_DISCONNECTED);
> 	}
> 
> 	//
> 	//	Notify Voice
> 	//
> 	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
> 
> 	//
2102c2128
< 	{
---
> 	{
2497,2498d2522
< // BUGBUG [mgere] [xbox] Temporarily removed until a CoCreateGuid call is implemented
< #ifdef _BUILD_FOR_WIN2000
2504d2527
< #endif
2567a2591,2599
> 	//	Inform DPNSVR of LISTENs
> 	//
> 	if( !(pdnObject->dnApplicationDescription.dwFlags & DPNSESSION_NODPNSVR) )
> 	{
> 		DPF(3,"Registering with DPNSVR");
> 		DNRegisterWithDPNSVR(pdnObject);
> 	}
> 
> 	//
2676a2709,2713
> 	//	Update Lobby status
> 	//
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_CONNECTED);
> 
> 	//
3929c3966
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
4052c4089
< 	pIHost->lpVtbl->GetURLW(pIHost,DP8ABuffer,&DP8ASize);
---
> 	pIHost->lpVtbl->GetURLA(pIHost,DP8ABuffer,&DP8ASize);
4056c4093
< 	pIDevice->lpVtbl->GetURLW(pIDevice,DP8ABuffer,&DP8ASize);
---
> 	pIDevice->lpVtbl->GetURLA(pIDevice,DP8ABuffer,&DP8ASize);
4115c4152
< 	//
---
> 	//
4133d4169
< // BUGBUG: [mgere] [xbox] Set breakpoint here and see if it ever gets in here.
4149,4151d4184
< // BUGBUG: [mgere] [xbox] I know this is busted.  Remove this whole section about enumerating adapters
< // and check if it's ok.
< /*
4183d4215
< */
4784c4816
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
4787c4819,4888
< 	return DPNERR_UNSUPPORTED;
---
> 	DIRECTNETOBJECT		*pdnObject;
> 	HRESULT             hResultCode;
> 
> 	DPF(3,"Parameters: pInterface [0x%p], pIDP8LobbiedApplication [0x%p], dwFlags [0x%lx]",
> 			pInterface,pIDP8LobbiedApplication,dwFlags);
> 
> 	TRY
> 	{
>     	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
>     	DNASSERT(pdnObject != NULL);
> 
>     	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
>     	{
>     	    if( FAILED( hResultCode = DN_ValidateRegisterLobby( pInterface, pIDP8LobbiedApplication, dwFlags ) ) )
>     	    {
>     	        DPFERR( "Error validating register lobby params" );
>     	        DPF_EXIT( hResultCode );
>     	    }
>     	}
> 
>     	// Check to ensure message handler registered
>     	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
>     	{
>     		DPFERR( "Object is not initialized" );
>     		DPF_EXIT(DPNERR_UNINITIALIZED);
>     	}
> 
> 	}
> 	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
> 	{
> 	    DPFERR("Invalid object" );
> 	    DPF_EXIT(DPNERR_INVALIDOBJECT);
> 	}	
> 
> 	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
> 	DNASSERT(pdnObject != NULL);
> 
> 	if (dwFlags == DPNLOBBY_REGISTER)
> 	{
> 		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 		if (pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE)
> 		{
> 			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 			return(DPNERR_ALREADYINITIALIZED);
> 		}
> 				
> 		pIDP8LobbiedApplication->lpVtbl->AddRef(pIDP8LobbiedApplication);
> 
> 		pdnObject->pIDP8LobbiedApplication = pIDP8LobbiedApplication;
> 		pdnObject->dpnhLobbyConnection = dpnhLobbyConnection;
> 		pdnObject->dwFlags |= DN_OBJECT_FLAG_LOBBY_AWARE;
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	}
> 	else
> 	{
> 		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE))
> 		{
> 			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 			return(DPNERR_UNINITIALIZED);
> 		}
> 				
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release(pdnObject->pIDP8LobbiedApplication);
> 		pdnObject->dpnhLobbyConnection = NULL;
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_LOBBY_AWARE);
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	}
> 
> 	return(DPN_OK);
4789a4891,4913
> #undef DPF_MODNAME
> #define DPF_MODNAME "DNNotifyLobbyClientOfSettings"
> // 
> // DNNotifyLobbyClientOfSettings
> //
> // This function sends a connection settings update to the lobby client informing it that the lobby 
> // client settings have changed.  
> //
> HRESULT DNNotifyLobbyClientOfSettings(
> 	DIRECTNETOBJECT * const pdnObject,
> 	IDirectPlay8LobbiedApplication *pdpLobbiedApp, 
> 	DPNHANDLE dpnConnection, 
> 	IDirectPlay8Address *pHostAddress, 
> 	IDirectPlay8Address *pConnectFromAddress )
> {
> 	HRESULT						hResultCode = DPN_OK;
> 	DPL_CONNECTION_SETTINGS		dplConnectionSettings;
> 	BOOL						fIsHost = FALSE;
> 	CPackedBuffer				packBuffer;
> 	PBYTE						pBuffer = NULL;
> 	BOOL						fINCriticalSection = FALSE;
> 	CNameTableEntry				*pNTEntry = NULL;
> 	DWORD						dwIndex;
4790a4915,5060
> 	fIsHost = DN_CHECK_LOCALHOST( pdnObject );
> 
> 	ZeroMemory( &dplConnectionSettings, sizeof( DPL_CONNECTION_SETTINGS ) );
> 	dplConnectionSettings.dwSize = sizeof( DPL_CONNECTION_SETTINGS );
> 	dplConnectionSettings.dwFlags = (fIsHost) ? DPLCONNECTSETTINGS_HOST : 0;
> 
> 	// Lock the object while we make a copy of the app desc.  
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	fINCriticalSection = TRUE;
> 	
> 	packBuffer.Initialize(NULL, 0 );
> 
> 	// Determine the size of buffer
> 	hResultCode = DNPackApplicationDesc( &pdnObject->dnApplicationDescription, &packBuffer );
> 
> 	if( hResultCode != DPNERR_BUFFERTOOSMALL ) 
> 	{
> 		DPF( 0, "Error getting app desc size hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	pBuffer = new BYTE[packBuffer.GetSizeRequired()];
> 
> 	if( !pBuffer )
> 	{
> 		DPF( 0, "Error allocating memory for buffer" );
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	packBuffer.Initialize(pBuffer,packBuffer.GetSizeRequired());
> 
> 	hResultCode = DNPackApplicationDesc( &pdnObject->dnApplicationDescription, &packBuffer );
> 
> 	if( FAILED( hResultCode ) )
> 	{
> 		DPF( 0, "Error packing app desc hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	fINCriticalSection = FALSE;
> 
> 	memcpy( &dplConnectionSettings.dpnAppDesc, pBuffer, sizeof( DPN_APPLICATION_DESC ) );
> 
> 	hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pNTEntry );
> 
> 	if( FAILED( hResultCode ) )
> 	{
> 		DPF( 0, "Error getting local player hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	// Make sure player name isn't changed while we are working with the entry
> 	pNTEntry->Lock();
> 	if( pNTEntry->GetName() )
> 	{
> 		dplConnectionSettings.pwszPlayerName = new WCHAR[wcslen(pNTEntry->GetName())+1];
> 
> 		if( !dplConnectionSettings.pwszPlayerName )
> 		{
> 			pNTEntry->Unlock();
> 			DPF( 0, "Error allocating memory" );
> 			goto NOTIFY_EXIT;
> 		}
> 		
> 		wcscpy( dplConnectionSettings.pwszPlayerName, pNTEntry->GetName() );
> 	}
> 	else
> 	{
> 		dplConnectionSettings.pwszPlayerName = NULL;		
> 	}
> 	pNTEntry->Unlock();
> 
> 	// Release our reference
> 	pNTEntry->Release();
> 
> 	// Host address field
> 	if( fIsHost )
> 	{
> 		dplConnectionSettings.pdp8HostAddress = NULL;
> 
> 		hResultCode = DNGetHostAddressHelper( pdnObject, dplConnectionSettings.ppdp8DeviceAddresses, &dplConnectionSettings.cNumDeviceAddresses );
> 
> 		if( hResultCode != DPNERR_BUFFERTOOSMALL )
> 		{
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			DPF( 0, "Could not get host addresses for lobby update hr=0x%x", hResultCode );
> 			goto NOTIFY_EXIT;
> 		}
> 
> 		dplConnectionSettings.ppdp8DeviceAddresses = new IDirectPlay8Address*[dplConnectionSettings.cNumDeviceAddresses];
> 
> 		if( !dplConnectionSettings.ppdp8DeviceAddresses )
> 		{
> 			DPF( 0, "Error allocating memory" );
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			hResultCode = DPNERR_OUTOFMEMORY;
> 			goto NOTIFY_EXIT;
> 		}
> 
> 		hResultCode = DNGetHostAddressHelper( pdnObject, dplConnectionSettings.ppdp8DeviceAddresses, &dplConnectionSettings.cNumDeviceAddresses );
> 
> 		if( FAILED( hResultCode ) )
> 		{
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			DPF( 0, "Could not get host addresses for lobby update hr=0x%x", hResultCode );
> 			goto NOTIFY_EXIT;
> 		}
> 	}
> 	else
> 	{
> 		dplConnectionSettings.pdp8HostAddress = pHostAddress;
> 		dplConnectionSettings.ppdp8DeviceAddresses = &pConnectFromAddress;
> 		dplConnectionSettings.cNumDeviceAddresses = 1;	
> 	}
> 
> 	// Update the settings
> 	hResultCode = pdpLobbiedApp->lpVtbl->SetConnectionSettings( pdpLobbiedApp, dpnConnection, &dplConnectionSettings, 0 );
> 
> NOTIFY_EXIT:
> 
> 	if( dplConnectionSettings.ppdp8DeviceAddresses && fIsHost )
> 	{
> 		for( dwIndex = 0; dwIndex < dplConnectionSettings.cNumDeviceAddresses; dwIndex++ )
> 		{
> 			dplConnectionSettings.ppdp8DeviceAddresses[dwIndex]->lpVtbl->Release( dplConnectionSettings.ppdp8DeviceAddresses[dwIndex] );
> 		}
> 
> 		delete [] dplConnectionSettings.ppdp8DeviceAddresses;
> 	}
> 
> 	if( dplConnectionSettings.pwszPlayerName )
> 		delete [] dplConnectionSettings.pwszPlayerName;
> 
> 	if( fINCriticalSection ) 
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	if( pBuffer )
> 		delete [] pBuffer;
> 
> 	return hResultCode;
> 
> }
> 
> 
4791a5062,5142
> #define DPF_MODNAME "DNUpdateLobbyStatus"
> 
> HRESULT DNUpdateLobbyStatus(DIRECTNETOBJECT *const pdnObject,
> 							const DWORD dwStatus)
> {
> 	HRESULT		hResultCode;
> 	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
> 	DPNHANDLE dpnhLobbyConnection = NULL;
> 	IDirectPlay8Address *pHostAddress = NULL;
> 	IDirectPlay8Address *pConnectFromAddress = NULL;
> 
> 	DPF(4,"Parameters: dwStatus [0x%lx]",dwStatus);
> 
> 	DNASSERT(pdnObject != NULL);
> 
> 	pIDP8LobbiedApplication = NULL;
> 
> 	//
> 	//	Get lobbied application interface, if it exists and other settings we need
> 	//
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE) && (pdnObject->pIDP8LobbiedApplication))
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->AddRef(pdnObject->pIDP8LobbiedApplication);
> 		pIDP8LobbiedApplication = pdnObject->pIDP8LobbiedApplication;
> 		dpnhLobbyConnection = pdnObject->dpnhLobbyConnection;
> 
> 		pConnectFromAddress = pdnObject->pIDP8ADevice;
> 		pHostAddress = pdnObject->pConnectAddress;
> 
> 		if( pConnectFromAddress )
> 		{
> 			pConnectFromAddress->lpVtbl->AddRef( pConnectFromAddress );			
> 		}
> 
> 		if( pHostAddress )
> 		{
> 			pHostAddress->lpVtbl->AddRef( pHostAddress );
> 		}
> 	}
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	//
> 	//	Update status and release object
> 	//
> 	if (pIDP8LobbiedApplication)
> 	{
> 		// If we are about to do a connection notification
> 		// we send the updated connection settings.  
> 		// 
> 		// This gives lobby client full picture. 
> 		//
> 		if( dwStatus == DPLSESSION_CONNECTED )
> 		{
> 			DNNotifyLobbyClientOfSettings(pdnObject, pIDP8LobbiedApplication, dpnhLobbyConnection, pHostAddress, pConnectFromAddress );
> 		}
> 
> 		pIDP8LobbiedApplication->lpVtbl->UpdateStatus(pIDP8LobbiedApplication,dpnhLobbyConnection,dwStatus,0);
> 
> 		pIDP8LobbiedApplication->lpVtbl->Release(pIDP8LobbiedApplication);
> 		pIDP8LobbiedApplication = NULL;
> 
> 		if( pHostAddress )
> 		{
> 			pHostAddress->lpVtbl->Release( pHostAddress );
> 		}		
> 
> 		if( pConnectFromAddress )
> 		{
> 			pConnectFromAddress->lpVtbl->Release( pConnectFromAddress );
> 		}
> 	}
> 
> 	hResultCode = DPN_OK;
> 
> 	DPF(4,"Returning: [0x%lx]",hResultCode);
> 	return(hResultCode);
> }
> 
> 						
> #undef DPF_MODNAME
5132a5484,5613
> }
> 
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DNRegisterWithDPNSVR"
> 
> HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject)
> {
> 	HRESULT					hResultCode;
> 	HRESULT					hrRegister;
> 	CAsyncOp				*pListenParent;
> 	CAsyncOp				*pListenSP;
> 	CAsyncOp				*pListen;
> 	CBilink					*pBilinkSP;
> 	CBilink					*pBilink;
> 	SPGETADDRESSINFODATA	spInfo;
> #ifdef	DEBUG
> 	CHAR			DP8ABuffer[512];
> 	DWORD			DP8ASize;
> #endif
> 
> 	DPF(4,"Parameters: (none)");
> 
> 	pListenParent = NULL;
> 	pListenSP = NULL;
> 	pListen = NULL;
> 
> 	//
> 	//	Default error returned
> 	//
> 	hrRegister = DPNERR_GENERIC;
> 
> 	//
> 	//	Get LISTEN AsyncOp parent from DirectNet object and add a RefCount
> 	//
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	if (pdnObject->pListen == NULL)
> 	{
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 		goto Exit;
> 	}
> 	pdnObject->pListen->AddRef();
> 	pListenParent = pdnObject->pListen;
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	//
> 	//	Lock the parent so that the child bilink list doesn't change
> 	//
> 	pListenParent->Lock();
> 
> 	//
> 	//	Locate each child (LISTEN SP parent) and then each actual LISTEN
> 	//
> 	pBilinkSP = pListenParent->m_bilinkParent.GetNext();
> 	while (pBilinkSP != &pListenParent->m_bilinkParent)
> 	{
> 		pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);
> 
> DNASSERT(pListenSP->GetParent() == pListenParent);
> 		//
> 		//	Lock the SP parent so that the child bilink doesn't change
> 		//
> 		pListenSP->Lock();
> 
> 		pBilink = pListenSP->m_bilinkParent.GetNext();
> 		while (pBilink != &pListenSP->m_bilinkParent)
> 		{
> 			pListen = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
> 
> 			DNASSERT(pListen->GetProtocolHandle() != NULL);
> 
> 			spInfo.hEndpoint = pListen->GetProtocolHandle();
> 			spInfo.pAddress = NULL;
> 			spInfo.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;
> 
> 			if (DNPGetListenAddressInfo(pListen->GetProtocolHandle(),&spInfo) == DPN_OK)
> 			{
> 				DNASSERT(spInfo.pAddress != NULL);
> #ifdef	DEBUG
> 				DP8ASize = 512;
> 				spInfo.pAddress->lpVtbl->GetURLA(spInfo.pAddress,DP8ABuffer,&DP8ASize);
> 				DPF(4,"Listen address [%s]",DP8ABuffer);
> 
> 				// We re-try the registration to catch the case where DPNSVR is shutting
> 				// down while we are trying to register.  Unlikely but has to be handled.
> 				//
> #endif
> 	            for( DWORD dwRetry = 0; dwRetry < DPNSVR_REGISTER_ATTEMPTS ; dwRetry ++ )
> 		        {
>     				hResultCode = DPNSVR_Register( &pdnObject->dnApplicationDescription, spInfo.pAddress );
> 	    			if( FAILED( hResultCode ) )
> 					{
>     					if( dwRetry < DPNSVR_REGISTER_ATTEMPTS )
>     					{
> 	    					DPF( 0, "Unable to register ourselves with DPNSVR hr=0x%x, retrying", hResultCode );    				
> 	    					Sleep( DPNSVR_REGISTER_SLEEP );    				
> 	    				}
> 						else
>     					{
> 	    					DPF( 0, "Unable to register ourselves with DPNSVR hr=0x%x", hResultCode );
> 	    				}
> 	    			}
> 					else
>     				{
>     					// Return DPN_OK if we succeed even once
>     					hrRegister = hResultCode;
>     					break;
> 	    			}
> 		        }
> 			
> 				spInfo.pAddress->lpVtbl->Release(spInfo.pAddress);
> 				spInfo.pAddress = NULL;
> 
> 			}
> 			pBilink = pBilink->GetNext();
> 		}
> 
> 		pListenSP->Unlock();
> 
> 		pBilinkSP = pBilinkSP->GetNext();
> 	}
> 
> 	pListenParent->Unlock();
> 
> 	pListenParent->Release();
> 	pListenParent = NULL;
> 
> Exit:
> 	DPF(4,"Returning: [0x%lx]",hrRegister);
> 	return( hrRegister );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
199c199
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
201a202,204
> HRESULT DNUpdateLobbyStatus(DIRECTNETOBJECT *const pdnObject,
> 							const DWORD dwStatus);
> 
209a213,214
> 
> HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
77a78
> #include "DPLobby8.h"
105d105
< #include <wchar.h>
109,112d108
< #define CompareGuid(a,b)                                         \
<     (memcmp((PVOID)(a), (PVOID)(b), sizeof(GUID)))
< 
< 
180c176
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
253,254c249,250
< 		if ((hResultCode = pAddress->lpVtbl->BuildFromURLW(	pAddress,
< 															static_cast<WCHAR*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
---
> 		if ((hResultCode = pAddress->lpVtbl->BuildFromURLA(	pAddress,
> 															static_cast<char*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
281c277
< 		pAddress->lpVtbl->GetURLW(pAddress,DP8ABuffer,&DP8ASize);
---
> 		pAddress->lpVtbl->GetURLA(pAddress,DP8ABuffer,&DP8ASize);
725c721
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
810c806
< 	if (pguidInstance && CompareGuid(pguidInstance,&GUID_NULL))
---
> 	if (pguidInstance && !UuidIsNil(pguidInstance,&rpcStatus))
823c819
< 	if (pguidApplication && CompareGuid(pguidApplication,&GUID_NULL))
---
> 	if (pguidApplication && !UuidIsNil(pguidApplication,&rpcStatus))
880c876
< 		pDevice->lpVtbl->GetURLW(pDevice,DP8ABuffer,&DP8ASize);
---
> 		pDevice->lpVtbl->GetURLA(pDevice,DP8ABuffer,&DP8ASize);
1181c1177
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
1206,1207c1202
< 				pAddress->lpVtbl->GetURLW(pAddress,NULL,&dwAddressSize);
< 				dwAddressSize = dwAddressSize * sizeof(WCHAR);
---
> 				pAddress->lpVtbl->GetURLA(pAddress,NULL,&dwAddressSize);
1211c1206
< 				pAddress->lpVtbl->GetURLW(pAddress,DP8ABuffer,&DP8ASize);
---
> 				pAddress->lpVtbl->GetURLA(pAddress,DP8ABuffer,&DP8ASize);
1338,1339c1333,1334
< 		if ((hResultCode = pAddress->lpVtbl->GetURLW(pAddress,
< 													static_cast<WCHAR*>(packedBuffer.GetTailAddress()),
---
> 		if ((hResultCode = pAddress->lpVtbl->GetURLA(pAddress,
> 													static_cast<char*>(packedBuffer.GetTailAddress()),
1709a1705,1709
> 	//	Update Lobby status
> 	//
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_CONNECTED);
> 
> 	//
2006a2007,2015
> 	if (fWasConnected)
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_DISCONNECTED);
> 	}
> 	else
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_COULDNOTCONNECT);
> 	}
> 
2851c2860
< 	WCHAR					DP8ABuffer[512];
---
> 	CHAR					DP8ABuffer[512];
2885c2894
< 		(*ppAddress)->lpVtbl->GetURLW(*ppAddress,DP8ABuffer,&DP8ASize);
---
> 		(*ppAddress)->lpVtbl->GetURLA(*ppAddress,DP8ABuffer,&DP8ASize);
2908c2917
< 	WCHAR					DP8ABuffer[512];
---
> 	CHAR					DP8ABuffer[512];
2935c2944
< 		(*ppAddress)->lpVtbl->GetURLW(*ppAddress,DP8ABuffer,&DP8ASize);
---
> 		(*ppAddress)->lpVtbl->GetURLA(*ppAddress,DP8ABuffer,&DP8ASize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dllmain.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "creg.h"
42a44,180
> #undef DPF_MODNAME
> #define DPF_MODNAME "RegisterDefaultSettings"
> //
> // RegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT RegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create app sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		return DPN_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "UnRegisterDefaultSettings"
> //
> // UnRegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT UnRegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot remove app, does not exist" );
> 	}
> 	else
> 	{
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_SP_SUB)[1] ) )
> 		{
> 			DPFERR( "Cannot remove cp sub-key, could have elements" );
> 		}
> 	}
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Client.1", L"DirectPlay8Client Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Client, L"DirectPlay8.Client") )
> 	{
> 		DPFERR( "Could not register dp8 client object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Server.1", L"DirectPlay8Server Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Server, L"DirectPlay8.Server") )
> 	{
> 		DPFERR( "Could not register dp8 Server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Peer.1", L"DirectPlay8Peer Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Peer, L"DirectPlay8.Peer") )
> 	{
> 		DPFERR( "Could not register dp8 client object" );
> 		fFailed = TRUE;
> 	}
> 
> 
> 	if( FAILED( hr = RegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Could not register default settings hr = 0x%x", hr );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Client) )
> 	{
> 		DPF( 0, "Failed to unregister client object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Server) )
> 	{
> 		DPF( 0, "Failed to unregister server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Peer) )
> 	{
> 		DPF( 0, "Failed to unregister peer object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = UnRegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Failed to remove default settings hr=0x%x", hr );
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
100a101,103
> #define DN_REG_LOCAL_SP_ROOT				L"Software\\Microsoft\\DirectPlay8"
> #define DN_REG_LOCAL_SP_SUB					L"\\Service Providers"
> #define DN_REG_LOCAL_SP_SUBKEY				DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB
101a105,109
> #define	DN_REG_KEYNAME_ADAPTER_LIST			L"Adapter List"
> #define	DN_REG_KEYNAME_ALL_APPLICATIONS		L"All Applications"
> #define	DN_REG_KEYNAME_FRIENDLY_NAME		L"Friendly Name"
> #define DN_REG_KEYNAME_GUID					L"GUID"
> 
124a133,134
> typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
> typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
159a170,177
> //
> // Voice Additions
> //
> // this is the number of clients of IDirectXVoice in this process
> // this is actually a ridiculously large number of client slots.
> //
> #define MAX_VOICE_CLIENTS	32	
> 
231a250,254
> 	// Voice Additions
> 	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
> 	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
> 	DNCRITICAL_SECTION		csVoice;
> 
239a263
> 	// Lobby additions
240a265,268
> 	DPNHANDLE				dpnhLobbyConnection;	// Lobby Connection to update
> 
> 	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
5a6,8
> 	DllRegisterServer	PRIVATE
> 	DllUnregisterServer	PRIVATE
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnet.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,62
> 
> #endif
> 
> #endif    // !_MAC
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
43a44
> #include "DNMisc.h"
45a47
> #include "CReg.h"
59c61,70
< // BUGBUG: [xbox] [mgere] Removed since we don't support registry
---
> 	DWORD	dwAllAppLen;
> 	WCHAR	lpwszAllAppStr[DN_FLAG_STR_LEN+1];
> 
> 	dwAllAppLen = (DN_FLAG_STR_LEN + 1) * sizeof(WCHAR);
> 	if (RegQueryValueExW(hSPKey,DN_REG_KEYNAME_ALL_APPLICATIONS,NULL,NULL,(PBYTE)lpwszAllAppStr,&dwAllAppLen) != ERROR_SUCCESS)
> 		return(FALSE);
> 
> 	if (towupper(lpwszAllAppStr[0]) == L'N')
> 		return(TRUE);
> 
74,75c85
< // BUGBUG:  [mgere] [xbox] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
77c87,97
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
79,80c99,102
<     WCHAR wszSP[] = L"DirectPlay8 TCP/IP Service Provider";
< 	GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
> //	CServiceProvider	*pSP;
88a111,114
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
> //	pSP = NULL;
> 
92,93c118,123
< 	hResultCode = packedBuffer.AddToBack(wszSP,(wcslen(wszSP)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,TRUE,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
95,96c125,152
< 	hResultCode = packedBuffer.AddToBack(&guidSP,sizeof(GUID));
< 	dnSpInfo.pGuid = static_cast<GUID*>(packedBuffer.GetTailAddress());
---
> 	//
> 	//	Set up to enumerate
> 	//
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(5,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
98,99c154,167
< 	dnSpInfo.dwFlags = 0;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	//
> 	//	Enumerate SP's !
> 	//
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(5,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,TRUE,FALSE))
> 		{
> 			DPF(0,"Couldn't open subentry.  Skipping [%S]", pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
100a169,260
> 		//
> 		//	GUID
> 		//
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPF(0,"SubEntry.ReadGUID failed.  Skipping [%S]", pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		//
> 		//	Attempt to instantiate SP and initialize it, to ensure that it is in fact usable.
> 		//
> 		if (!(dwFlags & DPNENUMSERVICEPROVIDERS_ALL))
> 		{
> 			hResultCode = DN_SPEnsureLoaded(pdnObject,&guid,NULL,TRUE);
> 			if (hResultCode != DPN_OK)
> 			{
> 				DPF(0,"Could not load SP.  Skipping [%S]", pwszKeyName);
> 				SubEntry.Close();
> 				dwEnumIndex++;
> 				dwKeyLen = dwMaxKeyLen;
> 				hResultCode = DPN_OK; // override return code
> 				continue;
> 			}
> 			else
> 			{
> //				DN_SPRelease(pdnObject,&guid);
> 			}
> 		}
> 
> 		//
> 		//	Friendly Name
> 		//
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(5,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		DPF(5,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
> 
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = static_cast<GUID*>(packedBuffer.GetTailAddress());
> 
> 		dnSpInfo.dwFlags = 0;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
> 	//
> 	//	Success ?
> 	//
106c266
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
108c268
< 		goto Exit;
---
> 		goto Failure;
112c272,273
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
> 		hResultCode = DPN_OK;
115,121d275
< 			hResultCode = DN_SPEnsureLoaded(pdnObject,&guidSP,NULL,TRUE);
< 			if (hResultCode != DPN_OK)
< 			{
< 				DPF(0,"Could not load SP.  Skipping [%S]", pwszKeyName);
< 				hResultCode = DPN_OK; // override return code
< 			}
< 
123a278,282
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
> 	DNFree(pwszFriendlyName);
> 	pwszFriendlyName = NULL;
> 
126a286,307
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
140,144d320
< // BUGBUG
< // [mgere] [xbox] Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
166c342
< 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,FALSE))
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,TRUE,FALSE))
195c371
< 		if (!SubEntry.Open(RegistryEntry,lpwszKeyName,FALSE))
---
> 		if (!SubEntry.Open(RegistryEntry,lpwszKeyName,TRUE,FALSE))
294d469
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\migration.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
74a75,77
> #include "dpnsvrq.h"
> #include "dpnsdef.h"
> #include "dpnsvlib.h"
75a79
> #include "dplobby8.h"
273a278
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_HOSTMIGRATEDHERE);	
676a682,701
> 	// Register with DPNSVR
> 	if( !(pdnObject->dnApplicationDescription.dwFlags & DPNSESSION_NODPNSVR) )
> 	{
> 		BOOL	fCoUninitialize = FALSE;
> 
> 		DPF( 7, "Asking for DPNSVR to start listening for us.." );
> 
> 		if (COM_CoInitialize(NULL) == S_OK)
> 		{
> 			fCoUninitialize = TRUE;
> 		}
> 
> 		DNRegisterWithDPNSVR(pdnObject);
> 
> 		if (fCoUninitialize)
> 		{
> 			COM_CoUninitialize();
> 		}
> 	}
> 
753a779,783
> 
> 	// 
> 	// Indicate to lobby (if there is one) that a host migration has occured
> 	//
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_HOSTMIGRATED);		
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\msghandler.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
43a44
> #include "DVoice.h"
64a66
> #include "Voice.h"
519c521,525
<                     // BUGBUG: [mgere] [xbox] Used to be Voice_Receive() but voice not supported on Xbox
---
> 			hResultCode = Voice_Receive(pdnObject,
> 										pConnection->GetDPNID(),
> 										0,
> 										pvData,
> 										dwDataSize);
1048c1054
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1064c1070
< 	pHostAddress->lpVtbl->GetURLW(pHostAddress,DP8ABuffer,&DP8ASize);
---
> 	pHostAddress->lpVtbl->GetURLA(pHostAddress,DP8ABuffer,&DP8ASize);
1068c1074
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
1099c1105
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1115c1121
< 	pHostAddress->lpVtbl->GetURLW(pHostAddress,DP8ABuffer,&DP8ASize);
---
> 	pHostAddress->lpVtbl->GetURLA(pHostAddress,DP8ABuffer,&DP8ASize);
1119c1125
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
1148c1154
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1164c1170
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\ntentry.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
399,400c399
< 		hResultCode = m_pAddress->lpVtbl->GetURLW(m_pAddress,NULL,&dwURLSize);
< 		dwURLSize = dwURLSize * sizeof(WCHAR);
---
> 		hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,NULL,&dwURLSize);
412,413c411,412
< 				if ((hResultCode = m_pAddress->lpVtbl->GetURLW(m_pAddress,
< 						static_cast<WCHAR*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
---
> 				if ((hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,
> 						static_cast<char*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
500c499
< 		hResultCode = pAddress->lpVtbl->BuildFromURLW(pAddress,reinterpret_cast<WCHAR*>(pBufferStart + pdnEntryInfo->dwURLOffset));
---
> 		hResultCode = pAddress->lpVtbl->BuildFromURLA(pAddress,reinterpret_cast<char*>(pBufferStart + pdnEntryInfo->dwURLOffset));
602d600
< }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
39a40
> #include "DVoice.h"
62a64
> #include "voice.h"
65a68
> extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;
182c185
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
190a194,200
>     if( pIDP8LobbiedApplication == NULL ||
>         !DNVALID_READPTR( pIDP8LobbiedApplication, sizeof( IDirectPlay8LobbiedApplication * ) ) )
>     {
>         DPFERR( "Invalid interface pointer specified for register lobby" );
>         return DPNERR_INVALIDPOINTER;
>     }
> 
950c960
<     if( dwFlags & ~(DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
---
>     if( dwFlags & ~(DPNENUMHOSTS_OKTOQUERYFORADDRESSING | DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
1669c1679
<     if( dwFlags & ~(DPNCONNECT_SYNC) )
---
>     if( dwFlags & ~(DPNCONNECT_SYNC | DPNCONNECT_OKTOQUERYFORADDRESSING) )
1985c1995
<     if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD) )
---
>     if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD | DPNSESSION_NODPNSVR) )
2234a2245
> 	   pIntList->lpVtbl != &DN_VoiceTbl &&
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
41c41
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\peer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
68d67
< #include <wchar.h>
119c118
< typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\server.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
61d60
< #include <wchar.h>
110c109
< typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2,3c17,27
< TARGETPATHLIB=$(BASEDIR)\public\sdk\lib
< TARGETTYPE=DYNLINK
---
> DLLDEF=..\dnet.def
> UMTYPE=windows
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
4a29
> TARGETTYPE=DYNLINK
6,14c31,35
< !ifdef _BUILD_FOR_WIN2000
< UMTYPE=windows
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
16c37
< INCLUDES=..\;..\..\inc;..\..\protocol;..\..\common
---
> PASS1_PUBLISH={ $(O)\dpnet.lib = $(SDK_LIB_PATH)\dpnet.lib}
18c39,56
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
> 	   ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
>            ..\..\protocol\obj$(BUILD_ALT_DIR)\*\protocol.lib \
>            ..\..\dpnsvr\dpnsvlib\obj$(BUILD_ALT_DIR)\*\dpnsvlib.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
20d57
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
22,23c59,60
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
26c63,67
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28c69
< DLLDEF=..\dnet.def
---
> INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\protocol;..\..\common;..\..\dpnsvr\dpnsvlib;..\..\dpnsvr\inc
29a71,78
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
61a111
>          ..\voice.cpp \
68a119,126
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
71,92c129,131
< TARGETLIBS= \
< 	   ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
<            ..\..\protocol\obj$(BUILD_ALT_DIR)\*\protocol.lib \
<            $(BASEDIR)\public\sdk\lib\*\dpnaddr.lib \
<            ..\..\sp\wsock\daytona\obj$(BUILD_ALT_DIR)\*\dpnwsock.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<              $(SDK_LIB_PATH)\libcntpr.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\user.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
43a44
> #include "DVoice.h"
53a55
> #include "voice.h"
198a201,202
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYER, dpnid, 0 );
> 
232a237,238
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYER, dpnid, 0 );
> 
265a272,273
> 	Voice_Notify( pdnObject, DVEVENT_CREATEGROUP, dpnid, 0 );
> 
300a309,310
> 	Voice_Notify( pdnObject, DVEVENT_DELETEGROUP, dpnid, 0 );
> 
335a346,347
> 	Voice_Notify( pdnObject, DVEVENT_ADDPLAYERTOGROUP, dpnidGroup, dpnidPlayer );
> 
371a384,385
> 	Voice_Notify( pdnObject, DVEVENT_REMOVEPLAYERFROMGROUP, dpnidGroup, dpnidPlayer );
> 
639a654,655
> 
> 	Voice_Notify( pdnObject, DVEVENT_MIGRATEHOST, dpnidNewHost, 0 );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\worker.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
44a45
> #include "DVoice.h"
65a67
> #include "Voice.h"
586c588,592
<                     // BUGBUG: [mgere] [xbox] Removed Voice_Receive()
---
> 			hResultCode = Voice_Receive(pdnObject,
> 										pConnection->GetDPNID(),
> 										0,
> 										pvData,
> 										dwDataSize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addbase.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
260d259
< /* BUGBUG: [mgere] [xbox] Removed this function.
291d289
< */  return DPNERR_UNSUPPORTED;
302,303c300,359
< // BUGBUG: [mgere] [xbox] ANSI not supported
< 	return DPNERR_UNSUPPORTED;
---
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pszAddress == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer to address.  An address must be specified" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( !DNVALID_STRING_A( pszAddress ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid string specified for address" );
> 		DP8A_RETURN( DPNERR_INVALIDSTRING );
> 	}
> 
> 	DPF( DP8A_PARAMLEVEL, "pszAddress = %s", pszAddress );
> 
> 	WCHAR *szShadowBuffer = NULL;
> 
> 	DWORD dwStrSize = 0;
> 
> 	if( pszAddress != NULL )
> 	{
> 		dwStrSize = strlen(pszAddress)+1;
> 		
> 		szShadowBuffer = new WCHAR[dwStrSize];
> 
> 		if( szShadowBuffer == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto BUILDFROMURLW_RETURN;
> 		}
> 
> 		if( FAILED( hr = STR_jkAnsiToWide( szShadowBuffer, pszAddress, dwStrSize ) )  )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting URL to ANSI hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 			goto BUILDFROMURLW_RETURN;
> 		}
> 	}
> 
> 	hr = pdp8Address->SetURL( szShadowBuffer );
> 
> BUILDFROMURLW_RETURN:
> 
> 	if( szShadowBuffer )
> 		delete [] szShadowBuffer;
> 
> 	DP8A_RETURN( hr );	
448,449c504,571
< // BUGBUG: [mgere] [xbox] ANSI not supported.
< 	return DPNERR_UNSUPPORTED;
---
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pdwAddressSize == NULL ||
> 	   !DNVALID_WRITEPTR( pdwAddressSize, sizeof(DWORD) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for address size" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
> 	}
> 
> 	if( *pdwAddressSize > 0 &&
> 	   (pszAddress == NULL ||
> 	    !DNVALID_WRITEPTR( pszAddress, (*pdwAddressSize) ) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for address" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
> 	DPF( DP8A_PARAMLEVEL, "pwszAddress = 0x%p pdwAddressSize = 0x%p (%u)",
> 	     pszAddress , pdwAddressSize, *pdwAddressSize );
> 
> 	WCHAR *szShadowBuffer = NULL;
> 
> 	if( *pdwAddressSize  != 0 )
> 	{
> 		szShadowBuffer = new WCHAR[*pdwAddressSize];
> 
> 		if( szShadowBuffer == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto GETURLW_RETURN;
> 		}
> 	}
> 	else
> 	{	
> 		szShadowBuffer= NULL;
> 	}
> 
> 	hr = pdp8Address->BuildURL( szShadowBuffer, pdwAddressSize );
> 
> 	if( hr == DPN_OK )
> 	{
> 		if( FAILED( hr = STR_jkWideToAnsi( pszAddress, szShadowBuffer, *pdwAddressSize ) ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting ANSI->WIDE hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 			goto GETURLW_RETURN;
> 		}
> 	}
> 	
> GETURLW_RETURN:
> 
> 	if( szShadowBuffer != NULL )
> 		delete [] szShadowBuffer;
> 
> 	DP8A_RETURN( hr );
873c995,996
< 	   dwDataType != DPNA_DATATYPE_BINARY )
---
> 	   dwDataType != DPNA_DATATYPE_BINARY &&
> 	   dwDataType != DPNA_DATATYPE_STRING_ANSI )
887a1011,1024
> 		{
> 			DPF( DP8A_ERRORLEVEL, "String size and component size don't match" );
> 			DP8A_RETURN( DPNERR_INVALIDPARAM );
> 		}
> 	}
> 	else if( dwDataType == DPNA_DATATYPE_STRING_ANSI )
> 	{
> 		if( !DNVALID_STRING_A( (const CHAR * const) pComponentData ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Invalid string component specified" );
> 			DP8A_RETURN( DPNERR_INVALIDSTRING );
> 		}
> 
> 		if( ((strlen( (const CHAR * const) pComponentData)+1)*sizeof(char)) != dwComponentSize )
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
47a48
> #include <stdio.h>
48a50
> #include "dplegacy.h"
50d51
< #include <wchar.h>
398a400,418
> 	case DPNA_DATATYPE_STRING_ANSI:
>         wszUnicodeString = new WCHAR[dwRealDataSize];
>         if( wszUnicodeString == NULL )
>         {
>             DPF( 0, "Error allocating memory for conversion" );
>             return DPNERR_OUTOFMEMORY;
>         }
> 
> 		hr = STR_jkAnsiToWide( wszUnicodeString, (const char * const) pvData, dwRealDataSize );
> 
> 		if( FAILED( hr ) )
> 		{
> 		    DPF( 0, "Error unable to convert element ANSI->Unicode 0x%x", hr );
>             return DPNERR_CONVERSION;
> 		}
> 		pvRealData = wszUnicodeString;
> 	    dwRealDataSize = dwDataSize*sizeof(WCHAR);
> 		dwRealDataType = DPNA_DATATYPE_STRING;
> 	    break;
422a443,454
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     hr= SetSP( &CLSID_DP8SP_IPX );
>                 }
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_MODEMPROVIDER ) == 0 )
>                 {
>                     hr = SetSP( &CLSID_DP8SP_MODEM );
>                 }
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_SERIALPROVIDER ) == 0 )
>                 {
>                     hr = SetSP( &CLSID_DP8SP_SERIAL );
>                 }
1369a1402,1470
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ADDRESSOBJECT::SetDirectPlay4Address"
> HRESULT DP8ADDRESSOBJECT::SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize )
> {
>     PBYTE pbCurrentLocation;
>     PDPADDRESS pdpAddressChunk;
>     LONG lRemaining;
>     HRESULT hr = DPN_OK;
>     DWORD dwCurrentChunkSize;
>     DWORD dwNumElementsParsed = 0;
> 
> 	if( IsLocked() )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
> 		return DPNERR_NOTALLOWED;
> 	}
> 
>     // XBOX! This function will not be required on XBOX.  Have it return DPNERR_NOTSUPPORTED
>     ENTERLOCK();
> 
>     hr = Clear();
> 
>     if( FAILED( hr ) )
>     {
>         DPF( 0, "Failed to clear old address data hr=[0x%lx]", hr );
>         LEAVELOCK();
>         return hr;
>     }
> 
>     pbCurrentLocation = (PBYTE) pvDataBuffer;
>     lRemaining = dwDataSize;
> 
>     while( lRemaining > 0 )
>     {
>         pdpAddressChunk = (PDPADDRESS) pbCurrentLocation;
> 
>         if( sizeof( DPADDRESS ) > lRemaining )
>         {
>             DPF( 0, "Error parsing address, unexpected end of address" );
> 			LEAVELOCK();
>             return DPNERR_INVALIDADDRESSFORMAT;
>         }
> 
>         dwCurrentChunkSize = sizeof( DPADDRESS ) + pdpAddressChunk->dwDataSize;
> 
>         if( ((LONG) dwCurrentChunkSize) > lRemaining )
>         {
>             DPF( 0, "Error parsing address, unexpected end during data" );
> 			LEAVELOCK();
>             return DPNERR_INVALIDADDRESSFORMAT;
>         }
> 
>         hr = AddDP4Element( pdpAddressChunk, this );
> 
>         if( FAILED( hr ) )
>         {
>             DPF( 0, "Error adding next element" );
>             break;
>         }
> 
>         lRemaining -= dwCurrentChunkSize;
> 
>         pbCurrentLocation += dwCurrentChunkSize;
>     }
> 
>     LEAVELOCK();
> 
>     return hr;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
140a141,142
>     HRESULT SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addparse.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
27c27
< #include <wchar.h>
---
> #include <stdio.h>
569d568
< // BUGBUG: [mgere] [xbox] Removed wtol temporarily until it is implemented on xbox
571d569
< #ifdef _BUILD_FOR_WIN2000
573d570
< #endif
581,582d577
< // BUGBUG: [mgere] [xbox] Removed swscanf temporarily until it is implemented on xbox
< #ifdef _BUILD_FOR_WIN2000
607d601
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
34c34
< //#include "dvoice.h"
---
> #include "dvoice.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
24a25,31
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DPNAddress"
> 
> /*
31a39,67
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNAddress"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNAddress"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dllmain.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
29a30
> #include "creg.h"
38a40,87
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8Address.Address.1", L"DirectPlay8Address Object", 
> 							  L"dpnaddr.dll", CLSID_DirectPlay8Address, L"DirectPlay8Address.Address") )
> 	{
> 		DPFERR( "Could not register address object" );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Address) )
> 	{
> 		DPF( 0, "Failed to unregister server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
5a6,8
> 	DirectPlay8AddressCreate	@1
> 	DllRegisterServer	PRIVATE
> 	DllUnregisterServer PRIVATE
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnaddr.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address \0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,61
> 
> #endif
> 
> #endif    // !_MAC
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2,3c17,27
< TARGETPATHLIB=$(BASEDIR)\public\sdk\lib
< TARGETTYPE=DYNLINK
---
> DLLDEF=..\dnadd.def
> UMTYPE=windows
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
4a29
> TARGETTYPE=DYNLINK
6,14c31,35
< !ifdef _BUILD_FOR_WIN2000
< UMTYPE=windows
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
16c37
< INCLUDES=..\;..\..\inc;..\..\common
---
> PASS1_PUBLISH={ $(O)\dpnaddr.lib = $(SDK_LIB_PATH)\dpnaddr.lib}
18c39,54
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
>            ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\wsock32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
20d55
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
22,23c57,58
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
26c61,65
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28c67
< DLLDEF=..\dnadd.def
---
> INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\common
29a69,76
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
38a86
>          ..\dplegacy.cpp \
40a89,95
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
> 
> USER_C_FLAGS=-nologo -W3
43,62c98,100
< TARGETLIBS= \
<            ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\winsockx.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
63a64,75
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
> // {826F86D1-AE2C-4428-A66F-974381B25F5B}
> DEFINE_GUID(IID_IDirectPlay8AddressModem,
> 0x826f86d1, 0xae2c, 0x4428, 0xa6, 0x6f, 0x97, 0x43, 0x81, 0xb2, 0x5f, 0x5b);
> 
> // {59BE79FE-A96A-4710-9BD2-22A50E7B24BD}
> DEFINE_GUID(IID_IDirectPlay8AddressSerial,
> 0x59be79fe, 0xa96a, 0x4710, 0x9b, 0xd2, 0x22, 0xa5, 0xe, 0x7b, 0x24, 0xbd);
> 
71a84,86
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
> typedef struct IDirectPlay8AddressSerial  	*PDIRECTPLAY8ADDRESSSERIAL, *LPDIRECTPLAY8ADDRESSSERIAL;
> typedef struct IDirectPlay8AddressModem		*PDIRECTPLAY8ADDRESSMODEM, *LPDIRECTPLAY8ADDRESSMODEM;
87a103
> #define DPNA_DATATYPE_STRING_ANSI           0x00000005
348a365,417
> // values for baud rate
> #define DPNA_BAUD_RATE_110					110
> #define DPNA_BAUD_RATE_300					300
> #define DPNA_BAUD_RATE_600					600
> #define DPNA_BAUD_RATE_1200					1200
> #define DPNA_BAUD_RATE_2400					2400
> #define DPNA_BAUD_RATE_4800					4800
> #define DPNA_BAUD_RATE_9600					9600
> #define DPNA_BAUD_RATE_14400				14400
> #define DPNA_BAUD_RATE_19200				19200
> #define DPNA_BAUD_RATE_38400				38400
> #define DPNA_BAUD_RATE_56000				56000
> #define DPNA_BAUD_RATE_57600				57600
> #define DPNA_BAUD_RATE_115200				115200
> #define DPNA_BAUD_RATE_128000				128000
> #define DPNA_BAUD_RATE_256000				256000
> 
> //// values for baud rate
> //#define DPNA_BAUD_RATE_110					L"110"
> //#define DPNA_BAUD_RATE_300					L"300"
> //#define DPNA_BAUD_RATE_600					L"600"
> //#define DPNA_BAUD_RATE_1200					L"1200"
> //#define DPNA_BAUD_RATE_2400					L"2400"
> //#define DPNA_BAUD_RATE_4800					L"4800"
> //#define DPNA_BAUD_RATE_9600					L"9600"
> //#define DPNA_BAUD_RATE_14400				L"14400"
> //#define DPNA_BAUD_RATE_19200				L"19200"
> //#define DPNA_BAUD_RATE_38400				L"38400"
> //#define DPNA_BAUD_RATE_56000				L"56000"
> //#define DPNA_BAUD_RATE_57600				L"57600"
> //#define DPNA_BAUD_RATE_115200				L"115200"
> //#define DPNA_BAUD_RATE_128000				L"128000"
> //#define DPNA_BAUD_RATE_256000				L"256000"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE					L"1"
> #define DPNA_STOP_BITS_ONE_FIVE				L"1.5"
> #define DPNA_STOP_BITS_TWO					L"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE					L"NONE"
> #define DPNA_PARITY_EVEN					L"EVEN"
> #define DPNA_PARITY_ODD						L"ODD"
> #define DPNA_PARITY_MARK					L"MARK"
> #define DPNA_PARITY_SPACE					L"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE				L"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF			L"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS				L"RTS"
> #define DPNA_FLOW_CONTROL_DTR				L"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR			L"RTSDTR"
> 
350a420,422
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
352a425,487
> //// ANSI DEFINITIONS
> 
> // Header
> #define DPNA_HEADER_A						"x-directplay:/"
> #define DPNA_SEPARATOR_KEYVALUE_A			'='
> #define DPNA_SEPARATOR_USERDATA_A			'#'
> #define DPNA_SEPARATOR_COMPONENT_A			';'
> #define DPNA_ESCAPECHAR_A					'%'
> 
> // key names for address components
> #define DPNA_KEY_APPLICATION_INSTANCE_A		"applicationinstance"
> #define DPNA_KEY_BAUD_A						"baud"
> #define DPNA_KEY_DEVICE_A					"device"
> #define DPNA_KEY_FLOWCONTROL_A				"flowcontrol"
> #define DPNA_KEY_HOSTNAME_A					"hostname"
> #define DPNA_KEY_PARITY_A					"parity"
> #define DPNA_KEY_PHONENUMBER_A				"phonenumber"
> #define DPNA_KEY_PORT_A						"port"
> #define DPNA_KEY_PROGRAM_A					"program"
> #define DPNA_KEY_PROVIDER_A					"provider"
> #define DPNA_KEY_STOPBITS_A					"stopbits"
> 
> //// values for baud rate
> //#define DPNA_BAUD_RATE_110_A				"110"
> //#define DPNA_BAUD_RATE_300_A				"300"
> //#define DPNA_BAUD_RATE_600_A				"600"
> //#define DPNA_BAUD_RATE_1200_A				"1200"
> //#define DPNA_BAUD_RATE_2400_A				"2400"
> //#define DPNA_BAUD_RATE_4800_A				"4800"
> //#define DPNA_BAUD_RATE_9600_A				"9600"
> //#define DPNA_BAUD_RATE_14400_A				"14400"
> //#define DPNA_BAUD_RATE_19200_A				"19200"
> //#define DPNA_BAUD_RATE_38400_A				"38400"
> //#define DPNA_BAUD_RATE_56000_A				"56000"
> //#define DPNA_BAUD_RATE_57600_A				"57600"
> //#define DPNA_BAUD_RATE_115200_A				"115200"
> //#define DPNA_BAUD_RATE_128000_A				"128000"
> //#define DPNA_BAUD_RATE_256000_A				"256000"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE_A				"1"
> #define DPNA_STOP_BITS_ONE_FIVE_A			"1.5"
> #define DPNA_STOP_BITS_TWO_A				"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE_A					"NONE"
> #define DPNA_PARITY_EVEN_A					"EVEN"
> #define DPNA_PARITY_ODD_A					"ODD"
> #define DPNA_PARITY_MARK_A					"MARK"
> #define DPNA_PARITY_SPACE_A					"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE_A			"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF_A 		"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS_A				"RTS"
> #define DPNA_FLOW_CONTROL_DTR_A				"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR_A			"RTSDTR"
> 
> // Shortcut values
> #define DPNA_VALUE_TCPIPPROVIDER_A          "IP"
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
> #define DPNA_VALUE_MODEMPROVIDER_A          "MODEM"
> #define DPNA_VALUE_SERIALPROVIDER_A         "SERIAL"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
120,121d119
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
162a161,169
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {6D4A3650-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_MODEM, 0x6d4a3650, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {743B5D60-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_SERIAL, 0x743b5d60, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
186a194,196
> typedef struct IDirectPlay8LobbiedApplication	*PDNLOBBIEDAPPLICATION;
> typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
> 
698a709
> #define	DPNCONNECT_OKTOQUERYFORADDRESSING	0x0001
703a715
> #define	DPNENUMHOSTS_OKTOQUERYFORADDRESSING	0x0001
812a825
> #define DPNSESSION_NODPNSVR					0x0040
893c906
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
938c951
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
988c1001
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpsp8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
56a57
> #define DPNSPF_OKTOQUERY			0x00000002		// OK for SP to ask the user for clarification on addresses
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
105c105
< 	DNASSERT( ulFlags == 0 );
---
> 	DNASSERT( ( ulFlags & ~( DPNCONNECT_OKTOQUERYFORADDRESSING ) ) == 0 );
106a107,111
> 	if ( ( ulFlags & DPNCONNECT_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		ConnData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\enum.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
117a118,122
> 	if ( ( dwFlags & DPNENUMHOSTS_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		EnumData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\initialize.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
351c351
< 		if((pSPD->hSendEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL){
---
> 		if((pSPD->hSendEvent = CreateEventA(NULL, FALSE, FALSE, NULL)) == NULL){
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2c17,26
< TARGETTYPE=LIBRARY
---
> 
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
3a28
> TARGETTYPE=LIBRARY
5,9d29
< !ifdef _BUILD_FOR_WIN2000
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< LINKER_FLAGS=-align:32
< !endif
11c31,35
< INCLUDES=..\common;..\inc;..\dnaddress
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
13c37,41
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE -DMICHAEL
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS)
15d42
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
17,18c44,55
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> 
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
> 
> INCLUDES=$(DXROOT)\inc;..\common;..\inc;..\dnaddress
> 
> 
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
21c58,63
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
34c76,78
< USE_NOLIBS=1
---
> #
> # Next specify options for the compiler.
> #
36c80,86
< TARGETLIBS=
---
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE /DMICHAEL
> MSC_OPTIMIZATION=/Odi /Zi
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\timer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
576c576
< 	hWorkToDoSem=CreateSemaphore(NULL,0,65535,NULL);
---
> 	hWorkToDoSem=CreateSemaphoreA(NULL,0,65535,NULL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
198,199c198,228
< // BUGBUG: [mgere] [xbox]  Removed all code in here.  I don't believe it's necessary anymore and it was using some COM functions that we don't have.
< 	return S_OK;
---
>     HRESULT		hr;
>     HINSTANCE	hdll;
>     LPGPCLASSFACTORY	pcf;
> 
> 
>     pcf = (LPGPCLASSFACTORY) This;
> 
>     /*
>      * call CoLockObjectExternal
>      */
>     hr = E_UNEXPECTED;
>     hdll = LoadLibraryA( "OLE32.DLL" );
>     if( hdll != NULL )
>     {
>         PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;
> 
> 
> 		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, "CoLockObjectExternal" ) );
>         if( lpCoLockObjectExternal != NULL )
>         {
>             hr = lpCoLockObjectExternal( (LPUNKNOWN) This, fLock, TRUE );
>         }
>         else
>         {
>         }
>     }
>     else
>     {
>     }
> 
> 	return hr;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
30a38,66
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNSPWinsock"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectDPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNSPWinsock"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
120a122,141
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( dwDebugLevel, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
> 					);
> 			break;
> 		}
> 
144,145d164
< // BUGBUG: [mgere] [xbox] Must convert this to unicode
< /*
193d211
< */
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> #include "resource.h"
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #include "windows.h"
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnwsock.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,153
> 
> #endif
> 
> #endif    // !_MAC
> 
> 
> 
> #ifdef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // TEXTINCLUDE
> //
> 
> 1 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "resource.h\0"
> END
> 
> 2 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "#include ""afxres.h""\r\n"
>     "\0"
> END
> 
> 3 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "\r\n"
>     "\0"
> END
> 
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // Dialog
> //
> 
> IDD_IP_SETTINGS DIALOG DISCARDABLE  0, 0, 194, 66
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION | 
>     WS_SYSMENU
> CAPTION "Enter host name"
> FONT 8, "MS Shell Dlg"
> BEGIN
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
> END
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // DESIGNINFO
> //
> 
> #ifdef APSTUDIO_INVOKED
> GUIDELINES DESIGNINFO DISCARDABLE 
> BEGIN
>     IDD_IP_SETTINGS, DIALOG
>     BEGIN
>         LEFTMARGIN, 7
>         RIGHTMARGIN, 187
>         TOPMARGIN, 7
>         BOTTOMMARGIN, 59
>     END
> END
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // String Table
> //
> 
> STRINGTABLE DISCARDABLE 
> BEGIN
>     IDS_FRIENDLYNAME_IPX    "DirectPlay8 IPX Service Provider"
>     IDS_FRIENDLYNAME_TCPIP  "DirectPlay8 TCP/IP Service Provider"
> END
> 
> #endif    // English (U.S.) resources
> /////////////////////////////////////////////////////////////////////////////
> 
> 
> 
> #ifndef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 3 resource.
> //
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> #endif    // not APSTUDIO_INVOKED
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock1.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,42c1,67
< #define p_accept accept
< #define p_bind bind
< #define p_closesocket closesocket
< #define p_connect connect
< #define p_gethostbyaddr gethostbyaddr
< #define p_gethostbyname gethostbyname
< #define p_gethostname gethostname
< #define p_getpeername getpeername
< #define p_getprotobyname getprotobyname
< #define p_getprotobynumber getprotobynumber
< #define p_getservbyname getservbyname
< #define p_getservbyport getservbyport
< #define p_getsockname getsockname
< #define p_getsockopt getsockopt
< #define p_htonl htonl
< #define p_htons htons
< #define p_inet_addr inet_addr
< #define p_inet_ntoa inet_ntoa
< #define p_ioctlsocket ioctlsocket
< #define p_listen listen
< #define p_ntohl ntohl
< #define p_ntohs ntohs
< #define p_recv recv
< #define p_recvfrom recvfrom
< #define p_select select
< #define p_send send
< #define p_sendto sendto
< #define p_setsockopt setsockopt
< #define p_shutdown shutdown
< #define p_socket socket
< //#define p_WSAAsyncGetHostByAddr WSAAsyncGetHostByAddr
< //#define p_WSAAsyncGetHostByName WSAAsyncGetHostByName
< //#define p_WSAAsyncGetProtoByName WSAAsyncGetProtoByName
< //#define p_WSAAsyncGetProtoByNumber WSAAsyncGetProtoByNumber
< //#define p_WSAAsyncGetServByName WSAAsyncGetServByName
< //#define p_WSAAsyncGetServByPort WSAAsyncGetServByPort
< //#define p_WSAAsyncSelect WSAAsyncSelect
< //#define p_WSACancelAsyncRequest WSACancelAsyncRequest
< #define p_WSACleanup WSACleanup
< #define p_WSAGetLastError WSAGetLastError
< #define p_WSASetLastError WSASetLastError
< #define p_WSAStartup WSAStartup
---
> //
> // DWNSOCK1.INC	Macros for dynamically linking to WinSock 1.1
> //
> 
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	//
> 	// Function available in both versions
> 	//
> 	DYNAMICWINSOCK(accept, LPFN_ACCEPT);
> 	DYNAMICWINSOCK(bind, LPFN_BIND);
> 	DYNAMICWINSOCK(closesocket, LPFN_CLOSESOCKET);
> 	DYNAMICWINSOCK(connect, LPFN_CONNECT);
> 	DYNAMICWINSOCK(gethostbyaddr, LPFN_GETHOSTBYADDR);
> 	DYNAMICWINSOCK(gethostbyname, LPFN_GETHOSTBYNAME);
> 	DYNAMICWINSOCK(gethostname, LPFN_GETHOSTNAME);
> 	DYNAMICWINSOCK(getpeername, LPFN_GETPEERNAME);
> 	DYNAMICWINSOCK(getprotobyname, LPFN_GETPROTOBYNAME);
> 	DYNAMICWINSOCK(getprotobynumber, LPFN_GETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(getservbyname, LPFN_GETSERVBYNAME);
> 	DYNAMICWINSOCK(getservbyport, LPFN_GETSERVBYPORT);
> 	DYNAMICWINSOCK(getsockname, LPFN_GETSOCKNAME);
> 	DYNAMICWINSOCK(getsockopt, LPFN_GETSOCKOPT);
> 	DYNAMICWINSOCK(htonl, LPFN_HTONL);
> 	DYNAMICWINSOCK(htons, LPFN_HTONS);
> 	DYNAMICWINSOCK(inet_addr, LPFN_INET_ADDR);
> 	DYNAMICWINSOCK(inet_ntoa, LPFN_INET_NTOA);
> 	DYNAMICWINSOCK(ioctlsocket, LPFN_IOCTLSOCKET);
> 	DYNAMICWINSOCK(listen, LPFN_LISTEN);
> 	DYNAMICWINSOCK(ntohl, LPFN_NTOHL);
> 	DYNAMICWINSOCK(ntohs, LPFN_NTOHS);
> 	DYNAMICWINSOCK(recv, LPFN_RECV);
> 	DYNAMICWINSOCK(recvfrom, LPFN_RECVFROM);
> 	DYNAMICWINSOCK(select, LPFN_SELECT);
> 	DYNAMICWINSOCK(send, LPFN_SEND);
> 	DYNAMICWINSOCK(sendto, LPFN_SENDTO);
> 	DYNAMICWINSOCK(setsockopt, LPFN_SETSOCKOPT);
> 	DYNAMICWINSOCK(shutdown, LPFN_SHUTDOWN);
> 	DYNAMICWINSOCK(socket, LPFN_SOCKET);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByAddr, LPFN_WSAASYNCGETHOSTBYADDR);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByName, LPFN_WSAASYNCGETHOSTBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByName, LPFN_WSAASYNCGETPROTOBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByNumber, LPFN_WSAASYNCGETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(WSAAsyncGetServByName, LPFN_WSAASYNCGETSERVBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetServByPort, LPFN_WSAASYNCGETSERVBYPORT);
> 	DYNAMICWINSOCK(WSAAsyncSelect, LPFN_WSAASYNCSELECT);
> 	DYNAMICWINSOCK(WSACancelAsyncRequest, LPFN_WSACANCELASYNCREQUEST);
> 	DYNAMICWINSOCK(WSACleanup, LPFN_WSACLEANUP);
> 	DYNAMICWINSOCK(WSAGetLastError, LPFN_WSAGETLASTERROR);
> 	DYNAMICWINSOCK(WSASetLastError, LPFN_WSASETLASTERROR);
> 	DYNAMICWINSOCK(WSAStartup, LPFN_WSASTARTUP);
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock2.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,27c1,3
< #ifdef UNICODE
< //	#define p_WSAAddressToString				WSAAddressToStringW
< //	#define p_WSADuplicateSocket				WSADuplicateSocketW
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersW
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsW
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoW
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdW
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassW
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginW
< //	#define p_WSALookupServiceNext				WSALookupServiceNextW
< //	#define p_WSASetService						WSASetServiceW
< //	#define p_WSASocket							WSASocketW
< //	#define p_WSAStringToAddress				WSAStringToAddressW
< #else
< //	#define p_WSAAddressToString				WSAAddressToStringA
< //	#define p_WSADuplicateSocket				WSADuplicateSocketA
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersA
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsA
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoA
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdA
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassA
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginA
< //	#define p_WSALookupServiceNext				WSALookupServiceNextA
< //	#define p_WSASetService						WSASetServiceA
< //	#define p_WSASocket							WSASocketA
< //	#define p_WSAStringToAddress				WSAStringToAddressA
< #endif // UNICODE
---
> //
> // DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
> //
29,53c5,70
< //#define p_WSAAccept WSAAccept
< #define p_WSACloseEvent WSACloseEvent
< //#define p_WSAConnect WSAConnect
< #define p_WSACreateEvent WSACreateEvent
< #define p_WSAEnumNetworkEvents WSAEnumNetworkEvents
< #define p_WSAEventSelect WSAEventSelect
< #define p_WSAGetOverlappedResult WSAGetOverlappedResult
< //#define p_WSAGetQOSByName WSAGetQOSByName
< //#define p_WSAHtonl WSAHtonl
< //#define p_WSAHtons WSAHtons
< #define p_WSAIoctl WSAIoctl
< //#define p_WSAJoinLeaf WSAJoinLeaf
< //#define p_WSALookupServiceEnd WSALookupServiceEnd
< //#define p_WSANtohl WSANtohl
< //#define p_WSANtohs WSANtohs
< #define p_WSARecv WSARecv
< //#define p_WSARecvDisconnect WSARecvDisconnect
< #define p_WSARecvFrom WSARecvFrom
< //#define p_WSARemoveServiceClass WSARemoveServiceClass
< #define p_WSAResetEvent WSAResetEvent
< #define p_WSASend WSASend
< //#define p_WSASendDisconnect WSASendDisconnect
< #define p_WSASendTo WSASendTo
< #define p_WSASetEvent WSASetEvent
< #define p_WSAWaitForMultipleEvents WSAWaitForMultipleEvents
---
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	DYNAMICWINSOCK(WSAAccept, LPFN_WSAACCEPT);
> 	DYNAMICWINSOCK(WSAAddressToStringA, LPFN_WSAADDRESSTOSTRINGA);
> 	DYNAMICWINSOCK(WSAAddressToStringW, LPFN_WSAADDRESSTOSTRINGW);
> 	DYNAMICWINSOCK(WSACloseEvent, LPFN_WSACLOSEEVENT);
> 	DYNAMICWINSOCK(WSAConnect, LPFN_WSACONNECT);
> 	DYNAMICWINSOCK(WSACreateEvent, LPFN_WSACREATEEVENT);
> 	DYNAMICWINSOCK(WSADuplicateSocketA, LPFN_WSADUPLICATESOCKETA);
> 	DYNAMICWINSOCK(WSADuplicateSocketW, LPFN_WSADUPLICATESOCKETW);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersA, LPFN_WSAENUMNAMESPACEPROVIDERSA);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersW, LPFN_WSAENUMNAMESPACEPROVIDERSW);
> 	DYNAMICWINSOCK(WSAEnumNetworkEvents, LPFN_WSAENUMNETWORKEVENTS);
> 	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
> 	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
> 	DYNAMICWINSOCK(WSAEventSelect, LPFN_WSAEVENTSELECT);
> 	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
> 	DYNAMICWINSOCK(WSAGetQOSByName, LPFN_WSAGETQOSBYNAME);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoA, LPFN_WSAGETSERVICECLASSINFOA);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoW, LPFN_WSAGETSERVICECLASSINFOW);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdA, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdW, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW);
> 	DYNAMICWINSOCK(WSAHtonl, LPFN_WSAHTONL);
> 	DYNAMICWINSOCK(WSAHtons, LPFN_WSAHTONS);
> 	DYNAMICWINSOCK(WSAInstallServiceClassA, LPFN_WSAINSTALLSERVICECLASSA);
> 	DYNAMICWINSOCK(WSAInstallServiceClassW, LPFN_WSAINSTALLSERVICECLASSW);
> 	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
> 	DYNAMICWINSOCK(WSAJoinLeaf, LPFN_WSAJOINLEAF);
> 	DYNAMICWINSOCK(WSALookupServiceBeginA, LPFN_WSALOOKUPSERVICEBEGINA);
> 	DYNAMICWINSOCK(WSALookupServiceBeginW, LPFN_WSALOOKUPSERVICEBEGINW);
> 	DYNAMICWINSOCK(WSALookupServiceEnd, LPFN_WSALOOKUPSERVICEEND);
> 	DYNAMICWINSOCK(WSALookupServiceNextA, LPFN_WSALOOKUPSERVICENEXTA);
> 	DYNAMICWINSOCK(WSALookupServiceNextW, LPFN_WSALOOKUPSERVICENEXTW);
> 	DYNAMICWINSOCK(WSANtohl, LPFN_WSANTOHL);
> 	DYNAMICWINSOCK(WSANtohs, LPFN_WSANTOHS);
> 	DYNAMICWINSOCK(WSARecv, LPFN_WSARECV);
> 	DYNAMICWINSOCK(WSARecvDisconnect, LPFN_WSARECVDISCONNECT);
> 	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
> 	DYNAMICWINSOCK(WSARemoveServiceClass, LPFN_WSAREMOVESERVICECLASS);
> 	DYNAMICWINSOCK(WSAResetEvent, LPFN_WSARESETEVENT);
> 	DYNAMICWINSOCK(WSASend, LPFN_WSASEND);
> 	DYNAMICWINSOCK(WSASendDisconnect, LPFN_WSASENDDISCONNECT);
> 	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
> 	DYNAMICWINSOCK(WSASetEvent, LPFN_WSASETEVENT);
> 	DYNAMICWINSOCK(WSASetServiceA, LPFN_WSASETSERVICEA);
> 	DYNAMICWINSOCK(WSASetServiceW, LPFN_WSASETSERVICEW);
> 	DYNAMICWINSOCK(WSASocketA, LPFN_WSASOCKETA);
> 	DYNAMICWINSOCK(WSASocketW, LPFN_WSASOCKETW);
> 	DYNAMICWINSOCK(WSAStringToAddressA, LPFN_WSASTRINGTOADDRESSA);
> 	DYNAMICWINSOCK(WSAStringToAddressW, LPFN_WSASTRINGTOADDRESSW);
> 	DYNAMICWINSOCK(WSAWaitForMultipleEvents, LPFN_WSAWAITFORMULTIPLEEVENTS);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
102a104
> 	m_hActiveSettingsDialog( NULL ),
129a132
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
362a366,373
> 		//
> 		// cancel any active dialogs
> 		// if there are no dialogs, cancel the active command
> 		//
> 		if ( m_hActiveSettingsDialog != NULL )
> 		{
> 			StopSettingsDialog( m_hActiveSettingsDialog );
> 		}
365a377,383
> 	else
> 	{
> 		//
> 		// there should be no active dialog if there isn't an active command
> 		//
> 		DNASSERT( m_hActiveSettingsDialog == NULL );
> 	}
847a866,872
> 	if ( m_hActiveSettingsDialog != NULL )
> 	{
> 		StopSettingsDialog( m_hActiveSettingsDialog );
> 		Unlock();
> 	}
> 	else
> 	{
853a879
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
290a291,297
> 		// UI functions
> 		//
> 		virtual	HRESULT	ShowSettingsDialog( CThreadPool *const pThreadPool ) = 0;
> 		virtual	void	StopSettingsDialog( const HWND hDlg ) = 0;
> 		virtual	void	SettingsDialogComplete( const HRESULT hr ) = 0;
> 
> 		//
309a317,318
> 
> 		HWND			m_hActiveSettingsDialog;		// handle of active settings dialog
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
44a46
> #include	"IPXAddress.h"
81c83,84
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
99a103,104
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
114a120
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
188a195,200
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
209a222,228
> 	switch ( OSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
213a233,255
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
238a281,282
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
271a316,317
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
302a349,354
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
444a497,503
> 	switch ( OSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
447a507,530
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
479a563,564
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
500a586,587
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
87a88,90
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
117a121
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
118a123
> 
148a154
> 		INT		m_Win9xReceiveWSAReturn;		
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
84a86
> const DWORD	g_dwIPBroadcastAddressSize = sizeof( g_IPBroadcastAddress );
978,980d979
< // BUGBUG: [mgere] [xbox] No need to enum adapters anymore since we only have one.
< // need to complete the removal of this functionality at a later date.
< /*
1300d1298
< */	return DPNERR_UNSUPPORTED;
1480a1479,1484
> 	//
> 	// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1481a1486,1504
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1484a1508,1510
> 		case 2:
> 		default:
> 		{
1485a1512,1514
> 			break;
> 		}
> 	}
1555a1585,1590
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1556a1592,1610
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1559a1614,1616
> 		case 2:
> 		default:
> 		{
1560a1618,1620
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
38a40
> #include	"StrUtils.h"
51a54
> #include	"IPUI.h"
94a98
> 	memset( m_TempHostName, 0x00, sizeof( m_TempHostName ) );
116a121,342
> // CIPEndpoint::ShowSettingsDialog - show dialog for settings
> //
> // Entry:		Pointer to thread pool
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CIPEndpoint::ShowSettingsDialog( CThreadPool *const pThreadPool )
> {
> 	HRESULT	hr;
> 
> 
> 	DNASSERT( pThreadPool != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	AddRef();
> 	hr = pThreadPool->SpawnDialogThread( DisplayIPHostNameSettingsDialog, &m_hActiveSettingsDialog, this );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to start IP hostname dialog!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:	
> 	DecRef();
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::SettingsDialogComplete - dialog has completed
> //
> // Entry:		Error code for dialog
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::SettingsDialogComplete( const HRESULT hDialogResult )
> {
> 	HRESULT					hr;
> 	HRESULT					hTempResult;
> 	IDirectPlay8Address		*pBaseAddress;
> 	DWORD					dwTotalAddressBufferSize;
> 	char					*pTempAddressString;
> 	WCHAR					WCharHostName[ sizeof( m_TempHostName ) + 1 ];
> 	DWORD					dwWCharHostNameSize;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = hDialogResult;
> 	pBaseAddress = NULL;
> 
> 	pTempAddressString = NULL;
> 
> 	//
> 	// since the dialog is exiting, clear our handle to the dialog
> 	//
> 	m_hActiveSettingsDialog = NULL;
> 
> 	//
> 	// dialog failed, fail the user's command
> 	//
> 	if ( hr != DPN_OK )
> 	{
> 		if ( hr != DPNERR_USERCANCEL)
> 		{
> 			DPF( 0, "Failing endpoint hostname dialog!" );
> 			DisplayErrorCode( 0, hr );
> 
> 		}
> 
> 		goto Failure;
> 	}
> 
> 	//
> 	// The dialog completed OK, rebuild remote address and complete command
> 	//
> 
> 	//
> 	// get the base DNADDRESS
> 	//
> 	pBaseAddress = m_pRemoteMachineAddress->DP8AddressFromSocketAddress();
> 	if ( pBaseAddress == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "SettingsDialogComplete: Failed to get base address when completing IP hostname dialog!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// Add the new 'HOSTNAME' parameter to the address.  If the hostname is blank
> 	// and this is an enum, copy the broadcast hostname.
> 	//
> 	if ( ( m_TempHostName[ 0 ] == '\0' ) && ( m_EndpointType == ENDPOINT_TYPE_ENUM ) )
> 	{
> 		DNASSERT( sizeof( WCharHostName ) >= g_dwIPBroadcastAddressSize );
> 		memcpy( WCharHostName, g_IPBroadcastAddress, g_dwIPBroadcastAddressSize );
> 		dwWCharHostNameSize = g_dwIPBroadcastAddressSize;
> 	}
> 	else
> 	{
> 		dwWCharHostNameSize = LENGTHOF( WCharHostName );
> 		hr = STR_AnsiToWide( m_TempHostName, -1, WCharHostName, &dwWCharHostNameSize );
> 		DNASSERT( hr == DPN_OK );
> 		dwWCharHostNameSize *= sizeof( WCHAR );
> 	}
> 
> 	hr = IDirectPlay8Address_AddComponent( pBaseAddress, DPNA_KEY_HOSTNAME, WCharHostName, dwWCharHostNameSize, DPNA_DATATYPE_STRING );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "SettingsDialogComplete: Failed to add hostname to address!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// set the address
> 	//
> 	hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pBaseAddress, SP_ADDRESS_TYPE_HOST );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to rebuild DNADDRESS when completing IP hostname dialog!" );
> 		DNASSERT( FALSE );
> 		goto Failure;
> 	}
> 
> 	//
> 	// the remote machine address has been adjusted, finish the command
> 	//
> 	switch ( m_EndpointType )
> 	{
> 		case ENDPOINT_TYPE_ENUM:
> 		{
> 			hr = CompleteEnumQuery();
> 			if ( hr != DPN_OK )
> 			{
> 				DPF( 0, "Problem completing EnumQuery after asking user for hostname!" );
> 				DisplayDNError( 0, hr );
> 			}
> 
> 			break;
> 		}
> 
> 		case ENDPOINT_TYPE_CONNECT:
> 		{
> 			hr = CompleteConnect();
> 			if ( hr != DPN_OK )
> 			{
> 				DPF( 0, "Problem completing Connect after asking user for hostname!" );
> 				DisplayDNError( 0, hr );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown!
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			hr = DPNERR_GENERIC;
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
> Exit:
> 	if ( pBaseAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DNASSERT( pTempAddressString == NULL );
> 	if ( pBaseAddress != NULL )
> 	{
> 		DNFree( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DecRef();
> 
> 	return;
> 
> Failure:
> 	//
> 	// close this endpoint
> 	//
> 	Close( hr );
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::StopSettingsDialog - stop an active settings dialog
> //
> // Entry:		Handle of dialog to close
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::StopSettingsDialog( const HWND hDlg)
> {
> 	StopIPHostNameSettingsDialog( hDlg );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
216a443
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
262,263d488
< 
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
22a23,24
> #define	TEMP_HOSTNAME_LENGTH	100
> 
52a55,67
> 		// UI functions
> 		//
> 		HRESULT		ShowSettingsDialog( CThreadPool *const pThreadPool );
> 		void		SettingsDialogComplete( const HRESULT hr );
> 		void		StopSettingsDialog( const HWND hDlg );
> 		void		SetTempHostName( const char *const pHostName, const UINT_PTR uHostNameLength )
> 		{
> 			DNASSERT( pHostName[ uHostNameLength ] == '\0' );
> 			DNASSERT( ( uHostNameLength + 1 ) <= LENGTHOF( m_TempHostName ) );
> 			memcpy( m_TempHostName, pHostName, ( uHostNameLength + 1 ) );
> 		}
> 
> 		//
69a85
> 		char		m_TempHostName[ TEMP_HOSTNAME_LENGTH ];
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\locals.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62a63,67
> //
> // OS version
> //
> UINT_PTR	g_uOSType;
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\locals.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
103a104,108
> //
> // OS version
> //
> extern	UINT_PTR	g_uOSType;
> 
105a111,125
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // OSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OSType
> // ------------------------------
> inline UINT_PTR	OSType( void )
> {
> 	return	g_uOSType;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
50a52
> #include	"IPXAddress.h"
54a57
> #include	"IPXEndpt.h"
82a86
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
84a89
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
174a180,186
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
193a206,222
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
> 	
318a348,354
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
328a365,370
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
399a442
> 
428a472,515
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	CIPXAddress	*pReturnAddress;
> 
> 	
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	
> 	DNEnterCriticalSection( &g_AddressLock );
> 	pReturnAddress = g_pIPXAddressPool->Get();
> 	DNLeaveCriticalSection( &g_AddressLock );
> 
> 	return	pReturnAddress;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	
> 	DNEnterCriticalSection( &g_AddressLock );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> 	DNLeaveCriticalSection( &g_AddressLock );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
438a526,541
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
59a62,63
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
61a66
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\rsip.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40a41
> #include	"Registry.h"
512a514,517
> 
> 		hr = GetGatewayFromRegistry( reinterpret_cast<BYTE*>( gwipaddr ), sizeof( gwipaddr ) );
> 
> 		if(hr != DPN_OK){
514a520,522
> 		}
> 
> 		DPF(0,"Found suggested RSIP gateway in registry %s, running on Win95?\n",gwipaddr);
651d658
<         WCHAR wszIPHLPAPI[] = L"IPHLPAPI.DLL";
687c694
< 	hIpHlpApi = LoadLibrary(wszIPHLPAPI);
---
> 	hIpHlpApi = LoadLibrary("IPHLPAPI.DLL");
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
258a260,267
> 	
> 	//
> 	// Winsock 2 functionality always exists on WinNT.  If we're on Win9x, we can
> 	// only use Winsock2 interfaces for TCP.
> 	//
> 	if ( ( OSType() == VER_PLATFORM_WIN32_NT ) ||
> 		 ( ( LOWORD( GetWinsockVersion() ) >= 2 ) && ( m_pSPData->GetType() == TYPE_IP ) ) )
> 	{
259a269,273
> 	}
> 	else
> 	{
> 		m_pSendFunction = Winsock1Send;
> 	}
405a420,431
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( ( LOWORD( GetWinsockVersion() ) == 1 ) ||
> 			 ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_pSPData->GetType() == TYPE_IPX ) ) )
> 		{
> 			m_pSPData->GetThreadPool()->RemoveSocketPort( this );
> 		}
> 
836a863,875
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
838a878,974
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ),	// pointer to receive buffer
> 								pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize,		// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();
> 
> Exit:
> 	return;
> }
839a976,978
> 
> 
> //**********************************************************************
840a980,1125
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
867,868c1152,1153
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( OSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
874a1160,1168
> 	// lock the 'pending operation' list over the call to Winsock to prevent the
> 	// operation from being completed while it's being set up.
> 	//
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->LockWriteData();
> 	}
> 	
> 	//
880a1175,1177
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
892a1190,1194
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->UnlockWriteData();
> 	}
> 
933a1236,1238
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1007c1312,1313
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( OSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1016a1323,1331
> 	// lock the 'pending operation' list over the call to Winsock to prevent the
> 	// operation from being completed while it's being set up.
> 	//
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->LockReadData();
> 	}
> 
> 	//
1022a1338,1340
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1033a1352,1357
> 	
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->UnlockReadData();
> 	}
> 
1080a1405,1406
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1114a1441,1442
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1159a1488,1489
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
1730a2061,2067
> 	switch ( OSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1775a2113,2176
> 			break;
> 		}
> 
> 		//
> 		// Win9x.
> 		// If this is not an IPX socket and Winsock 2 (or greater) is available,
> 		// call the Winsock 2 read function.  If this is IPX or we're stuck with
> 		// Winsock 1, inform the thread pool as such.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 
> 			if ( ( LOWORD( GetWinsockVersion() ) >= 2 ) &&
> 				 ( m_pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// we're using Winsock2, call for two outstanding reads per socket.
> 				//
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #1 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #2 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 			}
> 			else
> 			{
> 				DNASSERT( m_pSPData != NULL );
> 				hr = m_pSPData->GetThreadPool()->AddSocketPort( this );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Failed to add to active socket list!" );
> 					DisplayDNError( 0, hr );
> 					goto Failure;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
1975d2375
< 
2413a2814,2971
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
> 
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			goto Exit;
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			//
> 			// take a quick look at the return and submit a new receive if applicable
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					hTempResult = Winsock2Receive();
> 					if ( hTempResult != DPN_OK )
> 					{
> #pragma	BUGBUG( johnkan, "Fix this!" )
> 						INT3;
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = pReadData->m_dwOverlappedBytesReceived;
> 					pReadData->m_dwOverlappedBytesReceived = 0;
> 					ProcessReceivedData( pReadData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();	
> 	DecRef();
> 
> 	return;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
238a239
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
244a246,248
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
287a292
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,3c1,5
< TARGETNAME=dpnwsock
< TARGETTYPE=DYNLINK
< TARGETPATH=obj
---
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
5c7,17
< !ifdef _BUILD_FOR_WIN2000
---
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
> TARGETNAME=dpnwsock
> DLLDEF=..\wsocksp.def
7,13d18
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
15c20,26
< INCLUDES=..\..\;..\..\..\inc;..\..\..\common;..\..\..\..\dnaddress
---
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
17c28,29
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> TARGETPATH=obj
> TARGETTYPE=DYNLINK
19c31,35
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
21,22c37,58
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
>            ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
> 
> #
> # If a debug mode is selected, make sure we include the defines to make the
> # logging code operate.
> #
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
25c61,71
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
27c73,77
< DLLDEF=..\wsocksp.def
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28a79,88
> INCLUDES=$(DXROOT)\inc;..\..\..\inc;..\..\..\common;..\..\..\dnaddress
> 
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
32a93
> 	 ..\DWinsock.cpp \
36a98,100
> 	 ..\IPUI.cpp \
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
39a104
>          ..\Registry.cpp \
48a114,116
> #
> # Next specify options for the compiler.
> #
49a118,120
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNWSock_EXPORTS /DCINTERFACE
> 
> USER_C_FLAGS=-nologo -W3
52,72c123,124
< TARGETLIBS= \
<            ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
<            $(BASEDIR)\public\sdk\lib\*\dpnaddr.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<            $(BASEDIR)\public\sdk\lib\*\winsockx.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
104c104
< // the size of a SOCKADDR_IN!
---
> // the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
122c122,123
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
158c159,160
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
236a239
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
237a241
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
240c244
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
247c251
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
274a279
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
48a50
> #include	"IPXAddress.h"
54a57
> #include	"IPXEndpt.h"
224a228,257
> 	switch ( OSType() )
> 	{
> 		//
> 		// Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
> 			DPF( 8, "WinNT detected!" );
> 			break;
> 		}
> 
> 		//
> 		// Windows 95, 98
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DPF( 8, "Win9x detected!" );
> 			break;
> 		}
> 
> 		// other version (unsupported!)
> //		case VER_PLATFORM_WIN32_CE:
> 		case VER_PLATFORM_WIN32s:
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
584a618,623
> 		case TYPE_IPX:
> 		{
> 			pReturn = CreateIPXEndpoint( &EndpointPoolContext );
> 			break;
> 		}
> 
753a793,798
> 		case TYPE_IPX:
> 		{
> 			pReturn = CreateIPXAddress();
> 			break;
> 		}
> 
784a830,835
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
121a123,142
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
128a150,160
> //
> // structure passed to dialog threads
> //
> typedef	struct	_DIALOG_THREAD_PARAM
> {
> 	DIALOG_FUNCTION	*pDialogFunction;
> 	HWND			*phDialog;
> 	void			*pContext;
> 	CThreadPool		*pThisThreadPool;
> } DIALOG_THREAD_PARAM;
> 
233c265,272
< 	DEBUG_ONLY( 
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( OSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
235c274,275
< 	)
---
> 						break;
> 					}
236a277,284
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
243c291,298
< 	DEBUG_ONLY(
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( OSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
245c300,301
< 	)
---
> 						break;
> 					}
246a303,310
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
280a345,351
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
337a409,413
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( OSType() )
> 	{
340a417,418
> 		case VER_PLATFORM_WIN32_NT:
> 		{
346a425,451
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
375a481,482
> 	SYSTEM_INFO		SystemInfo;
> 	UINT_PTR		uDesiredThreads;
382a490,494
> 	//
> 	// get machine information
> 	//
> 	memset( &SystemInfo, 0x00, sizeof( SystemInfo ) );
> 	GetSystemInfo( &SystemInfo );
402a515,521
> 	uDesiredThreads = ( SystemInfo.dwNumberOfProcessors * 2 ) + 2;
> 	DNASSERT( uDesiredThreads != 0 );
> 	while ( uDesiredThreads > 0 )
> 	{
> 		uDesiredThreads--;
> 		StartNTCompletionThread();
> 	}
404,408d522
<     StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 
433a548,783
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT				hr;
> 	HANDLE				hPrimaryThread;
> 	HANDLE				hSecondaryThread;
> 	DWORD				dwPrimaryThreadID;
> 	DWORD				dwSecondaryThreadID;
> 	WIN9X_THREAD_DATA	*pPrimaryThreadInput;
> 	WIN9X_THREAD_DATA	*pSecondaryThreadInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	hPrimaryThread = NULL;
> 	hSecondaryThread = NULL;
> 	pPrimaryThreadInput = NULL;
> 	pSecondaryThreadInput = NULL;
> 
> 	//
> 	// Win9x requires completion events for Winsock2.  Always allocate the
> 	// events even though the they might not be used.
> 	//
> 	DNASSERT( m_hWinsock2SendComplete == NULL );
> 	m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 										   TRUE,	// manual reset
> 										   FALSE,	// start unsignalled
> 										   NULL		// pointer to name (none)
> 										   );
> 	if ( m_hWinsock2SendComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Send!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 	m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 											  TRUE,		// manual reset
> 											  FALSE,	// start unsignalled
> 											  NULL		// pointer to name (none)
> 											  );
> 	if ( m_hWinsock2ReceiveComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Receive!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	//
> 	// create parameters to worker threads
> 	//
> 	pPrimaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pPrimaryThreadInput ) ) );
> 	if ( pPrimaryThreadInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for primary Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	pSecondaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pSecondaryThreadInput ) ) );
> 	if ( pSecondaryThreadInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for secondary Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pPrimaryThreadInput, 0x00, sizeof( *pPrimaryThreadInput ) );
> 	pPrimaryThreadInput->pThisThreadPool = this;
> 	
> 	DBG_CASSERT( sizeof( *pPrimaryThreadInput ) == sizeof( *pSecondaryThreadInput ) );
> 	memcpy( pSecondaryThreadInput, pPrimaryThreadInput, sizeof( *pSecondaryThreadInput ) );
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	IncrementActiveThreadCount();
> 	
> 	//
> 	// Create one worker thread and boost its priority.  If the primary thread
> 	// can be created and boosted, create a secondary thread.  Do not create a
> 	// secondary thread if the primary could not be boosted because the system
> 	// is probably low on resources.
> 	//
> 	hPrimaryThread = CreateThread( NULL,					// pointer to security attributes (none)
> 								   0,						// stack size (default)
> 								   PrimaryWin9xThread,		// pointer to thread function
> 								   pPrimaryThreadInput,		// pointer to input parameter
> 								   0,						// let it run
> 								   &dwPrimaryThreadID		// pointer to destination of thread ID
> 								   );
> 	if ( hPrimaryThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		DecrementActiveThreadCount();
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		goto Failure;
> 	}
> 	pPrimaryThreadInput = NULL;
> 
> 
> 	DPF( 8, "Created primary Win9x thread: 0x%x\tTotal Thread Count: %d", dwPrimaryThreadID, ThreadCount() );
> 	DNASSERT( hPrimaryThread != NULL );
> 	if ( SetThreadPriority( hPrimaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of primary Win9x read thread!  Not starting secondary thread" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 	else
> 	{
> 		//
> 		// primary thread was created and boosted, create a secondary thread
> 		//
> 		IncrementActiveThreadCount();
> 		hSecondaryThread = CreateThread( NULL,						// pointer to security attributes (none)
> 										 0,							// stack size (default)
> 										 SecondaryWin9xThread,		// pointer to thread function
> 										 pSecondaryThreadInput,		// pointer to input parameter
> 										 0,							// let it run
> 										 &dwSecondaryThreadID		// pointer to destination of thread ID
> 										 );
> 		if ( hSecondaryThread != NULL )
> 		{
> 			DPF( 8, "Created secondary Win9x thread: 0x%x\tTotal Thread Count: %d", dwSecondaryThreadID, ThreadCount() );
> 			
> 			pSecondaryThreadInput = NULL;
> 			DNASSERT( hSecondaryThread != NULL );
> 			if ( SetThreadPriority( hSecondaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to boost priority of secondary Win9x thread!" );
> 				DisplayErrorCode( 0, dwError );
> 			}
> 		}
> 		else
> 		{
> 			//
> 			// thread startup failed, decrement active thread count
> 			//
> 			DecrementActiveThreadCount();
> 		}
> 	}
> 
> 
> Exit:
> 	if ( pPrimaryThreadInput != NULL )
> 	{
> 		DNFree( pPrimaryThreadInput );
> 		pPrimaryThreadInput = NULL;
> 	}
> 
> 	if ( pSecondaryThreadInput != NULL )
> 	{
> 		DNFree( pSecondaryThreadInput );
> 		pSecondaryThreadInput = NULL;
> 	}
> 
> 	if ( hPrimaryThread != NULL )
> 	{
> 		if ( CloseHandle( hPrimaryThread ) == FALSE )
> 		{
> 			DWORD	dwError;
> 
> 
> 			dwError = GetLastError();
> 			DPF( 0, "Problem closing Win9x thread hanle!" );
> 			DisplayErrorCode( 0, dwError );
> 		}
> 
> 		hPrimaryThread = NULL;
> 	}
> 
> 	if ( hSecondaryThread != NULL )
> 	{
> 		if ( CloseHandle( hSecondaryThread ) == FALSE )
> 		{
> 			DWORD	dwError;
> 
> 
> 			dwError = GetLastError();
> 			DPF( 0, "Problem closing Win9x thread hanle!" );
> 			DisplayErrorCode( 0, dwError );
> 		}
> 
> 		hSecondaryThread = NULL;
> 	}
> 
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
532a883,884
> 	if ( OSType() == VER_PLATFORM_WIN32_NT )
> 	{	
553a906
> 	}
629a983,986
> 
> 		DNASSERT( ( OSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
647a1005,1006
> 		DNASSERT( ( OSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
791a1151
> 	m_IPXReadIODataPool.Deinitialize();
839d1198
< 			
843a1203,1211
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			break;
> 		}
> 
> 		//
921a1290,1298
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1176a1554,1555
> 	switch ( OSType() )
> 	{
1179a1559,1560
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1196a1578,1606
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( m_JobQueue.SignalPendingJob() == FALSE )
> 			{
> 				hr = DPNERR_OUTOFMEMORY;
> 				DPF( 0, "Failed to signal pending job!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1307a1718,1719
> 	if ( OSType() == VER_PLATFORM_WIN32_NT )
> 	{
1314a1727
> 	}
1516a1930,2030
> // CThreadPool::SpawnDialogThread - start a secondary thread to display service
> //		provider UI.
> //
> // Entry:		Pointer to dialog function
> //				Pointer destination for copy of dialog handle
> //				Dialog context
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext )
> {
> 	HRESULT	hr;
> 	HANDLE	hDialogThread;
> 	DIALOG_THREAD_PARAM		*pThreadParam;
> 	DWORD	dwThreadID;
> 
> 
> 	DNASSERT( pDialogFunction != NULL );
> 	DNASSERT( phDialog != NULL );
> 	DNASSERT( pDialogContext != NULL );		// why would anyone not want a dialog context??
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pThreadParam = NULL;
> 
> 	//
> 	// create and initialize thread param
> 	//
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( DNMalloc( sizeof( *pThreadParam ) ) );
> 	if ( pThreadParam == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for dialog thread!" );
> 		goto Failure;
> 	}
> 
> 	pThreadParam->pDialogFunction = pDialogFunction;
> 	pThreadParam->phDialog = phDialog;
> 	pThreadParam->pContext = pDialogContext;
> 	pThreadParam->pThisThreadPool = this;
> 
> 	//
> 	// assume that a thread will be created
> 	//
> 	IncrementActiveThreadCount();
> 
> 	//
> 	// create thread
> 	//
> 	hDialogThread = CreateThread( NULL,					// pointer to security (none)
> 								  0,					// stack size (default)
> 								  DialogThreadProc,		// thread procedure
> 								  pThreadParam,			// thread param
> 								  0,					// creation flags (none)
> 								  &dwThreadID );		// pointer to thread ID
> 	if ( hDialogThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// decrement active thread count and report error
> 		//
> 		DecrementActiveThreadCount();
> 		
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to start dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		goto Failure;
> 	}
>   								
> 	if ( CloseHandle( hDialogThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing handle from create dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:
> 	if ( pThreadParam != NULL )
> 	{
> 		DNFree( pThreadParam );
> 		pThreadParam = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
1536a2051,2052
> 	switch ( OSType() )
> 	{
1537a2054,2063
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( NTCompletionThreadCount() == 0 );
> 			break;
> 		}
> 
> 		//
1539a2066,2067
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1541a2070,2071
> 			break;
> 		}
1542a2073,2082
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1571a2112,2113
> 	switch ( OSType() )
> 	{
1572a2115,2122
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1578a2129,2130
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1618a2171,2183
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1698a2264,2410
> // CThreadPool::AddSocketPort - add a socket to the Win9x watch list
> //
> // Entry:		Pointer to SocketPort
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::AddSocketPort( CSocketPort *const pSocketPort )
> {
> 	HRESULT	hr;
> 	BOOL	fSocketAdded;
> 
> 	
> 	DNASSERT( pSocketPort != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	fSocketAdded = FALSE;
> 
> 	Lock();
> 
> 	//
> 	// We're capped by the number of sockets we can use for Winsock1.  Make
> 	// sure we don't allocate too many sockets.
> 	//
> 	if ( m_uReservedSocketCount == FD_SETSIZE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "There are too many sockets allocated on Winsock1!" );
> 		goto Failure;
> 	}
> 
> 	m_uReservedSocketCount++;
> 	
> 	DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 	m_pSocketPorts[ m_SocketSet.fd_count ] = pSocketPort;
> 	m_SocketSet.fd_array[ m_SocketSet.fd_count ] = pSocketPort->GetSocket();
> 	m_SocketSet.fd_count++;
> 	fSocketAdded = TRUE;
> 
> 	//
> 	// add a reference to note that this socket port is being used by the thread
> 	// pool
> 	//
> 	pSocketPort->AddRef();
> 
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when adding socket port to active list!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> Exit:
> 	Unlock();
> 	
> 	return	hr;
> 
> Failure:
> 	if ( fSocketAdded != FALSE )
> 	{
> 		AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
> 		m_SocketSet.fd_count--;
> 		m_pSocketPorts[ m_SocketSet.fd_count ] = NULL;
> 		m_SocketSet.fd_array[ m_SocketSet.fd_count ] = NULL;
> 		fSocketAdded = FALSE;
> 	}
> 
> 	m_uReservedSocketCount--;
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::RemoveSocketPort - remove a socket from the Win9x watch list
> //
> // Entry:		Pointer to socket port to remove
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::RemoveSocketPort( CSocketPort *const pSocketPort )
> {
> 	UINT_PTR	uIndex;
> 
> 
> 	DNASSERT( pSocketPort != NULL );
> 	
> 	Lock();
> 
> 	uIndex = m_SocketSet.fd_count;
> 	DNASSERT( uIndex != 0 );
> 	while ( uIndex != 0 )
> 	{
> 		uIndex--;
> 
> 		if ( m_pSocketPorts[ uIndex ] == pSocketPort )
> 		{
> 			m_uReservedSocketCount--;
> 			m_SocketSet.fd_count--;
> 
> 			memmove( &m_pSocketPorts[ uIndex ],
> 					 &m_pSocketPorts[ uIndex + 1 ],
> 					 ( sizeof( m_pSocketPorts[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			memmove( &m_SocketSet.fd_array[ uIndex ],
> 					 &m_SocketSet.fd_array[ uIndex + 1 ],
> 					 ( sizeof( m_SocketSet.fd_array[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			//
> 			// clear last entry which is now unused
> 			//
> 			memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) );
> 			memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) );
> 
> 			//
> 			// end the loop
> 			//
> 			uIndex = 0;
> 		}
> 	}
> 
> 	Unlock();
> 	
> 	pSocketPort->DecRef();
> 
> 	//
> 	// It's really not necessary to signal a new job here because there were
> 	// active sockets on the last iteration of the Win9x thread.  That means the
> 	// Win9x thread was in a polling mode to check for sockets and the next time
> 	// through it will notice that there is a missing socket.  By signalling the
> 	// job event we reduce the time needed for the thread to figure out that the
> 	// socket is gone.
> 	//
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when removeing socket port to active list!" );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
1842a2555,3375
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwOverlappedBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				//
> 				// Overlapped results will complete with success and zero bytes
> 				// transferred when the overlapped structure is checked BEFORE
> 				// the operation has really been subnitted.  This is a possibility
> 				// with the current code.  To combat this, check the sent bytes
> 				// for zero (we'll never send zero bytes).
> 				//
> 				if ( pWriteIOData->m_dwOverlappedBytesSent == 0 )
> 				{
> 					goto SkipSendCompletion;
> 				}
> 
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 				pWriteIOData->m_dwOverlappedBytesSent = 0;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					//
> 					// WSAENOTSOCK = the socket has been closed, most likely
> 					// as a result of a command completing or being cancelled.
> 					//
> 					case WSAENOTSOCK:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_USERCANCEL;
> 						break;
> 					}
> 
> 					//
> 					// other error, stop and look
> 					//
> 					default:
> 					{
> 						INT3;
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwOverlappedBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				//
> 				// Overlapped results will complete with success and zero bytes
> 				// transferred when the overlapped structure is checked BEFORE
> 				// the operation has really been subnitted.  This is a possibility
> 				// with the current code.  To combat this, check the received bytes
> 				// for zero (the return when the overlapped request was checked before
> 				// it was sent) and check the return address (it's possible that someone
> 				// really sent zero bytes).
> 				//
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				if ( ( pReadIOData->m_dwOverlappedBytesReceived != 0 ) &&
> 					 ( pReadIOData->m_pSourceSocketAddress->IsUndefinedHostAddress() == FALSE ) )
> 				{
> 					pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 				}
> 				else
> 				{
> 					goto SkipReceiveCompletion;
> 				}
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::PrimaryWin9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::PrimaryWin9xThread( void *pParam )
> {
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 	
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Primary Win9x thread failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> //	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> //	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 	
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 	
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		DWORD	dwWaitReturn;
> 
> 		
> 		//
> 		// Update the job time so we know how long to wait.  We can
> 		// only get here if a socket was just added to the socket list, or
> 		// we've been servicing sockets.
> 		//
> 		DNTimeGet( &CurrentTime );
> 		if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 		{
> 			pThisThreadPool->LockTimerData();
> 			CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																		   &CoreData.NextTimerJobTime );
> 			if ( CoreData.fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 			}
> 			pThisThreadPool->UnlockTimerData();
> 		}
> 
> 		DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 		dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 
> 		//
> 		// Check for Winsock1 sockets.  If there are some around, do a quick poll
> 		// of them to check of I/O before entering the main Winsock2 loop for
> 		// the real timing.
> 		//
> 		pThisThreadPool->Lock();
> 		if ( pSocketSet->fd_count != 0 )
> 		{
> 			pThisThreadPool->Unlock();
> 
> 			pThisThreadPool->CheckWinsock1IO( pSocketSet );
> 			
> 			//
> 			// since there are Winsock1 sockets active, don't spend a lot of
> 			// time waiting for something to happen for Winsock2
> 			//
> 			if ( g_dwSelectTimeSlice < dwMaxWaitTime )
> 			{
> 				dwMaxWaitTime = g_dwSelectTimeSlice;
> 			}
> 		}
> 		else
> 		{
> 			pThisThreadPool->Unlock();
> 		}
> 
> 
> 		//
> 		// Check Winsock2 sockets.
> 		//
> 		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> 												 CoreData.hWaitHandles,					// handles to wait on
> 												 FALSE,									// don't wait for all to be signalled
> 												 dwMaxWaitTime,							// wait timeout
> 												 TRUE									// we're alertable for APCs
> 												 );
> 		switch ( dwWaitReturn )
> 		{
> 			//
> 			// timeout, don't do anything, we'll probably process timer jobs on
> 			// the next loop
> 			//
> 			case WAIT_TIMEOUT:
> 			{
> 				break;
> 			}
> 
> 			//
> 			// New job.  Account for the time spent in the wait.  Don't
> 			// account for time after the job is complete because it's
> 			// possible that the job was an job submission which will want
> 			// to reset the wait time.
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 			{
> 				DPF( 8, "Primary Win9x thread has a pending job!" );
> 				pThisThreadPool->ProcessWin9xJob( &CoreData );
> 				break;
> 			}
> 
> 			//
> 			// SP closing
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 			{
> 				DPF( 8, "Primary Win9x thread exit because SP closing!" );
> 				fLooping = FALSE;
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 send complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending write list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Primary Win9x thread failed to reset Winsock2 send event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nPrimary Win9x thread servicing sends!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingSends();
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 receive complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending read list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Primary Win9x thread failed to reset Winsock2 receive event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nPrimary Win9x thread servicing receives!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingReceives();
> 				break;
> 			}
> 
> 			//
> 			// There are I/O completion routines scheduled on this thread.
> 			// This is not a good thing!
> 			//
> 			case WAIT_IO_COMPLETION:
> 			{
> 				DPF( 1, "WARNING: APC was serviced on the primary Win9x IO service thread!  What is the application doing??" );
> 				break;
> 			}
> 
> 			//
> 			// wait failed
> 			//
> 			case WAIT_FAILED:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Primary Win9x thread wait failed!" );
> 				DisplayDNError( 0, dwError );
> 				break;
> 			}
> 
> 			//
> 			// problem
> 			//
> 			default:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Primary Win9x thread unknown problem in wait!" );
> 				DisplayDNError( 0, dwError );
> 				DNASSERT( FALSE );
> 				break;
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	COM_CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::SecondaryWin9xThread - secondary thread to handle only Win9x
> //		I/O so developers get bit faster with multithreading issues if they're
> //		developing on Win9x.  This thread will only handle Winsock2 based TCP
> //		I/O.  Winsock 1 is not deemed important enough to hack the rest of the
> //		code to work with two threads.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::SecondaryWin9xThread( void *pParam )
> {
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 
> 	
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Secondary Win9x thread failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 	
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 	
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		DWORD	dwWaitReturn;
> 
> 		
> 		//
> 		// Check Winsock2 sockets.
> 		//
> 		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> 												 CoreData.hWaitHandles,					// handles to wait on
> 												 FALSE,									// don't wait for all to be signalled
> 												 INFINITE,								// wait timeout (forever)
> 												 TRUE									// we're alertable for APCs
> 												 );
> 		switch ( dwWaitReturn )
> 		{
> 			//
> 			// timeout, shouldn't ever be here!!
> 			//
> 			case WAIT_TIMEOUT:
> 			{
> 				INT3;
> 				break;
> 			}
> 
> 			//
> 			// New job.  This is the secondary thread and is only used to handle
> 			// Winsock2 I/O.  Ignore this event and sleep to cause the proper
> 			// work thread to handle the event.
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 			{
> 				DPF( 8, "Secondary Win9x thread sleeping on job notification!" );
> 				SleepEx( 0, TRUE );
> 				break;
> 			}
> 
> 			//
> 			// SP closing
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 			{
> 				DPF( 8, "Secondary Win9x thread exit because SP closing!" );
> 				fLooping = FALSE;
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 send complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending write list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Secondary Win9x thread failed to reset Winsock2 send event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nSecondary Win9x thread servicing sends!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingSends();
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 receive complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending read list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Secondary Win9x thead failed to reset Winsock2 receive event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nSecondary Win9x thread servicing receives!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingReceives();
> 				break;
> 			}
> 
> 			//
> 			// There are I/O completion routines scheduled on this thread.
> 			// This is not a good thing!
> 			//
> 			case WAIT_IO_COMPLETION:
> 			{
> 				DPF( 1, "WARNING: APC was serviced on the secondary Win9x IO service thread!  What is the application doing??" );
> 				break;
> 			}
> 
> 			//
> 			// wait failed
> 			//
> 			case WAIT_FAILED:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Secondary Win9x thread wait failed!" );
> 				DisplayDNError( 0, dwError );
> 				break;
> 			}
> 
> 			//
> 			// problem
> 			//
> 			default:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Secondary Win9x thread unknown problem in wait!" );
> 				DisplayDNError( 0, dwError );
> 				DNASSERT( FALSE );
> 				break;
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	COM_CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2186a3720,4077
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::DialogThreadProc - thread proc for spawning dialogs
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> // ------------------------------
> DWORD WINAPI	CThreadPool::DialogThreadProc( void *pParam )
> {
> 	const DIALOG_THREAD_PARAM	*pThreadParam;
> 
> 
> 	//
> 	// Initialize COM.  If this fails, we'll have problems later.
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
> 	DNASSERT( pParam != NULL );
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( pParam );
> 	
> 	pThreadParam->pDialogFunction( pThreadParam->phDialog, pThreadParam->pContext );
> 
> 	pThreadParam->pThisThreadPool->DecrementActiveThreadCount();
> 	DNFree( pParam );
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// Remove and process a single job from the list.  If there is no job, skip
> 	// to the end of the function.
> 	//
> 	pJobInfo = GetWorkItem();
> 
> 	if ( pJobInfo == NULL )
> 	{
> 		goto Exit;
> 	}
> 
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> 
> Exit:
> 	return;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CheckWinsock1IO - check the IO status for Winsock1 sockets
> //
> // Entry:		Pointer to sockets to watch
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CheckWinsock1IO( const FD_SET *const pWinsock1Sockets )
> {
> static	const TIMEVAL	SelectNoTime = { 0 };
> 	INT			iSelectReturn;
> 	FD_SET		ReadSocketSet;
> 	FD_SET		WriteSocketSet;
> 	FD_SET		ErrorSocketSet;
> 
> 
> 	//
> 	// Make a local copy of all of the sockets.  This isn't totally
> 	// efficient, but it works.  Multiplying by active socket count will
> 	// spend half the time in the integer multiply.
> 	//
> 	Lock();
> 	memcpy( &ReadSocketSet, pWinsock1Sockets, sizeof( ReadSocketSet ) );
> 	memcpy( &WriteSocketSet, pWinsock1Sockets, sizeof( WriteSocketSet ) );
> 	memcpy( &ErrorSocketSet, pWinsock1Sockets, sizeof( ErrorSocketSet ) );
> 	Unlock();
> 
> 	//
> 	// Don't check write sockets here because it's very likely that they're ready
> 	// for service but have no outgoing data and will thrash
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  &ReadSocketSet,	// sockets to check for read
> 							  NULL,				// sockets to check for write (none)
> 							  &ErrorSocketSet,	// sockets to check for error
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// select got pissed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// WSAENOTSOCK = This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// WSAEINTR = this operation was interrupted
> 				//
> 				case WSAEINTR:
> 				{
> 					DPF( 1, "Winsock1 reporting interrupted operation when selecting read or error sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting read or error sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing read service and error service.
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 			ServiceWinsock1Sockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Since writes are likely to be ready, check for them separately
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  NULL,				// sockets to check for read (don't check reads)
> 							  &WriteSocketSet,	// sockets to check for write
> 							  NULL,				// sockets to check for error (don't check errors)
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout, no write sockets are ready for service
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// select failed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// this socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting write sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing write service
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 			break;
> 		}
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ServiceWinsock1Sockets - service requests on Winsock1 sockets ports
> //
> // Entry:		Pointer to set of sockets
> //				Pointer to service function
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction )
> {
> 	UINT_PTR	uWaitingSocketCount;
> 	UINT_PTR	uSocketPortCount;
> 	CSocketPort	*pSocketPorts[ FD_SETSIZE ];
> 
> 
> 	uSocketPortCount = 0;
> 	uWaitingSocketCount = pSocketSet->fd_count;
> 	
> 	Lock();
> 	while ( uWaitingSocketCount > 0 )
> 	{
> 		UINT_PTR	uIdx;
> 
> 
> 		uWaitingSocketCount--;
> 		uIdx = m_SocketSet.fd_count;
> 		while ( uIdx != 0 )
> 		{
> 			uIdx--;
> 			if ( pSocketSet->fd_array[ uWaitingSocketCount ] == m_SocketSet.fd_array[ uIdx ] )
> 			{
> 				//
> 				// this socket is still available, add a reference to the socket
> 				// port and keep it around to be processed outside of the lock
> 				//
> 				pSocketPorts[ uSocketPortCount ] = m_pSocketPorts[ uIdx ];
> 				pSocketPorts[ uSocketPortCount ]->AddRef();
> 				uSocketPortCount++;
> 				uIdx = 0;
> 			}
> 		}
> 	}
> 	Unlock();
> 
> 	while ( uSocketPortCount != 0 )
> 	{
> 		uSocketPortCount--;
> 		
> 		//
> 		// call the service function and remove the reference
> 		//
> 		(pSocketPorts[ uSocketPortCount ]->*pServiceFunction)();
> 		pSocketPorts[ uSocketPortCount ]->DecRef();
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
50a51
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
63a65
> typedef	void	DIALOG_FUNCTION( HWND *const phDialog, void *const pDialogContext );
100c102,103
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( OSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
146a150
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( OSType() == VER_PLATFORM_WIN32_NT ) );
151a156
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( OSType() == VER_PLATFORM_WIN32_NT ) );
159a165,167
> 		HRESULT	AddSocketPort( CSocketPort *const pSocketPort );
> 		void	RemoveSocketPort( CSocketPort *const pSocketPort );
> 
170a179,181
> 		HRESULT	SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext );
> 
> 		
222a234
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
276a289
> 		HRESULT	Win9xInit( void );
286a300,301
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
287a303,304
> 		static	DWORD WINAPI	PrimaryWin9xThread( void *pParam );
> 		static	DWORD WINAPI	SecondaryWin9xThread( void *pParam );
289a307
> 		static	DWORD WINAPI	DialogThreadProc( void *pParam );
294a313,316
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
> 
> 		void	CheckWinsock1IO( const FD_SET *const pWinsock1Sockets );
> 		void	ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
13a14,15
> #include <WSIPX.h>
> 
39a42
> #include	"Creg.h"
40a44,47
> #include	"strutils.h"
> 
> #include	"resource.h"
> 
50a58,66
> #define DN_REG_LOCAL_SP_ROOT				L"Software\\Microsoft\\DirectPlay8"
> #define DN_REG_LOCAL_SP_SUB					L"\\Service Providers"
> #define DN_REG_LOCAL_SP_SUBKEY				DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB
> #define DN_REG_LOCAL_WSOCK_IPX_ROOT			L"\\DPNSPWinsockIPX"
> #define DN_REG_LOCAL_WSOCK_TCPIP_ROOT		L"\\DPNSPWinsockTCP"
> #define	DN_REG_KEYNAME_ALL_APPLICATIONS		L"All Applications"
> #define	DN_REG_KEYNAME_FRIENDLY_NAME		L"Friendly Name"
> #define DN_REG_KEYNAME_GUID					L"GUID"
> 
73c89,118
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
> 	DNSP_QueryInterface,
> 	DNSP_AddRef,
> 	DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Close,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
134a180,236
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to pointer to SP interface
> //				Pointer to pointer to associated SP data
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP, CSPData **const ppSPData )
> {
> 	HRESULT 	hr;
> 	CSPData		*pSPData;
> 
> 
> 	DNASSERT( ppiDNSP != NULL );
> 	DNASSERT( ppSPData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pSPData = NULL;
> 	*ppiDNSP = NULL;
> 	*ppSPData = NULL;
> 
> 	//
> 	// create main data class
> 	//
> 	hr = CreateSPData( &pSPData, &CLSID_DP8SP_IPX, TYPE_IPX, &ipxInterface );
> 	if ( hr != DPN_OK )
> 	{
> 		DNASSERT( pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( pSPData != NULL );
> 	*ppiDNSP = pSPData->COMInterface();
> 	*ppSPData = pSPData;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( pSPData != NULL )
> 	{
> 		pSPData->DecRef();
> 		pSPData = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
221a324,326
> 	//
> 	// we can either create an IPX instance or an IP instance
> 	//
227a333,336
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP, &pSPData );
> 	}
268c377
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return ( IsEqualCLSID( rclsid, CLSID_DP8SP_TCPIP ) || IsEqualCLSID( rclsid, CLSID_DP8SP_IPX ) );
359a469,719
> #define MAX_RESOURCE_STRING_LENGTH		_MAX_PATH
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "CDPVACMI::LoadAndAllocString"
> HRESULT LoadAndAllocString( UINT uiResourceID, wchar_t **lpswzString )
> {
> 	int length;
> 	HRESULT hr;
> 
> 	if( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
> 		wchar_t wszTmpBuffer[MAX_RESOURCE_STRING_LENGTH];	
> 		
> 		length = LoadStringW( g_hDLLInstance, uiResourceID, wszTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
> 
> 		if( length == 0 )
> 		{
> 			hr = GetLastError();		
> 			
> 			DPF( 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
> 			*lpswzString = NULL;
> 
> 			return hr;
> 		}
> 		else
> 		{
> 			*lpswzString = new wchar_t[length+1];
> 
> 			if( *lpswzString == NULL )
> 			{
> 				DPF( 0, "Alloc failure" );
> 				return DPNERR_OUTOFMEMORY;
> 			}
> 
> 			wcscpy( *lpswzString, wszTmpBuffer );
> 
> 			return DPN_OK;
> 		}
> 	}
> 	else
> 	{
> 		char szTmpBuffer[MAX_RESOURCE_STRING_LENGTH];
> 		
> 		length = LoadStringA( g_hDLLInstance, uiResourceID, szTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
> 
> 		if( length == 0 )
> 		{
> 			hr = GetLastError();		
> 			
> 			DPF( 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
> 			*lpswzString = NULL;
> 
> 			return hr;
> 		}
> 		else
> 		{
> 			*lpswzString = new wchar_t[length+1];
> 
> 			if( *lpswzString == NULL )
> 			{
> 				DPF( 0, "Alloc failure" );
> 				return DPNERR_OUTOFMEMORY;
> 			}
> 
> 			if( STR_jkAnsiToWide( *lpswzString, szTmpBuffer, length+1 ) == 0 )
> 			{
> 				hr = GetLastError();
> 				
> 				DPF( 0, "Unable to upconvert from ansi to unicode hr=0x%x", hr );
> 				return hr;
> 			}
> 
> 			return DPN_OK;
> 		}
> 		
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "RegisterDefaultSettings"
> //
> // RegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT RegisterDefaultSettings()
> {
> 	CRegistry creg;
> 	WCHAR *wszFriendlyName = NULL;
> 	HRESULT hr;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB DN_REG_LOCAL_WSOCK_IPX_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create IPX sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 
> 	creg.WriteString( DN_REG_KEYNAME_ALL_APPLICATIONS, L"Y" );
> 
> 	hr = LoadAndAllocString( IDS_FRIENDLYNAME_IPX, &wszFriendlyName );
> 
> 	if( FAILED( hr ) )
> 	{
> 		DPF( 0, "Could not load IPX name hr=0x%x", hr );
> 		return hr;
> 	}
> 
> 	// Load from resource file
> 	creg.WriteString( DN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );
> 
> 	delete [] wszFriendlyName;
> 
> 	creg.WriteGUID( DN_REG_KEYNAME_GUID, CLSID_DP8SP_IPX );
> 
> 	creg.Close();
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB DN_REG_LOCAL_WSOCK_TCPIP_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create TCPIP sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 
> 	creg.WriteString( DN_REG_KEYNAME_ALL_APPLICATIONS, L"Y" );
> 
> 	hr = LoadAndAllocString( IDS_FRIENDLYNAME_TCPIP, &wszFriendlyName );
> 
> 	if( FAILED( hr ) )
> 	{
> 		DPF( 0, "Could not load IPX name hr=0x%x", hr );
> 		return hr;
> 	}
> 
> 	// Load from resource file
> 	creg.WriteString( DN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );
> 
> 	delete [] wszFriendlyName;
> 
> 	creg.WriteGUID( DN_REG_KEYNAME_GUID, CLSID_DP8SP_TCPIP );
> 
> 	creg.Close();
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "UnRegisterDefaultSettings"
> //
> // UnRegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT UnRegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot remove app, does not exist" );
> 	}
> 	else
> 	{
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_WSOCK_IPX_ROOT)[1] ) )
> 		{
> 			DPFERR( "Cannot remove IPX sub-key, could have elements" );
> 		}
> 
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_WSOCK_TCPIP_ROOT)[1] ) )
> 		{
> 			DPFERR( "Cannot remove TCPIP sub-key, could have elements" );
> 		}
> 
> 	}
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8SPWSock.IPX.1", L"DirectPlay8 WSock IPX Provider Object", 
> 							  L"dpnwsock.dll", CLSID_DP8SP_IPX, L"DirectPlay8SPWSock.IPX") )
> 	{
> 		DPFERR( "Could not register dp8 IPX object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8SPWSock.TCPIP.1", L"DirectPlay8 WSock TCPIP Provider Object", 
> 							  L"dpnwsock.dll", CLSID_DP8SP_TCPIP, L"DirectPlay8SPWSock.TCPIP") )
> 	{
> 		DPFERR( "Could not register dp8 IP object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = RegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Could not register default settings hr = 0x%x", hr );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DP8SP_IPX) )
> 	{
> 		DPF( 0, "Failed to unregister IPX object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DP8SP_TCPIP) )
> 	{
> 		DPF( 0, "Failed to unregister IP object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = UnRegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Failed to remove default settings hr=0x%x", hr );
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
22a24
> #include	"DWinsock.h"
50,53d51
< // provides us winsock1/2 support
< #include "dwnsock1.inc"
< #include "dwnsock2.inc"
< 
80a79,80
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
> 
83a84
> static DWORD_PTR	OverrideWinsockVersion( void );
91a93,158
> // OverrideWinsockVersion - override the Winsock version used by the SP
> //
> // Entry:		Nothing
> //
> // Exit:		Max Winsock version to ask for
> // ------------------------------
> static DWORD_PTR	OverrideWinsockVersion( void )
> {
> 	DWORD_PTR	WinsockVersion;
> 
> 
> 	//
> 	// check for override for OS version and Winsock version
> 	//
> 	g_uOSType = DNGetOSType();
> 	WinsockVersion = 2;
> 
> 	switch ( GetProfileInt( "DirectPlay8", "WinsockVersion", 0 ) )
> 	{
> 		//
> 		// Use Winsock1.  If this is an NT machine, fake it into
> 		// thinking it's Win9x.
> 		//
> 		case 1:
> 		{
> 			if ( g_uOSType == VER_PLATFORM_WIN32_NT )
> 			{
> 				g_uOSType = VER_PLATFORM_WIN32_WINDOWS;
> 			}
> 			WinsockVersion = 1;
> 				
> 			break;
> 		}
> 
> 		//
> 		// Use Winsock2.  If this is an NT machine, fake it into
> 		// thinking it's Win9x.
> 		//
> 		case 2:
> 		{
> 			if ( g_uOSType == VER_PLATFORM_WIN32_NT )
> 			{
> 				g_uOSType = VER_PLATFORM_WIN32_WINDOWS;
> 			}
> 			DNASSERT( WinsockVersion == 2 );
> 
> 			break;
> 		}
> 
> 		//
> 		// OS default
> 		//
> 		default:
> 		{
> 			DNASSERT( WinsockVersion == 2 );
> 			break;
> 		}
> 	}
> 
> 	return	WinsockVersion;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
105a173,174
> 	INT			iVersion;
> 	DWORD_PTR	MaxWinsockVersion;
115a185,186
> 	MaxWinsockVersion = OverrideWinsockVersion();
> 
131c202
< 	// initialize Winsock
---
> 	// initialize the bindings to Winsock
133,139c204,205
< 	WORD wVersionRequested;
< 	WSADATA wsaData;
< 	int nRet;
< 
< 	wVersionRequested = MAKEWORD(2,2);
< 	nRet = p_WSAStartup(wVersionRequested, &wsaData);
< 	if (nRet || wVersionRequested != wsaData.wVersion)
---
> 	iVersion = DWSInitWinSock( &g_dwsState, MaxWinsockVersion );
> 	if ( iVersion == 0 )	// failure
141,143c207,209
< 		DPF( 0, "Problem starting winsock!" );
< 	    fReturn = FALSE;
< 	    goto Failure;
---
> 		DPF( 0, "Problem binding dynamic winsock functions!" );
> 		fReturn = FALSE;
> 		goto Failure;
145d210
< 
147a213,214
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
157c224,232
< 		p_WSACleanup();
---
> 		BOOL	fFreeReturn;
> 
> 
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 		if ( fFreeReturn == FALSE )
> 		{
> 			DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 		}
> 
187a263,265
> 	BOOL	fFreeReturn;
> 
> 
191c269,273
< 	p_WSACleanup();
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 	if ( fFreeReturn == FALSE )
> 	{
> 		DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 	}
198a281,293
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
199a295
> 
285a382
> 	INT_PTR iWinsockVersion;
295a393
> 	iWinsockVersion = GetWinsockVersion();
589a688,744
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // AddNetworkAdapterToBuffer - add a network address to a packed buffer
> //
> // Entry:		Pointer to packed buffer
> //				Pointer to adapter name
> //				Pointer to adapter guid
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	AddNetworkAdapterToBuffer( CPackedBuffer *const pPackedBuffer,
> 								   const char *const pAdapterName,
> 								   const GUID *const pAdapterGUID )
> {
> 	HRESULT	hr;
> 	DPN_SERVICE_PROVIDER_INFO	AdapterInfo;
> 
> 
> 	DNASSERT( pPackedBuffer != NULL );
> 	DNASSERT( pAdapterName != NULL );
> 	DNASSERT( pAdapterGUID != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	memset( &AdapterInfo, 0x00, sizeof( AdapterInfo ) );
> 	DNASSERT( AdapterInfo.dwFlags == 0 );
> 
> 	hr = pPackedBuffer->AddToBack( pAdapterGUID, sizeof( *pAdapterGUID ) );
> 	if ( ( hr != DPNERR_BUFFERTOOSMALL ) && ( hr != DPN_OK ) )
> 	{
> 		DPF( 0, "Failed to add socket address to buffer!" );
> 		goto Failure;
> 	}
> 	AdapterInfo.pGuid = static_cast<GUID*>( pPackedBuffer->GetTailAddress() );
> 
> 	pPackedBuffer->AddStringToBack( pAdapterName );
> 	if ( ( hr != DPNERR_BUFFERTOOSMALL ) && ( hr != DPN_OK ) )
> 	{
> 		DPF( 0, "Failed to add adapter name to buffer!" );
> 		goto Failure;
> 	}
> 	AdapterInfo.pwszName = static_cast<WCHAR*>( pPackedBuffer->GetTailAddress() );
> 
> 	pPackedBuffer->AddToFront( &AdapterInfo, sizeof( AdapterInfo ) );
> 
> Exit:
> 	return	hr;
> 
> Failure:
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
48a49,50
> INT		GetWinsockVersion( void );
> 
59a62,65
> 
> HRESULT	AddNetworkAdapterToBuffer( CPackedBuffer *const pPackedBuffer,
> 								   const char *const pAdapterName,
> 								   const GUID *const pAdapterGUID );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22
> #include	<WSIPX.h>
94,95d94
< extern HRESULT WINAPI DirectPlay8AddressCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown);
< 
166a166,169
>  	switch ( pSPData->GetType() )
> 	{
> 		case TYPE_IP:
> 		{
168a172,187
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			DPF( 9, "Attempting to create IPX datagram socket." );
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
233a253
> 		case TYPE_IPX:
319a340
> 	IDirectPlay8Address		*pSPOnlyAddress;
328c349
< 	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );
---
> 	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );
343a365
> 	pSPOnlyAddress = NULL;
382a405,452
> 		HRESULT	hTempResult;
> 		GUID	SPGuid;
> 
> 
> 		//
> 		// get the SP
> 		//
> 		hTempResult = IDirectPlay8Address_GetSP( pDeviceAddress, &SPGuid );
> 		switch ( hTempResult )
> 		{
> 			//
> 			// no problem
> 			//
> 			case DPN_OK:
> 			{
> 				DNASSERT( hr == DPNERR_PENDING );
> 				break;
> 			}
> 
> 			//
> 			// pass these errors throug
> 			//
> 			case DPNERR_OUTOFMEMORY:
> 			{
> 				hr = hTempResult;
> 				goto Failure;
> 				break;
> 			}
> 
> 			//
> 			// remap other errors to addressing errors
> 			//
> 			default:
> 			{
> 				hr = DPNERR_ADDRESSING;
> 				goto Failure;
> 				break;
> 			}
> 		}
> 
> 		//
> 		// The host address is NULL, if we're using TCPIP and we're not allowed to query,
> 		// use the broadcast address.  If we're on IPX, use the broadcast address.
> 		//
> 		if ( ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
> 		{
384a455,502
> 		}
>         else
>         {
> 			HRESULT	hTempResult;
> 
> 
> 			//
> 			// Need to build address with just the SP guid.  Get it from the
> 			// device address.
> 			//
> 			DNASSERT( pSPOnlyAddress == NULL );
> 			hTempResult = COM_CoCreateInstance( CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>( &pSPOnlyAddress ) );
> 			if ( hTempResult != S_OK )
> 			{
> 				DPF( 0, "Failed to create SP-Only address when non was supplied!" );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			hTempResult = IDirectPlay8Address_SetSP( pSPOnlyAddress, &SPGuid );
> 			switch ( hTempResult )
> 			{
> 				//
> 				// set SP, no problem
> 				//
> 				case DPN_OK:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// failed to set SP, map error to an addressing error
> 				//
> 				default:
> 				{
> 					hr = DPNERR_ADDRESSING;
> 					goto Failure;
> 
> 					break;
> 				}
> 			}
> 
> 			pHostAddress = pSPOnlyAddress;
> 		}
516a635,667
> 			if ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) != 0 ) &&
> 				 ( pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// Copy the connect data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since the dialog is being popped, this command is in progress,
> 				// not pending.
> 				//
> 				DNASSERT( pSPData != NULL );
> 
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				pEndpoint->CopyEnumQueryData( pEnumQueryData );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for enum query!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove our reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
530a682,683
> 			}
> 
609a763,768
> 	if ( pSPOnlyAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pSPOnlyAddress );
> 		pSPOnlyAddress = NULL;
> 	}
> 
783c942
< 	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
---
> 	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
989a1149,1177
> 			if ( ( pConnectData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
> 			{
> 				//
> 				// Copy the connect data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since a dialog is being displayed, the command is in-progress,
> 				// not pending.
> 				//
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				pEndpoint->CopyConnectData( pConnectData );
> 				if ( ( hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() ) ) != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for connect!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove our reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
990a1179,1180
> 			}
> 
1256c1446
< 	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
---
> 	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
1462a1653,1685
> 			if ( ( pListenData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
> 			{
> 				//
> 				// Copy the listen data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since this endpoint is being handed off to another thread,
> 				// make sure it's in the unbound list.  Since a dialog is being
> 				// displayed, the command state is in progress, not pending.
> 				//
> 				DNASSERT( pSPData != NULL );
> 
> 				pEndpoint->CopyListenData( pListenData );
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for listen!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove out reference to it
> 				//
> 				pEndpoint->DecRef();
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
1463a1687,1688
> 			}
> 
2431a2657,2668
> 		// Multicast groups are unsupported on IPX.
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
> 		//
2648a2886,2897
> 		//
> 		// multicast groups are unsupported on IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DPF( 0, "Attempted to AddToGroup on IPX!" );
> 			goto Failure;
> 
> 			break;
> 		}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
6a7,8
>   DllRegisterServer PRIVATE
>   DllUnregisterServer PRIVATE
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\08091700.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\comutil.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\comutil.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dbginfo.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dneterrors.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\guidutil.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	1ece02cc	6bb05875
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\packbuff.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\packbuff.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\strutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\strutils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\appdesc.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\client.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\connect.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dllmain.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.def	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dnet.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\migration.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\msghandler.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\ntentry.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\peer.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\server.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addbase.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addparse.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dllmain.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.def	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpsp8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\connect.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\enum.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\initialize.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\timer.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dbginfo.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock1.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock2.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\locals.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\locals.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\rsip.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.def	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 90 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\callstack.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\memlog.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\dnmisc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\dpguid.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04241015.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04261045.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05010945.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05021600.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05031030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05081300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05091400.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05111530.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05121300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05151130.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05161345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05221345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05231030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06021030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06121345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06121445.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06141200.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06191100.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\07171100.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\07261030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\07281500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\07311100.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\08071630.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\08091615.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\lastsync.bat	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\dplegacy.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\dplegacy.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\connect.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\directnet.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\directplay8core.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dnaddress.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dndbg.txt	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dnregister.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dp8context.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dp8protocol.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpaddress.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpclassinfo.xls	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpcustombuild.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplay8.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplay8.xls	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplobby8.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpnsvr.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpv8dmo.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoice.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoice.mpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoicenote.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\hostmigration.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\lobby8update.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\nametable.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\nametbl.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\rfc1738.txt	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\spintf.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\usercb.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\winsockspwireprotocol.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvlib.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvlib.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvrq.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvrq.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpnsvr.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpsvr8.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpsvr8.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\proctbl.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\proctbl.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\inc\dpnsdef.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\inc\dpnsvmsg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\inc\dplobby8.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\classfac.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\comstuff.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dllmain.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dnlobby.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplapp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplapp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplclient.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplclient.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplcommon.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplcommon.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconnect.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconnect.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconset.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconset.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplmsgq.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplmsgq.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby8int.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplparam.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplparam.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplproc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplproc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplreg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplreg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\globals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\handles.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\handles.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\contextfixedpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\handletable.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\handletable.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\registry.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\registry.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 230 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
3a4
>       lobby \
5c6,7
<       core
---
>       core \
>       dpnsvr 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\comutil.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21a22
> #include "creg.h"
24a26
> #include <stdlib.h>
39c41
<     WCHAR                   wszFileName[_MAX_PATH];
---
>     CHAR                    szFileName[_MAX_PATH];
123c125
<     hr = COM_GetDLLName( clsid, pEntry->wszFileName, &dwSize );
---
>     hr = COM_GetDLLName( clsid, pEntry->szFileName, &dwSize );
131c133
<     pEntry->hDLL = LoadLibraryW( pEntry->wszFileName );
---
>     pEntry->hDLL = LoadLibraryA( pEntry->szFileName );
165c167
< HRESULT COM_GetDLLName( GUID guidCLSID, WCHAR *wszPath, DWORD *pdwSize )
---
> HRESULT COM_GetDLLName( GUID guidCLSID, CHAR *szPath, DWORD *pdwSize )
167,171c169,171
< // BUGBUG: [mgere] [xbox] These com wrapper functions will only be called to
< // retrieve the wsock com object, so I hard coded the dpwsock.dll to always
< // return from this function.
< //
<     WCHAR wszDLL[] = L"dpnwsock.dll";
---
>     CRegistry cregRoot;
>     CRegistry cregCLSID;
>     CRegistry cregInProc;
173c173,178
<     wcscpy( wszPath, wszDLL);
---
>     HRESULT hr;
>     BOOL fSuccess;
>     WCHAR *wszTmpPath = NULL;
>     DWORD dwTmpSize = 0;
>     int res;
>     BOOL fDefault;
175c180
<     return S_OK;
---
>     fSuccess = cregRoot.Open( HKEY_CLASSES_ROOT, L"CLSID", TRUE, FALSE );
176a182,265
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening HKEY_CLASSES_ROOT\\CLSID" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     fSuccess = cregCLSID.Open( cregRoot, &guidCLSID, TRUE, FALSE );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening specified CLSID" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     fSuccess = cregInProc.Open( cregCLSID, L"InprocServer32", TRUE, FALSE );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening inprocserver key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     cregCLSID.Close();
>     cregRoot.Close();
> 
>     fSuccess = cregInProc.ReadString( L"", wszTmpPath, &dwTmpSize );
> 
>     if( !dwTmpSize )
>     {
>         DPF( 0, "Error opening default key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     if( dwTmpSize > *pdwSize )
>     {
>     	DPF( 0, "Buffer too small" );
>     	hr = DPNERR_BUFFERTOOSMALL;
>     	*pdwSize = dwTmpSize;
>     	goto COM_GETDLLNAME_ERROR;
>     }
> 
>     *pdwSize = dwTmpSize;
> 
>     wszTmpPath = new WCHAR[dwTmpSize];
> 
> 	if( !wszTmpPath )
> 	{
> 		DPF( 0, "Error allocating memory" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto COM_GETDLLNAME_ERROR;
> 	}
> 
>     fSuccess = cregInProc.ReadString( L"", wszTmpPath, &dwTmpSize );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening default key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     if( FAILED( hr = STR_jkWideToAnsi(szPath,wszTmpPath, *pdwSize ) ) )
>     {
>         DPF( 0, "Error converting path to DLL to ANSI hr=0x%x", hr );
>         hr = E_FAIL;
>     }
> 
>     
> 
>     delete [] wszTmpPath;
> 
>     return hr;
> 
> COM_GETDLLNAME_ERROR:
> 
>     if( wszTmpPath )
>         delete [] wszTmpPath;
> 
>     return hr;
> 
193c282
< // BUGBUG: [mgere] [xbox] Added this temporarily
---
>     hr = CoCreateInstance( rclsid, pUnkOuter, dwClsContext, riid, ppv );
195,196c284,285
< COM_Init();
< 
---
>     if( hr == CO_E_NOTINITIALIZED )
>     {
218a308,311
> 
>         return hr;
> 
>     }
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\comutil.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21c21
< HRESULT COM_GetDLLName( GUID guidCLSID, WCHAR *szPath, DWORD *pdwSize );
---
> HRESULT COM_GetDLLName( GUID guidCLSID, CHAR *szPath, DWORD *pdwSize );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
29a37,65
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "UNKNOWN_MODULE"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectNet] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNetDebug"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dneterrors.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20,23
> // vanceo - changed to stdio for printf
> //#include	<iostream.h>
> #include	<stdio.h>
> 
78a83,92
> 			// output to console
> 			case DPNERR_OUT_CONSOLE:
> 			{
> 				// Also see the change from <iostream.h> to <stdio.h> above
> 				#pragma TODO(vanceo, "Changed cout to printf so NT build environment will work, figure this out.")
> 				//cout << endl << pString << endl;
> 				printf("\n%s\n", pString);
> 				break;
> 			}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\guidutil.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
15c15
< #include <wchar.h>
---
> #include "stdio.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34,37
> #ifdef	_WIN64
> #define	MEMORY_CRC			0X5AA55AA55AA55AA5
> #define	GUARD_SIGNATURE		0x0F1E2D3C4B5A6978
> #else
35a40
> #endif	// _WIN64
40a46,52
> //
> // enumerated values to indicate how to report memory leaks
> //
> #define	MEMORY_LEAK_REPORT_NONE		0x00000000
> #define	MEMORY_LEAK_REPORT_DPF		0x00000001
> #define	MEMORY_LEAK_REPORT_DIALOG	0x00000002
> 
60a73
> #ifdef	_X86_
61a75,77
> #else
> #define	ASSERT( arg )	if ( arg == FALSE ) { DebugBreak(); }
> #endif
94a111,116
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
> static	HINSTANCE			g_hApplicationInstance;
> 
> //
103a126,128
> static int	DisplayCallStack( const char *const pszMsg,
> 							  const char *const pszTitle,
> 							  const char *const pCallStack );
121a147
> 	OSVERSIONINFO	OSVersionInfo;
122a149
> 
130a158,186
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
> 	// note application instance
> 	//
> 	g_hApplicationInstance = GetModuleHandle( NULL );
> 	if ( g_hApplicationInstance == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to GetModuleHandle: 0x%x", dwError );
> 		goto Failure;
> 	}
> 
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
> 	//
229a286,287
> 		switch ( DNGetOSType() )
> 		{
232a291,292
> 			case VER_PLATFORM_WIN32_NT:
> 			{
257a318,328
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
290a362,393
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetApplcationInstance - application instance
> //
> // Entry:		Nothing
> //
> // Exit:		Application instance
> // ------------------------------
> HINSTANCE	DNGetApplicationInstance( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_hApplicationInstance;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
361a465
> //#ifdef	_WIN32
390a495
> //#endif	// _WIN32
391a497,518
> 
> //#ifdef	_WIN64
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	if ( pTime1->Time < pTime2->Time )
> //	{
> //		iReturnValue = -1;
> //	}
> //	else
> //	{
> //		if ( pTime1->Time == pTime2->Time )
> //		{
> //			iReturnValue = 0;
> //		}
> //		else
> //		{
> //			iReturnValue = 1;
> //		}
> //	}
> //#endif	// _WIN64
> 
417a545
> #ifdef	_X86_
429a558,608
> 
> #else	// _X86_
> 
> /*
> #ifdef	_ALPHA_
> 	// debug me
> 	DebugBreak();
> 
> 	__asm{ mov	$t0, *pTime1
> 		   mov	$t1, *pTime2
> 		   addq	$t0, $t1
> 		   mov	*pTimeResult, $t0
> 	};
> #else	// _ALPHA_
> */
> 
> //#ifdef	_WIN32
> 	DWORD	dwTempLowTime;
> 
> 
> 	dwTempLowTime = pTime1->Time32.TimeLow;
> 	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow + pTime2->Time32.TimeLow;
> 	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh + pTime2->Time32.TimeHigh;
> 
> 	//
> 	// check for overflow in low 32-bits and increment high value if applicable
> 	//
> 	if ( pTimeResult->Time32.TimeLow < dwTempLowTime )
> 	{
> #pragma	BUGBUG( johnkan, "Test this!" )
> 		// debug me
> 		DebugBreak();
> 		pTimeResult->Time32.TimeHigh++;
> 	}
> //#endif	// _WIN32
> 
> //#ifdef	_WIN64
> //	DEBUG_ONLY( UINT_PTR	ReferenceTime );
> //
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	DEBUG_ONLY( ReferenceTime = pTime1->Time );
> //	*pTimeResult = pTime1->Time + pTime2->Time;
> //	DNASSERT( *pTimeResult >= ReferenceTime );
> //
> //#endif	// _WIN64
> 
> // #endif	// _ALPHA_
> 
> #endif	// _X86_
455a635,636
> #ifdef	_X86_
> 
467a649,695
> 
> #else	// _X86_
> 
> /*
> #ifdef	_ALPHA_
> 	// debug me
> 	DebugBreak();
> 
> 	mov		$t0, *pTime1
> 	mov		$t1, *pTime2
> 	addq	$t0, $t1
> 	mov		*pTimeResult, $t0
> #else	// _ALPHA_
> */
> 
> //#ifdef	_WIN32
> 	DWORD	dwTempLowTime;
> 
> 
> 	dwTempLowTime = pTime1->Time32.TimeLow;
> 	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow - pTime2->Time32.TimeLow;
> 	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh - pTime2->Time32.TimeHigh;
> 
> 	//
> 	// check for underflow in low 32-bits and decrement high value if applicable
> 	//
> 	if ( pTimeResult->Time32.TimeLow > dwTempLowTime )
> 	{
> #pragma	BUGBUG( johnkan, "Test this!" )
> 		// debug me
> 		DebugBreak();
> 
> 		pTimeResult->Time32.TimeHigh--;
> 	}
> //#endif	// _WIN32
> 
> //#ifdef	_WIN64
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	DNASSERT( pTime1->Time > pTime2->Time );
> //	pTimeResult = pTime1->Time - pTime2->Time;
> //#endif	// _WIN64
> 
> // #endif	// _ALPHA_
> 
> #endif	// _X86_
688a917,919
> 		void	NoteCurrentCallStack( void ) { m_CallStack.NoteCurrentCallStack(); }
> 		void	GetCallStack( char *const pBuffer ) const { m_CallStack.GetCallStackString( pBuffer ); }
> 
707a939
> 		CCallStack<DN_MEMORY_CALL_STACK_DEPTH>	m_CallStack;
798a1031
> 		pMemoryLink->NoteCurrentCallStack();
908a1142
> 	char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
925a1160,1163
> #ifdef _IA64_
>                       // 8/05/2000(RichGr) - IA64: GetSize() returns UINT_PTR (64-bit), so we may as well handle in hex as %d expects a DWORD.
> 					  "Memory block: 0x%p\tAllocated size: 0x%p bytes\nCorruption Type: ",
> #else
926a1165
> #endif
943,944c1182,1193
< 			DPF( 0, "%s%s\n", "Memory Corruption!", MessageString );
< //					DNASSERT( FALSE );
---
> 			pMemoryLink->GetCallStack( CallStackBuffer );
> 			MessageReturn = DisplayCallStack( MessageString, "Memory Corruption!", CallStackBuffer );
> 			switch ( MessageReturn )
> 			{
> 				case IDABORT:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				case IDIGNORE:
> 				{
948a1198,1206
> 					break;
> 				}
> 
> 				case IDRETRY:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
979a1238
> 	DWORD		dwDisplayFlags;
980a1240
> 
983a1244
> 	fDisplayLeaks = TRUE;
986a1248,1249
> 	dwDisplayFlags = GetProfileIntA( PROF_SECT, "MemoryLeakOutput", MEMORY_LEAK_REPORT_DPF );
> 	
993a1257
> 		char		CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
1001a1266,1269
> #ifdef _IA64_
>         // 8/05/2000(RichGr) - IA64: GetSize() returns UINT_PTR (64-bit), so we may as well handle in hex as %d expects a DWORD.
> 		wsprintf( LeakSizeString, "0x%p bytes leaked at address 0x%p!\n", pTemp->GetSize(), pTemp->GetDataPointer() );
> #else
1002a1271
> #endif
1007,1008c1276
< 			DPF( 0, "%s%s\n", DialogTitle, LeakSizeString );
< //						DNASSERT( FALSE );
---
> 		pTemp->GetCallStack( CallStackBuffer );
1009a1278,1328
> 
> 		if ( ( dwDisplayFlags & MEMORY_LEAK_REPORT_DPF ) != 0 )
> 		{
> 			DPF( 0, "%s%s%s\n", DialogTitle, LeakSizeString, CallStackBuffer );
> 		}
> 
> 		if ( ( dwDisplayFlags & MEMORY_LEAK_REPORT_DIALOG ) != 0  )
> 		{
> 			if ( fDisplayLeaks != FALSE )
> 			{
> 				MessageReturn = DisplayCallStack( LeakSizeString, DialogTitle, CallStackBuffer );
> 				switch ( MessageReturn )
> 				{	
> 					//
> 					// stop application now
> 					//
> 					case IDABORT:
> 					{
> 						fDisplayLeaks = FALSE;
> 						break;
> 					}
> 
> 					//
> 					// display next leak
> 					//
> 					case IDIGNORE:
> 					{
> 						break;
> 					}
> 
> 					//
> 					// stop in the debugger
> 					//
> 					case IDRETRY:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 
> 					//
> 					// unknown
> 					//
> 					default:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 				}
> 			}
> 		}
> 
1022a1342,1485
> 
> 
> #if	defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
> //**********************************************************************
> //**
> //** THIS IS THE STACK TRACKING SECTION.  ONLY ADD FUNCTIONS HERE THAT ARE
> //** RELATED TO TRACKING THE CALL STACK!!
> //**
> //**********************************************************************
> 
> 
> ////**********************************************************************
> //// ------------------------------
> //// DNGetStackTop - return pointer to top of stack
> ////
> //// Entry:		Nothing
> ////
> //// Exit:		Pointer to top of stack
> //// ------------------------------
> //static void	*DNGetStackTop( void )
> //{
> //	void	*pReturn;
> //
> //	_asm	mov eax,dword ptr fs:[4]
> //	_asm	mov pReturn, eax
> //	return	pReturn;
> //}
> ////**********************************************************************
> //
> //
> ////**********************************************************************
> //// ------------------------------
> //// DNGetStackBottom - return pointer to bottom of call stack
> ////
> //// Entry:		Nothing
> ////
> //// Exit:		Pointer to bottom of call stack
> //// ------------------------------
> //static void	*DNGetStackBottom( void )
> //{
> //	void	*pReturn;
> //
> //	_asm	mov eax,dword ptr fs:[8]
> //	_asm	mov pReturn, eax
> //	return	pReturn;
> //}
> ////**********************************************************************
> 
> 
> ////**********************************************************************
> //// ------------------------------
> //// DNGetCallStack - get a call stack
> ////
> //// Entry:		Pointer to call stack array
> ////				Number of calls to report
> ////
> //// Exit:		Nothing
> //// ------------------------------
> //static	void	DNGetCallStack( const void **const pCallStack, const UINT_PTR Depth )
> //{
> //	void		**CallersEBP;
> //	void		*ReturnAddr;
> //	UINT_PTR	i,iCount;
> //	void		*StackTop;
> //	void		*StackBottom;
> //	static const	void	*min_dll_base = NULL;
> //
> //
> //	StackTop = DNGetStackTop();
> //	StackBottom = DNGetStackBottom();
> //	memset(	pCallStack, 0x00, sizeof( *pCallStack ) * Depth );
> //
> //	_asm
> //	{
> //		mov eax,[ebp]
> //		mov CallersEBP,eax
> //	}
> //
> //	__try
> //	{
> //		//
> //		// this code can generate exception if it steps back too far...
> //		//
> //		for ( i = 0, iCount = 0; i < Depth; iCount++ )
> //		{
> //			if ( ( CallersEBP < StackBottom ) || ( CallersEBP >= StackTop ) )
> //				break;
> //			ReturnAddr = CallersEBP[ 1 ];
> //			if ( ( iCount > 0 ) || ( ReturnAddr >= min_dll_base ) ) // iCount check skips memory_alloc_debug
> //				pCallStack[ i++ ] = ReturnAddr;
> //			CallersEBP = reinterpret_cast<void**>( *CallersEBP ); // get callers callers ebp
> //		}
> //	}
> //	__except( 1 )  // went too far back on the stack, fill up rest of array with zeros
> //	{
> //		DPF( 0, "Benign access violation creating return address stack." );
> //	}
> //}
> ////**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DisplayCallStack - display a call stack message box
> //
> // Entry:		Pointer to information string
> //				Pointer to title string
> //				Pointer to call stack string
> //
> // Exit:		Dialog return code
> // ------------------------------
> static int	DisplayCallStack( const char *const pszMsg, const char *const pszTitle, const char *const pCallStackString )
> {
> 	MSGBOXPARAMS	MessageBoxParams;
> 	char 			szStackTraceMsg[ CALLSTACK_BUFFER_SIZE ];
> 
> 
>     strcpy( szStackTraceMsg, pszMsg );
> 	strcat( szStackTraceMsg, pCallStackString );
> 
> 	//
> 	// display message box
> 	//
> 	memset( &MessageBoxParams, 0x00, sizeof( MessageBoxParams ) );
> 	MessageBoxParams.cbSize = sizeof( MessageBoxParams );
> 	MessageBoxParams.lpszText = szStackTraceMsg;
> 	MessageBoxParams.lpszCaption = pszTitle;
> 	MessageBoxParams.dwStyle = MB_ABORTRETRYIGNORE | MB_SETFOREGROUND | MB_TOPMOST | MB_DEFBUTTON2;
> 	MessageBoxParams.hInstance = NULL;
> 
> 	return MessageBoxIndirect( &MessageBoxParams );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> //**
> //** END OF CALL STACK TRACKING SECTION.
> //**
> //**********************************************************************
> #endif	// defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
> 
> 
> 
1117a1581
> 	static	BOOL	fDisplayCallStacks = TRUE;
1135a1600,1603
> 	if ( pCriticalSection->LockCount == 0 )
> 	{
> 		pCriticalSection->CallStack.NoteCurrentCallStack();
> 	}
1141a1610,1614
> 			if ( fDisplayCallStacks != FALSE )
> 			{
> 				char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
> 
> 
1146,1147c1619,1651
< 			    DPF( 0, "%s%s\n", "DNCritical section has been reentered!", "Check stack trace for function that originally held the lock." );
< //						DNASSERT( FALSE );
---
> 				pCriticalSection->CallStack.GetCallStackString( CallStackBuffer );
> 				switch ( DisplayCallStack( "Stack trace of function that originally held the lock:",
> 										   "DNCritical section has been reentered!",
> 										   CallStackBuffer ) )
> 				{
> 					//
> 					// don't display any more critical section warnings!
> 					//
> 					case IDABORT:
> 					{
> 						fDisplayCallStacks = FALSE;
> 						break;
> 					}
> 
> 					//
> 					// acknowledged
> 					//
> 					case IDIGNORE:
> 					{
> 						break;
> 					}
> 
> 					//
> 					// stop in debugger
> 					//
> 					case IDRETRY:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 				}
> 			}
> 
1180a1685
> 		memset( &pCriticalSection->CallStack, 0x00, sizeof( pCriticalSection->CallStack ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18,19
> #include	"CallStack.h"
> 
29a32,34
> #define	DN_MEMORY_CALL_STACK_DEPTH				12
> #define	DN_CRITICAL_SECTION_CALL_STACK_DEPTH	10
> 
53a59
> 	CCallStack< DN_CRITICAL_SECTION_CALL_STACK_DEPTH > 	CallStack;
76d81
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
86a92,101
> 
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
> HINSTANCE	DNGetApplicationInstance( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\packbuff.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
136a137,207
> // CPackedBuffer::AddStringToBack
> //
> // Entry:		Pointer to source string
> //
> // Exit:		Error Code:	DPN_OK					if able to add
> //							DPNERR_BUFFERTOOSMALL	if buffer is full
> // ------------------------------
> 
> HRESULT CPackedBuffer::AddStringToBack( const char *const pszString )
> {
> 	HRESULT	hr;
> 	DWORD	dwStringSize;
> 	DWORD	dwBufferSize;
> 
> 
> 	DNASSERT( pszString != NULL );
> 	
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	dwStringSize = 0;
> 	hr = STR_AnsiToWide( pszString,
> 						 -1,
> 						 NULL,
> 						 &dwStringSize );
> 	if ( hr != DPNERR_BUFFERTOOSMALL )
> 	{
> 		DNASSERT( hr != DPN_OK );
> 		goto Failure;
> 	}
> 	
> 	dwBufferSize = dwStringSize * sizeof( WCHAR );
> 	m_dwRequired += dwBufferSize;
> 	if ( !m_bBufferTooSmall )
> 	{
> 		if (m_dwRemaining >= dwBufferSize)
> 		{
> 			m_pTail -= dwBufferSize;
> 			m_dwRemaining -= dwBufferSize;
> 			hr = STR_AnsiToWide( pszString,
> 								 -1,
> 								 reinterpret_cast<WCHAR*>( m_pTail ),
> 								 &dwStringSize );
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			DNASSERT( ( dwStringSize * sizeof( WCHAR ) ) == dwBufferSize );
> 		}
> 		else
> 		{
> 			m_bBufferTooSmall = TRUE;
> 		}
> 	}
> 
> 	if ( m_bBufferTooSmall )
> 	{
> 		hr = DPNERR_BUFFERTOOSMALL;
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	goto Exit;
> }
> //**********************************************************************
> // ------------------------------
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\packbuff.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62a63
> 	HRESULT	AddStringToBack( const char *const pszString );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2c17,26
< TARGETTYPE=LIBRARY
---
> 
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
3a28
> TARGETTYPE=LIBRARY
5,9d29
< !ifdef _BUILD_FOR_WIN2000
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< LINKER_FLAGS=-align:32
< !endif
11c31,35
< INCLUDES=..\inc
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
13c37,41
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS)
15c43,47
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
17,18c49,52
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> INCLUDES=$(DXROOT)\inc;..\inc
> 
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
21d54
< MSC_WARNING_LEVEL=/W3 /WX
22a56,62
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
31a72
>         creg.cpp \
36c77,88
< TARGETLIBS=
---
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE
> MSC_OPTIMIZATION=/Odi /Zi
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
> 
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\strutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include "DNetErrors.h"
20a22,23
> #undef DPF_MODNAME
> #define DPF_MODNAME "STR_WideToAnsi"
22c25,48
< // BUGBUG: [mgere] [xbox] UnicodeToMultiByteN and MultiByteToUnicodeN were Taken from nlsxlat.c
---
> //**********************************************************************
> // ------------------------------
> // WideToANSI - convert a wide string to an ANSI string
> //
> // Entry:		Pointer to source wide string
> //				Size of source string (in WCHAR units, -1 implies NULL-terminated)
> //				Pointer to ANSI string destination
> //				Pointer to size of ANSI destination
> //
> // Exit:		Error code:
> //				DPNERR_GENERIC = operation failed
> //				DPN_OK = operation succeded
> //				DPNERR_BUFFERTOOSMALL = destination buffer too small
> // ------------------------------
> HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
> 						const DWORD dwWCHARStringLength,
> 						char *const pString,
> 						DWORD *const pdwStringLength )
> {
> 	HRESULT	hr;
> 	int		iReturn;
> 	BOOL	fDefault;
> 	char	cMilleniumHackBuffer;	
> 	char	*pMilleniumHackBuffer;
24,29d49
< HRESULT
< UnicodeToMultiByteN(
<     OUT PCH MultiByteString,
<     IN ULONG MaxBytesInMultiByteString,
<     IN PWCH UnicodeString,
<     IN ULONG BytesInUnicodeString)
31c51,53
< /*++
---
> 	DNASSERT( pWCHARString != NULL );
> 	DNASSERT( pdwStringLength != NULL );
> 	DNASSERT( ( pString != NULL ) || ( *pdwStringLength == 0 ) );
33c55,60
< Routine Description:
---
> 	//
> 	// Initialize.  A hack needs to be implemented because their paramter
> 	// validation is screwed and when you pass zero for a destination size, you
> 	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
> 	//
> 	hr = DPN_OK;
35,37c62,69
<     This functions converts the specified unicode source string into an
<     ansi string. The translation is done with respect to the
<     ANSI Code Page (ACP) loaded at boot time.
---
> 	if ( *pdwStringLength == 0 )
> 	{
> 		pMilleniumHackBuffer = &cMilleniumHackBuffer;
> 	}
> 	else
> 	{
> 		pMilleniumHackBuffer = pString;
> 	}
39c71,83
< Arguments:
---
> 	fDefault = FALSE;
> 	iReturn = WideCharToMultiByte( CP_ACP,					// code page (default ANSI)
> 								   0,						// flags (none)
> 								   pWCHARString,			// pointer to WCHAR string
> 								   dwWCHARStringLength,		// size of WCHAR string
> 								   pMilleniumHackBuffer,	// pointer to destination ANSI string
> 								   *pdwStringLength,		// size of destination string
> 								   NULL,					// pointer to default for unmappable characters (none)
> 								   &fDefault				// pointer to flag indicating that default was used
> 								   );
> 	if ( iReturn == 0 )
> 	{
> 		DWORD	dwError;
41,43d84
<     MultiByteString - Returns an ansi string that is equivalent to the
<         unicode source string.  If the translation can not be done,
<         an error is returned.
45,47c86,100
<     MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
<         written to MultiByteString.  If this causes MultiByteString to be a
<         truncated equivalent of UnicodeString, no error condition results.
---
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to convert WCHAR to multi-byte!" );
> 		DisplayDNError( 0, dwError );
> 		hr = DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		if ( *pdwStringLength == 0 )
> 		{
> 			hr = DPNERR_BUFFERTOOSMALL;
> 		}
> 		else
> 		{
> 			DNASSERT( hr == DPN_OK );
> 		}
49,50c102,103
<     BytesInMultiByteString - Returns the number of bytes in the returned
<         ansi string pointed to by MultiByteString.
---
> 		*pdwStringLength = iReturn;
> 	}
52,53c105,109
<     UnicodeString - Supplies the unicode source string that is to be
<         converted to ansi.
---
> 	//
> 	// if you hit this ASSERT it's because you've probably got ASCII text as your
> 	// input WCHAR string.  Double-check your input!!
> 	//
> 	DNASSERT( fDefault == FALSE );
55,56c111,113
<     BytesInUnicodeString - The number of bytes in the the string pointed to by
<         UnicodeString.
---
> 	return	hr;
> }
> //**********************************************************************
58d114
< Return Value:
60,63c116,133
<     SUCCESS - The conversion was successful
< 
< --*/
< 
---
> //**********************************************************************
> // ------------------------------
> // ANSIToWide - convert an ANSI string to a wide string
> //
> // Entry:		Pointer to source multi-byte (ANSI) string
> //				Size of source string (-1 imples NULL-terminated)
> //				Pointer to multi-byte string destination
> //				Pointer to size of multi-byte destination (in WCHAR units)
> //
> // Exit:		Error code:
> //				DPNERR_GENERIC = operation failed
> //				DPN_OK = operation succeded
> //				DPNERR_BUFFERTOOSMALL = destination buffer too small
> // ------------------------------
> HRESULT	STR_AnsiToWide( const char *const pString,
> 						const DWORD dwStringLength,
> 						WCHAR *const pWCHARString,
> 						DWORD *const pdwWCHARStringLength )
65,66c135,138
<     ULONG LoopCount;
<     ULONG CharsInUnicodeString;
---
> 	HRESULT	hr;
> 	int		iReturn;
> 	WCHAR	MilleniumHackBuffer;
> 	WCHAR	*pMilleniumHackBuffer;
68d139
<     CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);
70,71c141,143
<     LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
<                  CharsInUnicodeString : MaxBytesInMultiByteString;
---
> 	DNASSERT( pString != NULL );
> 	DNASSERT( pdwWCHARStringLength != NULL );
> 	DNASSERT( ( pWCHARString != NULL ) || ( *pdwWCHARStringLength == 0 ) );
73c145,150
<     while (LoopCount) {
---
> 	//
> 	// Initialize.  A hack needs to be implemented because their paramter
> 	// validation is screwed and when you pass zero for a destination size, you
> 	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
> 	//
> 	hr = DPN_OK;
75c152,170
<         *MultiByteString = (*UnicodeString < 256) ? (UCHAR)*UnicodeString : '?';
---
> 	if ( *pdwWCHARStringLength == 0 )
> 	{
> 		pMilleniumHackBuffer = &MilleniumHackBuffer;
> 	}
> 	else
> 	{
> 		pMilleniumHackBuffer = pWCHARString;
> 	}
> 	
> 	iReturn = MultiByteToWideChar( CP_ACP,					// code page (default ANSI)
> 								   0,						// flags (none)
> 								   pString,					// pointer to multi-byte string			
> 								   dwStringLength,			// size of string (assume null-terminated)
> 								   pMilleniumHackBuffer,	// pointer to destination wide-char string
> 								   *pdwWCHARStringLength	// size of destination in WCHARs
> 								   );
> 	if ( iReturn == 0 )
> 	{
> 		DWORD	dwError;
77,80d171
<         UnicodeString++;
<         MultiByteString++;
<         LoopCount--;
<     }
82,83c173,187
<     return DPN_OK;
< }
---
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to convert multi-byte to WCHAR!" );
> 		DisplayDNError( 0, dwError );
> 		hr = DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		if ( *pdwWCHARStringLength == 0 )
> 		{
> 			hr = DPNERR_BUFFERTOOSMALL;
> 		}
> 		else
> 		{
> 			DNASSERT( hr == DPN_OK );
> 		}
84a189,190
> 		*pdwWCHARStringLength = iReturn;
> 	}
86,151c192
< HRESULT
< MultiByteToUnicodeN(
<     OUT PWCH UnicodeString,
<     IN ULONG MaxBytesInUnicodeString,
<     IN PCH MultiByteString,
<     IN ULONG BytesInMultiByteString)
< 
< /*++
< 
< Routine Description:
< 
<     This functions converts the specified ansi source string into a
<     Unicode string. The translation is done with respect to the
<     ANSI Code Page (ACP) installed at boot time.  Single byte characters
<     in the range 0x00 - 0x7f are simply zero extended as a performance
<     enhancement.  In some far eastern code pages 0x5c is defined as the
<     Yen sign.  For system translation we always want to consider 0x5c
<     to be the backslash character.  We get this for free by zero extending.
< 
<     NOTE: This routine only supports precomposed Unicode characters.
< 
< Arguments:
< 
<     UnicodeString - Returns a unicode string that is equivalent to
<         the ansi source string.
< 
<     MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
<         written to UnicodeString.  If this causes UnicodeString to be a
<         truncated equivalent of MultiByteString, no error condition results.
< 
<     BytesInUnicodeString - Returns the number of bytes in the returned
<         unicode string pointed to by UnicodeString.
< 
<     MultiByteString - Supplies the ansi source string that is to be
<         converted to unicode.  For single-byte character sets, this address
<         CAN be the same as UnicodeString.
< 
<     BytesInMultiByteString - The number of bytes in the string pointed to
<         by MultiByteString.
< 
< Return Value:
< 
<     SUCCESS - The conversion was successful.
< 
< 
< --*/
< 
< {
<     ULONG LoopCount;
<     ULONG MaxCharsInUnicodeString;
< 
<     MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);
< 
<     LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
<                  MaxCharsInUnicodeString : BytesInMultiByteString;
< 
<     while (LoopCount) {
< 
<         *UnicodeString = (WCHAR)(UCHAR)(*MultiByteString);
< 
<         UnicodeString++;
<         MultiByteString++;
<         LoopCount--;
<     }
< 
<     return DPN_OK;
---
> 	return	hr;
152a194
> //**********************************************************************
154a197
> 
174a218,220
> 	int rval;
> 	BOOL bDefault = FALSE;
> 
182c228,238
< 	UnicodeToMultiByteN( lpStr, cchStr, (PWCH) lpWStr, cchStr*sizeof(WCHAR));
---
> 	// use the default code page (CP_ACP)
> 	// -1 indicates WStr must be null terminated
> 	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,
> 			NULL,&bDefault);
> 
> 	if (bDefault)
> 	{
> 		DPF(3,"!!! WARNING - used default string in WideToAnsi conversion.!!!");
> 		DPF(3,"!!! Possible bad unicode string - (you're not hiding ansi in there are you?) !!! ");
> 		return DPNERR_CONVERSION;
> 	}
188a245,251
> //	WideToAnsi
> //
> //	Convert a WCHAR (Wide) string to a CHAR (ANSI) string
> //
> //	CHAR	*pStr		CHAR string
> //	WCHAR	*pWStr		WCHAR string
> //	int		iStrSize	size (in bytes) of buffer pointed to by lpStr
189a253,295
> #define DPF_MODNAME "STR_AllocAndConvertToANSI"
> /*
>  ** GetAnsiString
>  *
>  *  CALLED BY: Everywhere
>  *
>  *  PARAMETERS: *ppszAnsi - pointer to string
>  *				lpszWide - string to copy
>  *
>  *  DESCRIPTION:	  handy utility function
>  *				allocs space for and converts lpszWide to ansi
>  *
>  *  RETURNS: string length
>  *
>  */
> HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide)
> {
> 	int iStrLen;
> 	BOOL bDefault;
> 	
> 	DNASSERT(ppszAnsi);
> 
> 	if (!lpszWide)
> 	{
> 		*ppszAnsi = NULL;
> 		return S_OK;
> 	}
> 
> 	*ppszAnsi = new char[wcslen(lpszWide)+1];
> 	if (!*ppszAnsi)	
> 	{
> 		DPF(0, "could not get ansi string -- out of memory");
> 		return E_OUTOFMEMORY;
> 	}
> 
> 	iStrLen = WideCharToMultiByte(CP_ACP,0,lpszWide,-1,*ppszAnsi,wcslen(lpszWide)+1,
> 			NULL,&bDefault);
> 
> 	return DPN_OK;
> } // OSAL_AllocAndConvertToANSI
> 
> 
> #undef DPF_MODNAME
208a315,316
> 	int rval;
> 
216c324
< 	MultiByteToUnicodeN( lpWStr, cchWStr*sizeof(WCHAR), (CHAR *) lpStr, cchWStr );
---
> 	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);
219a328
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\strutils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide);
21a23,31
> HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
> 						const DWORD dwWCHARStringLength,
> 						char *const pString,
> 						DWORD *const pdwStringLength );
> 
> HRESULT	STR_AnsiToWide( const char *const pString,
> 						const DWORD dwStringLength,
> 						WCHAR *const pWCHARString,
> 						DWORD *const pdwWCHARStringLength );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\appdesc.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
39d38
< #include <wchar.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
144c144,146
< #include <mmsystem.h>
---
> #include "dpnsdef.h"
> #include "dpnsvrq.h"
> #include "dpnsvlib.h"
207,208c209
< // BUGBUG: [mgere] [xbox] Completely removed this function since Xbox doesn't have multiple adapters.
< /*
---
> 
323d323
< */
409,410c409
< // BUGBUG: [mgere] [xbox] Need to figure out what to do with this.  We can't enumerate adapters.
< /*
---
> 
464c463
< */
---
> 
521c520
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
543c542
< 	pDeviceInfo->lpVtbl->GetURLW(pDeviceInfo,DP8ABuffer,&DP8ASize);
---
> 	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer,&DP8ASize);
697d695
< // BUGBUG: [mgere] [xbox] This shouldn't be needed since we don't have multiple adapters.
1219c1217
< 		//	generate a completion for the buffer.
---
> 		//	generate a completion for the buffer.
1264,1265c1262,1263
< 	WCHAR			DP8ABuffer[512];
< 	WCHAR			DP8ABuffer2[512];
---
> 	CHAR			DP8ABuffer[512];
> 	CHAR			DP8ABuffer2[512];
1281c1279
< 	pRemoteAddr->lpVtbl->GetURLW(pRemoteAddr,DP8ABuffer,&DP8ASize);
---
> 	pRemoteAddr->lpVtbl->GetURLA(pRemoteAddr,DP8ABuffer,&DP8ASize);
1284c1282
< 	pDeviceInfo->lpVtbl->GetURLW(pDeviceInfo,DP8ABuffer2,&DP8ASize);
---
> 	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer2,&DP8ASize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
128,129c128
< // BUGBUG: [mgere] [xbox] Removed (see cpp file)
< /*
---
> 
135c134
< */
---
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
97a98
> #include "dplobby8.h"
258a260,279
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
319a341,342
> 	pdnObject->pIDP8LobbiedApplication = NULL;
> 	pdnObject->dpnhLobbyConnection = NULL;
913a937,942
> 	if( pdnObject->pIDP8LobbiedApplication)
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release( pdnObject->pIDP8LobbiedApplication );
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 	}
> 
1098c1127
< 	{
---
> 	{
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\client.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
64d63
< #include <wchar.h>
102c101
< typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
166a167
> #include "DPLobby8.h"
194a196
> #include "DNMisc.h"
204a207,209
> #include "dpnsdef.h"
> #include "dpnsvrq.h"
> #include "dpnsvlib.h"
206,207d210
< #include <mmsystem.h>
< #include <wchar.h>
636a640,648
> 	pdnObject->dpnhLobbyConnection = NULL;
> 
> 	// Release our hold on the lobbiedapplication
> 	if( pdnObject->pIDP8LobbiedApplication) 
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release(pdnObject->pIDP8LobbiedApplication);
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 	}
> 
1077a1090,1093
> 	if (dwFlags & DPNCONNECT_OKTOQUERYFORADDRESSING)
> 	{
> 		dwConnectFlags |= DPNCONNECT_OKTOQUERYFORADDRESSING;
> 	}
1195d1210
< // BUGBUG: [mgere] [xbox] Set breakpoint here and see if it ever gets in here.
1211,1213d1225
< // BUGBUG: [mgere] [xbox] I know this is busted.  Remove this whole section about enumerating adapters
< // and check if it's ok.
< /*
1244d1255
< */
1844a1856,1863
> 	//	Update Lobby status
> 	//
> 	if (fWasConnected)
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_DISCONNECTED);
> 	}
> 
> 	//
2023c2042
< 	{
---
> 	{
2410,2411d2428
< // BUGBUG [mgere] [xbox] Temporarily removed until a CoCreateGuid call is implemented
< #ifdef _BUILD_FOR_WIN2000
2417d2433
< #endif
2480a2497,2505
> 	//	Inform DPNSVR of LISTENs
> 	//
> 	if( !(pdnObject->dnApplicationDescription.dwFlags & DPNSESSION_NODPNSVR) )
> 	{
> 		DPF(3,"Registering with DPNSVR");
> 		DNRegisterWithDPNSVR(pdnObject);
> 	}
> 
> 	//
2589a2615,2619
> 	//	Update Lobby status
> 	//
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_CONNECTED);
> 
> 	//
3866c3896
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
4023c4053
< 	pIHost->lpVtbl->GetURLW(pIHost,DP8ABuffer,&DP8ASize);
---
> 	pIHost->lpVtbl->GetURLA(pIHost,DP8ABuffer,&DP8ASize);
4027c4057
< 	pIDevice->lpVtbl->GetURLW(pIDevice,DP8ABuffer,&DP8ASize);
---
> 	pIDevice->lpVtbl->GetURLA(pIDevice,DP8ABuffer,&DP8ASize);
4091c4121
< 	//
---
> 	//
4109d4138
< // BUGBUG: [mgere] [xbox] Set breakpoint here and see if it ever gets in here.
4125,4127d4153
< // BUGBUG: [mgere] [xbox] I know this is busted.  Remove this whole section about enumerating adapters
< // and check if it's ok.
< /*
4159d4184
< */
4847c4872
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
4850c4875,4944
< 	return DPNERR_UNSUPPORTED;
---
> 	DIRECTNETOBJECT		*pdnObject;
> 	HRESULT             hResultCode;
> 
> 	DPF(3,"Parameters: pInterface [0x%p], pIDP8LobbiedApplication [0x%p], dwFlags [0x%lx]",
> 			pInterface,pIDP8LobbiedApplication,dwFlags);
> 
> 	TRY
> 	{
>     	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
>     	DNASSERT(pdnObject != NULL);
> 
>     	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
>     	{
>     	    if( FAILED( hResultCode = DN_ValidateRegisterLobby( pInterface, dpnhLobbyConnection, pIDP8LobbiedApplication, dwFlags ) ) )
>     	    {
>     	        DPFERR( "Error validating register lobby params" );
>     	        DPF_EXIT( hResultCode );
>     	    }
>     	}
> 
>     	// Check to ensure message handler registered
>     	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
>     	{
>     		DPFERR( "Object is not initialized" );
>     		DPF_EXIT(DPNERR_UNINITIALIZED);
>     	}
> 
> 	}
> 	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
> 	{
> 	    DPFERR("Invalid object" );
> 	    DPF_EXIT(DPNERR_INVALIDOBJECT);
> 	}	
> 
> 	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
> 	DNASSERT(pdnObject != NULL);
> 
> 	if (dwFlags == DPNLOBBY_REGISTER)
> 	{
> 		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 		if (pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE)
> 		{
> 			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 			return(DPNERR_ALREADYREGISTERED);
> 		}
> 				
> 		pIDP8LobbiedApplication->lpVtbl->AddRef(pIDP8LobbiedApplication);
> 
> 		pdnObject->pIDP8LobbiedApplication = pIDP8LobbiedApplication;
> 		pdnObject->dpnhLobbyConnection = dpnhLobbyConnection;
> 		pdnObject->dwFlags |= DN_OBJECT_FLAG_LOBBY_AWARE;
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	}
> 	else
> 	{
> 		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE))
> 		{
> 			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 			return(DPNERR_NOTREGISTERED);
> 		}
> 				
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release(pdnObject->pIDP8LobbiedApplication);
> 		pdnObject->dpnhLobbyConnection = NULL;
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_LOBBY_AWARE);
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	}
> 
> 	return(DPN_OK);
4852a4947,4969
> #undef DPF_MODNAME
> #define DPF_MODNAME "DNNotifyLobbyClientOfSettings"
> // 
> // DNNotifyLobbyClientOfSettings
> //
> // This function sends a connection settings update to the lobby client informing it that the lobby 
> // client settings have changed.  
> //
> HRESULT DNNotifyLobbyClientOfSettings(
> 	DIRECTNETOBJECT * const pdnObject,
> 	IDirectPlay8LobbiedApplication *pdpLobbiedApp, 
> 	DPNHANDLE dpnConnection, 
> 	IDirectPlay8Address *pHostAddress, 
> 	IDirectPlay8Address *pConnectFromAddress )
> {
> 	HRESULT						hResultCode = DPN_OK;
> 	DPL_CONNECTION_SETTINGS		dplConnectionSettings;
> 	BOOL						fIsHost = FALSE;
> 	CPackedBuffer				packBuffer;
> 	PBYTE						pBuffer = NULL;
> 	BOOL						fINCriticalSection = FALSE;
> 	CNameTableEntry				*pNTEntry = NULL;
> 	DWORD						dwIndex;
4853a4971,5116
> 	fIsHost = DN_CHECK_LOCALHOST( pdnObject );
> 
> 	ZeroMemory( &dplConnectionSettings, sizeof( DPL_CONNECTION_SETTINGS ) );
> 	dplConnectionSettings.dwSize = sizeof( DPL_CONNECTION_SETTINGS );
> 	dplConnectionSettings.dwFlags = (fIsHost) ? DPLCONNECTSETTINGS_HOST : 0;
> 
> 	// Lock the object while we make a copy of the app desc.  
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	fINCriticalSection = TRUE;
> 	
> 	packBuffer.Initialize(NULL, 0 );
> 
> 	// Determine the size of buffer
> 	hResultCode = DNPackApplicationDesc( &pdnObject->dnApplicationDescription, &packBuffer );
> 
> 	if( hResultCode != DPNERR_BUFFERTOOSMALL ) 
> 	{
> 		DPF( 0, "Error getting app desc size hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	pBuffer = new BYTE[packBuffer.GetSizeRequired()];
> 
> 	if( !pBuffer )
> 	{
> 		DPF( 0, "Error allocating memory for buffer" );
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	packBuffer.Initialize(pBuffer,packBuffer.GetSizeRequired());
> 
> 	hResultCode = DNPackApplicationDesc( &pdnObject->dnApplicationDescription, &packBuffer );
> 
> 	if( FAILED( hResultCode ) )
> 	{
> 		DPF( 0, "Error packing app desc hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	fINCriticalSection = FALSE;
> 
> 	memcpy( &dplConnectionSettings.dpnAppDesc, pBuffer, sizeof( DPN_APPLICATION_DESC ) );
> 
> 	hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pNTEntry );
> 
> 	if( FAILED( hResultCode ) )
> 	{
> 		DPF( 0, "Error getting local player hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	// Make sure player name isn't changed while we are working with the entry
> 	pNTEntry->Lock();
> 	if( pNTEntry->GetName() )
> 	{
> 		dplConnectionSettings.pwszPlayerName = new WCHAR[wcslen(pNTEntry->GetName())+1];
> 
> 		if( !dplConnectionSettings.pwszPlayerName )
> 		{
> 			pNTEntry->Unlock();
> 			DPF( 0, "Error allocating memory" );
> 			goto NOTIFY_EXIT;
> 		}
> 		
> 		wcscpy( dplConnectionSettings.pwszPlayerName, pNTEntry->GetName() );
> 	}
> 	else
> 	{
> 		dplConnectionSettings.pwszPlayerName = NULL;		
> 	}
> 	pNTEntry->Unlock();
> 
> 	// Release our reference
> 	pNTEntry->Release();
> 
> 	// Host address field
> 	if( fIsHost )
> 	{
> 		dplConnectionSettings.pdp8HostAddress = NULL;
> 
> 		hResultCode = DNGetHostAddressHelper( pdnObject, dplConnectionSettings.ppdp8DeviceAddresses, &dplConnectionSettings.cNumDeviceAddresses );
> 
> 		if( hResultCode != DPNERR_BUFFERTOOSMALL )
> 		{
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			DPF( 0, "Could not get host addresses for lobby update hr=0x%x", hResultCode );
> 			goto NOTIFY_EXIT;
> 		}
> 
> 		dplConnectionSettings.ppdp8DeviceAddresses = new IDirectPlay8Address*[dplConnectionSettings.cNumDeviceAddresses];
> 
> 		if( !dplConnectionSettings.ppdp8DeviceAddresses )
> 		{
> 			DPF( 0, "Error allocating memory" );
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			hResultCode = DPNERR_OUTOFMEMORY;
> 			goto NOTIFY_EXIT;
> 		}
> 
> 		hResultCode = DNGetHostAddressHelper( pdnObject, dplConnectionSettings.ppdp8DeviceAddresses, &dplConnectionSettings.cNumDeviceAddresses );
> 
> 		if( FAILED( hResultCode ) )
> 		{
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			DPF( 0, "Could not get host addresses for lobby update hr=0x%x", hResultCode );
> 			goto NOTIFY_EXIT;
> 		}
> 	}
> 	else
> 	{
> 		dplConnectionSettings.pdp8HostAddress = pHostAddress;
> 		dplConnectionSettings.ppdp8DeviceAddresses = &pConnectFromAddress;
> 		dplConnectionSettings.cNumDeviceAddresses = 1;	
> 	}
> 
> 	// Update the settings
> 	hResultCode = pdpLobbiedApp->lpVtbl->SetConnectionSettings( pdpLobbiedApp, dpnConnection, &dplConnectionSettings, 0 );
> 
> NOTIFY_EXIT:
> 
> 	if( dplConnectionSettings.ppdp8DeviceAddresses && fIsHost )
> 	{
> 		for( dwIndex = 0; dwIndex < dplConnectionSettings.cNumDeviceAddresses; dwIndex++ )
> 		{
> 			dplConnectionSettings.ppdp8DeviceAddresses[dwIndex]->lpVtbl->Release( dplConnectionSettings.ppdp8DeviceAddresses[dwIndex] );
> 		}
> 
> 		delete [] dplConnectionSettings.ppdp8DeviceAddresses;
> 	}
> 
> 	if( dplConnectionSettings.pwszPlayerName )
> 		delete [] dplConnectionSettings.pwszPlayerName;
> 
> 	if( fINCriticalSection ) 
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	if( pBuffer )
> 		delete [] pBuffer;
> 
> 	return hResultCode;
> 
> }
> 
> 
4854a5118,5198
> #define DPF_MODNAME "DNUpdateLobbyStatus"
> 
> HRESULT DNUpdateLobbyStatus(DIRECTNETOBJECT *const pdnObject,
> 							const DWORD dwStatus)
> {
> 	HRESULT		hResultCode;
> 	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
> 	DPNHANDLE dpnhLobbyConnection = NULL;
> 	IDirectPlay8Address *pHostAddress = NULL;
> 	IDirectPlay8Address *pConnectFromAddress = NULL;
> 
> 	DPF(4,"Parameters: dwStatus [0x%lx]",dwStatus);
> 
> 	DNASSERT(pdnObject != NULL);
> 
> 	pIDP8LobbiedApplication = NULL;
> 
> 	//
> 	//	Get lobbied application interface, if it exists and other settings we need
> 	//
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE) && (pdnObject->pIDP8LobbiedApplication))
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->AddRef(pdnObject->pIDP8LobbiedApplication);
> 		pIDP8LobbiedApplication = pdnObject->pIDP8LobbiedApplication;
> 		dpnhLobbyConnection = pdnObject->dpnhLobbyConnection;
> 
> 		pConnectFromAddress = pdnObject->pIDP8ADevice;
> 		pHostAddress = pdnObject->pConnectAddress;
> 
> 		if( pConnectFromAddress )
> 		{
> 			pConnectFromAddress->lpVtbl->AddRef( pConnectFromAddress );			
> 		}
> 
> 		if( pHostAddress )
> 		{
> 			pHostAddress->lpVtbl->AddRef( pHostAddress );
> 		}
> 	}
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	//
> 	//	Update status and release object
> 	//
> 	if (pIDP8LobbiedApplication)
> 	{
> 		// If we are about to do a connection notification
> 		// we send the updated connection settings.  
> 		// 
> 		// This gives lobby client full picture. 
> 		//
> 		if( dwStatus == DPLSESSION_CONNECTED )
> 		{
> 			DNNotifyLobbyClientOfSettings(pdnObject, pIDP8LobbiedApplication, dpnhLobbyConnection, pHostAddress, pConnectFromAddress );
> 		}
> 
> 		pIDP8LobbiedApplication->lpVtbl->UpdateStatus(pIDP8LobbiedApplication,dpnhLobbyConnection,dwStatus,0);
> 
> 		pIDP8LobbiedApplication->lpVtbl->Release(pIDP8LobbiedApplication);
> 		pIDP8LobbiedApplication = NULL;
> 
> 		if( pHostAddress )
> 		{
> 			pHostAddress->lpVtbl->Release( pHostAddress );
> 		}		
> 
> 		if( pConnectFromAddress )
> 		{
> 			pConnectFromAddress->lpVtbl->Release( pConnectFromAddress );
> 		}
> 	}
> 
> 	hResultCode = DPN_OK;
> 
> 	DPF(4,"Returning: [0x%lx]",hResultCode);
> 	return(hResultCode);
> }
> 
> 						
> #undef DPF_MODNAME
5199a5544,5673
> }
> 
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DNRegisterWithDPNSVR"
> 
> HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject)
> {
> 	HRESULT					hResultCode;
> 	HRESULT					hrRegister;
> 	CAsyncOp				*pListenParent;
> 	CAsyncOp				*pListenSP;
> 	CAsyncOp				*pListen;
> 	CBilink					*pBilinkSP;
> 	CBilink					*pBilink;
> 	SPGETADDRESSINFODATA	spInfo;
> #ifdef	DEBUG
> 	CHAR			DP8ABuffer[512];
> 	DWORD			DP8ASize;
> #endif
> 
> 	DPF(4,"Parameters: (none)");
> 
> 	pListenParent = NULL;
> 	pListenSP = NULL;
> 	pListen = NULL;
> 
> 	//
> 	//	Default error returned
> 	//
> 	hrRegister = DPNERR_GENERIC;
> 
> 	//
> 	//	Get LISTEN AsyncOp parent from DirectNet object and add a RefCount
> 	//
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	if (pdnObject->pListenParent == NULL)
> 	{
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 		goto Exit;
> 	}
> 	pdnObject->pListenParent->AddRef();
> 	pListenParent = pdnObject->pListenParent;
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	//
> 	//	Lock the parent so that the child bilink list doesn't change
> 	//
> 	pListenParent->Lock();
> 
> 	//
> 	//	Locate each child (LISTEN SP parent) and then each actual LISTEN
> 	//
> 	pBilinkSP = pListenParent->m_bilinkParent.GetNext();
> 	while (pBilinkSP != &pListenParent->m_bilinkParent)
> 	{
> 		pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);
> 
> DNASSERT(pListenSP->GetParent() == pListenParent);
> 		//
> 		//	Lock the SP parent so that the child bilink doesn't change
> 		//
> 		pListenSP->Lock();
> 
> 		pBilink = pListenSP->m_bilinkParent.GetNext();
> 		while (pBilink != &pListenSP->m_bilinkParent)
> 		{
> 			pListen = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
> 
> 			DNASSERT(pListen->GetProtocolHandle() != NULL);
> 
> 			spInfo.hEndpoint = pListen->GetProtocolHandle();
> 			spInfo.pAddress = NULL;
> 			spInfo.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;
> 
> 			if (DNPGetListenAddressInfo(pListen->GetProtocolHandle(),&spInfo) == DPN_OK)
> 			{
> 				DNASSERT(spInfo.pAddress != NULL);
> #ifdef	DEBUG
> 				DP8ASize = 512;
> 				spInfo.pAddress->lpVtbl->GetURLA(spInfo.pAddress,DP8ABuffer,&DP8ASize);
> 				DPF(4,"Listen address [%s]",DP8ABuffer);
> 
> 				// We re-try the registration to catch the case where DPNSVR is shutting
> 				// down while we are trying to register.  Unlikely but has to be handled.
> 				//
> #endif
> 	            for( DWORD dwRetry = 0; dwRetry < DPNSVR_REGISTER_ATTEMPTS ; dwRetry ++ )
> 		        {
>     				hResultCode = DPNSVR_Register( &pdnObject->dnApplicationDescription, spInfo.pAddress );
> 	    			if( FAILED( hResultCode ) )
> 					{
>     					if( dwRetry < DPNSVR_REGISTER_ATTEMPTS )
>     					{
> 	    					DPF( 0, "Unable to register ourselves with DPNSVR hr=0x%x, retrying", hResultCode );    				
> 	    					Sleep( DPNSVR_REGISTER_SLEEP );    				
> 	    				}
> 						else
>     					{
> 	    					DPF( 0, "Unable to register ourselves with DPNSVR hr=0x%x", hResultCode );
> 	    				}
> 	    			}
> 					else
>     				{
>     					// Return DPN_OK if we succeed even once
>     					hrRegister = hResultCode;
>     					break;
> 	    			}
> 		        }
> 			
> 				spInfo.pAddress->lpVtbl->Release(spInfo.pAddress);
> 				spInfo.pAddress = NULL;
> 
> 			}
> 			pBilink = pBilink->GetNext();
> 		}
> 
> 		pListenSP->Unlock();
> 
> 		pBilinkSP = pBilinkSP->GetNext();
> 	}
> 
> 	pListenParent->Unlock();
> 
> 	pListenParent->Release();
> 	pListenParent = NULL;
> 
> Exit:
> 	DPF(4,"Returning: [0x%lx]",hrRegister);
> 	return( hrRegister );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
205c205
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
207a208,210
> HRESULT DNUpdateLobbyStatus(DIRECTNETOBJECT *const pdnObject,
> 							const DWORD dwStatus);
> 
216a220,221
> 
> HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
84a85
> #include "DPLobby8.h"
113d113
< #include <wchar.h>
117,120d116
< #define CompareGuid(a,b)                                         \
<     (memcmp((PVOID)(a), (PVOID)(b), sizeof(GUID)))
< 
< 
189c185
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
264,265c260,261
< 		if ((hResultCode = pAddress->lpVtbl->BuildFromURLW(	pAddress,
< 															static_cast<WCHAR*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
---
> 		if ((hResultCode = pAddress->lpVtbl->BuildFromURLA(	pAddress,
> 															static_cast<char*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
292c288
< 		pAddress->lpVtbl->GetURLW(pAddress,DP8ABuffer,&DP8ASize);
---
> 		pAddress->lpVtbl->GetURLA(pAddress,DP8ABuffer,&DP8ASize);
725c721
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
810c806
< 	if (pguidInstance && CompareGuid(pguidInstance,&GUID_NULL))
---
> 	if (pguidInstance && !UuidIsNil(pguidInstance,&rpcStatus))
823c819
< 	if (pguidApplication && CompareGuid(pguidApplication,&GUID_NULL))
---
> 	if (pguidApplication && !UuidIsNil(pguidApplication,&rpcStatus))
880c876
< 		pDevice->lpVtbl->GetURLW(pDevice,DP8ABuffer,&DP8ASize);
---
> 		pDevice->lpVtbl->GetURLA(pDevice,DP8ABuffer,&DP8ASize);
1183c1179
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
1208,1209c1204
< 				pAddress->lpVtbl->GetURLW(pAddress,NULL,&dwAddressSize);
< 				dwAddressSize = dwAddressSize * sizeof(WCHAR);
---
> 				pAddress->lpVtbl->GetURLA(pAddress,NULL,&dwAddressSize);
1213c1208
< 				pAddress->lpVtbl->GetURLW(pAddress,DP8ABuffer,&DP8ASize);
---
> 				pAddress->lpVtbl->GetURLA(pAddress,DP8ABuffer,&DP8ASize);
1340,1341c1335,1336
< 		if ((hResultCode = pAddress->lpVtbl->GetURLW(pAddress,
< 													static_cast<WCHAR*>(packedBuffer.GetTailAddress()),
---
> 		if ((hResultCode = pAddress->lpVtbl->GetURLA(pAddress,
> 													static_cast<char*>(packedBuffer.GetTailAddress()),
1704a1700,1704
> 	//	Update Lobby status
> 	//
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_CONNECTED);
> 
> 	//
1970a1971,1979
> 	if (fWasConnected)
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_DISCONNECTED);
> 	}
> 	else
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_COULDNOTCONNECT);
> 	}	
> 
2832c2841
< 	WCHAR					DP8ABuffer[512];
---
> 	CHAR					DP8ABuffer[512];
2866c2875
< 		(*ppAddress)->lpVtbl->GetURLW(*ppAddress,DP8ABuffer,&DP8ASize);
---
> 		(*ppAddress)->lpVtbl->GetURLA(*ppAddress,DP8ABuffer,&DP8ASize);
2889c2898
< 	WCHAR					DP8ABuffer[512];
---
> 	CHAR					DP8ABuffer[512];
2916c2925
< 		(*ppAddress)->lpVtbl->GetURLW(*ppAddress,DP8ABuffer,&DP8ASize);
---
> 		(*ppAddress)->lpVtbl->GetURLA(*ppAddress,DP8ABuffer,&DP8ASize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dllmain.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "creg.h"
42a44,180
> #undef DPF_MODNAME
> #define DPF_MODNAME "RegisterDefaultSettings"
> //
> // RegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT RegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create app sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		return DPN_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "UnRegisterDefaultSettings"
> //
> // UnRegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT UnRegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot remove app, does not exist" );
> 	}
> 	else
> 	{
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_SP_SUB)[1] ) )
> 		{
> 			DPFERR( "Cannot remove cp sub-key, could have elements" );
> 		}
> 	}
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Client.1", L"DirectPlay8Client Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Client, L"DirectPlay8.Client") )
> 	{
> 		DPFERR( "Could not register dp8 client object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Server.1", L"DirectPlay8Server Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Server, L"DirectPlay8.Server") )
> 	{
> 		DPFERR( "Could not register dp8 Server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Peer.1", L"DirectPlay8Peer Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Peer, L"DirectPlay8.Peer") )
> 	{
> 		DPFERR( "Could not register dp8 client object" );
> 		fFailed = TRUE;
> 	}
> 
> 
> 	if( FAILED( hr = RegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Could not register default settings hr = 0x%x", hr );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Client) )
> 	{
> 		DPF( 0, "Failed to unregister client object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Server) )
> 	{
> 		DPF( 0, "Failed to unregister server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Peer) )
> 	{
> 		DPF( 0, "Failed to unregister peer object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = UnRegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Failed to remove default settings hr=0x%x", hr );
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
103a104,106
> #define DN_REG_LOCAL_SP_ROOT				L"Software\\Microsoft\\DirectPlay8"
> #define DN_REG_LOCAL_SP_SUB					L"\\Service Providers"
> #define DN_REG_LOCAL_SP_SUBKEY				DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB
104a108,112
> #define	DN_REG_KEYNAME_ADAPTER_LIST			L"Adapter List"
> #define	DN_REG_KEYNAME_ALL_APPLICATIONS		L"All Applications"
> #define	DN_REG_KEYNAME_FRIENDLY_NAME		L"Friendly Name"
> #define DN_REG_KEYNAME_GUID					L"GUID"
> 
127a136
> typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
266a276
> 	// Lobby additions
267a278,281
> 	DPNHANDLE				dpnhLobbyConnection;	// Lobby Connection to update
> 
> 	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
5a6,8
> 	DllRegisterServer	PRIVATE
> 	DllUnregisterServer	PRIVATE
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnet.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,62
> 
> #endif
> 
> #endif    // !_MAC
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
44a45
> #include "DNMisc.h"
46a48
> #include "CReg.h"
60c62,71
< // BUGBUG: [xbox] [mgere] Removed since we don't support registry
---
> 	DWORD	dwAllAppLen;
> 	WCHAR	lpwszAllAppStr[DN_FLAG_STR_LEN+1];
> 
> 	dwAllAppLen = (DN_FLAG_STR_LEN + 1) * sizeof(WCHAR);
> 	if (RegQueryValueExW(hSPKey,DN_REG_KEYNAME_ALL_APPLICATIONS,NULL,NULL,(PBYTE)lpwszAllAppStr,&dwAllAppLen) != ERROR_SUCCESS)
> 		return(FALSE);
> 
> 	if (towupper(lpwszAllAppStr[0]) == L'N')
> 		return(TRUE);
> 
75,76c86
< // BUGBUG:  [mgere] [xbox] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
78c88,98
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
80,81c100,103
<     WCHAR wszSP[] = L"DirectPlay8 TCP/IP Service Provider";
< 	GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
> //	CServiceProvider	*pSP;
89a112,115
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
> //	pSP = NULL;
> 
93,94c119,124
< 	hResultCode = packedBuffer.AddToBack(wszSP,(wcslen(wszSP)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,TRUE,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
96c126,153
< 	memcpy(&dnSpInfo.guid,&guidSP,sizeof(GUID));
---
> 	//
> 	//	Set up to enumerate
> 	//
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(5,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
98,101c155,168
< 	dnSpInfo.dwFlags = 0;
< 	dnSpInfo.dwReserved = 0;
< 	dnSpInfo.pvReserved = NULL;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	//
> 	//	Enumerate SP's !
> 	//
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(5,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,TRUE,FALSE))
> 		{
> 			DPF(0,"Couldn't open subentry.  Skipping [%S]", pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
102a170,264
> 		//
> 		//	GUID
> 		//
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPF(0,"SubEntry.ReadGUID failed.  Skipping [%S]", pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		//
> 		//	Attempt to instantiate SP and initialize it, to ensure that it is in fact usable.
> 		//
> 		if (!(dwFlags & DPNENUMSERVICEPROVIDERS_ALL))
> 		{
> 			hResultCode = DN_SPEnsureLoaded(pdnObject,&guid,NULL,TRUE);
> 			if (hResultCode != DPN_OK)
> 			{
> 				DPF(0,"Could not load SP.  Skipping [%S]", pwszKeyName);
> 				SubEntry.Close();
> 				dwEnumIndex++;
> 				dwKeyLen = dwMaxKeyLen;
> 				hResultCode = DPN_OK; // override return code
> 				continue;
> 			}
> 			else
> 			{
> //				DN_SPRelease(pdnObject,&guid);
> 			}
> 		}
> 
> 		//
> 		//	Friendly Name
> 		//
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(5,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		DPF(5,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
> /*	REMOVE
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = static_cast<GUID*>(packedBuffer.GetTailAddress());
> */
> 		memcpy(&dnSpInfo.guid,&guid,sizeof(GUID));
> 		dnSpInfo.dwFlags = 0;
> 		dnSpInfo.dwReserved = 0;
> 		dnSpInfo.pvReserved = NULL;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
> 	//
> 	//	Success ?
> 	//
108c270
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
110c272
< 		goto Exit;
---
> 		goto Failure;
114c276,277
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
> 		hResultCode = DPN_OK;
117,123d279
< 			hResultCode = DN_SPEnsureLoaded(pdnObject,&guidSP,NULL,TRUE);
< 			if (hResultCode != DPN_OK)
< 			{
< 				DPF(0,"Could not load SP.  Skipping [%S]", pwszKeyName);
< 				hResultCode = DPN_OK; // override return code
< 			}
< 
125a282,286
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
> 	DNFree(pwszFriendlyName);
> 	pwszFriendlyName = NULL;
> 
128a290,311
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
142,146d324
< // BUGBUG
< // [mgere] [xbox] Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
296d473
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\migration.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
81a82,84
> #include "dpnsvrq.h"
> #include "dpnsdef.h"
> #include "dpnsvlib.h"
82a86
> #include "dplobby8.h"
281a286
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_HOSTMIGRATEDHERE);	
680a686,705
> 	// Register with DPNSVR
> 	if( !(pdnObject->dnApplicationDescription.dwFlags & DPNSESSION_NODPNSVR) )
> 	{
> 		BOOL	fCoUninitialize = FALSE;
> 
> 		DPF( 7, "Asking for DPNSVR to start listening for us.." );
> 
> 		if (COM_CoInitialize(NULL) == S_OK)
> 		{
> 			fCoUninitialize = TRUE;
> 		}
> 
> 		DNRegisterWithDPNSVR(pdnObject);
> 
> 		if (fCoUninitialize)
> 		{
> 			COM_CoUninitialize();
> 		}
> 	}
> 
772a798,802
> 
> 	// 
> 	// Indicate to lobby (if there is one) that a host migration has occured
> 	//
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_HOSTMIGRATED);		
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\msghandler.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1148c1148
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1164c1164
< 	pHostAddress->lpVtbl->GetURLW(pHostAddress,DP8ABuffer,&DP8ASize);
---
> 	pHostAddress->lpVtbl->GetURLA(pHostAddress,DP8ABuffer,&DP8ASize);
1168c1168
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
1199c1199
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1215c1215
< 	pHostAddress->lpVtbl->GetURLW(pHostAddress,DP8ABuffer,&DP8ASize);
---
> 	pHostAddress->lpVtbl->GetURLA(pHostAddress,DP8ABuffer,&DP8ASize);
1219c1219
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
1248c1248
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1264c1264
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\ntentry.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
424,425c424
< 		hResultCode = m_pAddress->lpVtbl->GetURLW(m_pAddress,NULL,&dwURLSize);
< 		dwURLSize = dwURLSize * sizeof(WCHAR);
---
> 		hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,NULL,&dwURLSize);
437,438c436,437
< 				if ((hResultCode = m_pAddress->lpVtbl->GetURLW(m_pAddress,
< 						static_cast<WCHAR*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
---
> 				if ((hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,
> 						static_cast<char*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
525c524
< 		hResultCode = pAddress->lpVtbl->BuildFromURLW(pAddress,reinterpret_cast<WCHAR*>(pBufferStart + pdnEntryInfo->dwURLOffset));
---
> 		hResultCode = pAddress->lpVtbl->BuildFromURLA(pAddress,reinterpret_cast<char*>(pBufferStart + pdnEntryInfo->dwURLOffset));
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
212c212
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
220a221,227
>     if( pIDP8LobbiedApplication != NULL &&
>         !DNVALID_READPTR( pIDP8LobbiedApplication, sizeof( IDirectPlay8LobbiedApplication * ) ) )
>     {
>         DPFERR( "Invalid interface pointer specified for register lobby" );
>         return DPNERR_INVALIDPOINTER;
>     }
> 
246a254,259
> 
> 	    if( !pIDP8LobbiedApplication )
> 	    {
> 	    	DPFERR( "You must specify a lobby application interface to use" );
> 	    	return DPNERR_INVALIDPOINTER;
> 	    }
1062c1075
<     if( dwFlags & ~(DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
---
>     if( dwFlags & ~(DPNENUMHOSTS_OKTOQUERYFORADDRESSING | DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
1600a1614,1619
>     if( ( dwFlags & ~( DPNHOST_OKTOQUERYFORADDRESSING ) ) != 0 )
>     {
>         DPFERR("Invalid flags specified" );
>         return( DPNERR_INVALIDFLAGS );
>     }
> 
1813c1832
<     if( dwFlags & ~(DPNCONNECT_SYNC) )
---
>     if( dwFlags & ~(DPNCONNECT_SYNC | DPNCONNECT_OKTOQUERYFORADDRESSING) )
2129c2148
<     if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD) )
---
>     if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD | DPNSESSION_NODPNSVR) )
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
47c47
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\peer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
69d68
< #include <wchar.h>
120c119
< typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\server.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62d61
< #include <wchar.h>
111c110
< typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2,3c17,27
< TARGETPATHLIB=$(BASEDIR)\public\sdk\lib
< TARGETTYPE=DYNLINK
---
> DLLDEF=..\dnet.def
> UMTYPE=windows
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
4a29
> TARGETTYPE=DYNLINK
6,14c31,35
< !ifdef _BUILD_FOR_WIN2000
< UMTYPE=windows
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
16c37
< INCLUDES=..\;..\..\inc;..\..\protocol;..\..\common;..\..\..\dvoice\inc
---
> PASS1_PUBLISH={ $(O)\dpnet.lib = $(SDK_LIB_PATH)\dpnet.lib}
18c39,56
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
> 	   ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
>            ..\..\protocol\obj$(BUILD_ALT_DIR)\*\protocol.lib \
>            ..\..\dpnsvr\dpnsvlib\obj$(BUILD_ALT_DIR)\*\dpnsvlib.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
20d57
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
22,23c59,60
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
26c63,67
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28c69
< DLLDEF=..\dnet.def
---
> INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\protocol;..\..\common;..\..\dpnsvr\dpnsvlib;..\..\dpnsvr\inc
29a71,78
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
70a120,127
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
73,94c130,132
< TARGETLIBS= \
< 	   ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
<            ..\..\protocol\obj$(BUILD_ALT_DIR)\*\protocol.lib \
<            $(BASEDIR)\public\sdk\lib\*\dpnaddr.lib \
<            ..\..\sp\wsock\daytona\obj$(BUILD_ALT_DIR)\*\dpnwsock.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<              $(SDK_LIB_PATH)\libcntpr.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addbase.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
260d259
< /* BUGBUG: [mgere] [xbox] Removed this function.
291d289
< */  return DPNERR_UNSUPPORTED;
302,303c300,359
< // BUGBUG: [mgere] [xbox] ANSI not supported
< 	return DPNERR_UNSUPPORTED;
---
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pszAddress == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer to address.  An address must be specified" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( !DNVALID_STRING_A( pszAddress ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid string specified for address" );
> 		DP8A_RETURN( DPNERR_INVALIDSTRING );
> 	}
> 
> 	DPF( DP8A_PARAMLEVEL, "pszAddress = %s", pszAddress );
> 
> 	WCHAR *szShadowBuffer = NULL;
> 
> 	DWORD dwStrSize = 0;
> 
> 	if( pszAddress != NULL )
> 	{
> 		dwStrSize = strlen(pszAddress)+1;
> 		
> 		szShadowBuffer = new WCHAR[dwStrSize];
> 
> 		if( szShadowBuffer == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto BUILDFROMURLW_RETURN;
> 		}
> 
> 		if( FAILED( hr = STR_jkAnsiToWide( szShadowBuffer, pszAddress, dwStrSize ) )  )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting URL to ANSI hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 			goto BUILDFROMURLW_RETURN;
> 		}
> 	}
> 
> 	hr = pdp8Address->SetURL( szShadowBuffer );
> 
> BUILDFROMURLW_RETURN:
> 
> 	if( szShadowBuffer )
> 		delete [] szShadowBuffer;
> 
> 	DP8A_RETURN( hr );	
448,449c504,571
< // BUGBUG: [mgere] [xbox] ANSI not supported.
< 	return DPNERR_UNSUPPORTED;
---
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pdwAddressSize == NULL ||
> 	   !DNVALID_WRITEPTR( pdwAddressSize, sizeof(DWORD) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for address size" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
> 	}
> 
> 	if( *pdwAddressSize > 0 &&
> 	   (pszAddress == NULL ||
> 	    !DNVALID_WRITEPTR( pszAddress, (*pdwAddressSize) ) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for address" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
> 	DPF( DP8A_PARAMLEVEL, "pwszAddress = 0x%p pdwAddressSize = 0x%p (%u)",
> 	     pszAddress , pdwAddressSize, *pdwAddressSize );
> 
> 	WCHAR *szShadowBuffer = NULL;
> 
> 	if( *pdwAddressSize  != 0 )
> 	{
> 		szShadowBuffer = new WCHAR[*pdwAddressSize];
> 
> 		if( szShadowBuffer == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto GETURLW_RETURN;
> 		}
> 	}
> 	else
> 	{	
> 		szShadowBuffer= NULL;
> 	}
> 
> 	hr = pdp8Address->BuildURL( szShadowBuffer, pdwAddressSize );
> 
> 	if( hr == DPN_OK )
> 	{
> 		if( FAILED( hr = STR_jkWideToAnsi( pszAddress, szShadowBuffer, *pdwAddressSize ) ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting ANSI->WIDE hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 			goto GETURLW_RETURN;
> 		}
> 	}
> 	
> GETURLW_RETURN:
> 
> 	if( szShadowBuffer != NULL )
> 		delete [] szShadowBuffer;
> 
> 	DP8A_RETURN( hr );
873c995,996
< 	   dwDataType != DPNA_DATATYPE_BINARY )
---
> 	   dwDataType != DPNA_DATATYPE_BINARY &&
> 	   dwDataType != DPNA_DATATYPE_STRING_ANSI )
887a1011,1024
> 		{
> 			DPF( DP8A_ERRORLEVEL, "String size and component size don't match" );
> 			DP8A_RETURN( DPNERR_INVALIDPARAM );
> 		}
> 	}
> 	else if( dwDataType == DPNA_DATATYPE_STRING_ANSI )
> 	{
> 		if( !DNVALID_STRING_A( (const CHAR * const) pComponentData ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Invalid string component specified" );
> 			DP8A_RETURN( DPNERR_INVALIDSTRING );
> 		}
> 
> 		if( ((strlen( (const CHAR * const) pComponentData)+1)*sizeof(char)) != dwComponentSize )
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50
> #include <stdio.h>
50a52
> #include "dplegacy.h"
52d53
< #include <wchar.h>
400a402,420
> 	case DPNA_DATATYPE_STRING_ANSI:
>         wszUnicodeString = new WCHAR[dwRealDataSize];
>         if( wszUnicodeString == NULL )
>         {
>             DPF( 0, "Error allocating memory for conversion" );
>             return DPNERR_OUTOFMEMORY;
>         }
> 
> 		hr = STR_jkAnsiToWide( wszUnicodeString, (const char * const) pvData, dwRealDataSize );
> 
> 		if( FAILED( hr ) )
> 		{
> 		    DPF( 0, "Error unable to convert element ANSI->Unicode 0x%x", hr );
>             return DPNERR_CONVERSION;
> 		}
> 		pvRealData = wszUnicodeString;
> 	    dwRealDataSize = dwDataSize*sizeof(WCHAR);
> 		dwRealDataType = DPNA_DATATYPE_STRING;
> 	    break;
424a445,456
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     hr= SetSP( &CLSID_DP8SP_IPX );
>                 }
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_MODEMPROVIDER ) == 0 )
>                 {
>                     hr = SetSP( &CLSID_DP8SP_MODEM );
>                 }
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_SERIALPROVIDER ) == 0 )
>                 {
>                     hr = SetSP( &CLSID_DP8SP_SERIAL );
>                 }
1378a1411,1479
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ADDRESSOBJECT::SetDirectPlay4Address"
> HRESULT DP8ADDRESSOBJECT::SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize )
> {
>     PBYTE pbCurrentLocation;
>     PDPADDRESS pdpAddressChunk;
>     LONG lRemaining;
>     HRESULT hr = DPN_OK;
>     DWORD dwCurrentChunkSize;
>     DWORD dwNumElementsParsed = 0;
> 
> 	if( IsLocked() )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
> 		return DPNERR_NOTALLOWED;
> 	}
> 
>     // XBOX! This function will not be required on XBOX.  Have it return DPNERR_NOTSUPPORTED
>     ENTERLOCK();
> 
>     hr = Clear();
> 
>     if( FAILED( hr ) )
>     {
>         DPF( 0, "Failed to clear old address data hr=[0x%lx]", hr );
>         LEAVELOCK();
>         return hr;
>     }
> 
>     pbCurrentLocation = (PBYTE) pvDataBuffer;
>     lRemaining = dwDataSize;
> 
>     while( lRemaining > 0 )
>     {
>         pdpAddressChunk = (PDPADDRESS) pbCurrentLocation;
> 
>         if( sizeof( DPADDRESS ) > lRemaining )
>         {
>             DPF( 0, "Error parsing address, unexpected end of address" );
> 			LEAVELOCK();
>             return DPNERR_INVALIDADDRESSFORMAT;
>         }
> 
>         dwCurrentChunkSize = sizeof( DPADDRESS ) + pdpAddressChunk->dwDataSize;
> 
>         if( ((LONG) dwCurrentChunkSize) > lRemaining )
>         {
>             DPF( 0, "Error parsing address, unexpected end during data" );
> 			LEAVELOCK();
>             return DPNERR_INVALIDADDRESSFORMAT;
>         }
> 
>         hr = AddDP4Element( pdpAddressChunk, this );
> 
>         if( FAILED( hr ) )
>         {
>             DPF( 0, "Error adding next element" );
>             break;
>         }
> 
>         lRemaining -= dwCurrentChunkSize;
> 
>         pbCurrentLocation += dwCurrentChunkSize;
>     }
> 
>     LEAVELOCK();
> 
>     return hr;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
143a144,145
>     HRESULT SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addparse.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
27c27
< #include <wchar.h>
---
> #include <stdio.h>
569d568
< // BUGBUG: [mgere] [xbox] Removed wtol temporarily until it is implemented on xbox
571d569
< #ifdef _BUILD_FOR_WIN2000
573d570
< #endif
581,582d577
< // BUGBUG: [mgere] [xbox] Removed swscanf temporarily until it is implemented on xbox
< #ifdef _BUILD_FOR_WIN2000
607d601
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
24a25,31
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DPNAddress"
> 
> /*
31a39,67
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNAddress"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNAddress"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dllmain.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
29a30
> #include "creg.h"
38a40,87
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8Address.Address.1", L"DirectPlay8Address Object", 
> 							  L"dpnaddr.dll", CLSID_DirectPlay8Address, L"DirectPlay8Address.Address") )
> 	{
> 		DPFERR( "Could not register address object" );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Address) )
> 	{
> 		DPF( 0, "Failed to unregister server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
5a6,8
> 	DirectPlay8AddressCreate	@1
> 	DllRegisterServer	PRIVATE
> 	DllUnregisterServer PRIVATE
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnaddr.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address \0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,61
> 
> #endif
> 
> #endif    // !_MAC
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2,3c17,27
< TARGETPATHLIB=$(BASEDIR)\public\sdk\lib
< TARGETTYPE=DYNLINK
---
> DLLDEF=..\dnadd.def
> UMTYPE=windows
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
4a29
> TARGETTYPE=DYNLINK
6,14c31,35
< !ifdef _BUILD_FOR_WIN2000
< UMTYPE=windows
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
16c37
< INCLUDES=..\;..\..\inc;..\..\common;..\..\..\dvoice\inc
---
> PASS1_PUBLISH={ $(O)\dpnaddr.lib = $(SDK_LIB_PATH)\dpnaddr.lib}
18c39,54
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
>            ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\wsock32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
20d55
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
22,23c57,58
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
26c61,65
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28c67
< DLLDEF=..\dnadd.def
---
> INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\common
29a69,76
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
38a86
>          ..\dplegacy.cpp \
40a89,95
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
> 
> USER_C_FLAGS=-nologo -W3
43,62c98,100
< TARGETLIBS= \
<            ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\winsockx.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
99a100
> #define DPNA_DATATYPE_STRING_ANSI           0x00000005
131a133,168
> // values for baud rate
> #define DPNA_BAUD_RATE_110					110
> #define DPNA_BAUD_RATE_300					300
> #define DPNA_BAUD_RATE_600					600
> #define DPNA_BAUD_RATE_1200					1200
> #define DPNA_BAUD_RATE_2400					2400
> #define DPNA_BAUD_RATE_4800					4800
> #define DPNA_BAUD_RATE_9600					9600
> #define DPNA_BAUD_RATE_14400				14400
> #define DPNA_BAUD_RATE_19200				19200
> #define DPNA_BAUD_RATE_38400				38400
> #define DPNA_BAUD_RATE_56000				56000
> #define DPNA_BAUD_RATE_57600				57600
> #define DPNA_BAUD_RATE_115200				115200
> #define DPNA_BAUD_RATE_128000				128000
> #define DPNA_BAUD_RATE_256000				256000
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE					L"1"
> #define DPNA_STOP_BITS_ONE_FIVE				L"1.5"
> #define DPNA_STOP_BITS_TWO					L"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE					L"NONE"
> #define DPNA_PARITY_EVEN					L"EVEN"
> #define DPNA_PARITY_ODD						L"ODD"
> #define DPNA_PARITY_MARK					L"MARK"
> #define DPNA_PARITY_SPACE					L"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE				L"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF			L"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS				L"RTS"
> #define DPNA_FLOW_CONTROL_DTR				L"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR			L"RTSDTR"
> 
136a174,227
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
> 
> 
> //// ANSI DEFINITIONS
> 
> // Header
> #define DPNA_HEADER_A						"x-directplay:/"
> #define DPNA_SEPARATOR_KEYVALUE_A			'='
> #define DPNA_SEPARATOR_USERDATA_A			'#'
> #define DPNA_SEPARATOR_COMPONENT_A			';'
> #define DPNA_ESCAPECHAR_A					'%'
> 
> // key names for address components
> #define DPNA_KEY_APPLICATION_INSTANCE_A		"applicationinstance"
> #define DPNA_KEY_BAUD_A						"baud"
> #define DPNA_KEY_DEVICE_A					"device"
> #define DPNA_KEY_FLOWCONTROL_A				"flowcontrol"
> #define DPNA_KEY_HOSTNAME_A					"hostname"
> #define DPNA_KEY_PARITY_A					"parity"
> #define DPNA_KEY_PHONENUMBER_A				"phonenumber"
> #define DPNA_KEY_PORT_A						"port"
> #define DPNA_KEY_PROGRAM_A					"program"
> #define DPNA_KEY_PROVIDER_A					"provider"
> #define DPNA_KEY_STOPBITS_A					"stopbits"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE_A				"1"
> #define DPNA_STOP_BITS_ONE_FIVE_A			"1.5"
> #define DPNA_STOP_BITS_TWO_A				"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE_A					"NONE"
> #define DPNA_PARITY_EVEN_A					"EVEN"
> #define DPNA_PARITY_ODD_A					"ODD"
> #define DPNA_PARITY_MARK_A					"MARK"
> #define DPNA_PARITY_SPACE_A					"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE_A			"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF_A 		"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS_A				"RTS"
> #define DPNA_FLOW_CONTROL_DTR_A				"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR_A			"RTSDTR"
> 
> // Shortcut values
> //
> // These can be used instead of the corresponding CLSID_DP8SP_XXXX guids
> //
> #define DPNA_VALUE_TCPIPPROVIDER_A          "IP"
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
> #define DPNA_VALUE_MODEMPROVIDER_A          "MODEM"
> #define DPNA_VALUE_SERIALPROVIDER_A         "SERIAL"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
180a181,189
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {6D4A3650-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_MODEM, 0x6d4a3650, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> // {743B5D60-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_SERIAL, 0x743b5d60, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
206a216
> typedef struct IDirectPlay8LobbiedApplication	*PDNLOBBIEDAPPLICATION;
316a327
> #define	DPNCONNECT_OKTOQUERYFORADDRESSING	0x0001
337a349
> #define	DPNENUMHOSTS_OKTOQUERYFORADDRESSING	0x0001
360a373
> #define	DPNHOST_OKTOQUERYFORADDRESSING		0x0001
407a421
> #define DPNSESSION_NODPNSVR					0x0040
913c927
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
958c972
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
1008c1022
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpsp8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
56a57
> #define DPNSPF_OKTOQUERY			0x00000002		// OK for SP to ask the user for clarification on addresses
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
105c105
< 	DNASSERT( ulFlags == 0 );
---
> 	DNASSERT( ( ulFlags & ~( DPNCONNECT_OKTOQUERYFORADDRESSING ) ) == 0 );
106a107,111
> 	if ( ( ulFlags & DPNCONNECT_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		ConnData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\enum.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
117a118,122
> 	if ( ( dwFlags & DPNENUMHOSTS_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		EnumData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\initialize.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
357c357
< 		if((pSPD->hSendEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL){
---
> 		if((pSPD->hSendEvent = CreateEventA(NULL, FALSE, FALSE, NULL)) == NULL){
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2c17,26
< TARGETTYPE=LIBRARY
---
> 
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
3a28
> TARGETTYPE=LIBRARY
5,9d29
< !ifdef _BUILD_FOR_WIN2000
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< LINKER_FLAGS=-align:32
< !endif
11c31,35
< INCLUDES=..\common;..\inc;..\dnaddress
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
13c37,41
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE -DMICHAEL
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS)
15d42
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
17,18c44,55
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> 
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
> 
> INCLUDES=$(DXROOT)\inc;..\common;..\inc;..\dnaddress
> 
> 
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
21c58,63
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
34c76,78
< USE_NOLIBS=1
---
> #
> # Next specify options for the compiler.
> #
36c80,86
< TARGETLIBS=
---
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE /DMICHAEL
> MSC_OPTIMIZATION=/Odi /Zi
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\timer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
578c578
< 	hWorkToDoSem=CreateSemaphore(NULL,0,65535,NULL);
---
> 	hWorkToDoSem=CreateSemaphoreA(NULL,0,65535,NULL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
198,199c198,228
< // BUGBUG: [mgere] [xbox]  Removed all code in here.  I don't believe it's necessary anymore and it was using some COM functions that we don't have.
< 	return S_OK;
---
>     HRESULT		hr;
>     HINSTANCE	hdll;
>     LPGPCLASSFACTORY	pcf;
> 
> 
>     pcf = (LPGPCLASSFACTORY) This;
> 
>     /*
>      * call CoLockObjectExternal
>      */
>     hr = E_UNEXPECTED;
>     hdll = LoadLibraryA( "OLE32.DLL" );
>     if( hdll != NULL )
>     {
>         PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;
> 
> 
> 		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, "CoLockObjectExternal" ) );
>         if( lpCoLockObjectExternal != NULL )
>         {
>             hr = lpCoLockObjectExternal( (LPUNKNOWN) This, fLock, TRUE );
>         }
>         else
>         {
>         }
>     }
>     else
>     {
>     }
> 
> 	return hr;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
30a38,66
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNSPWinsock"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectDPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNSPWinsock"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
120a122,141
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( dwDebugLevel, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
> 					);
> 			break;
> 		}
> 
144,145d164
< // BUGBUG: [mgere] [xbox] Must convert this to unicode
< /*
193d211
< */
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> #include "resource.h"
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #include "windows.h"
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnwsock.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,153
> 
> #endif
> 
> #endif    // !_MAC
> 
> 
> 
> #ifdef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // TEXTINCLUDE
> //
> 
> 1 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "resource.h\0"
> END
> 
> 2 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "#include ""afxres.h""\r\n"
>     "\0"
> END
> 
> 3 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "\r\n"
>     "\0"
> END
> 
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // Dialog
> //
> 
> IDD_IP_SETTINGS DIALOG DISCARDABLE  0, 0, 194, 66
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION | 
>     WS_SYSMENU
> CAPTION "Enter host name"
> FONT 8, "MS Shell Dlg"
> BEGIN
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
> END
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // DESIGNINFO
> //
> 
> #ifdef APSTUDIO_INVOKED
> GUIDELINES DESIGNINFO DISCARDABLE 
> BEGIN
>     IDD_IP_SETTINGS, DIALOG
>     BEGIN
>         LEFTMARGIN, 7
>         RIGHTMARGIN, 187
>         TOPMARGIN, 7
>         BOTTOMMARGIN, 59
>     END
> END
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // String Table
> //
> 
> STRINGTABLE DISCARDABLE 
> BEGIN
>     IDS_FRIENDLYNAME_IPX    "DirectPlay8 IPX Service Provider"
>     IDS_FRIENDLYNAME_TCPIP  "DirectPlay8 TCP/IP Service Provider"
> END
> 
> #endif    // English (U.S.) resources
> /////////////////////////////////////////////////////////////////////////////
> 
> 
> 
> #ifndef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 3 resource.
> //
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> #endif    // not APSTUDIO_INVOKED
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock1.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,42c1,67
< #define p_accept accept
< #define p_bind bind
< #define p_closesocket closesocket
< #define p_connect connect
< #define p_gethostbyaddr gethostbyaddr
< #define p_gethostbyname gethostbyname
< #define p_gethostname gethostname
< #define p_getpeername getpeername
< #define p_getprotobyname getprotobyname
< #define p_getprotobynumber getprotobynumber
< #define p_getservbyname getservbyname
< #define p_getservbyport getservbyport
< #define p_getsockname getsockname
< #define p_getsockopt getsockopt
< #define p_htonl htonl
< #define p_htons htons
< #define p_inet_addr inet_addr
< #define p_inet_ntoa inet_ntoa
< #define p_ioctlsocket ioctlsocket
< #define p_listen listen
< #define p_ntohl ntohl
< #define p_ntohs ntohs
< #define p_recv recv
< #define p_recvfrom recvfrom
< #define p_select select
< #define p_send send
< #define p_sendto sendto
< #define p_setsockopt setsockopt
< #define p_shutdown shutdown
< #define p_socket socket
< //#define p_WSAAsyncGetHostByAddr WSAAsyncGetHostByAddr
< //#define p_WSAAsyncGetHostByName WSAAsyncGetHostByName
< //#define p_WSAAsyncGetProtoByName WSAAsyncGetProtoByName
< //#define p_WSAAsyncGetProtoByNumber WSAAsyncGetProtoByNumber
< //#define p_WSAAsyncGetServByName WSAAsyncGetServByName
< //#define p_WSAAsyncGetServByPort WSAAsyncGetServByPort
< //#define p_WSAAsyncSelect WSAAsyncSelect
< //#define p_WSACancelAsyncRequest WSACancelAsyncRequest
< #define p_WSACleanup WSACleanup
< #define p_WSAGetLastError WSAGetLastError
< #define p_WSASetLastError WSASetLastError
< #define p_WSAStartup WSAStartup
---
> //
> // DWNSOCK1.INC	Macros for dynamically linking to WinSock 1.1
> //
> 
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	//
> 	// Function available in both versions
> 	//
> 	DYNAMICWINSOCK(accept, LPFN_ACCEPT);
> 	DYNAMICWINSOCK(bind, LPFN_BIND);
> 	DYNAMICWINSOCK(closesocket, LPFN_CLOSESOCKET);
> 	DYNAMICWINSOCK(connect, LPFN_CONNECT);
> 	DYNAMICWINSOCK(gethostbyaddr, LPFN_GETHOSTBYADDR);
> 	DYNAMICWINSOCK(gethostbyname, LPFN_GETHOSTBYNAME);
> 	DYNAMICWINSOCK(gethostname, LPFN_GETHOSTNAME);
> 	DYNAMICWINSOCK(getpeername, LPFN_GETPEERNAME);
> 	DYNAMICWINSOCK(getprotobyname, LPFN_GETPROTOBYNAME);
> 	DYNAMICWINSOCK(getprotobynumber, LPFN_GETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(getservbyname, LPFN_GETSERVBYNAME);
> 	DYNAMICWINSOCK(getservbyport, LPFN_GETSERVBYPORT);
> 	DYNAMICWINSOCK(getsockname, LPFN_GETSOCKNAME);
> 	DYNAMICWINSOCK(getsockopt, LPFN_GETSOCKOPT);
> 	DYNAMICWINSOCK(htonl, LPFN_HTONL);
> 	DYNAMICWINSOCK(htons, LPFN_HTONS);
> 	DYNAMICWINSOCK(inet_addr, LPFN_INET_ADDR);
> 	DYNAMICWINSOCK(inet_ntoa, LPFN_INET_NTOA);
> 	DYNAMICWINSOCK(ioctlsocket, LPFN_IOCTLSOCKET);
> 	DYNAMICWINSOCK(listen, LPFN_LISTEN);
> 	DYNAMICWINSOCK(ntohl, LPFN_NTOHL);
> 	DYNAMICWINSOCK(ntohs, LPFN_NTOHS);
> 	DYNAMICWINSOCK(recv, LPFN_RECV);
> 	DYNAMICWINSOCK(recvfrom, LPFN_RECVFROM);
> 	DYNAMICWINSOCK(select, LPFN_SELECT);
> 	DYNAMICWINSOCK(send, LPFN_SEND);
> 	DYNAMICWINSOCK(sendto, LPFN_SENDTO);
> 	DYNAMICWINSOCK(setsockopt, LPFN_SETSOCKOPT);
> 	DYNAMICWINSOCK(shutdown, LPFN_SHUTDOWN);
> 	DYNAMICWINSOCK(socket, LPFN_SOCKET);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByAddr, LPFN_WSAASYNCGETHOSTBYADDR);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByName, LPFN_WSAASYNCGETHOSTBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByName, LPFN_WSAASYNCGETPROTOBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByNumber, LPFN_WSAASYNCGETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(WSAAsyncGetServByName, LPFN_WSAASYNCGETSERVBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetServByPort, LPFN_WSAASYNCGETSERVBYPORT);
> 	DYNAMICWINSOCK(WSAAsyncSelect, LPFN_WSAASYNCSELECT);
> 	DYNAMICWINSOCK(WSACancelAsyncRequest, LPFN_WSACANCELASYNCREQUEST);
> 	DYNAMICWINSOCK(WSACleanup, LPFN_WSACLEANUP);
> 	DYNAMICWINSOCK(WSAGetLastError, LPFN_WSAGETLASTERROR);
> 	DYNAMICWINSOCK(WSASetLastError, LPFN_WSASETLASTERROR);
> 	DYNAMICWINSOCK(WSAStartup, LPFN_WSASTARTUP);
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock2.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,27c1,3
< #ifdef UNICODE
< //	#define p_WSAAddressToString				WSAAddressToStringW
< //	#define p_WSADuplicateSocket				WSADuplicateSocketW
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersW
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsW
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoW
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdW
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassW
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginW
< //	#define p_WSALookupServiceNext				WSALookupServiceNextW
< //	#define p_WSASetService						WSASetServiceW
< //	#define p_WSASocket							WSASocketW
< //	#define p_WSAStringToAddress				WSAStringToAddressW
< #else
< //	#define p_WSAAddressToString				WSAAddressToStringA
< //	#define p_WSADuplicateSocket				WSADuplicateSocketA
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersA
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsA
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoA
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdA
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassA
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginA
< //	#define p_WSALookupServiceNext				WSALookupServiceNextA
< //	#define p_WSASetService						WSASetServiceA
< //	#define p_WSASocket							WSASocketA
< //	#define p_WSAStringToAddress				WSAStringToAddressA
< #endif // UNICODE
---
> //
> // DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
> //
29,53c5,70
< //#define p_WSAAccept WSAAccept
< #define p_WSACloseEvent WSACloseEvent
< //#define p_WSAConnect WSAConnect
< #define p_WSACreateEvent WSACreateEvent
< #define p_WSAEnumNetworkEvents WSAEnumNetworkEvents
< #define p_WSAEventSelect WSAEventSelect
< #define p_WSAGetOverlappedResult WSAGetOverlappedResult
< //#define p_WSAGetQOSByName WSAGetQOSByName
< //#define p_WSAHtonl WSAHtonl
< //#define p_WSAHtons WSAHtons
< #define p_WSAIoctl WSAIoctl
< //#define p_WSAJoinLeaf WSAJoinLeaf
< //#define p_WSALookupServiceEnd WSALookupServiceEnd
< //#define p_WSANtohl WSANtohl
< //#define p_WSANtohs WSANtohs
< #define p_WSARecv WSARecv
< //#define p_WSARecvDisconnect WSARecvDisconnect
< #define p_WSARecvFrom WSARecvFrom
< //#define p_WSARemoveServiceClass WSARemoveServiceClass
< #define p_WSAResetEvent WSAResetEvent
< #define p_WSASend WSASend
< //#define p_WSASendDisconnect WSASendDisconnect
< #define p_WSASendTo WSASendTo
< #define p_WSASetEvent WSASetEvent
< #define p_WSAWaitForMultipleEvents WSAWaitForMultipleEvents
---
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	DYNAMICWINSOCK(WSAAccept, LPFN_WSAACCEPT);
> 	DYNAMICWINSOCK(WSAAddressToStringA, LPFN_WSAADDRESSTOSTRINGA);
> 	DYNAMICWINSOCK(WSAAddressToStringW, LPFN_WSAADDRESSTOSTRINGW);
> 	DYNAMICWINSOCK(WSACloseEvent, LPFN_WSACLOSEEVENT);
> 	DYNAMICWINSOCK(WSAConnect, LPFN_WSACONNECT);
> 	DYNAMICWINSOCK(WSACreateEvent, LPFN_WSACREATEEVENT);
> 	DYNAMICWINSOCK(WSADuplicateSocketA, LPFN_WSADUPLICATESOCKETA);
> 	DYNAMICWINSOCK(WSADuplicateSocketW, LPFN_WSADUPLICATESOCKETW);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersA, LPFN_WSAENUMNAMESPACEPROVIDERSA);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersW, LPFN_WSAENUMNAMESPACEPROVIDERSW);
> 	DYNAMICWINSOCK(WSAEnumNetworkEvents, LPFN_WSAENUMNETWORKEVENTS);
> 	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
> 	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
> 	DYNAMICWINSOCK(WSAEventSelect, LPFN_WSAEVENTSELECT);
> 	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
> 	DYNAMICWINSOCK(WSAGetQOSByName, LPFN_WSAGETQOSBYNAME);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoA, LPFN_WSAGETSERVICECLASSINFOA);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoW, LPFN_WSAGETSERVICECLASSINFOW);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdA, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdW, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW);
> 	DYNAMICWINSOCK(WSAHtonl, LPFN_WSAHTONL);
> 	DYNAMICWINSOCK(WSAHtons, LPFN_WSAHTONS);
> 	DYNAMICWINSOCK(WSAInstallServiceClassA, LPFN_WSAINSTALLSERVICECLASSA);
> 	DYNAMICWINSOCK(WSAInstallServiceClassW, LPFN_WSAINSTALLSERVICECLASSW);
> 	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
> 	DYNAMICWINSOCK(WSAJoinLeaf, LPFN_WSAJOINLEAF);
> 	DYNAMICWINSOCK(WSALookupServiceBeginA, LPFN_WSALOOKUPSERVICEBEGINA);
> 	DYNAMICWINSOCK(WSALookupServiceBeginW, LPFN_WSALOOKUPSERVICEBEGINW);
> 	DYNAMICWINSOCK(WSALookupServiceEnd, LPFN_WSALOOKUPSERVICEEND);
> 	DYNAMICWINSOCK(WSALookupServiceNextA, LPFN_WSALOOKUPSERVICENEXTA);
> 	DYNAMICWINSOCK(WSALookupServiceNextW, LPFN_WSALOOKUPSERVICENEXTW);
> 	DYNAMICWINSOCK(WSANtohl, LPFN_WSANTOHL);
> 	DYNAMICWINSOCK(WSANtohs, LPFN_WSANTOHS);
> 	DYNAMICWINSOCK(WSARecv, LPFN_WSARECV);
> 	DYNAMICWINSOCK(WSARecvDisconnect, LPFN_WSARECVDISCONNECT);
> 	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
> 	DYNAMICWINSOCK(WSARemoveServiceClass, LPFN_WSAREMOVESERVICECLASS);
> 	DYNAMICWINSOCK(WSAResetEvent, LPFN_WSARESETEVENT);
> 	DYNAMICWINSOCK(WSASend, LPFN_WSASEND);
> 	DYNAMICWINSOCK(WSASendDisconnect, LPFN_WSASENDDISCONNECT);
> 	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
> 	DYNAMICWINSOCK(WSASetEvent, LPFN_WSASETEVENT);
> 	DYNAMICWINSOCK(WSASetServiceA, LPFN_WSASETSERVICEA);
> 	DYNAMICWINSOCK(WSASetServiceW, LPFN_WSASETSERVICEW);
> 	DYNAMICWINSOCK(WSASocketA, LPFN_WSASOCKETA);
> 	DYNAMICWINSOCK(WSASocketW, LPFN_WSASOCKETW);
> 	DYNAMICWINSOCK(WSAStringToAddressA, LPFN_WSASTRINGTOADDRESSA);
> 	DYNAMICWINSOCK(WSAStringToAddressW, LPFN_WSASTRINGTOADDRESSW);
> 	DYNAMICWINSOCK(WSAWaitForMultipleEvents, LPFN_WSAWAITFORMULTIPLEEVENTS);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
104a106
> 	m_hActiveSettingsDialog( NULL ),
134a137
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
369a373,380
> 		//
> 		// cancel any active dialogs
> 		// if there are no dialogs, cancel the active command
> 		//
> 		if ( m_hActiveSettingsDialog != NULL )
> 		{
> 			StopSettingsDialog( m_hActiveSettingsDialog );
> 		}
372a384,390
> 	else
> 	{
> 		//
> 		// there should be no active dialog if there isn't an active command
> 		//
> 		DNASSERT( m_hActiveSettingsDialog == NULL );
> 	}
374d391
< 
877a895,901
> 	if ( m_hActiveSettingsDialog != NULL )
> 	{
> 		StopSettingsDialog( m_hActiveSettingsDialog );
> 		Unlock();
> 	}
> 	else
> 	{
883a908
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
344a345,351
> 		// UI functions
> 		//
> 		virtual	HRESULT	ShowSettingsDialog( CThreadPool *const pThreadPool ) = 0;
> 		virtual	void	StopSettingsDialog( const HWND hDlg ) = 0;
> 		virtual	void	SettingsDialogComplete( const HRESULT hr ) = 0;
> 
> 		//
363a371,372
> 
> 		HWND			m_hActiveSettingsDialog;		// handle of active settings dialog
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
44a46
> #include	"IPXAddress.h"
81c83,84
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
99a103,104
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
114a120
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
191a198,203
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
212a225,231
> 	switch ( OSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
216a236,258
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
241a284,285
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
275a320,321
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
308a355,360
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
450a503,509
> 	switch ( OSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
453a513,536
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
485a569,570
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
506a592,593
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
87a88,90
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
117a121
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
118a123
> 
148a154
> 		INT		m_Win9xReceiveWSAReturn;		
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
84a86
> const DWORD	g_dwIPBroadcastAddressSize = sizeof( g_IPBroadcastAddress );
978,980d979
< // BUGBUG: [mgere] [xbox] No need to enum adapters anymore since we only have one.
< // need to complete the removal of this functionality at a later date.
< /*
1300d1298
< */	return DPNERR_UNSUPPORTED;
1480a1479,1484
> 	//
> 	// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1481a1486,1504
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1484a1508,1510
> 		case 2:
> 		default:
> 		{
1485a1512,1514
> 			break;
> 		}
> 	}
1555a1585,1590
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1556a1592,1610
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1559a1614,1616
> 		case 2:
> 		default:
> 		{
1560a1618,1620
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
38a40
> #include	"StrUtils.h"
52a55
> #include	"IPUI.h"
95a99
> 	memset( m_TempHostName, 0x00, sizeof( m_TempHostName ) );
117a122,368
> // CIPEndpoint::ShowSettingsDialog - show dialog for settings
> //
> // Entry:		Pointer to thread pool
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CIPEndpoint::ShowSettingsDialog( CThreadPool *const pThreadPool )
> {
> 	HRESULT	hr;
> 
> 
> 	DNASSERT( pThreadPool != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	AddRef();
> 	hr = pThreadPool->SpawnDialogThread( DisplayIPHostNameSettingsDialog, &m_hActiveSettingsDialog, this );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to start IP hostname dialog!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:	
> 	DecRef();
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::SettingsDialogComplete - dialog has completed
> //
> // Entry:		Error code for dialog
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::SettingsDialogComplete( const HRESULT hDialogResult )
> {
> 	HRESULT					hr;
> 	HRESULT					hTempResult;
> 	IDirectPlay8Address		*pBaseAddress;
> 	DWORD					dwTotalAddressBufferSize;
> 	char					*pTempAddressString;
> 	WCHAR					WCharHostName[ sizeof( m_TempHostName ) + 1 ];
> 	DWORD					dwWCharHostNameSize;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = hDialogResult;
> 	pBaseAddress = NULL;
> 	pTempAddressString = NULL;
> 
> 	//
> 	// since the dialog is exiting, clear our handle to the dialog
> 	//
> 	m_hActiveSettingsDialog = NULL;
> 
> 	//
> 	// dialog failed, fail the user's command
> 	//
> 	if ( hr != DPN_OK )
> 	{
> 		if ( hr != DPNERR_USERCANCEL)
> 		{
> 			DPF( 0, "Failing endpoint hostname dialog!" );
> 			DisplayErrorCode( 0, hr );
> 
> 		}
> 
> 		goto Failure;
> 	}
> 
> 	//
> 	// The dialog completed OK, rebuild remote address and complete command
> 	//
> 
> 	//
> 	// get the base DNADDRESS
> 	//
> 	pBaseAddress = m_pRemoteMachineAddress->DP8AddressFromSocketAddress();
> 	if ( pBaseAddress == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "SettingsDialogComplete: Failed to get base address when completing IP hostname dialog!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// Add the new 'HOSTNAME' parameter to the address.  If the hostname is blank
> 	// and this is an enum, copy the broadcast hostname.
> 	//
> 	if ( ( m_TempHostName[ 0 ] == '\0' ) && ( m_EndpointType == ENDPOINT_TYPE_ENUM ) )
> 	{
> 		DNASSERT( sizeof( WCharHostName ) >= g_dwIPBroadcastAddressSize );
> 		memcpy( WCharHostName, g_IPBroadcastAddress, g_dwIPBroadcastAddressSize );
> 		dwWCharHostNameSize = g_dwIPBroadcastAddressSize;
> 	}
> 	else
> 	{
> 		dwWCharHostNameSize = LENGTHOF( WCharHostName );
> 		hr = STR_AnsiToWide( m_TempHostName, -1, WCharHostName, &dwWCharHostNameSize );
> 		DNASSERT( hr == DPN_OK );
> 		dwWCharHostNameSize *= sizeof( WCHAR );
> 	}
> 
> 	hr = IDirectPlay8Address_AddComponent( pBaseAddress, DPNA_KEY_HOSTNAME, WCharHostName, dwWCharHostNameSize, DPNA_DATATYPE_STRING );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "SettingsDialogComplete: Failed to add hostname to address!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// set the address
> 	//
> 	hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pBaseAddress, SP_ADDRESS_TYPE_HOST );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to rebuild DNADDRESS when completing IP hostname dialog!" );
> 		DNASSERT( FALSE );
> 		goto Failure;
> 	}
> 
> 	AddRef();
> 
> 	//
> 	// Since any asynchronous I/O posted on a thread is quit when the thread
> 	// exits, it's necessary for the completion of this operation to happen
> 	// on one of the thread pool threads.
> 	//
> 	switch ( GetType() )
> 	{
> 	    case ENDPOINT_TYPE_ENUM:
> 	    {
> 			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( EnumQueryJobCallback,
> 																   CancelEnumQueryJobCallback,
> 																   this );
> 			if ( hr != DPN_OK )
> 			{
> 				DecRef();
> 				DPF( 0, "Failed to set enum query!" );
> 				DisplayDNError( 0, hr );
> 				goto Failure;
> 			}
> 
> //	    	hr = CompleteEnumQuery();
> //	    	if ( hr != DPN_OK )
> //	    	{
> //	    		DPF( 0, "Problem completing EnumQuery after asking user for hostname!" );
> //	    		DisplayDNError( 0, hr );
> //	    	}
> //
> 	    	break;
> 	    }
> 
> 	    case ENDPOINT_TYPE_CONNECT:
> 	    {
> 			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( ConnectJobCallback,
> 																   CancelConnectJobCallback,
> 																   this );
> 			if ( hr != DPN_OK )
> 			{
> 				DecRef();
> 				DPF( 0, "Failed to set enum query!" );
> 				DisplayDNError( 0, hr );
> 				goto Failure;
> 			}
> //	    	hr = CompleteConnect();
> //	    	if ( hr != DPN_OK )
> //	    	{
> //	    		DPF( 0, "Problem completing Connect after asking user for hostname!" );
> //	    		DisplayDNError( 0, hr );
> //	    	}
> 
> 	    	break;
> 	    }
> 
> 	    //
> 	    // unknown!
> 	    //
> 	    default:
> 	    {
> 	    	INT3;
> 			hr = DPNERR_GENERIC;
> 	    	goto Failure;
> 
> 	    	break;
> 	    }
> 	}
> 
> Exit:
> 	if ( pBaseAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DNASSERT( pTempAddressString == NULL );
> 	if ( pBaseAddress != NULL )
> 	{
> 		DNFree( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DecRef();
> 
> 	return;
> 
> Failure:
> 	//
> 	// close this endpoint
> 	//
> 	Close( hr );
> 	
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::StopSettingsDialog - stop an active settings dialog
> //
> // Entry:		Handle of dialog to close
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::StopSettingsDialog( const HWND hDlg)
> {
> 	StopIPHostNameSettingsDialog( hDlg );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
220a472
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
22a23,24
> #define	TEMP_HOSTNAME_LENGTH	100
> 
52a55,67
> 		// UI functions
> 		//
> 		HRESULT		ShowSettingsDialog( CThreadPool *const pThreadPool );
> 		void		SettingsDialogComplete( const HRESULT hr );
> 		void		StopSettingsDialog( const HWND hDlg );
> 		void		SetTempHostName( const char *const pHostName, const UINT_PTR uHostNameLength )
> 		{
> 			DNASSERT( pHostName[ uHostNameLength ] == '\0' );
> 			DNASSERT( ( uHostNameLength + 1 ) <= LENGTHOF( m_TempHostName ) );
> 			memcpy( m_TempHostName, pHostName, ( uHostNameLength + 1 ) );
> 		}
> 
> 		//
69a85
> 		char		m_TempHostName[ TEMP_HOSTNAME_LENGTH ];
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\locals.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62a63,67
> //
> // OS version
> //
> UINT_PTR	g_uOSType;
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\locals.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
106a107,111
> //
> // OS version
> //
> extern	UINT_PTR	g_uOSType;
> 
108a114,128
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // OSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OSType
> // ------------------------------
> inline UINT_PTR	OSType( void )
> {
> 	return	g_uOSType;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
50a52
> #include	"IPXAddress.h"
54a57
> #include	"IPXEndpt.h"
82a86
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
84a89
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
174a180,186
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
193a206,222
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
> 	
318a348,354
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
328a365,370
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
399a442
> 
428a472,515
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	CIPXAddress	*pReturnAddress;
> 
> 	
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	
> 	DNEnterCriticalSection( &g_AddressLock );
> 	pReturnAddress = g_pIPXAddressPool->Get();
> 	DNLeaveCriticalSection( &g_AddressLock );
> 
> 	return	pReturnAddress;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	
> 	DNEnterCriticalSection( &g_AddressLock );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> 	DNLeaveCriticalSection( &g_AddressLock );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
438a526,541
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
59a62,63
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
61a66
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\rsip.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40a41
> #include	"Registry.h"
512a514,517
> 
> 		hr = GetGatewayFromRegistry( reinterpret_cast<BYTE*>( gwipaddr ), sizeof( gwipaddr ) );
> 
> 		if(hr != DPN_OK){
514a520,522
> 		}
> 
> 		DPF(0,"Found suggested RSIP gateway in registry %s, running on Win95?\n",gwipaddr);
651d658
<         WCHAR wszIPHLPAPI[] = L"IPHLPAPI.DLL";
687c694
< 	hIpHlpApi = LoadLibrary(wszIPHLPAPI);
---
> 	hIpHlpApi = LoadLibrary("IPHLPAPI.DLL");
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
260a262,268
> //	//
> //	// Winsock 2 functionality always exists on WinNT.  If we're on Win9x, we can
> //	// only use Winsock2 interfaces for TCP.
> //	//
> //	if ( ( OSType() == VER_PLATFORM_WIN32_NT ) ||
> //		 ( ( LOWORD( GetWinsockVersion() ) >= 2 ) && ( m_pSPData->GetType() == TYPE_IP ) ) )
> //	{
261a270,274
> //	}
> //	else
> //	{
> //		m_pSendFunction = Winsock1Send;
> //	}
378a392,399
> 	
> 	//
> 	// Winsock 2 functionality always exists on WinNT.  If we're on Win9x, we can
> 	// only use Winsock2 interfaces for TCP.
> 	//
> 	if ( ( OSType() == VER_PLATFORM_WIN32_NT ) ||
> 		 ( ( LOWORD( GetWinsockVersion() ) >= 2 ) && ( m_pSPData->GetType() == TYPE_IP ) ) )
> 	{
379a401,405
> 	}
> 	else
> 	{
> 		m_pSendFunction = Winsock1Send;
> 	}
529a556,567
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( ( LOWORD( GetWinsockVersion() ) == 1 ) ||
> 			 ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_pSPData->GetType() == TYPE_IPX ) ) )
> 		{
> 			m_pSPData->GetThreadPool()->RemoveSocketPort( this );
> 		}
> 
965a1004,1016
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
967a1019,1114
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ),	// pointer to receive buffer
> 								pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize,		// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();
> 
> Exit:
> 	return;
> }
968a1116,1118
> 
> 
> //**********************************************************************
969a1120,1265
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
996,997c1292,1293
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( OSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
1003a1300,1308
> 	// lock the 'pending operation' list over the call to Winsock to prevent the
> 	// operation from being completed while it's being set up.
> 	//
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->LockWriteData();
> 	}
> 	
> 	//
1009a1315,1317
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
1021a1330,1334
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->UnlockWriteData();
> 	}
> 
1062a1376,1378
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1136c1452,1453
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( OSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1145a1463,1471
> 	// lock the 'pending operation' list over the call to Winsock to prevent the
> 	// operation from being completed while it's being set up.
> 	//
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->LockReadData();
> 	}
> 
> 	//
1151a1478,1480
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1162a1492,1497
> 	
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->UnlockReadData();
> 	}
> 
1209a1545,1546
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1243a1581,1582
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1288a1628,1629
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
1859a2201,2207
> 	switch ( OSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1904a2253,2316
> 			break;
> 		}
> 
> 		//
> 		// Win9x.
> 		// If this is not an IPX socket and Winsock 2 (or greater) is available,
> 		// call the Winsock 2 read function.  If this is IPX or we're stuck with
> 		// Winsock 1, inform the thread pool as such.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 
> 			if ( ( LOWORD( GetWinsockVersion() ) >= 2 ) &&
> 				 ( m_pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// we're using Winsock2, call for two outstanding reads per socket.
> 				//
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #1 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #2 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 			}
> 			else
> 			{
> 				DNASSERT( m_pSPData != NULL );
> 				hr = m_pSPData->GetThreadPool()->AddSocketPort( this );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Failed to add to active socket list!" );
> 					DisplayDNError( 0, hr );
> 					goto Failure;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2542a2955,3110
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
> 
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			goto Exit;
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data and submit a new receive if
> 		// applicable
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					//					
> 					// attempt another read on this socket.
> 					//
> 					Winsock2Receive();
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = pReadData->m_dwOverlappedBytesReceived;
> 					pReadData->m_dwOverlappedBytesReceived = 0;
> 					ProcessReceivedData( pReadData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						// ERROR_OPERATION_ABORTED = something stopped the I/O operation.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						case ERROR_OPERATION_ABORTED:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();	
> 	DecRef();
> 
> 	return;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
244a245
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
250a252,254
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
293a298
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,3c1,5
< TARGETNAME=dpnwsock
< TARGETTYPE=DYNLINK
< TARGETPATH=obj
---
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
5c7,17
< !ifdef _BUILD_FOR_WIN2000
---
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
> TARGETNAME=dpnwsock
> DLLDEF=..\wsocksp.def
7,13d18
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
15c20,26
< INCLUDES=..\..\;..\..\..\inc;..\..\..\common;..\..\..\..\dnaddress
---
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
17c28,29
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> TARGETPATH=obj
> TARGETTYPE=DYNLINK
19c31,35
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
21,22c37,58
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
>            ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
> 
> #
> # If a debug mode is selected, make sure we include the defines to make the
> # logging code operate.
> #
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
25c61,71
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
27c73,77
< DLLDEF=..\wsocksp.def
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28a79,88
> INCLUDES=$(DXROOT)\inc;..\..\..\inc;..\..\..\common;..\..\..\dnaddress
> 
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
32a93
> 	 ..\DWinsock.cpp \
37a99,101
> 	 ..\IPUI.cpp \
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
40a105
>          ..\Registry.cpp \
49a115,117
> #
> # Next specify options for the compiler.
> #
50a119,121
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNWSock_EXPORTS /DCINTERFACE
> 
> USER_C_FLAGS=-nologo -W3
53,73c124,125
< TARGETLIBS= \
<            ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
<            $(BASEDIR)\public\sdk\lib\*\dpnaddr.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<            $(BASEDIR)\public\sdk\lib\*\winsockx.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
120c120,121
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
158c159,160
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
236a239
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
237a241
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
240c244
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
247c251
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
275a280
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
49a51
> #include	"IPXAddress.h"
55a58
> #include	"IPXEndpt.h"
236a240,269
> 	switch ( OSType() )
> 	{
> 		//
> 		// Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
> 			DPF( 8, "WinNT detected!" );
> 			break;
> 		}
> 
> 		//
> 		// Windows 95, 98
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DPF( 8, "Win9x detected!" );
> 			break;
> 		}
> 
> 		// other version (unsupported!)
> //		case VER_PLATFORM_WIN32_CE:
> 		case VER_PLATFORM_WIN32s:
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
841a875,880
> 		case TYPE_IPX:
> 		{
> 			pEndpoint = CreateIPXEndpoint( &PoolContext );
> 			break;
> 		}
> 
1154a1194,1199
> 		case TYPE_IPX:
> 		{
> 			pReturn = CreateIPXAddress();
> 			break;
> 		}
> 
1185a1231,1236
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
122a124,143
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
129a151,161
> //
> // structure passed to dialog threads
> //
> typedef	struct	_DIALOG_THREAD_PARAM
> {
> 	DIALOG_FUNCTION	*pDialogFunction;
> 	HWND			*phDialog;
> 	void			*pContext;
> 	CThreadPool		*pThisThreadPool;
> } DIALOG_THREAD_PARAM;
> 
234c266,273
< 	DEBUG_ONLY( 
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( OSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
236c275,276
< 	)
---
> 						break;
> 					}
237a278,285
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
244c292,299
< 	DEBUG_ONLY(
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( OSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
246c301,302
< 	)
---
> 						break;
> 					}
247a304,311
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
281a346,352
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
338a410,414
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( OSType() )
> 	{
341a418,419
> 		case VER_PLATFORM_WIN32_NT:
> 		{
347a426,452
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
376a482,483
> 	SYSTEM_INFO		SystemInfo;
> 	UINT_PTR		uDesiredThreads;
383a491,495
> 	//
> 	// get machine information
> 	//
> 	memset( &SystemInfo, 0x00, sizeof( SystemInfo ) );
> 	GetSystemInfo( &SystemInfo );
407a520,526
> 	uDesiredThreads = ( SystemInfo.dwNumberOfProcessors * 2 ) + 2;
> 	DNASSERT( uDesiredThreads != 0 );
> 	while ( uDesiredThreads > 0 )
> 	{
> 		uDesiredThreads--;
> 		StartNTCompletionThread();
> 	}
409,413d527
<     StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 
438a553,788
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT				hr;
> 	HANDLE				hPrimaryThread;
> 	HANDLE				hSecondaryThread;
> 	DWORD				dwPrimaryThreadID;
> 	DWORD				dwSecondaryThreadID;
> 	WIN9X_THREAD_DATA	*pPrimaryThreadInput;
> 	WIN9X_THREAD_DATA	*pSecondaryThreadInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	hPrimaryThread = NULL;
> 	hSecondaryThread = NULL;
> 	pPrimaryThreadInput = NULL;
> 	pSecondaryThreadInput = NULL;
> 
> 	//
> 	// Win9x requires completion events for Winsock2.  Always allocate the
> 	// events even though the they might not be used.
> 	//
> 	DNASSERT( m_hWinsock2SendComplete == NULL );
> 	m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 										   TRUE,	// manual reset
> 										   FALSE,	// start unsignalled
> 										   NULL		// pointer to name (none)
> 										   );
> 	if ( m_hWinsock2SendComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Send!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 	m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 											  TRUE,		// manual reset
> 											  FALSE,	// start unsignalled
> 											  NULL		// pointer to name (none)
> 											  );
> 	if ( m_hWinsock2ReceiveComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Receive!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	//
> 	// create parameters to worker threads
> 	//
> 	pPrimaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pPrimaryThreadInput ) ) );
> 	if ( pPrimaryThreadInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for primary Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	pSecondaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pSecondaryThreadInput ) ) );
> 	if ( pSecondaryThreadInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for secondary Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pPrimaryThreadInput, 0x00, sizeof( *pPrimaryThreadInput ) );
> 	pPrimaryThreadInput->pThisThreadPool = this;
> 	
> 	DBG_CASSERT( sizeof( *pPrimaryThreadInput ) == sizeof( *pSecondaryThreadInput ) );
> 	memcpy( pSecondaryThreadInput, pPrimaryThreadInput, sizeof( *pSecondaryThreadInput ) );
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	IncrementActiveThreadCount();
> 	
> 	//
> 	// Create one worker thread and boost its priority.  If the primary thread
> 	// can be created and boosted, create a secondary thread.  Do not create a
> 	// secondary thread if the primary could not be boosted because the system
> 	// is probably low on resources.
> 	//
> 	hPrimaryThread = CreateThread( NULL,					// pointer to security attributes (none)
> 								   0,						// stack size (default)
> 								   PrimaryWin9xThread,		// pointer to thread function
> 								   pPrimaryThreadInput,		// pointer to input parameter
> 								   0,						// let it run
> 								   &dwPrimaryThreadID		// pointer to destination of thread ID
> 								   );
> 	if ( hPrimaryThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		DecrementActiveThreadCount();
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		goto Failure;
> 	}
> 	pPrimaryThreadInput = NULL;
> 
> 
> 	DPF( 8, "Created primary Win9x thread: 0x%x\tTotal Thread Count: %d", dwPrimaryThreadID, ThreadCount() );
> 	DNASSERT( hPrimaryThread != NULL );
> 	if ( SetThreadPriority( hPrimaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of primary Win9x read thread!  Not starting secondary thread" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 	else
> 	{
> 		//
> 		// primary thread was created and boosted, create a secondary thread
> 		//
> 		IncrementActiveThreadCount();
> 		hSecondaryThread = CreateThread( NULL,						// pointer to security attributes (none)
> 										 0,							// stack size (default)
> 										 SecondaryWin9xThread,		// pointer to thread function
> 										 pSecondaryThreadInput,		// pointer to input parameter
> 										 0,							// let it run
> 										 &dwSecondaryThreadID		// pointer to destination of thread ID
> 										 );
> 		if ( hSecondaryThread != NULL )
> 		{
> 			DPF( 8, "Created secondary Win9x thread: 0x%x\tTotal Thread Count: %d", dwSecondaryThreadID, ThreadCount() );
> 			
> 			pSecondaryThreadInput = NULL;
> 			DNASSERT( hSecondaryThread != NULL );
> 			if ( SetThreadPriority( hSecondaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to boost priority of secondary Win9x thread!" );
> 				DisplayErrorCode( 0, dwError );
> 			}
> 		}
> 		else
> 		{
> 			//
> 			// thread startup failed, decrement active thread count
> 			//
> 			DecrementActiveThreadCount();
> 		}
> 	}
> 
> 
> Exit:
> 	if ( pPrimaryThreadInput != NULL )
> 	{
> 		DNFree( pPrimaryThreadInput );
> 		pPrimaryThreadInput = NULL;
> 	}
> 
> 	if ( pSecondaryThreadInput != NULL )
> 	{
> 		DNFree( pSecondaryThreadInput );
> 		pSecondaryThreadInput = NULL;
> 	}
> 
> 	if ( hPrimaryThread != NULL )
> 	{
> 		if ( CloseHandle( hPrimaryThread ) == FALSE )
> 		{
> 			DWORD	dwError;
> 
> 
> 			dwError = GetLastError();
> 			DPF( 0, "Problem closing Win9x thread hanle!" );
> 			DisplayErrorCode( 0, dwError );
> 		}
> 
> 		hPrimaryThread = NULL;
> 	}
> 
> 	if ( hSecondaryThread != NULL )
> 	{
> 		if ( CloseHandle( hSecondaryThread ) == FALSE )
> 		{
> 			DWORD	dwError;
> 
> 
> 			dwError = GetLastError();
> 			DPF( 0, "Problem closing Win9x thread hanle!" );
> 			DisplayErrorCode( 0, dwError );
> 		}
> 
> 		hSecondaryThread = NULL;
> 	}
> 
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
537a888,889
> 	if ( OSType() == VER_PLATFORM_WIN32_NT )
> 	{	
558a911
> 	}
640a994,996
> 		DNASSERT( ( OSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
658a1015,1016
> 		DNASSERT( ( OSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
802a1161
> 	m_IPXReadIODataPool.Deinitialize();
850d1208
< 			
854a1213,1221
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			break;
> 		}
> 
> 		//
932a1300,1308
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1187a1564,1565
> 	switch ( OSType() )
> 	{
1190a1569,1570
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1207a1588,1616
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( m_JobQueue.SignalPendingJob() == FALSE )
> 			{
> 				hr = DPNERR_OUTOFMEMORY;
> 				DPF( 0, "Failed to signal pending job!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1318a1728,1729
> 	if ( OSType() == VER_PLATFORM_WIN32_NT )
> 	{
1325a1737
> 	}
1527a1940,2040
> // CThreadPool::SpawnDialogThread - start a secondary thread to display service
> //		provider UI.
> //
> // Entry:		Pointer to dialog function
> //				Pointer destination for copy of dialog handle
> //				Dialog context
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext )
> {
> 	HRESULT	hr;
> 	HANDLE	hDialogThread;
> 	DIALOG_THREAD_PARAM		*pThreadParam;
> 	DWORD	dwThreadID;
> 
> 
> 	DNASSERT( pDialogFunction != NULL );
> 	DNASSERT( phDialog != NULL );
> 	DNASSERT( pDialogContext != NULL );		// why would anyone not want a dialog context??
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pThreadParam = NULL;
> 
> 	//
> 	// create and initialize thread param
> 	//
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( DNMalloc( sizeof( *pThreadParam ) ) );
> 	if ( pThreadParam == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for dialog thread!" );
> 		goto Failure;
> 	}
> 
> 	pThreadParam->pDialogFunction = pDialogFunction;
> 	pThreadParam->phDialog = phDialog;
> 	pThreadParam->pContext = pDialogContext;
> 	pThreadParam->pThisThreadPool = this;
> 
> 	//
> 	// assume that a thread will be created
> 	//
> 	IncrementActiveThreadCount();
> 
> 	//
> 	// create thread
> 	//
> 	hDialogThread = CreateThread( NULL,					// pointer to security (none)
> 								  0,					// stack size (default)
> 								  DialogThreadProc,		// thread procedure
> 								  pThreadParam,			// thread param
> 								  0,					// creation flags (none)
> 								  &dwThreadID );		// pointer to thread ID
> 	if ( hDialogThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// decrement active thread count and report error
> 		//
> 		DecrementActiveThreadCount();
> 		
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to start dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		goto Failure;
> 	}
>   								
> 	if ( CloseHandle( hDialogThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing handle from create dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:
> 	if ( pThreadParam != NULL )
> 	{
> 		DNFree( pThreadParam );
> 		pThreadParam = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
1547a2061,2062
> 	switch ( OSType() )
> 	{
1548a2064,2073
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( NTCompletionThreadCount() == 0 );
> 			break;
> 		}
> 
> 		//
1550a2076,2077
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1552a2080,2081
> 			break;
> 		}
1553a2083,2092
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1582a2122,2123
> 	switch ( OSType() )
> 	{
1583a2125,2132
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1589a2139,2140
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1629a2181,2193
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1709a2274,2420
> // CThreadPool::AddSocketPort - add a socket to the Win9x watch list
> //
> // Entry:		Pointer to SocketPort
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::AddSocketPort( CSocketPort *const pSocketPort )
> {
> 	HRESULT	hr;
> 	BOOL	fSocketAdded;
> 
> 	
> 	DNASSERT( pSocketPort != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	fSocketAdded = FALSE;
> 
> 	Lock();
> 
> 	//
> 	// We're capped by the number of sockets we can use for Winsock1.  Make
> 	// sure we don't allocate too many sockets.
> 	//
> 	if ( m_uReservedSocketCount == FD_SETSIZE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "There are too many sockets allocated on Winsock1!" );
> 		goto Failure;
> 	}
> 
> 	m_uReservedSocketCount++;
> 	
> 	DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
> 	m_pSocketPorts[ m_SocketSet.fd_count ] = pSocketPort;
> 	m_SocketSet.fd_array[ m_SocketSet.fd_count ] = pSocketPort->GetSocket();
> 	m_SocketSet.fd_count++;
> 	fSocketAdded = TRUE;
> 
> 	//
> 	// add a reference to note that this socket port is being used by the thread
> 	// pool
> 	//
> 	pSocketPort->AddRef();
> 
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when adding socket port to active list!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> Exit:
> 	Unlock();
> 	
> 	return	hr;
> 
> Failure:
> 	if ( fSocketAdded != FALSE )
> 	{
> 		AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
> 		m_SocketSet.fd_count--;
> 		m_pSocketPorts[ m_SocketSet.fd_count ] = NULL;
> 		m_SocketSet.fd_array[ m_SocketSet.fd_count ] = NULL;
> 		fSocketAdded = FALSE;
> 	}
> 
> 	m_uReservedSocketCount--;
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::RemoveSocketPort - remove a socket from the Win9x watch list
> //
> // Entry:		Pointer to socket port to remove
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::RemoveSocketPort( CSocketPort *const pSocketPort )
> {
> 	UINT_PTR	uIndex;
> 
> 
> 	DNASSERT( pSocketPort != NULL );
> 	
> 	Lock();
> 
> 	uIndex = m_SocketSet.fd_count;
> 	DNASSERT( uIndex != 0 );
> 	while ( uIndex != 0 )
> 	{
> 		uIndex--;
> 
> 		if ( m_pSocketPorts[ uIndex ] == pSocketPort )
> 		{
> 			m_uReservedSocketCount--;
> 			m_SocketSet.fd_count--;
> 
> 			memmove( &m_pSocketPorts[ uIndex ],
> 					 &m_pSocketPorts[ uIndex + 1 ],
> 					 ( sizeof( m_pSocketPorts[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			memmove( &m_SocketSet.fd_array[ uIndex ],
> 					 &m_SocketSet.fd_array[ uIndex + 1 ],
> 					 ( sizeof( m_SocketSet.fd_array[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );
> 
> 			//
> 			// clear last entry which is now unused
> 			//
> 			memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) );
> 			memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) );
> 
> 			//
> 			// end the loop
> 			//
> 			uIndex = 0;
> 		}
> 	}
> 
> 	Unlock();
> 	
> 	pSocketPort->DecRef();
> 
> 	//
> 	// It's really not necessary to signal a new job here because there were
> 	// active sockets on the last iteration of the Win9x thread.  That means the
> 	// Win9x thread was in a polling mode to check for sockets and the next time
> 	// through it will notice that there is a missing socket.  By signalling the
> 	// job event we reduce the time needed for the thread to figure out that the
> 	// socket is gone.
> 	//
> 	if ( m_JobQueue.SignalPendingJob() == FALSE )
> 	{
> 		DPF( 0, "Failed to signal pending job when removeing socket port to active list!" );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
1853a2565,3385
> // CThreadPool::CompleteOutstandingSends - check for completed sends and
> //		indicate send completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingSends( void )
> {
> 	CBilink		*pCurrentOutstandingWrite;
> 	CBilink		WritesToBeProcessed;
> 
> 
> 	WritesToBeProcessed.Initialize();
> 	LockWriteData();
> 
> 	//
> 	// Loop through the list out outstanding sends.  Any completed sends are
> 	// removed from the list and processed after we release the write data lock.
> 	//
> 	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
> 	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CWriteIOData	*pWriteIOData;
> 		DWORD			dwFlags;
> 
> 
> 		//
> 		// note this send and advance pointer to the next pending send
> 		//
> 		pWriteIOData = pWriteIOData->WriteDataFromBilink( pCurrentOutstandingWrite );
> 		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();
> 
> 		if ( pWriteIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
> 										   pWriteIOData->Overlap(),
> 										   &pWriteIOData->m_dwOverlappedBytesSent,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				//
> 				// Overlapped results will complete with success and zero bytes
> 				// transferred when the overlapped structure is checked BEFORE
> 				// the operation has really been subnitted.  This is a possibility
> 				// with the current code.  To combat this, check the sent bytes
> 				// for zero (we'll never send zero bytes).
> 				//
> 				if ( pWriteIOData->m_dwOverlappedBytesSent == 0 )
> 				{
> 					goto SkipSendCompletion;
> 				}
> 
> 				pWriteIOData->m_Win9xSendHResult = DPN_OK;
> 				pWriteIOData->m_dwOverlappedBytesSent = 0;
> 			}
> 			else
> 			{
> 				DWORD	dwWSAError;
> 
> 
> 				dwWSAError = p_WSAGetLastError();
> 				switch( dwWSAError )
> 				{
> 					//
> 					// this I/O operation is incomplete, don't send notification to the user
> 					//
> 					case ERROR_IO_PENDING:
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipSendCompletion;
> 						break;
> 					}
> 
> 					//
> 					// WSAENOTSOCK = the socket has been closed, most likely
> 					// as a result of a command completing or being cancelled.
> 					//
> 					case WSAENOTSOCK:
> 					{
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_USERCANCEL;
> 						break;
> 					}
> 
> 					//
> 					// other error, stop and look
> 					//
> 					default:
> 					{
> 						INT3;
> 						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
> 						DisplayWinsockError( 0, dwWSAError );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
> 			pWriteIOData->SetWin9xOperationPending( FALSE );
> 
> 			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
> 			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( WritesToBeProcessed );
> 		}
> 
> SkipSendCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockWriteData();
> 
> 	//
> 	// process all writes that have been pulled to the side.
> 	//
> 	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
> 	{
> 		CWriteIOData	*pTempWrite;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
> 		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
> 		pSocketPort = pTempWrite->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 
> 		pSocketPort->SendFromWriteQueue();
> 		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
> 		pSocketPort->DecRef();
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CompleteOutstandingReceives - check for completed receives and
> //		indicate completion for them.
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CompleteOutstandingReceives( void )
> {
> 	CBilink		*pCurrentOutstandingRead;
> 	CBilink		ReadsToBeProcessed;
> 
> 
> 	ReadsToBeProcessed.Initialize();
> 	LockReadData();
> 
> 	//
> 	// Loop through the list of outstanding reads and pull out the ones that need
> 	// to be serviced.  We don't want to service them while the read data lock
> 	// is taken.
> 	//
> 	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
> 	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
> 	{
> 		CSocketPort		*pSocketPort;
> 		CReadIOData		*pReadIOData;
> 		DWORD			dwFlags;
> 
> 
> 		pReadIOData = pReadIOData->ReadDataFromBilink( pCurrentOutstandingRead );
> 		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();
> 
> 		//
> 		// Make sure this operation is really pending before attempting to check
> 		// for completion.  It's possible that the read was added to the list, but
> 		// we haven't actually called Winsock yet.
> 		//
> 		if ( pReadIOData->Win9xOperationPending() != FALSE )
> 		{
> 			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
> 										   pReadIOData->Overlap(),
> 										   &pReadIOData->m_dwOverlappedBytesReceived,
> 										   FALSE,
> 										   &dwFlags
> 										   ) != FALSE )
> 			{
> 				//
> 				// Overlapped results will complete with success and zero bytes
> 				// transferred when the overlapped structure is checked BEFORE
> 				// the operation has really been subnitted.  This is a possibility
> 				// with the current code.  To combat this, check the received bytes
> 				// for zero (the return when the overlapped request was checked before
> 				// it was sent) and check the return address (it's possible that someone
> 				// really sent zero bytes).
> 				//
> 				DBG_CASSERT( ERROR_SUCCESS == 0 );
> 				if ( ( pReadIOData->m_dwOverlappedBytesReceived != 0 ) &&
> 					 ( pReadIOData->m_pSourceSocketAddress->IsUndefinedHostAddress() == FALSE ) )
> 				{
> 					pReadIOData->m_Win9xReceiveWSAReturn = ERROR_SUCCESS;
> 				}
> 				else
> 				{
> 					goto SkipReceiveCompletion;
> 				}
> 			}
> 			else
> 			{
> 				pReadIOData->m_Win9xReceiveWSAReturn = p_WSAGetLastError();
> 				switch( pReadIOData->m_Win9xReceiveWSAReturn )
> 				{
> 					//
> 					// If this I/O operation is incomplete, don't send notification to the user.
> 					//
> 					case WSA_IO_INCOMPLETE:
> 					{
> 						goto SkipReceiveCompletion;
> 						break;
> 					}
> 
> 					//
> 					// socket was closed with an outstanding read, no problem
> 					// Win9x reports 'WSAENOTSOCK'
> 					// WinNT reports 'ERROR_OPERATION_ABORTED'
> 					//
> 					// If this is an indication that the connection was reset,
> 					// pass it on to the socket port so it can issue another
> 					// read
> 					//
> 					case ERROR_OPERATION_ABORTED:
> 					case WSAENOTSOCK:
> 					case WSAECONNRESET:
> 					{
> 						break;
> 					}
> 
> 					default:
> 					{
> 						DisplayWinsockError( 0, pReadIOData->m_Win9xReceiveWSAReturn );
> 
> 						// debug me!
> 						DNASSERT( FALSE );
> 
> 						break;
> 					}
> 				}
> 			}
> 
> 			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
> 			pReadIOData->SetWin9xOperationPending( FALSE );
> 
> 			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
> 			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( ReadsToBeProcessed );
> 		}
> 
> SkipReceiveCompletion:
> 		//
> 		// the following line is present to prevent the compiler from whining
> 		// about a blank line
> 		//
> 		;
> 	}
> 
> 	UnlockReadData();
> 
> 	//
> 	// loop through the list of reads that have completed and dispatch them
> 	//
> 	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
> 	{
> 		CReadIOData		*pTempRead;
> 		CSocketPort		*pSocketPort;
> 
> 
> 		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
> 		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
> 
> 		pSocketPort = pTempRead->SocketPort();
> 		DNASSERT( pSocketPort != NULL );
> 		pSocketPort->Win9xWinsock2ReceiveComplete( pTempRead );
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::PrimaryWin9xThread - main thread to do everything that the SP is
> //		supposed to do under Win9x.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::PrimaryWin9xThread( void *pParam )
> {
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 	DN_TIME				CurrentTime;
> 	DWORD				dwMaxWaitTime;
> 	DN_TIME				DeltaT;
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;
> 
> 	
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 	DNASSERT( pSocketSet != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Primary Win9x thread failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
> 	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
> 	// structure definition.
> 	//
> 	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
> //#ifdef	_WIN32
> //	DBG_CASSERT( OFFSETOF( FD_SET, fd_array ) == sizeof( pSocketSet->fd_count ) );
> //#endif	// _WIN32
> //	DNASSERT( pThisThreadPool->m_uReservedSocketCount == 0 );
> //	DNASSERT( pSocketSet->fd_count == 0 );
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 	
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 	
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		DWORD	dwWaitReturn;
> 
> 		
> 		//
> 		// Update the job time so we know how long to wait.  We can
> 		// only get here if a socket was just added to the socket list, or
> 		// we've been servicing sockets.
> 		//
> 		DNTimeGet( &CurrentTime );
> 		if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
> 		{
> 			pThisThreadPool->LockTimerData();
> 			CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
> 																		   &CoreData.NextTimerJobTime );
> 			if ( CoreData.fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active jobs left with Winsock1 sockets active!" );
> 			}
> 			pThisThreadPool->UnlockTimerData();
> 		}
> 
> 		DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
> #pragma	BUGBUG( johnkan, "Busted Win64!" )
> 		dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );
> 
> 
> 		//
> 		// Check for Winsock1 sockets.  If there are some around, do a quick poll
> 		// of them to check of I/O before entering the main Winsock2 loop for
> 		// the real timing.
> 		//
> 		pThisThreadPool->Lock();
> 		if ( pSocketSet->fd_count != 0 )
> 		{
> 			pThisThreadPool->Unlock();
> 
> 			pThisThreadPool->CheckWinsock1IO( pSocketSet );
> 			
> 			//
> 			// since there are Winsock1 sockets active, don't spend a lot of
> 			// time waiting for something to happen for Winsock2
> 			//
> 			if ( g_dwSelectTimeSlice < dwMaxWaitTime )
> 			{
> 				dwMaxWaitTime = g_dwSelectTimeSlice;
> 			}
> 		}
> 		else
> 		{
> 			pThisThreadPool->Unlock();
> 		}
> 
> 
> 		//
> 		// Check Winsock2 sockets.
> 		//
> 		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> 												 CoreData.hWaitHandles,					// handles to wait on
> 												 FALSE,									// don't wait for all to be signalled
> 												 dwMaxWaitTime,							// wait timeout
> 												 TRUE									// we're alertable for APCs
> 												 );
> 		switch ( dwWaitReturn )
> 		{
> 			//
> 			// timeout, don't do anything, we'll probably process timer jobs on
> 			// the next loop
> 			//
> 			case WAIT_TIMEOUT:
> 			{
> 				break;
> 			}
> 
> 			//
> 			// New job.  Account for the time spent in the wait.  Don't
> 			// account for time after the job is complete because it's
> 			// possible that the job was an job submission which will want
> 			// to reset the wait time.
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 			{
> 				DPF( 8, "Primary Win9x thread has a pending job!" );
> 				pThisThreadPool->ProcessWin9xJob( &CoreData );
> 				break;
> 			}
> 
> 			//
> 			// SP closing
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 			{
> 				DPF( 8, "Primary Win9x thread exit because SP closing!" );
> 				fLooping = FALSE;
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 send complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending write list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Primary Win9x thread failed to reset Winsock2 send event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nPrimary Win9x thread servicing sends!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingSends();
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 receive complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending read list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Primary Win9x thread failed to reset Winsock2 receive event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nPrimary Win9x thread servicing receives!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingReceives();
> 				break;
> 			}
> 
> 			//
> 			// There are I/O completion routines scheduled on this thread.
> 			// This is not a good thing!
> 			//
> 			case WAIT_IO_COMPLETION:
> 			{
> 				DPF( 1, "WARNING: APC was serviced on the primary Win9x IO service thread!  What is the application doing??" );
> 				break;
> 			}
> 
> 			//
> 			// wait failed
> 			//
> 			case WAIT_FAILED:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Primary Win9x thread wait failed!" );
> 				DisplayDNError( 0, dwError );
> 				break;
> 			}
> 
> 			//
> 			// problem
> 			//
> 			default:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Primary Win9x thread unknown problem in wait!" );
> 				DisplayDNError( 0, dwError );
> 				DNASSERT( FALSE );
> 				break;
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	COM_CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::SecondaryWin9xThread - secondary thread to handle only Win9x
> //		I/O so developers get bit faster with multithreading issues if they're
> //		developing on Win9x.  This thread will only handle Winsock2 based TCP
> //		I/O.  Winsock 1 is not deemed important enough to hack the rest of the
> //		code to work with two threads.
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> //
> // Note:	The startup parameter is allocated for this thread and must be
> //			deallocated by this thread when it exits
> // ------------------------------
> DWORD	WINAPI	CThreadPool::SecondaryWin9xThread( void *pParam )
> {
> 	WIN9X_CORE_DATA		CoreData;
> 	BOOL				fLooping;
> 
> 	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
> 
> 	
> 	DNASSERT( pParam != NULL );
> 	DNASSERT( pThisThreadPool != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	memset( &CoreData, 0x00, sizeof CoreData );
> 
> 	//
> 	// before we do anything we need to make sure COM is happy
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		//
> 		// no problem
> 		//
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// COM already initialized, huh?
> 		//
> 		case S_FALSE:
> 		{
> 			INT3;
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Secondary Win9x thread failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// set enums to happen infinitely in the future
> 	//
> 	DNASSERT( CoreData.fTimerJobsActive == FALSE );
> 	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );
> 
> 	//
> 	// set wait handles
> 	//
> 	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
> 	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
> 	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
> 	
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
> 	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
> 	
> 	//
> 	// go until we're told to stop
> 	//
> 	fLooping = TRUE;
> 	while ( fLooping != FALSE )
> 	{
> 		DWORD	dwWaitReturn;
> 
> 		
> 		//
> 		// Check Winsock2 sockets.
> 		//
> 		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
> 												 CoreData.hWaitHandles,					// handles to wait on
> 												 FALSE,									// don't wait for all to be signalled
> 												 INFINITE,								// wait timeout (forever)
> 												 TRUE									// we're alertable for APCs
> 												 );
> 		switch ( dwWaitReturn )
> 		{
> 			//
> 			// timeout, shouldn't ever be here!!
> 			//
> 			case WAIT_TIMEOUT:
> 			{
> 				INT3;
> 				break;
> 			}
> 
> 			//
> 			// New job.  This is the secondary thread and is only used to handle
> 			// Winsock2 I/O.  Ignore this event and sleep to cause the proper
> 			// work thread to handle the event.
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
> 			{
> 				DPF( 8, "Secondary Win9x thread sleeping on job notification!" );
> 				SleepEx( 0, TRUE );
> 				break;
> 			}
> 
> 			//
> 			// SP closing
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
> 			{
> 				DPF( 8, "Secondary Win9x thread exit because SP closing!" );
> 				fLooping = FALSE;
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 send complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending write list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Secondary Win9x thread failed to reset Winsock2 send event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nSecondary Win9x thread servicing sends!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingSends();
> 				break;
> 			}
> 
> 			//
> 			// Winsock2 receive complete
> 			//
> 			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
> 			{
> 				//
> 				// reset the event so it will be signalled again if anything
> 				// completes while we're scanning the pending read list
> 				//
> 				if ( ResetEvent( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
> 				{
> 					DWORD	dwError;
> 
> 
> 					dwError = GetLastError();
> 					DPF( 0, "Secondary Win9x thead failed to reset Winsock2 receive event!" );
> 					DisplayErrorCode( 0, dwError );
> 				}
> 
> //				DPF( 0, "\n\n\nSecondary Win9x thread servicing receives!\n\n\n" );
> 				pThisThreadPool->CompleteOutstandingReceives();
> 				break;
> 			}
> 
> 			//
> 			// There are I/O completion routines scheduled on this thread.
> 			// This is not a good thing!
> 			//
> 			case WAIT_IO_COMPLETION:
> 			{
> 				DPF( 1, "WARNING: APC was serviced on the secondary Win9x IO service thread!  What is the application doing??" );
> 				break;
> 			}
> 
> 			//
> 			// wait failed
> 			//
> 			case WAIT_FAILED:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Secondary Win9x thread wait failed!" );
> 				DisplayDNError( 0, dwError );
> 				break;
> 			}
> 
> 			//
> 			// problem
> 			//
> 			default:
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Secondary Win9x thread unknown problem in wait!" );
> 				DisplayDNError( 0, dwError );
> 				DNASSERT( FALSE );
> 				break;
> 			}
> 		}
> 	}
> 
> 	pThisThreadPool->DecrementActiveThreadCount();
> 
> 	DNFree( pParam );
> 
> 	COM_CoUninitialize();
> 
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
2197a3730,4087
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::DialogThreadProc - thread proc for spawning dialogs
> //
> // Entry:		Pointer to startup parameter
> //
> // Exit:		Error Code
> // ------------------------------
> DWORD WINAPI	CThreadPool::DialogThreadProc( void *pParam )
> {
> 	const DIALOG_THREAD_PARAM	*pThreadParam;
> 
> 
> 	//
> 	// Initialize COM.  If this fails, we'll have problems later.
> 	//
> 	switch ( COM_CoInitialize( NULL ) )
> 	{
> 		case S_OK:
> 		{
> 			break;
> 		}
> 
> 		case S_FALSE:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// COM init failed!
> 		//
> 		default:
> 		{
> 			DPF( 0, "Failed to initialize COM!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
> 	DNASSERT( pParam != NULL );
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( pParam );
> 	
> 	pThreadParam->pDialogFunction( pThreadParam->phDialog, pThreadParam->pContext );
> 
> 	pThreadParam->pThisThreadPool->DecrementActiveThreadCount();
> 	DNFree( pParam );
> 	return	0;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ProcessWin9xJob - process a Win9x job
> //
> // Entry:		Pointer core data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
> {
> 	THREAD_POOL_JOB	*pJobInfo;
> 
> 
> 	//
> 	// Remove and process a single job from the list.  If there is no job, skip
> 	// to the end of the function.
> 	//
> 	pJobInfo = GetWorkItem();
> 
> 	if ( pJobInfo == NULL )
> 	{
> 		goto Exit;
> 	}
> 
> 	switch ( pJobInfo->JobType )
> 	{
> 		//
> 		// enum refresh
> 		//
> 		case JOB_REFRESH_TIMER_JOBS:
> 		{
> 			DPF( 8, "WorkThread job REFRESH_ENUM" );
> 			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
> 			LockTimerData();
> 			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
> 			UnlockTimerData();
> 
> 			if ( pCoreData->fTimerJobsActive != FALSE )
> 			{
> 				DPF( 8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// issue callback for this job
> 		//
> 		case JOB_DELAYED_COMMAND:
> 		{
> 			DPF( 8, "WorkThread job DELAYED_COMMAND" );
> 			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
> 			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
> 			break;
> 		}
> 
> 		//
> 		// other job
> 		//
> 		default:
> 		{
> 			DPF( 0, "WorkThread Win9x job unknown!" );
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> 	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
> 	m_JobPool.Release( &m_JobPool, pJobInfo );
> 
> Exit:
> 	return;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::CheckWinsock1IO - check the IO status for Winsock1 sockets
> //
> // Entry:		Pointer to sockets to watch
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::CheckWinsock1IO( const FD_SET *const pWinsock1Sockets )
> {
> static	const TIMEVAL	SelectNoTime = { 0 };
> 	INT			iSelectReturn;
> 	FD_SET		ReadSocketSet;
> 	FD_SET		WriteSocketSet;
> 	FD_SET		ErrorSocketSet;
> 
> 
> 	//
> 	// Make a local copy of all of the sockets.  This isn't totally
> 	// efficient, but it works.  Multiplying by active socket count will
> 	// spend half the time in the integer multiply.
> 	//
> 	Lock();
> 	memcpy( &ReadSocketSet, pWinsock1Sockets, sizeof( ReadSocketSet ) );
> 	memcpy( &WriteSocketSet, pWinsock1Sockets, sizeof( WriteSocketSet ) );
> 	memcpy( &ErrorSocketSet, pWinsock1Sockets, sizeof( ErrorSocketSet ) );
> 	Unlock();
> 
> 	//
> 	// Don't check write sockets here because it's very likely that they're ready
> 	// for service but have no outgoing data and will thrash
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  &ReadSocketSet,	// sockets to check for read
> 							  NULL,				// sockets to check for write (none)
> 							  &ErrorSocketSet,	// sockets to check for error
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// select got pissed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// WSAENOTSOCK = This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// WSAEINTR = this operation was interrupted
> 				//
> 				case WSAEINTR:
> 				{
> 					DPF( 1, "Winsock1 reporting interrupted operation when selecting read or error sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting read or error sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing read service and error service.
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
> 			ServiceWinsock1Sockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
> 			break;
> 		}
> 	}
> 
> 	//
> 	// Since writes are likely to be ready, check for them separately
> 	//
> 	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
> 							  NULL,				// sockets to check for read (don't check reads)
> 							  &WriteSocketSet,	// sockets to check for write
> 							  NULL,				// sockets to check for error (don't check errors)
> 							  &SelectNoTime		// wait timeout (zero, do an instant check)
> 							  );
> 	switch ( iSelectReturn )
> 	{
> 		//
> 		// timeout, no write sockets are ready for service
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// select failed
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWSAError;
> 
> 
> 			dwWSAError = p_WSAGetLastError();
> 			switch ( dwWSAError )
> 			{
> 				//
> 				// this socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
> 					break;
> 				}
> 
> 				//
> 				// other
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem selecting write sockets for service!" );
> 					DisplayWinsockError( 0, dwWSAError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// Check for sockets needing write service
> 		//
> 		default:
> 		{
> 			ServiceWinsock1Sockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
> 			break;
> 		}
> 	}
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CThreadPool::ServiceWinsock1Sockets - service requests on Winsock1 sockets ports
> //
> // Entry:		Pointer to set of sockets
> //				Pointer to service function
> //
> // Exit:		Nothing
> // ------------------------------
> void	CThreadPool::ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction )
> {
> 	UINT_PTR	uWaitingSocketCount;
> 	UINT_PTR	uSocketPortCount;
> 	CSocketPort	*pSocketPorts[ FD_SETSIZE ];
> 
> 
> 	uSocketPortCount = 0;
> 	uWaitingSocketCount = pSocketSet->fd_count;
> 	
> 	Lock();
> 	while ( uWaitingSocketCount > 0 )
> 	{
> 		UINT_PTR	uIdx;
> 
> 
> 		uWaitingSocketCount--;
> 		uIdx = m_SocketSet.fd_count;
> 		while ( uIdx != 0 )
> 		{
> 			uIdx--;
> 			if ( pSocketSet->fd_array[ uWaitingSocketCount ] == m_SocketSet.fd_array[ uIdx ] )
> 			{
> 				//
> 				// this socket is still available, add a reference to the socket
> 				// port and keep it around to be processed outside of the lock
> 				//
> 				pSocketPorts[ uSocketPortCount ] = m_pSocketPorts[ uIdx ];
> 				pSocketPorts[ uSocketPortCount ]->AddRef();
> 				uSocketPortCount++;
> 				uIdx = 0;
> 			}
> 		}
> 	}
> 	Unlock();
> 
> 	while ( uSocketPortCount != 0 )
> 	{
> 		uSocketPortCount--;
> 		
> 		//
> 		// call the service function and remove the reference
> 		//
> 		(pSocketPorts[ uSocketPortCount ]->*pServiceFunction)();
> 		pSocketPorts[ uSocketPortCount ]->DecRef();
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
50a51
> typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;
63a65
> typedef	void	DIALOG_FUNCTION( HWND *const phDialog, void *const pDialogContext );
100c102,103
< 			DNASSERT( m_hIOCompletionPort != NULL );
---
> 			DNASSERT( ( ( OSType() == VER_PLATFORM_WIN32_NT ) && ( m_hIOCompletionPort != NULL ) ) ||
> 					  ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_hIOCompletionPort == NULL ) ) );
146a150
> 			DNASSERT( ( m_hWinsock2SendComplete != NULL ) || ( OSType() == VER_PLATFORM_WIN32_NT ) );
151a156
> 			DNASSERT( ( m_hWinsock2ReceiveComplete != NULL ) || ( OSType() == VER_PLATFORM_WIN32_NT ) );
159a165,167
> 		HRESULT	AddSocketPort( CSocketPort *const pSocketPort );
> 		void	RemoveSocketPort( CSocketPort *const pSocketPort );
> 
170a179,181
> 		HRESULT	SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext );
> 
> 		
222a234
> 		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
276a289
> 		HRESULT	Win9xInit( void );
286a300,301
> 		void	CompleteOutstandingSends( void );
> 		void	CompleteOutstandingReceives( void );
287a303,304
> 		static	DWORD WINAPI	PrimaryWin9xThread( void *pParam );
> 		static	DWORD WINAPI	SecondaryWin9xThread( void *pParam );
289a307
> 		static	DWORD WINAPI	DialogThreadProc( void *pParam );
294a313,316
> 		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
> 
> 		void	CheckWinsock1IO( const FD_SET *const pWinsock1Sockets );
> 		void	ServiceWinsock1Sockets( const FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\unk.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
14a15,16
> #include <WSIPX.h>
> 
41a44
> #include	"Creg.h"
42a46,49
> #include	"strutils.h"
> 
> #include	"resource.h"
> 
52a60,68
> #define DN_REG_LOCAL_SP_ROOT				L"Software\\Microsoft\\DirectPlay8"
> #define DN_REG_LOCAL_SP_SUB					L"\\Service Providers"
> #define DN_REG_LOCAL_SP_SUBKEY				DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB
> #define DN_REG_LOCAL_WSOCK_IPX_ROOT			L"\\DPNSPWinsockIPX"
> #define DN_REG_LOCAL_WSOCK_TCPIP_ROOT		L"\\DPNSPWinsockTCP"
> #define	DN_REG_KEYNAME_ALL_APPLICATIONS		L"All Applications"
> #define	DN_REG_KEYNAME_FRIENDLY_NAME		L"Friendly Name"
> #define DN_REG_KEYNAME_GUID					L"GUID"
> 
75c91,120
< // this is the vtable for IP.
---
> // these are the vtables for IPX and IP.  One or the other is used depending on
> // what is passed to DoCreateInstance.  The interfaces are presently the same,
> // but are different structures to facilitate potential future changes.
> static IDP8ServiceProviderVtbl	ipxInterface =
> {
> 	DNSP_QueryInterface,
> 	DNSP_AddRef,
> 	DNSP_Release,
> 	DNSP_Initialize,
> 	DNSP_Close,
> 	DNSP_Connect,
> 	DNSP_Disconnect,
> 	DNSP_Listen,
> 	DNSP_SendData,
> 	DNSP_EnumQuery,
> 	DNSP_EnumRespond,
> 	DNSP_CancelCommand,
> 	DNSP_CreateGroup,
> 	DNSP_DeleteGroup,
> 	DNSP_AddToGroup,
> 	DNSP_RemoveFromGroup,
> 	DNSP_GetCaps,
> 	DNSP_SetCaps,
> 	DNSP_ReturnReceiveBuffers,
> 	DNSP_GetAddressInfo,
> 	DNSP_IsApplicationSupported,
> 	DNSP_EnumAdapters,
> 	DNSP_ProxyEnumQuery
> };
> 
136a182,238
> // CreateIPXInterface - create an IPX interface
> //
> // Entry:		Pointer to pointer to SP interface
> //				Pointer to pointer to associated SP data
> //
> // Exit:		Error code
> // ------------------------------
> static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP, CSPData **const ppSPData )
> {
> 	HRESULT 	hr;
> 	CSPData		*pSPData;
> 
> 
> 	DNASSERT( ppiDNSP != NULL );
> 	DNASSERT( ppSPData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pSPData = NULL;
> 	*ppiDNSP = NULL;
> 	*ppSPData = NULL;
> 
> 	//
> 	// create main data class
> 	//
> 	hr = CreateSPData( &pSPData, &CLSID_DP8SP_IPX, TYPE_IPX, &ipxInterface );
> 	if ( hr != DPN_OK )
> 	{
> 		DNASSERT( pSPData == NULL );
> 		DPF( 0, "Problem creating SPData!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> 	DNASSERT( pSPData != NULL );
> 	*ppiDNSP = pSPData->COMInterface();
> 	*ppSPData = pSPData;
> 
> Exit:
> 	return hr;
> 
> Failure:
> 	if ( pSPData != NULL )
> 	{
> 		pSPData->DecRef();
> 		pSPData = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
223a326,328
> 	//
> 	// we can either create an IPX instance or an IP instance
> 	//
229a335,338
> 	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
> 	{
> 		hr = CreateIPXInterface( ppIDNSP, &pSPData );
> 	}
270c379
< 	return (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP));
---
> 	return ( IsEqualCLSID( rclsid, CLSID_DP8SP_TCPIP ) || IsEqualCLSID( rclsid, CLSID_DP8SP_IPX ) );
361a471,721
> #define MAX_RESOURCE_STRING_LENGTH		_MAX_PATH
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "CDPVACMI::LoadAndAllocString"
> HRESULT LoadAndAllocString( UINT uiResourceID, wchar_t **lpswzString )
> {
> 	int length;
> 	HRESULT hr;
> 
> 	if( DNGetOSType() == VER_PLATFORM_WIN32_NT )
> 	{
> 		wchar_t wszTmpBuffer[MAX_RESOURCE_STRING_LENGTH];	
> 		
> 		length = LoadStringW( g_hDLLInstance, uiResourceID, wszTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
> 
> 		if( length == 0 )
> 		{
> 			hr = GetLastError();		
> 			
> 			DPF( 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
> 			*lpswzString = NULL;
> 
> 			return hr;
> 		}
> 		else
> 		{
> 			*lpswzString = new wchar_t[length+1];
> 
> 			if( *lpswzString == NULL )
> 			{
> 				DPF( 0, "Alloc failure" );
> 				return DPNERR_OUTOFMEMORY;
> 			}
> 
> 			wcscpy( *lpswzString, wszTmpBuffer );
> 
> 			return DPN_OK;
> 		}
> 	}
> 	else
> 	{
> 		char szTmpBuffer[MAX_RESOURCE_STRING_LENGTH];
> 		
> 		length = LoadStringA( g_hDLLInstance, uiResourceID, szTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
> 
> 		if( length == 0 )
> 		{
> 			hr = GetLastError();		
> 			
> 			DPF( 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
> 			*lpswzString = NULL;
> 
> 			return hr;
> 		}
> 		else
> 		{
> 			*lpswzString = new wchar_t[length+1];
> 
> 			if( *lpswzString == NULL )
> 			{
> 				DPF( 0, "Alloc failure" );
> 				return DPNERR_OUTOFMEMORY;
> 			}
> 
> 			if( STR_jkAnsiToWide( *lpswzString, szTmpBuffer, length+1 ) == 0 )
> 			{
> 				hr = GetLastError();
> 				
> 				DPF( 0, "Unable to upconvert from ansi to unicode hr=0x%x", hr );
> 				return hr;
> 			}
> 
> 			return DPN_OK;
> 		}
> 		
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "RegisterDefaultSettings"
> //
> // RegisterDefaultSettings
> //
> // This function registers the default settings for this module.
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT RegisterDefaultSettings()
> {
> 	CRegistry creg;
> 	WCHAR *wszFriendlyName = NULL;
> 	HRESULT hr;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB DN_REG_LOCAL_WSOCK_IPX_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create IPX sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 
> 	creg.WriteString( DN_REG_KEYNAME_ALL_APPLICATIONS, L"Y" );
> 
> 	hr = LoadAndAllocString( IDS_FRIENDLYNAME_IPX, &wszFriendlyName );
> 
> 	if( FAILED( hr ) )
> 	{
> 		DPF( 0, "Could not load IPX name hr=0x%x", hr );
> 		return hr;
> 	}
> 
> 	// Load from resource file
> 	creg.WriteString( DN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );
> 
> 	delete [] wszFriendlyName;
> 
> 	creg.WriteGUID( DN_REG_KEYNAME_GUID, CLSID_DP8SP_IPX );
> 
> 	creg.Close();
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB DN_REG_LOCAL_WSOCK_TCPIP_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create TCPIP sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 
> 	creg.WriteString( DN_REG_KEYNAME_ALL_APPLICATIONS, L"Y" );
> 
> 	hr = LoadAndAllocString( IDS_FRIENDLYNAME_TCPIP, &wszFriendlyName );
> 
> 	if( FAILED( hr ) )
> 	{
> 		DPF( 0, "Could not load IPX name hr=0x%x", hr );
> 		return hr;
> 	}
> 
> 	// Load from resource file
> 	creg.WriteString( DN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );
> 
> 	delete [] wszFriendlyName;
> 
> 	creg.WriteGUID( DN_REG_KEYNAME_GUID, CLSID_DP8SP_TCPIP );
> 
> 	creg.Close();
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "UnRegisterDefaultSettings"
> //
> // UnRegisterDefaultSettings
> //
> // This function registers the default settings for this module.
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT UnRegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot remove app, does not exist" );
> 	}
> 	else
> 	{
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_WSOCK_IPX_ROOT)[1] ) )
> 		{
> 			DPFERR( "Cannot remove IPX sub-key, could have elements" );
> 		}
> 
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_WSOCK_TCPIP_ROOT)[1] ) )
> 		{
> 			DPFERR( "Cannot remove TCPIP sub-key, could have elements" );
> 		}
> 
> 	}
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8SPWSock.IPX.1", L"DirectPlay8 WSock IPX Provider Object",
> 							  L"dpnwsock.dll", CLSID_DP8SP_IPX, L"DirectPlay8SPWSock.IPX") )
> 	{
> 		DPFERR( "Could not register dp8 IPX object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8SPWSock.TCPIP.1", L"DirectPlay8 WSock TCPIP Provider Object",
> 							  L"dpnwsock.dll", CLSID_DP8SP_TCPIP, L"DirectPlay8SPWSock.TCPIP") )
> 	{
> 		DPFERR( "Could not register dp8 IP object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = RegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Could not register default settings hr = 0x%x", hr );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DP8SP_IPX) )
> 	{
> 		DPF( 0, "Failed to unregister IPX object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DP8SP_TCPIP) )
> 	{
> 		DPF( 0, "Failed to unregister IP object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = UnRegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Failed to remove default settings hr=0x%x", hr );
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
22a24
> #include	"DWinsock.h"
51,54d52
< // provides us winsock1/2 support
< #include "dwnsock1.inc"
< #include "dwnsock2.inc"
< 
81a80,81
> static	DWSSTATE	g_dwsState;		// state info for the WS1/2 glue lib
> 
84a85
> static DWORD_PTR	OverrideWinsockVersion( void );
92a94,159
> // OverrideWinsockVersion - override the Winsock version used by the SP
> //
> // Entry:		Nothing
> //
> // Exit:		Max Winsock version to ask for
> // ------------------------------
> static DWORD_PTR	OverrideWinsockVersion( void )
> {
> 	DWORD_PTR	WinsockVersion;
> 
> 
> 	//
> 	// check for override for OS version and Winsock version
> 	//
> 	g_uOSType = DNGetOSType();
> 	WinsockVersion = 2;
> 
> 	switch ( GetProfileInt( "DirectPlay8", "WinsockVersion", 0 ) )
> 	{
> 		//
> 		// Use Winsock1.  If this is an NT machine, fake it into
> 		// thinking it's Win9x.
> 		//
> 		case 1:
> 		{
> 			if ( g_uOSType == VER_PLATFORM_WIN32_NT )
> 			{
> 				g_uOSType = VER_PLATFORM_WIN32_WINDOWS;
> 			}
> 			WinsockVersion = 1;
> 				
> 			break;
> 		}
> 
> 		//
> 		// Use Winsock2.  If this is an NT machine, fake it into
> 		// thinking it's Win9x.
> 		//
> 		case 2:
> 		{
> 			if ( g_uOSType == VER_PLATFORM_WIN32_NT )
> 			{
> 				g_uOSType = VER_PLATFORM_WIN32_WINDOWS;
> 			}
> 			DNASSERT( WinsockVersion == 2 );
> 
> 			break;
> 		}
> 
> 		//
> 		// OS default
> 		//
> 		default:
> 		{
> 			DNASSERT( WinsockVersion == 2 );
> 			break;
> 		}
> 	}
> 
> 	return	WinsockVersion;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
106a174,175
> 	INT			iVersion;
> 	DWORD_PTR	MaxWinsockVersion;
116a186,187
> 	MaxWinsockVersion = OverrideWinsockVersion();
> 
132c203
< 	// initialize Winsock
---
> 	// initialize the bindings to Winsock
134,140c205,206
< 	WORD wVersionRequested;
< 	WSADATA wsaData;
< 	int nRet;
< 
< 	wVersionRequested = MAKEWORD(2,2);
< 	nRet = p_WSAStartup(wVersionRequested, &wsaData);
< 	if (nRet || wVersionRequested != wsaData.wVersion)
---
> 	iVersion = DWSInitWinSock( &g_dwsState, MaxWinsockVersion );
> 	if ( iVersion == 0 )	// failure
142,144c208,210
< 		DPF( 0, "Problem starting winsock!" );
< 	    fReturn = FALSE;
< 	    goto Failure;
---
> 		DPF( 0, "Problem binding dynamic winsock functions!" );
> 		fReturn = FALSE;
> 		goto Failure;
146d211
< 
148a214,215
> 	DPF( 8, "Detected WinSock version %d.%d\n", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
> 
158c225,233
< 		p_WSACleanup();
---
> 		BOOL	fFreeReturn;
> 
> 
> 		fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 		if ( fFreeReturn == FALSE )
> 		{
> 			DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 		}
> 
188a264,266
> 	BOOL	fFreeReturn;
> 
> 
192c270,274
< 	p_WSACleanup();
---
> 	fFreeReturn = DWSFreeWinSock( &g_dwsState );
> 	if ( fFreeReturn == FALSE )
> 	{
> 		DPF( 0, "Problem unbinding dynamic winsock functions!" );
> 	}
199a282,294
> //**********************************************************************
> // ------------------------------
> // GetWinsockVersion - get the version of Winsock
> //
> // Entry:		Nothing
> //
> // Exit:		Winsock version
> // ------------------------------
> INT	GetWinsockVersion( void )
> {
> 	return	g_dwsState.nVersion;
> }
> //**********************************************************************
200a296
> 
286a383
> 	INT_PTR iWinsockVersion;
296a394
> 	iWinsockVersion = GetWinsockVersion();
595c693
< /* BUGBUG: [mgere] [xbox] Removed -- multiple adapters not supported on xbox
---
> 
627c725
< */
---
> 
637c735
< /*	AdapterInfo.guid = *pAdapterGUID;
---
> 	AdapterInfo.guid = *pAdapterGUID;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\utils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
48a49,50
> INT		GetWinsockVersion( void );
> 
60c62
< /* BUGBUG: [mgere] [xbox] Removed -- multiple adapters not supported on xbox
---
> 
64d65
< */
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
22a23
> #include	<WSIPX.h>
165a167,170
>  	switch ( pSPData->GetType() )
> 	{
> 		case TYPE_IP:
> 		{
167a173,188
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			DPF( 9, "Attempting to create IPX datagram socket." );
> 			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
> 			break;
> 		}
> 
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
232a254
> 		case TYPE_IPX:
318a341
> 	IDirectPlay8Address		*pSPOnlyAddress;
326c349
< 	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );
---
> 	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_NOBROADCASTFALLBACK ) ) == 0 );
341a365
> 	pSPOnlyAddress = NULL;
391a416,463
> 		HRESULT	hTempResult;
> 		GUID	SPGuid;
> 
> 
> 		//
> 		// get the SP
> 		//
> 		hTempResult = IDirectPlay8Address_GetSP( pEnumQueryData->pAddressDeviceInfo, &SPGuid );
> 		switch ( hTempResult )
> 		{
> 			//
> 			// no problem
> 			//
> 			case DPN_OK:
> 			{
> 				DNASSERT( hr == DPNERR_PENDING );
> 				break;
> 			}
> 
> 			//
> 			// pass these errors throug
> 			//
> 			case DPNERR_OUTOFMEMORY:
> 			{
> 				hr = hTempResult;
> 				goto Failure;
> 				break;
> 			}
> 
> 			//
> 			// remap other errors to addressing errors
> 			//
> 			default:
> 			{
> 				hr = DPNERR_ADDRESSING;
> 				goto Failure;
> 				break;
> 			}
> 		}
> 
> 		//
> 		// The host address is NULL, if we're using TCPIP and we're not allowed to query,
> 		// use the broadcast address.  If we're on IPX, use the broadcast address.
> 		//
> 		if ( ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) == 0 ) &&
> 			   ( IsEqualCLSID( SPGuid, CLSID_DP8SP_TCPIP ) != FALSE ) ) ||
> 			 ( IsEqualCLSID( SPGuid, CLSID_DP8SP_IPX ) != FALSE ) )
> 		{
393a466,513
> 		}
>         else
>         {
> 			HRESULT	hTempResult;
> 
> 
> 			//
> 			// Need to build address with just the SP guid.  Get it from the
> 			// device address.
> 			//
> 			DNASSERT( pSPOnlyAddress == NULL );
> 			hTempResult = COM_CoCreateInstance( CLSID_DirectPlay8Address,
> 											NULL,
> 											CLSCTX_INPROC_SERVER,
> 											IID_IDirectPlay8Address,
> 											reinterpret_cast<void**>( &pSPOnlyAddress ) );
> 			if ( hTempResult != S_OK )
> 			{
> 				DPF( 0, "Failed to create SP-Only address when non was supplied!" );
> 				hr = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 
> 			hTempResult = IDirectPlay8Address_SetSP( pSPOnlyAddress, &SPGuid );
> 			switch ( hTempResult )
> 			{
> 				//
> 				// set SP, no problem
> 				//
> 				case DPN_OK:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// failed to set SP, map error to an addressing error
> 				//
> 				default:
> 				{
> 					hr = DPNERR_ADDRESSING;
> 					goto Failure;
> 
> 					break;
> 				}
> 			}
> 
> 			pHostAddress = pSPOnlyAddress;
> 		}
526a647,678
> 			if ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) != 0 ) &&
> 				 ( pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// Copy the connect data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since the dialog is being popped, this command is in progress,
> 				// not pending.
> 				//
> 				DNASSERT( pSPData != NULL );
> 
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				pEndpoint->CopyEnumQueryData( pEnumQueryData, pDeviceAddress );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for enum query!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove our reference to it
> 				//
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
540a693,694
> 			}
> 
618a773,778
> 	if ( pSPOnlyAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pSPOnlyAddress );
> 		pSPOnlyAddress = NULL;
> 	}
> 
811c971
< 	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
---
> 	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
1024a1185,1213
> 			if ( ( pConnectData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
> 			{
> 				//
> 				// Copy the connect data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since a dialog is being displayed, the command is in-progress,
> 				// not pending.
> 				//
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				pEndpoint->CopyConnectData( pConnectData, pDeviceAddress );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for connect!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove our reference to it
> 				//
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
1025a1215,1216
> 			}
> 
1296c1487
< 	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
---
> 	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOSHOWSTATUS | DPNSPF_OKTOQUERY | DPNSPF_RELIABLE | DPNSPF_UNRELIABLE ) ) == 0 );
1510a1702,1733
> 			if ( ( pListenData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
> 			{
> 				//
> 				// Copy the listen data locally and start the dialog.  When the
> 				// dialog completes, the connection will attempt to complete.
> 				// Since this endpoint is being handed off to another thread,
> 				// make sure it's in the unbound list.  Since a dialog is being
> 				// displayed, the command state is in progress, not pending.
> 				//
> 				DNASSERT( pSPData != NULL );
> 
> 				pEndpoint->CopyListenData( pListenData, pDeviceAddress );
> 				pCommand->SetState( COMMAND_STATE_INPROGRESS );
> 				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem showing settings dialog for listen!" );
> 					DisplayDNError( 0, hr );
> 
> 					goto Failure;
> 				}
> 
> 				//
> 				// this endpoint has been handed off, remove out reference to it
> 				//
> 				pEndpoint = NULL;
> 				hr = DPNERR_PENDING;
> 
> 				goto Exit;
> 			}
> 			else
> 			{
1511a1735,1736
> 			}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
6a7,8
>   DllRegisterServer PRIVATE
>   DllUnregisterServer PRIVATE
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\wsocksp.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
28a29,30
> 	TYPE_IPX			// IPX type
> 
.  
.  
()---()---()---()---()---()---()---()---()---(--)---()---()---()---()---()---()---()---()---()---()  
.  
.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\diff\08071630.txt ===
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes differing files
.\dirs	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\comutil.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\comutil.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dbginfo.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\dneterrors.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\guidutil.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	1ece02cc	6bb05875
.\common\osind.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\osind.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\common\packbuff.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\packbuff.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\strutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\common\strutils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\appdesc.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\async.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\client.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\common.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\connect.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dllmain.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dncore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\dnet.def	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\dnet.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\core\enum_sp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\migration.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\msghandler.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\ntentry.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\paramval.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\peer.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\server.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\core\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addbase.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addcore.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\addparse.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dbginfo.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\dllmain.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.def	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\dnaddress\dnadd.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\dnaddress\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpaddr.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dplay8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\inc\dpsp8.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\connect.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\enum.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\initialize.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\sources	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\protocol\timer.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\classfac.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\cmddata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dbginfo.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\debugutils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\dirs	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dnwsock.rc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock1.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\dwnsock2.inc	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\endpoint.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\endpoint.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\iodata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipaddress.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\ipendpt.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\locals.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\locals.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\pools.h	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\rsip.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sendqueue.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\socketport.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\sources.inc	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spaddress.cpp	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\spaddress.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\spdata.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\threadpool.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\unk.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\utils.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.cpp	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
.\sp\wsock\wsocksp.def	different (D:\nt\MULTIM~1\DirectX\dplay\dnet is more recent)	????????	????????
.\sp\wsock\wsocksp.h	different (D:\xbox\private\windows\directx\dplay is more recent)	????????	????????
-- 90 files listed
-- D:\xbox\private\windows\directx\dplay : D:\nt\MULTIM~1\DirectX\dplay\dnet -- includes left-only,right-only, files
.\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\common\callstack.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\creg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\memlog.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\common\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\dnmisc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\dpguid.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\voice.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\voice.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\core\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\core\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04041115.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04061145.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04101330.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04121430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04181430.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04201700.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04211500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04241015.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\04261045.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05010945.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05021600.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05031030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05081300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05091400.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05111530.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05121300.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05151130.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05161345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05221345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\05231030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06021030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06121345.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06121445.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06141200.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\06191100.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\07171100.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\07261030.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\07281500.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\07311100.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.lst	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\diff.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\dxdiff.cmd	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\lastsync.bat	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\diff\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\dplegacy.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\dplegacy.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dnaddress\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\dnaddress\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\doc\connect.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\directnet.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\directplay8core.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dnaddress.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dndbg.txt	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dnregister.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dp8context.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dp8protocol.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpaddress.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpclassinfo.xls	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpcustombuild.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplay8.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplay8.xls	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dplobby8.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpnsvr.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpv8dmo.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoice.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoice.mpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\dpvoicenote.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\hostmigration.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\lobby8update.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\nametable.vsd	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\nametbl.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\rfc1738.txt	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\spintf.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\usercb.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\doc\winsockspwireprotocol.doc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvlib.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvlib.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvrq.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\dpnsvrq.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvlib\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpnsvr.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpnsvr.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpsvr8.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\dpsvr8.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\proctbl.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\proctbl.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\dpnsvr\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\inc\dpnsdef.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\dpnsvr\inc\dpnsvmsg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\inc\dplobby8.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\inc\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\lobby\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\classfac.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\comstuff.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dllmain.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dnlobby.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplapp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplapp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplclient.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplclient.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplcommon.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplcommon.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconnect.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconnect.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconset.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplconset.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplmsgq.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplmsgq.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplobby8int.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplparam.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplparam.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplproc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplproc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplreg.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\dplreg.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\globals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\handles.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\handles.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\lobby\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\protocol\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\protocol\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\serial\classfac.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\commanddata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\comportui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\contextfixedpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\crc.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dataport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dbginfo.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dirs	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dnserial.rc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\dpnmodem.def	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\endpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\handletable.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\handletable.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\iodata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\jobqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\locals.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemendpoint.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemport.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\modemutils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\parseclass.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\pools.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sendqueue.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\serialsp.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\sources.inc	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\spdata.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\threadpool.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\unk.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\utils.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\workthread.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\daytona\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\makefile	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\serial\win9x\sources	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\dwinsock.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipui.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxaddress.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\ipxendpt.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\registry.cpp	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\registry.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\resource.h	only in D:\nt\MULTIM~1\DirectX\dplay\dnet	--------	????????
.\sp\wsock\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\bchecker\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\daytona\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\sp\wsock\win9x\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\dirs	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\makefile	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnect.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\netconnectres.h	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\readme.txt	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.cpp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\simplepeer.dsp	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\slm.ini	only in D:\xbox\private\windows\directx\dplay	????????	--------
.\test\simplepeer\sources	only in D:\xbox\private\windows\directx\dplay	????????	--------
-- 230 files listed
.  
.  
()---()---()---()---()---()---()---()---()---(.\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
3a4
>       lobby \
5c6,7
<       core
---
>       core \
>       dpnsvr 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\comutil.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include "creg.h"
23a25
> #include <stdlib.h>
38c40
<     WCHAR                   wszFileName[_MAX_PATH];
---
>     CHAR                    szFileName[_MAX_PATH];
122c124
<     hr = COM_GetDLLName( clsid, pEntry->wszFileName, &dwSize );
---
>     hr = COM_GetDLLName( clsid, pEntry->szFileName, &dwSize );
130c132
<     pEntry->hDLL = LoadLibraryW( pEntry->wszFileName );
---
>     pEntry->hDLL = LoadLibraryA( pEntry->szFileName );
164c166
< HRESULT COM_GetDLLName( GUID guidCLSID, WCHAR *wszPath, DWORD *pdwSize )
---
> HRESULT COM_GetDLLName( GUID guidCLSID, CHAR *szPath, DWORD *pdwSize )
166,170c168,170
< // BUGBUG: [mgere] [xbox] These com wrapper functions will only be called to
< // retrieve the wsock com object, so I hard coded the dpwsock.dll to always
< // return from this function.
< //
<     WCHAR wszDLL[] = L"dpnwsock.dll";
---
>     CRegistry cregRoot;
>     CRegistry cregCLSID;
>     CRegistry cregInProc;
172c172,177
<     wcscpy( wszPath, wszDLL);
---
>     HRESULT hr;
>     BOOL fSuccess;
>     WCHAR *wszTmpPath = NULL;
>     DWORD dwTmpSize = 0;
>     int res;
>     BOOL fDefault;
174c179
<     return S_OK;
---
>     fSuccess = cregRoot.Open( HKEY_CLASSES_ROOT, L"CLSID", TRUE, FALSE );
175a181,245
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening HKEY_CLASSES_ROOT\\CLSID" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     fSuccess = cregCLSID.Open( cregRoot, &guidCLSID, TRUE, FALSE );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening specified CLSID" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     fSuccess = cregInProc.Open( cregCLSID, L"InprocServer32", TRUE, FALSE );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening inprocserver key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     cregCLSID.Close();
>     cregRoot.Close();
> 
>     fSuccess = cregInProc.ReadString( L"", wszTmpPath, pdwSize );
> 
>     if( !*pdwSize )
>     {
>         DPF( 0, "Error opening default key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     wszTmpPath = new WCHAR[*pdwSize];
> 
>     fSuccess = cregInProc.ReadString( L"", wszTmpPath, pdwSize );
> 
>     if( !fSuccess )
>     {
>         DPF( 0, "Error opening default key" );
>         hr = E_FAIL;
>         goto COM_GETDLLNAME_ERROR;
>     }
> 
>     if( FAILED( hr = STR_jkWideToAnsi(szPath,wszTmpPath, *pdwSize ) ) )
>     {
>         DPF( 0, "Error converting path to DLL to ANSI hr=0x%x", hr );
>         hr = E_FAIL;
>     }
> 
>     delete [] wszTmpPath;
> 
>     return hr;
> 
> COM_GETDLLNAME_ERROR:
> 
>     if( wszTmpPath )
>         delete [] wszTmpPath;
> 
>     return hr;
> 
192c262
< // BUGBUG: [mgere] [xbox] Added this temporarily
---
>     hr = CoCreateInstance( rclsid, pUnkOuter, dwClsContext, riid, ppv );
194,195c264,265
< COM_Init();
< 
---
>     if( hr == CO_E_NOTINITIALIZED )
>     {
217a288,291
> 
>         return hr;
> 
>     }
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\comutil.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
21c21
< HRESULT COM_GetDLLName( GUID guidCLSID, WCHAR *szPath, DWORD *pdwSize );
---
> HRESULT COM_GetDLLName( GUID guidCLSID, CHAR *szPath, DWORD *pdwSize );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
29a37,65
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "UNKNOWN_MODULE"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectNet] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNetDebug"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\dneterrors.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20,23
> // vanceo - changed to stdio for printf
> //#include	<iostream.h>
> #include	<stdio.h>
> 
78a83,92
> 			// output to console
> 			case DPNERR_OUT_CONSOLE:
> 			{
> 				// Also see the change from <iostream.h> to <stdio.h> above
> 				#pragma TODO(vanceo, "Changed cout to printf so NT build environment will work, figure this out.")
> 				//cout << endl << pString << endl;
> 				printf("\n%s\n", pString);
> 				break;
> 			}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\guidutil.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
15c15
< #include <wchar.h>
---
> #include "stdio.h"
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34,37
> #ifdef	_WIN64
> #define	MEMORY_CRC			0X5AA55AA55AA55AA5
> #define	GUARD_SIGNATURE		0x0F1E2D3C4B5A6978
> #else
35a40
> #endif	// _WIN64
40a46,52
> //
> // enumerated values to indicate how to report memory leaks
> //
> #define	MEMORY_LEAK_REPORT_NONE		0x00000000
> #define	MEMORY_LEAK_REPORT_DPF		0x00000001
> #define	MEMORY_LEAK_REPORT_DIALOG	0x00000002
> 
60a73
> #ifdef	_X86_
61a75,77
> #else
> #define	ASSERT( arg )	if ( arg == FALSE ) { DebugBreak(); }
> #endif
94a111,116
> // OS items
> //
> static	UINT_PTR			g_OSVersion;
> static	HINSTANCE			g_hApplicationInstance;
> 
> //
103a126,128
> static int	DisplayCallStack( const char *const pszMsg,
> 							  const char *const pszTitle,
> 							  const char *const pCallStack );
121a147
> 	OSVERSIONINFO	OSVersionInfo;
122a149
> 
130a158,186
> 	// note OS version
> 	//
> 	memset( &OSVersionInfo, 0x00, sizeof( OSVersionInfo ) );
> 	OSVersionInfo.dwOSVersionInfoSize = sizeof( OSVersionInfo );
> 	if ( GetVersionEx( &OSVersionInfo ) == FALSE )
> 	{
> 		goto Failure;
> 	}
> 	g_OSVersion = OSVersionInfo.dwPlatformId;
> 
> 	//
> 	// note application instance
> 	//
> 	g_hApplicationInstance = GetModuleHandle( NULL );
> 	if ( g_hApplicationInstance == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to GetModuleHandle: 0x%x", dwError );
> 		goto Failure;
> 	}
> 
> //#pragma	BUGBUG( johnkan, "---->  Hard-coded Win9x emulation!!  <----" )
> //	g_OSVersion = VER_PLATFORM_WIN32_WINDOWS;
> 
> 
> 	//
229a286,287
> 		switch ( DNGetOSType() )
> 		{
232a291,292
> 			case VER_PLATFORM_WIN32_NT:
> 			{
257a318,328
> 				break;
> 			}
> 
> 			//
> 			// other OS, heap checking not available
> 			//
> 			default:
> 			{
> 				break;
> 			}
> 		}
290a362,393
> // DNGetOSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OS type
> // ------------------------------
> UINT_PTR	DNGetOSType( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_OSVersion;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DNGetApplcationInstance - application instance
> //
> // Entry:		Nothing
> //
> // Exit:		Application instance
> // ------------------------------
> HINSTANCE	DNGetApplicationInstance( void )
> {
> 	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
> 	return	g_hApplicationInstance;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
361a465
> //#ifdef	_WIN32
390a495
> //#endif	// _WIN32
391a497,518
> 
> //#ifdef	_WIN64
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	if ( pTime1->Time < pTime2->Time )
> //	{
> //		iReturnValue = -1;
> //	}
> //	else
> //	{
> //		if ( pTime1->Time == pTime2->Time )
> //		{
> //			iReturnValue = 0;
> //		}
> //		else
> //		{
> //			iReturnValue = 1;
> //		}
> //	}
> //#endif	// _WIN64
> 
417a545
> #ifdef	_X86_
429a558,608
> 
> #else	// _X86_
> 
> /*
> #ifdef	_ALPHA_
> 	// debug me
> 	DebugBreak();
> 
> 	__asm{ mov	$t0, *pTime1
> 		   mov	$t1, *pTime2
> 		   addq	$t0, $t1
> 		   mov	*pTimeResult, $t0
> 	};
> #else	// _ALPHA_
> */
> 
> //#ifdef	_WIN32
> 	DWORD	dwTempLowTime;
> 
> 
> 	dwTempLowTime = pTime1->Time32.TimeLow;
> 	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow + pTime2->Time32.TimeLow;
> 	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh + pTime2->Time32.TimeHigh;
> 
> 	//
> 	// check for overflow in low 32-bits and increment high value if applicable
> 	//
> 	if ( pTimeResult->Time32.TimeLow < dwTempLowTime )
> 	{
> #pragma	BUGBUG( johnkan, "Test this!" )
> 		// debug me
> 		DebugBreak();
> 		pTimeResult->Time32.TimeHigh++;
> 	}
> //#endif	// _WIN32
> 
> //#ifdef	_WIN64
> //	DEBUG_ONLY( UINT_PTR	ReferenceTime );
> //
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	DEBUG_ONLY( ReferenceTime = pTime1->Time );
> //	*pTimeResult = pTime1->Time + pTime2->Time;
> //	DNASSERT( *pTimeResult >= ReferenceTime );
> //
> //#endif	// _WIN64
> 
> // #endif	// _ALPHA_
> 
> #endif	// _X86_
455a635,636
> #ifdef	_X86_
> 
467a649,695
> 
> #else	// _X86_
> 
> /*
> #ifdef	_ALPHA_
> 	// debug me
> 	DebugBreak();
> 
> 	mov		$t0, *pTime1
> 	mov		$t1, *pTime2
> 	addq	$t0, $t1
> 	mov		*pTimeResult, $t0
> #else	// _ALPHA_
> */
> 
> //#ifdef	_WIN32
> 	DWORD	dwTempLowTime;
> 
> 
> 	dwTempLowTime = pTime1->Time32.TimeLow;
> 	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow - pTime2->Time32.TimeLow;
> 	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh - pTime2->Time32.TimeHigh;
> 
> 	//
> 	// check for underflow in low 32-bits and decrement high value if applicable
> 	//
> 	if ( pTimeResult->Time32.TimeLow > dwTempLowTime )
> 	{
> #pragma	BUGBUG( johnkan, "Test this!" )
> 		// debug me
> 		DebugBreak();
> 
> 		pTimeResult->Time32.TimeHigh--;
> 	}
> //#endif	// _WIN32
> 
> //#ifdef	_WIN64
> //	// debug me!
> //	DNASSERT( FALSE );
> //
> //	DNASSERT( pTime1->Time > pTime2->Time );
> //	pTimeResult = pTime1->Time - pTime2->Time;
> //#endif	// _WIN64
> 
> // #endif	// _ALPHA_
> 
> #endif	// _X86_
688a917,919
> 		void	NoteCurrentCallStack( void ) { m_CallStack.NoteCurrentCallStack(); }
> 		void	GetCallStack( char *const pBuffer ) const { m_CallStack.GetCallStackString( pBuffer ); }
> 
707a939
> 		CCallStack<DN_MEMORY_CALL_STACK_DEPTH>	m_CallStack;
798a1031
> 		pMemoryLink->NoteCurrentCallStack();
908a1142
> 	char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
925a1160,1163
> #ifdef _IA64_
>                       // 8/05/2000(RichGr) - IA64: GetSize() returns UINT_PTR (64-bit), so we may as well handle in hex as %d expects a DWORD.
> 					  "Memory block: 0x%p\tAllocated size: 0x%p bytes\nCorruption Type: ",
> #else
926a1165
> #endif
943,944c1182,1193
< 			DPF( 0, "%s%s\n", "Memory Corruption!", MessageString );
< //					DNASSERT( FALSE );
---
> 			pMemoryLink->GetCallStack( CallStackBuffer );
> 			MessageReturn = DisplayCallStack( MessageString, "Memory Corruption!", CallStackBuffer );
> 			switch ( MessageReturn )
> 			{
> 				case IDABORT:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 
> 				case IDIGNORE:
> 				{
948a1198,1206
> 					break;
> 				}
> 
> 				case IDRETRY:
> 				{
> 					DNASSERT( FALSE );
> 					break;
> 				}
> 			}
979a1238
> 	DWORD		dwDisplayFlags;
980a1240
> 
983a1244
> 	fDisplayLeaks = TRUE;
986a1248,1249
> 	dwDisplayFlags = GetProfileIntA( PROF_SECT, "MemoryLeakOutput", MEMORY_LEAK_REPORT_DPF );
> 	
993a1257
> 		char		CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
1001a1266,1269
> #ifdef _IA64_
>         // 8/05/2000(RichGr) - IA64: GetSize() returns UINT_PTR (64-bit), so we may as well handle in hex as %d expects a DWORD.
> 		wsprintf( LeakSizeString, "0x%p bytes leaked at address 0x%p!\n", pTemp->GetSize(), pTemp->GetDataPointer() );
> #else
1002a1271
> #endif
1007,1008c1276
< 			DPF( 0, "%s%s\n", DialogTitle, LeakSizeString );
< //						DNASSERT( FALSE );
---
> 		pTemp->GetCallStack( CallStackBuffer );
1009a1278,1328
> 
> 		if ( ( dwDisplayFlags & MEMORY_LEAK_REPORT_DPF ) != 0 )
> 		{
> 			DPF( 0, "%s%s%s\n", DialogTitle, LeakSizeString, CallStackBuffer );
> 		}
> 
> 		if ( ( dwDisplayFlags & MEMORY_LEAK_REPORT_DIALOG ) != 0  )
> 		{
> 			if ( fDisplayLeaks != FALSE )
> 			{
> 				MessageReturn = DisplayCallStack( LeakSizeString, DialogTitle, CallStackBuffer );
> 				switch ( MessageReturn )
> 				{	
> 					//
> 					// stop application now
> 					//
> 					case IDABORT:
> 					{
> 						fDisplayLeaks = FALSE;
> 						break;
> 					}
> 
> 					//
> 					// display next leak
> 					//
> 					case IDIGNORE:
> 					{
> 						break;
> 					}
> 
> 					//
> 					// stop in the debugger
> 					//
> 					case IDRETRY:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 
> 					//
> 					// unknown
> 					//
> 					default:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 				}
> 			}
> 		}
> 
1022a1342,1485
> 
> 
> #if	defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
> //**********************************************************************
> //**
> //** THIS IS THE STACK TRACKING SECTION.  ONLY ADD FUNCTIONS HERE THAT ARE
> //** RELATED TO TRACKING THE CALL STACK!!
> //**
> //**********************************************************************
> 
> 
> ////**********************************************************************
> //// ------------------------------
> //// DNGetStackTop - return pointer to top of stack
> ////
> //// Entry:		Nothing
> ////
> //// Exit:		Pointer to top of stack
> //// ------------------------------
> //static void	*DNGetStackTop( void )
> //{
> //	void	*pReturn;
> //
> //	_asm	mov eax,dword ptr fs:[4]
> //	_asm	mov pReturn, eax
> //	return	pReturn;
> //}
> ////**********************************************************************
> //
> //
> ////**********************************************************************
> //// ------------------------------
> //// DNGetStackBottom - return pointer to bottom of call stack
> ////
> //// Entry:		Nothing
> ////
> //// Exit:		Pointer to bottom of call stack
> //// ------------------------------
> //static void	*DNGetStackBottom( void )
> //{
> //	void	*pReturn;
> //
> //	_asm	mov eax,dword ptr fs:[8]
> //	_asm	mov pReturn, eax
> //	return	pReturn;
> //}
> ////**********************************************************************
> 
> 
> ////**********************************************************************
> //// ------------------------------
> //// DNGetCallStack - get a call stack
> ////
> //// Entry:		Pointer to call stack array
> ////				Number of calls to report
> ////
> //// Exit:		Nothing
> //// ------------------------------
> //static	void	DNGetCallStack( const void **const pCallStack, const UINT_PTR Depth )
> //{
> //	void		**CallersEBP;
> //	void		*ReturnAddr;
> //	UINT_PTR	i,iCount;
> //	void		*StackTop;
> //	void		*StackBottom;
> //	static const	void	*min_dll_base = NULL;
> //
> //
> //	StackTop = DNGetStackTop();
> //	StackBottom = DNGetStackBottom();
> //	memset(	pCallStack, 0x00, sizeof( *pCallStack ) * Depth );
> //
> //	_asm
> //	{
> //		mov eax,[ebp]
> //		mov CallersEBP,eax
> //	}
> //
> //	__try
> //	{
> //		//
> //		// this code can generate exception if it steps back too far...
> //		//
> //		for ( i = 0, iCount = 0; i < Depth; iCount++ )
> //		{
> //			if ( ( CallersEBP < StackBottom ) || ( CallersEBP >= StackTop ) )
> //				break;
> //			ReturnAddr = CallersEBP[ 1 ];
> //			if ( ( iCount > 0 ) || ( ReturnAddr >= min_dll_base ) ) // iCount check skips memory_alloc_debug
> //				pCallStack[ i++ ] = ReturnAddr;
> //			CallersEBP = reinterpret_cast<void**>( *CallersEBP ); // get callers callers ebp
> //		}
> //	}
> //	__except( 1 )  // went too far back on the stack, fill up rest of array with zeros
> //	{
> //		DPF( 0, "Benign access violation creating return address stack." );
> //	}
> //}
> ////**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // DisplayCallStack - display a call stack message box
> //
> // Entry:		Pointer to information string
> //				Pointer to title string
> //				Pointer to call stack string
> //
> // Exit:		Dialog return code
> // ------------------------------
> static int	DisplayCallStack( const char *const pszMsg, const char *const pszTitle, const char *const pCallStackString )
> {
> 	MSGBOXPARAMS	MessageBoxParams;
> 	char 			szStackTraceMsg[ CALLSTACK_BUFFER_SIZE ];
> 
> 
>     strcpy( szStackTraceMsg, pszMsg );
> 	strcat( szStackTraceMsg, pCallStackString );
> 
> 	//
> 	// display message box
> 	//
> 	memset( &MessageBoxParams, 0x00, sizeof( MessageBoxParams ) );
> 	MessageBoxParams.cbSize = sizeof( MessageBoxParams );
> 	MessageBoxParams.lpszText = szStackTraceMsg;
> 	MessageBoxParams.lpszCaption = pszTitle;
> 	MessageBoxParams.dwStyle = MB_ABORTRETRYIGNORE | MB_SETFOREGROUND | MB_TOPMOST | MB_DEFBUTTON2;
> 	MessageBoxParams.hInstance = NULL;
> 
> 	return MessageBoxIndirect( &MessageBoxParams );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> //**
> //** END OF CALL STACK TRACKING SECTION.
> //**
> //**********************************************************************
> #endif	// defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
> 
> 
> 
1117a1581
> 	static	BOOL	fDisplayCallStacks = TRUE;
1135a1600,1603
> 	if ( pCriticalSection->LockCount == 0 )
> 	{
> 		pCriticalSection->CallStack.NoteCurrentCallStack();
> 	}
1141a1610,1614
> 			if ( fDisplayCallStacks != FALSE )
> 			{
> 				char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
> 
> 
1146,1147c1619,1651
< 			    DPF( 0, "%s%s\n", "DNCritical section has been reentered!", "Check stack trace for function that originally held the lock." );
< //						DNASSERT( FALSE );
---
> 				pCriticalSection->CallStack.GetCallStackString( CallStackBuffer );
> 				switch ( DisplayCallStack( "Stack trace of function that originally held the lock:",
> 										   "DNCritical section has been reentered!",
> 										   CallStackBuffer ) )
> 				{
> 					//
> 					// don't display any more critical section warnings!
> 					//
> 					case IDABORT:
> 					{
> 						fDisplayCallStacks = FALSE;
> 						break;
> 					}
> 
> 					//
> 					// acknowledged
> 					//
> 					case IDIGNORE:
> 					{
> 						break;
> 					}
> 
> 					//
> 					// stop in debugger
> 					//
> 					case IDRETRY:
> 					{
> 						DNASSERT( FALSE );
> 						break;
> 					}
> 				}
> 			}
> 
1180a1685
> 		memset( &pCriticalSection->CallStack, 0x00, sizeof( pCriticalSection->CallStack ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\osind.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18,19
> #include	"CallStack.h"
> 
29a32,34
> #define	DN_MEMORY_CALL_STACK_DEPTH				12
> #define	DN_CRITICAL_SECTION_CALL_STACK_DEPTH	10
> 
53a59
> 	CCallStack< DN_CRITICAL_SECTION_CALL_STACK_DEPTH > 	CallStack;
85a92,101
> 
> //
> // Function to get OS version.  Supported returns:
> //	VER_PLATFORM_WIN32_WINDOWS
> //	VER_PLATFORM_WIN32_NT
> //	VER_PLATFORM_WIN32s
> //	
> //
> UINT_PTR	DNGetOSType( void );
> HINSTANCE	DNGetApplicationInstance( void );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\packbuff.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
136a137,207
> // CPackedBuffer::AddStringToBack
> //
> // Entry:		Pointer to source string
> //
> // Exit:		Error Code:	DPN_OK					if able to add
> //							DPNERR_BUFFERTOOSMALL	if buffer is full
> // ------------------------------
> 
> HRESULT CPackedBuffer::AddStringToBack( const char *const pszString )
> {
> 	HRESULT	hr;
> 	DWORD	dwStringSize;
> 	DWORD	dwBufferSize;
> 
> 
> 	DNASSERT( pszString != NULL );
> 	
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	dwStringSize = 0;
> 	hr = STR_AnsiToWide( pszString,
> 						 -1,
> 						 NULL,
> 						 &dwStringSize );
> 	if ( hr != DPNERR_BUFFERTOOSMALL )
> 	{
> 		DNASSERT( hr != DPN_OK );
> 		goto Failure;
> 	}
> 	
> 	dwBufferSize = dwStringSize * sizeof( WCHAR );
> 	m_dwRequired += dwBufferSize;
> 	if ( !m_bBufferTooSmall )
> 	{
> 		if (m_dwRemaining >= dwBufferSize)
> 		{
> 			m_pTail -= dwBufferSize;
> 			m_dwRemaining -= dwBufferSize;
> 			hr = STR_AnsiToWide( pszString,
> 								 -1,
> 								 reinterpret_cast<WCHAR*>( m_pTail ),
> 								 &dwStringSize );
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			DNASSERT( ( dwStringSize * sizeof( WCHAR ) ) == dwBufferSize );
> 		}
> 		else
> 		{
> 			m_bBufferTooSmall = TRUE;
> 		}
> 	}
> 
> 	if ( m_bBufferTooSmall )
> 	{
> 		hr = DPNERR_BUFFERTOOSMALL;
> 	}
> 
> Exit:
> 	return	hr;
> 
> Failure:
> 	goto Exit;
> }
> //**********************************************************************
> // ------------------------------
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\packbuff.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62a63
> 	HRESULT	AddStringToBack( const char *const pszString );
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2c17,26
< TARGETTYPE=LIBRARY
---
> 
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
3a28
> TARGETTYPE=LIBRARY
5,9d29
< !ifdef _BUILD_FOR_WIN2000
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< LINKER_FLAGS=-align:32
< !endif
11c31,35
< INCLUDES=..\inc
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
13c37,41
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS)
15c43,47
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
17,18c49,52
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> INCLUDES=$(DXROOT)\inc;..\inc
> 
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
21d54
< MSC_WARNING_LEVEL=/W3 /WX
22a56,62
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
31a72
>         creg.cpp \
36c77,88
< TARGETLIBS=
---
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE
> MSC_OPTIMIZATION=/Odi /Zi
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
> 
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\strutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include "DNetErrors.h"
20a22,23
> #undef DPF_MODNAME
> #define DPF_MODNAME "STR_WideToAnsi"
22c25,48
< // BUGBUG: [mgere] [xbox] UnicodeToMultiByteN and MultiByteToUnicodeN were Taken from nlsxlat.c
---
> //**********************************************************************
> // ------------------------------
> // WideToANSI - convert a wide string to an ANSI string
> //
> // Entry:		Pointer to source wide string
> //				Size of source string (in WCHAR units, -1 implies NULL-terminated)
> //				Pointer to ANSI string destination
> //				Pointer to size of ANSI destination
> //
> // Exit:		Error code:
> //				DPNERR_GENERIC = operation failed
> //				DPN_OK = operation succeded
> //				DPNERR_BUFFERTOOSMALL = destination buffer too small
> // ------------------------------
> HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
> 						const DWORD dwWCHARStringLength,
> 						char *const pString,
> 						DWORD *const pdwStringLength )
> {
> 	HRESULT	hr;
> 	int		iReturn;
> 	BOOL	fDefault;
> 	char	cMilleniumHackBuffer;	
> 	char	*pMilleniumHackBuffer;
24,29d49
< HRESULT
< UnicodeToMultiByteN(
<     OUT PCH MultiByteString,
<     IN ULONG MaxBytesInMultiByteString,
<     IN PWCH UnicodeString,
<     IN ULONG BytesInUnicodeString)
31c51,53
< /*++
---
> 	DNASSERT( pWCHARString != NULL );
> 	DNASSERT( pdwStringLength != NULL );
> 	DNASSERT( ( pString != NULL ) || ( *pdwStringLength == 0 ) );
33c55,60
< Routine Description:
---
> 	//
> 	// Initialize.  A hack needs to be implemented because their paramter
> 	// validation is screwed and when you pass zero for a destination size, you
> 	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
> 	//
> 	hr = DPN_OK;
35,37c62,69
<     This functions converts the specified unicode source string into an
<     ansi string. The translation is done with respect to the
<     ANSI Code Page (ACP) loaded at boot time.
---
> 	if ( *pdwStringLength == 0 )
> 	{
> 		pMilleniumHackBuffer = &cMilleniumHackBuffer;
> 	}
> 	else
> 	{
> 		pMilleniumHackBuffer = pString;
> 	}
39c71,83
< Arguments:
---
> 	fDefault = FALSE;
> 	iReturn = WideCharToMultiByte( CP_ACP,					// code page (default ANSI)
> 								   0,						// flags (none)
> 								   pWCHARString,			// pointer to WCHAR string
> 								   dwWCHARStringLength,		// size of WCHAR string
> 								   pMilleniumHackBuffer,	// pointer to destination ANSI string
> 								   *pdwStringLength,		// size of destination string
> 								   NULL,					// pointer to default for unmappable characters (none)
> 								   &fDefault				// pointer to flag indicating that default was used
> 								   );
> 	if ( iReturn == 0 )
> 	{
> 		DWORD	dwError;
41,43d84
<     MultiByteString - Returns an ansi string that is equivalent to the
<         unicode source string.  If the translation can not be done,
<         an error is returned.
45,47c86,100
<     MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
<         written to MultiByteString.  If this causes MultiByteString to be a
<         truncated equivalent of UnicodeString, no error condition results.
---
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to convert WCHAR to multi-byte!" );
> 		DisplayDNError( 0, dwError );
> 		hr = DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		if ( *pdwStringLength == 0 )
> 		{
> 			hr = DPNERR_BUFFERTOOSMALL;
> 		}
> 		else
> 		{
> 			DNASSERT( hr == DPN_OK );
> 		}
49,50c102,103
<     BytesInMultiByteString - Returns the number of bytes in the returned
<         ansi string pointed to by MultiByteString.
---
> 		*pdwStringLength = iReturn;
> 	}
52,53c105,109
<     UnicodeString - Supplies the unicode source string that is to be
<         converted to ansi.
---
> 	//
> 	// if you hit this ASSERT it's because you've probably got ASCII text as your
> 	// input WCHAR string.  Double-check your input!!
> 	//
> 	DNASSERT( fDefault == FALSE );
55,56c111,113
<     BytesInUnicodeString - The number of bytes in the the string pointed to by
<         UnicodeString.
---
> 	return	hr;
> }
> //**********************************************************************
58d114
< Return Value:
60,63c116,133
<     SUCCESS - The conversion was successful
< 
< --*/
< 
---
> //**********************************************************************
> // ------------------------------
> // ANSIToWide - convert an ANSI string to a wide string
> //
> // Entry:		Pointer to source multi-byte (ANSI) string
> //				Size of source string (-1 imples NULL-terminated)
> //				Pointer to multi-byte string destination
> //				Pointer to size of multi-byte destination (in WCHAR units)
> //
> // Exit:		Error code:
> //				DPNERR_GENERIC = operation failed
> //				DPN_OK = operation succeded
> //				DPNERR_BUFFERTOOSMALL = destination buffer too small
> // ------------------------------
> HRESULT	STR_AnsiToWide( const char *const pString,
> 						const DWORD dwStringLength,
> 						WCHAR *const pWCHARString,
> 						DWORD *const pdwWCHARStringLength )
65,66c135,138
<     ULONG LoopCount;
<     ULONG CharsInUnicodeString;
---
> 	HRESULT	hr;
> 	int		iReturn;
> 	WCHAR	MilleniumHackBuffer;
> 	WCHAR	*pMilleniumHackBuffer;
68d139
<     CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);
70,71c141,143
<     LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
<                  CharsInUnicodeString : MaxBytesInMultiByteString;
---
> 	DNASSERT( pString != NULL );
> 	DNASSERT( pdwWCHARStringLength != NULL );
> 	DNASSERT( ( pWCHARString != NULL ) || ( *pdwWCHARStringLength == 0 ) );
73c145,150
<     while (LoopCount) {
---
> 	//
> 	// Initialize.  A hack needs to be implemented because their paramter
> 	// validation is screwed and when you pass zero for a destination size, you
> 	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
> 	//
> 	hr = DPN_OK;
75c152,170
<         *MultiByteString = (*UnicodeString < 256) ? (UCHAR)*UnicodeString : '?';
---
> 	if ( *pdwWCHARStringLength == 0 )
> 	{
> 		pMilleniumHackBuffer = &MilleniumHackBuffer;
> 	}
> 	else
> 	{
> 		pMilleniumHackBuffer = pWCHARString;
> 	}
> 	
> 	iReturn = MultiByteToWideChar( CP_ACP,					// code page (default ANSI)
> 								   0,						// flags (none)
> 								   pString,					// pointer to multi-byte string			
> 								   dwStringLength,			// size of string (assume null-terminated)
> 								   pMilleniumHackBuffer,	// pointer to destination wide-char string
> 								   *pdwWCHARStringLength	// size of destination in WCHARs
> 								   );
> 	if ( iReturn == 0 )
> 	{
> 		DWORD	dwError;
77,80d171
<         UnicodeString++;
<         MultiByteString++;
<         LoopCount--;
<     }
82,83c173,187
<     return DPN_OK;
< }
---
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to convert multi-byte to WCHAR!" );
> 		DisplayDNError( 0, dwError );
> 		hr = DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		if ( *pdwWCHARStringLength == 0 )
> 		{
> 			hr = DPNERR_BUFFERTOOSMALL;
> 		}
> 		else
> 		{
> 			DNASSERT( hr == DPN_OK );
> 		}
84a189,190
> 		*pdwWCHARStringLength = iReturn;
> 	}
86,151c192
< HRESULT
< MultiByteToUnicodeN(
<     OUT PWCH UnicodeString,
<     IN ULONG MaxBytesInUnicodeString,
<     IN PCH MultiByteString,
<     IN ULONG BytesInMultiByteString)
< 
< /*++
< 
< Routine Description:
< 
<     This functions converts the specified ansi source string into a
<     Unicode string. The translation is done with respect to the
<     ANSI Code Page (ACP) installed at boot time.  Single byte characters
<     in the range 0x00 - 0x7f are simply zero extended as a performance
<     enhancement.  In some far eastern code pages 0x5c is defined as the
<     Yen sign.  For system translation we always want to consider 0x5c
<     to be the backslash character.  We get this for free by zero extending.
< 
<     NOTE: This routine only supports precomposed Unicode characters.
< 
< Arguments:
< 
<     UnicodeString - Returns a unicode string that is equivalent to
<         the ansi source string.
< 
<     MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
<         written to UnicodeString.  If this causes UnicodeString to be a
<         truncated equivalent of MultiByteString, no error condition results.
< 
<     BytesInUnicodeString - Returns the number of bytes in the returned
<         unicode string pointed to by UnicodeString.
< 
<     MultiByteString - Supplies the ansi source string that is to be
<         converted to unicode.  For single-byte character sets, this address
<         CAN be the same as UnicodeString.
< 
<     BytesInMultiByteString - The number of bytes in the string pointed to
<         by MultiByteString.
< 
< Return Value:
< 
<     SUCCESS - The conversion was successful.
< 
< 
< --*/
< 
< {
<     ULONG LoopCount;
<     ULONG MaxCharsInUnicodeString;
< 
<     MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);
< 
<     LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
<                  MaxCharsInUnicodeString : BytesInMultiByteString;
< 
<     while (LoopCount) {
< 
<         *UnicodeString = (WCHAR)(UCHAR)(*MultiByteString);
< 
<         UnicodeString++;
<         MultiByteString++;
<         LoopCount--;
<     }
< 
<     return DPN_OK;
---
> 	return	hr;
152a194
> //**********************************************************************
154a197
> 
174a218,220
> 	int rval;
> 	BOOL bDefault = FALSE;
> 
182c228,238
< 	UnicodeToMultiByteN( lpStr, cchStr, (PWCH) lpWStr, cchStr*sizeof(WCHAR));
---
> 	// use the default code page (CP_ACP)
> 	// -1 indicates WStr must be null terminated
> 	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,
> 			NULL,&bDefault);
> 
> 	if (bDefault)
> 	{
> 		DPF(3,"!!! WARNING - used default string in WideToAnsi conversion.!!!");
> 		DPF(3,"!!! Possible bad unicode string - (you're not hiding ansi in there are you?) !!! ");
> 		return DPNERR_CONVERSION;
> 	}
188a245,251
> //	WideToAnsi
> //
> //	Convert a WCHAR (Wide) string to a CHAR (ANSI) string
> //
> //	CHAR	*pStr		CHAR string
> //	WCHAR	*pWStr		WCHAR string
> //	int		iStrSize	size (in bytes) of buffer pointed to by lpStr
189a253,295
> #define DPF_MODNAME "STR_AllocAndConvertToANSI"
> /*
>  ** GetAnsiString
>  *
>  *  CALLED BY: Everywhere
>  *
>  *  PARAMETERS: *ppszAnsi - pointer to string
>  *				lpszWide - string to copy
>  *
>  *  DESCRIPTION:	  handy utility function
>  *				allocs space for and converts lpszWide to ansi
>  *
>  *  RETURNS: string length
>  *
>  */
> HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide)
> {
> 	int iStrLen;
> 	BOOL bDefault;
> 	
> 	DNASSERT(ppszAnsi);
> 
> 	if (!lpszWide)
> 	{
> 		*ppszAnsi = NULL;
> 		return S_OK;
> 	}
> 
> 	*ppszAnsi = new char[wcslen(lpszWide)+1];
> 	if (!*ppszAnsi)	
> 	{
> 		DPF(0, "could not get ansi string -- out of memory");
> 		return E_OUTOFMEMORY;
> 	}
> 
> 	iStrLen = WideCharToMultiByte(CP_ACP,0,lpszWide,-1,*ppszAnsi,wcslen(lpszWide)+1,
> 			NULL,&bDefault);
> 
> 	return DPN_OK;
> } // OSAL_AllocAndConvertToANSI
> 
> 
> #undef DPF_MODNAME
208a315,316
> 	int rval;
> 
216c324
< 	MultiByteToUnicodeN( lpWStr, cchWStr*sizeof(WCHAR), (CHAR *) lpStr, cchWStr );
---
> 	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);
219a328
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\common\strutils.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide);
21a23,31
> HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
> 						const DWORD dwWCHARStringLength,
> 						char *const pString,
> 						DWORD *const pdwStringLength );
> 
> HRESULT	STR_AnsiToWide( const char *const pString,
> 						const DWORD dwStringLength,
> 						WCHAR *const pWCHARString,
> 						DWORD *const pdwWCHARStringLength );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\appdesc.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
39d38
< #include <wchar.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
143c143,145
< #include <mmsystem.h>
---
> #include "dpnsdef.h"
> #include "dpnsvrq.h"
> #include "dpnsvlib.h"
206,207c208
< // BUGBUG: [mgere] [xbox] Completely removed this function since Xbox doesn't have multiple adapters.
< /*
---
> 
322d322
< */
408,409c408
< // BUGBUG: [mgere] [xbox] Need to figure out what to do with this.  We can't enumerate adapters.
< /*
---
> 
463c462
< */
---
> 
520c519
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
542c541
< 	pDeviceInfo->lpVtbl->GetURLW(pDeviceInfo,DP8ABuffer,&DP8ASize);
---
> 	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer,&DP8ASize);
696d694
< // BUGBUG: [mgere] [xbox] This shouldn't be needed since we don't have multiple adapters.
1218c1216
< 		//	generate a completion for the buffer.
---
> 		//	generate a completion for the buffer.
1263,1264c1261,1262
< 	WCHAR			DP8ABuffer[512];
< 	WCHAR			DP8ABuffer2[512];
---
> 	CHAR			DP8ABuffer[512];
> 	CHAR			DP8ABuffer2[512];
1280c1278
< 	pRemoteAddr->lpVtbl->GetURLW(pRemoteAddr,DP8ABuffer,&DP8ASize);
---
> 	pRemoteAddr->lpVtbl->GetURLA(pRemoteAddr,DP8ABuffer,&DP8ASize);
1283c1281
< 	pDeviceInfo->lpVtbl->GetURLW(pDeviceInfo,DP8ABuffer2,&DP8ASize);
---
> 	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer2,&DP8ASize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\async.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
128,129c128
< // BUGBUG: [mgere] [xbox] Removed (see cpp file)
< /*
---
> 
135c134
< */
---
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
97a98
> #include "dplobby8.h"
258a260,279
> 	/*
> 	*
> 	*	TIME BOMB
> 	*
> 	*/
> 
> #ifndef DX_FINAL_RELEASE
> {
> #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
> 	SYSTEMTIME st;
> 	GetSystemTime(&st);
> 
> 	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
> 	{
> 		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
> //		return E_FAIL;
> 	}
> }
> #endif
> 
319a341,342
> 	pdnObject->pIDP8LobbiedApplication = NULL;
> 	pdnObject->dpnhLobbyConnection = NULL;
913a937,942
> 	if( pdnObject->pIDP8LobbiedApplication)
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release( pdnObject->pIDP8LobbiedApplication );
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 	}
> 
1098c1127
< 	{
---
> 	{
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\client.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
64d63
< #include <wchar.h>
102c101
< typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
166a167
> #include "DPLobby8.h"
194a196
> #include "DNMisc.h"
204a207,209
> #include "dpnsdef.h"
> #include "dpnsvrq.h"
> #include "dpnsvlib.h"
206,207d210
< #include <mmsystem.h>
< #include <wchar.h>
629a633,641
> 	pdnObject->dpnhLobbyConnection = NULL;
> 
> 	// Release our hold on the lobbiedapplication
> 	if( pdnObject->pIDP8LobbiedApplication) 
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release(pdnObject->pIDP8LobbiedApplication);
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 	}
> 
1070a1083,1086
> 	if (dwFlags & DPNCONNECT_OKTOQUERYFORADDRESSING)
> 	{
> 		dwConnectFlags |= DPNCONNECT_OKTOQUERYFORADDRESSING;
> 	}
1188d1203
< // BUGBUG: [mgere] [xbox] Set breakpoint here and see if it ever gets in here.
1204,1206d1218
< // BUGBUG: [mgere] [xbox] I know this is busted.  Remove this whole section about enumerating adapters
< // and check if it's ok.
< /*
1237d1248
< */
1837a1849,1856
> 	//	Update Lobby status
> 	//
> 	if (fWasConnected)
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_DISCONNECTED);
> 	}
> 
> 	//
2016c2035
< 	{
---
> 	{
2403,2404d2421
< // BUGBUG [mgere] [xbox] Temporarily removed until a CoCreateGuid call is implemented
< #ifdef _BUILD_FOR_WIN2000
2410d2426
< #endif
2473a2490,2498
> 	//	Inform DPNSVR of LISTENs
> 	//
> 	if( !(pdnObject->dnApplicationDescription.dwFlags & DPNSESSION_NODPNSVR) )
> 	{
> 		DPF(3,"Registering with DPNSVR");
> 		DNRegisterWithDPNSVR(pdnObject);
> 	}
> 
> 	//
2582a2608,2612
> 	//	Update Lobby status
> 	//
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_CONNECTED);
> 
> 	//
3859c3889
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
4016c4046
< 	pIHost->lpVtbl->GetURLW(pIHost,DP8ABuffer,&DP8ASize);
---
> 	pIHost->lpVtbl->GetURLA(pIHost,DP8ABuffer,&DP8ASize);
4020c4050
< 	pIDevice->lpVtbl->GetURLW(pIDevice,DP8ABuffer,&DP8ASize);
---
> 	pIDevice->lpVtbl->GetURLA(pIDevice,DP8ABuffer,&DP8ASize);
4084c4114
< 	//
---
> 	//
4102d4131
< // BUGBUG: [mgere] [xbox] Set breakpoint here and see if it ever gets in here.
4118,4120d4146
< // BUGBUG: [mgere] [xbox] I know this is busted.  Remove this whole section about enumerating adapters
< // and check if it's ok.
< /*
4152d4177
< */
4840c4865
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
4843c4868,4937
< 	return DPNERR_UNSUPPORTED;
---
> 	DIRECTNETOBJECT		*pdnObject;
> 	HRESULT             hResultCode;
> 
> 	DPF(3,"Parameters: pInterface [0x%p], pIDP8LobbiedApplication [0x%p], dwFlags [0x%lx]",
> 			pInterface,pIDP8LobbiedApplication,dwFlags);
> 
> 	TRY
> 	{
>     	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
>     	DNASSERT(pdnObject != NULL);
> 
>     	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
>     	{
>     	    if( FAILED( hResultCode = DN_ValidateRegisterLobby( pInterface, dpnhLobbyConnection, pIDP8LobbiedApplication, dwFlags ) ) )
>     	    {
>     	        DPFERR( "Error validating register lobby params" );
>     	        DPF_EXIT( hResultCode );
>     	    }
>     	}
> 
>     	// Check to ensure message handler registered
>     	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
>     	{
>     		DPFERR( "Object is not initialized" );
>     		DPF_EXIT(DPNERR_UNINITIALIZED);
>     	}
> 
> 	}
> 	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
> 	{
> 	    DPFERR("Invalid object" );
> 	    DPF_EXIT(DPNERR_INVALIDOBJECT);
> 	}	
> 
> 	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
> 	DNASSERT(pdnObject != NULL);
> 
> 	if (dwFlags == DPNLOBBY_REGISTER)
> 	{
> 		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 		if (pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE)
> 		{
> 			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 			return(DPNERR_ALREADYREGISTERED);
> 		}
> 				
> 		pIDP8LobbiedApplication->lpVtbl->AddRef(pIDP8LobbiedApplication);
> 
> 		pdnObject->pIDP8LobbiedApplication = pIDP8LobbiedApplication;
> 		pdnObject->dpnhLobbyConnection = dpnhLobbyConnection;
> 		pdnObject->dwFlags |= DN_OBJECT_FLAG_LOBBY_AWARE;
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	}
> 	else
> 	{
> 		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE))
> 		{
> 			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 			return(DPNERR_NOTREGISTERED);
> 		}
> 				
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release(pdnObject->pIDP8LobbiedApplication);
> 		pdnObject->dpnhLobbyConnection = NULL;
> 		pdnObject->pIDP8LobbiedApplication = NULL;
> 		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_LOBBY_AWARE);
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	}
> 
> 	return(DPN_OK);
4845a4940,4962
> #undef DPF_MODNAME
> #define DPF_MODNAME "DNNotifyLobbyClientOfSettings"
> // 
> // DNNotifyLobbyClientOfSettings
> //
> // This function sends a connection settings update to the lobby client informing it that the lobby 
> // client settings have changed.  
> //
> HRESULT DNNotifyLobbyClientOfSettings(
> 	DIRECTNETOBJECT * const pdnObject,
> 	IDirectPlay8LobbiedApplication *pdpLobbiedApp, 
> 	DPNHANDLE dpnConnection, 
> 	IDirectPlay8Address *pHostAddress, 
> 	IDirectPlay8Address *pConnectFromAddress )
> {
> 	HRESULT						hResultCode = DPN_OK;
> 	DPL_CONNECTION_SETTINGS		dplConnectionSettings;
> 	BOOL						fIsHost = FALSE;
> 	CPackedBuffer				packBuffer;
> 	PBYTE						pBuffer = NULL;
> 	BOOL						fINCriticalSection = FALSE;
> 	CNameTableEntry				*pNTEntry = NULL;
> 	DWORD						dwIndex;
4846a4964,5109
> 	fIsHost = DN_CHECK_LOCALHOST( pdnObject );
> 
> 	ZeroMemory( &dplConnectionSettings, sizeof( DPL_CONNECTION_SETTINGS ) );
> 	dplConnectionSettings.dwSize = sizeof( DPL_CONNECTION_SETTINGS );
> 	dplConnectionSettings.dwFlags = (fIsHost) ? DPLCONNECTSETTINGS_HOST : 0;
> 
> 	// Lock the object while we make a copy of the app desc.  
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	fINCriticalSection = TRUE;
> 	
> 	packBuffer.Initialize(NULL, 0 );
> 
> 	// Determine the size of buffer
> 	hResultCode = DNPackApplicationDesc( &pdnObject->dnApplicationDescription, &packBuffer );
> 
> 	if( hResultCode != DPNERR_BUFFERTOOSMALL ) 
> 	{
> 		DPF( 0, "Error getting app desc size hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	pBuffer = new BYTE[packBuffer.GetSizeRequired()];
> 
> 	if( !pBuffer )
> 	{
> 		DPF( 0, "Error allocating memory for buffer" );
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	packBuffer.Initialize(pBuffer,packBuffer.GetSizeRequired());
> 
> 	hResultCode = DNPackApplicationDesc( &pdnObject->dnApplicationDescription, &packBuffer );
> 
> 	if( FAILED( hResultCode ) )
> 	{
> 		DPF( 0, "Error packing app desc hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 	fINCriticalSection = FALSE;
> 
> 	memcpy( &dplConnectionSettings.dpnAppDesc, pBuffer, sizeof( DPN_APPLICATION_DESC ) );
> 
> 	hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pNTEntry );
> 
> 	if( FAILED( hResultCode ) )
> 	{
> 		DPF( 0, "Error getting local player hr=0x%x", hResultCode );
> 		goto NOTIFY_EXIT;
> 	}
> 
> 	// Make sure player name isn't changed while we are working with the entry
> 	pNTEntry->Lock();
> 	if( pNTEntry->GetName() )
> 	{
> 		dplConnectionSettings.pwszPlayerName = new WCHAR[wcslen(pNTEntry->GetName())+1];
> 
> 		if( !dplConnectionSettings.pwszPlayerName )
> 		{
> 			pNTEntry->Unlock();
> 			DPF( 0, "Error allocating memory" );
> 			goto NOTIFY_EXIT;
> 		}
> 		
> 		wcscpy( dplConnectionSettings.pwszPlayerName, pNTEntry->GetName() );
> 	}
> 	else
> 	{
> 		dplConnectionSettings.pwszPlayerName = NULL;		
> 	}
> 	pNTEntry->Unlock();
> 
> 	// Release our reference
> 	pNTEntry->Release();
> 
> 	// Host address field
> 	if( fIsHost )
> 	{
> 		dplConnectionSettings.pdp8HostAddress = NULL;
> 
> 		hResultCode = DNGetHostAddressHelper( pdnObject, dplConnectionSettings.ppdp8DeviceAddresses, &dplConnectionSettings.cNumDeviceAddresses );
> 
> 		if( hResultCode != DPNERR_BUFFERTOOSMALL )
> 		{
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			DPF( 0, "Could not get host addresses for lobby update hr=0x%x", hResultCode );
> 			goto NOTIFY_EXIT;
> 		}
> 
> 		dplConnectionSettings.ppdp8DeviceAddresses = new IDirectPlay8Address*[dplConnectionSettings.cNumDeviceAddresses];
> 
> 		if( !dplConnectionSettings.ppdp8DeviceAddresses )
> 		{
> 			DPF( 0, "Error allocating memory" );
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			hResultCode = DPNERR_OUTOFMEMORY;
> 			goto NOTIFY_EXIT;
> 		}
> 
> 		hResultCode = DNGetHostAddressHelper( pdnObject, dplConnectionSettings.ppdp8DeviceAddresses, &dplConnectionSettings.cNumDeviceAddresses );
> 
> 		if( FAILED( hResultCode ) )
> 		{
> 			dplConnectionSettings.cNumDeviceAddresses = 0;
> 			DPF( 0, "Could not get host addresses for lobby update hr=0x%x", hResultCode );
> 			goto NOTIFY_EXIT;
> 		}
> 	}
> 	else
> 	{
> 		dplConnectionSettings.pdp8HostAddress = pHostAddress;
> 		dplConnectionSettings.ppdp8DeviceAddresses = &pConnectFromAddress;
> 		dplConnectionSettings.cNumDeviceAddresses = 1;	
> 	}
> 
> 	// Update the settings
> 	hResultCode = pdpLobbiedApp->lpVtbl->SetConnectionSettings( pdpLobbiedApp, dpnConnection, &dplConnectionSettings, 0 );
> 
> NOTIFY_EXIT:
> 
> 	if( dplConnectionSettings.ppdp8DeviceAddresses && fIsHost )
> 	{
> 		for( dwIndex = 0; dwIndex < dplConnectionSettings.cNumDeviceAddresses; dwIndex++ )
> 		{
> 			dplConnectionSettings.ppdp8DeviceAddresses[dwIndex]->lpVtbl->Release( dplConnectionSettings.ppdp8DeviceAddresses[dwIndex] );
> 		}
> 
> 		delete [] dplConnectionSettings.ppdp8DeviceAddresses;
> 	}
> 
> 	if( dplConnectionSettings.pwszPlayerName )
> 		delete [] dplConnectionSettings.pwszPlayerName;
> 
> 	if( fINCriticalSection ) 
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	if( pBuffer )
> 		delete [] pBuffer;
> 
> 	return hResultCode;
> 
> }
> 
> 
4847a5111,5191
> #define DPF_MODNAME "DNUpdateLobbyStatus"
> 
> HRESULT DNUpdateLobbyStatus(DIRECTNETOBJECT *const pdnObject,
> 							const DWORD dwStatus)
> {
> 	HRESULT		hResultCode;
> 	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
> 	DPNHANDLE dpnhLobbyConnection = NULL;
> 	IDirectPlay8Address *pHostAddress = NULL;
> 	IDirectPlay8Address *pConnectFromAddress = NULL;
> 
> 	DPF(4,"Parameters: dwStatus [0x%lx]",dwStatus);
> 
> 	DNASSERT(pdnObject != NULL);
> 
> 	pIDP8LobbiedApplication = NULL;
> 
> 	//
> 	//	Get lobbied application interface, if it exists and other settings we need
> 	//
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE) && (pdnObject->pIDP8LobbiedApplication))
> 	{
> 		pdnObject->pIDP8LobbiedApplication->lpVtbl->AddRef(pdnObject->pIDP8LobbiedApplication);
> 		pIDP8LobbiedApplication = pdnObject->pIDP8LobbiedApplication;
> 		dpnhLobbyConnection = pdnObject->dpnhLobbyConnection;
> 
> 		pConnectFromAddress = pdnObject->pIDP8ADevice;
> 		pHostAddress = pdnObject->pConnectAddress;
> 
> 		if( pConnectFromAddress )
> 		{
> 			pConnectFromAddress->lpVtbl->AddRef( pConnectFromAddress );			
> 		}
> 
> 		if( pHostAddress )
> 		{
> 			pHostAddress->lpVtbl->AddRef( pHostAddress );
> 		}
> 	}
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	//
> 	//	Update status and release object
> 	//
> 	if (pIDP8LobbiedApplication)
> 	{
> 		// If we are about to do a connection notification
> 		// we send the updated connection settings.  
> 		// 
> 		// This gives lobby client full picture. 
> 		//
> 		if( dwStatus == DPLSESSION_CONNECTED )
> 		{
> 			DNNotifyLobbyClientOfSettings(pdnObject, pIDP8LobbiedApplication, dpnhLobbyConnection, pHostAddress, pConnectFromAddress );
> 		}
> 
> 		pIDP8LobbiedApplication->lpVtbl->UpdateStatus(pIDP8LobbiedApplication,dpnhLobbyConnection,dwStatus,0);
> 
> 		pIDP8LobbiedApplication->lpVtbl->Release(pIDP8LobbiedApplication);
> 		pIDP8LobbiedApplication = NULL;
> 
> 		if( pHostAddress )
> 		{
> 			pHostAddress->lpVtbl->Release( pHostAddress );
> 		}		
> 
> 		if( pConnectFromAddress )
> 		{
> 			pConnectFromAddress->lpVtbl->Release( pConnectFromAddress );
> 		}
> 	}
> 
> 	hResultCode = DPN_OK;
> 
> 	DPF(4,"Returning: [0x%lx]",hResultCode);
> 	return(hResultCode);
> }
> 
> 						
> #undef DPF_MODNAME
5192a5537,5666
> }
> 
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DNRegisterWithDPNSVR"
> 
> HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject)
> {
> 	HRESULT					hResultCode;
> 	HRESULT					hrRegister;
> 	CAsyncOp				*pListenParent;
> 	CAsyncOp				*pListenSP;
> 	CAsyncOp				*pListen;
> 	CBilink					*pBilinkSP;
> 	CBilink					*pBilink;
> 	SPGETADDRESSINFODATA	spInfo;
> #ifdef	DEBUG
> 	CHAR			DP8ABuffer[512];
> 	DWORD			DP8ASize;
> #endif
> 
> 	DPF(4,"Parameters: (none)");
> 
> 	pListenParent = NULL;
> 	pListenSP = NULL;
> 	pListen = NULL;
> 
> 	//
> 	//	Default error returned
> 	//
> 	hrRegister = DPNERR_GENERIC;
> 
> 	//
> 	//	Get LISTEN AsyncOp parent from DirectNet object and add a RefCount
> 	//
> 	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
> 	if (pdnObject->pListenParent == NULL)
> 	{
> 		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 		goto Exit;
> 	}
> 	pdnObject->pListenParent->AddRef();
> 	pListenParent = pdnObject->pListenParent;
> 	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
> 
> 	//
> 	//	Lock the parent so that the child bilink list doesn't change
> 	//
> 	pListenParent->Lock();
> 
> 	//
> 	//	Locate each child (LISTEN SP parent) and then each actual LISTEN
> 	//
> 	pBilinkSP = pListenParent->m_bilinkParent.GetNext();
> 	while (pBilinkSP != &pListenParent->m_bilinkParent)
> 	{
> 		pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);
> 
> DNASSERT(pListenSP->GetParent() == pListenParent);
> 		//
> 		//	Lock the SP parent so that the child bilink doesn't change
> 		//
> 		pListenSP->Lock();
> 
> 		pBilink = pListenSP->m_bilinkParent.GetNext();
> 		while (pBilink != &pListenSP->m_bilinkParent)
> 		{
> 			pListen = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
> 
> 			DNASSERT(pListen->GetProtocolHandle() != NULL);
> 
> 			spInfo.hEndpoint = pListen->GetProtocolHandle();
> 			spInfo.pAddress = NULL;
> 			spInfo.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;
> 
> 			if (DNPGetListenAddressInfo(pListen->GetProtocolHandle(),&spInfo) == DPN_OK)
> 			{
> 				DNASSERT(spInfo.pAddress != NULL);
> #ifdef	DEBUG
> 				DP8ASize = 512;
> 				spInfo.pAddress->lpVtbl->GetURLA(spInfo.pAddress,DP8ABuffer,&DP8ASize);
> 				DPF(4,"Listen address [%s]",DP8ABuffer);
> 
> 				// We re-try the registration to catch the case where DPNSVR is shutting
> 				// down while we are trying to register.  Unlikely but has to be handled.
> 				//
> #endif
> 	            for( DWORD dwRetry = 0; dwRetry < DPNSVR_REGISTER_ATTEMPTS ; dwRetry ++ )
> 		        {
>     				hResultCode = DPNSVR_Register( &pdnObject->dnApplicationDescription, spInfo.pAddress );
> 	    			if( FAILED( hResultCode ) )
> 					{
>     					if( dwRetry < DPNSVR_REGISTER_ATTEMPTS )
>     					{
> 	    					DPF( 0, "Unable to register ourselves with DPNSVR hr=0x%x, retrying", hResultCode );    				
> 	    					Sleep( DPNSVR_REGISTER_SLEEP );    				
> 	    				}
> 						else
>     					{
> 	    					DPF( 0, "Unable to register ourselves with DPNSVR hr=0x%x", hResultCode );
> 	    				}
> 	    			}
> 					else
>     				{
>     					// Return DPN_OK if we succeed even once
>     					hrRegister = hResultCode;
>     					break;
> 	    			}
> 		        }
> 			
> 				spInfo.pAddress->lpVtbl->Release(spInfo.pAddress);
> 				spInfo.pAddress = NULL;
> 
> 			}
> 			pBilink = pBilink->GetNext();
> 		}
> 
> 		pListenSP->Unlock();
> 
> 		pBilinkSP = pBilinkSP->GetNext();
> 	}
> 
> 	pListenParent->Unlock();
> 
> 	pListenParent->Release();
> 	pListenParent = NULL;
> 
> Exit:
> 	DPF(4,"Returning: [0x%lx]",hrRegister);
> 	return( hrRegister );
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\common.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
205c205
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
207a208,210
> HRESULT DNUpdateLobbyStatus(DIRECTNETOBJECT *const pdnObject,
> 							const DWORD dwStatus);
> 
216a220,221
> 
> HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
84a85
> #include "DPLobby8.h"
113d113
< #include <wchar.h>
117,120d116
< #define CompareGuid(a,b)                                         \
<     (memcmp((PVOID)(a), (PVOID)(b), sizeof(GUID)))
< 
< 
189c185
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
264,265c260,261
< 		if ((hResultCode = pAddress->lpVtbl->BuildFromURLW(	pAddress,
< 															static_cast<WCHAR*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
---
> 		if ((hResultCode = pAddress->lpVtbl->BuildFromURLA(	pAddress,
> 															static_cast<char*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
292c288
< 		pAddress->lpVtbl->GetURLW(pAddress,DP8ABuffer,&DP8ASize);
---
> 		pAddress->lpVtbl->GetURLA(pAddress,DP8ABuffer,&DP8ASize);
725c721
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
810c806
< 	if (pguidInstance && CompareGuid(pguidInstance,&GUID_NULL))
---
> 	if (pguidInstance && !UuidIsNil(pguidInstance,&rpcStatus))
823c819
< 	if (pguidApplication && CompareGuid(pguidApplication,&GUID_NULL))
---
> 	if (pguidApplication && !UuidIsNil(pguidApplication,&rpcStatus))
880c876
< 		pDevice->lpVtbl->GetURLW(pDevice,DP8ABuffer,&DP8ASize);
---
> 		pDevice->lpVtbl->GetURLA(pDevice,DP8ABuffer,&DP8ASize);
1183c1179
< 	WCHAR				DP8ABuffer[512];
---
> 	CHAR				DP8ABuffer[512];
1208,1209c1204
< 				pAddress->lpVtbl->GetURLW(pAddress,NULL,&dwAddressSize);
< 				dwAddressSize = dwAddressSize * sizeof(WCHAR);
---
> 				pAddress->lpVtbl->GetURLA(pAddress,NULL,&dwAddressSize);
1213c1208
< 				pAddress->lpVtbl->GetURLW(pAddress,DP8ABuffer,&DP8ASize);
---
> 				pAddress->lpVtbl->GetURLA(pAddress,DP8ABuffer,&DP8ASize);
1340,1341c1335,1336
< 		if ((hResultCode = pAddress->lpVtbl->GetURLW(pAddress,
< 													static_cast<WCHAR*>(packedBuffer.GetTailAddress()),
---
> 		if ((hResultCode = pAddress->lpVtbl->GetURLA(pAddress,
> 													static_cast<char*>(packedBuffer.GetTailAddress()),
1704a1700,1704
> 	//	Update Lobby status
> 	//
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_CONNECTED);
> 
> 	//
1970a1971,1979
> 	if (fWasConnected)
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_DISCONNECTED);
> 	}
> 	else
> 	{
> 		DNUpdateLobbyStatus(pdnObject,DPLSESSION_COULDNOTCONNECT);
> 	}	
> 
2832c2841
< 	WCHAR					DP8ABuffer[512];
---
> 	CHAR					DP8ABuffer[512];
2866c2875
< 		(*ppAddress)->lpVtbl->GetURLW(*ppAddress,DP8ABuffer,&DP8ASize);
---
> 		(*ppAddress)->lpVtbl->GetURLA(*ppAddress,DP8ABuffer,&DP8ASize);
2889c2898
< 	WCHAR					DP8ABuffer[512];
---
> 	CHAR					DP8ABuffer[512];
2916c2925
< 		(*ppAddress)->lpVtbl->GetURLW(*ppAddress,DP8ABuffer,&DP8ASize);
---
> 		(*ppAddress)->lpVtbl->GetURLA(*ppAddress,DP8ABuffer,&DP8ASize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dllmain.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
37a38
> #include "creg.h"
42a44,180
> #undef DPF_MODNAME
> #define DPF_MODNAME "RegisterDefaultSettings"
> //
> // RegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT RegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot create app sub-aread" );
> 		return DPNERR_GENERIC;
> 	}
> 	else
> 	{
> 		return DPN_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "UnRegisterDefaultSettings"
> //
> // UnRegisterDefaultSettings
> //
> // This function registers the default settings for this module.  
> //
> // For DPVOICE.DLL this is making sure the compression provider sub-key is created.
> //
> HRESULT UnRegisterDefaultSettings()
> {
> 	CRegistry creg;
> 
> 	if( !creg.Open( HKEY_LOCAL_MACHINE, DN_REG_LOCAL_SP_ROOT, FALSE, TRUE ) )
> 	{
> 		DPFERR( "Cannot remove app, does not exist" );
> 	}
> 	else
> 	{
> 		if( !creg.DeleteSubKey( &(DN_REG_LOCAL_SP_SUB)[1] ) )
> 		{
> 			DPFERR( "Cannot remove cp sub-key, could have elements" );
> 		}
> 	}
> 
> 	return DPN_OK;
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Client.1", L"DirectPlay8Client Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Client, L"DirectPlay8.Client") )
> 	{
> 		DPFERR( "Could not register dp8 client object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Server.1", L"DirectPlay8Server Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Server, L"DirectPlay8.Server") )
> 	{
> 		DPFERR( "Could not register dp8 Server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::Register( L"DirectPlay8.Peer.1", L"DirectPlay8Peer Object", 
> 							  L"dpnet.dll", CLSID_DirectPlay8Peer, L"DirectPlay8.Peer") )
> 	{
> 		DPFERR( "Could not register dp8 client object" );
> 		fFailed = TRUE;
> 	}
> 
> 
> 	if( FAILED( hr = RegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Could not register default settings hr = 0x%x", hr );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Client) )
> 	{
> 		DPF( 0, "Failed to unregister client object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Server) )
> 	{
> 		DPF( 0, "Failed to unregister server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Peer) )
> 	{
> 		DPF( 0, "Failed to unregister peer object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( FAILED( hr = UnRegisterDefaultSettings() ) )
> 	{
> 		DPF( 0, "Failed to remove default settings hr=0x%x", hr );
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dncore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
103a104,106
> #define DN_REG_LOCAL_SP_ROOT				L"Software\\Microsoft\\DirectPlay8"
> #define DN_REG_LOCAL_SP_SUB					L"\\Service Providers"
> #define DN_REG_LOCAL_SP_SUBKEY				DN_REG_LOCAL_SP_ROOT DN_REG_LOCAL_SP_SUB
104a108,112
> #define	DN_REG_KEYNAME_ADAPTER_LIST			L"Adapter List"
> #define	DN_REG_KEYNAME_ALL_APPLICATIONS		L"All Applications"
> #define	DN_REG_KEYNAME_FRIENDLY_NAME		L"Friendly Name"
> #define DN_REG_KEYNAME_GUID					L"GUID"
> 
127a136
> typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
268a278
> 	// Lobby additions
269a280,283
> 	DPNHANDLE				dpnhLobbyConnection;	// Lobby Connection to update
> 
> 	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
> 	
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
5a6,8
> 	DllRegisterServer	PRIVATE
> 	DllUnregisterServer	PRIVATE
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\dnet.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnet.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,62
> 
> #endif
> 
> #endif    // !_MAC
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\enum_sp.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
44a45
> #include "DNMisc.h"
46a48
> #include "CReg.h"
60c62,71
< // BUGBUG: [xbox] [mgere] Removed since we don't support registry
---
> 	DWORD	dwAllAppLen;
> 	WCHAR	lpwszAllAppStr[DN_FLAG_STR_LEN+1];
> 
> 	dwAllAppLen = (DN_FLAG_STR_LEN + 1) * sizeof(WCHAR);
> 	if (RegQueryValueExW(hSPKey,DN_REG_KEYNAME_ALL_APPLICATIONS,NULL,NULL,(PBYTE)lpwszAllAppStr,&dwAllAppLen) != ERROR_SUCCESS)
> 		return(FALSE);
> 
> 	if (towupper(lpwszAllAppStr[0]) == L'N')
> 		return(TRUE);
> 
75,76c86
< // BUGBUG:  [mgere] [xbox] this function changed substantially.  Need to verify that it's still working properly.
< 	HRESULT	hResultCode = DPN_OK;
---
> 	GUID	guid;
78c88,98
< 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
---
> 	DWORD	dwEntrySize;
> 	DWORD	dwEnumCount;
> 	DWORD	dwEnumIndex;
> 	DWORD	dwFriendlyNameLen;
> 	DWORD	dwGuidSize;
> 	DWORD	dwKeyLen;
> 	DWORD	dwMaxFriendlyNameLen;
> 	DWORD	dwMaxKeyLen;
> 	PWSTR	pwszFriendlyName;
> 	PWSTR	pwszKeyName;
> 	HRESULT	hResultCode = DPN_OK;
80,81c100,103
<     WCHAR wszSP[] = L"DirectPlay8 TCP/IP Service Provider";
< 	GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };
---
> 	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
> 	CRegistry	RegistryEntry;
> 	CRegistry	SubEntry;
> //	CServiceProvider	*pSP;
89a112,115
> 	pwszFriendlyName = NULL;
> 	pwszKeyName = NULL;
> //	pSP = NULL;
> 
93,94c119,124
< 	hResultCode = packedBuffer.AddToBack(wszSP,(wcslen(wszSP)+1)*sizeof(WCHAR));
< 	dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
---
> 	if (!RegistryEntry.Open(HKEY_LOCAL_MACHINE,DN_REG_LOCAL_SP_SUBKEY,TRUE,FALSE))
> 	{
> 		DPFERR("RegistryEntry.Open() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
96c126,153
< 	memcpy(&dnSpInfo.guid,&guid,sizeof(GUID));
---
> 	//
> 	//	Set up to enumerate
> 	//
> 	if (!RegistryEntry.GetMaxKeyLen(dwMaxKeyLen))
> 	{
> 		DPFERR("RegistryEntry.GetMaxKeyLen() failed");
> 		hResultCode = DPNERR_GENERIC;
> 		goto Failure;
> 	}
> 	dwMaxKeyLen++;	// Null terminator
> 	DPF(5,"dwMaxKeyLen = %ld",dwMaxKeyLen);
> 	if ((pwszKeyName = static_cast<WCHAR*>(DNMalloc(dwMaxKeyLen * sizeof(WCHAR)))) == NULL)
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwMaxFriendlyNameLen = dwMaxKeyLen;
> 	if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof(WCHAR)))) == NULL)	// Seed friendly name size
> 	{
> 		DPFERR("DNMalloc() failed");
> 		hResultCode = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 	dwGuidSize = (GUID_STRING_LENGTH + 1) * sizeof(WCHAR);
> 	dwEnumIndex = 0;
> 	dwKeyLen = dwMaxKeyLen;
> 	dwEnumCount = 0;
98,101c155,168
< 	dnSpInfo.dwFlags = 0;
< 	dnSpInfo.dwReserved = 0;
< 	dnSpInfo.pvReserved = NULL;
< 	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
---
> 	//
> 	//	Enumerate SP's !
> 	//
> 	while (RegistryEntry.EnumKeys(pwszKeyName,&dwKeyLen,dwEnumIndex))
> 	{
> 		dwEntrySize = 0;
> 		DPF(5,"%ld - %S (%ld)",dwEnumIndex,pwszKeyName,dwKeyLen);
> 		if (!SubEntry.Open(RegistryEntry,pwszKeyName,TRUE,FALSE))
> 		{
> 			DPF(0,"Couldn't open subentry.  Skipping [%S]", pwszKeyName);
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
102a170,264
> 		//
> 		//	GUID
> 		//
> 		dwGuidSize = (DN_GUID_STR_LEN + 1) * sizeof(WCHAR);
> 		if (!SubEntry.ReadGUID(DN_REG_KEYNAME_GUID,guid))
> 		{
> 			DPF(0,"SubEntry.ReadGUID failed.  Skipping [%S]", pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 
> 		//
> 		//	Attempt to instantiate SP and initialize it, to ensure that it is in fact usable.
> 		//
> 		if (!(dwFlags & DPNENUMSERVICEPROVIDERS_ALL))
> 		{
> 			hResultCode = DN_SPEnsureLoaded(pdnObject,&guid,NULL,TRUE);
> 			if (hResultCode != DPN_OK)
> 			{
> 				DPF(0,"Could not load SP.  Skipping [%S]", pwszKeyName);
> 				SubEntry.Close();
> 				dwEnumIndex++;
> 				dwKeyLen = dwMaxKeyLen;
> 				hResultCode = DPN_OK; // override return code
> 				continue;
> 			}
> 			else
> 			{
> //				DN_SPRelease(pdnObject,&guid);
> 			}
> 		}
> 
> 		//
> 		//	Friendly Name
> 		//
> 		if (!SubEntry.GetValueLength(DN_REG_KEYNAME_FRIENDLY_NAME,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not get FriendlyName length.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		if (dwFriendlyNameLen > dwMaxFriendlyNameLen)
> 		{
> 			// grow buffer (noting that the registry functions always return WCHAR) and try again
> 			DPF(5,"Need to grow pwszFriendlyName from %ld to %ld",
> 					dwMaxFriendlyNameLen * sizeof(WCHAR),dwFriendlyNameLen * sizeof(WCHAR));
> 			if (pwszFriendlyName != NULL)
> 			{
> 				DNFree(pwszFriendlyName);
> 			}
> 			dwMaxFriendlyNameLen = dwFriendlyNameLen;
> 			if ((pwszFriendlyName = static_cast<WCHAR*>(DNMalloc(dwMaxFriendlyNameLen * sizeof( WCHAR )))) == NULL)
> 			{
> 				DPFERR("DNMalloc() failed");
> 				hResultCode = DPNERR_OUTOFMEMORY;
> 				goto Failure;
> 			}
> 		}
> 		if (!SubEntry.ReadString(DN_REG_KEYNAME_FRIENDLY_NAME,pwszFriendlyName,&dwFriendlyNameLen))
> 		{
> 			DPF(0,"Could not read friendly name.  Skipping [%S]",pwszKeyName);
> 			SubEntry.Close();
> 			dwEnumIndex++;
> 			dwKeyLen = dwMaxKeyLen;
> 			continue;
> 		}
> 		DPF(5,"Friendly Name = %S (%ld WCHARs)",pwszFriendlyName,dwFriendlyNameLen);
> 
> 		hResultCode = packedBuffer.AddToBack(pwszFriendlyName,dwFriendlyNameLen * sizeof(WCHAR));
> 		dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());
> /*	REMOVE
> 		hResultCode = packedBuffer.AddToBack(&guid,sizeof(GUID));
> 		dnSpInfo.pGuid = static_cast<GUID*>(packedBuffer.GetTailAddress());
> */
> 		memcpy(&dnSpInfo.guid,&guid,sizeof(GUID));
> 		dnSpInfo.dwFlags = 0;
> 		dnSpInfo.dwReserved = 0;
> 		dnSpInfo.pvReserved = NULL;
> 		hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));
> 
> 		dwEnumCount++;
> 		SubEntry.Close();
> 		dwEnumIndex++;
> 		dwKeyLen = dwMaxKeyLen;
> 	}
> 
> 	RegistryEntry.Close();
> 
> 	//
> 	//	Success ?
> 	//
108c270
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
110c272
< 		goto Exit;
---
> 		goto Failure;
114c276,277
< 		*pcReturned = 1;
---
> 		*pcReturned = dwEnumCount;
> 		hResultCode = DPN_OK;
117,123d279
< 			hResultCode = DN_SPEnsureLoaded(pdnObject,&guidSP,NULL,TRUE);
< 			if (hResultCode != DPN_OK)
< 			{
< 				DPF(0,"Could not load SP.  Skipping [%S]", pwszKeyName);
< 				hResultCode = DPN_OK; // override return code
< 			}
< 
125a282,286
> 	DNFree(pwszKeyName);
> 	pwszKeyName = NULL;
> 	DNFree(pwszFriendlyName);
> 	pwszFriendlyName = NULL;
> 
128a290,311
> 
> Failure:
> 
> 	if (pwszKeyName)
> 	{
> 		DNFree(pwszKeyName);
> 		pwszKeyName = NULL;
> 	}
> 	if (pwszFriendlyName)
> 	{
> 		DNFree(pwszFriendlyName);
> 		pwszFriendlyName = NULL;
> 	}
> 	if (SubEntry.IsOpen())
> 	{
> 		SubEntry.Close();
> 	}
> 	if (RegistryEntry.IsOpen())
> 	{
> 		RegistryEntry.Close();
> 	}
> 	goto Exit;
142,146d324
< // BUGBUG
< // [mgere] [xbox] Removed this whole function.  It uses registry to enumerate adapters
< //         and XBox doesn't have a registry.  Need to figure out some other way to
< //         handle this, if at all.
< /*
296d473
< */	return(E_FAIL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\migration.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
80a81,83
> #include "dpnsvrq.h"
> #include "dpnsdef.h"
> #include "dpnsvlib.h"
81a85
> #include "dplobby8.h"
280a285
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_HOSTMIGRATEDHERE);	
679a685,704
> 	// Register with DPNSVR
> 	if( !(pdnObject->dnApplicationDescription.dwFlags & DPNSESSION_NODPNSVR) )
> 	{
> 		BOOL	fCoUninitialize = FALSE;
> 
> 		DPF( 7, "Asking for DPNSVR to start listening for us.." );
> 
> 		if (COM_CoInitialize(NULL) == S_OK)
> 		{
> 			fCoUninitialize = TRUE;
> 		}
> 
> 		DNRegisterWithDPNSVR(pdnObject);
> 
> 		if (fCoUninitialize)
> 		{
> 			COM_CoUninitialize();
> 		}
> 	}
> 
771a797,801
> 
> 	// 
> 	// Indicate to lobby (if there is one) that a host migration has occured
> 	//
> 	DNUpdateLobbyStatus(pdnObject,DPLSESSION_HOSTMIGRATED);		
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\msghandler.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1140c1140
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1156c1156
< 	pHostAddress->lpVtbl->GetURLW(pHostAddress,DP8ABuffer,&DP8ASize);
---
> 	pHostAddress->lpVtbl->GetURLA(pHostAddress,DP8ABuffer,&DP8ASize);
1160c1160
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
1191c1191
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1207c1207
< 	pHostAddress->lpVtbl->GetURLW(pHostAddress,DP8ABuffer,&DP8ASize);
---
> 	pHostAddress->lpVtbl->GetURLA(pHostAddress,DP8ABuffer,&DP8ASize);
1211c1211
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
1240c1240
< 	WCHAR			DP8ABuffer[512];
---
> 	CHAR			DP8ABuffer[512];
1256c1256
< 	pDeviceAddress->lpVtbl->GetURLW(pDeviceAddress,DP8ABuffer,&DP8ASize);
---
> 	pDeviceAddress->lpVtbl->GetURLA(pDeviceAddress,DP8ABuffer,&DP8ASize);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\ntentry.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
424,425c424
< 		hResultCode = m_pAddress->lpVtbl->GetURLW(m_pAddress,NULL,&dwURLSize);
< 		dwURLSize = dwURLSize * sizeof(WCHAR);
---
> 		hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,NULL,&dwURLSize);
437,438c436,437
< 				if ((hResultCode = m_pAddress->lpVtbl->GetURLW(m_pAddress,
< 						static_cast<WCHAR*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
---
> 				if ((hResultCode = m_pAddress->lpVtbl->GetURLA(m_pAddress,
> 						static_cast<char*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
525c524
< 		hResultCode = pAddress->lpVtbl->BuildFromURLW(pAddress,reinterpret_cast<WCHAR*>(pBufferStart + pdnEntryInfo->dwURLOffset));
---
> 		hResultCode = pAddress->lpVtbl->BuildFromURLA(pAddress,reinterpret_cast<char*>(pBufferStart + pdnEntryInfo->dwURLOffset));
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
211c211
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
219a220,226
>     if( pIDP8LobbiedApplication == NULL ||
>         !DNVALID_READPTR( pIDP8LobbiedApplication, sizeof( IDirectPlay8LobbiedApplication * ) ) )
>     {
>         DPFERR( "Invalid interface pointer specified for register lobby" );
>         return DPNERR_INVALIDPOINTER;
>     }
> 
1061c1068
<     if( dwFlags & ~(DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
---
>     if( dwFlags & ~(DPNENUMHOSTS_OKTOQUERYFORADDRESSING | DPNENUMHOSTS_SYNC | DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
1784c1791
<     if( dwFlags & ~(DPNCONNECT_SYNC) )
---
>     if( dwFlags & ~(DPNCONNECT_SYNC | DPNCONNECT_OKTOQUERYFORADDRESSING) )
2100c2107
<     if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD) )
---
>     if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD | DPNSESSION_NODPNSVR) )
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\paramval.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
47c47
< 							  PVOID const pIDP8LobbiedApplication,
---
> 							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\peer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
69d68
< #include <wchar.h>
120c119
< typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP PeerRegisterLobby(IDirectPlay8Peer *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\server.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62d61
< #include <wchar.h>
111c110
< typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags);
---
> typedef STDMETHODIMP ServerRegisterLobby(IDirectPlay8Server *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);
.  
.  
()---()---()---()---()---()---()---()---()---(.\core\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2,3c17,27
< TARGETPATHLIB=$(BASEDIR)\public\sdk\lib
< TARGETTYPE=DYNLINK
---
> DLLDEF=..\dnet.def
> UMTYPE=windows
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
4a29
> TARGETTYPE=DYNLINK
6,14c31,35
< !ifdef _BUILD_FOR_WIN2000
< UMTYPE=windows
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
16c37
< INCLUDES=..\;..\..\inc;..\..\protocol;..\..\common
---
> PASS1_PUBLISH={ $(O)\dpnet.lib = $(SDK_LIB_PATH)\dpnet.lib}
18c39,56
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
> 	   ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
>            ..\..\protocol\obj$(BUILD_ALT_DIR)\*\protocol.lib \
>            ..\..\dpnsvr\dpnsvlib\obj$(BUILD_ALT_DIR)\*\dpnsvlib.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
20d57
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
22,23c59,60
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
26c63,67
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28c69
< DLLDEF=..\dnet.def
---
> INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\protocol;..\..\common;..\..\dpnsvr\dpnsvlib;..\..\dpnsvr\inc
29a71,78
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
62a112
>          ..\voice.cpp \
69a120,127
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
72,93c130,132
< TARGETLIBS= \
< 	   ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
<            ..\..\protocol\obj$(BUILD_ALT_DIR)\*\protocol.lib \
<            $(BASEDIR)\public\sdk\lib\*\dpnaddr.lib \
<            ..\..\sp\wsock\daytona\obj$(BUILD_ALT_DIR)\*\dpnwsock.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<              $(SDK_LIB_PATH)\libcntpr.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addbase.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
260d259
< /* BUGBUG: [mgere] [xbox] Removed this function.
291d289
< */  return DPNERR_UNSUPPORTED;
302,303c300,359
< // BUGBUG: [mgere] [xbox] ANSI not supported
< 	return DPNERR_UNSUPPORTED;
---
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pszAddress == NULL )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer to address.  An address must be specified" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	if( !DNVALID_STRING_A( pszAddress ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid string specified for address" );
> 		DP8A_RETURN( DPNERR_INVALIDSTRING );
> 	}
> 
> 	DPF( DP8A_PARAMLEVEL, "pszAddress = %s", pszAddress );
> 
> 	WCHAR *szShadowBuffer = NULL;
> 
> 	DWORD dwStrSize = 0;
> 
> 	if( pszAddress != NULL )
> 	{
> 		dwStrSize = strlen(pszAddress)+1;
> 		
> 		szShadowBuffer = new WCHAR[dwStrSize];
> 
> 		if( szShadowBuffer == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto BUILDFROMURLW_RETURN;
> 		}
> 
> 		if( FAILED( hr = STR_jkAnsiToWide( szShadowBuffer, pszAddress, dwStrSize ) )  )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting URL to ANSI hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 			goto BUILDFROMURLW_RETURN;
> 		}
> 	}
> 
> 	hr = pdp8Address->SetURL( szShadowBuffer );
> 
> BUILDFROMURLW_RETURN:
> 
> 	if( szShadowBuffer )
> 		delete [] szShadowBuffer;
> 
> 	DP8A_RETURN( hr );	
448,449c504,571
< // BUGBUG: [mgere] [xbox] ANSI not supported.
< 	return DPNERR_UNSUPPORTED;
---
> 	if( pInterface == NULL ||
> 	   !DP8A_VALID( pInterface ) )
> 	{
> 		DPF( DP8A_ENTERLEVEL, "Invalid object" );
> 		DP8A_RETURN( DPNERR_INVALIDOBJECT );
> 	}
> 	
> 	DP8ADDRESSOBJECT *pdp8Address = (DP8ADDRESSOBJECT *) GET_OBJECT_FROM_INTERFACE( pInterface );
> 
> 	HRESULT hr;
> 
> 	DPF( DP8A_ENTERLEVEL, "Enter" );	
> 
> 	if( pdwAddressSize == NULL ||
> 	   !DNVALID_WRITEPTR( pdwAddressSize, sizeof(DWORD) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for address size" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );		
> 	}
> 
> 	if( *pdwAddressSize > 0 &&
> 	   (pszAddress == NULL ||
> 	    !DNVALID_WRITEPTR( pszAddress, (*pdwAddressSize) ) ) )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Invalid pointer specified for address" );
> 		DP8A_RETURN( DPNERR_INVALIDPOINTER );
> 	}
> 
> 	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
> 	DPF( DP8A_PARAMLEVEL, "pwszAddress = 0x%p pdwAddressSize = 0x%p (%u)",
> 	     pszAddress , pdwAddressSize, *pdwAddressSize );
> 
> 	WCHAR *szShadowBuffer = NULL;
> 
> 	if( *pdwAddressSize  != 0 )
> 	{
> 		szShadowBuffer = new WCHAR[*pdwAddressSize];
> 
> 		if( szShadowBuffer == NULL )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error allocating memory" );
> 			hr = DPNERR_OUTOFMEMORY;
> 			goto GETURLW_RETURN;
> 		}
> 	}
> 	else
> 	{	
> 		szShadowBuffer= NULL;
> 	}
> 
> 	hr = pdp8Address->BuildURL( szShadowBuffer, pdwAddressSize );
> 
> 	if( hr == DPN_OK )
> 	{
> 		if( FAILED( hr = STR_jkWideToAnsi( pszAddress, szShadowBuffer, *pdwAddressSize ) ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Error converting ANSI->WIDE hr=0x%x", hr );
> 			hr = DPNERR_CONVERSION;
> 			goto GETURLW_RETURN;
> 		}
> 	}
> 	
> GETURLW_RETURN:
> 
> 	if( szShadowBuffer != NULL )
> 		delete [] szShadowBuffer;
> 
> 	DP8A_RETURN( hr );
873c995,996
< 	   dwDataType != DPNA_DATATYPE_BINARY )
---
> 	   dwDataType != DPNA_DATATYPE_BINARY &&
> 	   dwDataType != DPNA_DATATYPE_STRING_ANSI )
887a1011,1024
> 		{
> 			DPF( DP8A_ERRORLEVEL, "String size and component size don't match" );
> 			DP8A_RETURN( DPNERR_INVALIDPARAM );
> 		}
> 	}
> 	else if( dwDataType == DPNA_DATATYPE_STRING_ANSI )
> 	{
> 		if( !DNVALID_STRING_A( (const CHAR * const) pComponentData ) )
> 		{
> 			DPF( DP8A_ERRORLEVEL, "Invalid string component specified" );
> 			DP8A_RETURN( DPNERR_INVALIDSTRING );
> 		}
> 
> 		if( ((strlen( (const CHAR * const) pComponentData)+1)*sizeof(char)) != dwComponentSize )
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50
> #include <stdio.h>
50a52
> #include "dplegacy.h"
52d53
< #include <wchar.h>
400a402,420
> 	case DPNA_DATATYPE_STRING_ANSI:
>         wszUnicodeString = new WCHAR[dwRealDataSize];
>         if( wszUnicodeString == NULL )
>         {
>             DPF( 0, "Error allocating memory for conversion" );
>             return DPNERR_OUTOFMEMORY;
>         }
> 
> 		hr = STR_jkAnsiToWide( wszUnicodeString, (const char * const) pvData, dwRealDataSize );
> 
> 		if( FAILED( hr ) )
> 		{
> 		    DPF( 0, "Error unable to convert element ANSI->Unicode 0x%x", hr );
>             return DPNERR_CONVERSION;
> 		}
> 		pvRealData = wszUnicodeString;
> 	    dwRealDataSize = dwDataSize*sizeof(WCHAR);
> 		dwRealDataType = DPNA_DATATYPE_STRING;
> 	    break;
424a445,456
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_IPXPROVIDER ) == 0 )
>                 {
>                     hr= SetSP( &CLSID_DP8SP_IPX );
>                 }
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_MODEMPROVIDER ) == 0 )
>                 {
>                     hr = SetSP( &CLSID_DP8SP_MODEM );
>                 }
>                 else if( _wcsicmp( (const WCHAR * const) pvRealData, DPNA_VALUE_SERIALPROVIDER ) == 0 )
>                 {
>                     hr = SetSP( &CLSID_DP8SP_SERIAL );
>                 }
1378a1411,1479
> #undef DPF_MODNAME
> #define DPF_MODNAME "DP8ADDRESSOBJECT::SetDirectPlay4Address"
> HRESULT DP8ADDRESSOBJECT::SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize )
> {
>     PBYTE pbCurrentLocation;
>     PDPADDRESS pdpAddressChunk;
>     LONG lRemaining;
>     HRESULT hr = DPN_OK;
>     DWORD dwCurrentChunkSize;
>     DWORD dwNumElementsParsed = 0;
> 
> 	if( IsLocked() )
> 	{
> 		DPF( DP8A_ERRORLEVEL, "Cannot set element, object read-only" );
> 		return DPNERR_NOTALLOWED;
> 	}
> 
>     // XBOX! This function will not be required on XBOX.  Have it return DPNERR_NOTSUPPORTED
>     ENTERLOCK();
> 
>     hr = Clear();
> 
>     if( FAILED( hr ) )
>     {
>         DPF( 0, "Failed to clear old address data hr=[0x%lx]", hr );
>         LEAVELOCK();
>         return hr;
>     }
> 
>     pbCurrentLocation = (PBYTE) pvDataBuffer;
>     lRemaining = dwDataSize;
> 
>     while( lRemaining > 0 )
>     {
>         pdpAddressChunk = (PDPADDRESS) pbCurrentLocation;
> 
>         if( sizeof( DPADDRESS ) > lRemaining )
>         {
>             DPF( 0, "Error parsing address, unexpected end of address" );
> 			LEAVELOCK();
>             return DPNERR_INVALIDADDRESSFORMAT;
>         }
> 
>         dwCurrentChunkSize = sizeof( DPADDRESS ) + pdpAddressChunk->dwDataSize;
> 
>         if( ((LONG) dwCurrentChunkSize) > lRemaining )
>         {
>             DPF( 0, "Error parsing address, unexpected end during data" );
> 			LEAVELOCK();
>             return DPNERR_INVALIDADDRESSFORMAT;
>         }
> 
>         hr = AddDP4Element( pdpAddressChunk, this );
> 
>         if( FAILED( hr ) )
>         {
>             DPF( 0, "Error adding next element" );
>             break;
>         }
> 
>         lRemaining -= dwCurrentChunkSize;
> 
>         pbCurrentLocation += dwCurrentChunkSize;
>     }
> 
>     LEAVELOCK();
> 
>     return hr;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addcore.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
143a144,145
>     HRESULT SetDirectPlay4Address( void * pvDataBuffer, const DWORD dwDataSize );
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\addparse.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
27c27
< #include <wchar.h>
---
> #include <stdio.h>
569d568
< // BUGBUG: [mgere] [xbox] Removed wtol temporarily until it is implemented on xbox
571d569
< #ifdef _BUILD_FOR_WIN2000
573d570
< #endif
581,582d577
< // BUGBUG: [mgere] [xbox] Removed swscanf temporarily until it is implemented on xbox
< #ifdef _BUILD_FOR_WIN2000
607d601
< #endif
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
24a25,31
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DPNAddress"
> 
> /*
31a39,67
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNAddress"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNAddress"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dllmain.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
29a30
> #include "creg.h"
38a40,87
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllRegisterServer"
> HRESULT WINAPI DllRegisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::Register( L"DirectPlay8Address.Address.1", L"DirectPlay8Address Object", 
> 							  L"dpnaddr.dll", CLSID_DirectPlay8Address, L"DirectPlay8Address.Address") )
> 	{
> 		DPFERR( "Could not register address object" );
> 		fFailed = TRUE;
> 	}
> 	
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> }
> 
> #undef DPF_MODNAME
> #define DPF_MODNAME "DllUnregisterServer"
> STDAPI DllUnregisterServer()
> {
> 	HRESULT hr = S_OK;
> 	BOOL fFailed = FALSE;
> 
> 	if( !CRegistry::UnRegister(CLSID_DirectPlay8Address) )
> 	{
> 		DPF( 0, "Failed to unregister server object" );
> 		fFailed = TRUE;
> 	}
> 
> 	if( fFailed )
> 	{
> 		return E_FAIL;
> 	}
> 	else
> 	{
> 		return S_OK;
> 	}
> 
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.def)---()---()---()---()---()---()---()---()---()---()  
.  
.  
5a6,8
> 	DirectPlay8AddressCreate	@1
> 	DllRegisterServer	PRIVATE
> 	DllUnregisterServer PRIVATE
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\dnadd.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #define APSTUDIO_HIDDEN_SYMBOLS
> #include "windows.h"
> #undef APSTUDIO_HIDDEN_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnaddr.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Address \0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,61
> 
> #endif
> 
> #endif    // !_MAC
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\dnaddress\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2,3c17,27
< TARGETPATHLIB=$(BASEDIR)\public\sdk\lib
< TARGETTYPE=DYNLINK
---
> DLLDEF=..\dnadd.def
> UMTYPE=windows
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
4a29
> TARGETTYPE=DYNLINK
6,14c31,35
< !ifdef _BUILD_FOR_WIN2000
< UMTYPE=windows
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
16c37
< INCLUDES=..\;..\..\inc;..\..\common
---
> PASS1_PUBLISH={ $(O)\dpnaddr.lib = $(SDK_LIB_PATH)\dpnaddr.lib}
18c39,54
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
>            ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\wsock32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
20d55
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
22,23c57,58
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
26c61,65
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28c67
< DLLDEF=..\dnadd.def
---
> INCLUDES=..\;..\..\..\dvoice\inc;$(DXROOT)\inc;..\..\inc;..\..\common
29a69,76
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
38a86
>          ..\dplegacy.cpp \
40a89,95
> #
> # Next specify options for the compiler.
> #
> 
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNET_EXPORT /DCINTERFACE /DMICHAEL
> 
> USER_C_FLAGS=-nologo -W3
43,62c98,100
< TARGETLIBS= \
<            ..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\winsockx.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpaddr.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
64a65,76
> // {4F0B879F-FA84-42ad-AD4D-B908B908DF87}
> DEFINE_GUID(IID_IDirectPlay8AddressIPX,
> 0x4f0b879f, 0xfa84, 0x42ad, 0xad, 0x4d, 0xb9, 0x8, 0xb9, 0x8, 0xdf, 0x87);
> 
> // {826F86D1-AE2C-4428-A66F-974381B25F5B}
> DEFINE_GUID(IID_IDirectPlay8AddressModem,
> 0x826f86d1, 0xae2c, 0x4428, 0xa6, 0x6f, 0x97, 0x43, 0x81, 0xb2, 0x5f, 0x5b);
> 
> // {59BE79FE-A96A-4710-9BD2-22A50E7B24BD}
> DEFINE_GUID(IID_IDirectPlay8AddressSerial,
> 0x59be79fe, 0xa96a, 0x4710, 0x9b, 0xd2, 0x22, 0xa5, 0xe, 0x7b, 0x24, 0xbd);
> 
72a85,87
> typedef struct IDirectPlay8AddressIPX   	*PDIRECTPLAY8ADDRESSIPX, *LPDIRECTPLAY8ADDRESSIPX;
> typedef struct IDirectPlay8AddressSerial  	*PDIRECTPLAY8ADDRESSSERIAL, *LPDIRECTPLAY8ADDRESSSERIAL;
> typedef struct IDirectPlay8AddressModem		*PDIRECTPLAY8ADDRESSMODEM, *LPDIRECTPLAY8ADDRESSMODEM;
88a104
> #define DPNA_DATATYPE_STRING_ANSI           0x00000005
340a357,409
> // values for baud rate
> #define DPNA_BAUD_RATE_110					110
> #define DPNA_BAUD_RATE_300					300
> #define DPNA_BAUD_RATE_600					600
> #define DPNA_BAUD_RATE_1200					1200
> #define DPNA_BAUD_RATE_2400					2400
> #define DPNA_BAUD_RATE_4800					4800
> #define DPNA_BAUD_RATE_9600					9600
> #define DPNA_BAUD_RATE_14400				14400
> #define DPNA_BAUD_RATE_19200				19200
> #define DPNA_BAUD_RATE_38400				38400
> #define DPNA_BAUD_RATE_56000				56000
> #define DPNA_BAUD_RATE_57600				57600
> #define DPNA_BAUD_RATE_115200				115200
> #define DPNA_BAUD_RATE_128000				128000
> #define DPNA_BAUD_RATE_256000				256000
> 
> //// values for baud rate
> //#define DPNA_BAUD_RATE_110					L"110"
> //#define DPNA_BAUD_RATE_300					L"300"
> //#define DPNA_BAUD_RATE_600					L"600"
> //#define DPNA_BAUD_RATE_1200					L"1200"
> //#define DPNA_BAUD_RATE_2400					L"2400"
> //#define DPNA_BAUD_RATE_4800					L"4800"
> //#define DPNA_BAUD_RATE_9600					L"9600"
> //#define DPNA_BAUD_RATE_14400				L"14400"
> //#define DPNA_BAUD_RATE_19200				L"19200"
> //#define DPNA_BAUD_RATE_38400				L"38400"
> //#define DPNA_BAUD_RATE_56000				L"56000"
> //#define DPNA_BAUD_RATE_57600				L"57600"
> //#define DPNA_BAUD_RATE_115200				L"115200"
> //#define DPNA_BAUD_RATE_128000				L"128000"
> //#define DPNA_BAUD_RATE_256000				L"256000"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE					L"1"
> #define DPNA_STOP_BITS_ONE_FIVE				L"1.5"
> #define DPNA_STOP_BITS_TWO					L"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE					L"NONE"
> #define DPNA_PARITY_EVEN					L"EVEN"
> #define DPNA_PARITY_ODD						L"ODD"
> #define DPNA_PARITY_MARK					L"MARK"
> #define DPNA_PARITY_SPACE					L"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE				L"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF			L"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS				L"RTS"
> #define DPNA_FLOW_CONTROL_DTR				L"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR			L"RTSDTR"
> 
342a412,414
> #define DPNA_VALUE_IPXPROVIDER              L"IPX"
> #define DPNA_VALUE_MODEMPROVIDER            L"MODEM"
> #define DPNA_VALUE_SERIALPROVIDER           L"SERIAL"
344a417,479
> //// ANSI DEFINITIONS
> 
> // Header
> #define DPNA_HEADER_A						"x-directplay:/"
> #define DPNA_SEPARATOR_KEYVALUE_A			'='
> #define DPNA_SEPARATOR_USERDATA_A			'#'
> #define DPNA_SEPARATOR_COMPONENT_A			';'
> #define DPNA_ESCAPECHAR_A					'%'
> 
> // key names for address components
> #define DPNA_KEY_APPLICATION_INSTANCE_A		"applicationinstance"
> #define DPNA_KEY_BAUD_A						"baud"
> #define DPNA_KEY_DEVICE_A					"device"
> #define DPNA_KEY_FLOWCONTROL_A				"flowcontrol"
> #define DPNA_KEY_HOSTNAME_A					"hostname"
> #define DPNA_KEY_PARITY_A					"parity"
> #define DPNA_KEY_PHONENUMBER_A				"phonenumber"
> #define DPNA_KEY_PORT_A						"port"
> #define DPNA_KEY_PROGRAM_A					"program"
> #define DPNA_KEY_PROVIDER_A					"provider"
> #define DPNA_KEY_STOPBITS_A					"stopbits"
> 
> //// values for baud rate
> //#define DPNA_BAUD_RATE_110_A				"110"
> //#define DPNA_BAUD_RATE_300_A				"300"
> //#define DPNA_BAUD_RATE_600_A				"600"
> //#define DPNA_BAUD_RATE_1200_A				"1200"
> //#define DPNA_BAUD_RATE_2400_A				"2400"
> //#define DPNA_BAUD_RATE_4800_A				"4800"
> //#define DPNA_BAUD_RATE_9600_A				"9600"
> //#define DPNA_BAUD_RATE_14400_A				"14400"
> //#define DPNA_BAUD_RATE_19200_A				"19200"
> //#define DPNA_BAUD_RATE_38400_A				"38400"
> //#define DPNA_BAUD_RATE_56000_A				"56000"
> //#define DPNA_BAUD_RATE_57600_A				"57600"
> //#define DPNA_BAUD_RATE_115200_A				"115200"
> //#define DPNA_BAUD_RATE_128000_A				"128000"
> //#define DPNA_BAUD_RATE_256000_A				"256000"
> 
> // values for stop bits
> #define DPNA_STOP_BITS_ONE_A				"1"
> #define DPNA_STOP_BITS_ONE_FIVE_A			"1.5"
> #define DPNA_STOP_BITS_TWO_A				"2"
> 
> // values for parity
> #define DPNA_PARITY_NONE_A					"NONE"
> #define DPNA_PARITY_EVEN_A					"EVEN"
> #define DPNA_PARITY_ODD_A					"ODD"
> #define DPNA_PARITY_MARK_A					"MARK"
> #define DPNA_PARITY_SPACE_A					"SPACE"
> 
> // values for flow control
> #define DPNA_FLOW_CONTROL_NONE_A			"NONE"
> #define DPNA_FLOW_CONTROL_XONXOFF_A 		"XONXOFF"
> #define DPNA_FLOW_CONTROL_RTS_A				"RTS"
> #define DPNA_FLOW_CONTROL_DTR_A				"DTR"
> #define DPNA_FLOW_CONTROL_RTSDTR_A			"RTSDTR"
> 
> // Shortcut values
> #define DPNA_VALUE_TCPIPPROVIDER_A          "IP"
> #define DPNA_VALUE_IPXPROVIDER_A            "IPX"
> #define DPNA_VALUE_MODEMPROVIDER_A          "MODEM"
> #define DPNA_VALUE_SERIALPROVIDER_A         "SERIAL"
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dplay8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
135,136d134
< DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
< 
177a176,177
> // {53934290-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_IPX, 0x53934290, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
178a179,180
> // {6D4A3650-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_MODEM, 0x6d4a3650, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
179a182,185
> // {743B5D60-628D-11D2-AE0F-006097B01411}
> DEFINE_GUID(CLSID_DP8SP_SERIAL, 0x743b5d60, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);
> 
> 
199a206,208
> typedef struct IDirectPlay8LobbiedApplication	*PDNLOBBIEDAPPLICATION;
> typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
> 
691a701
> #define	DPNCONNECT_OKTOQUERYFORADDRESSING	0x0001
696a707
> #define	DPNENUMHOSTS_OKTOQUERYFORADDRESSING	0x0001
804a816
> #define DPNSESSION_NODPNSVR					0x0040
888c900
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
933c945
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
983c995
< 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, PVOID const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
---
> 	STDMETHOD(RegisterLobby)			(THIS_ const DPNHANDLE dpnHandle, IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags) PURE;
.  
.  
()---()---()---()---()---()---()---()---()---(.\inc\dpsp8.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
56a57
> #define DPNSPF_OKTOQUERY			0x00000002		// OK for SP to ask the user for clarification on addresses
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\connect.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
105c105
< 	DNASSERT( ulFlags == 0 );
---
> 	DNASSERT( ( ulFlags & ~( DPNCONNECT_OKTOQUERYFORADDRESSING ) ) == 0 );
106a107,111
> 	if ( ( ulFlags & DPNCONNECT_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		ConnData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\enum.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
117a118,122
> 	if ( ( dwFlags & DPNENUMHOSTS_OKTOQUERYFORADDRESSING ) != 0 )
> 	{
> 		EnumData.dwFlags |= DPNSPF_OKTOQUERY;
> 	}
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\initialize.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
353c353
< 		if((pSPD->hSendEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL){
---
> 		if((pSPD->hSendEvent = CreateEventA(NULL, FALSE, FALSE, NULL)) == NULL){
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\sources)---()---()---()---()---()---()---()---()---()---()  
.  
.  
0a1,15
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
> 
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
2c17,26
< TARGETTYPE=LIBRARY
---
> 
> 
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
> 
3a28
> TARGETTYPE=LIBRARY
5,9d29
< !ifdef _BUILD_FOR_WIN2000
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< LINKER_FLAGS=-align:32
< !endif
11c31,35
< INCLUDES=..\common;..\inc;..\dnaddress
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
13c37,41
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE -DMICHAEL
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc 
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS)
15d42
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
17,18c44,55
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> 
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
> 
> INCLUDES=$(DXROOT)\inc;..\common;..\inc;..\dnaddress
> 
> 
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
21c58,63
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
34c76,78
< USE_NOLIBS=1
---
> #
> # Next specify options for the compiler.
> #
36c80,86
< TARGETLIBS=
---
> C_DEFINES= $(C_DEFINES) /D_LIB /D_MBCS /DWIN32 /D_MT /DCINTERFACE /DMICHAEL
> MSC_OPTIMIZATION=/Odi /Zi
> NTDEBUGTYPE=both
> 
> USER_C_FLAGS=-nologo -W3
> 
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\protocol\timer.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
576c576
< 	hWorkToDoSem=CreateSemaphore(NULL,0,65535,NULL);
---
> 	hWorkToDoSem=CreateSemaphoreA(NULL,0,65535,NULL);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,2
< DIRS= wsock
---
> DIRS= serial \
>       wsock
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\classfac.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
198,199c198,228
< // BUGBUG: [mgere] [xbox]  Removed all code in here.  I don't believe it's necessary anymore and it was using some COM functions that we don't have.
< 	return S_OK;
---
>     HRESULT		hr;
>     HINSTANCE	hdll;
>     LPGPCLASSFACTORY	pcf;
> 
> 
>     pcf = (LPGPCLASSFACTORY) This;
> 
>     /*
>      * call CoLockObjectExternal
>      */
>     hr = E_UNEXPECTED;
>     hdll = LoadLibraryA( "OLE32.DLL" );
>     if( hdll != NULL )
>     {
>         PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;
> 
> 
> 		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, "CoLockObjectExternal" ) );
>         if( lpCoLockObjectExternal != NULL )
>         {
>             hr = lpCoLockObjectExternal( (LPUNKNOWN) This, fLock, TRUE );
>         }
>         else
>         {
>         }
>     }
>     else
>     {
>     }
> 
> 	return hr;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\cmddata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dbginfo.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
23a24,30
>  *  Sets the section in Win.ini that the debug code looks at to get the settings
>  */
> 
> #undef PROF_SECT
> #define PROF_SECT "DirectPlay8"
> 
> /*
30a38,66
> 
> /*
>  *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
>  *  string when present in a file.  This name is also used as the key to override
>  *  the standard debug value for this module.
>  */
> #undef DPF_MODULE_NAME
> #define DPF_MODULE_NAME "DNSPWinsock"
> 
> 
> /*
>  * Use this identifier to define which line in WIN.INI [DirectDPlay8] denotes the
>  * debug control string.  This string is typically the default debug value, it
>  * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
>  */
> #undef DPF_CONTROL_LINE
> #define DPF_CONTROL_LINE "DNSPWinsock"
> 
> 
> /*
>  * Define this identifier to a DWORD variable in your component if you want to
>  * be able to turn debugging of components off and on in your component during
>  * a debug session.  This is the variable that holds the mask of the component
>  * bits that are ON and you want debug spew for.  You then use DPFSC instead
>  * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
>  * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
>  * displayed.
>  */
> //#define DPF_SUBCOMP_MASK
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\debugutils.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
120a122,141
> 		case AF_IPX:
> 		{
> 			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );
> 
> 			DPF ( dwDebugLevel, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
> 					(BYTE)pIPXAddress->sa_netnum[ 0 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 1 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 2 ],
> 					(BYTE)pIPXAddress->sa_netnum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
> 					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
> 					p_ntohs( pIPXAddress->sa_socket )
> 					);
> 			break;
> 		}
> 
144,145d164
< // BUGBUG: [mgere] [xbox] Must convert this to unicode
< /*
193d211
< */
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dirs)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1
< DIRS = daytona
---
> DIRS = win9x{32} daytona
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dnwsock.rc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1c1,20
< //LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
---
> //Microsoft Developer Studio generated resource script.
> //
> #include "resource.h"
> 
> #define APSTUDIO_READONLY_SYMBOLS
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 2 resource.
> //
> #include "windows.h"
> 
> /////////////////////////////////////////////////////////////////////////////
> #undef APSTUDIO_READONLY_SYMBOLS
> 
> /////////////////////////////////////////////////////////////////////////////
> // English (U.S.) resources
> 
> #if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
> #ifdef _WIN32
> LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
2a22
> #endif //_WIN32
3a24,31
> #ifndef _MAC
> /////////////////////////////////////////////////////////////////////////////
> //
> // Version
> //
> 
> #ifdef WIN95
> 
4a33,48
> #include "verinfo.h"
> 
> #define VERSIONNAME               "dpnwsock.dll\0"
> #ifdef DEBUG
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider Debug\0"
> #else
> #define VERSIONDESCRIPTION        "Microsoft DirectPlay8 Winsock Provider\0"
> #endif
> #define VERSIONTYPE               VFT_DLL
> #define VERSIONSUBTYPE            VFT2_UNKNOWN
> 
> #include "verinfo.ver"
> 
> #else // WinNT
> 
> #include <windows.h>
12a57,153
> 
> #endif
> 
> #endif    // !_MAC
> 
> 
> 
> #ifdef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // TEXTINCLUDE
> //
> 
> 1 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "resource.h\0"
> END
> 
> 2 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "#include ""afxres.h""\r\n"
>     "\0"
> END
> 
> 3 TEXTINCLUDE DISCARDABLE 
> BEGIN
>     "\r\n"
>     "\0"
> END
> 
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // Dialog
> //
> 
> IDD_IP_SETTINGS DIALOG DISCARDABLE  0, 0, 194, 66
> STYLE DS_MODALFRAME | DS_SETFOREGROUND | WS_POPUP | WS_VISIBLE | WS_CAPTION | 
>     WS_SYSMENU
> CAPTION "Enter host name"
> FONT 8, "MS Shell Dlg"
> BEGIN
>     LTEXT           "Enter the remote machine address:",
>                     IDC_STATIC_IP_HOSTNAME,7,7,110,8
>     EDITTEXT        IDC_EDIT_IP_HOSTNAME,7,45,180,14,ES_AUTOHSCROLL
>     DEFPUSHBUTTON   "OK",IDOK,137,7,50,14
>     PUSHBUTTON      "Cancel",IDCANCEL,137,24,50,14
> END
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // DESIGNINFO
> //
> 
> #ifdef APSTUDIO_INVOKED
> GUIDELINES DESIGNINFO DISCARDABLE 
> BEGIN
>     IDD_IP_SETTINGS, DIALOG
>     BEGIN
>         LEFTMARGIN, 7
>         RIGHTMARGIN, 187
>         TOPMARGIN, 7
>         BOTTOMMARGIN, 59
>     END
> END
> #endif    // APSTUDIO_INVOKED
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> //
> // String Table
> //
> 
> STRINGTABLE DISCARDABLE 
> BEGIN
>     IDS_FRIENDLYNAME_IPX    "DirectPlay8 IPX Service Provider"
>     IDS_FRIENDLYNAME_TCPIP  "DirectPlay8 TCP/IP Service Provider"
> END
> 
> #endif    // English (U.S.) resources
> /////////////////////////////////////////////////////////////////////////////
> 
> 
> 
> #ifndef APSTUDIO_INVOKED
> /////////////////////////////////////////////////////////////////////////////
> //
> // Generated from the TEXTINCLUDE 3 resource.
> //
> 
> 
> /////////////////////////////////////////////////////////////////////////////
> #endif    // not APSTUDIO_INVOKED
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock1.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,42c1,67
< #define p_accept accept
< #define p_bind bind
< #define p_closesocket closesocket
< #define p_connect connect
< #define p_gethostbyaddr gethostbyaddr
< #define p_gethostbyname gethostbyname
< #define p_gethostname gethostname
< #define p_getpeername getpeername
< #define p_getprotobyname getprotobyname
< #define p_getprotobynumber getprotobynumber
< #define p_getservbyname getservbyname
< #define p_getservbyport getservbyport
< #define p_getsockname getsockname
< #define p_getsockopt getsockopt
< #define p_htonl htonl
< #define p_htons htons
< #define p_inet_addr inet_addr
< #define p_inet_ntoa inet_ntoa
< #define p_ioctlsocket ioctlsocket
< #define p_listen listen
< #define p_ntohl ntohl
< #define p_ntohs ntohs
< #define p_recv recv
< #define p_recvfrom recvfrom
< #define p_select select
< #define p_send send
< #define p_sendto sendto
< #define p_setsockopt setsockopt
< #define p_shutdown shutdown
< #define p_socket socket
< //#define p_WSAAsyncGetHostByAddr WSAAsyncGetHostByAddr
< //#define p_WSAAsyncGetHostByName WSAAsyncGetHostByName
< //#define p_WSAAsyncGetProtoByName WSAAsyncGetProtoByName
< //#define p_WSAAsyncGetProtoByNumber WSAAsyncGetProtoByNumber
< //#define p_WSAAsyncGetServByName WSAAsyncGetServByName
< //#define p_WSAAsyncGetServByPort WSAAsyncGetServByPort
< //#define p_WSAAsyncSelect WSAAsyncSelect
< //#define p_WSACancelAsyncRequest WSACancelAsyncRequest
< #define p_WSACleanup WSACleanup
< #define p_WSAGetLastError WSAGetLastError
< #define p_WSASetLastError WSASetLastError
< #define p_WSAStartup WSAStartup
---
> //
> // DWNSOCK1.INC	Macros for dynamically linking to WinSock 1.1
> //
> 
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	//
> 	// Function available in both versions
> 	//
> 	DYNAMICWINSOCK(accept, LPFN_ACCEPT);
> 	DYNAMICWINSOCK(bind, LPFN_BIND);
> 	DYNAMICWINSOCK(closesocket, LPFN_CLOSESOCKET);
> 	DYNAMICWINSOCK(connect, LPFN_CONNECT);
> 	DYNAMICWINSOCK(gethostbyaddr, LPFN_GETHOSTBYADDR);
> 	DYNAMICWINSOCK(gethostbyname, LPFN_GETHOSTBYNAME);
> 	DYNAMICWINSOCK(gethostname, LPFN_GETHOSTNAME);
> 	DYNAMICWINSOCK(getpeername, LPFN_GETPEERNAME);
> 	DYNAMICWINSOCK(getprotobyname, LPFN_GETPROTOBYNAME);
> 	DYNAMICWINSOCK(getprotobynumber, LPFN_GETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(getservbyname, LPFN_GETSERVBYNAME);
> 	DYNAMICWINSOCK(getservbyport, LPFN_GETSERVBYPORT);
> 	DYNAMICWINSOCK(getsockname, LPFN_GETSOCKNAME);
> 	DYNAMICWINSOCK(getsockopt, LPFN_GETSOCKOPT);
> 	DYNAMICWINSOCK(htonl, LPFN_HTONL);
> 	DYNAMICWINSOCK(htons, LPFN_HTONS);
> 	DYNAMICWINSOCK(inet_addr, LPFN_INET_ADDR);
> 	DYNAMICWINSOCK(inet_ntoa, LPFN_INET_NTOA);
> 	DYNAMICWINSOCK(ioctlsocket, LPFN_IOCTLSOCKET);
> 	DYNAMICWINSOCK(listen, LPFN_LISTEN);
> 	DYNAMICWINSOCK(ntohl, LPFN_NTOHL);
> 	DYNAMICWINSOCK(ntohs, LPFN_NTOHS);
> 	DYNAMICWINSOCK(recv, LPFN_RECV);
> 	DYNAMICWINSOCK(recvfrom, LPFN_RECVFROM);
> 	DYNAMICWINSOCK(select, LPFN_SELECT);
> 	DYNAMICWINSOCK(send, LPFN_SEND);
> 	DYNAMICWINSOCK(sendto, LPFN_SENDTO);
> 	DYNAMICWINSOCK(setsockopt, LPFN_SETSOCKOPT);
> 	DYNAMICWINSOCK(shutdown, LPFN_SHUTDOWN);
> 	DYNAMICWINSOCK(socket, LPFN_SOCKET);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByAddr, LPFN_WSAASYNCGETHOSTBYADDR);
> 	DYNAMICWINSOCK(WSAAsyncGetHostByName, LPFN_WSAASYNCGETHOSTBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByName, LPFN_WSAASYNCGETPROTOBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetProtoByNumber, LPFN_WSAASYNCGETPROTOBYNUMBER);
> 	DYNAMICWINSOCK(WSAAsyncGetServByName, LPFN_WSAASYNCGETSERVBYNAME);
> 	DYNAMICWINSOCK(WSAAsyncGetServByPort, LPFN_WSAASYNCGETSERVBYPORT);
> 	DYNAMICWINSOCK(WSAAsyncSelect, LPFN_WSAASYNCSELECT);
> 	DYNAMICWINSOCK(WSACancelAsyncRequest, LPFN_WSACANCELASYNCREQUEST);
> 	DYNAMICWINSOCK(WSACleanup, LPFN_WSACLEANUP);
> 	DYNAMICWINSOCK(WSAGetLastError, LPFN_WSAGETLASTERROR);
> 	DYNAMICWINSOCK(WSASetLastError, LPFN_WSASETLASTERROR);
> 	DYNAMICWINSOCK(WSAStartup, LPFN_WSASTARTUP);
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\dwnsock2.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,27c1,3
< #ifdef UNICODE
< //	#define p_WSAAddressToString				WSAAddressToStringW
< //	#define p_WSADuplicateSocket				WSADuplicateSocketW
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersW
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsW
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoW
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdW
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassW
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginW
< //	#define p_WSALookupServiceNext				WSALookupServiceNextW
< //	#define p_WSASetService						WSASetServiceW
< //	#define p_WSASocket							WSASocketW
< //	#define p_WSAStringToAddress				WSAStringToAddressW
< #else
< //	#define p_WSAAddressToString				WSAAddressToStringA
< //	#define p_WSADuplicateSocket				WSADuplicateSocketA
< //	#define p_WSAEnumNameSpaceProviders			WSAEnumNameSpaceProvidersA
< 	#define p_WSAEnumProtocols					WSAEnumProtocolsA
< //	#define p_WSAGetServiceClassInfo			WSAGetServiceClassInfoA
< //	#define p_WSAGetServiceClassNameByClassId	WSAGetServiceClassNameByClassIdA
< //	#define p_WSAInstallServiceClass			WSAInstallServiceClassA
< //	#define p_WSALookupServiceBegin				WSALookupServiceBeginA
< //	#define p_WSALookupServiceNext				WSALookupServiceNextA
< //	#define p_WSASetService						WSASetServiceA
< //	#define p_WSASocket							WSASocketA
< //	#define p_WSAStringToAddress				WSAStringToAddressA
< #endif // UNICODE
---
> //
> // DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
> //
29,53c5,70
< //#define p_WSAAccept WSAAccept
< #define p_WSACloseEvent WSACloseEvent
< //#define p_WSAConnect WSAConnect
< #define p_WSACreateEvent WSACreateEvent
< #define p_WSAEnumNetworkEvents WSAEnumNetworkEvents
< #define p_WSAEventSelect WSAEventSelect
< #define p_WSAGetOverlappedResult WSAGetOverlappedResult
< //#define p_WSAGetQOSByName WSAGetQOSByName
< //#define p_WSAHtonl WSAHtonl
< //#define p_WSAHtons WSAHtons
< #define p_WSAIoctl WSAIoctl
< //#define p_WSAJoinLeaf WSAJoinLeaf
< //#define p_WSALookupServiceEnd WSALookupServiceEnd
< //#define p_WSANtohl WSANtohl
< //#define p_WSANtohs WSANtohs
< #define p_WSARecv WSARecv
< //#define p_WSARecvDisconnect WSARecvDisconnect
< #define p_WSARecvFrom WSARecvFrom
< //#define p_WSARemoveServiceClass WSARemoveServiceClass
< #define p_WSAResetEvent WSAResetEvent
< #define p_WSASend WSASend
< //#define p_WSASendDisconnect WSASendDisconnect
< #define p_WSASendTo WSASendTo
< #define p_WSASetEvent WSASetEvent
< #define p_WSAWaitForMultipleEvents WSAWaitForMultipleEvents
---
> #ifdef DWINSOCK_GLOBAL
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_EXTERN
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
> #endif
> 
> #ifdef DWINSOCK_GETPROCADDRESS
> 	#undef DYNAMICWINSOCK
> 	#define DYNAMICWINSOCK(name, ptr)							\
> 				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
> 				if (p_##name == NULL) fOK = FALSE
> #endif
> 
> 	DYNAMICWINSOCK(WSAAccept, LPFN_WSAACCEPT);
> 	DYNAMICWINSOCK(WSAAddressToStringA, LPFN_WSAADDRESSTOSTRINGA);
> 	DYNAMICWINSOCK(WSAAddressToStringW, LPFN_WSAADDRESSTOSTRINGW);
> 	DYNAMICWINSOCK(WSACloseEvent, LPFN_WSACLOSEEVENT);
> 	DYNAMICWINSOCK(WSAConnect, LPFN_WSACONNECT);
> 	DYNAMICWINSOCK(WSACreateEvent, LPFN_WSACREATEEVENT);
> 	DYNAMICWINSOCK(WSADuplicateSocketA, LPFN_WSADUPLICATESOCKETA);
> 	DYNAMICWINSOCK(WSADuplicateSocketW, LPFN_WSADUPLICATESOCKETW);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersA, LPFN_WSAENUMNAMESPACEPROVIDERSA);
> 	DYNAMICWINSOCK(WSAEnumNameSpaceProvidersW, LPFN_WSAENUMNAMESPACEPROVIDERSW);
> 	DYNAMICWINSOCK(WSAEnumNetworkEvents, LPFN_WSAENUMNETWORKEVENTS);
> 	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
> 	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
> 	DYNAMICWINSOCK(WSAEventSelect, LPFN_WSAEVENTSELECT);
> 	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
> 	DYNAMICWINSOCK(WSAGetQOSByName, LPFN_WSAGETQOSBYNAME);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoA, LPFN_WSAGETSERVICECLASSINFOA);
> 	DYNAMICWINSOCK(WSAGetServiceClassInfoW, LPFN_WSAGETSERVICECLASSINFOW);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdA, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA);
> 	DYNAMICWINSOCK(WSAGetServiceClassNameByClassIdW, LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW);
> 	DYNAMICWINSOCK(WSAHtonl, LPFN_WSAHTONL);
> 	DYNAMICWINSOCK(WSAHtons, LPFN_WSAHTONS);
> 	DYNAMICWINSOCK(WSAInstallServiceClassA, LPFN_WSAINSTALLSERVICECLASSA);
> 	DYNAMICWINSOCK(WSAInstallServiceClassW, LPFN_WSAINSTALLSERVICECLASSW);
> 	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
> 	DYNAMICWINSOCK(WSAJoinLeaf, LPFN_WSAJOINLEAF);
> 	DYNAMICWINSOCK(WSALookupServiceBeginA, LPFN_WSALOOKUPSERVICEBEGINA);
> 	DYNAMICWINSOCK(WSALookupServiceBeginW, LPFN_WSALOOKUPSERVICEBEGINW);
> 	DYNAMICWINSOCK(WSALookupServiceEnd, LPFN_WSALOOKUPSERVICEEND);
> 	DYNAMICWINSOCK(WSALookupServiceNextA, LPFN_WSALOOKUPSERVICENEXTA);
> 	DYNAMICWINSOCK(WSALookupServiceNextW, LPFN_WSALOOKUPSERVICENEXTW);
> 	DYNAMICWINSOCK(WSANtohl, LPFN_WSANTOHL);
> 	DYNAMICWINSOCK(WSANtohs, LPFN_WSANTOHS);
> 	DYNAMICWINSOCK(WSARecv, LPFN_WSARECV);
> 	DYNAMICWINSOCK(WSARecvDisconnect, LPFN_WSARECVDISCONNECT);
> 	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
> 	DYNAMICWINSOCK(WSARemoveServiceClass, LPFN_WSAREMOVESERVICECLASS);
> 	DYNAMICWINSOCK(WSAResetEvent, LPFN_WSARESETEVENT);
> 	DYNAMICWINSOCK(WSASend, LPFN_WSASEND);
> 	DYNAMICWINSOCK(WSASendDisconnect, LPFN_WSASENDDISCONNECT);
> 	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
> 	DYNAMICWINSOCK(WSASetEvent, LPFN_WSASETEVENT);
> 	DYNAMICWINSOCK(WSASetServiceA, LPFN_WSASETSERVICEA);
> 	DYNAMICWINSOCK(WSASetServiceW, LPFN_WSASETSERVICEW);
> 	DYNAMICWINSOCK(WSASocketA, LPFN_WSASOCKETA);
> 	DYNAMICWINSOCK(WSASocketW, LPFN_WSASOCKETW);
> 	DYNAMICWINSOCK(WSAStringToAddressA, LPFN_WSASTRINGTOADDRESSA);
> 	DYNAMICWINSOCK(WSAStringToAddressW, LPFN_WSASTRINGTOADDRESSW);
> 	DYNAMICWINSOCK(WSAWaitForMultipleEvents, LPFN_WSAWAITFORMULTIPLEEVENTS);
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
104a106
> 	m_hActiveSettingsDialog( NULL ),
134a137
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
369a373,380
> 		//
> 		// cancel any active dialogs
> 		// if there are no dialogs, cancel the active command
> 		//
> 		if ( m_hActiveSettingsDialog != NULL )
> 		{
> 			StopSettingsDialog( m_hActiveSettingsDialog );
> 		}
372a384,390
> 	else
> 	{
> 		//
> 		// there should be no active dialog if there isn't an active command
> 		//
> 		DNASSERT( m_hActiveSettingsDialog == NULL );
> 	}
374d391
< 
876a894,900
> 	if ( m_hActiveSettingsDialog != NULL )
> 	{
> 		StopSettingsDialog( m_hActiveSettingsDialog );
> 		Unlock();
> 	}
> 	else
> 	{
882a907
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\endpoint.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
344a345,351
> 		// UI functions
> 		//
> 		virtual	HRESULT	ShowSettingsDialog( CThreadPool *const pThreadPool ) = 0;
> 		virtual	void	StopSettingsDialog( const HWND hDlg ) = 0;
> 		virtual	void	SettingsDialogComplete( const HRESULT hr ) = 0;
> 
> 		//
363a371,372
> 
> 		HWND			m_hActiveSettingsDialog;		// handle of active settings dialog
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include <WSIPX.h>
44a46
> #include	"IPXAddress.h"
81c83,84
< 	m_pSocketPort( NULL )
---
> 	m_pSocketPort( NULL ),
> 	m_fWin9xOperationPending( FALSE )
99a103,104
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
114a120
> 	m_Win9xReceiveWSAReturn( ERROR_SUCCESS ),
191a198,203
> 		case TYPE_IPX:
> 		{
> 			pSocketAddress = CreateIPXAddress();
> 			break;
> 		}
> 
212a225,231
> 	switch ( OSType() )
> 	{
> 		//
> 		// WinNT, always use IO completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
216a236,258
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
241a284,285
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
275a320,321
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
308a355,360
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
> 			break;
> 		}
> 
450a503,509
> 	switch ( OSType() )
> 	{
> 		//
> 		// WinNT, we'll always use completion ports
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
453a513,536
> 
> 			break;
> 		}
> 
> 		//
> 		// Win9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( NTCompletionFunction() == NULL );
> 			DNASSERT( OverlapEvent() == NULL );
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
485a569,570
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
506a592,593
> 	DNASSERT( ( Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\iodata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
87a88,90
> 		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
> 		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
> 
117a121
> 		BOOL			m_fWin9xOperationPending;	// this structure has been initialized and the operation is pending on Win9x
118a123
> 
148a154
> 		INT		m_Win9xReceiveWSAReturn;		
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
20a21
> #include	<WSIPX.h>
84a86
> const DWORD	g_dwIPBroadcastAddressSize = sizeof( g_IPBroadcastAddress );
978,980d979
< // BUGBUG: [mgere] [xbox] No need to enum adapters anymore since we only have one.
< // need to complete the removal of this functionality at a later date.
< /*
1300d1298
< */	return DPNERR_UNSUPPORTED;
1480a1479,1484
> 	//
> 	// Since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1481a1486,1504
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_ADD_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 5;
> 			break;
> 		}
> 
> 		//
1484a1508,1510
> 		case 2:
> 		default:
> 		{
1485a1512,1514
> 			break;
> 		}
> 	}
1555a1585,1590
> 	//
> 	// since the IP multicast constants are different for Winsock1 vs. Winsock2,
> 	// make sure we use the proper constant.
> 	//
> 	switch ( GetWinsockVersion() )
> 	{
1556a1592,1610
> 		// Winsock 0 doesn't exist!
> 		//
> 		case 0:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 
> 		//
> 		// Winsock1, use the IP_DROP_MEMBERSHIP value for Winsock1
> 		// see WINSOCK.H
> 		//
> 		case 1:
> 		{
> 			SocketOption = 6;
> 			break;
> 		}
> 
> 		//
1559a1614,1616
> 		case 2:
> 		default:
> 		{
1560a1618,1620
> 			break;
> 		}
> 	}
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
18a19
> #include	<WSIPX.h>
38a40
> #include	"StrUtils.h"
52a55
> #include	"IPUI.h"
95a99
> 	memset( m_TempHostName, 0x00, sizeof( m_TempHostName ) );
117a122,368
> // CIPEndpoint::ShowSettingsDialog - show dialog for settings
> //
> // Entry:		Pointer to thread pool
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CIPEndpoint::ShowSettingsDialog( CThreadPool *const pThreadPool )
> {
> 	HRESULT	hr;
> 
> 
> 	DNASSERT( pThreadPool != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 
> 	AddRef();
> 	hr = pThreadPool->SpawnDialogThread( DisplayIPHostNameSettingsDialog, &m_hActiveSettingsDialog, this );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to start IP hostname dialog!" );
> 		DisplayDNError( 0, hr );
> 		goto Failure;
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:	
> 	DecRef();
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::SettingsDialogComplete - dialog has completed
> //
> // Entry:		Error code for dialog
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::SettingsDialogComplete( const HRESULT hDialogResult )
> {
> 	HRESULT					hr;
> 	HRESULT					hTempResult;
> 	IDirectPlay8Address		*pBaseAddress;
> 	DWORD					dwTotalAddressBufferSize;
> 	char					*pTempAddressString;
> 	WCHAR					WCharHostName[ sizeof( m_TempHostName ) + 1 ];
> 	DWORD					dwWCharHostNameSize;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = hDialogResult;
> 	pBaseAddress = NULL;
> 	pTempAddressString = NULL;
> 
> 	//
> 	// since the dialog is exiting, clear our handle to the dialog
> 	//
> 	m_hActiveSettingsDialog = NULL;
> 
> 	//
> 	// dialog failed, fail the user's command
> 	//
> 	if ( hr != DPN_OK )
> 	{
> 		if ( hr != DPNERR_USERCANCEL)
> 		{
> 			DPF( 0, "Failing endpoint hostname dialog!" );
> 			DisplayErrorCode( 0, hr );
> 
> 		}
> 
> 		goto Failure;
> 	}
> 
> 	//
> 	// The dialog completed OK, rebuild remote address and complete command
> 	//
> 
> 	//
> 	// get the base DNADDRESS
> 	//
> 	pBaseAddress = m_pRemoteMachineAddress->DP8AddressFromSocketAddress();
> 	if ( pBaseAddress == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "SettingsDialogComplete: Failed to get base address when completing IP hostname dialog!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// Add the new 'HOSTNAME' parameter to the address.  If the hostname is blank
> 	// and this is an enum, copy the broadcast hostname.
> 	//
> 	if ( ( m_TempHostName[ 0 ] == '\0' ) && ( m_EndpointType == ENDPOINT_TYPE_ENUM ) )
> 	{
> 		DNASSERT( sizeof( WCharHostName ) >= g_dwIPBroadcastAddressSize );
> 		memcpy( WCharHostName, g_IPBroadcastAddress, g_dwIPBroadcastAddressSize );
> 		dwWCharHostNameSize = g_dwIPBroadcastAddressSize;
> 	}
> 	else
> 	{
> 		dwWCharHostNameSize = LENGTHOF( WCharHostName );
> 		hr = STR_AnsiToWide( m_TempHostName, -1, WCharHostName, &dwWCharHostNameSize );
> 		DNASSERT( hr == DPN_OK );
> 		dwWCharHostNameSize *= sizeof( WCHAR );
> 	}
> 
> 	hr = IDirectPlay8Address_AddComponent( pBaseAddress, DPNA_KEY_HOSTNAME, WCharHostName, dwWCharHostNameSize, DPNA_DATATYPE_STRING );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "SettingsDialogComplete: Failed to add hostname to address!" );
> 		goto Failure;
> 	}
> 
> 	//
> 	// set the address
> 	//
> 	hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pBaseAddress, SP_ADDRESS_TYPE_HOST );
> 	if ( hr != DPN_OK )
> 	{
> 		DPF( 0, "Failed to rebuild DNADDRESS when completing IP hostname dialog!" );
> 		DNASSERT( FALSE );
> 		goto Failure;
> 	}
> 
> 	AddRef();
> 
> 	//
> 	// Since any asynchronous I/O posted on a thread is quit when the thread
> 	// exits, it's necessary for the completion of this operation to happen
> 	// on one of the thread pool threads.
> 	//
> 	switch ( GetType() )
> 	{
> 	    case ENDPOINT_TYPE_ENUM:
> 	    {
> 			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( EnumQueryJobCallback,
> 																   CancelEnumQueryJobCallback,
> 																   this );
> 			if ( hr != DPN_OK )
> 			{
> 				DecRef();
> 				DPF( 0, "Failed to set enum query!" );
> 				DisplayDNError( 0, hr );
> 				goto Failure;
> 			}
> 
> //	    	hr = CompleteEnumQuery();
> //	    	if ( hr != DPN_OK )
> //	    	{
> //	    		DPF( 0, "Problem completing EnumQuery after asking user for hostname!" );
> //	    		DisplayDNError( 0, hr );
> //	    	}
> //
> 	    	break;
> 	    }
> 
> 	    case ENDPOINT_TYPE_CONNECT:
> 	    {
> 			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( ConnectJobCallback,
> 																   CancelConnectJobCallback,
> 																   this );
> 			if ( hr != DPN_OK )
> 			{
> 				DecRef();
> 				DPF( 0, "Failed to set enum query!" );
> 				DisplayDNError( 0, hr );
> 				goto Failure;
> 			}
> //	    	hr = CompleteConnect();
> //	    	if ( hr != DPN_OK )
> //	    	{
> //	    		DPF( 0, "Problem completing Connect after asking user for hostname!" );
> //	    		DisplayDNError( 0, hr );
> //	    	}
> 
> 	    	break;
> 	    }
> 
> 	    //
> 	    // unknown!
> 	    //
> 	    default:
> 	    {
> 	    	INT3;
> 			hr = DPNERR_GENERIC;
> 	    	goto Failure;
> 
> 	    	break;
> 	    }
> 	}
> 
> Exit:
> 	if ( pBaseAddress != NULL )
> 	{
> 		IDirectPlay8Address_Release( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DNASSERT( pTempAddressString == NULL );
> 	if ( pBaseAddress != NULL )
> 	{
> 		DNFree( pBaseAddress );
> 		pBaseAddress = NULL;
> 	}
> 
> 	DecRef();
> 
> 	return;
> 
> Failure:
> 	//
> 	// close this endpoint
> 	//
> 	Close( hr );
> 	
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CIPEndpoint::StopSettingsDialog - stop an active settings dialog
> //
> // Entry:		Handle of dialog to close
> //
> // Exit:		Nothing
> // ------------------------------
> void	CIPEndpoint::StopSettingsDialog( const HWND hDlg)
> {
> 	StopIPHostNameSettingsDialog( hDlg );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
204a456,458
> 	m_EndpointType = ENDPOINT_TYPE_UNKNOWN;
> 	m_EnumKey.SetKey( INVALID_ENUM_KEY );
> 
216c470
< 	DNASSERT( m_pSocketPort == NULL );
---
> 	DNASSERT( GetSocketPort() == NULL );
217a472
> 	DNASSERT( m_hActiveSettingsDialog == NULL );
255,258c510,514
< 	if ( ConnectHasBeenSignalled() != FALSE )
< 	{
< 		SignalDisconnect();
< 	}
---
> 	DNASSERT( ConnectHasBeenSignalled() == FALSE );
> //	if ( ConnectHasBeenSignalled() != FALSE )
> //	{
> //	    SignalDisconnect();
> //	}
263,264d518
< 
< 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\ipendpt.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
22a23,24
> #define	TEMP_HOSTNAME_LENGTH	100
> 
52a55,67
> 		// UI functions
> 		//
> 		HRESULT		ShowSettingsDialog( CThreadPool *const pThreadPool );
> 		void		SettingsDialogComplete( const HRESULT hr );
> 		void		StopSettingsDialog( const HWND hDlg );
> 		void		SetTempHostName( const char *const pHostName, const UINT_PTR uHostNameLength )
> 		{
> 			DNASSERT( pHostName[ uHostNameLength ] == '\0' );
> 			DNASSERT( ( uHostNameLength + 1 ) <= LENGTHOF( m_TempHostName ) );
> 			memcpy( m_TempHostName, pHostName, ( uHostNameLength + 1 ) );
> 		}
> 
> 		//
69a85
> 		char		m_TempHostName[ TEMP_HOSTNAME_LENGTH ];
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\locals.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
62a63,67
> //
> // OS version
> //
> UINT_PTR	g_uOSType;
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\locals.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
106a107,111
> //
> // OS version
> //
> extern	UINT_PTR	g_uOSType;
> 
108a114,128
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // OSType - get OS type
> //
> // Entry:		Nothing
> //
> // Exit:		OSType
> // ------------------------------
> inline UINT_PTR	OSType( void )
> {
> 	return	g_uOSType;
> }
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include <WSIPX.h>
50a52
> #include	"IPXAddress.h"
54a57
> #include	"IPXEndpt.h"
82a86
> static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
84a89
> static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
174a180,186
> 	DNASSERT( g_pIPXAddressPool == NULL );
> 	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
> 	if ( g_pIPXAddressPool == NULL )
> 	{
> 		goto Failure;
> 	}
> 
193a206,222
> 	DNASSERT( g_pIPXEndpointPool == NULL );
> 	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		if ( g_pIPXEndpointPool->Initialize() == FALSE )
> 		{
> 			delete	g_pIPXEndpointPool;
> 			g_pIPXEndpointPool = NULL;
> 			goto Failure;
> 		}
> 	}
> 	else
> 	{
> 		goto Failure;
> 	}
> 
> 	
318a348,354
> 	if ( g_pIPXEndpointPool != NULL )
> 	{
> 		g_pIPXEndpointPool->Deinitialize();
> 		delete	g_pIPXEndpointPool;
> 		g_pIPXEndpointPool = NULL;
> 	}
> 
328a365,370
> 	if ( g_pIPXAddressPool != NULL )
> 	{
> 		delete	g_pIPXAddressPool;
> 		g_pIPXAddressPool = NULL;
> 	}
> 
399a442
> 
428a472,515
> // CreateIPXAddress - create IPX address
> //
> // Entry:		Nothing
> //
> // Exit:		Pointer to IPX address
> // ------------------------------
> CIPXAddress	*CreateIPXAddress( void )
> {
> 	CIPXAddress	*pReturnAddress;
> 
> 	
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	
> 	DNEnterCriticalSection( &g_AddressLock );
> 	pReturnAddress = g_pIPXAddressPool->Get();
> 	DNLeaveCriticalSection( &g_AddressLock );
> 
> 	return	pReturnAddress;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // ReturnIPXAddress - return an IPX address
> //
> // Entry:		Pointer to IPX address
> //
> // Exit:		Nothing
> // ------------------------------
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
> {
> 	DNASSERT( pIPXAddress != NULL );
> 	DNASSERT( g_pIPXAddressPool != NULL );
> 	
> 	DNEnterCriticalSection( &g_AddressLock );
> 	g_pIPXAddressPool->Release( pIPXAddress );
> 	DNLeaveCriticalSection( &g_AddressLock );
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
438a526,541
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CreateIPXEndpoint - create IPX endpoint
> //
> // Entry:		Pointer to context
> //
> // Exit:		Pointer to IPX endpoint
> // ------------------------------
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
> {
> 	DNASSERT( g_pIPXEndpointPool != NULL );
> 	return	g_pIPXEndpointPool->Get( pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\pools.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
33a34
> class	CIPXAddress;
34a36
> class	CIPXEndpoint;
59a62,63
> CIPXAddress	*CreateIPXAddress( void );
> void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );
61a66
> CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\rsip.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
40a41
> #include	"Registry.h"
512a514,517
> 
> 		hr = GetGatewayFromRegistry( reinterpret_cast<BYTE*>( gwipaddr ), sizeof( gwipaddr ) );
> 
> 		if(hr != DPN_OK){
514a520,522
> 		}
> 
> 		DPF(0,"Found suggested RSIP gateway in registry %s, running on Win95?\n",gwipaddr);
651d658
<         WCHAR wszIPHLPAPI[] = L"IPHLPAPI.DLL";
687c694
< 	hIpHlpApi = LoadLibrary(wszIPHLPAPI);
---
> 	hIpHlpApi = LoadLibrary("IPHLPAPI.DLL");
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sendqueue.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include	<WSIPX.h>
260a262,268
> //	//
> //	// Winsock 2 functionality always exists on WinNT.  If we're on Win9x, we can
> //	// only use Winsock2 interfaces for TCP.
> //	//
> //	if ( ( OSType() == VER_PLATFORM_WIN32_NT ) ||
> //		 ( ( LOWORD( GetWinsockVersion() ) >= 2 ) && ( m_pSPData->GetType() == TYPE_IP ) ) )
> //	{
261a270,274
> //	}
> //	else
> //	{
> //		m_pSendFunction = Winsock1Send;
> //	}
378a392,399
> 	
> 	//
> 	// Winsock 2 functionality always exists on WinNT.  If we're on Win9x, we can
> 	// only use Winsock2 interfaces for TCP.
> 	//
> 	if ( ( OSType() == VER_PLATFORM_WIN32_NT ) ||
> 		 ( ( LOWORD( GetWinsockVersion() ) >= 2 ) && ( m_pSPData->GetType() == TYPE_IP ) ) )
> 	{
379a401,405
> 	}
> 	else
> 	{
> 		m_pSendFunction = Winsock1Send;
> 	}
529a556,567
> 		//
> 		// No more endpoints are referencing this item, unbind this socket port
> 		// from the network and then remove it from the active socket port list.
> 		// If we're on Winsock1, tell the other thread that this socket needs to
> 		// be removed so we can get rid of our outstanding I/O reference.
> 		//
> 		if ( ( LOWORD( GetWinsockVersion() ) == 1 ) ||
> 			 ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( m_pSPData->GetType() == TYPE_IPX ) ) )
> 		{
> 			m_pSPData->GetThreadPool()->RemoveSocketPort( this );
> 		}
> 
965a1004,1016
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ReadService - service a read request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ReadService( void )
> {
> 	INT			iSocketReturn;
> 	READ_IO_DATA_POOL_CONTEXT	PoolContext;
> 	CReadIOData		*pReadData;
967a1019,1114
> 	//
> 	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
> 	// just fail to service this read and the socket will still be labeled
> 	// as ready to receive so we'll try again later.
> 	//
> 	PoolContext.SPType = m_pSPData->GetType();
> 	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
> 	if ( pReadData == NULL )
> 	{
> 		DPF( 0, "Could not get read data to perform a Winsock1 read!" );
> 		goto Exit;
> 	}
> 
> 	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ) == sizeof( char* ) );
> 	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
> 	pReadData->SetSocketPort( NULL );
> 	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
> 								reinterpret_cast<char*>( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ),	// pointer to receive buffer
> 								pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize,		// size of receive buffer
> 								0,															// flags (none)
> 								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
> 								&pReadData->m_iSocketAddressSize							// size of address of sending socket
> 								);
> 	switch ( iSocketReturn )
> 	{
> 		//
> 		// socket has been closed
> 		//
> 		case 0:
> 		{
> 			break;
> 		}
> 
> 		//
> 		// problem
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// one of our previous sends failed to get through,
> 				// and we don't really care anymore
> 				//
> 				case WSAECONNRESET:
> 				{
> 					break;
> 				}
> 
> 				//
> 				// This socket was probably closed
> 				//
> 				case WSAENOTSOCK:
> 				{
> 					DPF( 8, "Winsock1 reporting 'Not a socket' on receive!" );
> 					break;
> 				}
> 
> 				//
> 				// something bad happened
> 				//
> 				default:
> 				{
> 					DPF( 0, "Problem with Winsock1 recvfrom!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					INT3;
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// bytes were read
> 		//
> 		default:
> 		{
> 			pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = iSocketReturn;
> 			ProcessReceivedData( pReadData );
> 
> 			break;
> 		}
> 	}
> 
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();
> 
> Exit:
> 	return;
> }
968a1116,1118
> 
> 
> //**********************************************************************
969a1120,1265
> // CSocketPort::Winsock1WriteService - service a write request on a socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1WriteService( void )
> {
> 	m_SendQueue.Lock();
> 
> 	//
> 	// if there's data to send, attempt to send it
> 	//
> 	if ( m_SendQueue.IsEmpty() == FALSE )
> 	{
> 		SendFromWriteQueue();
> 	}
> 
> 	m_SendQueue.Unlock();
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1ErrorService - service an error on this socket
> //
> // Entry:		Nothing
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Winsock1ErrorService( void )
> {
> 	INT3;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
> //
> // Entry:		Pointer to write data
> //
> // Exit:		Send completion code
> // ------------------------------
> SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
> {
> 	SEND_COMPLETION_CODE	SendCompletionCode;
> 	INT			iSendToReturn;
> 	UINT_PTR	uOutputBufferIndex;
> 	INT			iOutputByteCount;
> 	char		TempBuffer[ MAX_MESSAGE_SIZE ];
> 
> 
> 	DNASSERT( pWriteData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;
> 
> 	//
> 	// flatten output data
> 	//
> 	iOutputByteCount = 0;
> 	uOutputBufferIndex = 0;
> 
> 	DNASSERT( pWriteData->m_uBufferCount != 0 );
> 	do
> 	{
> 		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
> 		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
> 		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;
> 
> 		uOutputBufferIndex++;
> 	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );
> 
> 	//
> 	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
> 	//
> 	iSendToReturn = p_sendto( GetSocket(),			// socket
> 							  TempBuffer,			// data to send
> 							  iOutputByteCount,		// number of bytes to send
> 							  0,					// flags (none)
> 							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
> 							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
> 							  );
> 	switch ( iSendToReturn )
> 	{
> 		//
> 		// problem with send
> 		//
> 		case SOCKET_ERROR:
> 		{
> 			DWORD	dwWinsockError;
> 
> 
> 			dwWinsockError = p_WSAGetLastError();
> 			switch ( dwWinsockError )
> 			{
> 				//
> 				// socket would block on call
> 				//
> 				case WSAEWOULDBLOCK:
> 				{
> 					SendCompletionCode = SEND_WINSOCK_BUSY;
> 					break;
> 				}
> 
> 				//
> 				// other problem
> 				//
> 				default:
> 				{
> 					SendCompletionCode = SEND_FAILED;
> 					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
> 
> 					DPF( 0, "Problem with Winsock1 sendto!" );
> 					DisplayWinsockError( 0, dwWinsockError );
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// send went through, make sure all bytes were sent
> 		//
> 		default:
> 		{
> 			DNASSERT( iSendToReturn == iOutputByteCount );
> 			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );
> 
> 			break;
> 		}
> 	}
> 
> 	return	SendCompletionCode;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
996,997c1292,1293
< 	DNASSERT( pWriteData->OverlapEvent() == NULL );
< 
---
> 	DNASSERT( ( ( OSType() == VER_PLATFORM_WIN32_NT ) && ( pWriteData->OverlapEvent() == NULL ) ) ||
> 			  ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pWriteData->OverlapEvent() != NULL ) ) );
1003a1300,1308
> 	// lock the 'pending operation' list over the call to Winsock to prevent the
> 	// operation from being completed while it's being set up.
> 	//
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->LockWriteData();
> 	}
> 	
> 	//
1009a1315,1317
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
> 	pWriteData->SetWin9xOperationPending( TRUE );
1021a1330,1334
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->UnlockWriteData();
> 	}
> 
1062a1376,1378
> 				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
> 				pWriteData->SetWin9xOperationPending( FALSE );
> 
1136c1452,1453
< 	DNASSERT( pReadData->OverlapEvent() == NULL );
---
> 	DNASSERT( ( ( OSType() == VER_PLATFORM_WIN32_NT ) && ( pReadData->OverlapEvent() == NULL ) ) ||
> 			  ( ( OSType() == VER_PLATFORM_WIN32_WINDOWS ) && ( pReadData->OverlapEvent() != NULL ) ) );
1145a1463,1471
> 	// lock the 'pending operation' list over the call to Winsock to prevent the
> 	// operation from being completed while it's being set up.
> 	//
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->LockReadData();
> 	}
> 
> 	//
1151a1478,1480
> 	DNASSERT( ( pReadData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
> 	pReadData->SetWin9xOperationPending( TRUE );
1162a1492,1497
> 	
> 	if ( OSType() == VER_PLATFORM_WIN32_WINDOWS )
> 	{
> 		m_pSPData->GetThreadPool()->UnlockReadData();
> 	}
> 
1209a1545,1546
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1243a1581,1582
> 					DNASSERT( pReadData->Win9xOperationPending() != FALSE );
> 					pReadData->SetWin9xOperationPending( FALSE );
1288a1628,1629
> 	DNASSERT( ( pWriteData->Win9xOperationPending() == FALSE ) ||
> 			  ( OSType() == VER_PLATFORM_WIN32_NT ) );
1859a2201,2207
> 	switch ( OSType() )
> 	{
> 		//
> 		// we're on NT, bind to the completion port, issue a read and we're done
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1904a2253,2316
> 			break;
> 		}
> 
> 		//
> 		// Win9x.
> 		// If this is not an IPX socket and Winsock 2 (or greater) is available,
> 		// call the Winsock 2 read function.  If this is IPX or we're stuck with
> 		// Winsock 1, inform the thread pool as such.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( hIOCompletionPort == NULL );
> 
> 			if ( ( LOWORD( GetWinsockVersion() ) >= 2 ) &&
> 				 ( m_pSPData->GetType() == TYPE_IP ) )
> 			{
> 				//
> 				// we're using Winsock2, call for two outstanding reads per socket.
> 				//
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #1 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 				hr = Winsock2Receive();
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Problem issuing Win9x read #2 in StartReceiving!" );
> 					DisplayDNError( 0, hr );
> 					INT3;
> 				}
> 
> 			}
> 			else
> 			{
> 				DNASSERT( m_pSPData != NULL );
> 				hr = m_pSPData->GetThreadPool()->AddSocketPort( this );
> 				if ( hr != DPN_OK )
> 				{
> 					DPF( 0, "Failed to add to active socket list!" );
> 					DisplayDNError( 0, hr );
> 					goto Failure;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			hr = DPNERR_UNSUPPORTED;
> 			DNASSERT( FALSE );
> 			goto Failure;
> 
> 			break;
> 		}
> 	}
> 
2542a2955,3110
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
> // CSocketPort::Win9xWinsock2ReceiveComplete - a Winsock2 socket receive
> //		completed on Win9x
> //
> // Entry:		Poiner to read data
> //
> // Exit:		Nothing
> // ------------------------------
> void	CSocketPort::Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData )
> {
> 	DNASSERT( pReadData != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
> 
> 	//
> 	// figure out what's happening with this socket port
> 	//
> 	switch ( m_State )
> 	{
> 		//
> 		// we're unbound, discard this message and don't ask for any more
> 		//
> 		case SOCKET_PORT_STATE_UNBOUND:
> 		{
> 			goto Exit;
> 			break;
> 		}
> 
> 		//
> 		// we're initialized, process input data and submit a new receive if
> 		// applicable
> 		//
> 		case SOCKET_PORT_STATE_INITIALIZED:
> 		{
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// the socket was closed on an outstanding read, stop
> 				// receiving
> 				//
> 				case WSAENOTSOCK:					// WinNT return for closed socket
> 				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
> 				{
> 					break;
> 				}
> 
> 				//
> 				// ERROR_SUCCESS = no problem
> 				// WSAECONNRESET = previous send failed (who cares!)
> 				// default = other error, just try reading again
> 				//
> 				case WSAECONNRESET:
> 				case ERROR_SUCCESS:
> 				default:
> 				{
> 					HRESULT			hTempResult;
> 
> 
> 					DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );
> 
> 					//					
> 					// attempt another read on this socket.
> 					//
> 					Winsock2Receive();
> 
> 					break;
> 				}
> 			}
> 
> 			//
> 			// now that initial reads have been taken care of, perform error-specific
> 			// processing
> 			//
> 			switch ( pReadData->m_Win9xReceiveWSAReturn )
> 			{
> 				//
> 				// succcess, note the actual number of bytes read and tell
> 				// someone about the received data
> 				//
> 				//	Since this data has been processed then we know that receive buffer has already been returned.
> 				//
> 				case ERROR_SUCCESS:
> 				{
> 					pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = pReadData->m_dwOverlappedBytesReceived;
> 					pReadData->m_dwOverlappedBytesReceived = 0;
> 					ProcessReceivedData( pReadData );
> 
> 					break;
> 				}
> 
> 				//
> 				// Other error, stop in the debugger if it's not 'known'.
> 				//
> 				default:
> 				{
> 					switch ( pReadData->m_Win9xReceiveWSAReturn )
> 					{
> 						//
> 						// WSAECONNRESET = a previous send failed and Winsock is telling
> 						//				   us on an unrelated receive (Thanks WINSOCK).
> 						// WSAENOTSOCK = Socket was closed, user probably cancelled
> 						//				 somethinng.  Just clean up.
> 						// ERROR_OPERATION_ABORTED = something stopped the I/O operation.
> 						//
> 						case WSAECONNRESET:
> 						case WSAENOTSOCK:
> 						case ERROR_OPERATION_ABORTED:
> 						{
> 							break;
> 						}
> 
> 						default:
> 						{
> 							DPF( 0, "Problem with Winsock2 Win9x read: " );
> 							DisplayWinsockError( 0, pReadData->m_Win9xReceiveWSAReturn );
> 							INT3;
> 							
> 							break;
> 						}
> 					}
> 
> 					break;
> 				}
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// other state
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
> Exit:
> 	//
> 	// return the current data to the pool and note that
> 	// this I/O operation is complete
> 	//
> 	DNASSERT( pReadData != NULL );
> 	pReadData->DecRef();	
> 	DecRef();
> 
> 	return;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\socketport.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
244a245
> 		void	Win9xWinsock2ReceiveComplete( CReadIOData *const pReadData );
250a252,254
> 		void	Winsock1ReadService( void );
> 		void	Winsock1WriteService( void );
> 		void	Winsock1ErrorService( void );
293a298
> 		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\sources.inc)---()---()---()---()---()---()---()---()---()---()  
.  
.  
1,3c1,5
< TARGETNAME=dpnwsock
< TARGETTYPE=DYNLINK
< TARGETPATH=obj
---
> #
> # The MAJORCOMP and MINORCOMP variables are defined
> # so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
> # cross compiling to provide unique filenames in a flat namespace.
> #
5c7,17
< !ifdef _BUILD_FOR_WIN2000
---
> MAJORCOMP=windows
> MINORCOMP=media
> 
> #
> # The TARGETNAME variable is defined by the developer.  It is the name of
> # the target (component) that is being built by this makefile.  It
> # should NOT include any path or file extension information.
> #
> 
> TARGETNAME=dpnwsock
> DLLDEF=..\wsocksp.def
7,13d18
< DLLENTRY=_DllMainCRTStartup
< C_DEFINES=$(C_DEFINES) -D_BUILD_FOR_WIN2000
< !else
< UMTYPE=xboxdll
< DLLENTRY=DllMain
< LINKER_FLAGS=-align:32
< !endif
15c20,26
< INCLUDES=..\..\;..\..\..\inc;..\..\..\common;..\..\..\..\dnaddress
---
> #
> # The TARGETPATH and TARGETTYPE variables are defined by the developer.
> # The first specifies where the target is to be build.  The second specifies
> # the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
> # UMAPPL_NOLIB is used when you're only building user-mode
> # apps and don't need to build a library.
> #
17c28,29
< C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -DCINTERFACE
---
> TARGETPATH=obj
> TARGETTYPE=DYNLINK
19c31,35
< USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Od
---
> #
> # The TARGETLIBS specifies additional libraries to link with you target
> # image.  Each library path specification should contain an asterisk (*)
> # where the machine specific subdirectory name should go.
> #
21,22c37,58
< !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "ntsdnodbg" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
< USER_C_FLAGS=$(USER_C_FLAGS) /Od
---
> #
> # 04/10/2000 - allows for addition of BoundsChecker, etc
> #  libs specified in the OS environment
> #
> TARGETLIBS=$(TARGETLIBS) \
>            ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
>            $(BASEDIR)\public\sdk\lib\*\libcpmt$(BUILD_ALT_DIR).lib \
> 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
> 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
> 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib
> 
> #
> # If a debug mode is selected, make sure we include the defines to make the
> # logging code operate.
> #
> !if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
> C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
25c61,71
< MSC_WARNING_LEVEL=/W3 /WX
---
> #
> # If we're in the release mode, force the compiler output debug information
> # in the form of a .PDB file.  The MSC_OPTIMIZATION lines are to force the compiler
> # to generate MSDEV compatible .PDB files with /Zi.  The /FAcs line is used to
> # generate mixed source and code files for easier debugging.
> #
> !if "$(NTDEBUG)" == ""
> #MSC_OPTIMIZATION=/Oxs /Zi
> #MSC_OPTIMIZATION= $(MSC_OPTIMIZATION) /FAcs
> NTDEBUGTYPE=both
> !endif
27c73,77
< DLLDEF=..\wsocksp.def
---
> #
> # The INCLUDES variable specifies any include paths that are specific to
> # this source directory.  Separate multiple directory paths with single
> # semicolons.  Relative path specifications are okay.
> #
28a79,88
> INCLUDES=$(DXROOT)\inc;..\..\..\inc;..\..\..\common;..\..\..\dnaddress
> 
> 
> #
> # The SOURCES variable is defined by the developer.  It is a list of all the
> # source files for this component.  Each source file should be on a separate
> # line using the line continuation character.  This will minimize merge
> # conflicts if two developers adding source files to the same component.
> #
> 
32a93
> 	 ..\DWinsock.cpp \
37a99,101
> 	 ..\IPUI.cpp \
> 	 ..\IPXAddress.cpp \
> 	 ..\IPXEndpt.cpp \
40a105
>          ..\Registry.cpp \
49a115,117
> #
> # Next specify options for the compiler.
> #
50a119,121
> C_DEFINES= $(C_DEFINES) /D_USRDLL /D_MBCS /DWIN32 /D_MT /DDNWSock_EXPORTS /DCINTERFACE
> 
> USER_C_FLAGS=-nologo -W3
53,73c124,125
< TARGETLIBS= \
<            ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
<            $(BASEDIR)\public\sdk\lib\*\dpnaddr.lib \
< !ifdef _BUILD_FOR_WIN2000
< 	   $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
<            $(BASEDIR)\public\sdk\lib\*\libcmt$(BUILD_ALT_DIR).lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
< 	   $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib
< !else
< 	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
<            $(BASEDIR)\public\sdk\lib\*\xapi.lib \
<            $(DDK_LIB_PATH)\ntoskrnl.lib \
<            $(BASEDIR)\public\sdk\lib\*\winsockx.lib
< !endif
---
> DLLENTRY=_DllMainCRTStartup
> 
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
17a18
> #include	<WSIPX.H>
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spaddress.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
120c120,121
< 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) );
---
> 						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
> 						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
158c159,160
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
> 					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
236a239
> 			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
237a241
> 			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
240c244
< 			DNASSERT( m_SocketAddress.SocketAddress.sa_family == AF_INET );
---
> 			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
247c251
< 			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
---
> 			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
275a280
> 			SOCKADDR_IPX	IPXSocketAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
19a20
> #include <WSIPX.h>
49a51
> #include	"IPXAddress.h"
55a58
> #include	"IPXEndpt.h"
236a240,269
> 	switch ( OSType() )
> 	{
> 		//
> 		// Windows NT.  Nothing to do.
> 		//
> 		case VER_PLATFORM_WIN32_NT:
> 		{
> 			DPF( 8, "WinNT detected!" );
> 			break;
> 		}
> 
> 		//
> 		// Windows 95, 98
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DPF( 8, "Win9x detected!" );
> 			break;
> 		}
> 
> 		// other version (unsupported!)
> //		case VER_PLATFORM_WIN32_CE:
> 		case VER_PLATFORM_WIN32s:
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
841a875,880
> 		case TYPE_IPX:
> 		{
> 			pEndpoint = CreateIPXEndpoint( &PoolContext );
> 			break;
> 		}
> 
1154a1194,1199
> 		case TYPE_IPX:
> 		{
> 			pReturn = CreateIPXAddress();
> 			break;
> 		}
> 
1185a1231,1236
> 			break;
> 		}
> 
> 		case TYPE_IPX:
> 		{
> 			ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\spdata.h)---()---()---()---()---()---()---()---()---()---()  
.  
.  
49a50,51
> class	CIPXEndpoint;
> class	CIPXAddress;
.  
.  
()---()---()---()---()---()---()---()---()---(.\sp\wsock\threadpool.cpp)---()---()---()---()---()---()---()---()---()---()  
.  
.  
16a17
> #include	<WSIPX.h>
122a124,143
> // structure for common data in Win9x thread
> //
> typedef	struct	_WIN9X_CORE_DATA
> {
> 	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
> 	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
> 	DWORD		dwTimeToNextJob;					// time to next job
> 	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
> 
> } WIN9X_CORE_DATA;
> 
> //
> // information passed to the Win9x workhorse thread
> //
> typedef struct	_WIN9X_THREAD_DATA
> {
> 	CThreadPool		*pThisThreadPool;	// pointer to this object
> } WIN9X_THREAD_DATA;
> 
> //
129a151,161
> //
> // structure passed to dialog threads
> //
> typedef	struct	_DIALOG_THREAD_PARAM
> {
> 	DIALOG_FUNCTION	*pDialogFunction;
> 	HWND			*phDialog;
> 	void			*pContext;
> 	CThreadPool		*pThisThreadPool;
> } DIALOG_THREAD_PARAM;
> 
234c266,273
< 	DEBUG_ONLY( 
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the read data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( OSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
236c275,276
< 	)
---
> 						break;
> 					}
237a278,285
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
244c292,299
< 	DEBUG_ONLY(
---
> 	//
> 	// Win9x has lame APC support and as part of the workaround, the write data
> 	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
> 	//
> 	DEBUG_ONLY( switch ( OSType() )
> 				{
> 					case VER_PLATFORM_WIN32_WINDOWS:
> 					{
246c301,302
< 	)
---
> 						break;
> 					}
247a304,311
> 					default:
> 					{
> 						DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
> 						break;
> 					}
> 				} )
> 
> 
281a346,352
> 	// pool of IPX read requests
> 	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
> 									CReadIOData::ReadIOData_Get,
> 									CReadIOData::ReadIOData_Release,
> 									CReadIOData::ReadIOData_Dealloc
> 									);
> 
338a410,414
> 	//
> 	// OS-specific initialization
> 	//
> 	switch ( OSType() )
> 	{
341a418,419
> 		case VER_PLATFORM_WIN32_NT:
> 		{
347a426,452
> 			break;
> 		}
> 
> 		//
> 		// Windows 9x
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			hr = Win9xInit();
> 			if ( hr != DPN_OK )
> 			{
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 	
376a482,483
> 	SYSTEM_INFO		SystemInfo;
> 	UINT_PTR		uDesiredThreads;
383a491,495
> 	//
> 	// get machine information
> 	//
> 	memset( &SystemInfo, 0x00, sizeof( SystemInfo ) );
> 	GetSystemInfo( &SystemInfo );
407a520,526
> 	uDesiredThreads = ( SystemInfo.dwNumberOfProcessors * 2 ) + 2;
> 	DNASSERT( uDesiredThreads != 0 );
> 	while ( uDesiredThreads > 0 )
> 	{
> 		uDesiredThreads--;
> 		StartNTCompletionThread();
> 	}
409,413d527
<     StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 	StartNTCompletionThread();
< 
438a553,788
> // CThreadPool::Win9xInit - initialize Win9x components
> //
> // Entry:		Nothing
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::Win9xInit( void )
> {
> 	HRESULT				hr;
> 	HANDLE				hPrimaryThread;
> 	HANDLE				hSecondaryThread;
> 	DWORD				dwPrimaryThreadID;
> 	DWORD				dwSecondaryThreadID;
> 	WIN9X_THREAD_DATA	*pPrimaryThreadInput;
> 	WIN9X_THREAD_DATA	*pSecondaryThreadInput;
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	hPrimaryThread = NULL;
> 	hSecondaryThread = NULL;
> 	pPrimaryThreadInput = NULL;
> 	pSecondaryThreadInput = NULL;
> 
> 	//
> 	// Win9x requires completion events for Winsock2.  Always allocate the
> 	// events even though the they might not be used.
> 	//
> 	DNASSERT( m_hWinsock2SendComplete == NULL );
> 	m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
> 										   TRUE,	// manual reset
> 										   FALSE,	// start unsignalled
> 										   NULL		// pointer to name (none)
> 										   );
> 	if ( m_hWinsock2SendComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Send!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	DNASSERT( m_hWinsock2ReceiveComplete == NULL );
> 	m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
> 											  TRUE,		// manual reset
> 											  FALSE,	// start unsignalled
> 											  NULL		// pointer to name (none)
> 											  );
> 	if ( m_hWinsock2ReceiveComplete == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to create event for Winsock2Receive!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	//
> 	// create parameters to worker threads
> 	//
> 	pPrimaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pPrimaryThreadInput ) ) );
> 	if ( pPrimaryThreadInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for primary Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	pSecondaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pSecondaryThreadInput ) ) );
> 	if ( pSecondaryThreadInput == NULL )
> 	{
> 		DPF( 0, "Problem allocating memory for secondary Win9x thread!" );
> 		hr = DPNERR_OUTOFMEMORY;
> 		goto Failure;
> 	}
> 
> 	memset( pPrimaryThreadInput, 0x00, sizeof( *pPrimaryThreadInput ) );
> 	pPrimaryThreadInput->pThisThreadPool = this;
> 	
> 	DBG_CASSERT( sizeof( *pPrimaryThreadInput ) == sizeof( *pSecondaryThreadInput ) );
> 	memcpy( pSecondaryThreadInput, pPrimaryThreadInput, sizeof( *pSecondaryThreadInput ) );
> 
> 	//
> 	// assume that the thread will be created
> 	//
> 	IncrementActiveThreadCount();
> 	
> 	//
> 	// Create one worker thread and boost its priority.  If the primary thread
> 	// can be created and boosted, create a secondary thread.  Do not create a
> 	// secondary thread if the primary could not be boosted because the system
> 	// is probably low on resources.
> 	//
> 	hPrimaryThread = CreateThread( NULL,					// pointer to security attributes (none)
> 								   0,						// stack size (default)
> 								   PrimaryWin9xThread,		// pointer to thread function
> 								   pPrimaryThreadInput,		// pointer to input parameter
> 								   0,						// let it run
> 								   &dwPrimaryThreadID		// pointer to destination of thread ID
> 								   );
> 	if ( hPrimaryThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// Failed to create thread, decrement active thread count and report
> 		// error.
> 		//
> 		DecrementActiveThreadCount();
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem creating Win9x thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		hr = DPNERR_OUTOFMEMORY;
> 
> 		goto Failure;
> 	}
> 	pPrimaryThreadInput = NULL;
> 
> 
> 	DPF( 8, "Created primary Win9x thread: 0x%x\tTotal Thread Count: %d", dwPrimaryThreadID, ThreadCount() );
> 	DNASSERT( hPrimaryThread != NULL );
> 	if ( SetThreadPriority( hPrimaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to boost priority of primary Win9x read thread!  Not starting secondary thread" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 	else
> 	{
> 		//
> 		// primary thread was created and boosted, create a secondary thread
> 		//
> 		IncrementActiveThreadCount();
> 		hSecondaryThread = CreateThread( NULL,						// pointer to security attributes (none)
> 										 0,							// stack size (default)
> 										 SecondaryWin9xThread,		// pointer to thread function
> 										 pSecondaryThreadInput,		// pointer to input parameter
> 										 0,							// let it run
> 										 &dwSecondaryThreadID		// pointer to destination of thread ID
> 										 );
> 		if ( hSecondaryThread != NULL )
> 		{
> 			DPF( 8, "Created secondary Win9x thread: 0x%x\tTotal Thread Count: %d", dwSecondaryThreadID, ThreadCount() );
> 			
> 			pSecondaryThreadInput = NULL;
> 			DNASSERT( hSecondaryThread != NULL );
> 			if ( SetThreadPriority( hSecondaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
> 			{
> 				DWORD	dwError;
> 
> 
> 				dwError = GetLastError();
> 				DPF( 0, "Failed to boost priority of secondary Win9x thread!" );
> 				DisplayErrorCode( 0, dwError );
> 			}
> 		}
> 		else
> 		{
> 			//
> 			// thread startup failed, decrement active thread count
> 			//
> 			DecrementActiveThreadCount();
> 		}
> 	}
> 
> 
> Exit:
> 	if ( pPrimaryThreadInput != NULL )
> 	{
> 		DNFree( pPrimaryThreadInput );
> 		pPrimaryThreadInput = NULL;
> 	}
> 
> 	if ( pSecondaryThreadInput != NULL )
> 	{
> 		DNFree( pSecondaryThreadInput );
> 		pSecondaryThreadInput = NULL;
> 	}
> 
> 	if ( hPrimaryThread != NULL )
> 	{
> 		if ( CloseHandle( hPrimaryThread ) == FALSE )
> 		{
> 			DWORD	dwError;
> 
> 
> 			dwError = GetLastError();
> 			DPF( 0, "Problem closing Win9x thread hanle!" );
> 			DisplayErrorCode( 0, dwError );
> 		}
> 
> 		hPrimaryThread = NULL;
> 	}
> 
> 	if ( hSecondaryThread != NULL )
> 	{
> 		if ( CloseHandle( hSecondaryThread ) == FALSE )
> 		{
> 			DWORD	dwError;
> 
> 
> 			dwError = GetLastError();
> 			DPF( 0, "Problem closing Win9x thread hanle!" );
> 			DisplayErrorCode( 0, dwError );
> 		}
> 
> 		hSecondaryThread = NULL;
> 	}
> 
> 	return	hr;
> 
> Failure:
> 	DPF( 0, "Failed Win9x Initialization!" );
> 	DisplayDNError( 0, hr );
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
537a888,889
> 	if ( OSType() == VER_PLATFORM_WIN32_NT )
> 	{	
558a911
> 	}
640a994,996
> 		DNASSERT( ( OSType() == VER_PLATFORM_WIN32_NT ) || ( pReadData->Win9xOperationPending() != FALSE ) );
> 		pReadData->SetWin9xOperationPending( FALSE );
> 		pReadData->m_Win9xReceiveWSAReturn = WSAESHUTDOWN;
658a1015,1016
> 		DNASSERT( ( OSType() == VER_PLATFORM_WIN32_NT ) || ( pWriteData->Win9xOperationPending() != FALSE ) );
> 		pWriteData->SetWin9xOperationPending( FALSE );
802a1161
> 	m_IPXReadIODataPool.Deinitialize();
850d1208
< 			
854a1213,1221
> 		// IPX
> 		//
> 		case TYPE_IPX:
> 		{
> 			pTempReadData = m_IPXReadIODataPool.Get( pContext );
> 			break;
> 		}
> 
> 		//
932a1300,1308
> 		// IPX
> 		//
> 		case AF_IPX:
> 		{
> 			m_IPXReadIODataPool.Release( pReadData );
> 			break;
> 		}
> 
> 		//
1187a1564,1565
> 	switch ( OSType() )
> 	{
1190a1569,1570
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1207a1588,1616
> 			break;
> 		}
> 
> 		//
> 		// Win9x, set event that the work thread will listen for
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
> 			if ( m_JobQueue.SignalPendingJob() == FALSE )
> 			{
> 				hr = DPNERR_OUTOFMEMORY;
> 				DPF( 0, "Failed to signal pending job!" );
> 				goto Failure;
> 			}
> 
> 			break;
> 		}
> 
> 		//
> 		// unknown platform
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1318a1728,1729
> 	if ( OSType() == VER_PLATFORM_WIN32_NT )
> 	{
1325a1737
> 	}
1527a1940,2040
> // CThreadPool::SpawnDialogThread - start a secondary thread to display service
> //		provider UI.
> //
> // Entry:		Pointer to dialog function
> //				Pointer destination for copy of dialog handle
> //				Dialog context
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, HWND *const phDialog, void *const pDialogContext )
> {
> 	HRESULT	hr;
> 	HANDLE	hDialogThread;
> 	DIALOG_THREAD_PARAM		*pThreadParam;
> 	DWORD	dwThreadID;
> 
> 
> 	DNASSERT( pDialogFunction != NULL );
> 	DNASSERT( phDialog != NULL );
> 	DNASSERT( pDialogContext != NULL );		// why would anyone not want a dialog context??
> 
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	pThreadParam = NULL;
> 
> 	//
> 	// create and initialize thread param
> 	//
> 	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( DNMalloc( sizeof( *pThreadParam ) ) );
> 	if ( pThreadParam == NULL )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "Failed to allocate memory for dialog thread!" );
> 		goto Failure;
> 	}
> 
> 	pThreadParam->pDialogFunction = pDialogFunction;
> 	pThreadParam->phDialog = phDialog;
> 	pThreadParam->pContext = pDialogContext;
> 	pThreadParam->pThisThreadPool = this;
> 
> 	//
> 	// assume that a thread will be created
> 	//
> 	IncrementActiveThreadCount();
> 
> 	//
> 	// create thread
> 	//
> 	hDialogThread = CreateThread( NULL,					// pointer to security (none)
> 								  0,					// stack size (default)
> 								  DialogThreadProc,		// thread procedure
> 								  pThreadParam,			// thread param
> 								  0,					// creation flags (none)
> 								  &dwThreadID );		// pointer to thread ID
> 	if ( hDialogThread == NULL )
> 	{
> 		DWORD	dwError;
> 
> 
> 		//
> 		// decrement active thread count and report error
> 		//
> 		DecrementActiveThreadCount();
> 		
> 		dwError = GetLastError();
> 		DPF( 0, "Failed to start dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 		goto Failure;
> 	}
>   								
> 	if ( CloseHandle( hDialogThread ) == FALSE )
> 	{
> 		DWORD	dwError;
> 
> 
> 		dwError = GetLastError();
> 		DPF( 0, "Problem closing handle from create dialog thread!" );
> 		DisplayErrorCode( 0, dwError );
> 	}
> 
> Exit:	
> 	return	hr;
> 
> Failure:
> 	if ( pThreadParam != NULL )
> 	{
> 		DNFree( pThreadParam );
> 		pThreadParam = NULL;
> 	}
> 
> 	goto Exit;
> }
> //**********************************************************************
> 
> 
> //**********************************************************************
> // ------------------------------
1547a2061,2062
> 	switch ( OSType() )
> 	{
1548a2064,2073
> 		// Win9x only has one thread
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			*piThreadCount = 1;
> 			DNASSERT( NTCompletionThreadCount() == 0 );
> 			break;
> 		}
> 
> 		//
1550a2076,2077
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1552a2080,2081
> 			break;
> 		}
1553a2083,2092
> 		//
> 		// other
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1582a2122,2123
> 	switch ( OSType() )
> 	{
1583a2125,2132
> 		// Win9x has only 1 thread, too bad.
> 		//
> 		case VER_PLATFORM_WIN32_WINDOWS:
> 		{
> 			break;
> 		}
> 
> 		//
1589a2139,2140
> 		case VER_PLATFORM_WIN32_NT:
> 		{
1629a2181,2193
> 			break;
> 		}
> 
> 		//
> 		// other OS
> 		//
> 		default:
> 		{
> 			DNASSERT( FALSE );
> 			break;
> 		}
> 	}
> 
1709a2274,2420
> // CThreadPool::AddSocketPort - add a socket to the Win9x watch list
> //
> // Entry:		Pointer to SocketPort
> //
> // Exit:		Error code
> // ------------------------------
> HRESULT	CThreadPool::AddSocketPort( CSocketPort *const pSocketPort )
> {
> 	HRESULT	hr;
> 	BOOL	fSocketAdded;
> 
> 	
> 	DNASSERT( pSocketPort != NULL );
> 
> 	//
> 	// initialize
> 	//
> 	hr = DPN_OK;
> 	fSocketAdded = FALSE;
> 
> 	Lock();
> 
> 	//
> 	// We're capped by the number of sockets we can use for Winsock1.  Make
> 	// sure we don't allocate too many sockets.
> 	//
> 	if ( m_uReservedSocketCount == FD_SETSIZE )
> 	{
> 		hr = DPNERR_OUTOFMEMORY;
> 		DPF( 0, "There are too many sockets allocated on Winsock1!" );
> 		goto Failure;
> 	}
> 
> 	m_uReservedSocketCount++;
> 	
> 	DNASSERT