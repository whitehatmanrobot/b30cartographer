 Virtual Adapter Instance (for LIS 0 on AIC59002) Linkage Parameters Tcpip // TCP/IP parameters for LIS 0 EnableDHCP: REG_DWORD: 0 IPAddress: REG_MULTI_SZ: 11.221.7.61 Tcpip // TCP/IP is bound to the Virtual adapter Linkage Bind: REG_MULTI_SZ: \Device\ipatmarp3 Figure   SEQ Figure \* ARABIC  : Example registry layout Even though TCP/IP is bound to the virtual adapter  ipatmarp3 , it doesn t try to open the adapter and run Ethernet ARP on it because there is no miniport for ipatmarp3 that starts up and causes TCP/IP s BindAdapter handler to be called for the virtual adapter. Installation and Basic Configuration This section describes the installation of IP over ATM components, and configuring a single Logical IP Subnet. Prerequisites The IP over ATM components need the UNI 3.1 ATM Call Manager and an ATM adapter to be installed on the machine first. All machines are assumed to be ATM-connected to each other, meaning that there is a way for each pair of machines to set up an ATM connection between them. Installing IP over ATM Server One of the stations in the IP/ATM network must be designated as the IP over ATM server machine. Normally, the IP over ATM Client is also installed on this machine. Refer to Section   REF _Ref372007537 \n  5.1.3  for instructions on installing IP over ATM client software. Step 1: Select the Protocols tab within the Network Control Panel. Click on Add... for adding protocols. A list of network protocols is displayed. Step 2: Click on Have Disk. You will be prompted to enter the directory path for the software component. Enter <DriveName>:\atmarps and press RETURN. You will be prompted to confirm installation of  IP over ATM Server Step 3: When prompted to restart the machine, you can click on Yes if you have completed installing all ATM components, otherwise, click on No. Installing IP over ATM Client This component must be installed on all IP stations on the ATM network. The following information is needed for basic configuration of each client station: IP Address and Mask for the client. The network administrator should assign an IP address for the client, from the range of addresses allocated for the Logical IP subnet. The network mask is the appropriate IP address mask for the subnet. ATM Address of the IP over ATM Server. This can be obtained by running the  ATMADM -A  command from a command shell on the IP over ATM server machine. Step 1: Select the Protocols tab within the Network Control Panel. Click on Add... for adding protocols. A list of network protocols is displayed. Step 2: Click on Have Disk. You will be prompted to enter the directory path for the software component. Enter <DriveName>:\atmarpc and press RETURN. You will be prompted to confirm installation of  IP over ATM Client Step 3: A bindings review now takes place, during which TCP/IP pops up a menu  prompting you to configure the IP over ATM Client virtual adapter with an IP address. Enter the IP address assigned to the client, and the network mask for the subnet here. If you have a router on the IP/ATM network, you can optionally enter the IP address of the router as the Default Gateway entry. Step 4:  After entering the IP address for the client, the Network Control Panel prompts you to restart the machine. Select No here. Before restarting the machine, the ATM address of the IP over ATM server must be entered in the NT registry, as outlined in the following steps. Step 5: Start the Registry Editor by typing regedt32 at the command prompt. Select the HKEY_LOCAL_MACHINE window, and navigate down the following path: SYSTEM - CurrentControlSet - Services. Step 6: Obtain the ATM adapter instance name to which the IP over ATM Client is bound. This name (e.g.  AIC59002 ) will be listed, along with a  \Device\  prefix (e.g.  \Device\AIC59002 ) in the Bind value under the atmarpc - Linkage key below the Services key. Step 7: Navigate to the adapter instance subkey below the Services key, and thence to the following subkey: Parameters\AtmArpC\LIS0\ARPServerList\Server1. There is one value under this key, AtmAddress. Change this value to the actual ATM address of the IP over ATM server. Exit regedt32, and restart the machine. Features This section lists some additional features provided with the IP over ATM components. Support for built-in commands The IP over ATM Client supports most of the built-in TCP/IP utilities: IPCONFIG: Display IP configuration information, including IP addresses, Network Masks and Gateway addresses. NETSTAT: TCP/IP Network statistics. Display ARP cache entries. Since the command can display only 6-byte MAC addresses, the ARP client reports only the ESI part of ATM addresses. Also, the -a option, to add ARP cache entries, is not supported. Registry Parameters This section lists configurable parameters for the IP over ATM components. IP over ATM Server Parameters The IP over ATM Server has two sets of parameters: Global parameters and per-adapter parameters. The server doesn t require parameters on a per-LIS basis, because a single instance of the server can be used to support multiple LIS IP over ATM Server Global Parameters These are stored under the Services\AtmArpS\Parameters key in the registry. The complete list is given below. Purpose Default Buffers DWORD The number of buffers used to store received ARP requests. Limits the number of ARP requests queued for processing. FlushTime DWORD The periodic interval at which the server saves the ARP cache to disk. A value of 0 here disables disk caching. 0 (minutes) IP over ATM Server Adapter Parameters These are stored under the Services\<AdapterInstance>\Parameters\AtmArpS key in the registry, and apply to all LIS  served by the server. Purpose Default Selector DWORD The SEL byte on which the Server receives incoming calls on this adapter. RegisteredAddresses MULTI A list of ATM addresses that the server registers with the switch. Clients could connect to the server using one of these addresses. <Empty list> IP over ATM Client Parameters As discussed in Section   REF _Ref372008228 \n  , the IP over ATM Client parameters for each Logical IP Subnet are present under the appropriate Services\<AdapterInstance>\Parameters\AtmArpC\LISi key in the registry. The complete parameter list is given below. Purpose Default SapSelector DWORD The SEL byte used as part of the IP/ATM client s address. Typically, this is set to i+1, where i is the LIS number, as in LISi. ServerConnectInterval DWORD The time between successive attempts to connect to the IP over ATM Server (if connect fails). 5 (secs) ServerRegistrationTimeout DWORD The time, after sending an ARP Request to register with the server, at which the registration attempt is declared to have failed. 3 (secs) AddressResolutionTimeout DWORD The time, after sending an ARP Request to resolve an IP address, at which the resolution attempt is declared to have failed. 3 (secs) ARPEntryAgingTimeout DWORD The time, after creating/refreshing an ARP cache entry, at which the entry is declared to be invalid. The client attempts to refresh this information by sending an ARP Request, only if a VC is associated with this entry. 900 (secs) InARPWaitTimeout DWORD The time, after sending an InARP Request to resolve a PVC, at which the attempt to resolve is deemed to have failed. 5 (secs) ServerRefreshTimeout DWORD The client s IP, ATM address information is sent to the server periodically at this interval. 900 (secs) MinWaitAfterNak DWORD On receiving an ARP NAK in response to an ARP Request sent to resolve an IP address, no more requests for this IP address are sent for this interval. 10 (secs) MaxRegistrationAttempts DWORD Number of times the client tries to register with the server. After exhausting this, the client moves to the next server in the ARPServerList (see below) if one exists, otherwise, to the first server in the list. MaxResolutionAttempts DWORD Number of times address resolution is attempted for an IP address. After exhausting this, the ARP cache entry for the IP address is deleted. DWORD Maximum Transmission Unit for the LIS. This is the value reported to the IP layer. 9188 (bytes) ARPServerList\ Key containing a list of ARP servers that the client tries to contact. Note: the client is registered with only one server at any point of time.      Server1\ Subkey containing information about the first ARP server. Multiple such subkeys can be created.          AtmAddress ATM Address of this ARP Server. ( End Of Document (  In certain cases, it may be possible to use the  well-known IP over ATM server address  that the INFs install by default. See  Well-known IP over ATM addresses  With NT 4.0 and early builds of NT 5.0, it is possible that this pop-up menu may not appear. If this is the case, when prompted to restart the machine, select No, restart Network Control Panel, select the Protocols tab, select  IP over ATM Client , click on Properties, and finally click on OK at the bottom of the panel. You should see a bindings review happen now, and the TCP/IP menu appear. Windows Internetworking IP over ATM User Guide for Windows NT Microsoft Corporation Page   PAGE  PAGE \# "'Page: '#' ATM Switch 10.0.0.1 10.0.0.2 10.0.0.3 10.0.0.4 11.0.0.1 11.0.0.2 11.0.0.3 11.0.0.4 10.0.0.99 11.0.0.99 Server: LIS 10 Server: LIS 11 Router attaching to LIS 10 and LIS 11  Client connections to server, LIS 11  Client connections to server, LIS 10 ATM Miniport NDIS 4.1 Extensions ARP Server for ATM (IP over ATM Server) ARP Interface NDIS 4.0  Interface TCPIP.SYS ATM UNI Call Manager Ethernet Miniport TCP, UDP ARP Module for ATM (IP over ATM Client) ARP Module for Ethernet, TR, ArcNet Normal Heading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Heading 7 Heading 8 Heading 9 Default Paragraph Font Title Annotation Reference Annotation Text Caption Footnote Text Footnote Reference Header Footer Page Number Arvind Murching _Ref371142172 _Ref371127943 _Ref372008228 _Ref372020253 _Ref372007537} Arvind Murching C:\arvind\docs\ipatm\ntuser.doc @\\MSPRINT44\26S/1MC CORPN 157.55.80.239 Ne02: winspool HP LaserJet 4Si/4Si MX PS \\MSPRINT44\26S/1MC CORPN 157.5 Letter \\MSPRINT44\26S/1MC CORPN 157.5 Letter Times New Roman Symbol Arial Lucida Console Wingdings %IP Over ATM User Guide for Windows NT Arvind Murching Arvind Murching
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\atmarps\notes.txt ===
9/2/1998 JosephJ
    As part of implementing promiscuous mode multicast, we need to make some changes
    to the mars server.

    Some observations:
    * RCF2022 has special support for routers wanting to monitor blocks of
      NONOVERLAPPING addresses. It handles these blocks somewhat independantly
      from individual group joins: a block can overlap one or more individual
      group joins. On leaving the block, the mars server maintains the
      individual group joins.

    Changes/fixes required:
    1. MarsPunchHoles needs to be written to change time complexity from
        O(number of addresses in block)
        to
        O(number of mcs address-ranges + number of individual groups).

        Currently, it runs through all 268 million possible addresses
        when processing a join of the entire class-D address space!

        Fix is jump to the end of the hole (if in a hole) or to the
        beginning of the next hole (if not in a hole).

        Also, it  was enumerating the list of groups wrongly -- using
        pGroup->Next instead of pGroup->NextGroup.

    2. MarsAddClusterMemberTogroups:
		When processing an join of the entire class-D space, it needs to check if
        the member has already joined the entire space, in which case it
        should treat the join request as a duplicate (send it back on the private
        vc). Currently it will treat it as a new entry and hence will send
		it on the cluster-control-vc. We would end up with duplicate entries.
        MarsDelClusterMemberFromGroups:
		Similarly, when when processing a leave of the entire class-D space
        when in fact the member has  already left, we must make sure
        that we reflect it privately.

	3. MARS_MULTI processing: MarsHandleRequest had to be modified to
		also return the hw addresses of members monitoring the entire class-D
		address space (but also make sure that it doesn't send duplicate
		hw addresses if the member is also minitoring the specific 
		group address).

9/14/1998 JosephJ

	There are reports of bugchecks during boot up. One is bug# 212412
	(ATMARPS: MarsSendRedirect referenced past end of pool). The stack was:
	f7cfbcdc f276ba36 00000000 fa502000 00000000 ntoskrnl!KiTrap0E+0xc3
	f7cfbd80 f276cc04 80a11828 f92cff18 00000000 atmarps!MarsSendRedirect+0xbe

	MarsSendRedirect is a timer callback function. It it creates and sends
	a redirect packet containing all the configured and registered addresses.
	However it doesn't claim any lock. So it's possible that it's in the
	middle of doing this when registered addresses are added (they are
	added on ArpSCoRequestComplete callbacks.

	So we fix this by adding a lock to the interface when reading/modifying
	these addresses: in  MarsSendRedirect and in ArpSCoRequestComplete. Checked
	in today.

10/24/1998  JosephJ

	Added statistics -- created ARP_SERVER_STATISTICS and MARS_SERVER_STATISTICS
	(iocto.h, ioctl.c, also the added functionality to atmarp.exe to dump this
	stuff).

10/25/1998  JosephJ
	Added support to actually fill out the statistics: ndis.c, mars.c, arps.c, etc.

	Some clarifications...

	Mcast Joins: failed doesn't include dups.

	Mcast requests: MCMesh requests include responses to those nodes that are in 
	promiscuous mode.

	Discarded pkts: usually means pkts discarded due to error/unsupported format or 
	because a resource allocation failure. Also includes pkts discarded because 
	they are not from a cluster member. If the discarded pkt is known to be for a
	particular  task, say a join, then the count of failed joins is also incremented.
	
	We do not explicitly keep track of  failed mars or arp requests which are 
	ignored (either acked or nacked) -- so if you see the arp request count 
	increment but the ack+nak not incrementing, you can conclude that the request 
	is being ignored.

10/25/1998 JosephJ
	While implementing the above, found the following existing bugs:

	MarsReqThread -- if it gets a pkt with an unrecognized opcode, it simply
	leaves it in limbo -- it should put it back into the free list! Otherwise
	we'll soon run out of pkts if we get barraged with bad pkts.

	MarsDelClusterMemberFromGroups: it should
		 (a) delete a mars entry when
			it's list of members goes to NULL -- delete consists of removing
			it from the hash table and calling ArpSFreeBlock on it.
		 (b) actually free the pGroup, calling FREE_MEM.

	checked in  10/28/1998 

12/22/1998 

	Made a change to the following code in  ArpSCoRequestComplete:
	[Old code]
		pIntF->NumAddressesRegd ++;
		if (pIntF->NumAddressesRegd < pIntF->NumRegdAddresses)
		{
			...
		}
	[New code]
		We inly increment NumAddressRegd if 
		(pIntF->NumAddressesRegd < pIntF->NumRegdAddresses).
		We assert otherwise. See 12/22/1998 Note in
		ArpSCoRequestComplete for details.

2/26/1999 JosephJ
	Bug: #297656 ATMARPS: Unbinding arp/mars on server A does not unregister
 			the well-known address from server A.
	Fix:
	I unregister the registered addresses in shutdowninterface, and block until all
	the unregistrations complete. I decided to block because the completions will
	likely be asynchronous and we immediately go on to close the Af and then
	deallocate the object, so I was not comfortable with not waiting for
	completions) of the unregistrations.

2/29/1999 JosephJ

	Stress hit the following assert with checked atmarpc.sys, 1990:
 	 	Assert NdisPartyHandle != NULL failed: file mars.c, line 3247

	The assert was because the ndispartyhandle was NULL in the context of  the
	dropparty handler.

	The crutial observation is the following 2 identical lines of debug spew before
	the assert:
	0:MARS:  AddMemberToCC: pVc 868178c8, pMember 87736808, ConnState 2
	0:MARS:  AddMemberToCC: pVc 868178c8, pMember 87736808, ConnState 2

	The 2nd call to NdisAddParty (from MarsAddMemberToClusterControlVc) clobbers
	the previous value of pMember->NdisPartyHandle on entry and then probably fails
	(because there's already a party).

	Looking for ways that MarsAddMemberToClusterControlVc could be called twice
	(which is not supposed to happen), the only way I can see this happening
	consistant with the  debug spew,  is that an incoming registration-join from a
	new member (MarsHandleJoin) came at the same time that we were handling
	post-processing of the initial CC MakeCall complete
	(ArpSMakeCallComplete, 1195,ndis.c).

	There are holes in the way vc and member flags are set and checked that would
	lead to MarsAddMemberToClusterControlVc being called from both code paths.
	(The enumeration in line 1185 of ArpSMakeCallComplete is also dangerous in
	that it could potentially deref a freed pMember, but that's not what happened
	here).

	The following functions have similary dangerous emumeration/assumption that
	pMember will be valid:
	 MarsAbortAllMembers
	 ArpSDropPartyComplete
	 MarsDelMemberFromClusterControlVc


	FIXES to all of the above:
	  1. Added new function MarsIsValidClusterMember that makes sure a particular
	     member is in the cluster list.
	  2. This function is called from:
		  MarsDelMemberFromClusterControlVc (which simply returns if invalid).
		  ArpSMakeCallComplete (which stops enumeration if a pMember is invalid).
	  3. MarsAbortAllMembers fixed to do a safe enumeration of all members.
	  4. MarsAddMemberToClusterControlVc returns without doing anything if
		if (MARS_GET_CM_CONN_STATE(pMember) != CM_CONN_IDLE) (check is made
		AFTER getting the IF lock).

3/3/1999 JosephJ Revisiting MarsAbortAllMembers and DelMembersfromVc
	-- safe enumeration used.
	

3/3/1999 JosephJ CM_INVALID use
	-- fix del member on add-party complete, but be careful on make-call complete
	   (maybe ok if there are no other members at this time).

3/16/1999 JosephJ Actually checked in the following files...
	ioctl.c v13         fix uninit var 
	mars.c v12          299201 -- various robustness-re
	mars.h v2           299201 -- various robustness-re
	ndis.c v16          299201 -- various robustness-re
	protos.h v9         299201 -- various robustness-re

	All of the above are the fixes explained in 2/29 and 3/3 entries above

	registry.c v5  ArpSReadAdapterConfig... p -- p
				(make sure proper default values are in place in case the
				 corresponding call to read registry values fails -- 
				The are two cases:
				- pConfig->RegAddresses -- this is benign in all cases  (because
					 pConfig->NumAllocedRegdAddresses  is set to 0 on failure),
					 EXCEPT  in ArpSReadAdapterConfiguration, where 
					 PrevRegAddresses is freed if it is non NULL.
					Fix is to initialize pConfig->RegAddresses to NULL before
					 calling NdisReadocnfiguration.
				 - pConfig->pMcsList -- this is not benign.
					Fix is to init it to NULL before calling NdisReadocnfiguration.

04/20/1999 JosephJ Fix for 327626	Need Rouge ARP Server detection on ARP
	registration.

	1st version of fix:
	BEFORE registering address, we try to make a call to the address. If it
	succeeds, we log an event in the event log and fail the initialization.

	2nd version of fix: keep call open -- if we get an incoming close, we
	then try again.

	Note: it's possible that if two notes are doing this at the same time they
	may still both come up, i.e., rogue detection will fail.

05/05/1999  JosephJ 331517 - bugchecks due to wrong VC PacketSize
The bugchk was triggered by the fact that the mars server got several incoming VCs
with very large max packet size (they should all be 9188, but we saw 64008 for
several and 18200 for one).

Fix (in MarsHandleRequest (mars.c)) is to replace SHORT and USHORT local variables
by ULONG.

05/05/1999  JosephJ rogue ARP server detection contd...
	ArpSCoAfRegisterNotify -> ArpSOpenAfComplete ->
		ArpSRegisterSap -> ArpSRegisterSapComplete

ArpSBindAdapter -> ArpSReadAdapterConfiguration -> ArpSQueryAndSetAddresses

	ArpSCoRequestComplete

Configured address (pIntF->ConfiguredAddress) filled by GET OID_CO_GET_ADDRESSES
registered addresses (pIntF->RegAddresses[])

Fri 05/14/1999  JosephJ Rogue ARP server detection contd.
	Things are kicked off on getting a OID_CO_ADDRESS_CHANGE notification.
	We (as before) query the adapter for the configured address.
	On completion of this (OID_CO_GET_ADDRESS), we start the process of validating
 	and registering all addresses, by calling  ArpSValidateAndSetRegdAddresses.

	ArpSValidateAndSetRegdAddresses allocates and initializes pIntF->pRegAddrCtxt
    (which keeps all context associated with the validation and registration of
	addresses). A reference is added to pIntF for pRegAddrCtxt.
	The function then calls ArpSValidateOneRegdAddress. 

	ArpSValidateOneRegdAddress attempts to initiate the validation & registration
	of a single address. If there are no addresses left to be processed, it
	will unlink pIntF->pRegAddrCtxt (deref pIntF and deallocate pRegAddrCtxt).
	"Validation" consists of making a point-to-point to call to the address,
	using the same call params as the atmarp client uses. If the call fails,
	the address is considered "validated". The protocol's context for the VC
	is pRegAddrCtxt itself.

	The next stage happens in the make-call complete handler
	(ArpSMakeRegAddrCallComplete).

	ArpSMakeRegAddrCallComplete:
		- on successful make call (which is a failed validation),
		  it it immediately closes the call. The close call handler
		  (ArpSCloseRegAddrCallComplete) deltes the vc, increments
			pRegAddrCtxt->RegAddrIndex and calls
		  ArpSValidateOneRegdAddress (to initiate the validation & registration
		  of the NEXT address, if any).

		-- On failed make call (which is a successful validation), it deletes the
		  vc and initiates registration of the address (calls NdisRequest with
		  OID_CO_ADD_ADDRESS). On completion of the OID_CO_ADD_ADDRESS
		  (ArpSCoRequestComplete), we do the following:
		  	- on success, copy over the addres to
			 pIntF->RegAddresses[pIntF->NumAddressesRegd] and
			 increment pIntF->NumAddressesRegd ++
		   
		   - on failure or success, we increment pRegAddrCtxt->RegAddrIndex
			 and call ArpSValidateOneRegdAddress (to initiate the validation &
			 registration of the NEXT address, if any).

	A note on the use of pIntF->RegAddresses[...]
	This array is initialized with all the user-specified addresses read from
	the registry. As validation proceeds, however, the successfully validated
	and registered addresses are copied sequentially into this array. If
	*all* the addresses are successfully validated and registered, then the
	end values in the array is the same as the initial values. However, if
	some intermediate addresses are not validated or registered succcessfully,
	then the end result will be different. In all cases,  the first
	pIntF->NumAddressesRegd entries will contain the registered addresses.

09/30/1999  JosephJ Bug 405851
	*RC3SS: ATMARPS: Bugcheck unloading atmarps during shutdown
	The basic problem is that ArpSIfList contains a pointer to a just-freed pIF.
	
	The biggest problem I've found is that  INTF_CLOSING state is set only in the
	ArpSCloseAdapterComplete handler. This means that ArpSStopInterface (which
	calls on ArpSReferenceIntF which *does* check the INTF_CLOSING flag) can be
	called multiple times for the same adapter. Also ArpSReferenceIntF is called
	from some other places. ArpSStopInterface is  called from: ArpSShutDown
	(called from arp's unload handler as WELL as when handling IRP_MJ_SHUTDOWN)
	ArpSCoRequest(AF closing)  and ArpSUnbindAdapter(unbind adapter handler).
	
	ArpSStopInterface is NOT idempotent (it expects to be called only once per pIF),
	but given the above, it CAN becalled multiple times per IF (i.e., because
	INTF_CLOSING is only set on close adapter complete).
	One specific problem with this: it assumes it can use pIntF->CleanupEvent.
	
	Another problem:
	ArpSShutDown: it goes through each IF in ArpSIfList, refs it (which would fail
	if the IF is INTF_CLOSING), release list lock, then calls ArpSStopInterface.
  	It is definately flawed in the way it uses pIF->Next -- pIF->Next could well be
	gone by the time it gets to it. HOWEVER that's not the problem we're seeing
	-- we're seeing the case of the ArpSIfList ITSELF being corrupted.
	
	FIXES:   
	1. arps.c ArpSShutdown now refs the pNext pointer -- a little bit of intricate
	   code that makes sure pNext is still around when we need it. 
	2. We use the INTF_ADAPTER_OPENED flag, set on successful completion of
	   open adapter (in ArpSOpenAdapterComplete). We use this to make sure
	   that NdisCloseAdapter is called only once. NdisCloseAdapter was called
	   in a bunch of places -- now we call ArpSTryCloseAdapter, which checks
	   the INTF_ADAPTER_OPENED flag first.
	3. ArpSStopInterface now doesn't clobber pIntF->CleanupEvent -- if it's
	   NON-NULL it simply doesn't wait.

10/07/1999  JosephJ fix for 412018
	*RC3SS: ATMARPS bugchecks on unloading if no call manager bound to adapter.
	On unloading, we were trying to deregister addresses which had never
	been registered (in fact the AF was never opened). Fix is in 
	DeregisterAllAddresses (ndis.c): it used to check that
	pIntF->NumAllocedRegdAddresses is non-null ; now it checks that
	NumAddressesRegd is non-null.

01/06/2000  JosephJ fix for 416301 corrupt ArpSIfList
	
	
	ArpSOpenAfComplete(ndis.c): we were setting a pInfF flag without holding the IF
	lock (we just had the IF list lock). This was possibly corrupting the other
	bits in the flag field. This is most likely the cause of the problem.
	Also got rid of INTF_IN_LIST field, which is not required.

	ArpSDereferenceIntF(arps.c): Arvindm added code to make sure two threads don't
	try to deref the interface to zero at the same time. This is not likely to
	be the cause of the bug (bug is that the list is corrupted, not that 
	an IF entry was de-allocated prematurely or twice) but is a hole that needs to
	be fixed.
03/30/2000  JosephJ Hit an assert in arps.c when the close-call handler for
    the validation make call (ArpSCloseRegAddrCallComplete) is called during
    shutdown -- we've nuked pIntF->NumAllocedRegdAddresses by this time as 
    part of shutdown, so the following assert in the function fails:
        ASSERT(pRegAddrCtxt->RegAddrIndex < pIntF->NumAllocedRegdAddresses);
    Fix is to bracket this code by  if (!(pIntF->Flags & INTF_STOPPING)).

04/18/2000  JosephJ
    Removed assert  from the code below in  ArpSValidateAndSetRegdAddresses

    if (pIntF->pRegAddrCtxt != NULL)
    {
        ASSERT(FALSE);
        break;
    }

    This could happen if we get an  OID_CO_ADDRESS_CHANGE when we are
    either processing an earlier one, or are in the process of
    initializing. We get this case (and hit the assert) during pnp stress
    ( 1c_reset script against an Olicom 616X) -- Whistler bug#102805
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\arp\kdext\notes.txt ===
4/1/1998 JosephJ
    Yesterday I quite successfully set things up so that the kd extensions could
    be tested as a simple console app. The code in main.c emulates kd from
    the point of view of the extension dll. It works remarkably well.
    The memory read/write operations simply read/write memory.

    I don't know how kd decides which operations are exported by the dll --
    does it simply try to do a getprocaddress for anything the user types
    in?

4/1/1998 JosephJ

    Plan of action:
    1. Write code which hex-dumps all the fields of the ARPC_GLOBALS structure.
    2. Fill out the ARPC_CLOBALS description structures.
    3. Write basic command parser.
    4. Add commands to dump globals 

    // !aac ? d
    // !aac help

!aac dr <type> <address> . <field> L <count> <flags>
!aac dr <type> [index] . <field>   L <count> <flags>
!aac dg <name> . <field>

!aac dr if[*].*handle*

01234444: ARPC_INTERFACE[0]
09890000: [32]  .NDISHandle = 02349880
09890000: [36]  .IFHandle   = 02349880

01234444: ARPC_INTERFACE[1]
09890000: [32]  .NDISHandle = 02349880
09890000: [36]  .IFHandle   = 02349880

01234444: ARPC_INTERFACE[2]
09890000: [32]  .NDISHandle = 02349880
09890000: [36]  .IFHandle   = 02349880

4/8/1998 JosephJ
tok_try_force_to_ident(BOOL fPrefixStart, TOKEN *pTok)
//
// This gets called when an identifier is expected -- so we see if this
// particular token can be interpreted as in identifier. Some examples
// of when we can do this:
//  dt if.*20334     <--- the "20334" could be part of an identifier, because
//                        of the * prefix.
//
//  dt L.help        <--- both "L" and "help" would have been parsed as
//                        keywords, but here they are intended to be
//                        identifiers.
//  dt abc.def       <--- abc and def would have been parsed as numbers (they
//                        are valid hex numbers), but are intended to be
//                        identifiers.

4/26/1998 JosephJ
	Change command structure:
		!aac i		<--- dumps atmarpc interface structure
		!ndis mpb	<--- dumps ndis NDIS_MINIPORT_BLOCK structure
		!ndis mpb	<--- dumps ndis M_DRIVER_BLOCK structure
	Variations:
		!acc i 0xf00998009 <-- dump interface at this address
		!aac i			   <-- dump interface at last cached interface address,
								if there is one, else dump list of all interface
								pointers.
		!aac i[*]	<--- list of all interfaces (if it makes sense)
		!aac i[2]	<--- dump 3rd (zerobased) interface
		!aac i.*list*	<-- as before.

	List walking support...
		WalkList(
			TYPE_INFO *pType,
			UINT_PTR uStartAddress,
			UINT uNextOffset,
			UINT uStartIndex,
			UINT uEndIndex,
			DBGCMD *pCmd,
			NODEFUNC pFunc
			);
		The above function will visit each node in the list in turn,
		reading just the next pointers. It calls pFunc for each list node
		between uStartIndex and uEndIndex. It terminates under the first of
		the following conditions:
			* Null pointer
			* ReadMemoryError
			* Read past uEndIndex
			* pFunc returns FALSE

5/7/1998 To Do
	Support following:
	a	 -- last-specified adapter
	i	 -- last-specified interface
	a[*] -- adapter list
	i[*] -- interface list


	DoCommand -- makeing it more flexable:
	Add TypeProc to TYPE_INFO: generic func to handle customization:
		-- print summary information
	Add ResolveAddress function to DoCommand
		-- resolve address
	Add UINT_PTR uLastPtr -- cache of last address used with this type.

5/31/1998 JosephJ Support for dumping flags

	typedef struct
	{
		UINT Mask;
		UINT Value;
		char *szName;

	} FLAGINFO;

	FLAGINFO rgFlagInfo[] =
	{
	{AA_IPMC_AE_GEN_STATE_MASK, AA_IPMC_AE_VALID, "AA_IPMC_AE_VALID"},
	{AA_IPMC_AE_GEN_STATE_MASK, AA_IPMC_AE_INVALID, "AA_IPMC_AE_INVALID"},
	{AA_IPMC_AE_GEN_STATE_MASK, AA_IPMC_AE_TERMINATING,
												"AA_IPMC_AE_TERMINATING"},
	{AA_IPMC_AE_CONN_STATE_MASK, AA_IPMC_AE_CONN_DISCONNECTED,
											 	"AA_IPMC_AE_CONN_DISCONNECTED"}
	{0,0,NULL} // must be last.
	};

	DumpFlags(dwFlags, rgFlagInfo)
	{
		FLAGIONFO *pFI = rgFlagInfo;
		for(;pFI->szName; pFI++)
		{
			if ((dwFlags & pFI->Mask) == pFI->Value)
			{
				DbgPrintf(" szName");
			}
		}
		DbgPrintf("\n");
	}

	Above scheme can deal with traditional enums and 1-bit flags as well.

6/1/1998 JosephJ Perl script
	
	.h + annotations -> intermediate_form -> source
	annotations == allow special cases, so that the generated source
	does not have to be modified by hand. This allows easy updating.

	generating code to dump flags:
		annotation file identifies flag types:
		(default mask = 
			flag
			{
				{MASK
			}

Automatic conversion for:
	* enum
	* Flags matching a regex pattern: eg
		AA_IPMC_AE_*

	flag: type=enum/macro
		enum {enum_name};
		macroflag{mask, flag_pattern}

7/9/1998 JosephJ

	Generic list dumping syntax
	!aac void {1-3@45}.$b25@52 21343434
	  Dumps a 25-byte section at offset 0x52, for list elements 1 to 3. The
	  next pointer is at offset 0x45. Starting address is 21343434.

	So:
		$bnnn means nnn bytes
		@xxx means byte offset xxx
		$bnnn@xxx  means nnn butes at byte offset xxx

	Other $ global type definitions:
	$sz null terminated string
	$szz multisz stringox
	$wsz unicode null terminated string
	$s35 35-byte long ansi string
	$ws35 35-char long unicode string
	$dw35  35 dwords
	$w35  35 16-bit words
	$pv	  pointer


Some examples ...
!aac a		     -- dumps the most recently referenced adapter (1st time, it will dump the 1st adapter in the global adapter list).
!aac a 0x80001092  -- dumps the adapter at the specified address.
!aac i	                 -- dumps the most recently referenced interface (1st time, it will dump the 1st interface of the 1st adapter).
!aac i.*list*	     -- dumps all fields of the most recently referenced interface stucture which match the pattern "*list*"
!aac ae[*].RefCount -- dumps the ip addreses of all the atm entries of the most recently referenced interface (yes, you can substitute any field name or pattern like "*Ref*"  for "RefCount").
!aac ip[*].IPAddress -- dumps the ref counts of all the ip address of the most recently reference atm entry.
!aac ip[1]                -- dumps the next ip structure in the list of ip structures for an atm entry (so you can step through the list items by successively calling !aac ip[1]).
!aac vc[*]	     -- dumps the vc list for the most recently referenced atm entry.
The dumping formats are terrible -- I'll clean it up and provide more type-friendly output format over time.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\epvc\sys\notes.txt ===
8/14/00
When the Protocol's Reconfigure handler is called, the protocol will be in one 
of two condtions - Its binding to the adapter below is open or the binding is 
closed.

if the blinding is closed, then the protocol will call NdisReEnumerate Bindings
and this will restart the Binding  and re-instantiate the miniports.

If the binding is open, then the miniport will walk through the registry and 
Initialize All Device Instances that have been disabled.

I noticed that when the last miniport is disabled, the driver gets unloaded 
causing the protocol to be unbound from the adapter.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\dbgext\readme.txt ===
README file for sample WINDBG (old stlye) extension simple.dll


This extsnsion dll shows how to write a simple extension and demostrates use of APIs in wdbgexts.h


Mandatory routines which must be implemented and exported for windbg style extensions:
VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )

This is called on loading extension dll. Global variables and flags for extension should be initialized in this routine. One 
of the useful things to initialize is WINDBG_WNTENSION_APIS which has some commonly used APIS for memory reads and I/O.



LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
This tells debugger about version of the extension dll. The values returned by this will determine how extension of this
dll will be called. A common error while writing extensions is mismatched values of version returned be this routine as 
compared to what version dll was built with.

This has ApiVersion = { (VER_PRODUCTVERSION_W >> 8), 
                   (VER_PRODUCTVERSION_W & 0xff), 
                   EXT_API_VERSION_NUMBER64, 
                    0 };


VOID
CheckVersion(
    VOID
    )
This is called after the dll is loaded by the debugger. The extension dll can verify here if it was loaded for correct target.




Extension Calls
---------------

EXT_API_VERSION_NUMBER64 is needed for making 64-bit aware extensions, all addresses for these will then be ULONG64s, for this
an extension is defined as:
CPPMOD VOID 
extension(
        HANDLE                 hCurrentProcess,
        HANDLE                 hCurrentThread,
        ULONG64                dwCurrentPc,
        ULONG                  dwProcessor,
        PCSTR                  args
     )


Extensions
----------


help

Every extension dll should have one extension called 'help' which shows descriptions for extensions that are present in the dll.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\netcfg.ini ===
[DebugFlags]
BreakOnAddLegacy=0
BreakOnAlloc=0
BreakOnDoUnattend=0
BreakOnDwrefProblem=0
BreakOnError=0
BreakOnHr=0
BreakOnHrInteration=0
BreakOnIteration=0
BreakOnNetInstall=0
BreakOnWizard=0
DisableTray=0
DumpLeaks=1
DumpNetCfgTree=0
NetShellBreakOnInit=0
ShowIgnoredErrors=0
ShowProcessAndThreadIds=1
SkipLanEnum=0
TracingTimeStamps=0

[Default]
OutputToDebug=1

[EsLocks]
OutputToDebug=0

[ShellViewMsgs]
OutputToDebug=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\dhcpscfg\infnotes.txt ===
// None yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netaarps.txt ===
[strings]
V_MS="Microsoft"

V_CLASSNAME="Network Protocol"
ATMARPS.DeviceDesc="ATM ARP/MARS Service"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netacs.txt ===
[Strings]
Msft = "Microsoft"

ACS_Desc          = "QoS Admission Control Service"
ACS_HELP          = "Qos Admission Control Service"
ACS_Admin_Group	  = "Administrative Tools"
ACS_Admin_HelpTxt = "Manages the Quality of Service (QoS) Admissions Control service, which provides end-to-end resource and bandwidth management for network traffic."
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netatlk.txt ===
[Strings]
Msft = "Microsoft"
NetATLK_Desc = "AppleTalk Protocol"
ATLK_PNT_MON_Desc = "AppleTalk Print Monitor"
ATLK_PNT_MON_Name = "AppleTalk Printing Devices"
SERVICE_DEMAND_START = 2
SERVICE_WIN32_SHARE_PROCESS = 1
REG_EXPAND_SZ = 0x20000
REG_DWORD = 0x10001
REG_MULTI_SZ = 0x10000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netauni.txt ===
;****************************************************************************
; Localizable Strings
;****************************************************************************
[strings]
V_MS="Microsoft"
V_CLASSNAME="Network Protocol"
ATMUNI.DeviceDesc="ATM Call Manager"

; AddReg flags
FLG_ADDREG_TYPE_EXPAND_SZ   = 0x00020000
FLG_ADDREG_TYPE_MULTI_SZ    = 0x00010000
FLG_ADDREG_TYPE_DWORD       = 0x00010001
FLG_ADDREG_KEYONLY          = 0x00000010
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netcis.txt ===
[Strings]
Msft = "Microsoft"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netdhcpr.txt ===
[Strings]
Msft = "Microsoft"
RelayAgent_Desc = "DHCP Relay Agent"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netdhoc.txt ===
[Strings]
Msft            = "Microsoft"
DHCPServer_Desc = "Microsoft DHCP Server"
DHCPServer_Help = "Automatically assigns IP addresses to other computers running the DHCP (Dynamic Host Configuration Protocol) Client Service."
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netdhcps.txt ===
[Strings]
Msft                        = "Microsoft"
DHCPServer_SCM_Display      = "DHCP Server"
DHCPServer_SCM_Desc         = "Provides dynamic IP address assignment and network configuration for Dynamic Host Configuration Protocol (DHCP) clients."
DHCPServer_Help             = "Automatically assigns IP addresses to other computers running the DHCP (Dynamic Host Configuration Protocol) Client Service."

; Shortcuts
DHCPServer_Admin_SC_Desc            = "DHCP"
DHCPServer_Admin_SC_Group_Name      = "Administrative Tools"
DHCPServer_Admin_SC_HelpText        = "Use DHCP to configure and manage the Dynamic Host Configuration Protocol (DHCP) service."

; Note to localizers: Please make sure this is the same description used in NT 4.0
DHCPServer_Old_Admin_Sc_Desc        = "DHCP Manager"
DHCPServer_Old_Admin_Sc_Group_Name  = "Administrative Tools"

; Note to localizers: Please make sure this is the same description used in NT 3.51
DHCPServer_Really_Old_Admin_Sc_Desc        = "DHCP Manager"
DHCPServer_Really_Old_Admin_Sc_Group_Name  = "Network Administration"

; ServiceType values
SERVICE_KERNEL_DRIVER               = 0x00000001
SERVICE_FILE_SYSTEM_DRIVER          = 0x00000002
SERVICE_ADAPTER                     = 0x00000004
SERVICE_RECOGNIZER_DRIVER           = 0x00000008
SERVICE_WIN32_OWN_PROCESS           = 0x00000010
SERVICE_WIN32_SHARE_PROCESS         = 0x00000020
SERVICE_INTERACTIVE_PROCESS         = 0x00000100
SERVICE_INTERACTIVE_SHARE_PROCESS   = 0x00000120

; Some standard defines
REG_MULTI_SZ                = 0x10000
REG_EXPAND_SZ               = 0x20000
REG_DWORD                   = 0x10001
REG_BIN                     = 0x00001
REG_NOCLOBBER               = 0x00020
REG_MULTI_SZ_NOCLOBBER      = 0x10020
REG_EXPAND_SZ_NOCLOBBER     = 0x20020
REG_DWORD_NOCLOBBER         = 0x10021
REG_BIN_NOCLOBBER           = 0x00021
FLG_ADDREG_KEYONLY          = 0x0010

; StartType values
SERVICE_BOOT_START          = 0x00000000
SERVICE_SYSTEM_START        = 0x00000001
SERVICE_AUTO_START          = 0x00000002
SERVICE_DEMAND_START        = 0x00000003
SERVICE_DISABLED            = 0x00000004

; ErrorControl values
SERVICE_ERROR_IGNORE        = 0x00000000
SERVICE_ERROR_NORMAL        = 0x00000001
SERVICE_ERROR_SEVERE        = 0x00000002
SERVICE_ERROR_CRITICAL      = 0x00000003

; Characteristic flags
NCF_VIRTUAL                 = 0x0001
NCF_WRAPPER                 = 0x0002
NCF_PHYSICAL                = 0x0004
NCF_HIDDEN                  = 0x0008
NCF_NO_SERVICE              = 0x0010
NCF_NOT_USER_REMOVABLE      = 0x0020
NCF_HAS_UI                  = 0x0080
NCF_MODEM                   = 0x0100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netcm.txt ===
[Strings]
; CMAK Strings
;; Localizable Strings
Msft			= "Microsoft"
AdminTools		= "Administrative Tools"
OLDDOCDIR               = "Docs" ; must be the same as IEAK4 doc dir name
PhoneName               = "Phone Book"
RegionName              = "Region File"
CMAK_DESC 		= "Connection Manager Administration Kit" ; link name


;; NON - Localizable Strings
CMAppName		= "Connection Manager Administration Kit" ; registry keyname
CMHELP_DIR		= "CMHelp"
CMREGROOT		= "Software\Microsoft\Connection Manager Administration Kit"
CMAppPath		= "SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\cmak.exe"
RegUninstPath           = "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\CMAK"

; PBS Strings
;; NON - Localizable Strings
KEY_NAME_DSN_Name	= "PBServer"
KEY_ODBC_ROOT_Name	= "SOFTWARE\ODBC\ODBC.INI\PBServer"
KEY_ODBC_ROOT_Data	= "SOFTWARE\ODBC\ODBC.INI\PBServer\Engines\Jet"
KEY_NAME_ACCESS_DRIVER	= "ODBCJT32.DLL"
APP_PATH_SERVER		= "Phone Book Service"
KEY_EVENTS		= "System\CurrentControlSet\Services\EventLog\Application\Phone Book Service"
KEY_CPSMON_ROOT		= "SYSTEM\CurrentControlSet\Services\PBServerMonitor"
KEY_CPSMON_PERF		= "SYSTEM\CurrentControlSet\Services\PBServerMonitor\Performance"
DB_PATH_SERVER		= "Data\Database"
REG_MULTI_SZ		= 0x10000
REG_EXPAND_SZ		= 0x20000
REG_DWORD		= 0x10001
REG_SZ			= 1
;; Localizable Strings
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netdlc.txt ===
[Strings]
Msft = "Microsoft"
HP_PORTMON = "Hewlett-Packard Network Port"

DLC_Desc = "DLC Protocol"

FLG_ADDREG_KEYONLY=0x00000010
REG_MULTI_SZ = 0x10000
REG_DWORD = 0x10001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netias.txt ===
[Strings]
Msft = "Microsoft"
IAS_Display = "Internet Authentication Service"
IAS_Desc = "Enables authentication, authorization and accounting of dial-up and VPN users. IAS supports the RADIUS protocol."
Snapin-Group-Name = "Administrative Tools"
IAS_Shortcut_Display = "Internet Authentication Service"

REG_MULTI_SZ  = 0x10000
REG_EXPAND_SZ = 0x20000
REG_DWORD     = 0x10001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netiprip.txt ===
[Strings]
Msft = "Microsoft"

Iprip_Desc = "Listens for route updates sent by routers that use the Routing Information Protocol version 1 (RIPv1)."
Iprip_Display = "RIP Listener"
Iprip_HELP = "This service listens for IP route updates and adds them to the local routing table.  (Also known as RIP for IP)"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netgpc.txt ===
[Strings]
Msft = "Microsoft"

GPC_Desc = "Generic Packet Classifier"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netirda.txt ===
[Strings]
;-----------------------------------------------------
Msft                    = "Microsoft"
IrDA.DisplayName        = "IrDA Protocol"
IrDA.HelpText           = "Infrared Data Association Protocol. Easy to use self configuring point-to-point connectivity without wires"
Irmon.Description       = "Supports infrared devices installed on the computer and detects other devices that are in range."
Irmon.DisplayName       = "Infrared Monitor"
REG_MULTI_SZ            = 0x10000
FLG_ADDREG_TYPE_DWORD   = 0x00010001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netlanep.txt ===
[Strings]
Msft = "Microsoft"

ATMLANE_Desc = "ATM LAN Emulation"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netlanem.txt ===
[Strings]
Msft = "Microsoft"

ATMELAN_Desc = "ATM Emulated LAN"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netdns.txt ===
[Strings]
Msft = "Microsoft"

DNSServer_Display = "DNS Server"
DNSServer_Desc = "Answers query and update requests for Domain Name System (DNS) names."

; Service names
DNS_Desc = "Microsoft DNS Server"
DNS_Admin_Group = "Administrative Tools"
DNSServer_HELP = "The Domain Name System maps DNS domain names to IP addresses."

; Note to localizers: This string must be the same as the one from NT4.
DNS_Admin_Tool_Old = "DNS Manager"
DNS_Admin_Group_Old = "Administrative Tools"
DNS_Shortcut_Desc = "DNS"
DNS_EXTENSION = "DNS Extension"
DNS_Admin_HelpText = "Manages the Domain Name System (DNS) service, which translates DNS computer names to IP addresses."

REG_MULTI_SZ = 0x10000
REG_EXPAND_SZ = 0x20000
REG_DWORD = 0x10001
SERVICE_DEMAND_START = 3
SERVICE_AUTO_START = 2
SERVICE_WIN32_SHARE_PROCESS = 32
SERVICE_FILE_SYSTEM_DRIVER = 2
SERVICE_WIN32_OWN_PROCESS = 16

; Characteristic flags
NCF_VIRTUAL                 = 0x0001
NCF_WRAPPER                 = 0x0002
NCF_PHYSICAL                = 0x0004
NCF_HIDDEN                  = 0x0008
NCF_NO_SERVICE              = 0x0010
NCF_NOT_USER_REMOVABLE      = 0x0020
NCF_HAS_UI                  = 0x0080
NCF_MODEM                   = 0x0100

KEY_OPTIONAL            = "SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netlpd.txt ===
[Strings]
Msft                        = "Microsoft"

LPDSVC_Display              = "TCP/IP Print Server"
LPDSVC_Desc                 = "Provides a TCP/IP-based printing service that uses the Line Printer protocol."
LPDSVC_HELP                 = "Enables Windows to print to TCP/IP-connected printers or to printers that are physically attached to UNIX computers."

; ServiceType values
SERVICE_KERNEL_DRIVER       = 0x00000001
SERVICE_FILE_SYSTEM_DRIVER  = 0x00000002
SERVICE_ADAPTER             = 0x00000004
SERVICE_RECOGNIZER_DRIVER   = 0x00000008
SERVICE_WIN32_OWN_PROCESS   = 0x00000010
SERVICE_WIN32_SHARE_PROCESS = 0x00000020
SERVICE_INTERACTIVE_PROCESS = 0x00000100
SERVICE_INTERACTIVE_SHARE_PROCESS = 0x00000120

; StartType values
SERVICE_BOOT_START          = 0x00000000
SERVICE_SYSTEM_START        = 0x00000001
SERVICE_AUTO_START          = 0x00000002
SERVICE_DEMAND_START        = 0x00000003
SERVICE_DISABLED            = 0x00000004

; ErrorControl values
SERVICE_ERROR_IGNORE        = 0x00000000
SERVICE_ERROR_NORMAL        = 0x00000001
SERVICE_ERROR_SEVERE        = 0x00000002
SERVICE_ERROR_CRITICAL      = 0x00000003

; Registry types
REG_MULTI_SZ                = 0x10000
REG_EXPAND_SZ               = 0x20000
REG_DWORD                   = 0x10001
FLG_ADDREG_KEYONLY          = 0x00000010
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netmacsv.txt ===
[Strings]
Msft = "Microsoft"

MACSRV_DESC     = "SFM Kernel Driver"
MacFile_Display = "File Server for Macintosh"
MacFile_Desc    = "Enables Macintosh users to store and access files on this Windows server machine."

MICROSOFT_UAM_VOLUME = "Microsoft UAM Volume"

FLG_ADDREG_KEYONLY = 0x0010
REG_MULTI_SZ = 0x10000
REG_MULTI_SZ_NOCLOBBER = 0x10002
REG_MULTI_SZ_APPEND = 0x1000A
REG_MULTI_SZ_DELVAL = 0x10006
REG_EXPAND_SZ = 0x20000
REG_DWORD = 0x10001
REG_DWORD_NOCLOBBER = 0x10003
SERVICE_DEMAND_START = 3
SERVICE_AUTO_START = 2
SERVICE_WIN32_SHARE_PROCESS = 32
SERVICE_FILE_SYSTEM_DRIVER = 2
SERVICE_WIN32_OWN_PROCESS = 16

XCEL1COMMENT   = "Comment=MS Excel 3.0 Chart"
XCEL2COMMENT   = "Comment=MS Excel 3.0 Spreadsheet"
XCEL3COMMENT   = "Comment=MS Excel 3.0 Macrosheet"
XCEL4COMMENT   = "Comment=MS Excel 3.0 Workspace"
XCEL5COMMENT   = "Comment=MS Excel 3.0 Add-in MacroFile"
XCEL6COMMENT   = "Comment=MS Excel 3.0 Template File"
XCEL7COMMENT   = "Comment=MS Excel 3.0"
XCEL8COMMENT   = "Comment=MS Excel 4.0 Chart"
XCEL9COMMENT   = "Comment=MS Excel 4.0 Spreadsheet"
XCEL10COMMENT  = "Comment=MS Excel 4.0 Macrosheet"
XCEL11COMMENT  = "Comment=MS Excel 4.0 WorkSpace"
XCEL12COMMENT  = "Comment=MS Excel 4.0 Add-in MacroFile"
XCEL13COMMENT  = "Comment=MS Excel 4.0 Template File"
MSWD1COMMENT   = "Comment=MS Word 5.1 Document"
MSWD2COMMENT   = "Comment=MS Word 5.1 Document"
MSWD3COMMENT   = "Comment=MS Word 6.0 Document"
MSWD4COMMENT   = "Comment=MS Word 6.0 Template"
MSPJ1COMMENT   = "Comment=MS Project 4.0"
MSPJ2COMMENT   = "Comment=MS Project 4.0 Exchange File"
MSPJ3COMMENT   = "Comment=MS Project 4.0 Calendar"
MSPJ4COMMENT   = "Comment=MS Project 4.0 View"
MSPJ5COMMENT   = "Comment=MS Project 4.0 WorkSpace"
MSPJ6COMMENT   = "Comment=MS Project 4.0 Template"
ALD31COMMENT   = "Comment=Pagemaker 3.0  Publication"
ALD32COMMENT   = "Comment=Pagemaker 3.0 Template"
ALD33COMMENT   = "Comment=Pagemaker 3.0 Tiff Graphics"
ALD41COMMENT   = "Comment=Pagemaker 4.0 Publication"
ALD42COMMENT   = "Comment=Pagemaker 4.0 Template"
ALD43COMMENT   = "Comment=Pagemaker 4.0 Tiff Graphics"
MORECOMMENT    = "Comment=Symantec More File"
FOXCOMMENT    = "Comment=FoxBase Plus"
ARTZCOMMENT    = "Comment=Adobe Illustrator"
SITCOMMENT    = "Comment=Aladdin Stuffit"
PPT2COMMENT    = "Comment=MS PowerPoint 2.0"
PPT3COMMENT    = "Comment=MS PowerPoint 3.0"
L123COMMENT    = "Comment=Lotus 1-2-3"
LMANCOMMENT    = "Comment=LMAN Executables"
TTXTCOMMENT    = "Comment=Teach Text Document"
FOXX1COMMENT   = "Comment=FoxPro 2.0 Table"
FOXX2COMMENT   = "Comment=FoxPro 2.0 Memo"
FOXX3COMMENT   = "Comment=FoxPro 2.0 Index"
FOXX4COMMENT   = "Comment=FoxPro 2.0 Compound Index"
FOXX5COMMENT   = "Comment=FoxPro 2.0 Program"
FOXX6COMMENT   = "Comment=FoxPro 2.0 Report"
FOXX7COMMENT   = "Comment=FoxPro 2.0 Report Memo"
FOXX8COMMENT   = "Comment=FoxPro 2.0 Label"
FOXX9COMMENT   = "Comment=FoxPro 2.0 Label Memo"
FOXX10COMMENT   = "Comment=FoxPro 2.0 Screen"
FOXX11COMMENT   = "Comment=FoxPro 2.0 Screen Memo"
FOXX12COMMENT   = "Comment=FoxPro 2.0 Menu"
FOXX13COMMENT   = "Comment=FoxPro 2.0 Menu Memo"
FOXX14COMMENT   = "Comment=FoxPro 2.0 Gen. Query Program"
FOXX15COMMENT   = "Comment=FoxPro 2.0 Project"
FOXX16COMMENT   = "Comment=FoxPro 2.0 Project Memo"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netnb.txt ===
[Strings]
Msft = "Microsoft"

; Service names
NetBIOS_Desc = "NetBIOS Interface"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netmacpr.txt ===
[Strings]
Msft = "Microsoft"

MacPrint_Help    = "Enables Macintosh users to print to any printer connected to the computer running Windows Server and to spool print jobs for AppleTalk printers such as the LaserWriter."
MacPrint_Desc    = "Enables Macintosh users to send print jobs to a spooler on a server running Windows XP."
MacPrint_Display = "Print Server for Macintosh"

FLG_ADDREG_KEYONLY = 0x0010
REG_MULTI_SZ = 0x10000
REG_EXPAND_SZ = 0x20000
REG_DWORD = 0x10001
SERVICE_DEMAND_START = 3
SERVICE_AUTO_START = 2
SERVICE_WIN32_SHARE_PROCESS = 32
SERVICE_FILE_SYSTEM_DRIVER = 2
SERVICE_WIN32_OWN_PROCESS = 16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netmscli.txt ===
[Strings]
Msft = "Microsoft"

MSClient_Desc = "Client for Microsoft Networks"

; Service names
Alerter_Display = "Alerter"
Alerter_Desc = "Notifies selected users and computers of administrative alerts. If the service is stopped, programs that use administrative alerts will not receive them. If this service is disabled, any services that explicitly depend on it will fail to start."
Browser_Display = "Computer Browser"
Browser_Desc = "Maintains an updated list of computers on the network and supplies this list to computers designated as browsers. If this service is stopped, this list will not be updated or maintained. If this service is disabled, any services that explicitly depend on it will fail to start."
LanmanWorkstation_Display = "Workstation"
LanmanWorkstation_Desc = "Creates and maintains client network connections to remote servers. If this service is stopped, these connections will be unavailable. If this service is disabled, any services that explicitly depend on it will fail to start."
NetLogon_Display = "Net Logon"
NetLogon_Desc = "Supports pass-through authentication of account logon events for computers in a domain."
Messenger_Display = "Messenger"
Messenger_Desc = "Transmits net send and Alerter service messages between clients and servers. This service is not related to Windows Messenger. If this service is stopped, Alerter messages will not be transmitted. If this service is disabled, any services that explicitly depend on it will fail to start."
Rdr_Desc = "MRXSMB"
Rdbss_Desc = "Rdbss"
RpcLocator_Display = "Remote Procedure Call (RPC) Locator"
RpcLocator_Desc = "Manages the RPC name service database."
NtLmSsp_Display = "NT LM Security Support Provider"
NtLmSsp_Desc = "Provides security to remote procedure call (RPC) programs that use transports other than named pipes."

NetproviderName = "Microsoft Windows Network"
LanmanPrintProvider = "LanMan Print Services"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netnwcli.txt ===
[Strings]
Msft = "Microsoft"

NWC_Install_Display_Name = "Client Service for NetWare"
NWC_Service_Display_Name = "Client Service for NetWare"
NWC_Service_Description  = "Provides access to file and print resources on NetWare networks."

NWC_Network_Display_Name    = "NetWare or Compatible Network"
NWRDR_Service_Display_Name  = "NetWare Rdr"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netnbf.txt ===
[Strings]
Msft = "Microsoft"
NetBEUI_Desc = "NetBEUI Protocol"

REG_DWORD = 0x10001
REG_MULTI_SZ = 0x10000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netnwlnk.txt ===
[Strings]
Msft = "Microsoft"

NwlnkIpx_Desc = "NWLink IPX/SPX/NetBIOS Compatible Transport Protocol"
NwlnkNb_Desc  = "NWLink NetBIOS"
NwlnkSpx_Desc = "NWLink SPX/SPXII Protocol"

NwlnkSpx_HelpText = ""
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netrasa.txt ===
[Strings]
Msft = "Microsoft"

Mp-AsyncMac-DispName        = "RAS Async Adapter"
Mp-L2tp-DispName            = "WAN Miniport (L2TP)"
Mp-Irda-DispName            = "Infrared Port"
Mp-IrModem-DispName         = "Infrared Modem Port"
Mp-Irda-LineName            = "Infrared Direct Line"
Mp-IrModem-LineName         = "Infrared Modem Line"
Mp-Pptp-DispName            = "WAN Miniport (PPTP)"
Mp-Pptp-LineName            = "RAS VPN Line"
;Mp-Pptp-LineName must use ANSI characters, not UNICODE.
Mp-Pti-DispName             = "Direct Parallel"
Mp-Atalk-DispName           = "WAN Miniport (AppleTalk)"
Mp-Bh-DispName              = "WAN Miniport (Network Monitor)"
Mp-Ip-DispName              = "WAN Miniport (IP)"
Mp-Ipx-DispName             = "WAN Miniport (IPX)"
Mp-NbfIn-DispName           = "WAN Miniport (NetBEUI, Dial In)"
Mp-NbfOut-DispName          = "WAN Miniport (NetBEUI, Dial Out)"
Mp-Pppoe-DispName           = "WAN Miniport (PPPOE)"
Mp-Pppoe-LineName           = "RAS PPPOE Line"

Svc-Mp-AsyncMac-DispName    = "RAS Asynchronous Media Driver"
Svc-Mp-L2tp-DispName        = "WAN Miniport (L2TP)"
Svc-Mp-Irda-DispName        = "WAN Miniport (IrDA)"
Svc-Mp-IrModem-DispName     = "WAN Miniport (IrDA Modem)"
Svc-Mp-Pptp-DispName        = "WAN Miniport (PPTP)"
Svc-Mp-Pti-DispName         = "Direct Parallel"
Svc-NdisTapi-DispName       = "Remote Access NDIS TAPI Driver"
Svc-NdisWan-DispName        = "Remote Access NDIS WAN Driver"
Svc-PptpProtocol-DispName   = "PPTP Protocol Driver"
Svc-Ptilink-DispName        = "Direct Parallel Link Driver"
Svc-WanArp-DispName         = "Remote Access IP ARP Driver"
Svc-Mp-Pppoe-DispName       = "Remote Access PPPOE Driver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netrsvp.txt ===
[Strings]
Msft = "Microsoft"

RSVP_Display = "QoS RSVP"
RSVP_HELP = "The RSVP protocol is used to provide reserved bandwidth through the network."
RSVP_Desc = "Provides network signaling and local traffic control setup functionality for QoS-aware programs and control applets."
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netrast.txt ===
[Strings]
Msft = "Microsoft"

L2tp-DispName               = "Layer 2 Tunneling Protocol"
L2tp-HelpText               = "Allows you to securely connect to a private network using the Internet."
NdisWan-DispName            = "Remote Access NDIS WAN Driver"
Pptp-DispName               = "Point to Point Tunneling Protocol"
Pptp-HelpText               = "Allows you to securely connect to a private network using the Internet."
Wanarp-DispName             = "Remote Access IP ARP Driver"
Pppoe-DispName              = "Point to Point Protocol Over Ethernet"
Pppoe-HelpText              = "Provides the abilitiy to connect a host to a Remote Access Concentrator that supports RFC2516."

Svc-NdisTapi-DispName       = "Remote Access NDIS TAPI Driver"
Svc-NdisWan-DispName        = "Remote Access NDIS WAN Driver"
Svc-PppoeProtocol-DispName  = "Remote Access PPPOE Driver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netpsa.txt ===
[Strings]
Msft = "Microsoft"

PSched_Desc   = "QoS Packet Scheduler"
PSchedMP_Desc = "Packet Scheduler Miniport"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netpschd.txt ===
[Strings]
Msft = "Microsoft"

PSched_Desc = "QoS Packet Scheduler"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netrwan.txt ===
;****************************************************************************
; Localizable Strings
;****************************************************************************
[strings]
V_MS="Microsoft"
V_CLASSNAME="Network Protocol"
RAWWAN.DeviceDesc="RAW WAN Driver"
RAWWAN_HELP="The RAW WAN driver provides TDI access to connection oriented network media."

; AddReg flags
FLG_ADDREG_TYPE_EXPAND_SZ   = 0x00020000
FLG_ADDREG_TYPE_MULTI_SZ    = 0x00010000
FLG_ADDREG_TYPE_DWORD       = 0x00010001
FLG_ADDREG_KEYONLY          = 0x00000010
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netoc.txt ===
[Strings]
NetOC_DESC              = "Management and Monitoring Tools"
NetOC_TIP               = "Includes tools for monitoring and improving network performance."

NetServices_DESC        = "Networking Services"
NetServices_TIP         = "Contains a variety of specialized, network-related services and protocols."

FileAndPrint_DESC       = "Other Network File and Print Services"
FileAndPrint_TIP        = "Shares files and printers on this computer with others on the network."

SNMP_Desc               = "Simple Network Management Protocol"
SNMP_HELP               = "Includes agents that monitor the activity in network devices and report to the network console workstation."

WBEMSNMP_DESC           = "WMI SNMP Provider"
WBEMSNMP_TIP            = "Allows client applications to access static and dynamic SNMP information through Windows Management Instrumentation (WMI)."

UPNP_Desc               = "Universal Plug and Play"
UPNP_HELP               = "Allows your computer to discover and control Universal Plug and Play devices."

BEACON_Desc             = "Internet Gateway Device Discovery and Control Client"
BEACON_HELP             = "Allows you to find and control Internet connection sharing hardware and software that uses Universal Plug and Play."

WINS_Desc               = "Windows Internet Name Service (WINS)"
WINS_HELP               = "Sets up a WINS server that registers and resolves NetBIOS names for clients."

DNSServer_Desc          = "Domain Name System (DNS)"
DNSServer_HELP          = "Sets up a DNS server that answers query and update requests for DNS names."

DHCPServer_Desc         = "Dynamic Host Configuration Protocol (DHCP)"
DHCPServer_HELP         = "Sets up a DHCP server that automatically assigns temporary IP addresses to client computers on the same network."

MACSRV_DESC             = "File Services for Macintosh"
MACSRV_HELP             = "Enables Macintosh users to both store and gain access to files on a server running Microsoft Windows XP."

MacPrint_Desc           = "Print Services for Macintosh"
MacPrint_Help           = "Enables Macintosh users to send jobs to a print spooler on a server running Microsoft Windows XP."

SimpTcp_Desc            = "Simple TCP/IP Services"
SimpTcp_HELP            = "Supports the following TCP/IP services: Character Generator, Daytime, Discard, Echo, and Quote of the Day."

NETMONTOOLS_Desc        = "Network Monitor Tools"
NETMONTOOLS_HELP        = "Analyzes and troubleshoots packets of data transferred over the network."

LPDSVC_Desc             = "Print Services for Unix"
LPDSVC_HELP             = "Enables UNIX clients to print to any printer available to this computer."

Iprip_Desc              = "RIP Listener"
Iprip_HELP              = "Listens for route updates sent by routers that use the Routing Information Protocol version 1 (RIPv1)."

ACS_Desc                = "QoS Admission Control Service"
ACS_HELP                = "Allows you to specify the quality of the network connection for each subnet."

NETCM_DESC              = "Connection Manager Components"
NETCM_TIP               = "Installs Connection Manager Administration Kit and the Phone Book Service."

IASServer_Desc          = "Internet Authentication Service"
IASServer_HELP          = "Enables authentication, authorization and accounting of dial-up and VPN users. IAS supports the RADIUS protocol."

NetCIS_DESC             = "COM Internet Services Proxy"
NetCIS_HELP             = "Enables DCOM (Distributed Component Object Model) to travel over HTTP via the Internet Information Server (IIS)."

FLG_ADDREG_KEYONLY = 0x0010
REG_MULTI_SZ = 0x10000
REG_EXPAND_SZ = 0x20000
REG_DWORD = 0x10001
REG_SZ_NO_CLOBBER = 0x2
SERVICE_DEMAND_START = 3
SERVICE_AUTO_START = 2
SERVICE_WIN32_SHARE_PROCESS = 32
SERVICE_FILE_SYSTEM_DRIVER = 2
SERVICE_WIN32_OWN_PROCESS = 16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netrass.txt ===
[Strings]
Msft = "Microsoft"

ALG-DispName                = "Application Layer Gateway"
RasCli-DispName             = "Dial-Up Client"
RasMan-DispName             = "Remote Access Connection Manager"
RasSrv-DispName             = "Dial-Up Server"
Steelhead-DispName          = "Steelhead"

Snapin-Desc                 = "Routing and Remote Access"
Snapin-Group-Name           = "Administrative Tools"
Snapin-HelpText             = "Use Routing and Remote Access to configure and manage the Routing and Remote Access service."
Nt4RasAdmin-Desc            = "Routing and RAS Admin"
Nt4RasAdmin-Group-Name      = "Administrative Tools"

Svc-ALG-DispName            = "Application Layer Gateway Service"
Svc-ALG-Description         = "Provides support for 3rd party protocol plug-ins for Internet Connection Sharing and the Internet Connection Firewall"
Svc-RasAcd-DispName         = "Remote Access Auto Connection Driver"
Svc-RasAuto-DispName        = "Remote Access Auto Connection Manager"
Svc-RasAuto-Description     = "Creates a connection to a remote network whenever a program references a remote DNS or NetBIOS name or address."
Svc-RasMan-DispName         = "Remote Access Connection Manager"
Svc-RasMan-Description      = "Creates a network connection."
Svc-RemoteAccess-DispName   = "Routing and Remote Access"
Svc-RemoteAccess-Description = "Offers routing services to businesses in local area and wide area network environments."
Svc-IpFilter-DispName       = "IP Traffic Filter Driver"
Svc-IpInIp-DispName         = "IP in IP Tunnel Driver"
Svc-IpNat-DispName          = "IP Network Address Translator"
Svc-IpxFilter-DispName      = "IPX Traffic Filter Driver"
Svc-IpxForwarder-DispName   = "IPX Traffic Forwarder Driver"
Svc-NwSapAgent-DispName     = "SAP Agent"
Svc-SharedAccess-DispName   = "Internet Connection Firewall (ICF) / Internet Connection Sharing (ICS)"
Svc-SharedAccess-Description = "Provides network address translation, addressing, name resolution and/or intrusion prevention services for a home or small office network."

RtrMgr-Ip-DispName          = "TCP/IP Routing Manager"
RtrMgr-Ip-AutoDhcp-DispName = "DHCP Allocator"
RtrMgr-Ip-Bootp-DispName    = "DHCP Relay Agent"
RtrMgr-Ip-DnsProxy-DispName = "DNS Proxy Agent"
RtrMgr-Ip-Ftp-DispName      = "Ftp Proxy Agent"
RtrMgr-Ip-H323-DispName     = "H.323 Proxy Agent"
RtrMgr-Ip-Igmp-DispName     = "IGMP Router and Proxy"
RtrMgr-Ip-Nat-DispName      = "Network Address Translation (NAT)"
RtrMgr-Ip-Ospf-DispName     = "Open Shortest Path First (OSPF)"
RtrMgr-Ip-Rip-DispName      = "RIP Version 2 for Internet Protocol"

RtrMgr-Ipx-DispName         = "IPX Routing Manager"
RtrMgr-Ipx-Rip-DispName     = "RIP for IPX"
RtrMgr-Ipx-Sap-DispName     = "SAP for IPX"

Nt-Authentication           = "Windows Authentication"
Nt-Accounting               = "Windows Accounting"
Radius-Authentication       = "RADIUS Authentication"
Radius-Accounting           = "RADIUS Accounting"

Eap-DispName                = "Smart Card or other Certificate"
Chap-DispName               = "MD5-Challenge"
PEAP-DispName               = "Protected EAP (PEAP)"
EAPMSCHAP-DispName          = "Secured password (EAP-MSCHAP v2)"


ConnFolderName              = "Network Connections"
ConnFolderSubDir            = "Accessories\Communications"
ConnFolderTip               = "@%systemroot%\system32\netshell.dll,-1201"

NCW-Name                    = "New Connection Wizard"
NCW-SubDir                  = "Accessories\Communications"
NCW-ToolTip                 = "@%systemroot%\system32\netshell.dll,-1011"

CmDefaultCmdKeyName         = "Connection Manager Profile"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netsap.txt ===
[Strings]
Msft                = "Microsoft"
NWSapAgent_Display  = "SAP Agent"
NWSapAgent_Desc     = "Service Advertising Protocol"


; AddReg flags
FLG_ADDREG_KEYONLY          = 0x00000010

; Some standard defines
REG_MULTI_SZ                = 0x10000
REG_EXPAND_SZ               = 0x20000
REG_DWORD                   = 0x10001

; Characteristic flags
NCF_VIRTUAL                 = 0x0001
NCF_WRAPPER                 = 0x0002
NCF_PHYSICAL                = 0x0004
NCF_HIDDEN                  = 0x0008
NCF_NO_SERVICE              = 0x0010
NCF_NOT_USER_REMOVABLE      = 0x0020
NCF_HAS_UI                  = 0x0080
NCF_MODEM                   = 0x0100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netserv.txt ===
[Strings]
Msft = "Microsoft"

; Component description
MSServer_Desc = "File and Printer Sharing for Microsoft Networks"

; Do not localize these

; Service descriptions
LanmanServer_Display = "Server"
LanmanServer_Desc    = "Supports file, print, and named-pipe sharing over the network for this computer. If this service is stopped, these functions will be unavailable. If this service is disabled, any services that explicitly depend on it will fail to start."
Srv_Desc = "Srv"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netsfnt.txt ===
[Strings]
Msft                = "Microsoft"
FPNWTools_Desc      = "File and Print Services for NetWare Administrative Tools"
FPNWTools_Help      = "File and Print Services for NetWare Administrative Tools"

; ServiceType values
SERVICE_KERNEL_DRIVER               = 0x00000001
SERVICE_FILE_SYSTEM_DRIVER          = 0x00000002
SERVICE_ADAPTER                     = 0x00000004
SERVICE_RECOGNIZER_DRIVER           = 0x00000008
SERVICE_WIN32_OWN_PROCESS           = 0x00000010
SERVICE_WIN32_SHARE_PROCESS         = 0x00000020
SERVICE_INTERACTIVE_PROCESS         = 0x00000100
SERVICE_INTERACTIVE_SHARE_PROCESS   = 0x00000120

; Some standard defines
REG_MULTI_SZ                = 0x10000
REG_EXPAND_SZ               = 0x20000
REG_DWORD                   = 0x10001
FLG_ADDREG_KEYONLY          = 0x0010

; StartType values
SERVICE_BOOT_START          = 0x00000000
SERVICE_SYSTEM_START        = 0x00000001
SERVICE_AUTO_START          = 0x00000002
SERVICE_DEMAND_START        = 0x00000003
SERVICE_DISABLED            = 0x00000004

; ErrorControl values
SERVICE_ERROR_IGNORE        = 0x00000000
SERVICE_ERROR_NORMAL        = 0x00000001
SERVICE_ERROR_SEVERE        = 0x00000002
SERVICE_ERROR_CRITICAL      = 0x00000003

; Characteristic flags
NCF_VIRTUAL                     = 0x0001
NCF_WRAPPER                     = 0x0002
NCF_PHYSICAL                    = 0x0004
NCF_HIDDEN                      = 0x0008
NCF_NO_SERVICE                  = 0x0010
NCF_NOT_USER_REMOVABLE          = 0x0020
NCF_HAS_UI                      = 0x0080
NCF_MODEM                       = 0x0100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netsnmp.txt ===
[Strings]
Msft = "Microsoft"

; Service names
SNMP_Display = "SNMP Service"
SNMP_Desc = "Includes agents that monitor the activity in network devices and report to the network console workstation."
SNMPTRAP_Display = "SNMP Trap Service"
SNMPTRAP_Desc = "Receives trap messages generated by local or remote SNMP agents and forwards the messages to SNMP management programs running on this computer."
SNMP_HELP = "Simple Network Management Protocol service that enables a Windows computer to be administered remotely with an SNMP management tool."
Admin_Tools = "Administrative Tools"

REG_MULTI_SZ = 0x10000
REG_EXPAND_SZ = 0x20000
FLG_ADDREG_KEYONLY = 0x0010
REG_DWORD = 0x10001
SERVICE_DEMAND_START = 3
SERVICE_AUTO_START = 2
SERVICE_WIN32_SHARE_PROCESS = 32
SERVICE_FILE_SYSTEM_DRIVER = 2
SERVICE_WIN32_OWN_PROCESS = 16

; Characteristic flags
NCF_VIRTUAL                 = 0x0001
NCF_WRAPPER                 = 0x0002
NCF_PHYSICAL                = 0x0004
NCF_HIDDEN                  = 0x0008
NCF_NO_SERVICE              = 0x0010
NCF_NOT_USER_REMOVABLE      = 0x0020
NCF_HAS_UI                  = 0x0080
NCF_MODEM                   = 0x0100

KEY_OPTIONAL            = "SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netsfn.txt ===
[Strings]
Msft            = "Microsoft"
FPNW_Desc       = "File and Print Services for NetWare"
FPNWSRV_Desc    = "FPNWSrv"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\nettpcu.txt ===
[Strings]
Msft                        = "Microsoft"

TCPUTIL_Desc                = "TCP/IP Connectivity Utilities"
TCPUTIL_HELP                = "TCP/IP Connectivity Utilities"

; ServiceType values
SERVICE_KERNEL_DRIVER       = 0x00000001
SERVICE_FILE_SYSTEM_DRIVER  = 0x00000002
SERVICE_ADAPTER             = 0x00000004
SERVICE_RECOGNIZER_DRIVER   = 0x00000008
SERVICE_WIN32_OWN_PROCESS   = 0x00000010
SERVICE_WIN32_SHARE_PROCESS = 0x00000020
SERVICE_INTERACTIVE_PROCESS = 0x00000100
SERVICE_INTERACTIVE_SHARE_PROCESS = 0x00000120

; StartType values
SERVICE_BOOT_START          = 0x00000000
SERVICE_SYSTEM_START        = 0x00000001
SERVICE_AUTO_START          = 0x00000002
SERVICE_DEMAND_START        = 0x00000003
SERVICE_DISABLED            = 0x00000004
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\nettp4.txt ===
[Strings]
Msft                     = "Microsoft"

ISOTPSYS_Desc            = "OSI-LAN Protocol"

ISOTP_Desc               = "Microsoft OSI-LAN Transport"
ISOTP_HELP               = "TP4/CLNP/ES-IS Protocol Suite from Microsoft, Inc."

; ServiceType values
SERVICE_KERNEL_DRIVER       = 0x00000001
SERVICE_FILE_SYSTEM_DRIVER  = 0x00000002
SERVICE_ADAPTER             = 0x00000004
SERVICE_RECOGNIZER_DRIVER   = 0x00000008
SERVICE_WIN32_OWN_PROCESS   = 0x00000010
SERVICE_WIN32_SHARE_PROCESS = 0x00000020
SERVICE_INTERACTIVE_PROCESS = 0x00000100
SERVICE_INTERACTIVE_SHARE_PROCESS = 0x00000120

; StartType values
SERVICE_BOOT_START          = 0x00000000
SERVICE_SYSTEM_START        = 0x00000001
SERVICE_AUTO_START          = 0x00000002
SERVICE_DEMAND_START        = 0x00000003
SERVICE_DISABLED            = 0x00000004

; ErrorControl values
SERVICE_ERROR_IGNORE        = 0x00000000
SERVICE_ERROR_NORMAL        = 0x00000001
SERVICE_ERROR_SEVERE        = 0x00000002
SERVICE_ERROR_CRITICAL      = 0x00000003

; Characteristic flags
NCF_VIRTUAL                 = 0x0001
NCF_WRAPPER                 = 0x0002
NCF_PHYSICAL                = 0x0004
NCF_HIDDEN                  = 0x0008
NCF_NO_SERVICE              = 0x0010
NCF_NOT_USER_REMOVABLE      = 0x0020
NCF_HAS_UI                  = 0x0080
NCF_MODEM                   = 0x0100

; Registry types
REG_MULTI_SZ                = 0x10000
REG_EXPAND_SZ               = 0x20000
REG_DWORD                   = 0x10001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\nettcpip.txt ===
[Strings]
Msft = "Microsoft"

;TCPIP strings
MS_TCPIP.DisplayName = "Internet Protocol (TCP/IP)"
MS_TCPIP.DHCP.DisplayName    = "DHCP Client"
MS_TCPIP.DHCP.ServiceDescription    = "Manages network configuration by registering and updating IP addresses and DNS names."
MS_TCPIP.TCPIP.ServiceDescription   = "TCP/IP Protocol Driver"

MS_TCPIP.Provider_Desc = "Tcpip"
MS_NTDS.Provider_Desc = "NTDS"

;WINS strings
MS_WINS.DisplayName = "WINS Client(TCP/IP) Protocol"
MS_WINS.LMHosts.DisplayName = "TCP/IP NetBIOS Helper"
MS_WINS.LMHosts.ServiceDescription = "Enables support for NetBIOS over TCP/IP (NetBT) service and NetBIOS name resolution."
;MS_WINS.WINS.ServiceDescription    = "WINS Client(TCP/IP) Protocol Driver"
MS_WINS.WINS.ServiceDescription    = "NetBios over Tcpip"

;ATM ARPC
MS_ATMARPC.DeviceDesc = "ATM ARP Client Protocol"

;DNSCACHE
MS_TCPIP.DNSCACHE.DisplayName = "DNS Client"
MS_TCPIP.DNSCACHE.ServiceDescription = "Resolves and caches Domain Name System (DNS) names for this computer. If this service is stopped, this computer will not be able to resolve DNS names and locate Active Directory domain controllers. If this service is disabled, any services that explicitly depend on it will fail to start."

; IPSEC
MS_TCPIP.IPSEC.ServiceDescription = "IPSEC driver"
MS_TCPIP.Oakley.ServiceDescription = "ISAKMP/Oakley Key Manager"
MS_TCPIP.PolicyAgent.DisplayName = "IPSEC Services"
MS_TCPIP.PolicyAgent.ServiceDescription = "Manages IP security policy and starts the ISAKMP/Oakley (IKE) and the IP security driver."

; Winsock Mobility strings
MS_TCPIP.Nla.DisplayName = "Network Location Awareness (NLA)"
MS_TCPIP.Nla.ServiceDescription = "Collects and stores network configuration and location information, and notifies applications when this information changes."
MS_TCPIP.Nla.Provider_Desc = "Network Location Awareness (NLA) Namespace"

IPSEC_Group_Name = "Administrative Tools"
IPSEC_Admin_Desc = "IP Security Management"

; NETBT_SMB
MS_NETBT_SMB.DisplayName = "Message-oriented TCP/IP Protocol (SMB session)"
MS_NETBT_SMB.HelpText = "A protocol layered on TCP/IP which preserves message boundaries.  This instance of the protocol is for use by the file sharing protocol."

; AddReg flags
FLG_ADDREG_TYPE_EXPAND_SZ   = 0x00020000
FLG_ADDREG_TYPE_MULTI_SZ    = 0x00010000
FLG_ADDREG_TYPE_DWORD       = 0x00010001
FLG_ADDREG_KEYONLY          = 0x00000010
FLG_ADDREG_SZ_NO_CLOBBER    = 0x00000002
FLG_ADDREG_MULTI_SZ_APPEND  = 0x0001000A
FLG_ADDREG_TYPE_BINARY      = 0x00000001
FLG_ADDREG_DWORD_NO_CLOBBER = 0x00010003
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netupgrd.txt ===
[Strings]
Msft = "Microsoft"

CSID00=0B9398C0-DC7E-101B-A351-00AA004797A7     ; Global menu and propsheet
CSID01=208D2C60-3AEA-1069-A2D7-08002B30309D     ; Network Neighbourhood
CSID02=0B7F1760-B613-101B-B115-00AA00479C41     ; per file-folder menu and propsheet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netupg.txt ===
[Strings]
Msft = "Microsoft"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netupnph.txt ===
[Strings]
Msft = "Microsoft"

UPNPHOST_Display = "Universal Plug and Play Device Host"
UPNPHOST_Desc = "Provides support to host Universal Plug and Play devices."

UPNP_Display = "SSDP Discovery Service"
UPNP_Desc = "Enables discovery of UPnP devices on your home network."
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\nettpsmp.txt ===
[Strings]
Msft                        = "Microsoft"

SimpTcp_Name                = "Simple TCP/IP Services"
SimpTcp_Desc                = "Supports the following TCP/IP services: Character Generator, Daytime, Discard, Echo, and Quote of the Day."
SimpTcp_HELP                = "Client programs for simple network protocols, including Character Generator, Daytime, Discard, Echo and Quote of the Day."

; ServiceType values
SERVICE_KERNEL_DRIVER       = 0x00000001
SERVICE_FILE_SYSTEM_DRIVER  = 0x00000002
SERVICE_ADAPTER             = 0x00000004
SERVICE_RECOGNIZER_DRIVER   = 0x00000008
SERVICE_WIN32_OWN_PROCESS   = 0x00000010
SERVICE_WIN32_SHARE_PROCESS = 0x00000020
SERVICE_INTERACTIVE_PROCESS = 0x00000100
SERVICE_INTERACTIVE_SHARE_PROCESS = 0x00000120

; StartType values
SERVICE_BOOT_START          = 0x00000000
SERVICE_SYSTEM_START        = 0x00000001
SERVICE_AUTO_START          = 0x00000002
SERVICE_DEMAND_START        = 0x00000003
SERVICE_DISABLED            = 0x00000004

; ErrorControl values
SERVICE_ERROR_IGNORE        = 0x00000000
SERVICE_ERROR_NORMAL        = 0x00000001
SERVICE_ERROR_SEVERE        = 0x00000002
SERVICE_ERROR_CRITICAL      = 0x00000003

; Registry types
REG_MULTI_SZ                = 0x10000
REG_EXPAND_SZ               = 0x20000
REG_DWORD                   = 0x10001

FLG_ADDREG_KEYONLY          = 0x00000010
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netwlbs.txt ===
[Strings]
Msft = "Microsoft"

WLBS_Desc = "Network Load Balancing"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netwins.txt ===
[Strings]
Msft = "Microsoft"

WINSServer_Desc = "Windows Internet Name Service"

; Service names
WINS_Display = "Windows Internet Name Service (WINS)"
WINS_Desc = "Provides a NetBIOS name service for TCP/IP clients that have to register and resolve NetBIOS-type names."
WINS_HELP = "Dynamic name registration and resolution service that maps NetBIOS computer names to IP addresses."

; Note to localizers: Please make sure this is the same description used in NT4
WINS_Desc_Old = "WINS Manager"
WINS_Group = "Administrative Tools"
WINS_Admin_Desc = "WINS"
WINS_Admin_HelpText = "Manages the Windows Internet Name Service (WINS), which translates NetBIOS computer names to IP addresses."

; Note to localizers: Please make sure this is the same description used in NT 3.51
WINS_Desc_Really_Old = "WINS Manager"
WINS_Group_Really_Old = "Network Administration"

FLG_ADDREG_KEYONLY = 0x0010
REG_MULTI_SZ = 0x10000
REG_EXPAND_SZ = 0x20000
REG_DWORD = 0x10001
SERVICE_DEMAND_START = 3
SERVICE_AUTO_START = 2
SERVICE_WIN32_SHARE_PROCESS = 32
SERVICE_FILE_SYSTEM_DRIVER = 2
SERVICE_WIN32_OWN_PROCESS = 16

; Characteristic flags
NCF_VIRTUAL                     = 0x0001
NCF_WRAPPER                     = 0x0002
NCF_PHYSICAL                    = 0x0004
NCF_HIDDEN                      = 0x0008
NCF_NO_SERVICE                  = 0x0010
NCF_NOT_USER_REMOVABLE          = 0x0020
NCF_HAS_UI                      = 0x0080
NCF_MODEM                       = 0x0100

KEY_OPTIONAL            = "SOFTWARE\Microsoft\Windows\CurrentVersion\Setup\OptionalComponents"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netwlbsm.txt ===
[Strings]
Msft = "Microsoft"

WLBS_Desc   = "Network Load Balancing"
WLBSMP_Desc = "Network Load Balancing Filter Device"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netupnp.txt ===
[Strings]
Msft = "Microsoft"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\netwzc.txt ===
[Strings]
Msft = "Microsoft"
WZCSVC_Desc = "Wireless Zero Configuration"
WZCSVC_HelpText = "Provides automatic configuration for the 802.11 adapters"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\inf\usa\syssetup.txt ===
@*: Lines marked with @w: are for workstation only
@*: Lines marked with @s: are for server only
@*: Lines marked with @@: or nothing are for both

[Strings]
;
; Names of program groups
;
main = "Main"
games = "Games"
accessories = "Accessories"
accessories_games = "Accessories\Games"
accessories_multimedia = "Accessories\Multimedia"
startup = "Startup"
admintools = "Administrative Tools"
@s:netadmintools = "Network Administration"

;
; Names of program group items
;
winfile = "File Manager"
control = "Control Panel"
printman = "Print Manager"
clipbrd = "ClipBook Viewer"
dialer = "Phone Dialer"
cmd = "Command Prompt"
explorer = "Windows NT Explorer"
setup = "Windows NT Setup"
pifedit = "PIF Editor"
msmail32 = "Mail"
schdpl32 = "Schedule+"
intro = "Introducing Windows NT"
readme = "Read Me"
ntbooks = "Books Online"
cmdref = "Windows NT Help"
windisk = "Disk Administrator"
perfmon = "Performance Monitor"
ntbackup = "Backup"
eventvwr = "Event Viewer"
dcomcnfg = "DCOM Configuration"
winmsd = "Windows NT Diagnostics"
@s:upedit = "User Profile Editor"
@s:usrmgr = "User Manager for Domains"
@s:nwconv = "Migration Tool for NetWare"
@s:srvmgr = "Server Manager"
@s:poledit = "System Policy Editor"
@w:musrmgr = "User Manager"
pbrush = "Paintbrush"
paint = "Paint"
winchat = "Chat"
terminal = "Terminal"
notepad = "Notepad"
cardfile = "Cardfile"
calc = "Calculator"
clock = "Clock"
charmap = "Character Map"
mplayer = "Media Player"
sndrec32 = "Sound Recorder"
sndvol32 = "Volume Control"
cdplayer = "CD Player"
write = "Write"
packgr32 = "Object Packager"
hyperterm = "HyperTerminal"
sol = "Solitaire"
winmine = "Minesweeper"
freecell = "Freecell"
@s:netclientadmin = "Network Client Administrator"
@s:licmanager = "License Manager"
rasadmin = "Remote Access Admin"
du_networking = "Dial-Up Networking"
admin_wiz = "Administrative Wizards"
@*:;
@*:;   Win9x Paths
@*:;
@*:win9x_programs_path    = "Start Menu\Programs"
@*:win9x_accessoriess_path= "Start Menu\Programs\Accessories"
@*:win9x_games_path       = "Start Menu\Programs\Accessories\Games"
@*:win9x_multimedia_path  = "Start Menu\Programs\Accessories\Multimedia"
@*:win9x_systemtools_path = "Start Menu\Programs\Accessories\System Tools"
@*:;
@*:;   Win9x Group Names
@*:;
@*:win9x_fax_group            = "Fax"
@*:win9x_games_group          = "Games"
@*:win9x_internet_tools_group = "Internet Tools"
@*:win9x_multimedia_group     = "Multimedia"
@*:win9x_systemtools_group    = "System Tools"
@*:;
@*:;   Win9x Item Names
@*:;
@*:win9x_freecel       = "Freecell"
@*:win9x_hearts        = "Hearts"
@*:win9x_minesweeper   = "Minesweeper"
@*:win9x_solitaire     = "Solitaire"
@*:win9x_cdplayer      = "CD Player"
@*:win9x_mediaplayer   = "Media Player"
@*:win9x_soundrecorder = "Sound Recorder"
@*:win9x_volumecontrol = "Volume Control"
@*:win9x_backup        = "Backup"
@*:win9x_diskdefrag    = "Disk Defragmenter"
@*:win9x_drivespace    = "DriveSpace"
@*:win9x_inboxrepair   = "Inbox Repair Tool"
@*:win9x_netwatcher    = "Net Watcher"
@*:win9x_resmeter      = "Resource Meter"
@*:win9x_scandisk      = "ScanDisk"
@*:win9x_sysmonitor    = "System Monitor"
@*:win9x_doscommand    = "MS-DOS Prompt"
@*:win9x_explorer      = "Windows Explorer"
@*:win9x_exchange      = "Microsoft Exchange"
@*:win9x_msn           = "The Microsoft Network"
@*:win9x_du_networking = "Dial-up Networking"
@*:win9x_du_scripting  = "Dial-up Scripting Tool"
@*:win9x_direct_cable  = "Direct Cable Connection"
@*:win9x_hyperterm     = "HyperTerminal"
@*:win9x_online_reg    = "Online Registration"
@*:win9x_paint         = "Paint"
@*:win9x_phone_dialer  = "Phone Dialer"
@*:win9x_WordPad       = "WordPad"
ProgramF    = "Program Files"
CommonF     = "Common Files"
ADOF        = "ADO"
OLEDBF      = "OLE DB"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\nwclicfg\infnotes.txt ===
%NWCLIENT_Desc% needs to be added
%NWCWORKSTATION_Desc% needs to be added

AddParametersKey does stuff for STF_UNATTENDED_SECTION like setting the DefaultLocation 
and DefaultScriptOptions on the Parameters key of the NWCWorkstation service. I've
never seen the NW setup do this, and I don't see where those are defined anyway. Weird.

Can't set permissions on the parameters/option key. Error code 122. Need debug
nwapi32.dll to find the problem.

Make sure that I'm not leaking memory or forgetting to close a reg key!!!

Do I have to add RPC stuff?

Rename Novell.cpl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\rascfg\binding.txt ===
Issues
------
    WAN devices vs. LAN devices.  Can we gen an indications of the "subclass"?
    Last protocol to be removed should cause something to happen with RAS.
    Can we reference count adapter installs?  (Maybe for Beta2)


RasCli, RasSrv, RasRtr NetworkInstall and Install
-------------------------------------------------
Install NdisWan


NdisWan NetworkInstall and Install
----------------------------------
Install PPTP


RasCli QueryBindingInterface (NCN_LOWER)
----------------------------------------
if (binding == "rasPortUse")    // enable dial-out port
{
    // if a component is being added, default the binding
    // to disabled on the server product.
    if (NCN_ADD && FProdServer)
        return NETCFG_DISABLEQUERY
}


RasSrv QueryBindingInterface (NCN_LOWER)
----------------------------------------
if (binding == "rasPortUse")    // enable dial-in port
{
    // if a component is being added, default the binding
    // to disabled on the workstation product.
    if (NCN_ADD && FProdWorkstation)
    {
        return NETCG_S_DISABLE_QUERY
    }

    // if someone is trying to enable this binding on
    // the workstation product, veto it if we already have
    // at least one binding of this type enabled.
    if (NBF_ENABLED && FProdWorkstation)
    {
        Iterate our enabled binding paths
            Iterate the binding interfaces along this path
                if (GetName == "rasPortUse")
                    return NETCFG_S_VETO_QUERY
    }

}

PPTP
----
    NetworkInstall and Install
    {
        AddVpnEndpoints(1)
    }

    ApplyProperties
    {
        dEndpoints = nEnpointsNew - nEndpointsCur;
        if (dEndpoints > 0)
            AddEndpoints(dEndpoints)
        else if (dEndpoints < 0)
            RemoveEndpoints(-dEndpoints)

        Write registry parameters
    }

    AddVpnEndpoints(n)
    {
        Add n components with device id of "VaPptpEndpoint"
    }
    RemoveVpnEndpoints(n)
    {
        Remove first n components with device id of "VaPptpEndpoint"
    }


NdisWan
-------

    Add Protocol -or- Enable binding over "rasTransUse" interface.
    (Handle this via SysNotifyBindingInterface(NCN_ENABLE) for "rasTransUse")
    {
        nDialOut = Get number of dial-out adapters bound below using "ndisWanAdapter"
        nDialIn  = Get number of dial-in  adapters bound below using "ndisWanAdapter"
        {
            Get RasCli component using INetCfg and INetCfgClass
            Get RasSrv component using INetCfg and INetCfgClass

            Iterate our enabled binding paths
                Iterate binding interfaces along this path
                    if (GetName == "ndisWanAdapter")
                    {
                        GetLowerComponent   // this is the adapter

                        GetPortUsage(LowerComponent, &fDialOut, &fDialIn)
                        if (fDialOut) nDialOut++
                        if (fDialIn)  nDialIn++
                    }
        }

        Create WanWrap devices for protocol being added
        {
            if (protocol == "Ip")
            {
                AddComponentNTimes("WanwrapIpOut", nDialOut)

                if (nDialIn > 0)
                    AddComponentRefCount("WanwrapIpIn", &m_cRefIpIn)
            }

            else if (protocol == "Ipx")
            {
                if ((nDialOut > 0) || (nDialIn > 0))
                    AddComponentRefCount("WanwrapIpx", &m_cRefIpx)
            }

            else if (protocol == "Nbf")
            {
                AddComponentNTimes("WanwrapNbfOut", nDialOut)
                AddComponentNTimes("WanwrapNbfIn",  nDialIn)
            }
        }

    }

    Remove Protocol -or- Disable binding over "rasTransUse" interface.
    (Handle this via SysNotifyBindingInterface(NCN_DISABLE) for "rasTransUse")
    {
        Get a pointer to the constant, static list of binding interfaces that
        involve this protocol.
        {
            if (protocol == "Ip")
                list = { WanwrapIpIn, WanwrapIpOut }
            else if (protocol == "Ipx")
                list = { WanwrapIpx }
            else if (protocol == "Nbf")
                list = { WanwrapNbfIn, WanwrapNbfOut }
        }

        Iterate our lower binding paths
            Iterate binding interfaces along this path
                if (GetName is in list)
                    Remove the lower component
    }

    Add WAN Adapter
    (Handle this via NotifyBindingInterface(NCN_LOWER | NCN_ENABLE) for "ndisWanAdapter")
    {
        if (Component supports upper-edge interface of "rasPortUse")
        {
            return S_OK;
            // We'll pick up this change when we get a SysNotifyBindingInterface
            // for "rasPortUse".  If we did it here as well, we'd be adding
            // wan wrappers twice and we don't want to do that.
        }

        // Otherwise, we're adding a port which cannot have its usage controlled.
        // Therefore, its both dial-in and dial-out.

        fDialOut = TRUE;
        fDialIn = TRUE;

        AddWanWrapperForAllProtocols(fDialOut, fDialIn)
    }

    Enable binding over "rasPortUse" interface.
    (Handle this via SysNotifyBindingInterface(NCN_ENABLE) for "rasPortUse")
    {
        GetPortUsage(Component, &fDialOut, &fDialIn)
        AddWanWrappersForAllProtocols(fDialOut, fDialIn);
    }


    Remove WAN Adapter
    (Handle this via NotifyBindingInterface(NCN_LOWER | NCN_DISABLE) for "ndisWanAdapter")
    {
        if (Component supports upper-edge interface of "rasPortUse")
        {
            return S_OK;
            // We'll pick up this change when we get a SysNotifyBindingInterface
            // for "rasPortUse".  If we did it here as well, we'd be adding
            // wan wrappers twice and we don't want to do that.
        }

        // Otherwise, we're removing a port which cannot have its usage controlled.
        // Therefore, its both dial-in and dial-out.

        fDialOut = TRUE;
        fDialIn = TRUE;

        RemoveWanWrapperForAllProtocols(fDialOut, fDialIn)
    }

    Disable binding over "rasPortUse" interface.
    (Handle this via SysNotifyBindingInterface(NCN_DISABLE) for "rasPortUse")
    {
        GetPortUsage(Component, &fDialOut, &fDialIn)
        RemoveWanWrapperForAllProtocols(fDialOut, fDialIn);
    }


    Helper function: GetPortUsage(Component*, pfDialOut, pfDialIn)
    {
        if (Component does not support an upper-edge binding
            interface of "rasPortUse")
        {
            *pfDialOut = *pfDialIn = TRUE
        }
        else
        {
            if (LowerComponent->IsBoundTo(RasCli))
                *pfDialOut = TRUE

            if (LowerComponent->IsBoundTo(RasSrv))
                *pfDialIn = TRUE
        }
    }

    Helper function: AddWanWrapperForAllProtocols(fDialOut, fDialIn)
    {
        Get Ip  component using INetCfg and INetCfgClass
        Get Ipx component using INetCfg and INetCfgClass
        Get Nbf component using INetCfg and INetCfgClass

        if (fDialOut)
        {
            if (Ip && Ip->IsBoundTo(RasCli))
                AddComponent("WanwrapIpOut")    (no more than 64)

            if (Ipx && Ipx->IsBoundTo(RasCli))
                AddComponentRefCount("WanwrapIpx", &m_cRefIpx)

            if (Nbf && Nbf->IsBoundTo(RasCli))
                AddComponent("WanwrapNbfOut")   (no more than 255)
        }
        if (fDialIn)
        {
            if (Ip && Ip->IsBoundTo(RasSrv))
                AddComponentRefCount("WanwrapIpIn", &m_cRefIpIn)

            if (Ipx && Ipx->IsBoundTo(RasSrv))
                AddComponentRefCount("WanwrapIpx", &m_cRefIpx)

            if (Nbf && Nbf->IsBoundTo(RasSrv))
                AddComponent("WanwrapNbfIn")
        }
    }

    Helper function: RemoveWanWrapperForAllProtocols(fDialOut, fDialIn)
    {
        Get Ip  component using INetCfg and INetCfgClass
        Get Ipx component using INetCfg and INetCfgClass
        Get Nbf component using INetCfg and INetCfgClass

        if (fDialOut)
        {
            if (Ip && Ip->IsBoundTo(RasCli))
                RemoveComponent("WanwrapIpOut")

            if (Ipx && Ipx->IsBoundTo(RasCli))
                RemoveComponentRefCount("WanwrapIpx", &m_cRefIpx)

            if (Nbf && Nbf->IsBoundTo(RasCli))
                RemoveComponent("WanwrapNbfOut")
        }
        if (fDialIn)
        {
            if (Ip && Ip->IsBoundTo(RasSrv))
                RemoveComponentRefCount("WanwrapIpIn", &m_cRefIpIn)

            if (Ipx && Ipx->IsBoundTo(RasSrv))
                RemoveComponentRefCount("WanwrapIpx", &m_cRefIpx)

            if (Nbf && Nbf->IsBoundTo(RasSrv))
                RemoveComponent("WanwrapNbfIn")
        }
    }


#ifdef NEVER
                //--------------------------------------------------------
                // Get the interface to enumerate our binding paths.
                IEnumNetCfgBindingPath* pebp;
                if (SUCCEEDED(hr = m_pnccMe->EnumBindingPaths(&pebp)))
                {
                    CIEnumIter<IEnumNetCfgBindingPath, INetCfgBindingPath> ei(pebp);
                    INetCfgBindingPath* pncbp;
                    while (SUCCEEDED(hr = ei.HrNext(&pncbp)) && (S_FALSE != hr))
                    {
                        ReleaseObj(pncbp);
                    }

                    // Get the next batch of binding path interfaces.
                    const ULONG         c_celtBatch = 512;
                    ULONG               celtFetched;
                    INetCfgBindingPath* apbp;
                    do
                    {
                        if (SUCCEEDED(hr = pebp->Next(c_celtBatch, &apbp, &celtFetched)))
                        {
                            // Make sure the implementor of Next is obeying the rules.
                            Assert(FImplies((S_OK == hr), (celtFetched == c_celtBatch)));

                            // Iterate this batch of interfaces.
                            INetCfgBindingPath* pncbp;
                            for (pncbp = apbp; pncbp < apbp + celtFetched; pncbp++)
                            {
                                //--------------------------------------------------------
                                // Get the interface to enumerate the interfaces along this path.

                                ReleaseObj(pncbp);
                            }

                            // Free this batch of binding path interfaces;
                            CoTaskMemFree(apbp);
                        }
                    }
                    while (SUCCEEDED(hr) && (celtFetched >= c_celtBatch));

                    // Release the binding path enumerator.
                    ReleaseObj(pebp);
                }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\sfncfg\infnotes.txt ===
Add localization strings (..._DESC, etc)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\wlbscfg\tracewpp.ini ===
FUNC TRACE_CRIT{LEVEL=Critical}(MSG,...);
FUNC TRACE_INFO{LEVEL=Informational}(MSG,...);
FUNC TRACE_VERB{LEVEL=Verbose}(MSG,...);
FUNC TRACE_FULL{LEVEL=Full}(MSG,...);
FUNC TRACE_HB{LEVEL=Heartbeats}(MSG,...);
FUNC TRACE_TCPCTRL{LEVEL=TcpControl}(MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\answerfiles\baseaf.txt ===
; ----------------------------------------------------------------------
; baseaf.txt
;
; This file has the minimum number of sections required for unattended
; install of Windows. This file does not have any Networking sections.
; If you use this file alone, networking will not be installed.
; Please use this file in combination with other sample answerfiles 
; found in the same directory.
;
[Unattended]
TargetPath = winnt
FileSystem = LeaveAlone

[UserData]
FullName = "User Name"
OrgName = "Microsoft"
ComputerName = OEM_Computer

[Display]
BitsPerPel = 8
Xresolution = 640
Yresolution = 480
Vrefresh = 60

[Identification]
JoinDomain=MyDomain
CreateComputerAccountInDomain=Yes
DomainAdmin=MyDomainAdmin
DomainAdminPassword=MyDomainAdminPassword
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\answerfiles\minaf.txt ===
; -----------------------------------------------------------------
; This file shows how to install the default networking components.
;
; 1. This sample contains only the Networking related sections.
;    If you want to use this file for unattended installs, you may want to 
;    add contents of the file baseaf.txt to this file.
;

[Networking]
InstallDefaultComponents = Yes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\answerfiles\csnw.txt ===
; -----------------------------------------------------------------
; This file shows how to install / configure the following components.
; - Client / Gateway Services For Netware
; - IPX protocol
;
; 1. Only some of the configurable parameters of the above components 
;    are listed here. For a full list, please refer to the document
;    "Unattended Setup Parameters" available at http://ntcentral/ntbase.
; 2. This sample contains only the Networking related sections.
;    If you want to use this file for unattended installs, you may want to 
;    add contents of the file baseaf.txt to this file.
;

[Networking]

; -----------------------------------------------------------------
; Adapters
;
[NetAdapters]
A1=params.A1

[params.A1]
InfId=*

; -----------------------------------------------------------------
; Protocols
;
[NetProtocols]
MS_NWIPX=params.MS_NWIPX

[params.MS_NWIPX]
AdapterSections=params.MS_NWIPX.A1

[params.MS_NWIPX.A1]
SpecificTo=A1
; set frame type to Ethernet_802.3 for adapter A1
PktType=1

; -----------------------------------------------------------------
; Clients
;
[NetClients]
MS_NWClient=params.MS_NWClient

[params.MS_NWClient]
PreferredServer=NWSERVER1
LogonScript=No
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\answerfiles\snmpaf.txt ===
[NetOptionalComponents]
SNMP=1

[SNMP]
    Accept_CommunityName = public:READ_CREATE, all, rw:READ_WRITE  , none:NONE
    Send_Authentication  = YES
    Any_Host             = NO
    Limit_Host           = 127.0.0.1, 172.31.243.15

    Community_Name       = public
    Traps                = 127.0.0.1, 172.31.243.15

    Contact_Name         = NT_Administration
    Location             = Building_26
    Service              = Physical, Applications, End-to-End
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\samples\answerfiles\tcpip.txt ===
; -----------------------------------------------------------------
; This file shows how to install / configure the following components.
; - TCP/IP protocol
;
; 1. Only some of the configurable parameters of the above components 
;    are listed here. For a full list, please refer to the document
;    "Unattended Setup Parameters" available at http://ntcentral/ntbase.
; 2. This sample contains only the Networking related sections.
;    If you want to use this file for unattended installs, you may want to 
;    add contents of the file baseaf.txt to this file.
;

[Networking]

; -----------------------------------------------------------------
; Adapters
;
[NetAdapters]
A1=params.A1

[params.A1]
InfId=*

; -----------------------------------------------------------------
; Protocols
;
[NetProtocols]
MS_TCPIP=params.MS_TCPIP

[params.MS_TCPIP]
AdapterSections=params.MS_TCPIP.A1

[params.MS_TCPIP.A1]
SpecificTo=A1
IPAddress=1.1.1.1
DNSServerSearchOrder=193.1.1.3,193.1.1.44
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\design.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Network Connections Folder overview   We are a shell namespace extension (using IShellFolder as a base, that uses the Network  TitleNetwork Connections Folder overview   We are a shell namespace extension (using IShellFolder as a base, that uses the Network  Jeffspr Normal Jeffspr Microsoft Word 9.0$RHx1IDATx^ B>9X=R lxVuY 8,GW}6 M9WWV[. cc[S>N {JW_> V(1j"G qz?xp] AiR73Bj owGU[ x/}_%&!R tuY,8 Xed]R KOV:! m}]"~ i[D{_ z&luW p{5k_V kVjMXn ju~-^ e|GFvh D.sM8Ku OE]/B >"O*m =/T?( U[e5k 5.&ML 62Q.S_ hSrM? Az;C64d MC9== Jxxx8 Im+g"Y ikV$W :)b_4 %o.g@ 7A)AL _?Oyg8 +YiE^3 pJR'^]B |O'Hoe O?t@G 4!:&x +M&%Q ;[e|- RS$`P ZEj#k :),M\ W"xECb PYZjH pJA:MJM &1-2L 7::b* SC "w B;P#T `u2,+ =siU= '7W?y msREP M9>[} mO<GdJ ~\}Y]<: Y!?Hmp hL43T uN/+] &<*T} k_VW( ;iFo| .Mj]B D*KU| sM8jB J"o>| 8[qj$At NVw>X5 N|9'w ySCEP$ Rnutb +C6fA MBoQ$| 2t56I? &frI( NOOeM M&|pY* 98Y[( N5QA0 *}C)J TsWK} =6!Dt C'3#D KDpd;9 `" y}Xw "J,hhwBzs j7j1u %<tWrK @6!M& (GX}J b:k|? R)t$M 5bph?0 ]#&\/B9 q^oAn+ _5GmA ']P9q5 ,7Y:vI S\pG|pC& v4}ud 71>)@o +G6Fv i"]:c x&]kri (15u;R v#P~u;"J@ rMWGX M^qEj VZ#9B BfMgeR i-#~9 N)n,= KR$`Y :gAD[o EYkEjx ){>k4 F&zgs D{z/Fi; fw3;x ;s^J7 FGG-@ BFh}X Bb#.. hLboC "l"$d qI~u]2'0m' q RDd LiBrL +dVZ% 95ZOpz KB?yk E"(#C)Cq 2qX$# !4 bJ1 wJD<* (&Mda bXgo; `-bs"# q]V71 PA#C; )9dV2 k!dPd dcHLO 6$M"7 &K1.( dh3!= '%K$MD 7n.oKD 4XQER -R7wM LiBgM )%P$~ &z=u, [nb^$ ed[ ; &B!tf Z+[DAoa =g%o i 5aiR~ ){UgT IDATx^ #o!!-$ ZD"umaZ /mDRB E?7q5 R~,+n INs(6 i3obs JD$^^g C7X3[ >75[u S_{fn ?1Rb% 0%YqXJ. I+%n} MID>T F7\F&b (a1iH ML}:+ir Vn-lKQ J_7Od }t+fz |4Hrw efF"v aE"1l-4 %:oR/|X E\ 05 MHLrVd '5}T^ ~oP^B '&i?s Z!*%\ ==2ao '#@bw %Ljd4 P0,"i) Ag<=M[ |((e!D PWMh9l ;t$N^\ u_$%$( Jy"G;_ OHZ~3 (C`Mj 4]cup nl=S[$ O$XMn |\9=3 {cx/k AMtr! !LWEa\zx Yc&G= SR@]  D*>(m JIHoE F, 0? jW_D\PBrush PBrush PBrushBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBAB BABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBAB BABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBAB BABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBAB BABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBAB Z]ZZ]ZZ]ZZ]ZZ]Z sussusZ]ZZ]ZJMJJMJsussus sussus JMJJMJZ]Z JMJJMJJMJJMJJMJJMJ susJMJ Z]ZJMJ JMJJMJJMJJMJJMJ Z]ZZ]Z JMJJMJJMJ Z]Zsussussussus Z]ZZ]ZZ]Z JMJJMJJMJJMJ JMJJMJcec Z]ZZ]ZZ]ZZ]ZZ]ZZ]ZZ]ZZ]ZZ]ZZ]ZZ]ZZ]ZZ]ZZ]Z JMJcec JMJZ]Z 101c01c01 ecce1JMJc0 101c011e1RUR)() BAB101989101 c01ce1 e1c01 e1ce1 989Z]Zce1BABBABBAB e1ce1 101BABce )()989 110c1e 1e11e1 110cce susceccecsus! !1e 1)()JMJ10c10c1e 011e1)() 0c10cZ]ZBAB )()1ec1 0c10c1ec1ecZ]Z1 c1e11e1 01! ! {8!{4 {8!{4 {8!{8 {8!{8 {8!{8 {<!{8 <!{8! <!{8! <!{<! <!{<! <!{<! <!{<! A){<! {4!{4 {8!{4 {8!{4 {8!{4 {8!{8 8!{8! <!{8! <!{8! <!{8! <!{<! <!{<! <!{<! {8!{4 {8!{4 {8!{8 {8!{8 {8!{8 {8!{8 <!{8! <!{8! <!{<! <!{<! <!{<! <!{<! A!{<! BABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBAB BABBABBABBABBABBABBABBABBABBABBABBABBABBABBABBAB {4!{4 {8!{4 {8!{4 {8!{4 {8!{8 {8!{8 8!{8! <!{8! <!{8! <!{8! <!{<! <!{<! {8!{4 {8!{4 {8!{8 {8!{8 {8!{8 {<!{8 <!{8! <!{8! <!{<! <!{<! <!{<! <!{<! A){<! {8!{4 8!{8! <!{8! <!{<! <!{8! <!{<! <!{<! {8!{4 {8!{4 {8!{8 {8!{8 {8!{4 {8!{8 {8!{4 {8!{4 <!{8! <!{8! <!{<! {8!{8 <!{<! <!{<! {4!{4 {8!{4 {8!{4 {8!{8 {8!{8 <!{8! <!{8! <!{8! <!{<! {8!{4 {8!{8 {<!{8 <!{8! <!{<! <!{<! <!{<! A){<! {4!{4 {8!{4 {8!{4 {8!{8 8!{8! <!{8! <!{8! <!{8! <!{<! <!{<! <!{<! {8!{4 {8!{4 {8!{8 {8!{8 {8!{8 {8!{8 <!{8! <!{8! <!{<! <!{<! <!{<! <!{<! A!{<! {4!{4 {8!{4 {8!{4 {8!{4 {8!{8 {8!{8 8!{8! <!{8! <!{8! <!{8! <!{<! <!{<! {8!{4 {8!{4 {8!{8 {8!{8 {8!{8 {<!{8 <!{8! <!{8! <!{<! <!{<! <!{<! <!{<! A){<! {4!{4 {8!{4 {8!{4 {8!{4 {8!{8 8!{8! <!{8! <!{8! <!{8! <!{<! <!{<! <!{<!bjbjU Network Connections Folder overview   We are a shell namespace extension (using IShellFolder as a base, that uses the Network Connections Manager to enumerate LAN and Dial-Up networking connectoids and displays useful data in a folder. We provide access to configuration, status, and invocation of connection objects. Definitions: Namespace extension   We essentially become a node in the existing standard window hierarchy. For now, we are a child of the Control Panel: (My Computer->Control Panel->Network and Dial-up Connections) IShellFolder   The base interface for accessing a namespace extension. Implemented in  \config\shell\folder\ishellf.cpp. Provides access to our view objects (ishellv.cpp), our enumerator (ienumidl.cpp), and a multitude of other interfaces (ipersistf.cpp, ipersistf2.cpp, i*.cpp). Network Connections Manager   Provides an enumerator (CLSID_ConnectionManager), which has the standard Reset, Next, Skip enumerator. We get them one by one, retrieve their properties, and fill our connection cache. The shell retrieves this info (in opaque format) via our folder enumerator (ienumidl.cpp), and uses that info to call back and retrieve specifics.  EMBED PBrush   Interesting pieces of above image: Webview   This is owned by the shell team, but uses our IShellDetails interfaces through Java to extract relevant info about selections. See %windir%\web\dialup.htt for the Javascript source. Example:            function Connect() {                 if (FileList.SelectedItems().Count)                     FileList.SelectedItems().Item(0).InvokeVerb(L_Connect_Text);             } This gets a list of the selected items, and can invoke the  Connect  verb on those Items. To do this, it loads our context menu and invokes  Connect  (see icontextm.cpp). Todd Ouzts is the PM owner of this file,  and typically makes the bugfixes. Details view   Extracted through IShellDetails, which is queried for through IShellView. Our IShellView implementation comes from defview (Default IShellView), which is a shell32.dll component. It provides a standard IShellView implementation for multiple internal windows shell folder extensions, taking some of the pain out of implementing a standard folder. Other important aspects of this part of the folder are: Defview   Explained above a little bit, it uses callbacks to the specific folder implementation to get our various underlying implementations of toolbars, tooltips, details, etc (each of the pieces listed below) Context menus   Right clicking in this portion of the folder causes our IContextMenu interfaces to be instantiated and queried for info. The shell does this by passing us the pidl (opaque data) to us along with an HMENU and requests that we merge the menu and return. See icontextm.cpp for implementation. Tooltips   Hovering over a connection causes our IQueryInfo interface (iqinfo.cpp) to be instantiated and queried. Code is pretty self-explanatory Icons   Defview uses our IExtractIcon (iextract.cpp) code to load and update icons based on their status and media type. All of our icons, with the exception of those made via CM (Connection Manager, not to be confused with Network Connection Manager), are loaded directly from netshell.dll itself. CM connections may contain  branded icons , which are loaded from the Connection Manager profile (see NickBall for details or see our usage in iextract.cpp).  Make New Connection wizard   Also owned by our team, we provide a icon that launches the wizard (see oncommand.cpp, OnCommandNewConnection). Folder background   When right-clicking on the folder background, IContextMenu is invoked as well, but uses different flags and will retrieve different menus. I ve implemented icontextm.cpp in such a way that most of the code is shared between the object menus and the background menus. See the CMT_ defines in confold.h. The rest should be obvious from the implementation. Menus   Our menus are loaded via defview as well via a callback. We merge our connection-specific commands into the file and context menus, and then modify them as needed based on connection state and selection (we disable the  status  command when a connection is disconnected, for instance). See cmdtable.cpp for this code   it should be very clear. Toolbar   We have toolbar code, but it is currently completely unused as we have no toolbar buttons. Implementing static toolbar items is simple, but if you ever need to enable/disable these buttons, you may have to implement other Shell interfaces IShellToolbar?)  Connection Properties: When selecting properties from the context menu of a connection in the folder, we bring up a properties dialog. This dialog is different for RAS and LAN   the actual code is in shell\lanui (LAN) and shell\wanui (RAS). This code provides property sheet pages to conprops.cpp in the folder directory. The RAS implementation is owned by the RAS team itself (currently Pmay). The LAN config obiect is owned internally and ties into the bindings engine and core NetCfg code. Permissions: \net\config\common\ncbase\ncperms.cpp FHasPermission contains the check routine for GP (Group Policy) settings. We load these the first time one is used, and optionally cache them. These are set at a computer level or user level, and administrators are assumed to have all permissions. Users have a subsetup; that subset can be found in RefreshAllPermission   look for FcheckGroupMembership(DOMAIN_ALIAS_RID_USERS). Group policy is managed via: mmc.exe, Console   Add Snap-In.  Choose the Group Policy Snap-In. Open Local Computer Policy, User Configuration, Administrative Templates, Network, Network and Dial-up Connections Configure policies. By default, all are  Not Configured . You can explicitly enable/disable individual policies. These will affect Users/Power Users. In the future, we need to do two things here: All policies are supposed to be  Disable/Lock-down  policies, meaning that if they are not configured, the user will have full permission. Ours are a mishmash of  Enable  and  Disable  policies. Because of this, it s not clear to the admin whether the default is on/off. It s ugly. We need to make use of these policies outside of the connections folder. For instance, we may lockdown the ability to connect/disconnect connections in the policy editor, but nothing prevents them from using the RAS API s to do the same thing. Our policies should apply to any RAS usage.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\modemshr\netmap\nmplcfil.txt ===
; ----------------------------------------------------------------------
; This file is used for binplacing netmap.inf file in this directory.
;
; We need to use this file because there are multiple files named netmap.inf
; and thus we cannot list this file in the main placefil.txt
; ----------------------------------------------------------------------

netmap.inf	winnt32\winntupg\ms\modemshr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\unsupmsg.txt ===
Setup has determined that you have some networking components that are not compatible with Microsoft Windows XP. If you have a disk containing the files that are necessary to upgrade this component, click Have Disk, and point to those files. If updated files are unavailable, this component may not be upgraded correctly or some settings may be lost.

Setup is sometimes unable to confirm whether a particular network device will upgrade correctly. If you want to discontinue to upgrade at this time, click Cancel to exit Setup.

For a list of devices supported by Windows XP, see the Microsoft Windows XP Hardware Compatibility List at  http://www.microsoft.com/hwtest/hcl.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\netupgrd\unsupmsg.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft The files necessary to upgrade this networking component are  Title _PID_GUIDThe files necessary to upgrade this networking component are  Kumar Pandit Normal.dot scottbri Microsoft Word 8.0bjbjt+t+ The files necessary to upgrade this networking component are not available on the Windows CD-ROM. If you have a disk having the necessary files supplied by another company, please click the  Have Disk  button and provide these file to Setup. If you do not have such a disk and if you decide to continue upgrade, this component will not be upgraded correctly. If you do not wish to continue with the upgrade, please click the  Cancel  button to exit Setup.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\upgrade\nunt4dll\nuplcfil.txt ===
; ----------------------------------------------------------------------
; This sources file is used only for correctly binplacing
; NT4 SP3 version of setupapi.dll and cfgmgr32.dll in winnt32\winntupg
;
; we need to use this file because the files 
; setupapi.dll and cfgmgr32.dll are also built and binplaced by the
; NT5 placefil.txt and thus we cannot add the following entries to the
; standard placefil.txt
; ----------------------------------------------------------------------

setupapi.dll    winnt32\winntupg
cfgmgr32.dll    winnt32\winntupg
msvcrt.dll      winnt32\winntupg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ddk\ddk_net.ini ===
; FORMAT : SourceDir, SourceFile, DestDir, DestFile, OPERATION
; All fields are required
; [subname]* is allowed for source, in which case * required for destination

config\samples\oemupg                         , *           , src\network\config\oemupg                         , *           , HSPLIT      
config\samples\netcfg                         , *           , src\network\config\netcfg                         , *           , HSPLIT      
config\samples\bindview                       , *           , src\network\config\bindview                       , *           , HSPLIT      

irda\irclass                                  , *           , src\network\irda\dll\irclass                      , *           , HSPLIT      
irda\samples\nscirda                          , *           , src\network\irda\miniport\nscirda                 , *           , HSPLIT
irda\samples\blaster                          , *           , src\network\irda\exe\blaster                      , *           , HSPLIT

atm\samples\atmsmpl                           , atmsmple.htm, src\network\ndis\atmsmple                         , *           , HSPLIT      
atm\samples\atmsmpl\inc                       , atmsample.h , src\network\ndis\atmsmple\inc                     , *           , HSPLIT
atm\samples\atmsmpl\app                       , *           , src\network\ndis\atmsmple\app                     , *           , HSPLIT      
atm\samples\atmsmpl\driver                    , *           , src\network\ndis\atmsmple\driver                  , *           , HSPLIT      

ndis\samples\im                               , *           , src\network\ndis\passthru\driver                  , *           , HSPLIT
config\samples\filter                         , *           , src\network\ndis\passthru\notifyob                , *           , HSPLIT

ndis\samples\isdnwan                          , *           , src\network\ndis\isdnwan                          , *           , COPY
ndis\samples\coisdn                           , *           , src\network\ndis\coisdn                           , *           , COPY

ndis\samples\muxim                            , *           , src\network\ndis\mux\driver                       , *           , HSPLIT
config\samples\muxim                          , *           , src\network\ndis\mux\notifyob                     , *           , HSPLIT

ndis\uio\sys                                  , *           , src\network\ndis\ndisuio\sys                      , *           , HSPLIT
ndis\uio\inf                                  , ndisuio.inx , src\network\ndis\ndisuio\sys                      , ndisuio.inf , HSPLIT
inc                                           , nuiouser.h  , src\network\ndis\ndisuio\sys                      , *           , HSPLIT      
ndis\uio                                      , uiosample.htm, src\network\ndis\ndisuio                         , *           , COPY
ndis\uio\test                                 , *           , src\network\ndis\ndisuio\test                     , *           , HSPLIT      

unimodem\inf\usa\INF\samples                  , *           , src\network\modem\infs                            , *           , COPY

sockets\samples\wshsmple                      , *           , src\network\wshsmple                              , *           , COPY
published\inc                                 , wsahelp.w   , src\network\inc                                   , wsahelp.h   , HSPLIT
unimodem\sample\sys                           , *           , src\network\modem\fakemodem                       , *           , HSPLIT
unimodem\sample\inf                           , mdmfake.inx , src\network\modem\fakemodem                       , mdmfake.inf , HSPLIT
unimodem\sample                               , fakemodem.htm , src\network\modem\fakemodem                     , *           , COPY

unimodem\tools\procalc                        , *           , tools\procalc                                     , *           , COPY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\client\rogue\dhcploc.txt ===
dhcploc:

This utility can be used to detect unauthorized DHCP server on a subnet.
It displays the dhcp servers that are active on the subnet and beeps and
sends out alert messages when it sees from any unauthorized dhcp
servers. The usage of this tool is as given below :

dhcploc [-p] [-a:"list-of-alertnames"] [-i:alertinterval] machine-ip-address [list of valid dhcp servers ip addresses]

machine-ip-address - ip address of the machine where the utility is
run. If the machine has multiple adapters then you need to select an
adapter (and the corresponding ip address) that is connected to the
subnet under test.

list of valid dhcp servers - you can specify any number of authorized
dhcp servers' ip addresses here. This utility will be silent if it sees any
packets from these server. However it will display the packets it sees
from these servers unless '-p' option is specified.

-p - if this option is specified then this utility will not display the
packets it sees from the specified authorized dhcp servers.

-a - if this option is specified the tool sends of alert message to
the list of names specified.

-i - this option specifies the alert frequency in seconds.

The format of the output will look like as below :

<time> (IP)<ipaddress offered> <packet type> (S)<server ip address> <***>

*** - indicates unauthorized server.

Examples :

17:34:58 (IP)0.0.0.0        NACK      (S)11.11.31.84         ***
17:36:38 (IP)11.101.190.130 OFFER     (S)11.101.12.226       ***
17:36:38 (IP)11.101.196.231 ACK       (S)11.101.13.53
17:36:53 (IP)11.101.196.231 ACK       (S)11.101.13.53
17:37:05 (IP)11.101.196.234 OFFER     (S)11.101.13.53
17:37:05 (IP)11.101.193.232 OFFER     (S)11.101.12.198
17:37:06 (IP)11.101.190.132 OFFER     (S)11.101.12.226       ***
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\client\dhcpcmd.txt ===
dhcpcmd:

This utility can be used as axillary tool to administrator DHCP servers.
The usage of this tool is as given below :

usage: dhcpcmd <server ip address> <command> [<command parameters>].
commands :
    1. AddIpRange
    2. AddReservedIp
    2. EnumClients
    3. MibCounts
    4. ServerConfig

Commands:

AddIpRange - can be used to add another ip range to an already existing
    scope.

    <parameters> - <scope address> <start ip range> <end ip range>

    Ex : dhcpcmd 127.0.0.1 addiprange 11.101.0.0 11.101.4.1 11.101.4.254

AddReservedIp - can be used to add a reserved ip to an already existing
    scope.

    <parameters> - <scope address> <reserved ip> <hardware string>

    Example: dhcpcmd 127.0.0.1 11.101.0.0 11.101.13.53 08002B30369B

EnumClients - can be used to list out the lease information in different
    format.

    <parameters> - <scope address> [ -v | -h]

    -v - this option will list out detailed lease information.

    -h - this option will list out lease information with hardware info.

    Example : dhcpcmd 127.0.0.1 enumclients 11.101.0.0 -h

MibCounts - displays the current dhcp server statistic information.

ServerConfig - can be used to display current server parameters. Also
    used to set server parameters.

    <parameters> - <config parameter> <value>

    Examples :

        dhcpcmd 127.0.0.1 serverconfig
            - displays current parameters.

        dhcpcmd 127.0.0.1 serverconfig backupinterval 15
            - sets the database backup interval to 15 mins.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\dhcpexim\readme.txt ===
========================================================================
       MICROSOFT FOUNDATION CLASS LIBRARY : DhcpExim
========================================================================


AppWizard has created this DhcpExim application for you.  This application
not only demonstrates the basics of using the Microsoft Foundation classes
but is also a starting point for writing your application.

This file contains a summary of what you will find in each of the files that
make up your DhcpExim application.

DhcpExim.dsp
    This file (the project file) contains information at the project level and
    is used to build a single project or subproject. Other users can share the
    project (.dsp) file, but they should export the makefiles locally.

DhcpExim.h
    This is the main header file for the application.  It includes other
    project specific headers (including Resource.h) and declares the
    CDhcpEximApp application class.

DhcpExim.cpp
    This is the main application source file that contains the application
    class CDhcpEximApp.

DhcpExim.rc
    This is a listing of all of the Microsoft Windows resources that the
    program uses.  It includes the icons, bitmaps, and cursors that are stored
    in the RES subdirectory.  This file can be directly edited in Microsoft
	Visual C++.

DhcpExim.clw
    This file contains information used by ClassWizard to edit existing
    classes or add new classes.  ClassWizard also uses this file to store
    information needed to create and edit message maps and dialog data
    maps and to create prototype member functions.

res\DhcpExim.ico
    This is an icon file, which is used as the application's icon.  This
    icon is included by the main resource file DhcpExim.rc.

res\DhcpExim.rc2
    This file contains resources that are not edited by Microsoft 
	Visual C++.  You should place all resources not editable by
	the resource editor in this file.




/////////////////////////////////////////////////////////////////////////////

AppWizard creates one dialog class:

DhcpEximDlg.h, DhcpEximDlg.cpp - the dialog
    These files contain your CDhcpEximDlg class.  This class defines
    the behavior of your application's main dialog.  The dialog's
    template is in DhcpExim.rc, which can be edited in Microsoft
	Visual C++.


/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named DhcpExim.pch and a precompiled types file named StdAfx.obj.

Resource.h
    This is the standard header file, which defines new resource IDs.
    Microsoft Visual C++ reads and updates this file.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

If your application uses MFC in a shared DLL, and your application is 
in a language other than the operating system's current language, you
will need to copy the corresponding localized resources MFC42XXX.DLL
from the Microsoft Visual C++ CD-ROM onto the system or system32 directory,
and rename it to be MFCLOC.DLL.  ("XXX" stands for the language abbreviation.
For example, MFC42DEU.DLL contains resources translated to German.)  If you
don't do this, some of the UI elements of your application will remain in the
language of the operating system.

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\structure.txt ===
//===============================================================================
// The structure of the various data types (names not accurate)
// Author: RameshV
//================================================================================

M_OPTION (OptionId,Value)       +-    M_CLASSDEFL (Array of ClassId,bytes,name etc)
   |                            +-    M_OPTDEFL   {Array of OptionId,Name etc -- no classId}
   |                            |
M_OPTLIST (array of M_OPTIONS   \
   |                              ------------------M_OPTCLASSDEFL (array of M_OPTDEFL with ClassId per element)
   |
M_OPTCLASS (array of M_OPTLIST with ClassId for each)


M_RESERVATION = IpAddress, HwAddress, State, Additinoal info, M_OPTCLASS

M_RANGE = StartAddress, EndAddress, Mask, State, BITMAP, M_OPTCLASS, Array of M_RESERVATION

M_EXCLUSION = StartAddress, EndAddress

M_SUBNET = Array of M_RANGE, State, SuperScopeId, M_OPTCLASS

M_SUPERSCOPE = Array of M_SUBNET, State, SuperScopeId, M_OPTCLASS

M_SERVER = Array of M_SUPERSCOPE, Array of M_SUBNET (Array of M_RANGE?)
        State, M_OPTCLASS, M_OPTCLASSDEFL, M_CLASSDEFL

M_ROOT = Array of M_SERVER, State, M_OPTCLASS, M_OPTCLASSDEFL, M_CLASSDEFL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\api\calltree.txt ===
AcsLan              
              DumpCcb             
              AcslanDebugPrint    
              QueueCommandCompletion
              NtAcsLan            
NtAcsLan            
              DumpCcb             
              AcslanDebugPrint    
              DlcSetInfo          
              DlcGetInfo          
              DoSyncDeviceIoControl
              GetAdapterNameAndParameters
              OpenDlcApiDriver    
GetCcbStationId     
OpenDlcApiDriver    
GetAdapterNameAndParameters
DoSyncDeviceIoControl
DlcGetInfo          
              DoSyncDeviceIoControl
DlcSetInfo          
              DoSyncDeviceIoControl
DlcCallDriver       
DllEntry            
              GetAcslanDebugFlags 
QueueCommandCompletion
              DoSyncDeviceIoControl
              GetCcbStationId     
GetAcslanDebugFlags 
              DbgPrint            
              AcslanDebugPrint    
AcslanDebugPrint    
              DbgPrint            
AcslanDebugPrintString
              DbgPrint            
DumpCcb             
              MapCcbRetcode       
              AcslanDebugPrint    
MapCcbRetcode       
DumpData            
              AcslanDebugPrintString
              AcslanDebugPrint    
DefaultParameterTableDump
              AcslanDebugPrint    
DumpParameterTableHeader
              AcslanDebugPrint    
DumpBufferCreateParms
              DumpParameterTableHeader
              AcslanDebugPrint    
DumpBufferFreeParms 
              DumpParameterTableHeader
              AcslanDebugPrint    
DumpBufferGetParms  
              DumpParameterTableHeader
              AcslanDebugPrint    
DumpDirInitializeParms
              DumpParameterTableHeader
              AcslanDebugPrint    
DumpDirOpenAdapterParms
              MapEthernetType     
              DumpParameterTableHeader
              AcslanDebugPrint    
MapEthernetType     
DumpDirOpenDirectParms
              DumpParameterTableHeader
              AcslanDebugPrint    
DumpDirReadLogParms 
              MapLogType          
              DumpParameterTableHeader
              AcslanDebugPrint    
MapLogType          
DumpDirSetExceptionFlagsParms
              DumpParameterTableHeader
              AcslanDebugPrint    
DumpDirSetFunctionalAddressParms
              AcslanDebugPrint    
DumpDirSetGroupAddressParms
              AcslanDebugPrint    
DumpDirStatusParms  
              MapAdapterType      
              DumpParameterTableHeader
              AcslanDebugPrint    
MapAdapterType      
DumpDirTimerCancelParms
              AcslanDebugPrint    
DumpDirTimerCancelGroupParms
              AcslanDebugPrint    
DumpDirTimerSetParms
              AcslanDebugPrint    
DumpDlcCloseSapParms
              AcslanDebugPrint    
DumpDlcCloseStationParms
              AcslanDebugPrint    
DumpDlcConnectStationParms
              DumpParameterTableHeader
              AcslanDebugPrint    
DumpDlcFlowControlParms
              MapFlowControl      
              AcslanDebugPrint    
MapFlowControl      
DumpDlcModifyParms  
              DumpParameterTableHeader
              DumpData            
              AcslanDebugPrint    
DumpDlcOpenSapParms 
              DumpParameterTableHeader
              AcslanDebugPrint    
DumpDlcOpenStationParms
              DumpParameterTableHeader
              AcslanDebugPrint    
DumpDlcReallocateParms
              DumpParameterTableHeader
              AcslanDebugPrint    
DumpDlcStatisticsParms
              DumpParameterTableHeader
              AcslanDebugPrint    
DumpReadParms       
              DumpReceiveDataBuffer
              MapDlcStatus        
              MapReadEvent        
              MapOptionIndicator  
              DumpParameterTableHeader
              DumpCcb             
              AcslanDebugPrint    
MapOptionIndicator  
MapReadEvent        
MapDlcStatus        
DumpReceiveParms    
              MapRcvReadOption    
              MapReceiveOptions   
              DumpParameterTableHeader
              AcslanDebugPrint    
MapReceiveOptions   
MapRcvReadOption    
DumpReceiveCancelParms
              AcslanDebugPrint    
DumpTransmitDirFrameParms
              DumpTransmitParms   
              DumpParameterTableHeader
DumpTransmitIFrameParms
              DumpTransmitParms   
              DumpParameterTableHeader
DumpTransmitTestCmdParms
              DumpTransmitParms   
              DumpParameterTableHeader
DumpTransmitUiFrameParms
              DumpTransmitParms   
              DumpParameterTableHeader
DumpTransmitXidCmdParms
              DumpTransmitParms   
              DumpParameterTableHeader
DumpTransmitXidRespFinalParms
              DumpTransmitParms   
              DumpParameterTableHeader
DumpTransmitXidRespNotFinalParms
              DumpTransmitParms   
              DumpParameterTableHeader
DumpTransmitFramesParms
              DumpParameterTableHeader
DumpTransmitParms   
              MapXmitReadOption   
              DumpTransmitQueue   
              DumpData            
              AcslanDebugPrint    
DumpTransmitQueue   
              DumpData            
              AcslanDebugPrint    
MapXmitReadOption   
DumpReceiveDataBuffer
              MapMessageType      
              DumpReceiveDataBuffer
              DumpData            
              AcslanDebugPrint    
MapMessageType      
_except_handler3    
DbgPrint
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\calltree.txt ===
BufferPoolCreate    
              KeInitializeSpinLock
              CreatePacketPool    
              AllocateZeroMemory  
              DeallocateMemory    
              BufferPoolDereference
              BufferPoolExpand    
BufferPoolExpand    
              MmMapLockedPages    
              DbgPrint            
              DeallocatePacket    
              AllocatePacket      
              UnlockAndFreeMdl    
              AllocateProbeAndLockMdl
              AllocateBufferHeader
BufferPoolFreeExtraPages
              DeallocateBuffer    
DeallocateBuffer    
              IoFreeMdl           
              DeallocatePacket    
              UnlockAndFreeMdl    
AllocateBufferHeader
              IoAllocateMdl       
              DeallocatePacket    
              AllocatePacket      
BufferPoolAllocate  
              BuildMappedPartialMdl
              AllocateBufferHeader
BufferPoolDeallocate
              GetBufferHeader     
BufferPoolDeallocateList
BufferPoolBuildXmitBuffers
              IoAllocateMdl       
              DbgPrint            
              BuildMappedPartialMdl
              AllocateProbeAndLockMdl
              GetBufferHeader     
              BufferPoolFreeXmitBuffers
BufferPoolFreeXmitBuffers
              IoFreeMdl           
              UnlockAndFreeMdl    
              GetBufferHeader     
GetBufferHeader     
BufferPoolDereference
              DbgPrint            
              DeletePacketPool    
              DeallocateMemory    
              RemoveFromLinkList  
              DeallocateBuffer    
BufferPoolReference 
              ProbeVirtualBuffer  
ProbeVirtualBuffer  
              DbgPrint            
AllocateProbeAndLockMdl
              MmProbeAndLockPages 
              IoAllocateMdl       
              IoFreeMdl           
              DbgPrint            
BuildMappedPartialMdl
              MmMapLockedPages    
UnlockAndFreeMdl    
              MmUnlockPages       
              IoFreeMdl           
              DbgPrint            
SetIrpCancelRoutine 
              IoAcquireCancelSpinLock
              IoReleaseCancelSpinLock
              @InterlockedExchange
@InterlockedExchange
DlcCancelIrp        
              IoReleaseCancelSpinLock
              DbgPrint            
              MapIoctlCode        
              CancelTransmitIrp   
              CancelCommandIrp    
              @InterlockedExchange
CancelCommandIrp    
              DbgBreakPoint       
              DbgPrint            
              DeallocatePacket    
              GetStation          
              CompleteAsyncCommand
              SearchAndRemoveSpecificCommand
              DlcKillFileContext  
CancelTransmitIrp   
              DbgPrint            
MapIoctlCode        
DriverEntry         
              IoCreateDevice      
              DbgPrint            
              KeInitializeSpinLock
              InitializeMemoryPackage
              LlcInitialize       
              LoadDlcConfiguration
              DlcRegistryInitialization
CreateAdapterFileContext
              CheckMemoryReturned 
              DeletePacketPool    
              CreatePacketPool    
              AllocateZeroMemory  
              DeallocateMemory    
              UnlinkMemoryUsage   
              LinkMemoryUsage     
              UnlinkFileContext   
              LinkFileContext     
              DlcCompleteIoRequest
CleanupAdapterFileContext
              DbgBreakPoint       
              DbgPrint            
              DirCloseAdapter     
              DlcCompleteIoRequest
              DlcKillFileContext  
DlcDriverUnload     
              IoDeleteDevice      
              CheckDriverMemoryUsage
              CheckMemoryReturned 
              LlcTerminate        
              DlcRegistryTermination
CloseAdapterFileContext
              DbgBreakPoint       
              DbgPrint            
              CheckDriverMemoryUsage
              UnlinkFileContext   
              DlcCompleteIoRequest
              DlcKillFileContext  
DlcKillFileContext  
              LlcCloseAdapter     
              LlcDisableAdapter   
              CheckMemoryReturned 
              DeletePacketPool    
              DeallocateMemory    
              UnlinkMemoryUsage   
              PurgeDlcFlowControlQueue
              PurgeDlcEventQueue  
              UnlinkFileContext   
DlcDeviceIoControl  
              DbgBreakPoint       
              MmMapLockedPages    
              DbgPrint            
              DlcCompleteIoRequest
              DlcKillFileContext  
              AllocateProbeAndLockMdl
              BufferPoolDereference
              BufferPoolExpand    
DlcCompleteIoRequest
              @IofCompleteRequest 
              SetIrpCancelRoutine 
              UnlockAndFreeMdl    
LinkFileContext     
UnlinkFileContext   
LlcReceiveIndication
              @ExfInterlockedAddUlong
              DbgPrint            
              LlcTransferData     
              AllocatePacket      
              LlcCopyReceivedLanHeader
              SearchAndRemoveCommandByHandle
              CompleteDlcCommand  
              BufferPoolDeallocateList
              BufferPoolAllocate  
LlcEventIndication  
              LlcCloseStation     
              MakeDlcEvent        
              QueueDlcEvent       
              CloseAllStations    
              InitializeLinkStation
              CompleteDlcCommand  
              BufferPoolFreeExtraPages
LlcCommandCompletion
              LlcCloseStation     
              DeallocatePacket    
              ResetLocalBusyBufferStates
              QueueDlcEvent       
              CompleteLlcObjectClose
              CompleteCloseReset  
              CompleteCloseStation
              CompleteDlcCommand  
              CompleteTransmitCommand
              BufferPoolFreeXmitBuffers
              BufferPoolDeallocateList
CompleteTransmitCommand
              @IofCompleteRequest 
              DbgBreakPoint       
              MmMapLockedPages    
              DbgPrint            
              DeallocatePacket    
              QueueDlcEvent       
              DlcKillFileContext  
              SetIrpCancelRoutine 
              UnlockAndFreeMdl    
CompleteDlcCommand  
              DeallocatePacket    
              CompleteAsyncCommand
              MakeDlcEvent        
GetDlcErrorCounters 
              DbgPrint            
              LlcNdisRequest      
DlcQueryInformation 
              LlcQueryInformation 
              GetStation          
              GetLinkStation      
              GetOpenSapAndStationCount
              GetDlcErrorCounters 
DlcSetInformation   
              LlcSetInformation   
              GetStation          
              SetupGroupSaps      
GetOpenSapAndStationCount
SetupGroupSaps      
              LlcCloseStation     
              LlcOpenStation      
              AllocateZeroMemory  
              DeallocateMemory    
DlcOpenSap          
              DbgPrint            
              LlcReferenceObject  
              LlcCloseStation     
              LlcOpenStation      
              DeallocatePacket    
              AllocatePacket      
              LlcSetInformation   
DirOpenDirect       
              LlcReferenceObject  
              LlcOpenStation      
              DeallocatePacket    
              AllocatePacket      
DlcOpenLinkStation  
              LlcSetInformation   
              GetSapStation       
              InitializeLinkStation
InitializeLinkStation
              LlcReferenceObject  
              DeallocatePacket    
              AllocatePacket      
              LlcBindLinkStation  
              LlcOpenLinkStation  
DlcCloseStation     
              DbgPrint            
              AllocatePacket      
              GetStation          
              CompleteAsyncCommand
              CompleteDirectOutIrp
              SearchReadCommandForClose
              CloseAnyStation     
CloseAllStations    
              LlcNdisReset        
              AllocatePacket      
              DecrementCloseCounters
              SearchReadCommandForClose
              CloseAnyStation     
CloseAnyStation     
              DbgPrint            
              CloseStation        
              CloseAnyStation     
CloseStation        
              DbgPrint            
              LlcCloseStation     
              AllocatePacket      
              LlcDisconnectStation
              CompleteLlcObjectClose
              CompleteCloseStation
CompleteCloseStation
              @ExfInterlockedAddUlong
              LlcCloseStation     
              DeallocatePacket    
              RemoveFromLinkList  
              DecrementCloseCounters
              CleanUpEvents       
              CloseStation        
              SetupGroupSaps      
CompleteCloseReset  
              DbgBreakPoint       
              DbgPrint            
              DeallocatePacket    
              CompleteAsyncCommand
              CancelDlcCommand    
              AbortCommand        
              MakeDlcEvent        
              CompleteDirectOutIrp
              DlcKillFileContext  
              BufferPoolDeallocateList
CleanUpEvents       
              DeallocatePacket    
              AllocatePacket      
              AbortCommand        
              SearchAndRemoveAnyCommand
SearchReadCommandForClose
              AllocatePacket      
              SearchAndRemoveCommandByHandle
              SearchAndRemoveCommand
CompleteLlcObjectClose
              LlcDereferenceObject
DecrementCloseCounters
              CompleteCloseReset  
CompleteDirectOutIrp
              MmMapLockedPages    
QueueDlcEvent       
              DbgPrint            
              DeallocatePacket    
              SearchAndRemoveCommandByHandle
              SearchAndRemoveCommand
MakeDlcEvent        
              DbgPrint            
              AllocatePacket      
              QueueDlcEvent       
IsCommandOnList     
SearchAndRemoveCommand
              DbgPrint            
SearchAndRemoveAnyCommand
              DbgPrint            
              SearchAndRemoveCommandByHandle
SearchAndRemoveCommandByHandle
              DbgPrint            
SearchAndRemoveSpecificCommand
              DbgPrint            
QueueDlcCommand     
              DbgPrint            
              DeallocatePacket    
              AllocatePacket      
              SearchAndRemoveCommand
AbortCommand        
              DbgPrint            
              CancelDlcCommand    
              SearchAndRemoveAnyCommand
CancelDlcCommand    
              DbgPrint            
              DeallocatePacket    
              CompleteAsyncCommand
PurgeDlcEventQueue  
              DbgPrint            
              DeallocatePacket    
PurgeDlcFlowControlQueue
              DeallocatePacket    
DlcReceiveRequest   
              DbgPrint            
              LlcSetDirectOpenOptions
              LlcFlowControl      
              GetStation          
              QueueDlcCommand     
              CompleteLlcObjectClose
              SetIrpCancelRoutine 
ReceiveCompletion   
              MmMapLockedPages    
              DbgPrint            
              CompleteAsyncCommand
              CreateBufferChain   
              MakeDlcEvent        
              UnlockAndFreeMdl    
DlcReadRequest      
              DbgBreakPoint       
              DbgPrint            
              GetStation          
              QueueDlcCommand     
              IsCommandOnList     
              SetIrpCancelRoutine 
ReadCompletion      
              @IofCompleteRequest 
              DbgBreakPoint       
              MmMapLockedPages    
              DbgPrint            
              SwapMemCpy          
              CreateBufferChain   
              CompleteCompletionPacket
              DlcKillFileContext  
              SetIrpCancelRoutine 
              UnlockAndFreeMdl    
CompleteCompletionPacket
              DeallocatePacket    
              CreateBufferChain   
CreateBufferChain   
DlcReceiveCancel    
              GetStation          
              CancelDlcCommand    
              SearchAndRemoveAnyCommand
DlcRegistryInitialization
              LlcInitUnicodeString
DlcRegistryTermination
              LlcFreeUnicodeString
LoadDlcConfiguration
LoadAdapterConfiguration
              DbgPrint            
              DeallocateMemory    
              AllocateMemory      
              GetAdapterParameters
GetAdapterParameters
              SetRegistryParameter
              GetRegistryParameter
              OpenDlcAdapterRegistryHandle
              OpenDlcRegistryHandle
OpenDlcRegistryHandle
              DbgPrint            
OpenDlcAdapterRegistryHandle
              DbgPrint            
GetRegistryParameter
              DbgPrint            
              DlcpGetParameter    
              SetRegistryParameter
SetRegistryParameter
              DbgPrint            
DlcpGetParameter    
              DbgPrint            
DlcBufferFree       
              ResetLocalBusyBufferStates
              BufferPoolDereference
              BufferPoolDeallocate
DlcBufferGet        
              BufferPoolDereference
              BufferPoolDeallocateList
              BufferPoolAllocate  
              BufferPoolExpand    
DlcBufferCreate     
              BufferPoolReference 
              BufferPoolCreate    
DlcConnectStation   
              AllocatePacket      
              LlcConnectStation   
              GetLinkStation      
              CompleteLlcObjectClose
DlcFlowControl      
              AllocatePacket      
              LlcFlowControl      
              GetStation          
              ResetLocalBusyBufferStates
              CompleteLlcObjectClose
ResetLocalBusyBufferStates
              @ExfInterlockedAddUlong
              DeallocatePacket    
              LlcFlowControl      
              GetLinkStation      
              CompleteLlcObjectClose
              BufferPoolDereference
              BufferPoolExpand    
DlcReallocate       
              GetSapStation       
DlcReset            
              AllocatePacket      
              GetSapStation       
              DecrementCloseCounters
              CloseAnyStation     
              CloseAllStations    
DirSetExceptionFlags
CompleteAsyncCommand
              DbgBreakPoint       
              DbgPrint            
              DlcCompleteIoRequest
              DlcKillFileContext  
GetLinkStation      
              GetStation          
GetSapStation       
GetStation          
DlcReadCancel       
              AbortCommand        
DirOpenAdapter      
              LlcOpenAdapter      
              LlcSetInformation   
              LlcQueryInformation 
              GetDlcErrorCounters 
              BufferPoolReference 
              BufferPoolDereference
DirCloseAdapter     
              DbgPrint            
              LlcResetBroadcastAddresses
              CloseAllStations    
CompleteDirCloseAdapter
              DbgBreakPoint       
              DbgPrint            
              LlcDisableAdapter   
              CompleteAsyncCommand
              DlcCompleteIoRequest
              DlcKillFileContext  
              BufferPoolDereference
DlcCompleteCommand  
              MakeDlcEvent        
DirTimerSet         
              AllocatePacket      
DirTimerCancelGroup 
              AbortCommandsWithFlag
DirTimerCancel      
              SearchTimerCommand  
              CancelDlcCommand    
SearchTimerCommand  
AbortCommandsWithFlag
              DeallocatePacket    
              SearchTimerCommand  
              CompleteAsyncCommand
DlcTransmit         
              MmMapLockedPages    
              LlcSendI            
              LlcSendU            
              DeallocatePacket    
              AllocatePacket      
              LlcSleep            
              GetStation          
              CompleteLlcObjectClose
              CompleteCloseStation
              CompleteTransmitCommand
              SetIrpCancelRoutine 
              BufferPoolBuildXmitBuffers
LlcBuildAddress     
LlcBuildAddressFromLanHeader
              LlcBuildAddress     
LlcGetMaxInfoField  
LlcCopyReceivedLanHeader
              SwapMemCpy          
CopyLanHeader       
              SwapMemCpy          
LlcQueryInformation 
              SwapMemCpy          
              LlcCopyReceivedLanHeader
LlcSetInformation   
              CopyNonZeroBytes    
              CopyLinkParameters  
              CheckLinkParameters 
              SetLinkParameters   
              SwapMemCpy          
              UpdateGroupAddress  
              UpdateFunctionalAddress
UpdateFunctionalAddress
              KeWaitForSingleObject
              KeReleaseMutex      
              SetNdisParameter    
UpdateGroupAddress  
              SetNdisParameter    
              UpdateFunctionalAddress
SwapMemCpy          
RemoveFromLinkList  
LlcSleep            
              KeDelayExecutionThread
LlcInitUnicodeString
              AllocateZeroMemory  
LlcFreeUnicodeString
              DeallocateMemory    
LlcOpenLinkStation  
              TerminateTimer      
              DeallocatePacket    
              AllocatePacket      
              SetLinkParameters   
              SearchLinkAddress   
              SwapMemCpy          
              CopyLanHeader       
              LlcBuildAddressFromLanHeader
              LlcBuildAddress     
LlcBindLinkStation  
LlcConnectStation   
              RunInterlockedStateMachineCommand
              InitiateAsyncLinkCommand
              LlcGetMaxInfoField  
              LlcBuildAddress     
InitiateAsyncLinkCommand
              QueueCommandCompletion
              RunStateMachine     
              DisableSendProcess  
              BackgroundProcessAndUnlock
LlcDisconnectStation
              InitiateAsyncLinkCommand
LlcFlowControl      
              BackgroundProcess   
              LinkFlowControl     
LinkFlowControl     
              RunInterlockedStateMachineCommand
SearchLinkAddress   
SetLinkParameters   
              InitializeLinkTimers
              CopyLinkParameters  
              LlcGetMaxInfoField  
CheckLinkParameters 
CopyLinkParameters  
              CopyNonZeroBytes    
CopyNonZeroBytes    
RunInterlockedStateMachineCommand
              RunStateMachine     
LlcInitialize       
              MmBuildMdlForNonPagedPool
              KeInitializeMutex   
              KeInitializeSemaphore
              IoAllocateMdl       
              IoFreeMdl           
              KeInitializeSpinLock
              LlcInitializeTimerSystem
LlcTerminate        
              IoFreeMdl           
              LlcTerminateTimerSystem
InitializeMemoryPackage
              KeInitializeSpinLock
              ReportSwitchSettings
              LinkMemoryUsage     
PullEntryList       
LinkMemoryUsage     
UnlinkMemoryUsage   
              CheckMemoryReturned 
              PullEntryList       
ChargeNonPagedPoolUsage
              DbgBreakPoint       
              DbgPrint            
              DumpMemoryUsage     
RefundNonPagedPoolUsage
              DbgBreakPoint       
              DbgPrint            
              CheckEntryOnList    
              DumpMemoryUsage     
AllocateMemory      
              ExAllocatePoolWithTag
              x86SleazeCallersAddress
              UpdateCounter       
              ChargeNonPagedPoolUsage
DeallocateMemory    
              ExFreePool          
              DbgBreakPoint       
              DbgPrint            
              CheckEntryOnList    
              UpdateCounter       
              MemoryAllocationError
              RefundNonPagedPoolUsage
AllocateZeroMemory  
              ExAllocatePoolWithTag
              x86SleazeCallersAddress
              UpdateCounter       
              ChargeNonPagedPoolUsage
CreatePacketPool    
              DbgPrint            
              KeInitializeSpinLock
              DumpPool            
              AllocateZeroMemory  
              DeallocateMemory    
              LinkMemoryUsage     
DeletePacketPool    
              DbgBreakPoint       
              DbgPrint            
              x86SleazeCallersAddress
              DumpPool            
              CheckMemoryReturned 
              DeallocateMemory    
              UnlinkMemoryUsage   
AllocatePacket      
              DbgBreakPoint       
              DbgPrint            
              x86SleazeCallersAddress
              DumpPacketHead      
              DumpPoolStats       
              AllocateZeroMemory  
DeallocatePacket    
              DbgBreakPoint       
              DbgPrint            
              x86SleazeCallersAddress
              DumpPool            
CheckMemoryReturned 
              DbgBreakPoint       
              DbgPrint            
              DumpMemoryUsage     
CheckDriverMemoryUsage
              DbgBreakPoint       
              DbgPrint            
              DumpMemoryMetrics   
MemoryAllocationError
              DbgBreakPoint       
              DbgPrint            
              DumpMemoryMetrics   
UpdateCounter       
              MemoryCounterOverflow
MemoryCounterOverflow
              DbgPrint            
              DumpMemoryMetrics   
DumpMemoryMetrics   
              DbgPrint            
              DumpMemoryUsageList 
DumpPoolStats       
              DbgPrint            
              DumpMemoryUsage     
              MapObjectId         
MapObjectId         
DumpPool            
              DumpPoolList        
              DumpPoolStats       
DumpPoolList        
              DbgPrint            
              DumpPacketHead      
DumpPacketHead      
              DbgPrint            
DumpMemoryUsageList 
              DbgPrint            
              DumpMemoryUsage     
DumpMemoryUsage     
              DbgPrint            
              MapObjectId         
x86SleazeCallersAddress
CheckEntryOnList    
              DbgBreakPoint       
              DbgPrint            
ReportSwitchSettings
              DbgPrint            
LlcOpenAdapter      
              KeReleaseSemaphore  
              KeResetEvent        
              KeWaitForSingleObject
              DbgBreakPoint       
              IoFreeMdl           
              DbgPrint            
              StartTimer          
              InitializeTimer     
              UnicodeStringCompare
              WaitAsyncOperation  
              SetNdisParameter    
              GetNdisParameter    
              InitNdisPackets     
              CheckMemoryReturned 
              DeletePacketPool    
              CreatePacketPool    
              AllocateZeroMemory  
              DeallocateMemory    
              UnlinkMemoryUsage   
              LinkMemoryUsage     
              LlcInitUnicodeString
              GetAdapterParameters
              LoadAdapterConfiguration
LlcNdisOpenAdapterComplete
              KeSetEvent          
LlcDisableAdapter   
              TerminateTimer      
LlcCloseAdapter     
              KeReleaseSemaphore  
              KeWaitForSingleObject
              DbgBreakPoint       
              IoFreeMdl           
              DbgPrint            
              PurgeLlcEventQueue  
              WaitAsyncOperation  
              CheckMemoryReturned 
              DeletePacketPool    
              DeallocateMemory    
              UnlinkMemoryUsage   
              LlcSleep            
              RemoveFromLinkList  
LlcResetBroadcastAddresses
              UpdateGroupAddress  
              UpdateFunctionalAddress
InitNdisPackets     
              MmBuildMdlForNonPagedPool
              IoAllocateMdl       
LlcNdisCloseComplete
              KeSetEvent          
NdisStatusHandler   
              AllocatePacket      
GetNdisParameter    
              SyncNdisRequest     
SetNdisParameter    
              SyncNdisRequest     
SyncNdisRequest     
              WaitAsyncOperation  
WaitAsyncOperation  
              KeWaitForSingleObject
LlcNdisRequest      
              SyncNdisRequest     
LlcNdisRequestComplete
              KeSetEvent          
LlcNdisReset        
              LlcNdisResetComplete
LlcNdisResetComplete
UnicodeStringCompare
PurgeLlcEventQueue  
              DbgPrint            
              DeallocatePacket    
LlcOpenStation      
              SetNdisParameter    
              AllocateZeroMemory  
              DeallocateMemory    
LlcCloseStation     
              TerminateTimer      
              RunStateMachine     
              SendLlcFrame        
              DisableSendProcess  
              LlcDereferenceObject
              AllocatePacket      
              RunInterlockedStateMachineCommand
              SearchLinkAddress   
              RemoveFromLinkList  
CompleteClose       
              QueueCommandCompletion
              CancelTransmitCommands
              DeallocatePacket    
              DeallocateMemory    
CancelTransmitCommands
              StopSendProcess     
              CancelTransmitsInQueue
CancelTransmitsInQueue
              DeallocatePacket    
LlcSetDirectOpenOptions
CompleteObjectDelete
              BackgroundProcessAndUnlock
              CompletePendingLlcCommand
CompletePendingLlcCommand
              CancelTransmitCommands
              CompleteClose       
LlcDereferenceObject
              @InterlockedDecrement
              CompleteObjectDelete
@InterlockedDecrement
LlcReferenceObject  
              @InterlockedIncrement
@InterlockedIncrement
LlcNdisReceiveIndication
              RespondTestOrXid    
              ProcessType2_Frames 
              MakeRcvIndication   
              ProcessType1_Frames 
LlcNdisReceiveComplete
              BackgroundProcessAndUnlock
ProcessType1_Frames 
              RespondTestOrXid    
              FramingDiscoveryCacheHit
              ProcessNewSabme     
              MakeRcvIndication   
MakeRcvIndication   
verify_pack         
ProcessType2_Frames 
              StopTimer           
              SendAck             
              UpdateVa            
              RunStateMachine     
              SendLlcFrame        
              verify_pack         
              ProcessType1_Frames 
ProcessNewSabme     
              RunStateMachine     
              LlcOpenLinkStation  
LlcTransferData     
              MmMapLockedPages    
              safe_memcpy         
LlcNdisTransferDataComplete
safe_memcpy         
FramingDiscoveryCacheHit
              KeQueryTickCount    
RunSendTaskAndUnlock
              SendNdisPacket      
BackgroundProcessAndUnlock
              RunSendTaskAndUnlock
              DeallocatePacket    
BackgroundProcess   
              BackgroundProcessAndUnlock
BackgroundProcessWithinLock
LlcNdisSendComplete 
              CompleteSendAndLock 
              RunSendTaskAndUnlock
GetI_Packet         
              StopTimer           
              StartTimer          
              RunStateMachine     
              StopSendProcess     
              BackgroundProcessAndUnlock
StartSendProcess    
EnableSendProcess   
              StartSendProcess    
StopSendProcess     
DisableSendProcess  
              StopSendProcess     
BuildDirOrU_Packet  
SendLlcFrame        
              CheckAndDuplicatePacket
              DeallocatePacket    
              AllocatePacket      
GetLlcCommandPacket 
SendNdisPacket      
              LlcNdisSendComplete 
              CopyLanHeader       
CompleteSendAndLock 
              IoFreeMdl           
              StartSendProcess    
              BackgroundProcess   
              CompletePendingLlcCommand
              DeallocatePacket    
              DeallocateMemory    
RespondTestOrXid    
              MmBuildMdlForNonPagedPool
              IoAllocateMdl       
              IoFreeMdl           
              QueuePacket         
              DeallocatePacket    
              AllocatePacket      
              AllocateZeroMemory  
              DeallocateMemory    
              LlcBuildAddressFromLanHeader
LlcSendU            
              CheckAndDuplicatePacket
              RunSendTaskAndUnlock
LlcSendI            
              StartSendProcess    
              RunSendTaskAndUnlock
QueuePacket         
CheckAndDuplicatePacket
              QueuePacket         
              AllocatePacket      
RunStateMachine     
              StopTimer           
              StartTimer          
              InitializeLinkTimers
              SendAck             
              AdjustWw            
              UpdateVaChkpt       
              UpdateVa            
              ResendPackets       
              SaveStatusChangeEvent
              SendLlcFrame        
              DisableSendProcess  
              EnableSendProcess   
SaveStatusChangeEvent
              InitializeLinkTimers
              QueueCommandCompletion
              CancelTransmitCommands
              AllocatePacket      
ResendPackets       
              DynamicWindowAlgorithm
              StartSendProcess    
UpdateVa            
              StopTimer           
              StartTimer          
              DynamicWindowAlgorithm
UpdateVaChkpt       
              StopTimer           
              StartTimer          
              DynamicWindowAlgorithm
              ResendPackets       
AdjustWw            
              DynamicWindowAlgorithm
SendAck             
              StopTimer           
              StartTimer          
              SendLlcFrame        
QueueCommandCompletion
DynamicWindowAlgorithm
ScanTimersDpc       
              KeSetTimer          
              StopTimer           
              StartTimer          
              RunStateMachine     
              BackgroundProcessAndUnlock
              DeallocateMemory    
              RemoveFromLinkList  
LlcInitializeTimerSystem
              KeInitializeDpc     
              KeInitializeTimer   
              KeSetTimer          
LlcTerminateTimerSystem
              KeCancelTimer       
              LlcSleep            
TerminateTimer      
              StopTimer           
              DeallocateMemory    
              RemoveFromLinkList  
InitializeLinkTimers
              InitializeTimer     
InitializeTimer     
              StartTimer          
              TerminateTimer      
              AllocateZeroMemory  
StartTimer          
StopTimer           
KeInitializeSpinLock
DbgPrint            
MmMapLockedPages    
IoFreeMdl           
IoAllocateMdl       
_global_unwind2     
_local_unwind2      
_abnormal_termination
_except_handler3    
              _global_unwind2     
_seh_longjmp_unwind 
              _local_unwind2      
MmProbeAndLockPages 
MmUnlockPages       
IoReleaseCancelSpinLock
IoAcquireCancelSpinLock
DbgBreakPoint       
IoCreateDevice      
IoDeleteDevice      
@IofCompleteRequest 
@ExfInterlockedAddUlong
KeReleaseMutex      
KeWaitForSingleObject
KeDelayExecutionThread
KeInitializeSemaphore
KeInitializeMutex   
MmBuildMdlForNonPagedPool
ExAllocatePoolWithTag
ExFreePool          
KeResetEvent        
KeReleaseSemaphore  
KeSetEvent          
KeQueryTickCount    
KeSetTimer          
KeInitializeTimer   
KeInitializeDpc     
KeCancelTimer       
RtlUnwind
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\driver\dlcpnp.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft DLC PnP Design Document Title _PID_GUIDDLC PnP Design Document DLC PnP Scott Holden STREAMS, ISOTP, PnP, design, IAYF, Windows, NT This document describes the changes required to implement PnP functionality in the Windows 2000 DLC transport provider. nt5-new Scott Holden Microsoft Word 9.0@@@@@@ @@@@@@ Z(e82 R2f[,2S`B:q G3_Pr o<n"! Fo>aL cZY?I K3L$G!3 <S+Cs> I>`lUZ Zale1 MuI?y Ils|g Tq"FJ5 'cbmh |nteQ bWW`= 4]qg) 0.;s7H 5 Yiek& T]TfO ucN[0 >7'$f{MM X;&FL1 r}#A? v|fHQ6 H9&a]l l-b;  /.*mq Btjj#. J7&$.(I= e>B9OF Fq*E_ X]lTU m]rzv ;;CE; 4gXY` 2K4f>7[v A)zzn$} =8[]<. _P]<Iu 2M9^^^ P4KV>Sz JK\A3 i;KG\SS 9C'MK w/\rdMicrosoft Word Picture MSWordDoc Word.Picture.8Microsoft Title _PID_GUIDScott Holden Normal Scott Holden Microsoft Word 9.0bjbj  DLCAPI.dll DLC.sys KERNEL Driver N Driver 1Microsoft Word Picture MSWordDoc Word.Picture.8Microsoft Title _PID_GUIDScott Holden Normal Scott Holden Microsoft Word 9.0bjbj  BINDING_CONTEXT  z BINDING_CONTEXT  a ADAPTER_CONTEXT  0 ADAPTER_CONTEXT  N BINDING_CONTEXT  A Adapter ListMicrosoft Word Picture MSWordDoc Word.Picture.8Microsoft Title _PID_GUIDScott Holden Normal Scott Holden Microsoft Word 9.0bjbj  Open Adapter Complete IOCTL_DLC_OPEN_ADAPTER completes (Creates BINDING_CONTEXT associated with ADAPTER_CONTEXT) IOCTL_DLC_OPEN_ADAPTER (blocks until PnP Binds Complete) Adapter Configuration Requests For each adapter indicated to DLC DLC Client NdisRegisterProtocol Bind Notifications PnP Binds Complete NdisOpenAdapterMicrosoft Word Picture MSWordDoc Word.Picture.8Microsoft Title _PID_GUIDScott Holden Normal Scott Holden Microsoft Word 9.0bjbj  Send Data Close Adapter Complete Send Complete NdisSend Send Data Send Data failure Unbind Adapter Complete Close Adapter Unbind Adapter (wait for sends/request to complete) DLC clientMicrosoft Word Picture MSWordDoc Word.Picture.8Microsoft Title _PID_GUIDScott Holden Normal Scott Holden Microsoft Word 9.0bjbj  vpqrQ Send Data Open Adapter Complete Send Complete NdisSend Send Data failure Open Adapter Bind Adapter Adapter Configuration Requests Bind Adapter Complete DLC Client Send Databjbj  Windows 2000 info subject DLC PnP title  DLC PnP Design Document info filename \* lower dlcpnp Windows NT Design Team author  Scott Holden Version 0. revnum  savedate \@ "MMMM d, yyyy" February 5, 1999 Distribution: Microsoft Internal Distribution  Copyright Microsoft Corporation, 1998. All Rights Reserved Microsoft Confidential Printed on  date \@ M/d/yy 2/10/99 time \@ "h:mm AM/PM" 10:08 AM Note: This documentation is an early release of the final product documentation. It is meant to accompany software that is still in development. Some of the information in this documentation may be inaccurate or may not be an accurate representation of the functionality of the final retail product. Microsoft assumes no responsibility for any damages that might occur either directly or indirectly from these inaccuracies. Contents toc \o DLC Overview  PAGEREF _Toc443275531 \h   PAGEREF _Toc443275533 \h  Current Architecture  PAGEREF _Toc443275534 \h  Proposed Architecture  PAGEREF _Toc443275535 \h  Implementation  PAGEREF _Toc443275536 \h  Data Structures  PAGEREF _Toc443275537 \h  3.1.1 ADAPTER_CONTEXT  PAGEREF _Toc443275538 \h  3.1.2 BINDING_CONTEXT  PAGEREF _Toc443275539 \h  3.1.3 Locking Strategy  PAGEREF _Toc443275540 \h  Timing  PAGEREF _Toc443275541 \h  3.2.1 Boot Timing  PAGEREF _Toc443275542 \h  3.2.2 Unbind Timing  PAGEREF _Toc443275543 \h  3.2.3 Re-bind Timing  PAGEREF _Toc443275544 \h  Testing Requirements  PAGEREF _Toc443275545 \h  seq chapt \c  <> 0 "Chapter  seq chapt \c : " "" title  DLC PnP Design Document comments  This document describes the changes required to implement PnP functionality in the Windows 2000 DLC transport provider. DLC Overview DLC is a legacy protocol used for printer servers and SNA server. The DLC transport provider exports a private interface at the upper layer (exported via dlcapi.dll) and an NDIS interface for using NICs. DLC Architecture  EMBED Word.Picture.8   The current DLC transport driver is an NDIS 3.0 protocol driver and does not support any PnP features. The purpose of this design document is to describe the changes necessary to support PnP in the DLC transport provider to support the following goals: Ensure that the PnP changes in the DLC transport provider are transparent to DLC clients   such as the printer port monitor. Allow re-balancing of NICs below DLC. Allow the NIC to be  disconnected  via the Network Connection UI. Restrict changes to NDIS protocol layer of DLC. Non-goals: t need to be able to uninstall DLC without re-booting machine. In order to achieve these goals, adapter bindings are transparent to the upper layers of DLC. DLC                A DLC client explicitly opens and closes adapters via the following ioctls: IOCTL_DLC_OPEN_ADAPTER and IOCTL_DLC_CLOSE_ADAPTER. Both the current architecture for binding adapters and the proposed PnP solution are described below. Current Architecture When DLC receives an IOCTL_DLC_OPEN_ADAPTER, DLC looks through a list of active adapters. If the adapter is not found, then DLC opens the adapter, configures the adapter, and adds the adapter to the list of active adapters. It also creates a binding context associated with the adapter context. If the adapter is found in the list of active adapters, DLC references the adapter and creates a new binding context. Current Data Structure Architecture  EMBED Word.Picture.8   Each ADAPTER_CONTEXT represents an open NDIS adapter. Each BINDING_CONTEXT represents a binding to each adapter via an IOCTL_DLC_OPEN_ADAPTER. When the last BINDING_CONTEXT is removed from the ADAPTER_CONTEXT, the adapter is closed and the context is freed. Proposed Architecture Making the DLC transport provider an NDIS 4.0 Protocol Driver and providing NDIS bind, unbind and PnP handlers supports the above stated design goals. The above data structure architecture (depicted in   REF _Ref440089988 \w \h  Figure 2 ) is maintained, with new data members added to the ADAPTER_CONTEXT data structure to maintain binding state. The basic sequence of events (described in more detail later by timing diagrams): After DLC registers as an NDIS 4.0 protocol driver, NDIS indicates all adapter bindings. Each indication results in an open ADAPTER_CONTEXT structure being allocated. DLC calls NdisOpenAdapter for each binding indication and configures each adapter. At this point, the adapter state is bound. Once the adapter context is created it is persistent even when the NDIS binding handle is closed. Each DLC client will call down to the DLC transport provider with IOCTL_DLC_OPEN_ADAPTER. This will create a new BINDING_CONTEXT and associate the binding context with the context for adapter. If the ADAPTER_CONTEXT does not exist, the open request fails with a DLC_STATUS_ADAPTER_NOT_INSTALLED error. If the DLC client calls down to the DLC transport provider with IOCTL_DLC_CLOSE_ADAPTER, the binding context is disassociated from the adapter context and all structures related the binding context cleaned up. The adapter context remains in tact. If NDIS indicates an unbind for an adapter, the adapter context remains in the list, but the adapter NDIS binding handle is closed and the state changed to unbound. All data transmit and NDIS requests will fail until the adapter is re-bound. It is expected that these transmit and request failures will propagate up through the DLC transport provider and DLC will time-out/fail appropriately. If NDIS indicates a re-bind for an adapter, the adapter context is found in the list and the adapter is re-opened and configured. The adapter state is changed to bound. All transmits and requests operate normally again. Implementation Data Structures The following data structures are not complete as defined, but instead only illustrate the high level design of the data with respect to the new data members added to the ADAPTER_CONTEXT structure. ADAPTER_CONTEXT typedef struct _ADAPTER_CONTEXT // Singly-linked list of all ADAPTER_CONTEXT structures representing all // adapter bindings indicated by NDIS. struct _ADAPTER_CONTEXT *pNext; // NDIS binding handle. NDIS_HANDLE NdisBindingHandle; // Singly-linked list of all BINDING_CONTEXT structures associated with this adapter. PBINDING_CONTEXT pBindings; // Plus other configuration and resources... // Members added to support PnP: // Reference count to protect NdisBindingHandle doesn t go away while in use. // Uses InterlockXxx to protect count. When the reference count becomes zero, // a delete handler is called. The delete handler will set the CloseAdapterEvent. // Thus the unbind handler will wait until the CloseAdapterEvent is set to // ensure that all references are removed. REF_CNT  AdapterRefCnt; KEVENT   CloseAdapterEvent; // Maintain binding state. This is used in conjunction with the reference count  // to protect the NdisBindingHandle (instead of using a spinlock). LONG BindState;         #define BIND_STATE_UNBOUND      1         #define BIND_STATE_UNBINDING    2         #define BIND_STATE_BOUND        3 } ADAPTER_CONTEXT, *PADAPTER_CONTEXT; BINDING_CONTEXT typedef struct _BINDING_CONTEXT // Singly-linked list of all BINDING_CONTEXT structures associated with a particular // adapter (ADAPTER_CONTEXT). Each BINDING_CONTEXT corresponds to an  // IOCTL_DLC_OPEN_ADAPTER. struct _BINDING_CONTEXT *pNext; // Pointer to parent ADAPTER_CONTEXT. struct _ADAPTER_CONTEXT *pAdapterContext; // Plus other configuration and resources... } BINDING_CONTEXT, *PBINDING_CONTEXT; Locking Strategy There is a global semaphore for protecting the ADAPTER_CONTEXT list and the BINDING_CONTEXT lists for each adapter context. An interlocked reference count and interlocked state are used to protect the NDIS binding handle from going away while the driver is about to call NdisSend, NdisRequest or when NDIS calls the protocol receive handler. This is to ensure minimal latency in the send path. Timing Boot Timing Once DLC is initialized and has registered as an NDIS 4.0 protocol driver, NDIS will indicate all adapter bindings to DLC.  To ensure that all adapters are initialized before allowing an IOCTL_DLC_OPEN_ADAPTER, the call is blocked until NDIS indicates that all adapter bindings are completed (PnP Binds Complete event to PnP event handler).  EMBED Word.Picture.8   Unbind Timing Once an adapter has been opened, it may receive an unbind notification. When an adapter is unbound, the NDIS binding handle in the adapter context is invalidated, the adapter is closed, and all subsequent send and configuration requests are failed. The state of the adapter context is changed to unbound until NDIS indicates a re-bind of the adapter. This will cause all subsequent IOCTL_DLC_OPEN_ADAPTER requests to fail until the adapter is re-bound. An interlocked reference count and state is used to prevent the NDIS binding handle from being invalidated while in use. When this reference count goes to zero, the adapter is closed and the unbind is completed.  EMBED Word.Picture.8   Re-bind Timing When an adapter is re-bound, the adapter NDIS binding handle is re-opened, the adapter is configured and state is changed to bound. The NDIS binding handle is now valid again and send/configuration requests may proceed normally.  EMBED Word.Picture.8   Testing Requirements In addition to current tests and BVTs, PnP tests will be required to test functionality of binding/unbinding to adapters dynamically. This includes connecting/disconnecting adapters This section needs to be expanded. Index INDEX \h "A" Error! No index entries found. Microsoft Confidential ref ProjectName Windows  title  DLC PnP Design Document Draft:  ref Version Version 0.19 2/10/99 SYMBOL 227 \f "Symbol"  Microsoft Corporation, 1998. All Rights Reserved. Contents -  Microsoft Confidential Microsoft Confidential ref ProjectName \* mergeformat Windows  title  DLC PnP Design Document Draft,  ref Version \* mergeformat Version 0.19 savedate  2/5/99 5:54 PM rinted  date \@ "M/d/yy h:mm AM/PM" 2/10/99 10:08 AM Microsoft Confidential jnHe:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\idl\cmnicfg.xml ===
<?xml version="1.0"?>
<scpd xmlns="urn:schemas-upnp-org:service-1-0">
	<specVersion>
		<major>1</major>
		<minor>0</minor>
	</specVersion>
	<actionList>
    <action>
      <name>GetCommonLinkProperties</name>
      <argumentList>
        <argument>
          <name>NewWANAccessType</name>
          <direction>out</direction>
          <relatedStateVariable>WANAccessType</relatedStateVariable>
        </argument>
        <argument>
          <name>NewLayer1UpstreamMaxBitRate</name>
          <direction>out</direction>
          <relatedStateVariable>Layer1UpstreamMaxBitRate</relatedStateVariable>
        </argument>
        <argument>
          <name>NewLayer1DownstreamMaxBitRate</name>
          <direction>out</direction>
          <relatedStateVariable>Layer1DownstreamMaxBitRate</relatedStateVariable>
        </argument>
        <argument>
          <name>NewPhysicalLinkStatus</name>
          <direction>out</direction>
          <relatedStateVariable>PhysicalLinkStatus</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
    <name>GetTotalBytesSent</name>
      <argumentList>
        <argument>
          <name>NewTotalBytesSent</name>
          <direction>out</direction>
          <relatedStateVariable>TotalBytesSent</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
    <name>GetTotalBytesReceived</name>
      <argumentList>
        <argument>
          <name>NewTotalBytesReceived</name>
          <direction>out</direction>
          <relatedStateVariable>TotalBytesReceived</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
    <name>GetTotalPacketsSent</name>
      <argumentList>
        <argument>
          <name>NewTotalPacketsSent</name>
          <direction>out</direction>
          <relatedStateVariable>TotalPacketsSent</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
    <name>GetTotalPacketsReceived</name>
      <argumentList>
        <argument>
          <name>NewTotalPacketsReceived</name>
          <direction>out</direction>
         <relatedStateVariable>TotalPacketsReceived</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
    <name>X_GetICSStatistics</name>
      <argumentList>
        <argument>
          <name>TotalBytesSent</name>
          <direction>out</direction>
          <relatedStateVariable>TotalBytesSent</relatedStateVariable>
        </argument>
        <argument>
          <name>TotalBytesReceived</name>
          <direction>out</direction>
          <relatedStateVariable>TotalBytesReceived</relatedStateVariable>
        </argument>
        <argument>
          <name>TotalPacketsSent</name>
          <direction>out</direction>
          <relatedStateVariable>TotalPacketsSent</relatedStateVariable>
        </argument>
        <argument>
          <name>TotalPacketsReceived</name>
          <direction>out</direction>
          <relatedStateVariable>TotalPacketsReceived</relatedStateVariable>
        </argument>
        <argument>
          <name>Layer1DownstreamMaxBitRate</name>
          <direction>out</direction>
          <relatedStateVariable>Layer1DownstreamMaxBitRate</relatedStateVariable>
        </argument>
        <argument>
          <name>Uptime</name>
          <direction>out</direction>
          <relatedStateVariable>X_Uptime</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
	</actionList>
	<serviceStateTable>
		<stateVariable sendEvents="no">
			<name>WANAccessType</name>
			<dataType>string</dataType>
			<allowedValueList>
				<allowedValue>DSL</allowedValue>
				<allowedValue>POTS</allowedValue>
				<allowedValue>Cable</allowedValue>
				<allowedValue>Ethernet</allowedValue>
				<allowedValue>Other</allowedValue>
			</allowedValueList>
		</stateVariable>
		<stateVariable sendEvents="no">
			<name>Layer1UpstreamMaxBitRate</name>
			<dataType>ui4</dataType>
		</stateVariable>
		<stateVariable sendEvents="no">
			<name>Layer1DownstreamMaxBitRate</name>
			<dataType>ui4</dataType>
		</stateVariable>
		<stateVariable sendEvents="yes">
			<name>PhysicalLinkStatus</name>
			<dataType>string</dataType>
      <allowedValueList>
        <allowedValue>Up</allowedValue>
        <allowedValue>Down</allowedValue>
        <allowedValue>Initializing</allowedValue>
        <allowedValue>Unavailable</allowedValue>
      </allowedValueList>
		</stateVariable>
    <stateVariable sendEvents="no">
      <name>WANAccessProvider</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>MaximumActiveConnections</name>
      <dataType>ui2</dataType>
      <allowedValueRange>
        <minimum>1</minimum>
        <maximum></maximum>
        <step>1</step>
      </allowedValueRange>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>TotalBytesSent</name>
      <dataType>ui4</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>TotalBytesReceived</name>
      <dataType>ui4</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>TotalPacketsSent</name>
      <dataType>ui4</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>TotalPacketsReceived</name>
      <dataType>ui4</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>X_PersonalFirewallEnabled</name>
      <dataType>boolean</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>X_Uptime</name>
      <dataType>ui4</dataType>
    </stateVariable>
	</serviceStateTable>
</scpd>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\idl\ipcfg.xml ===
<?xml version="1.0"?>
<scpd xmlns="urn:schemas-upnp-org:service-1-0">
  <specVersion>
    <major>1</major>
    <minor>0</minor>
  </specVersion>
  <actionList>
    <action>
      <name>SetConnectionType</name>
      <argumentList>
        <argument>
          <name>NewConnectionType</name>
          <direction>in</direction>
          <relatedStateVariable>ConnectionType</relatedStateVariable>
        </argument>
      </argumentList>
    </action> 
    <action>
    <name>GetConnectionTypeInfo</name>
      <argumentList>
        <argument>
          <name>NewConnectionType</name>
          <direction>out</direction>
          <relatedStateVariable>ConnectionType</relatedStateVariable>
        </argument>
        <argument>
          <name>NewPossibleConnectionTypes</name>
          <direction>out</direction>
          <relatedStateVariable>PossibleConnectionTypes</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
      <name>RequestConnection</name>
    </action>
    <action>
      <name>ForceTermination</name>
    </action>
    <action>
     <name>GetStatusInfo</name>
      <argumentList>
        <argument>
          <name>NewConnectionStatus</name>
          <direction>out</direction>
          <relatedStateVariable>ConnectionStatus</relatedStateVariable>
        </argument>
        <argument>
          <name>NewLastConnectionError</name>
          <direction>out</direction>
          <relatedStateVariable>LastConnectionError</relatedStateVariable>
        </argument>
        <argument>
          <name>NewUptime</name>
          <direction>out</direction>
          <relatedStateVariable>Uptime</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
      <name>GetNATRSIPStatus</name>
      <argumentList>
        <argument>
          <name>NewRSIPAvailable</name>
          <direction>out</direction>
          <relatedStateVariable>RSIPAvailable</relatedStateVariable>
        </argument>
        <argument>
          <name>NewNATEnabled</name>
          <direction>out</direction>
          <relatedStateVariable>NATEnabled</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
      <name>GetGenericPortMappingEntry</name>
      <argumentList>
        <argument>
          <name>NewPortMappingIndex</name>
          <direction>in</direction>
          <relatedStateVariable>PortMappingNumberOfEntries</relatedStateVariable>
        </argument>
        <argument>
          <name>NewRemoteHost</name>
          <direction>out</direction>
          <relatedStateVariable>RemoteHost</relatedStateVariable>
        </argument>
        <argument>
          <name>NewExternalPort</name>
          <direction>out</direction>
          <relatedStateVariable>ExternalPort</relatedStateVariable>
        </argument>
        <argument>
          <name>NewProtocol</name>
          <direction>out</direction>
          <relatedStateVariable>PortMappingProtocol</relatedStateVariable>
        </argument>
        <argument>
          <name>NewInternalPort</name>
          <direction>out</direction>
          <relatedStateVariable>InternalPort</relatedStateVariable>
        </argument>
        <argument>
          <name>NewInternalClient</name>
          <direction>out</direction>
          <relatedStateVariable>InternalClient</relatedStateVariable>
        </argument>
        <argument>
          <name>NewEnabled</name>
          <direction>out</direction>
          <relatedStateVariable>PortMappingEnabled</relatedStateVariable>
        </argument>
        <argument>
          <name>NewPortMappingDescription</name>
          <direction>out</direction>
          <relatedStateVariable>PortMappingDescription</relatedStateVariable>
        </argument>
        <argument>
          <name>NewLeaseDuration</name>
          <direction>out</direction>
          <relatedStateVariable>PortMappingLeaseDuration</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
      <name>GetSpecificPortMappingEntry</name>
      <argumentList>
        <argument>
          <name>NewRemoteHost</name>
          <direction>in</direction>
          <relatedStateVariable>RemoteHost</relatedStateVariable>
        </argument>
        <argument>
          <name>NewExternalPort</name>
          <direction>in</direction>
          <relatedStateVariable>ExternalPort</relatedStateVariable>
        </argument>
        <argument>
          <name>NewProtocol</name>
          <direction>in</direction>
          <relatedStateVariable>PortMappingProtocol</relatedStateVariable>
        </argument>
        <argument>
          <name>NewInternalPort</name>
          <direction>out</direction>
          <relatedStateVariable>InternalPort</relatedStateVariable>
        </argument>
        <argument>
          <name>NewInternalClient</name>
          <direction>out</direction>
          <relatedStateVariable>InternalClient</relatedStateVariable>
        </argument>
        <argument>
          <name>NewEnabled</name>
          <direction>out</direction>
          <relatedStateVariable>PortMappingEnabled</relatedStateVariable>
        </argument>
        <argument>
          <name>NewPortMappingDescription</name>
          <direction>out</direction>
          <relatedStateVariable>PortMappingDescription</relatedStateVariable>
        </argument>
        <argument>
          <name>NewLeaseDuration</name>
          <direction>out</direction>
          <relatedStateVariable>PortMappingLeaseDuration</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
      <name>AddPortMapping</name>
      <argumentList>
        <argument>
          <name>NewRemoteHost</name>
          <direction>in</direction>
          <relatedStateVariable>RemoteHost</relatedStateVariable>
        </argument>
        <argument>
          <name>NewExternalPort</name>
          <direction>in</direction>
          <relatedStateVariable>ExternalPort</relatedStateVariable>
        </argument>
        <argument>
          <name>NewProtocol</name>
          <direction>in</direction>
          <relatedStateVariable>PortMappingProtocol</relatedStateVariable>
        </argument>
        <argument>
          <name>NewInternalPort</name>
          <direction>in</direction>
          <relatedStateVariable>InternalPort</relatedStateVariable>
        </argument>
        <argument>
          <name>NewInternalClient</name>
          <direction>in</direction>
          <relatedStateVariable>InternalClient</relatedStateVariable>
        </argument>
        <argument>
          <name>NewEnabled</name>
          <direction>in</direction>
          <relatedStateVariable>PortMappingEnabled</relatedStateVariable>
        </argument>
        <argument>
          <name>NewPortMappingDescription</name>
          <direction>in</direction>
          <relatedStateVariable>PortMappingDescription</relatedStateVariable>
        </argument>
        <argument>
          <name>NewLeaseDuration</name>
          <direction>in</direction>
          <relatedStateVariable>PortMappingLeaseDuration</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
      <name>DeletePortMapping</name>
      <argumentList>
        <argument>
          <name>NewRemoteHost</name>
          <direction>in</direction>
          <relatedStateVariable>RemoteHost</relatedStateVariable>
        </argument>
        <argument>
          <name>NewExternalPort</name>
          <direction>in</direction>
          <relatedStateVariable>ExternalPort</relatedStateVariable>
        </argument>
        <argument>
          <name>NewProtocol</name>
          <direction>in</direction>
          <relatedStateVariable>PortMappingProtocol</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
    <name>GetExternalIPAddress</name>
      <argumentList>
        <argument>
          <name>NewExternalIPAddress</name>
          <direction>out</direction>
        <relatedStateVariable>ExternalIPAddress</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
  </actionList>
  <serviceStateTable>
    <stateVariable sendEvents="no">
      <name>ConnectionType</name>
      <dataType>string</dataType>
      <defaultValue>Unconfigured</defaultValue>
    </stateVariable>
    <stateVariable sendEvents="yes">
      <name>PossibleConnectionTypes</name>
      <dataType>string</dataType>
      <allowedValueList>
        <allowedValue>Unconfigured</allowedValue>
        <allowedValue>IP_Routed</allowedValue>
        <allowedValue>IP_Bridged</allowedValue>
      </allowedValueList>
    </stateVariable>
    <stateVariable sendEvents="yes">
      <name>ConnectionStatus</name>
      <dataType>string</dataType>
      <defaultValue>Unconfigured</defaultValue>
      <allowedValueList>
        <allowedValue>Unconfigured</allowedValue>
    	  <allowedValue>Connecting</allowedValue>
    	  <allowedValue>Authenticating</allowedValue>
        <allowedValue>PendingDisconnect</allowedValue>
        <allowedValue>Disconnecting</allowedValue>
        <allowedValue>Disconnected</allowedValue>
        <allowedValue>Connected</allowedValue>
      </allowedValueList>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>Uptime</name>
      <dataType>ui4</dataType>
      <defaultValue>0</defaultValue>
      <allowedValueRange>
        <minimum>0</minimum>
        <maximum></maximum>
        <step>1</step>
      </allowedValueRange>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>RSIPAvailable</name>
      <dataType>boolean</dataType>
      <defaultValue>0</defaultValue>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>NATEnabled</name>
      <dataType>boolean</dataType>
      <defaultValue>1</defaultValue>
    </stateVariable>  
    <stateVariable sendEvents="yes">
      <name>X_Name</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>LastConnectionError</name>
      <dataType>string</dataType>
      <defaultValue>ERROR_NONE</defaultValue>
      <allowedValueList>
        <allowedValue>ERROR_NONE</allowedValue>
    	  <allowedValue>ERROR_ISP_TIME_OUT</allowedValue>
        <allowedValue>ERROR_COMMAND_ABORTED</allowedValue>
        <allowedValue>ERROR_ NOT_ENABLED_FOR_INTERNET</allowedValue>
        <allowedValue>ERROR_BAD_PHONE_NUMBER</allowedValue>
        <allowedValue>ERROR_USER_DISCONNECT</allowedValue>
        <allowedValue>ERROR_ISP_DISCONNECT</allowedValue>
        <allowedValue>ERROR_IDLE_DISCONNECT</allowedValue>
        <allowedValue>ERROR_FORCED_DISCONNECT</allowedValue>
        <allowedValue>ERROR_SERVER_OUT_OF_RESOURCES</allowedValue>
        <allowedValue>ERROR_RESTRICTED_LOGON_HOURS</allowedValue>
        <allowedValue>ERROR_ACCOUNT_DISABLED</allowedValue>
        <allowedValue>ERROR_ACCOUNT_EXPIRED</allowedValue>
        <allowedValue>ERROR_PASSWORD_EXPIRED</allowedValue>
        <allowedValue>ERROR_AUTHENTICATION_FAILURE</allowedValue>
        <allowedValue>ERROR_NO_DIALTONE</allowedValue>
        <allowedValue>ERROR_NO_CARRIER</allowedValue>
        <allowedValue>ERROR_NO_ANSWER</allowedValue>
	      <allowedValue>ERROR_LINE_BUSY</allowedValue>
	      <allowedValue>ERROR_UNSUPPORTED_BITSPERSECOND</allowedValue>
	      <allowedValue>ERROR_TOO_MANY_LINE_ERRORS</allowedValue>
	      <allowedValue>ERROR_IP_CONFIGURATION</allowedValue>
	      <allowedValue>ERROR_UNKNOWN</allowedValue>
      </allowedValueList>
    </stateVariable>
    <stateVariable sendEvents="yes">
      <name>ExternalIPAddress</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>RemoteHost</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>ExternalPort</name>
      <dataType>ui2</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>InternalPort</name>
      <dataType>ui2</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>PortMappingProtocol</name>
      <dataType>string</dataType>
      <allowedValueList>
        <allowedValue>TCP</allowedValue>
        <allowedValue>UDP</allowedValue>
      </allowedValueList>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>InternalClient</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>PortMappingDescription</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>PortMappingEnabled</name>
      <dataType>boolean</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>PortMappingLeaseDuration</name>
      <dataType>ui4</dataType>
    </stateVariable>
    <stateVariable sendEvents="yes">
      <name>PortMappingNumberOfEntries</name>
      <dataType>ui2</dataType>
    </stateVariable>
  </serviceStateTable>
</scpd>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\idl\osinfo.xml ===
<?xml version="1.0"?>
<scpd xmlns="urn:schemas-upnp-org:service-1-0">
  <specVersion>
    <major>1</major>
    <minor>0</minor>
  </specVersion>
  <actionList>
   <action>
      <name>MagicOn</name>
    </action>
  </actionList>
  <serviceStateTable>
    <stateVariable>
      <name>OSMajorVersion</name>
      <dataType>i4</dataType>
    </stateVariable>
    <stateVariable>
      <name>OSMinorVersion</name>
      <dataType>i4</dataType>
    </stateVariable>
    <stateVariable>
      <name>OSBuildNumber</name>
      <dataType>i4</dataType>
    </stateVariable>
    <stateVariable>
      <name>OSMachineName</name>
      <dataType>string</dataType>
    </stateVariable>
  </serviceStateTable>
</scpd>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\idl\dprtmap.xml ===
<?xml version="1.0"?>
<scpd xmlns="urn:schemas-upnp-org:service-1-0">
  <specVersion>
    <major>1</major>
    <minor>0</minor>
  </specVersion>
  <actionList>
    <action>
     <name>CreateDynamicPortMapping</name>
      <argumentList>
        <argument>
          <name>DynamicPublicIP</name>
          <direction>in</direction>
          <relatedStateVariable>DynamicPublicIP</relatedStateVariable>
        </argument>
        <argument>
          <name>DynamicPort</name>
          <direction>in</direction>
          <relatedStateVariable>DynamicPort</relatedStateVariable>
        </argument>
        <argument>
          <name>DynamicProtocol</name>
          <direction>in</direction>
          <relatedStateVariable>DynamicProtocol</relatedStateVariable>
        </argument>
        <argument>
          <name>DynamicPrivateIP</name>
          <direction>in</direction>
          <relatedStateVariable>DynamicPrivateIP</relatedStateVariable>
        </argument>
        <argument>
          <name>DynamicLeaseDuration</name>
          <direction>in</direction>
          <relatedStateVariable>DynamicLeaseDuration</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
     <name>DeleteDynamicPortMapping</name>
      <argumentList>
        <argument>
          <name>DynamicPublicIP</name>
          <direction>in</direction>
          <relatedStateVariable>DynamicPublicIP</relatedStateVariable>
        </argument>
        <argument>
          <name>DynamicPort</name>
          <direction>in</direction>
          <relatedStateVariable>DynamicPort</relatedStateVariable>
        </argument>
        <argument>
          <name>DynamicProtocol</name>
          <direction>in</direction>
          <relatedStateVariable>DynamicProtocol</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
     <name>ExtendDynamicPortMapping</name>
      <argumentList>
        <argument>
          <name>DynamicPublicIP</name>
          <direction>in</direction>
          <relatedStateVariable>DynamicPublicIP</relatedStateVariable>
        </argument>
        <argument>
          <name>DynamicPort</name>
          <direction>in</direction>
          <relatedStateVariable>DynamicPort</relatedStateVariable>
        </argument>
        <argument>
          <name>DynamicProtocol</name>
          <direction>in</direction>
          <relatedStateVariable>DynamicProtocol</relatedStateVariable>
        </argument>
        <argument>
          <name>DynamicLeaseDuration</name>
          <direction>in</direction>
          <relatedStateVariable>DynamicLeaseDuration</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
  </actionList>
  <serviceStateTable>
    <stateVariable sendEvents="no">
      <name>DynamicPublicIP</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>DynamicPort</name>
      <dataType>ui4</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>DynamicProtocol</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>DynamicPrivateIP</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>DynamicLeaseDuration</name>
      <dataType>ui4</dataType>
    </stateVariable>
  </serviceStateTable>
</scpd>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\idl\internetgatewaydevicelan.xml ===
<?xml version="1.0"?>
<root xmlns="urn:schemas-upnp-org:device-1-0">
	<specVersion>
		<major>1</major>
		<minor>0</minor>
	</specVersion>
	<device>
		<deviceType>urn:schemas-upnp-org:device:InternetGatewayDevice:1</deviceType>
		<friendlyName>Residential Gateway Device</friendlyName>
		<manufacturer>Microsoft</manufacturer>
		<manufacturerURL>http://www.microsoft.com/</manufacturerURL>
		<modelName>Internet Connection Sharing</modelName>
		<UDN>DummyUDN</UDN>
		<serviceList>
			<service>
				<serviceType>urn:schemas-microsoft-com:service:OSInfo:1</serviceType>
				<serviceId>urn:microsoft-com:serviceId:OSInfo1</serviceId>
				<controlURL></controlURL>
				<eventSubURL></eventSubURL>
				<SCPDURL>OSInfo.xml</SCPDURL>
			</service>
		</serviceList>
		<deviceList>
      <device>
        <deviceType>urn:schemas-upnp-org:device:WANDevice:1</deviceType>
        <friendlyName>WANDevice</friendlyName>
        <manufacturer>Microsoft</manufacturer>
        <manufacturerURL>http://www.microsoft.com/</manufacturerURL>
        <modelDescription>Residential Gateway</modelDescription>
        <modelName>Internet Connection Sharing</modelName>
        <modelNumber>1</modelNumber>
        <modelURL>http://www.microsoft.com/</modelURL>
        <serialNumber>0000001</serialNumber>
        <UDN>DummyUDN2</UDN>
        <UPC>00000-00001</UPC>
        <serviceList>
          <service>
       	    <serviceType>urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1</serviceType>
            <serviceId>urn:upnp-org:serviceId:WANCommonIFC1</serviceId>
				    <controlURL></controlURL>
				    <eventSubURL></eventSubURL>
            <SCPDURL>cmnicfg.xml</SCPDURL>
          </service>
        </serviceList>
        <deviceList>
          <device>
            <deviceType>urn:schemas-upnp-org:device:WANConnectionDevice:1</deviceType>
            <friendlyName>WANConnectionDevice</friendlyName>
            <manufacturer>Microsoft</manufacturer>
            <manufacturerURL>http://www.microsoft.com/</manufacturerURL>
            <modelDescription>Residential Gateway</modelDescription>
            <modelName>Internet Connection Sharing</modelName>
            <modelNumber>1</modelNumber>
            <modelURL>http://www.microsoft.com/</modelURL>
            <serialNumber>0000001</serialNumber>
            <UDN>DummyUDN3</UDN>
            <UPC>00000-00001</UPC>
            <serviceList>
              <service>
                <serviceType>urn:schemas-upnp-org:service:WANIPConnection:1</serviceType>
                <serviceId>urn:upnp-org:serviceId:WANIPConn1</serviceId>
                <controlURL></controlURL>
                <eventSubURL></eventSubURL>
                <SCPDURL>ipcfg.xml</SCPDURL>
              </service>
            </serviceList>
          </device>
        </deviceList>
      </device>
		</deviceList>
	</device>
</root>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\idl\internetgatewaydeviceras.xml ===
<?xml version="1.0"?>
<root xmlns="urn:schemas-upnp-org:device-1-0">
	<specVersion>
		<major>1</major>
		<minor>0</minor>
	</specVersion>
	<device>
		<deviceType>urn:schemas-upnp-org:device:InternetGatewayDevice:1</deviceType>
		<friendlyName>Residential Gateway Device</friendlyName>
		<manufacturer>Microsoft</manufacturer>
		<manufacturerURL>http://www.microsoft.com/</manufacturerURL>
		<modelName>Internet Connection Sharing</modelName>
		<UDN>DummyUDN</UDN>
		<serviceList>
			<service>
				<serviceType>urn:schemas-microsoft-com:service:OSInfo:1</serviceType>
				<serviceId>urn:microsoft-com:serviceId:OSInfo1</serviceId>
				<controlURL></controlURL>
				<eventSubURL></eventSubURL>
				<SCPDURL>OSInfo.xml</SCPDURL>
			</service>
		</serviceList>
		<deviceList>
      <device>
        <deviceType>urn:schemas-upnp-org:device:WANDevice:1</deviceType>
        <friendlyName>WANDevice</friendlyName>
        <manufacturer>Microsoft</manufacturer>
        <manufacturerURL>http://www.microsoft.com/</manufacturerURL>
        <modelDescription>Residential Gateway</modelDescription>
        <modelName>Internet Connection Sharing</modelName>
        <modelNumber>1</modelNumber>
        <modelURL>http://www.microsoft.com/</modelURL>
        <serialNumber>0000001</serialNumber>
        <UDN>DummyUDN2</UDN>
        <UPC>00000-00001</UPC>
        <serviceList>
          <service>
       	    <serviceType>urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1</serviceType>
            <serviceId>urn:upnp-org:serviceId:WANCommonIFC1</serviceId>
				    <controlURL></controlURL>
				    <eventSubURL></eventSubURL>
            <SCPDURL>cmnicfg.xml</SCPDURL>
          </service>
        </serviceList>
        <deviceList>
          <device>
            <deviceType>urn:schemas-upnp-org:device:WANConnectionDevice:1</deviceType>
            <friendlyName>WANConnectionDevice</friendlyName>
            <manufacturer>Microsoft</manufacturer>
            <manufacturerURL>http://www.microsoft.com/</manufacturerURL>
            <modelDescription>Residential Gateway</modelDescription>
            <modelName>Internet Connection Sharing</modelName>
            <modelNumber>1</modelNumber>
            <modelURL>http://www.microsoft.com/</modelURL>
            <serialNumber>0000001</serialNumber>
            <UDN>DummyUDN3</UDN>
            <UPC>00000-00001</UPC>
            <serviceList>
              <service>
                <serviceType>urn:schemas-upnp-org:service:WANPOTSLinkConfig:1</serviceType>
                <serviceId>urn:upnp-org:serviceId:WANPOTSLinkC1</serviceId>
                <controlURL></controlURL>
                <eventSubURL></eventSubURL>
                <SCPDURL>potscfg.xml</SCPDURL>
              </service>
              <service>
                <serviceType>urn:schemas-upnp-org:service:WANPPPConnection:1</serviceType>
                <serviceId>urn:upnp-org:serviceId:WANPPPConn1</serviceId>
                <controlURL></controlURL>
                <eventSubURL></eventSubURL>
                <SCPDURL>pppcfg.xml</SCPDURL>
              </service>
            </serviceList>
          </device>
        </deviceList>
      </device>
		</deviceList>
	</device>
</root>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\idl\natinfo.xml ===
<?xml version="1.0"?>
<scpd xmlns="urn:schemas-upnp-org:service-1-0">
  <specVersion>
    <major>1</major>
    <minor>0</minor>
  </specVersion>
  <actionList>
    <action>
     <name>GetPublicIPList</name>
      <argumentList>
        <argument>
          <name>IPList</name>
          <direction>out</direction>
          <relatedStateVariable>IPList</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
     <name>GetPortMappingPrivateIP</name>
      <argumentList>
        <argument>
          <name>PublicIP</name>
          <direction>in</direction>
          <relatedStateVariable>PublicIP</relatedStateVariable>
        </argument>
        <argument>
          <name>Port</name>
          <direction>in</direction>
          <relatedStateVariable>Port</relatedStateVariable>
        </argument>
        <argument>
          <name>Protocol</name>
          <direction>in</direction>
          <relatedStateVariable>Protocol</relatedStateVariable>
        </argument>
        <argument>
          <name>PrivateIP</name>
          <direction>out</direction>
          <relatedStateVariable>PrivateIP</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
     <name>GetPortMappingPublicIP</name>
      <argumentList>
        <argument>
          <name>PrivateIP</name>
          <direction>in</direction>
          <relatedStateVariable>PrivateIP</relatedStateVariable>
        </argument>
        <argument>
          <name>Port</name>
          <direction>in</direction>
          <relatedStateVariable>Port</relatedStateVariable>
        </argument>
        <argument>
          <name>Protocol</name>
          <direction>in</direction>
          <relatedStateVariable>Protocol</relatedStateVariable>
        </argument>
        <argument>
          <name>PublicIP</name>
          <direction>out</direction>
          <relatedStateVariable>PublicIP</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
  </actionList>
  <serviceStateTable>
    <stateVariable sendEvents="yes">
      <name>IPList</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>PublicIP</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>Port</name>
      <dataType>ui4</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>Protocol</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>PrivateIP</name>
      <dataType>string</dataType>
    </stateVariable>
  </serviceStateTable>
</scpd>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\idl\pppcfg.xml ===
<?xml version="1.0"?>
<scpd xmlns="urn:schemas-upnp-org:service-1-0">
  <specVersion>
    <major>1</major>
    <minor>0</minor>
  </specVersion>
  <actionList>
    <action>
      <name>SetConnectionType</name>
      <argumentList>
        <argument>
          <name>NewConnectionType</name>
          <direction>in</direction>
          <relatedStateVariable>ConnectionType</relatedStateVariable>
        </argument>
      </argumentList>
    </action> 
    <action>
    <name>GetConnectionTypeInfo</name>
      <argumentList>
        <argument>
          <name>NewConnectionType</name>
          <direction>out</direction>
          <relatedStateVariable>ConnectionType</relatedStateVariable>
        </argument>
        <argument>
          <name>NewPossibleConnectionTypes</name>
          <direction>out</direction>
          <relatedStateVariable>PossibleConnectionTypes</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
      <name>RequestConnection</name>
    </action>
    <action>
      <name>ForceTermination</name>
    </action>
    <action>
     <name>GetStatusInfo</name>
      <argumentList>
        <argument>
          <name>NewConnectionStatus</name>
          <direction>out</direction>
          <relatedStateVariable>ConnectionStatus</relatedStateVariable>
        </argument>
        <argument>
          <name>NewLastConnectionError</name>
          <direction>out</direction>
          <relatedStateVariable>LastConnectionError</relatedStateVariable>
        </argument>
        <argument>
          <name>NewUptime</name>
          <direction>out</direction>
          <relatedStateVariable>Uptime</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
      <name>GetNATRSIPStatus</name>
      <argumentList>
        <argument>
          <name>NewRSIPAvailable</name>
          <direction>out</direction>
          <relatedStateVariable>RSIPAvailable</relatedStateVariable>
        </argument>
        <argument>
          <name>NewNATEnabled</name>
          <direction>out</direction>
          <relatedStateVariable>NATEnabled</relatedStateVariable>
        </argument>
      </argumentList>
     </action>
     <action>
      <name>GetLinkLayerMaxBitRates</name>
      <argumentList>
        <argument>
          <name>NewUpstreamMaxBitRate</name>
          <direction>out</direction>
          <relatedStateVariable>UpstreamMaxBitRate</relatedStateVariable>
        </argument>
        <argument>
          <name>NewDownstreamMaxBitRate</name>
          <direction>out</direction>
          <relatedStateVariable>DownstreamMaxBitRate</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
      <name>GetGenericPortMappingEntry</name>
      <argumentList>
        <argument>
          <name>NewPortMappingIndex</name>
          <direction>in</direction>
          <relatedStateVariable>PortMappingNumberOfEntries</relatedStateVariable>
        </argument>
        <argument>
          <name>NewRemoteHost</name>
          <direction>out</direction>
          <relatedStateVariable>RemoteHost</relatedStateVariable>
        </argument>
        <argument>
          <name>NewExternalPort</name>
          <direction>out</direction>
          <relatedStateVariable>ExternalPort</relatedStateVariable>
        </argument>
        <argument>
          <name>NewProtocol</name>
          <direction>out</direction>
          <relatedStateVariable>PortMappingProtocol</relatedStateVariable>
        </argument>
        <argument>
          <name>NewInternalPort</name>
          <direction>out</direction>
          <relatedStateVariable>InternalPort</relatedStateVariable>
        </argument>
        <argument>
          <name>NewInternalClient</name>
          <direction>out</direction>
          <relatedStateVariable>InternalClient</relatedStateVariable>
        </argument>
        <argument>
          <name>NewEnabled</name>
          <direction>out</direction>
          <relatedStateVariable>PortMappingEnabled</relatedStateVariable>
        </argument>
        <argument>
          <name>NewPortMappingDescription</name>
          <direction>out</direction>
          <relatedStateVariable>PortMappingDescription</relatedStateVariable>
        </argument>
        <argument>
          <name>NewLeaseDuration</name>
          <direction>out</direction>
          <relatedStateVariable>PortMappingLeaseDuration</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
      <name>GetSpecificPortMappingEntry</name>
      <argumentList>
        <argument>
          <name>NewRemoteHost</name>
          <direction>in</direction>
          <relatedStateVariable>RemoteHost</relatedStateVariable>
        </argument>
        <argument>
          <name>NewExternalPort</name>
          <direction>in</direction>
          <relatedStateVariable>ExternalPort</relatedStateVariable>
        </argument>
        <argument>
          <name>NewProtocol</name>
          <direction>in</direction>
          <relatedStateVariable>PortMappingProtocol</relatedStateVariable>
        </argument>
        <argument>
          <name>NewInternalPort</name>
          <direction>out</direction>
          <relatedStateVariable>InternalPort</relatedStateVariable>
        </argument>
        <argument>
          <name>NewInternalClient</name>
          <direction>out</direction>
          <relatedStateVariable>InternalClient</relatedStateVariable>
        </argument>
        <argument>
          <name>NewEnabled</name>
          <direction>out</direction>
          <relatedStateVariable>PortMappingEnabled</relatedStateVariable>
        </argument>
        <argument>
          <name>NewPortMappingDescription</name>
          <direction>out</direction>
          <relatedStateVariable>PortMappingDescription</relatedStateVariable>
        </argument>
        <argument>
          <name>NewLeaseDuration</name>
          <direction>out</direction>
          <relatedStateVariable>PortMappingLeaseDuration</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
      <name>AddPortMapping</name>
      <argumentList>
        <argument>
          <name>NewRemoteHost</name>
          <direction>in</direction>
          <relatedStateVariable>RemoteHost</relatedStateVariable>
        </argument>
        <argument>
          <name>NewExternalPort</name>
          <direction>in</direction>
          <relatedStateVariable>ExternalPort</relatedStateVariable>
        </argument>
        <argument>
          <name>NewProtocol</name>
          <direction>in</direction>
          <relatedStateVariable>PortMappingProtocol</relatedStateVariable>
        </argument>
        <argument>
          <name>NewInternalPort</name>
          <direction>in</direction>
          <relatedStateVariable>InternalPort</relatedStateVariable>
        </argument>
        <argument>
          <name>NewInternalClient</name>
          <direction>in</direction>
          <relatedStateVariable>InternalClient</relatedStateVariable>
        </argument>
        <argument>
          <name>NewEnabled</name>
          <direction>in</direction>
          <relatedStateVariable>PortMappingEnabled</relatedStateVariable>
        </argument>
        <argument>
          <name>NewPortMappingDescription</name>
          <direction>in</direction>
          <relatedStateVariable>PortMappingDescription</relatedStateVariable>
        </argument>
        <argument>
          <name>NewLeaseDuration</name>
          <direction>in</direction>
          <relatedStateVariable>PortMappingLeaseDuration</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
      <name>DeletePortMapping</name>
      <argumentList>
        <argument>
          <name>NewRemoteHost</name>
          <direction>in</direction>
          <relatedStateVariable>RemoteHost</relatedStateVariable>
        </argument>
        <argument>
          <name>NewExternalPort</name>
          <direction>in</direction>
          <relatedStateVariable>ExternalPort</relatedStateVariable>
        </argument>
        <argument>
          <name>NewProtocol</name>
          <direction>in</direction>
          <relatedStateVariable>PortMappingProtocol</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
    <name>GetExternalIPAddress</name>
      <argumentList>
        <argument>
          <name>NewExternalIPAddress</name>
          <direction>out</direction>
        <relatedStateVariable>ExternalIPAddress</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
  </actionList>
  <serviceStateTable>
    <stateVariable sendEvents="no">
      <name>ConnectionType</name>
      <dataType>string</dataType>
      <defaultValue>Unconfigured</defaultValue>
    </stateVariable>
    <stateVariable sendEvents="yes">
      <name>PossibleConnectionTypes</name>
      <dataType>string</dataType>
      <defaultValue>Unconfigured</defaultValue>
    </stateVariable>
    <stateVariable sendEvents="yes">
      <name>ConnectionStatus</name>
      <dataType>string</dataType>
      <defaultValue>Unconfigured</defaultValue>
      <allowedValueList>
        <allowedValue>Unconfigured</allowedValue>
    	  <allowedValue>Connecting</allowedValue>
    	  <allowedValue>Authenticating</allowedValue>
        <allowedValue>PendingDisconnect</allowedValue>
        <allowedValue>Disconnecting</allowedValue>
        <allowedValue>Disconnected</allowedValue>
        <allowedValue>Connected</allowedValue>
      </allowedValueList>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>Uptime</name>
      <dataType>ui4</dataType>
      <defaultValue>0</defaultValue>
      <allowedValueRange>
        <minimum>0</minimum>
        <maximum></maximum>
        <step>1</step>
      </allowedValueRange>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>UpstreamMaxBitRate</name>
      <dataType>ui4</dataType>
      <defaultValue>0</defaultValue>
      <allowedValueRange>
        <minimum>0</minimum>
        <maximum></maximum>
        <step></step>
      </allowedValueRange>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>DownstreamMaxBitRate</name>
      <dataType>ui4</dataType>
      <defaultValue>0</defaultValue>
      <allowedValueRange>
        <minimum>0</minimum>
        <maximum></maximum>
        <step></step>
      </allowedValueRange>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>LastConnectionError</name>
      <dataType>string</dataType>
      <defaultValue>ERROR_NONE</defaultValue>
      <allowedValueList>
        <allowedValue>ERROR_NONE</allowedValue>
    	  <allowedValue>ERROR_ISP_TIME_OUT</allowedValue>
        <allowedValue>ERROR_COMMAND_ABORTED</allowedValue>
        <allowedValue>ERROR_NOT_ENABLED_FOR_INTERNET</allowedValue>
        <allowedValue>ERROR_BAD_PHONE_NUMBER</allowedValue>
        <allowedValue>ERROR_USER_DISCONNECT</allowedValue>
        <allowedValue>ERROR_ISP_DISCONNECT</allowedValue>
        <allowedValue>ERROR_IDLE_DISCONNECT</allowedValue>
        <allowedValue>ERROR_FORCED_DISCONNECT</allowedValue>
        <allowedValue>ERROR_SERVER_OUT_OF_RESOURCES</allowedValue>
        <allowedValue>ERROR_RESTRICTED_LOGON_HOURS</allowedValue>
        <allowedValue>ERROR_ACCOUNT_DISABLED</allowedValue>
        <allowedValue>ERROR_ACCOUNT_EXPIRED</allowedValue>
        <allowedValue>ERROR_PASSWORD_EXPIRED</allowedValue>
        <allowedValue>ERROR_AUTHENTICATION_FAILURE</allowedValue>
        <allowedValue>ERROR_NO_DIALTONE</allowedValue>
        <allowedValue>ERROR_NO_CARRIER</allowedValue>
        <allowedValue>ERROR_NO_ANSWER</allowedValue>
	      <allowedValue>ERROR_LINE_BUSY</allowedValue>
	      <allowedValue>ERROR_UNSUPPORTED_BITSPERSECOND</allowedValue>
	      <allowedValue>ERROR_TOO_MANY_LINE_ERRORS</allowedValue>
	      <allowedValue>ERROR_IP_CONFIGURATION</allowedValue>
	      <allowedValue>ERROR_UNKNOWN</allowedValue>
      </allowedValueList>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>RSIPAvailable</name>
      <dataType>boolean</dataType>
      <defaultValue>0</defaultValue>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>NATEnabled</name>
      <dataType>boolean</dataType>
      <defaultValue>1</defaultValue>
    </stateVariable>  
    <stateVariable sendEvents="yes">
      <name>X_Name</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="yes">
      <name>ExternalIPAddress</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>RemoteHost</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>ExternalPort</name>
      <dataType>ui2</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>InternalPort</name>
      <dataType>ui2</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>PortMappingProtocol</name>
      <dataType>string</dataType>
      <allowedValueList>
        <allowedValue>TCP</allowedValue>
        <allowedValue>UDP</allowedValue>
      </allowedValueList>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>InternalClient</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>PortMappingDescription</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>PortMappingEnabled</name>
      <dataType>boolean</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>PortMappingLeaseDuration</name>
      <dataType>ui4</dataType>
    </stateVariable>
    <stateVariable sendEvents="yes">
      <name>PortMappingNumberOfEntries</name>
      <dataType>ui2</dataType>
    </stateVariable>
  </serviceStateTable>
</scpd>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\idl\potscfg.xml ===
<?xml version="1.0"?>
<scpd xmlns="urn:schemas-upnp-org:service-1-0">
	<specVersion>
		<major>1</major>
		<minor>0</minor>
	</specVersion>
	<actionList>
    <action>
    <name>GetISPInfo</name>
      <argumentList>
        <argument>
          <name>NewISPPhoneNumber</name>
          <direction>out</direction>
          <relatedStateVariable>ISPPhoneNumber</relatedStateVariable>
        </argument>
        <argument>
          <name>NewISPInfo</name>
          <direction>out</direction>
          <relatedStateVariable>ISPInfo</relatedStateVariable>
        </argument>
        <argument>
          <name>NewLinkType</name>
          <direction>out</direction>
          <relatedStateVariable>LinkType</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
    <name>GetCallRetryInfo</name>
      <argumentList>
        <argument>
          <name>NewNumberOfRetries</name>
          <direction>out</direction>
          <relatedStateVariable>NumberOfRetries</relatedStateVariable>
        </argument>
        <argument>
          <name>NewDelayBetweenRetries</name>
          <direction>out</direction>
        <relatedStateVariable>DelayBetweenRetries</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
	</actionList>
	<serviceStateTable>
		<stateVariable sendEvents="no">
			<name>ISPPhoneNumber</name>
			<dataType>string</dataType>
		</stateVariable>
    <stateVariable sendEvents="no">
      <name>ISPInfo</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>LinkType</name>
      <dataType>string</dataType>
      <allowedValueList>
        <allowedValue>PPP_Dialup</allowedValue>                                                                                                                                     
      </allowedValueList>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>NumberOfRetries</name>
      <dataType>ui4</dataType>
      <defaultValue>5</defaultValue>
      <allowedValueRange>
        <minimum>0</minimum>
        <maximum></maximum>
        <step>0</step>
      </allowedValueRange>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>DelayBetweenRetries</name>
      <dataType>ui4</dataType>
      <defaultValue>10</defaultValue>
      <allowedValueRange>
        <minimum>0</minimum>
        <maximum></maximum>
        <step>1</step>
      </allowedValueRange>
    </stateVariable>
	</serviceStateTable>
</scpd>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\homenet\beacon\idl\sprtmap.xml ===
<?xml version="1.0"?>
<scpd xmlns="urn:schemas-upnp-org:service-1-0">
  <specVersion>
    <major>1</major>
    <minor>0</minor>
  </specVersion>
  <actionList>
    <action>
     <name>GetStaticPortMappingList</name>
      <argumentList>
        <argument>
          <name>StaticPortDescriptionList</name>
          <direction>out</direction>
          <relatedStateVariable>StaticPortDescriptionList</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
     <name>GetStaticPortMapping</name>
      <argumentList>
        <argument>
          <name>StaticPortDescription</name>
          <direction>in</direction>
          <relatedStateVariable>StaticPortDescription</relatedStateVariable>
        </argument>
        <argument>
          <name>StaticPort</name>
          <direction>out</direction>
          <relatedStateVariable>StaticPort</relatedStateVariable>
        </argument>
        <argument>
          <name>StaticPortClient</name>
          <direction>out</direction>
          <relatedStateVariable>StaticPortClient</relatedStateVariable>
        </argument>
        <argument>
          <name>StaticPortProtocol</name>
          <direction>out</direction>
          <relatedStateVariable>StaticPortProtocol</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
     <name>SetStaticPortMappingEnabled</name>
      <argumentList>
        <argument>
          <name>StaticPortDescription</name>
          <direction>in</direction>
          <relatedStateVariable>StaticPortDescription</relatedStateVariable>
        </argument>
        <argument>
          <name>StaticPortEnable</name>
          <direction>in</direction>
          <relatedStateVariable>StaticPortEnable</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
     <name>CreateStaticPortMapping</name>
      <argumentList>
        <argument>
          <name>StaticPortDescription</name>
          <direction>in</direction>
          <relatedStateVariable>StaticPortDescription</relatedStateVariable>
        </argument>
        <argument>
          <name>StaticPort</name>
          <direction>in</direction>
          <relatedStateVariable>StaticPort</relatedStateVariable>
        </argument>
        <argument>
          <name>StaticPortClient</name>
          <direction>in</direction>
          <relatedStateVariable>StaticPortClient</relatedStateVariable>
        </argument>
        <argument>
          <name>StaticPortProtocol</name>
          <direction>in</direction>
          <relatedStateVariable>StaticPortProtocol</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
     <name>DeleteStaticPortMapping</name>
      <argumentList>
        <argument>
          <name>StaticPortDescription</name>
          <direction>in</direction>
          <relatedStateVariable>StaticPortDescription</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
    <action>
     <name>SetStaticPortMapping</name>
      <argumentList>
        <argument>
          <name>StaticPortDescription</name>
          <direction>in</direction>
          <relatedStateVariable>StaticPortDescription</relatedStateVariable>
        </argument>
        <argument>
          <name>StaticPort</name>
          <direction>in</direction>
          <relatedStateVariable>StaticPort</relatedStateVariable>
        </argument>
        <argument>
          <name>StaticPortClient</name>
          <direction>in</direction>
          <relatedStateVariable>StaticPortClient</relatedStateVariable>
        </argument>
        <argument>
          <name>StaticPortProtocol</name>
          <direction>in</direction>
          <relatedStateVariable>StaticPortProtocol</relatedStateVariable>
        </argument>
      </argumentList>
    </action>
  </actionList>
  <serviceStateTable>
    <stateVariable sendEvents="no">
      <name>StaticPortDescriptionList</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>StaticPort</name>
      <dataType>ui4</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>StaticPortProtocol</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>StaticPortClient</name>
      <dataType>string</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>StaticPortEnable</name>
      <dataType>boolean</dataType>
    </stateVariable>
    <stateVariable sendEvents="no">
      <name>StaticPortDescription</name>
      <dataType>string</dataType>
    </stateVariable>
  </serviceStateTable>
</scpd>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\ias\iasmmc.rtf ===
{\rtf1\ansi \deff4\deflang1033{\fonttbl{\f4\froman\fcharset0\fprq2 Times New Roman;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif{\*\falt Century Gothic};}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255; \red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0; \red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\widctlpar \f4\fs20 \snext0 Normal;}{\s1\sb280\sa40\widctlpar \b\f4\fs20 \sbasedon0\snext0 heading 1;}{\s2\sb120\widctlpar \b\f4\fs20 \sbasedon0\snext0 heading 2;}{ \s3\sb120\sa60\widctlpar \f4\fs20 \sbasedon0\snext0 heading 3;}{\s4\fi-245\li360\widctlpar \f4\fs20 \sbasedon0\snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}{\s15\fi-187\li302\widctlpar\tx302 \f4\fs20 \sbasedon0\snext0 Lb1;}{ \s16\fi-187\li274\sl-120\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \tx302 \f4\fs20 \sbasedon0\snext0 a/k link;}{\*\cs17 \additive\cf6 \sbasedon10 annotation reference;}{\s18\widctlpar \f4\fs20 \sbasedon0\snext18 annotation text;}{ \s19\li115\ri130\sb120\sa120\widctlpar \f7\fs16 \snext0 bitmap;}{\s20\widctlpar \f4\fs20 \sbasedon0\snext0 Context;}{\*\cs21 \additive\up6 \sbasedon10 footnote reference;}{\s22\widctlpar \f4\fs20 \sbasedon0\snext0 footnote text;}{\s23\widctlpar \f4\fs20  \sbasedon0\snext23 Jl;}{\s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 \sbasedon15\snext24 Lb2;}{\s25\fi-158\li461\sb48\widctlpar\tx461 \f4\fs20 \sbasedon24\snext25 Lb3;}{\s26\li302\sb60\widctlpar\tx302 \f4\fs20 \sbasedon24\snext24 Lp1;}{ \s27\li720\widctlpar \f4\fs20 \sbasedon0\snext0 Normal Indent;}{\s28\fi-187\li274\sl-120\slmult0\widctlpar\tx302 \f4\fs20 \sbasedon16\snext28 oem a/k link;}{\s29\fi-302\li418\ri86\sa120\widctlpar \f4\fs20 \sbasedon0\snext29 oem button;}{ \s30\fi-302\li418\ri86\sb160\sa120\widctlpar\tx720 \f4\fs20 \sbasedon29\snext30 oem button1;}{\s31\fi-187\li302\sb160\widctlpar\tx302 \f4\fs20 \sbasedon0\snext31 oem Lb1;}{\s32\sb160\widctlpar \f4\fs20 \sbasedon0\snext32 oem normal;}{ \s33\ri2160\sb160\widctlpar \f4\fs20 \sbasedon0\snext33 oem popup;}{\s34\ri2160\widctlpar \f4\fs12 \sbasedon33\snext34 oem popup end;}{\s35\fi-187\li302\ri2160\sb160\widctlpar\tx302 \f4\fs20 \sbasedon31\snext35 oem popup Lb1;}{\s36\sb240\widctlpar  \b\f4\fs20 \sbasedon0\snext36 oem proc head;}{\s37\ri86\widctlpar \f4\fs20 \sbasedon0\snext0 oem tb text;}{\s38\li58\widctlpar \f4\fs20 \sbasedon0\snext38 oem tb text 2;}{\s39\fi-187\li245\widctlpar\tx245\tx302 \f4\fs20 \sbasedon15\snext39  oem tb text 2 Lb1;}{\s40\fi-187\li245\sb48\widctlpar\tx245\tx302 \f4\fs20 \sbasedon24\snext40 oem tb text 2 Lb2;}{\s41\fi-158\li403\sb48\widctlpar\tx403\tx461 \f4\fs20 \sbasedon25\snext41 oem tb text 2 Lb3;}{\s42\widctlpar \f4\fs20 \sbasedon0\snext42  Pop-up;}{\s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \snext15 proc head;}{\s44\li115\ri86\sb280\widctlpar \f4\fs20 \sbasedon29\snext29 table top;}{\s45\li58\sb280\widctlpar \f4\fs20 \sbasedon44\snext38 table top 2;}{ \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \sbasedon24\snext46 Tbr1;}{\s47\widctlpar \f4\fs20 \sbasedon0\snext0 Tech Rev;}{\s48\li58\sb80\widctlpar \f4\fs20 \sbasedon44\snext48 vertrule;}{\*\cs49 \additive\b \sbasedon10 UI;}{\s50\widctlpar \brdrb\brdrs\brdrw15\brsp20 \f4\fs20 \sbasedon38\snext50 Table row w/rule;}{\*\cs51 \additive\scaps\fs14 \sbasedon10 Smallcaps;}}{\info{\author ms user}{\operator ms user}{\creatim\yr1998\mo2\dy18\hr10\min1}{\revtim\yr1998\mo8\dy3\hr12\min22}{\version5} {\edmins1}{\nofpages43}{\nofwords292}{\nofchars1667}{\*\company  }{\vern57443}}\widowctrl\ftnbj\aenddoc\linkstyles\hyphcaps0\formshade \fet0\sectd \linex0\endnhere {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2 \pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6 \pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain \widctlpar \f4\fs20 {\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_EDIT_ADD_CLIENT__NAME}}}{\up6  IDH_EDIT_ADD_CLIENT__NAME \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_COMBO_ADD_CLIENT__PROTOCOL}}}{\up6  IDH_COMBO_ADD_CLIENT__PROTOCOL \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT}}}{\up6  IDH_BUTTON_ADD_CLIENT__CONFIGURE_CLIENT \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_BUTTON_ADD_CLIENT__OK}}}{\up6  IDH_BUTTON_ADD_CLIENT__OK \par }\page {\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_BUTTON_ADD_CLIENT__CANCEL}} }{\up6 IDH_BUTTON_ADD_CLIENT__CANCEL \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_EDIT_CLIENT_PAGE1__NAME}}}{\up6  IDH_EDIT_CLIENT_PAGE1__NAME \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_EDIT_CLIENT_PAGE1__ADDRESS}} }{\up6 IDH_EDIT_CLIENT_PAGE1__ADDRESS \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_BUTTON_CLIENT_PAGE1__FIND}}}{\up6  IDH_BUTTON_CLIENT_PAGE1__FIND \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_COMBO_CLIENT_PAGE1__MANUFACTURER}}}{\up6  IDH_COMBO_CLIENT_PAGE1__MANUFACTURER \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_CHECK_CLIENT_PAGE1__ONLY_SUPPORTED_ATTRIBUTES_IN_REPLY}}}{\up6  IDH_CHECK_CLIENT_PAGE1__ONLY_SUPPORTED_ATTRIBUTES_IN_REPLY \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE}}}{\up6  IDH_CHECK_CLIENT_PAGE1__CLIENT_ALWAYS_SENDS_SIGNATURE \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_EDIT_CLIENT_PAGE1__SHARED_SECRET}}}{\up6  IDH_EDIT_CLIENT_PAGE1__SHARED_SECRET \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM}}}{\up6  IDH_EDIT_CLIENT_PAGE1__SHARED_SECRET_CONFIRM \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_CHECK_LOCAL_FILE_LOGGING_PAGE1__ENABLE_LOGGING}}}{\up6  IDH_CHECK_LOCAL_FILE_LOGGING_PAGE1__ENABLE_LOGGING \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_CHECK_LOCAL_FILE_LOGGING_PAGE1__LOG_ACCOUNTING_PACKETS}}}{\up6  IDH_CHECK_LOCAL_FILE_LOGGING_PAGE1__LOG_ACCOUNTING_PACKETS \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_CHECK_LOCAL_FILE_LOGGING_PAGE1__LOG_AUTHENTICATION_PACKETS}}}{\up6  IDH_CHECK_LOCAL_FILE_LOGGING_PAGE1__LOG_AUTHENTICATION_PACKETS \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_CHECK_LOCAL_FILE_LOGGING_PAGE1__LOG_INTERIM_ACCOUNTING_PACKETS}}}{\up6  IDH_CHECK_LOCAL_FILE_LOGGING_PAGE1__LOG_INTERIM_ACCOUNTING_PACKETS \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_CHECK_LOCAL_FILE_LOGGING_PAGE2__AUTOMATICALLY_OPEN_NEW_LOG}}}{\up6  IDH_CHECK_LOCAL_FILE_LOGGING_PAGE2__AUTOMATICALLY_OPEN_NEW_LOG \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY}}}{\up6  IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__DAILY \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY}}}{\up6  IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__WEEKLY \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY}}}{\up6  IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__MONTHLY \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES}}}{\up6  IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__WHEN_LOG_FILE_REACHES \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE}}}{\up6  IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_SIZE \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY}}}{\up6  IDH_EDIT_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_DIRECTORY \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE}}}{\up6  IDH_BUTTON_LOCAL_FILE_LOGGING_PAGE2__BROWSE \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6  IDH_CHECK_LOCAL_FILE_LOGGING_PAGE2__USE_V1_FORMAT}}}{\up6  IDH_CHECK_LOCAL_FILE_LOGGING_PAGE2__USE_V1_FORMAT \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_EDIT_SERVER_PAGE1__NAME}}}{\up6  IDH_EDIT_SERVER_PAGE1__NAME \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6  IDH_CHECK_SERVER_PAGE1__CAPTURE_APPLICATION_EVENTS}}}{\up6  IDH_CHECK_SERVER_PAGE1__CAPTURE_APPLICATION_EVENTS \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6  IDH_CHECK_SERVER_PAGE1__CAPTURE_MALFORMED_PACKETS}}}{\up6  IDH_CHECK_SERVER_PAGE1__CAPTURE_MALFORMED_PACKETS \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6  IDH_CHECK_SERVER_PAGE1__CAPTURE_DEBUG_PACKET}}}{\up6  IDH_CHECK_SERVER_PAGE1__CAPTURE_DEBUG_PACKET \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6 IDH_EDIT_SERVER_PAGE2_AUTHENTICATION_PORT}}}{\up6  IDH_EDIT_SERVER_PAGE2_AUTHENTICATION_PORT \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6  IDH_EDIT_SERVER_PAGE2_ACCOUNTING_PORT}}}{\up6  IDH_EDIT_SERVER_PAGE2_ACCOUNTING_PORT \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6  IDH_EDIT_RESOLVE_DNS_NAME__DNS_NAME}}}{\up6  IDH_EDIT_RESOLVE_DNS_NAME__DNS_NAME \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6  IDH_BUTTON_RESOLVE_DNS_NAME__RESOLVE}}}{\up6  IDH_BUTTON_RESOLVE_DNS_NAME__RESOLVE \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6  IDH_COMBO_RESOLVE_DNS_NAME__RESULT}}}{\up6  IDH_COMBO_RESOLVE_DNS_NAME__RESULT \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6  IDH_BUTTON_RESOLVE_DNS_NAME__USE_THIS_IP}}}{\up6  IDH_BUTTON_RESOLVE_DNS_NAME__USE_THIS_IP \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6  IDH_BUTTON_RESOLVE_DNS_NAME__CANCEL}}}{\up6  IDH_BUTTON_RESOLVE_DNS_NAME__CANCEL \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6  IDH_RADIO_STARTUP_WIZARD_CONNECT__LOCAL_COMPUTER}}}{\up6  IDH_RADIO_STARTUP_WIZARD_CONNECT__LOCAL_COMPUTER \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6  IDH_RADIO_STARTUP_WIZARD_CONNECT__ANOTHER_COMPUTER}}}{\up6  IDH_RADIO_STARTUP_WIZARD_CONNECT__ANOTHER_COMPUTER \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} {\up6  IDH_EDIT_STARTUP_WIZARD_CONNECT__COMPUTER_NAME}}}{\up6  IDH_EDIT_STARTUP_WIZARD_CONNECT__COMPUTER_NAME \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1}}{\up6  IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_IAS1 \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC}}{\up6  IDH_RADIO_LOCAL_FILE_LOGGING_PAGE2__FORMAT_ODBC \par \page }{\cs21\up6 #{\footnote \pard\plain \s22\widctlpar \f4\fs20 {\cs21\up6 #} IDH_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME}}{\up6  IDH_STATIC_LOCAL_FILE_LOGGING_PAGE2__LOG_FILE_NAME} \par }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\iasnt4\placefil.txt ===
readme.htm msft\mgmt\ias
iasnt4.exe msft\mgmt\ias
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\mmc\nap\napmmc.rtf ===
{\rtf1\ansi \deff4\deflang1033{\fonttbl{\f4\froman\fcharset0\fprq2 Times New Roman;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif{\*\falt Century Gothic};}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255; \red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0; \red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\widctlpar \f4\fs20 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\widctlpar \f4\fs20 \sbasedon0\snext15 footnote text;}{\*\cs16 \additive\super  \sbasedon10 footnote reference;}}{\info{\title #define HIDCANCEL                       0x80f60002    // IDD_COND_SELECT_ATTRIBUTE}{\author ms user}{\operator ms user}{\creatim\yr1998\mo4\dy13\hr20\min13}{\revtim\yr1998\mo7\dy31\hr17\min10}{\version8} {\edmins15}{\nofpages43}{\nofwords349}{\nofchars1993}{\*\company  }{\vern57443}}\widowctrl\ftnbj\aenddoc\linkstyles\hyphcaps0\formshade \fet0\sectd \linex0\endnhere {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2 \pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6 \pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain \widctlpar \f4\fs20 {\f7\fs16 #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDCANCEL} Closes the dialog box without saving any changes you have made. \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_BUTTON_CONDITION_ADD} HIDC_BUTTON_CONDITION_ADD - IDD_PROPPAGE_POLICY1 \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_BUTTON_CONDITION_EDIT} HIDC_BUTTON_CONDITION_EDIT - IDD_PROPPAGE_POLICY1 \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_BUTTON_CONDITION_REMOVE} HIDC_BUTTON_CONDITION_REMOVE - IDD_PROPPAGE_POLICY1 \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_BUTTON_EDITPROFILE} HIDC_BUTTON_EDITPROFILE - IDD_PROPPAGE_POLICY1 \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_BUTTON_ENUMCOND_ADD} HIDC_BUTTON_ENUMCOND_ADD - IDD_DIALOG_ENUM_COND \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_BUTTON_ENUMCOND_DELETE} HIDC_BUTTON_ENUMCOND_DELETE - IDD_DIALOG_ENUM_COND \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_BUTTON_HELP} Displays help for this dialog box. \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_CHECK_GRANT_DIALIN} HIDC_CHECK_GRANT_DIALIN - IDD_PROPPAGE_POLICY1 \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_EDIT_COND_TEXT} HIDC_EDIT_COND_TEXT - IDD_DIALOG_MATCH_COND \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_EDIT_POLICYNAME} HIDC_EDIT_POLICYNAME - IDD_PROPPAGE_POLICY1 \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_LIST_CONDITIONS} HIDC_LIST_CONDITIONS - IDD_PROPPAGE_POLICY1 \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_LIST_COND_SELATTR} HIDC_LIST_COND_SELATTR - IDD_COND_SELECT_ATTRIBUTE \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_LIST_ENUMCOND_CHOICE} HIDC_LIST_ENUMCOND_CHOICE - IDD_DIALOG_ENUM_COND \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_LIST_ENUMCOND_SELECTION} HIDC_LIST_ENUMCOND_SELECTION - IDD_DIALOG_ENUM_COND \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_RADIO_STORE_ACTIVEDS} HIDC_RADIO_STORE_ACTIVEDS - IDD_PROPPAGE_POLICIES1 \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_RADIO_STORE_LOCAL} HIDC_RADIO_STORE_LOCAL - IDD_PROPPAGE_POLICIES1 \par \page #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDOK} Closes the dialog box and saves any changes you have made \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_RADIO_RADIUS}}{\f7\fs16  HIDC_IAS_RADIO_RADIUS - IDD_IAS_VENDORSPEC_ATTR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_BUTTON_EDIT}}{\f7\fs16  HIDC_IAS_BUTTON_EDIT - IDD_IAS_MULTIVALUED_EDITOR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_EDIT_MULTI_ATTR_NAME}}{\f7\fs16  HIDC_IAS_EDIT_MULTI_ATTR_NAME - IDD_IAS_MULTIVALUED_EDITOR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_BUTTON_MOVE_UP}}{\f7\fs16  HIDC_IAS_BUTTON_MOVE_UP - IDD_IAS_MULTIVALUED_EDITOR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_RADIO_DENY_DIALIN}}{\f7\fs16  HIDC_RADIO_DENY_DIALIN - IDD_PROPPAGE_POLICY1 \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_EDIT_MULTI_ATTR_FORMAT}}{\f7\fs16  HIDC_IAS_EDIT_MULTI_ATTR_FORMAT  - IDD_IAS_MULTIVALUED_EDITOR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_BUTTON_ADD_CONDITION}}{\f7\fs16  HIDC_BUTTON_ADD_CONDITION - IDD_COND_SELECT_ATTRIBUTE \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_RADIO_GRANT_DIALIN}}{\f7\fs16  HIDC_RADIO_GRANT_DIALIN - IDD_PROPPAGE_POLICY1 \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_COMBO_VENDORID}}{\f7\fs16  HIDC_IAS_COMBO_VENDORID - IDD_IAS_VENDORSPEC_ATTR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_COMBO_ENUM_VALUES}}{\f7\fs16  HIDC_IAS_COMBO_ENUM_VALUES - IDD_IAS_ENUM_ATTR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_EDIT_MULTI_ATTR_NUMBER}}{\f7\fs16  HIDC_IAS_EDIT_MULTI_ATTR_NUMBER - IDD_IAS_MULTIVALUED_EDITOR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_BUTTON_CONFIGURE}}{\f7\fs16  HIDC_IAS_BUTTON_CONFIGURE - IDD_IAS_VENDORSPEC_ATTR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_LIST_MULTI_ATTRS}}{\f7\fs16  HIDC_IAS_LIST_MULTI_ATTRS - IDD_IAS_MULTIVALUED_EDITOR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_BUTTON_ADD_VALUE}}{\f7\fs16  HIDC_IAS_BUTTON_ADD_VALUE - IDD_IAS_MULTIVALUED_EDITOR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_EDIT_ATTRVALUE}}{\f7\fs16  HIDC_IAS_EDIT_ATTRVALUE - IDD_IAS_SINGLE_ATTR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_EDIT_VENDORSPEC_VALUE}}{\f7\fs16  HIDC_IAS_EDIT_VENDORSPEC_VALUE - IDD_IAS_VENDORSPEC_ATTR_CONFORMS_YES \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_STATIC_ATTRFORMAT}}{\f7\fs16  HIDC_IAS_STATIC_ATTRFORMAT - IDD_IAS_IPADDR_ATTR (all attribute editors) \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_STATIC_ATTRNAME}}{\f7\fs16  HIDC_IAS_STATIC_ATTRNAME - IDD_IAS_IPADDR_ATTR (all attribute editors) \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_STATIC_ATTRTYPE}}{\f7\fs16  HIDC_IAS_STATIC_ATTRTYPE - IDD_IAS_IPADDR_ATTR (all attribute editors)\page }{\cs16\f7\fs16\super #{\footnote \pard\plain  \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_BUTTON_REMOVE}}{\f7\fs16  HIDC_IAS_BUTTON_REMOVE - IDD_IAS_MULTIVALUED_EDITOR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_BUTTON_MOVE_DOWN}}{\f7\fs16  HIDC_IAS_BUTTON_MOVE_DOWN - IDD_IAS_MULTIVALUED_EDITOR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_RADIO_HEX}}{\f7\fs16  HIDC_IAS_RADIO_HEX - IDD_IAS_VENDORSPEC_ATTR \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_EDIT_VENDORSPEC_TYPE}}{\f7\fs16  HIDC_IAS_EDIT_VENDORSPEC_TYPE - IDD_IAS_VENDORSPEC_ATTR_CONFORMS_YES \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_COMBO_VENDORSPEC_FORMAT}}{\f7\fs16  HIDC_IAS_COMBO_VENDORSPEC_FORMAT - IDD_IAS_VENDORSPEC_ATTR_CONFORMS_YES \par \page }{\cs16\f7\fs16\super #{\footnote \pard\plain \s15\widctlpar \f4\fs20 {\cs16\super #} HIDC_IAS_EDIT_IPADDR}}{\f7\fs16  HIDC_IAS_EDIT_IPADDR - IDD_IAS_IPADDR_ATTR \par }}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ias\system\perfmon\iasperf.ini ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997, Microsoft Corp. All rights reserved.
//
// FILE
//
//    iasperf.ini
//
// SYNOPSIS
//
//    This is the initialization file for the PerfMon registry entries.
//
// MODIFICATION HISTORY
//
//    09/15/1997    Original version.
//    09/09/1998    Divided authentication and accounting.
//                  Added support for per-client counters.
//    05/13/1999    Improve help text. Add [objects] section.
//    02/18/2000    Added support for proxy counters.
//
///////////////////////////////////////////////////////////////////////////////

[info]
drivername=IAS
symbolfile=iasperf.h

[objects]
RADIUS_AUTH_SERVER_OBJECT_009_NAME=IAS Authentication Server
RADIUS_AUTH_CLIENT_OBJECT_009_NAME=IAS Authentication Clients
RADIUS_ACCT_SERVER_OBJECT_009_NAME=IAS Accounting Server
RADIUS_ACCT_CLIENT_OBJECT_009_NAME=IAS Accounting Clients
PROXY_AUTH_PROXY_OBJECT_009_NAME=IAS Authentication Proxy
PROXY_AUTH_REMSRV_OBJECT_009_NAME=IAS Remote Authentication Servers
PROXY_ACCT_PROXY_OBJECT_009_NAME=IAS Accounting Proxy
PROXY_ACCT_REMSRV_OBJECT_009_NAME=IAS Remote Accounting Servers

[languages]
009=English

[text]
; 009
RADIUS_AUTH_SERVER_OBJECT_009_NAME=IAS Authentication Server
RADIUS_AUTH_CLIENT_OBJECT_009_NAME=IAS Authentication Clients
RADIUS_ACCT_SERVER_OBJECT_009_NAME=IAS Accounting Server
RADIUS_ACCT_CLIENT_OBJECT_009_NAME=IAS Accounting Clients
RADIUS_SRV_UP_TIME_009_NAME=Server Up Time
RADIUS_SRV_RESET_TIME_009_NAME=Server Reset Time
RADIUS_SRV_INVALID_CLIENT_009_NAME=Invalid Requests
RADIUS_SRV_INVALID_CLIENT_RATE_009_NAME=Invalid Requests / sec.
RADIUS_PACKETS_SENT_009_NAME=Packets Sent
RADIUS_PACKETS_SENT_RATE_009_NAME=Packets Sent / sec.
RADIUS_PACKETS_RECEIVED_009_NAME=Packets Received
RADIUS_PACKETS_RECEIVED_RATE_009_NAME=Packets Received / sec.
RADIUS_MALFORMED_PACKET_009_NAME=Malformed Packets
RADIUS_MALFORMED_PACKET_RATE_009_NAME=Malformed Packets / sec.
RADIUS_BAD_AUTHENTICATOR_009_NAME=Bad Authenticators
RADIUS_BAD_AUTHENTICATOR_RATE_009_NAME=Bad Authenticators / sec.
RADIUS_DROPPED_PACKET_009_NAME=Dropped Packets
RADIUS_DROPPED_PACKET_RATE_009_NAME=Dropped Packets / sec.
RADIUS_UNKNOWN_TYPE_009_NAME=Unknown Type
RADIUS_UNKNOWN_TYPE_RATE_009_NAME=Unknown Type / sec.
RADIUS_AUTH_ACCESS_REQUEST_009_NAME=Access-Requests
RADIUS_AUTH_ACCESS_REQUEST_RATE_009_NAME=Access-Requests / sec.
RADIUS_AUTH_DUP_ACCESS_REQUEST_009_NAME=Duplicate Access-Requests
RADIUS_AUTH_DUP_ACCESS_REQUEST_RATE_009_NAME=Duplicate Access-Requests / sec.
RADIUS_AUTH_ACCESS_ACCEPT_009_NAME=Access-Accepts
RADIUS_AUTH_ACCESS_ACCEPT_RATE_009_NAME=Access-Accepts / sec.
RADIUS_AUTH_ACCESS_REJECT_009_NAME=Access-Rejects
RADIUS_AUTH_ACCESS_REJECT_RATE_009_NAME=Access-Rejects / sec.
RADIUS_AUTH_ACCESS_CHALLENGE_009_NAME=Access-Challenges
RADIUS_AUTH_ACCESS_CHALLENGE_RATE_009_NAME=Access-Challenges / sec.
RADIUS_ACCT_REQUEST_009_NAME=Accounting-Requests
RADIUS_ACCT_REQUEST_RATE_009_NAME=Accounting-Requests / sec.
RADIUS_ACCT_DUP_REQUEST_009_NAME=Duplicate Accounting-Requests
RADIUS_ACCT_DUP_REQUEST_RATE_009_NAME=Duplicate Accounting-Requests / sec.
RADIUS_ACCT_RESPONSE_009_NAME=Accounting-Responses
RADIUS_ACCT_RESPONSE_RATE_009_NAME=Accounting-Responses / sec.
RADIUS_ACCT_NO_RECORD_009_NAME=No Record
RADIUS_ACCT_NO_RECORD_RATE_009_NAME=No Record / sec.
PROXY_AUTH_PROXY_OBJECT_009_NAME=IAS Authentication Proxy
PROXY_AUTH_REMSRV_OBJECT_009_NAME=IAS Remote Authentication Servers
PROXY_ACCT_PROXY_OBJECT_009_NAME=IAS Accounting Proxy
PROXY_ACCT_REMSRV_OBJECT_009_NAME=IAS Remote Accounting Servers
PROXY_INVALID_ADDRESS_009_NAME=Invalid Addresses
PROXY_INVALID_ADDRESS_RATE_009_NAME=Invalid Addresses / sec.
PROXY_REMSRV_PORT_009_NAME=Port Number
PROXY_REMSRV_ROUND_TRIP_009_NAME=Last Round-Trip Time
PROXY_PENDING_009_NAME=Pending Requests
PROXY_TIMEOUT_009_NAME=Request Timeouts
PROXY_TIMEOUT_RATE_009_NAME=Request Timeouts / sec.
PROXY_RETRANSMISSION_009_NAME=Retransmissions
PROXY_RETRANSMISSION_RATE_009_NAME=Retransmissions / sec.
PROXY_AUTH_ACCESS_REQUEST_009_NAME=Access-Requests
PROXY_AUTH_ACCESS_REQUEST_RATE_009_NAME=Access-Requests / sec.
PROXY_AUTH_ACCESS_ACCEPT_009_NAME=Access-Accepts
PROXY_AUTH_ACCESS_ACCEPT_RATE_009_NAME=Access-Accepts / sec.
PROXY_AUTH_ACCESS_REJECT_009_NAME=Access-Rejects
PROXY_AUTH_ACCESS_REJECT_RATE_009_NAME=Access-Rejects / sec.
PROXY_AUTH_ACCESS_CHALLENGE_009_NAME=Access-Challenges
PROXY_AUTH_ACCESS_CHALLENGE_RATE_009_NAME=Access-Challenges / sec.
PROXY_ACCT_REQUEST_009_NAME=Accounting-Requests
PROXY_ACCT_REQUEST_RATE_009_NAME=Accounting-Requests / sec.
PROXY_ACCT_RESPONSE_009_NAME=Accounting-Responses
PROXY_ACCT_RESPONSE_RATE_009_NAME=Accounting-Responses / sec.

RADIUS_AUTH_SERVER_OBJECT_009_HELP=IAS Authentication Server
RADIUS_AUTH_CLIENT_OBJECT_009_HELP=IAS Authentication Clients
RADIUS_ACCT_SERVER_OBJECT_009_HELP=IAS Accounting Server
RADIUS_ACCT_CLIENT_OBJECT_009_HELP=IAS Accounting Clients
RADIUS_SRV_UP_TIME_009_HELP=The time elapsed (in hundredths of a second) since the server process was started.
RADIUS_SRV_RESET_TIME_009_HELP=The time elapsed (in hundredths of a second) since the server configuration was reset.
RADIUS_SRV_INVALID_CLIENT_009_HELP=The number of packets received from unknown addresses.
RADIUS_SRV_INVALID_CLIENT_RATE_009_HELP=The number of packets received per second from unknown addresses.
RADIUS_PACKETS_SENT_009_HELP=The number of packets sent.
RADIUS_PACKETS_SENT_RATE_009_HELP=The number of packets sent per second.
RADIUS_PACKETS_RECEIVED_009_HELP=The number of packets received.
RADIUS_PACKETS_RECEIVED_RATE_009_HELP=The number of packets per second received.
RADIUS_MALFORMED_PACKET_009_HELP=The number of malformed packets received. Bad authenticators or unknown types are not included.
RADIUS_MALFORMED_PACKET_RATE_009_HELP=The number of malformed packets per second received. Bad authenticators or unknown types are not included.
RADIUS_BAD_AUTHENTICATOR_009_HELP=The number of packets which contained invalid Signature attributes.
RADIUS_BAD_AUTHENTICATOR_RATE_009_HELP=The number of packets per second which contained invalid Signature attributes.
RADIUS_DROPPED_PACKET_009_HELP=The number of incoming packets silently discarded for a reason other than malformed, bad authenticators, or unknown types.
RADIUS_DROPPED_PACKET_RATE_009_HELP=The number of incoming packets per second silently discarded for a reason other than malformed, bad authenticators, or unknown types.
RADIUS_UNKNOWN_TYPE_009_HELP=The number of packets of unknown type which were received.
RADIUS_UNKNOWN_TYPE_RATE_009_HELP=The number of packets per second of unknown type which were received.
RADIUS_AUTH_ACCESS_REQUEST_009_HELP=The number of packets received on the authentication port from this client.
RADIUS_AUTH_ACCESS_REQUEST_RATE_009_HELP=The number of packets per second received on the authentication port from this client.
RADIUS_AUTH_DUP_ACCESS_REQUEST_009_HELP=The number of duplicate RADIUS Access-Request packets received from this client.
RADIUS_AUTH_DUP_ACCESS_REQUEST_RATE_009_HELP=The number of duplicate RADIUS Access-Request packets per second received from this client.
RADIUS_AUTH_ACCESS_ACCEPT_009_HELP=The number of RADIUS Access-Accept packets sent to this client.
RADIUS_AUTH_ACCESS_ACCEPT_RATE_009_HELP=The number of RADIUS Access-Accept packets per second sent to this client.
RADIUS_AUTH_ACCESS_REJECT_009_HELP=The number of RADIUS Access-Reject packets sent to this client.
RADIUS_AUTH_ACCESS_REJECT_RATE_009_HELP=The number of RADIUS Access-Reject packets per second sent to this client.
RADIUS_AUTH_ACCESS_CHALLENGE_009_HELP=The number of RADIUS Access-Challenge packets sent to this client.
RADIUS_AUTH_ACCESS_CHALLENGE_RATE_009_HELP=The number of RADIUS Access-Challenge packets per second sent to this client.
RADIUS_ACCT_REQUEST_009_HELP=The number of packets received from this client on the accounting port.
RADIUS_ACCT_REQUEST_RATE_009_HELP=The number of packets per second received from this client on the accounting port.
RADIUS_ACCT_DUP_REQUEST_009_HELP=The number of duplicate RADIUS Accounting-Request packets received from this client.
RADIUS_ACCT_DUP_REQUEST_RATE_009_HELP=The number of duplicate RADIUS Accounting-Request packets per second received from this client.
RADIUS_ACCT_RESPONSE_009_HELP=The number of RADIUS Accounting-Response packets sent to this client.
RADIUS_ACCT_RESPONSE_RATE_009_HELP=The number of RADIUS Accounting-Response packets per second sent to this client.
RADIUS_ACCT_NO_RECORD_009_HELP=The number of RADIUS Accounting-Request packets which were received and responded to but not recorded.
RADIUS_ACCT_NO_RECORD_RATE_009_HELP=The number of RADIUS Accounting-Request packets per second which were received and responded to but not recorded.
PROXY_AUTH_PROXY_OBJECT_009_HELP=IAS Authentication Proxy
PROXY_AUTH_REMSRV_OBJECT_009_HELP=IAS Remote Authentication Servers
PROXY_ACCT_PROXY_OBJECT_009_HELP=IAS Accounting Proxy
PROXY_ACCT_REMSRV_OBJECT_009_HELP=IAS Remote Accounting Servers
PROXY_INVALID_ADDRESS_009_HELP=The number of packets received from unknown addresses.
PROXY_INVALID_ADDRESS_RATE_009_HELP=The number of packets per second received from unknown addresses.
PROXY_REMSRV_PORT_009_HELP=The UDP port the proxy is using to send requests to this server.
PROXY_REMSRV_ROUND_TRIP_009_HELP=The time interval (in hundredths of a second) between the most recent request and the response that matched it from this server.
PROXY_PENDING_009_HELP=The number of requests destined for this server that have not yet timed out or received a response.
PROXY_TIMEOUT_009_HELP=The number of request timeouts to this server.
PROXY_TIMEOUT_RATE_009_HELP=The number of request timeouts per second to this server.
PROXY_RETRANSMISSION_009_HELP=The number of requests retransmitted to this server.
PROXY_RETRANSMISSION_RATE_009_HELP=The number of requests retransmitted per second to this server.
PROXY_AUTH_ACCESS_REQUEST_009_HELP=The number of RADIUS Access-Request packets sent to this server.
PROXY_AUTH_ACCESS_REQUEST_RATE_009_HELP=The number of RADIUS Access-Request packets per second sent to this server.
PROXY_AUTH_ACCESS_ACCEPT_009_HELP=The number of RADIUS Access-Accept packets received from this server.
PROXY_AUTH_ACCESS_ACCEPT_RATE_009_HELP=The number of RADIUS Access-Accept packets per second received from this server.
PROXY_AUTH_ACCESS_REJECT_009_HELP=The number of RADIUS Access-Reject packets received from this server.
PROXY_AUTH_ACCESS_REJECT_RATE_009_HELP=The number of RADIUS Access-Reject packets per second received from this server.
PROXY_AUTH_ACCESS_CHALLENGE_009_HELP=The number of RADIUS Access-Challenge packets received from this server.
PROXY_AUTH_ACCESS_CHALLENGE_RATE_009_HELP=The number of RADIUS Access-Challenge packets per second received from this server.
PROXY_ACCT_REQUEST_009_HELP=The number of RADIUS Accounting-Request packets sent to this server.
PROXY_ACCT_REQUEST_RATE_009_HELP=The number of RADIUS Accounting-Request packets per second sent to this server.
PROXY_ACCT_RESPONSE_009_HELP=The number of RADIUS Accounting-Response packets received from this server.
PROXY_ACCT_RESPONSE_RATE_009_HELP=The number of RADIUS Accounting-Response packets per second received from this server.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\readme.txt ===
IPSEC POLICY CONFIGURATION COMMAND LINE TOOL: "IPSECCMD"
by Randy Ramig (RandyRam@Microsoft.com)
and Dennis Kalinichenko (DKalin@Microsoft.com)

This tool is used to configure IP Security policies in the Directory
Service, or in a local or remote registry.  It does everything that the
IP Security MMC snap-in does, and is even modeled after the snap-in.

It can also query the IPSec Security Policies Database (SPD).

No regkeys required

The tool will NOT be localized.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\overview.txt ===
IPSEC POLICY CONFIGURATION COMMAND LINE TOOL
by Randy Ramig (RandyRam@Microsoft.com)
and Dennis Kalinichenko (DKalin@Microsoft.com)

This tool is used to configure IP Security policies in the Directory
Service, or in a local or remote registry.  It does everything that the
IP Security MMC snap-in does, and is even modeled after the snap-in.

In addition, it can query IPSec Security Policies Database (SPD) and
display the current state of IPSec Services

ipseccmd has three mutually exclusive modes: static, dynamic and query. 

Dynamic mode will plumb policy into the IPSec Services 
Security Policies Database. The policy will be persisted, ie. it will stay
after a reboot.  The benefit of dynamic mode is that the policy can co-exist 
with DS based policies, which overrides any local policy not plumbed 
by ipseccmd.

When the tool is used in static mode,
it creates or modifies stored policy.  This policy can be used again and 
will last the lifetime of the store. Static mode is indicated by the -w
flag.  The flags in the {} braces are only valid for static mode.  The usage 
for static mode is an extension of dynamic mode, so please read through
the dynamic mode section.

In query mode, the tool queries IPSec Security Policies Database.

WHY WOULD I WANT TO USE IPSECCMD?

*   You have a large and/or complex IPSec policy that you want to 
    configure.  IPSECCMD can help you by providing a scriptable way to
    create that policy.  Just put your IPSECCMD commands into a batch file.
    
    This also provides a backup in case you lose the DS or registry that
    the policy is stored in.  Just re-run the batch file.

*   IPSECCMD facilitates just in time policy with it's batch ability.
    If someone wants a secured channel with your server, simply send them
    the tool binaries and the command line or batch file to run.

*   Your machine is using DS policy and you want to enhance or add rules
    that will allow you to speak IPSec to machines not covered in the 
    DS policy.  Dynamic mode of IPSECCMD will achieve this for you.

*   You prefer command line tools to GUI apps.

RESTRICTIONS

You must have privileges to the storage that you write to in static mode.
This is typically administrative privileges, but authorized users can
modify the ACLs of the storage to give you access.  IP Security policy 
objects are stored in

HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\IPSec\Policy\Local
    for the local/remote machine case
AND

CN=IP Security,CN=System,DC=YourDCName,DC=ParentDCName,DC=TopLevelDC
    ie, the IP Security container under the System container,
    for the Directory Service case.

CAVEATS

*   In dynamic mode, if you use a DNS name that resolves to multiple addresses
    only the first address in the list is used.  This is not a problem in
    static mode.

*   Read the filter spec help carefully, it is the most difficult and
    easiest to confuse.  In particular, pay attention to how a protocol
    is specified.

REQUIRED FILES:
ipseccmd.exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\readme.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Filename Title _PID_HLINKSFilename A-MARGPL Normal.dot Dennis Kalinichenko Microsoft Word 9.0@\\msprint44\CORP0150 Ne00: winspool HP LaserJet 8100 Series PCL \\msprint44\CORP0150 Letter DINU" \\msprint44\CORP0150 Letter DINU" T&dU,ipseccmd.exe  IP Security Policy Configuration Tool Contents Introduction Command-line Syntax Tips and Examples for Using IPSECCMD Notes and Caveats Feedback Introduction IPSECCMD  is a command line tool used to configure IP Security policies in the Directory Service, or in a local or remote registry.  It does almost everything that the IP Security MMC snap-in does, and is even modeled after the snap-in. In addition, it can query IPSec Security Policies Database (SPD) and display the current state of IPSec Services IPSECCMD has three mutually exclusive modes: static, dynamic, and query  Dynamic mode will plumb policy into the IPSec Services Security Policies Database. The policy will be persisted, ie. it will stay after a reboot.  The benefit of dynamic mode is that the policy can co-exist with DS based policies, which overrides any local policy not plumbed by ipseccmd. To delete all dynamic policies, execute "ipseccmd -u" command When the tool is used in static mode, it creates or modifies stored policy.   This policy can be used again and will last the lifetime of the store.  This is the mode that the IP Security MMC snap-in uses.  In query mode, the tool queries IPSec Security Policies Database. WHY WOULD YOU WANT TO USE IPSECCMD? *  You have a large and/or complex IPSec policy that you want to      configure.  IPSECCMD can help you by providing a scriptable way to     create that policy.  Just put your IPSECCMD commands into a batch file.     This also provides a backup in case you lose the DS or registry that     the policy is stored in.  Just re-run the batch file. *   IPSECCMD facilitates just in time policy with it's batch ability.     If someone wants a secured channel with your server, simply send them     the tool binaries and the command line or batch file to run. *   Your machine is using DS policy and you want to add rules     that will allow you to speak IPSec to machines not covered in the      DS policy.  Dynamic mode of IPSECCMD will achieve this for you. *   You prefer command line tools to GUI apps. For a more thorough explanation of IP Security policy terminology, see the online Help for the IP Security MMC snap-in. Type a brief description of your tool. What does it do? Who can benefit from using it? Command Reference USAGE:  ipseccmd \\machinename -f FilterList -n NegotiationPolicyList -t TunnelAddr          -a AuthMethodList -1s SecurityMethodList -1k Phase1RekeyAfter -1p          -1f MMFilterList -1e SoftSAExpirationTime -soft -confirm            [-dialup OR -lan]           {-w TYPE:DOMAIN -p PolicyName:PollInterval -r RuleName -x -y -o} ipseccmd \\\\machinename show filters policies auth stats sas all BATCH MODE: ipseccmd -file filename          File must contain regular ipseccmd commands,          all these commands will be executed in one shot. ipseccmd has three mutually exclusive modes: static, dynamic, and query. The default mode is dynamic.  Dynamic mode will plumb policy directly into the IPSec Services Security Policies Database. The policy will be persisted, i.e. it will stay after a reboot. The benefit of dynamic policy is that it can co-exist with DS based policy. To delete all dynamic policies, execute "ipseccmd -u" command When the tool is used in static mode, it creates or modifies stored policy.  This policy can be used again and  will last the lifetime of the store. Static mode is indicated by the -w flag.  The flags in the {} braces are only valid for static mode.  The usage  for static mode is an extension of dynamic mode, so please read through the dynamic mode section. In query mode, the tool queries IPSec Security Policies Database. NOTE: references to SHA in ipseccmd are referring to the SHA1 algorithm.  QUERY MODE  The tool displays requested type of data from IPSec Security Policies Database  filters   - shows main mode and quick mode filters  policies  - shows main mode and quick mode policies  auth      - shows main mode authentication methods  stats     - shows Internet Key Exchange (IKE) and IPSec statistics  sas       - shows main mode and quick mode Security Associations  all       - shows all of the above data It is possible to combine several flags EXAMPLE: ipseccmd show filters policies DYNAMIC MODE Each execution of the tool sets an IPSec rule, an IKE policy, or both.  When setting the IPSec policy,  think of it as setting an "IP Security Rule" in the UI.  So, if you need to set up a tunnel policy, you will need to execute  the tool twice, once for the outbound filters and outgoing tunnel endpoint, and once for the inbound filters and incoming tunnel endpoint. OPTIONS:   \\machinename sets policies on that machine.  If not included, the    local machine is assumed.   NOTE: that if you use this it must be the first argument AND   you MUST have administrative privileges on that machine.   -confirm will ask you to confirm before setting policy       can be abbreviated to -c       *OPTIONAL, DYNAMIC MODE ONLY*   The following flags deal with IPSec policy. If omitted, a default value    is used where specified.   -f FilterList        where FilterList is one or more space separated filterspecs       a filterspec is of the format:       A.B.C.D/mask:port=A.B.C.D/mask:port:protocol         you can also specify DEFAULT to create default response rule       The Source address is always on the left of the '=' and the Destination        address is always on the right.         MIRRORING: If you replace the '=' with a '+' two filters will be created,        one in each direction.       mask and port are optional.  If omitted, Any port and       mask 255.255.255.255 will be used for the filter.         You can replace A.B.C.D/mask with the following for        special meaning:       0 means My address(es)       * means Any address       a DNS name (NOTE: multiple resolutions are ignored) a GUID of the local network interface in the form  {12345678-1234-1234-1234-123456789ABC} GUIDs are NOT supported for static mode       protocol is optional, if omitted, Any protocol is assumed.  If you           indicate a protocol, a port must precede it or :: must preceded it.       NOTE BENE: if protocol is specified, it must be the last item in                   the filter spec.        Examples:       Machine1+Machine2::6 will filter TCP traffic between Machine1 and Machine2       172.31.0.0/255.255.0.0:80=157.0.0.0/255.0.0.0:80:TCP will filter         all TCP traffic from the first subnet, port 80 to the second subnet,          port 80       PASSTHRU and DROP filters: By surrounding a filter specification with (),        the filter will be a passthru filter.  If you surround it with [], the        filter will be a blocking, or drop, filter.        Example: (0+128.2.1.1) will create 2 filters (it's mirrored) that will        be exempted from policy.       You can use the following protocol symbols: ICMP UDP RAW TCP          Star notation:       If you're subnet masks are along octet boundaries, then you       can use the star notation to wildcard subnets.       Examples:       128.*.*.* is same as 128.0.0.0/255.0.0.0       128.*.* is the same as above       128.* is the same as above       144.92.*.* is same as 144.92.0.0/255.255.0.0       There is no DEFAULT, -f is required   -n NegotiationPolicyList        where NegotiationPolicyList is one or more space separated        IPSec policies in the one of the following forms:       ESP[ConfAlg,AuthAlg]RekeyPFS[Group]        AH[HashAlg]        AH[HashAlg]+ESP[ConfAlg,AuthAlg]       where ConfAlg can be NONE, DES, or 3DES       and AuthAlg can be NONE, MD5, or SHA       and HashAlg is MD5 or SHA       NOTE: ESP[NONE,NONE] is not a supported config       NOTE: SHA refers the SHA1 hash algorithm       Rekey is number of KBytes or number of seconds to rekey        put K or S after the number to indicate KBytes or seconds, respectively       Example: 3600S will rekey after 1 hour       To use both, separate with a slash.       Example: 3600S/5000K will rekey every hour and 5 MB.       REKEY PARAMETERS ARE OPTIONAL       PFS this is OPTIONAL, if it is present it will enable phase 2 perfect       forward secrecy.  You may use just P for short. It is also possible to specify which PFS Group to use: PFS1 or P1, PFS2 or P2 By Default, PFS Group value will be taken from current Main Mode settings       DEFAULT: ESP[3DES,SHA] ESP[3DES,MD5] ESP[DES,SHA]                ESP[DES,MD5]   -t tunnel address in one of the following forms:       A.B.C.D       DNS name       DEFAULT: omission of tunnel address assumes transport mode   -a AuthMethodList        A list of space separated auth methods of the form:       PRESHARE:"preshared key string"       KERBEROS       CERT:"CA Info"       The strings provided to preshared key and CA info ARE case sensitive.       You can abbreviate the method with the first letter, ie. P, K, or C.       DEFAULT: KERBEROS   -soft will allow soft associations       DEFAULT: don't allow soft SAs   -lan will set policy only for lan adapters   -dialup will set policy only for dialup adapters       *BOTH ARE OPTIONAL, if not specified, All adapters are used*       DEFAULT: All adapters   The following deal with IKE phase 1 policy.  An easy way to remember   is that all IKE phase 1 parameters are passed with a 1 in the flag.   If no IKE flags are specified, the current IKE policy   will be used.  If there is no current IKE policy, the defaults    specified below will be used.   -1s SecurityMethodList       where SecurityMethodList is one or more space separated SecurityMethods       in the form:       ConfAlg-HashAlg-GroupNum       where ConfAlg can be DES or 3DES       and HashAlg is MD5 or SHA       and GroupNum is:       1 (Low)       2 (Med)       Example: DES-SHA-1       DEFAULT: 3DES-SHA-2 3DES-MD5-2 DES-SHA-1 DES-MD5-1   -1p enable PFS for phase 1       DEFAULT: not enabled   -1k number of Quick Modes or number of seconds to rekey for phase 1       put Q or S after the number to indicate Quick Modes or seconds,        respectively       Example: 10Q will rekey after 10 quick modes       To use both, separate with a slash.       Example: 10Q/3600S will rekey every hour and 10 quick modes       *OPTIONAL*       DEFAULT: no QM limit, 480 min lifetime   -1e SoftSAExpirationTime       set Soft SA expiration time attribute of the main mode policy        value is specified in seconds       DEFAULT: not set if Soft SA is not allowed                set to 300 seconds if Soft SA is allowed   -1f MMFilterList       set specific main mode filters. Syntax is the same as for -f option        except that you cannot specify passthru, block filters, ports and protocols       DEFAULT: filters are generated automatically based on quick mode filters STATIC MODE Static mode uses most of the dynamic mode syntax, but adds a few flags that enable it work at a policy level as well.  Remember, dynamic mode just lets you add anonymous rules to the policy agent.  Static mode allows you to create named policies and named rules.  It also has some functionality to modify existing policies and rules, provided they were originally created with ipseccmd. Static mode is supposed to provide most of the functionality of the IPSec UI in a command line tool, so there are references here to the UI. First, there is one change to the dynamic mode usage that static mode requires.  In static mode, pass through and block filters are indicated in the NegotiationPolicyList that is specified by -n.  There are three items you can pass in the NegotiationPolicyList that have special meaning: BLOCK will ignore the rest of the policies in NegotiationPolicyList and        will make all of the filters blocking or drop filters.       This is the same as checking the "Block" radio button       in the UI PASS  will ignore the rest of the policies in NegotiationPolicyList and        will make all of the filters pass through filters.       This is the same as checking the "Permit"       radio button in the UI INPASS will plumb any inbound filters as pass through.        This is the same as checking the "Allow unsecured communication,        but always respond using IPSEC" check box in the UI         Static Mode flags: All flags are REQUIRED unless otherwise indicated. -w Write the policy to storage indicated by TYPE:LOCATION    TYPE can be either REG for registry or DS for Directory Storage         if \\machinename was specified and TYPE is REG, will be written         to the remote machine's registry    DOMAIN for the DS case only. Indicates the domain name of the           DS to write to. If omitted, use the domain the local machine is in.           OPTIONAL -p PolicyName:PollInterval    Name the policy with this string.  If a policy with this name is    already in storage, this rule will be added to the policy.     Otherwise a new policy will be created.  If PollInterval is specified,    the polling interval for the policy will be set. -r RuleName    Name the rule with this string.  If a rule with that name already exists,    that rule is modified to reflect the information supplied to ipseccmd.    For example, if only -f is specified and the rule exists,    only the filters of that rule will be replaced.  -x will set the policy active in the LOCAL registry case OPTIONAL -y will set the policy inactive in the LOCAL registry case OPTIONAL -o will delete the policy specified by -p OPTIONAL    (NOTE: this will delete all aspects of the specified policy     don't use if you have other policies pointing to the objects in that policy) Tips and Examples for Using IPSECCMD At the bare minimum,  you need is to specify at least one flag, otherwise the help kicks in. There are defaults for all flags except -f.  Typically you will always provide  f to specify what filters to apply the policy to.  An exception is for the  y or  x or  u flags, which delete policies or rules.  For tunnel policies, specify your tunnel endpoint with -t. REMEMBER: each time you run ipseccmd you are plumbing a "rule" into  ipsec.  So for tunnel policies, you'll have to run the tool twice, once for the inbound and once for the outbound. DON'T USE MIRRORING (the plus symbol) IN YOUR TUNNEL FILTERS! Example 1: Dynamic mode for all traffic from this host to any other host. ipseccmd -f 0+* -n ah[md5] will set a mirrored filter of me to any using AH md5.  Uses Kerberos for oakley auth ON THE LOCAL MACHINE Example 2: Setting dynamic policy on a remote machine ipseccmd \\foobar0 -f foobar+foobar0 -n esp[des,sha]+ah[md5]  -apreshare:tooltime -c mirrored filter between the two machines named foobar and foobar0, using and AND proposal and a preshared key.  SETS POLICY ON \\foobar0 Example 3:  Tunnel Policy ipseccmd -f 128.2.1.1=128.2.1.13 -t 128.2.1.13 -n ah[sha]  -apreshare:tooltime -1s des40-md5-3 -1p -c ipseccmd -f 128.2.1.13=128.2.1.1 -t 128.2.1.1 -n ah[sha]  -apreshare:tooltime -1s des40-md5-3 -1p -c AH tunnel between the two specified IP addresses.  Note the phase 1 security method is set with PFS.  Also uses -confirm, abbriviated. Example 4: Using static mode ipseccmd -w DS -p "Default Domain Policy":30 -r "Secured Servers" -f 0+SecuredServer1  0+SecuredServer2 -n ESP[MD5,DES] AH[MD5] -a KERBEROS P:ace -lan this would set up a policy in the Directory Service for the domain that the machine running this command is in.  It sets up a DS based policy for clients to two secured servers.  Both ESP and AH are sent as security offers and the machines negotiate which one they will use. Note the use of abbreviation in the authentication methods  (KERBEROS could have been abbreviated as a K) and that this rule is only for LAN interfaces. Example 5:  Using static mode ipseccmd -w REG -r "Me to Anyone" -p "Secure My Traffic" -f 0+*  -n AH[MD5] -a P:ace -x this would set up a local policy that would negotiate properly with the policy from example 4, so it would be run on SecuredServer1 or SecuredServer2.   Note the use of -x to make the policy active. Example 6:  Using query  mode ipseccmd   HYPERLINK "\\\\RemoteMachine"  \\RemoteMachine  show filters policies  this would show IPSec filters and policies information from the RemoteMachine. You must have administrative rights on RemoteMachine for this command to complete successfully. Example 7:  Using query  mode ipseccmd show all  this would show all information from IPSec Security Policies Database (SPD), or the complete IPSec state of the local machine. Notes Important You must have specific privileges for both dynamic and static mode.  For static mode, you must have read/write access to the storage that you write to in static mode.  For dynamic mode, you must have Administrator privleges on the machine that you are plumbing the dynamic policy to. For static mode, authorized users can modify the ACLs of the storage to give you access.  IP Security policy objects are stored in: HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\IPSec\\Policy\Local for the local/remote machine case AND CN=IP Security,CN=System,DC=YourDCName,DC=ParentDCName,DC=TopLevelDC  ie, the IP Security container under the System container  for the Directory Service case. CAVEATS In dynamic mode, if you use a DNS name that resolves to multiple addresses only the first address in the list is used.  This is not a problem in static mode. Read the filter spec help carefully, it is the most difficult and easiest to confuse.  In particular, pay attention to how a protocol is specified. Notes List all the comments, special considerations, features, and restrictions that you can think of.  Use a separate paragraph for each subject. Important If something is important, you can put it in an Important box by typing important and pressing f3. Warning There may be something you want to warn users about. To put information in a Warning box, type warning and press f3. Other Information Include information here on everything you can think of that you haven t been able to place in the sections we ve provided for you. Copy this paragraph and its heading, and customize them to suit your needs. Please include the following section as is: Feedback For questions or feedback concerning this utility, please contact rkinput@microsoft.com.   Part 1    Part Head Chapter 1    Chapter Head
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\usage.txt ===
v1.51 Copyright(c) 1998-2001, Microsoft Corporation
USAGE: 
ipseccmd \\machinename -f FilterList -n NegotiationPolicyList -t TunnelAddr
         -a AuthMethodList -1s SecurityMethodList -1k Phase1RekeyAfter -1p
         -1f MMFilterList -1e SoftSAExpirationTime -soft -confirm
         [-dialup OR -lan]
         {-w TYPE:DOMAIN -p PolicyName:PollInterval -r RuleName -x -y -o}
ipseccmd \\machinename show filters policies auth stats sas all
 

BATCH MODE:
ipseccmd -file filename
         File must contain regular ipseccmd commands,
         all these commands will be executed in one shot.
 

ipseccmd has three mutually exclusive modes: static, dynamic, and query. 

The default mode is dynamic. 

Dynamic mode will plumb policy directly into the IPSec Services
Security Policies Database. The policy will be persisted, i.e. it will stay
after a reboot. The benefit of dynamic policy is that it can co-exist with
DS based policy.

To delete all dynamic policies, execute "ipseccmd -u" command

When the tool is used in static mode,
it creates or modifies stored policy.  This policy can be used again and 
will last the lifetime of the store. Static mode is indicated by the -w
flag.  The flags in the {} braces are only valid for static mode.  The usage 
for static mode is an extension of dynamic mode, so please read through
the dynamic mode section.

In query mode, the tool queries IPSec Security Policies Database.

NOTE: references to SHA in ipseccmd are referring to the SHA1 algorithm.

------------
 QUERY MODE 
------------

The tool displays requested type of data from IPSec Security Policies Database

 filters   - shows main mode and quick mode filters
 policies  - shows main mode and quick mode policies
 auth      - shows main mode authentication methods
 stats     - shows Internet Key Exchange (IKE) and IPSec statistics
 sas       - shows main mode and quick mode Security Associations
 all       - shows all of the above data
It is possible to combine several flags
EXAMPLE: ipseccmd show filters policies

------------
DYNAMIC MODE
------------

Each execution of the tool sets an IPSec rule, an IKE policy,
or both.  When setting the IPSec policy,  think of it as setting an "IP Security Rule" 
in the UI.  So, if you need to set up a tunnel policy, you will need
to execute  the tool twice, once for the outbound filters and outgoing tunnel
endpoint, and once for the inbound filters and incoming tunnel endpoint.


OPTIONS:
  
  \\machinename sets policies on that machine.  If not included, the 
  local machine is assumed.
  NOTE: that if you use this it must be the first argument AND
  you MUST have administrative privileges on that machine.

  -confirm will ask you to confirm before setting policy
      can be abbreviated to -c
      *OPTIONAL, DYNAMIC MODE ONLY*

  The following flags deal with IPSec policy. If omitted, a default value 
  is used where specified.

  -f FilterList 
      where FilterList is one or more space separated filterspecs
      a filterspec is of the format:
      A.B.C.D/mask:port=A.B.C.D/mask:port:protocol
        you can also specify DEFAULT to create default response rule

      The Source address is always on the left of the '=' and the Destination 
      address is always on the right.  

      MIRRORING: If you replace the '=' with a '+' two filters will be created, 
      one in each direction.

      mask and port are optional.  If omitted, Any port and
      mask 255.255.255.255 will be used for the filter.  

      You can replace A.B.C.D/mask with the following for 
      special meaning:
      0 means My address(es)
      * means Any address
      a DNS name (NOTE: multiple resolutions are ignored)
      a GUID of the local network interface in the form {12345678-1234-1234-1234-123456789ABC}
        GUIDs are NOT supported for static mode

      protocol is optional, if omitted, Any protocol is assumed.  If you    
      indicate a protocol, a port must precede it or :: must preceded it.
      NOTE BENE: if protocol is specified, it must be the last item in 
                 the filter spec. 

      Examples:
      Machine1+Machine2::6 will filter TCP traffic between Machine1 and Machine2
      172.31.0.0/255.255.0.0:80=157.0.0.0/255.0.0.0:80:TCP will filter
        all TCP traffic from the first subnet, port 80 to the second subnet, 
        port 80

      PASSTHRU and DROP filters: By surrounding a filter specification with (), 
      the filter will be a passthru filter.  If you surround it with [], the 
      filter will be a blocking, or drop, filter. 
      Example: (0+128.2.1.1) will create 2 filters (it's mirrored) that will 
      be exempted from policy.

      You can use the following protocol symbols: ICMP UDP RAW TCP   

      Star notation:
      If you're subnet masks are along octet boundaries, then you
      can use the star notation to wildcard subnets.
      Examples:
      128.*.*.* is same as 128.0.0.0/255.0.0.0
      128.*.* is the same as above
      128.* is the same as above
      144.92.*.* is same as 144.92.0.0/255.255.0.0

      There is no DEFAULT, -f is required
 
  -n NegotiationPolicyList 
      where NegotiationPolicyList is one or more space separated 
      IPSec policies in the one of the following forms:

      ESP[ConfAlg,AuthAlg]RekeyPFS[Group] 
      AH[HashAlg] 
      AH[HashAlg]+ESP[ConfAlg,AuthAlg]

      where ConfAlg can be NONE, DES, or 3DES
      and AuthAlg can be NONE, MD5, or SHA
      and HashAlg is MD5 or SHA

      NOTE: ESP[NONE,NONE] is not a supported config
      NOTE: SHA refers the SHA1 hash algorithm

      Rekey is number of KBytes or number of seconds to rekey 
      put K or S after the number to indicate KBytes or seconds, respectively
      Example: 3600S will rekey after 1 hour
      To use both, separate with a slash.
      Example: 3600S/5000K will rekey every hour and 5 MB.

      REKEY PARAMETERS ARE OPTIONAL

      PFS this is OPTIONAL, if it is present it will enable phase 2 perfect
      forward secrecy.  You may use just P for short.
      It is also possible to specify which PFS Group to use: 
        PFS1 or P1, PFS2 or P2
      By Default, PFS Group value will be taken from current Main Mode settings
      DEFAULT: ESP[3DES,SHA] ESP[3DES,MD5] ESP[DES,SHA]
               ESP[DES,MD5]

  -t tunnel address in one of the following forms:
      A.B.C.D
      DNS name

      DEFAULT: omission of tunnel address assumes transport mode

  -a AuthMethodList 
      A list of space separated auth methods of the form:
      PRESHARE:"preshared key string"
      KERBEROS
      CERT:"CA Info"

      The strings provided to preshared key and CA info ARE case sensitive.
      You can abbreviate the method with the first letter, ie. P, K, or C.

      DEFAULT: KERBEROS

  -soft will allow soft associations
      DEFAULT: don't allow soft SAs

  -lan will set policy only for lan adapters
  -dialup will set policy only for dialup adapters
      *BOTH ARE OPTIONAL, if not specified, All adapters are used*
      DEFAULT: All adapters

  The following deal with IKE phase 1 policy.  An easy way to remember
  is that all IKE phase 1 parameters are passed with a 1 in the flag.

  If no IKE flags are specified, the current IKE policy
  will be used.  If there is no current IKE policy, the defaults 
  specified below will be used.

  -1s SecurityMethodList
      where SecurityMethodList is one or more space separated SecurityMethods
      in the form:
      ConfAlg-HashAlg-GroupNum
      where ConfAlg can be DES or 3DES
      and HashAlg is MD5 or SHA
      and GroupNum is:
      1 (Low)
      2 (Med)

      Example: DES-SHA-1
      DEFAULT: 3DES-SHA-2 3DES-MD5-2 DES-SHA-1 DES-MD5-1

  -1p enable PFS for phase 1
      DEFAULT: not enabled

  -1k number of Quick Modes or number of seconds to rekey for phase 1
      put Q or S after the number to indicate Quick Modes or seconds,
       respectively
      Example: 10Q will rekey after 10 quick modes
      To use both, separate with a slash.
      Example: 10Q/3600S will rekey every hour and 10 quick modes
      *OPTIONAL*
      DEFAULT: no QM limit, 480 min lifetime
   
  -1e SoftSAExpirationTime
      set Soft SA expiration time attribute of the main mode policy
       value is specified in seconds
      DEFAULT: not set if Soft SA is not allowed
               set to 300 seconds if Soft SA is allowed

  -1f MMFilterList
      set specific main mode filters. Syntax is the same as for -f option
       except that you cannot specify passthru, block filters, ports and protocols
      DEFAULT: filters are generated automatically based on quick mode filters
   
-----------
STATIC MODE
-----------

Static mode uses most of the dynamic mode syntax, but adds a few flags
that enable it work at a policy level as well.  Remember, dynamic mode
just lets you add anonymous rules to the policy agent.  Static mode
allows you to create named policies and named rules.  It also has some
functionality to modify existing policies and rules, provided they were
originally created with ipseccmd.

Static mode is supposed to provide most of the functionality of the IPSec UI
in a command line tool, so there are references here to the UI.

First, there is one change to the dynamic mode usage that static mode
requires.  In static mode, pass through and block filters are indicated
in the NegotiationPolicyList that is specified by -n.  There are three
items you can pass in the NegotiationPolicyList that have special meaning:

BLOCK will ignore the rest of the policies in NegotiationPolicyList and 
      will make all of the filters blocking or drop filters.
      This is the same as checking the "Block" radio button
      in the UI

PASS  will ignore the rest of the policies in NegotiationPolicyList and 
      will make all of the filters pass through filters.
      This is the same as checking the "Permit"
      radio button in the UI

INPASS will plumb any inbound filters as pass through.
       This is the same as checking the "Allow unsecured communication,
       but always respond using IPSEC" check box in the UI
       

Static Mode flags:
All flags are REQUIRED unless otherwise indicated.

-w Write the policy to storage indicated by TYPE:LOCATION
   TYPE can be either REG for registry or DS for Directory Storage
        if \\machinename was specified and TYPE is REG, will be written
        to the remote machine's registry
   DOMAIN for the DS case only. Indicates the domain name of the
          DS to write to. If omitted, use the domain the local machine is in.
          OPTIONAL

-p PolicyName:PollInterval
   Name the policy with this string.  If a policy with this name is
   already in storage, this rule will be added to the policy. 
   Otherwise a new policy will be created.  If PollInterval is specified,
   the polling interval for the policy will be set.

-r RuleName
   Name the rule with this string.  If a rule with that name already exists,
   that rule is modified to reflect the information supplied to ipseccmd.
   For example, if only -f is specified and the rule exists,
   only the filters of that rule will be replaced. 

-x will set the policy active in the LOCAL registry case OPTIONAL

-y will set the policy inactive in the LOCAL registry case OPTIONAL

-o will delete the policy specified by -p OPTIONAL
   (NOTE: this will delete all aspects of the specified policy
    don't use if you have other policies pointing to the objects in that policy)

The command completed successfully.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\irda\irxfer\questions.txt ===
Open questions:

1. Does IrXfer send anything in ANSI, forcing NT to detect whether the other guy is Unicode or ANSI?

    OBEX is natively Unicode, so only private header types would be ANSI.

2. How do I register a service DLL, as opposed to a service that is an EXE?

    There is a flag for this: SERVICE_WIN32_SHARE_PROCESS

3. What is the best way to fix the TerminateThread() logic used for timeouts?

    Use async reads and writes.

4. How should the client and server share files, since BUILD.EXE generates only a single executable file per directory?

5. What is the structure of the receive-file service?

    - it must handle IR devices coming and going

    - one thread would block in AcceptEx(), listening for connections
      ...unless we can set up an async accept() with a c/b

    - it would launch another thread to read the incoming data

    - it should show a progress bar for the user

6. What are the possibilities for sending?

    Here are the modules to be divided between shell extension, the service, and perhaps another program:

    - getting the file name  (definitely part of the shell)

    - getting the file handle

    - getting the file data

    - sending the data

    - displaying the progress bar

    possible solutions:

    1. the shell reads and sends the data itself
        - protocol code is in two places
        - two copies of progress code
        + the send path is simple

    2. the shell opens the file, displays progress, sends data to service for transmission
        + a single copy of protocol code
        + all send UI is in the shell extension
        - shell <-> service communication is complex
        - two copies of progress code

    3. the shell opens the file, displays progress; the service reads and sends data
        + a single copy of protocol code
        + all UI is in the shell extension
        - shell <-> service communication is complex
        - two copies of progress code

  * 4. the shell opens the file; the service reads data, sends it, and displays progress
        + a single copy of protocol code
        + a single copy of progress code
        + shell <-> service communication is modest
        - not as simple as 1.

        request sends an array of file names and a destination directory
                receives a transfer cookie

        checkup sends a transfer cookie and an XFER_DATA pointer
                receives data in the XFER_DATA

        close   sends a transfer cookie
                xfer is aborted if still in progress

        E_ADDRINUSE at connect() means the port is bound to another device

tasks:

- convert to Unicode
- create RPC interface
- allow 64-bit file sizes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\compact\jetpack.txt ===
jetpack:

This utility can be used to compact the JET database that is used by the
DHCP server service (or wins service). The JET database grows over time
due to database changes. The administrator should periodically use this
utility to refresh and compact the database. The usage of this utility
is as given below :

jetpack [-351db] <database file name> <temporary file>
Use -351db if you are converting NTS3.51 or prior release database

Example:

jetpack dhcp.mdb dhcp.tmp

NOTE :

The administrator should compact the database after stopping the
DHCP server (or WINS) service. The administrator may want to backup the
original database so that it can be restored in case this utility fails.


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\jet\jet\inc\exports.txt ===
JetAddColumn			28		101
JetAttachDatabase		12		102
JetBackup			4		103
JetBeginSession 		16		104
JetBeginTransaction		4		105
JetCapability			20		106
JetCloseDatabase		12		107
JetCloseTable			8		108
JetCommitTransaction		8		109
JetCompact			28		110
JetComputeStats 		8		111
JetCreateDatabase		20		112
JetCreateIndex			28		113
JetCreateObject 		20		114
JetCreateTable			24		115
JetDelete			8		116
JetDeleteColumn 		12		117
JetDeleteIndex			12		118
JetDeleteObject 		16		119
JetDeleteTable			12		120
JetDetachDatabase		8		121
JetDupCursor			16		122
JetDupSession			8		123
JetEndSession			8		124
JetGetBookmark			20		125
JetGetChecksum			12		126
JetGetColumnInfo		28		127
JetGetCurrentIndex		16		128
JetGetCursorInfo		20		129
JetGetDatabaseInfo		20		130
JetGetIndexInfo 		28		131
JetGetLastErrorInfo		28		132
JetGetObjidFromName		20		133
JetGetObjectInfo		32		134
JetGetRecordPosition		16		135
JetGetSystemParameter		24		136
JetGetTableColumnInfo		24		137
JetGetTableIndexInfo		24		138
JetGetTableInfo 		20		139
JetGetVersion			8		140
JetGotoBookmark 		16		141
JetGotoPosition 		12		142
JetIdle 			8		143
JetIndexRecordCount		16		144
JetInit 			4		145
JetMakeKey			20		146
JetMove 			16		147
JetOpenDatabase 		20		148
JetOpenTable			28		149
JetOpenTempTable		20		150
JetPrepareUpdate		12		151
JetRenameColumn 		16		152
JetRenameIndex			16		153
JetRenameObject			20		154
JetRenameTable			16		155
JetRestore			0		156
JetRetrieveColumn		32		157
JetRetrieveColumns    		16		158
JetRetrieveKey			24		159
JetRollback			8		160
JetSeek 			12		161
JetSetColumn			28		162
JetSetColumns			16		163
JetSetCurrentIndex		12		164
JetSetSystemParameter		20		165
JetSetIndexRange		12		166
JetTerm 			4		167
JetUpdate			20		168

JetExecuteSql			12		200
JetSetAccess			28		201
JetGetQueryParameterInfo	24		202
JetCreateLink			24		203
JetCreateQuery			16		204
JetGetTableReferenceInfo	24		205
JetRetrieveQoSql		36		206
JetOpenQueryDef 		16		207
JetSetQoSql			24		208
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\exports.txt ===
JetAddColumn			28
JetAttachDatabase		12
JetBackup			12
JetBeginSession 		16
JetBeginTransaction		4
JetCloseDatabase		12
JetCloseTable			8
JetCommitTransaction		8
JetCompact			24
JetComputeStats 		8
JetCreateDatabase		20
JetCreateIndex			28
JetCreateTable			24
JetDelete			8
JetDeleteColumn 		12
JetDeleteIndex			12
JetDeleteTable			12
JetDetachDatabase		8
JetDupCursor			16
JetDupSession			8
JetEndSession			8
JetGetBookmark			20
JetGetChecksum			12
JetGetColumnInfo		28
JetGetCurrentIndex		16
JetGetCursorInfo		20
JetGetDatabaseInfo		20
JetGetIndexInfo 		28
JetGetObjidFromName		20
JetGetObjectInfo		32
JetGetRecordPosition		16
JetGetSystemParameter		24
JetGetTableColumnInfo		24
JetGetTableIndexInfo		24
JetGetTableInfo 		20
JetGetVersion			8
JetGotoBookmark 		16
JetGotoPosition 		12
JetIdle 			8
JetIndexRecordCount		16
JetInit 			4
JetMakeKey			20
JetMove 			16
JetOpenDatabase 		20
JetOpenTable			28
JetOpenTempTable		24
JetPrepareUpdate		12
JetRestore			8
JetRestore2			12
JetRetrieveColumn		32
JetRetrieveColumns    		16
JetRetrieveKey			24
JetRollback			8
JetSeek 			12
JetSetColumn			28
JetSetColumns			16
JetSetCurrentIndex		12
JetSetCurrentIndex2		16
JetSetSystemParameter		20
JetSetIndexRange		12
JetTerm 			4
JetTerm2 			8
JetUpdate			20

JetBeginExternalBackup		4
JetEndExternalBackup		0
JetGetAttachInfo		12
JetOpenFile			16
JetReadFile			16
JetCloseFile			4
JetGetLogInfo			12
JetTruncateLog			0
JetExternalRestore		32

JetResetCounter			8
JetGetCounter			12

JetOpenTempTable2		28
JetDBUtilities			4
JetExecuteSql			12
JetSetAccess			28
JetGetQueryParameterInfo	24
JetCreateLink			24
JetCreateQuery			16
JetRetrieveQoSql		36
JetOpenQueryDef 		16
JetSetQoSql			24
JetCreateTableColumnIndex	12

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\perfdata.txt ===
;/***********************************************************************
;* Microsoft Jet
;*
;* Microsoft Confidential.  Copyright 1991-1995 Microsoft Corporation.
;*
;* Component:
;*
;* File: perfdata.txt
;*
;* File Comments:
;*
;*     Global project data file for performance monitoring, in .INI
;*     file format (why not?)
;*
;* Revision History:
;*
;*    [0]  11-Jul-94  t-andyg	Added this file
;*
;***********************************************************************/


;Header files included in all generated C files:
;
;(NOTE:  you can use macros from these headers below)
;
;
;#include "std.h"
;
;#include "version.h"
;
;#include <stddef.h>
;
;#include "winperf.h"


;general module info

;Name=Application name
;MaxInstanceNameSize=max significant chars of each instance name returned
;                    by an Instance Catalog Function (default is 32
;                    wchar_t's)

[ModuleInfo]
Name=EDB
MaxInstanceNameSize=32


;supported languages

;lang id=(optional) language name
;NOTE:  these langid keys are now supplied from localized .tok files

[Languages]


;performance objects

;[symbolic_object_name]
;Type=Object (must be first key in section)
;InstanceCatalogFunction=symbolic function name
;xxx_Name=Name in language xxx
;xxx_Help=Help text in language xxx (this key can be specified multiple
;    times.  Each line will be appended in order, minus '\n')
;NOTE:  these Name and Help keys are now supplied from localized .tok files

;The following object is an object whose InstanceCatalogFunction represents
;each process that is using the main DLL as an instance.  You can define
;counters for this object that return global data for each process using
;the DLL.  (NOTE:  do not change or move this definition!)

[EDB]
Type=RootObject
InstanceCatalogFunction=LProcNameICFLPpv

;REM out Tables if COSTLY_PERF is not defined in _jet.h and change counters to
;point to EDB

;[Tables]
;Type=Object
;InstanceCatalogFunction=LTableClassNamesICFLPpv

;REM out LRUK and all its counters if COSTLY_PERF is not defined in _jet.h

;[LRUKRefInt]
;Type=Object
;InstanceCatalogFunction=LLRUKIntervalsICFLPpv

;[LRUKDeltaT]
;Type=Object
;InstanceCatalogFunction=LLRUKRawIntervalsICFLPpv


;performance counters

;[symbolic_counter_name]
;Type=Counter (must be first key in section)
;Object=symbolic parent object name
;DetailLevel=detail level
;DefaultScale=default display scale (== pow(10,DefaultScale))
;CounterType=counter type
;CounterSize=counter size in bytes (only need for variable length counters)
;EvaluationFunction=symbolic function name
;xxx_Name=Name in language xxx
;xxx_Help=Help text in language xxx (this key can be specified multiple
;    times.  Each line will be appended in order, minus '\n')
;NOTE:  these Name and Help keys are now supplied from localized .tok files

[OpenTableCacheHits]
Type=Counter
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=0
CounterType=PERF_SAMPLE_FRACTION
EvaluationFunction=LOpenTableCacheHitsCEFLPpv

[OpenTableCacheRequests]
Type=Counter
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=0
CounterType=PERF_SAMPLE_BASE
EvaluationFunction=LOpenTablesCEFLPpv

[LGBytesWrittenPerSec]
Type=Counter
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=-5
CounterType=PERF_COUNTER_COUNTER
EvaluationFunction=LLGBytesWrittenCEFLPpv

[LGUsersWaiting]
Type=Counter
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=1
CounterType=PERF_COUNTER_RAWCOUNT
EvaluationFunction=LLGUsersWaitingCEFLPpv

[LGCheckpointDepth]
Type=Counter
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=-5
CounterType=PERF_COUNTER_RAWCOUNT
EvaluationFunction=LLGCheckpointDepthCEFLPpv

[BFSyncReadsPerSec]
Type=Counter
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=0
CounterType=PERF_COUNTER_COUNTER
EvaluationFunction=LBFSyncReadsCEFLPpv

[BFAsyncReadsPerSec]
Type=Counter
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=0
CounterType=PERF_COUNTER_COUNTER
EvaluationFunction=LBFAsyncReadsCEFLPpv

[BFBytesReadPerSec]
Type=Counter
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=-5
CounterType=PERF_COUNTER_COUNTER
EvaluationFunction=LBFBytesReadCEFLPpv

[BFSyncWritesPerSec]
Type=Counter
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=0
CounterType=PERF_COUNTER_COUNTER
EvaluationFunction=LBFSyncWritesCEFLPpv

[BFAsyncWritesPerSec]
Type=Counter
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=0
CounterType=PERF_COUNTER_COUNTER
EvaluationFunction=LBFAsyncWritesCEFLPpv

[BFBytesWrittenPerSec]
Type=Counter
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=-5
CounterType=PERF_COUNTER_COUNTER
EvaluationFunction=LBFBytesWrittenCEFLPpv

[BFIOQueueLength]
Type=Counter
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=0
CounterType=PERF_COUNTER_RAWCOUNT
EvaluationFunction=LBFIOQueueLengthCEFLPpv

[BFCacheHits]
Type=Counter
;Object=Tables
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=0
CounterType=PERF_SAMPLE_FRACTION
EvaluationFunction=LBFCacheHitsCEFLPpv

[BFCacheRequests]
Type=Counter
;Object=Tables
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=0
CounterType=PERF_SAMPLE_BASE
EvaluationFunction=LBFCacheReqsCEFLPpv

[BFPctClean]
Type=Counter
;Object=Tables
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=0
CounterType=PERF_RAW_FRACTION
EvaluationFunction=LBFCleanBuffersCEFLPpv

[BFTotalBuffers2]
Type=Counter
;Object=Tables
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=0
CounterType=PERF_RAW_BASE
EvaluationFunction=LBFTotalBuffersCEFLPpv

[BFPctAvail]
Type=Counter
;Object=Tables
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=0
CounterType=PERF_RAW_FRACTION
EvaluationFunction=LBFAvailBuffersCEFLPpv

[BFTotalBuffers3]
Type=Counter
;Object=Tables
Object=EDB
DetailLevel=PERF_DETAIL_DEFAULT
DefaultScale=0
CounterType=PERF_RAW_BASE
EvaluationFunction=LBFTotalBuffersCEFLPpv

;[UserCommitsPerSec]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_COUNTER
;EvaluationFunction=LUserCommitsTo0CEFLPpv
;
;[UserRollbacksPerSec]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_COUNTER
;EvaluationFunction=LUserRollbacksTo0CEFLPpv
;
;[OpenTablesPerSec]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_COUNTER
;EvaluationFunction=LOpenTablesCEFLPpv
;
;[BTSplits]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_COUNTER
;EvaluationFunction=LBTSplitsCEFLPpv
;
;[BTAppends]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_COUNTER
;EvaluationFunction=LBTAppendsCEFLPpv
;
;[OLCConflicts]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_SAMPLE_FRACTION
;EvaluationFunction=LOLCConflictsCEFLPpv
;
;[OLCPagesProcessed]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_SAMPLE_BASE
;EvaluationFunction=LOLCPagesProcessedCEFLPpv
;
;[OLCSplitsAvoided]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_RAWCOUNT
;EvaluationFunction=LOLCSplitsAvoidedCEFLPpv
;
;;[MPLAddEntries]
;;Type=Counter
;;Object=EDB
;;DetailLevel=PERF_DETAIL_DEFAULT
;;DefaultScale=0
;;CounterType=PERF_COUNTER_COUNTER
;;EvaluationFunction=LMPLAddEntriesCEFLPpv
;
;;[MPLDeleteEntries]
;;Type=Counter
;;Object=EDB
;;DetailLevel=PERF_DETAIL_DEFAULT
;;DefaultScale=0
;;CounterType=PERF_COUNTER_COUNTER
;;EvaluationFunction=LMPLDeleteEntriesCEFLPpv
;
;[MPLTotalEntries]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_RAWCOUNT
;EvaluationFunction=LMPLTotalEntriesCEFLPpv
;
;[LGRecordsPerSec]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=-1
;CounterType=PERF_COUNTER_COUNTER
;EvaluationFunction=LLGRecordsCEFLPpv
;
;[LGWritesPerSec]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_COUNTER
;EvaluationFunction=LLGWritesCEFLPpv
;
;[BFOutstandingReads]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_RAWCOUNT
;EvaluationFunction=LBFOutstandingReadsCEFLPpv
;
;[BFOutstandingWrites]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_RAWCOUNT
;EvaluationFunction=LBFOutstandingWritesCEFLPpv
;
;[BFOutstandingIOs]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_RAWCOUNT
;EvaluationFunction=LBFOutstandingIOsCEFLPpv
;
;[BFIOsPerSec]
;Type=Counter
;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_COUNTER
;EvaluationFunction=LBFIOsCEFLPpv
;
;;[BFHashEfficiency]
;;Type=Counter
;;Object=EDB
;;DetailLevel=PERF_DETAIL_DEFAULT
;;DefaultScale=0
;;CounterType=PERF_RAW_FRACTION
;;EvaluationFunction=LBFHashEntriesCEFLPpv
;
;;[BFHashMaxLength]
;;Type=Counter
;;Object=EDB
;;DetailLevel=PERF_DETAIL_DEFAULT
;;DefaultScale=0
;;CounterType=PERF_RAW_BASE
;;EvaluationFunction=LBFMaxHashChainCEFLPpv
;
;;[FCBHashEfficiency]
;;Type=Counter
;;Object=EDB
;;DetailLevel=PERF_DETAIL_DEFAULT
;;DefaultScale=0
;;CounterType=PERF_RAW_FRACTION
;;EvaluationFunction=LFCBHashEntriesCEFLPpv
;
;;[FCBHashMaxLength]
;;Type=Counter
;;Object=EDB
;;DetailLevel=PERF_DETAIL_DEFAULT
;;DefaultScale=0
;;CounterType=PERF_RAW_BASE
;;EvaluationFunction=LFCBMaxHashChainCEFLPpv
;
;;[RCEHashEfficiency]
;;Type=Counter
;;Object=EDB
;;DetailLevel=PERF_DETAIL_DEFAULT
;;DefaultScale=0
;;CounterType=PERF_RAW_FRACTION
;;EvaluationFunction=LRCEHashEntriesCEFLPpv
;
;;[RCEHashMaxLength]
;;Type=Counter
;;Object=EDB
;;DetailLevel=PERF_DETAIL_DEFAULT
;;DefaultScale=0
;;CounterType=PERF_RAW_BASE
;;EvaluationFunction=LRCEMaxHashChainCEFLPpv
;
;[BFPctUsed]
;Type=Counter
;Object=Tables
;;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_RAW_FRACTION
;EvaluationFunction=LBFUsedBuffersCEFLPpv
;
;[BFTotalBuffers1]
;Type=Counter
;Object=Tables
;;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_RAW_BASE
;EvaluationFunction=LBFTotalBuffersCEFLPpv
;
;[BFPagesReadPerSec]
;Type=Counter
;Object=Tables
;;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_COUNTER
;EvaluationFunction=LBFPagesReadCEFLPpv
;
;[BFPagesWrittenPerSec]
;Type=Counter
;Object=Tables
;;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_COUNTER
;EvaluationFunction=LBFPagesWrittenCEFLPpv
;
;[BFPagesTransferredPerSec]
;Type=Counter
;Object=Tables
;;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_COUNTER
;EvaluationFunction=LBFPagesTransferredCEFLPpv
;
;[BFNewDirtiesPerSec]
;Type=Counter
;Object=Tables
;;Object=EDB
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_COUNTER
;EvaluationFunction=LBFNewDirtiesCEFLPpv
;
;[LRUKRefIntDist]
;Type=Counter
;Object=LRUKRefInt
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_RAWCOUNT
;EvaluationFunction=LLRUKRefIntDistCEFLPpv
;
;[LRUKDeltaTDist]
;Type=Counter
;Object=LRUKDeltaT
;DetailLevel=PERF_DETAIL_DEFAULT
;DefaultScale=0
;CounterType=PERF_COUNTER_RAWCOUNT
;EvaluationFunction=LLRUKDeltaTDistCEFLPpv
;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbeui\sys\netbeui.txt ===
NetBEUI (NBF) is a non-routable protocol suitable for small networks.
Support for this protocol in Microsoft Windows has been discontinued.
If you are instructed by the Product Support Personnel to install this protocol 
as a temporary measure, follow the instructions below.

Installation instructions for NetBEUI protocol on Windows XP and Windows 2002.

* copy nbf.sys into the %SYSTEMROOT%\SYSTEM32\DRIVERS\ directory
* copy netnbf.inf into the %SYSTEMROOT%\INF\ directory
* open network connection properties and use "Install..." button to add NetBEUI protocol
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbios\componentdef\netbios.doc ===
Microsoft Word Document MSWordDoc Word.Document.8MSDN Authoring Template TitleMSDN Authoring Template SStonich Use for authoring only. Publication should be accomplished with CSS for HTML, or a related Word template for print or WinHelp. netbios SStonich Microsoft Word 10.0W6xcW comptemp.dotComponent Description NETBIOS is a legacy programming interface that has been used to develop some networking applications. The NETBIOS Kernel-mode provider supports this API over transport providers. Component Configuration There are no configuration parameters associated with this component. Special Notes For More Information Additional Information This information will not be published in the database and is for internal use only. Contact name: arvindm PAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\nbttrace.ini ===
DEFINE_CPLX_TYPE(NBTNAME, WPP_LOGNBTNAME, PCHAR, ItemString, "s", z, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\ipx\ipxspxnb.doc ===
Microsoft Word Document MSWordDoc Word.Document.8The purpose of Component Help is to help Embedded Developers understand what your component does, how to configure your compon TitleThe purpose of Component Help is to help Embedded Developers understand what your component does, how to configure your compon SStonich Use for authoring only. Publication should be accomplished with CSS for HTML, or a related Word template for print or WinHelp. IpxSpxNb M. Shabbir Alam Microsoft Word 10.0comptemp.dotComponent Description NwlnkIpx / NwlnkSpx / NwlnkNb represent a suite of protocols designed to interoperate with Netware s Ipx standard.  These are transport protocols and function as drivers in the NT kernel space.  All 3 protocols (of which NwlnkSpx and NwlnkNb bind to nwlnkIpx) are typically installed or uninstalled as a set.  Please note that since these protocols are broadcast-based, installing them will increase the broadcast traffic on your network.  Configuring the Component There are no configuration requirements for this component. Property or Setting Name Default Setting How Used? Additional info required Example Property Example Setting Add additional rows to the table as needed. Special Notes None.  Links for Further Information Additional Information This information will not be published in the database and is for internal use only. Contact name: MAlam PAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\nb\nwlnknb.ini ===
\Registry\Machine\System\CurrentControlSet\Services\NwlnkNb
    Type = REG_DWORD 0x00000001
    Start = REG_DWORD 0x00000003
    ErrorControl = REG_DWORD 0x00000001
    ImagePath = REG_EXPAND_SZ \SystemRoot\System32\drivers\nwlnknb.sys
    DisplayName = NWLINK2 IPX Netbios Protocol
    Group = TDI
    DependOnService = REG_MULTI_SZ "NwlnkIpx"
    DependOnGroup = REG_MULTI_SZ "NDIS"
    Linkage
        Bind = REG_MULTI_SZ "\Device\NwlnkIpx"
        Export = REG_MULTI_SZ "\Device\NwlnkNb"
        Route = REG_MULTI_SZ ""NwlnkIpx""
        Disabled
            Bind = REG_MULTI_SZ
            Export = REG_MULTI_SZ
            Route = REG_MULTI_SZ
    Parameters
        AckDelayTime = REG_DWORD 0x000000fa
        AckWindow = REG_DWORD 0x00000002
        AckWindowThreshold = REG_DWORD 0x000001f4
        EnablePiggyBackAck = REG_DWORD 0x00000001
        Extensions = REG_DWORD 0x00000001
        RcvWindowMax = REG_DWORD 0x00000004
        BroadcastCount = REG_DWORD 0x00000003
        BroadcastTimeout = REG_DWORD 0x00000001
        ConnectionCount = REG_DWORD 0x00000005
        ConnectionTimeout = REG_DWORD 0x00000002
        InitPackets= REG_DWORD 0x00000005
        MaxPackets = REG_DWORD 0x0000001e
        InitialRetransmissionTime = REG_DWORD 0x000001f4
        Internet = REG_DWORD 0x00000001
        KeepAliveCount = REG_DWORD 0x00000008
        KeepAliveTimeout = REG_DWORD 0x0000003c
        RetransmitMax = REG_DWORD 0x00000008
    Performance
        Library = Perfctrs.dll
        Open = OpenNbfPerformanceData
        Collect = CollectNbfPerformanceData
        Close = CloseNbfPerformanceData
\Registry\Machine\System\CurrentControlSet\Services\EventLog\System\NwlnkNb
    EventMessageFile = REG_EXPAND_SZ %SystemRoot%\System32\netevent.dll
    TypesSupported = REG_DWORD 0x00000007
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\published\lib\readme.txt ===
The only subdirectories that should be checked in here are those that
build static libraries and whose source files depend ONLY on headers
that live in public\sdk\inc.

Generally speaking, this area of the source tree is for static libraries
that stand by themselves and do not depend on any specific feature area
under net.  Examples are nls and unixapis.  These libraries depend only
on windows.h and CRT headers.  They provide generic routines and have nothing
to do with any feature area of net.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\kdext\dso.txt ===
#******************************************************************************
# 
# structo.exe: Structures List
#
# 1/11/1999: Shreedhar Madhavapeddi (ShreeM) 
#******************************************************************************

CLIENT_BLOCK
BLOB_BLOCK
CLASSIFICATION_BLOCK
PATTERN_BLOCK
CF_BLOCK
PROTOCOL_BLOCK
GLOBAL_BLOCK
GPC_LOCK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\pclass\kdext\readme.txt ===
rem instructions to generate dsogpc.c
rem precomp.pph is generated by makefile.inc

structo -s dso.txt -o dsogpc.c precomp.pph
rem remember to add "include kdpre.h" to dsogpc.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\kdext\dso.txt ===
#******************************************************************************
# 
# structo.exe: Structures List
#
# Copyright (c) 1998-1999  Microsoft Corporation
#
# 10/06/1998: Rajesh Sundaram (rajeshsu)
#
#******************************************************************************

DSEQ_PIPE
DSEQ_FLOW
TS_PIPE
TS_FLOW
TBC_FLOW
TBC_PIPE
PS_WAN_LINK
GPC_CLIENT_VC
ADAPTER
DIFFSERV_MAPPING
PS_PIPE_CONTEXT
PS_FLOW_CONTEXT
PS_SPIN_LOCK
PS_NDIS_REQUEST
PS_SEND_PACKET_CONTEXT
PS_RECV_PACKET_CONTEXT
PS_MEDIA_PARAMETERS
PS_PIPE_PARAMETERS
PACKET_INFO_BLOCK
PS_ADAPTER_STATS
PS_CONFORMER_STATS
PS_SHAPER_STATS
PS_DRRSEQ_STATS
PS_FLOW_STATS
NPAGED_LOOKASIDE_LIST
GENERAL_LOOKASIDE
NDIS_REQUEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-netsh\sdchanges.txt ===
//depot/Lab02_N/Net/rras/netsh/ip/protocols/common.c#2 - edit default change (text)
//depot/Lab02_N/Net/rras/netsh/ip/protocols/ippromon.rc#5 - edit default change (text)
//depot/Lab02_N/Net/rras/netsh/ip/protocols/precomp.h#1 - edit default change (text)
//depot/Lab02_N/Net/rras/netsh/ip/protocols/prstring.h#2 - edit default change (text)
//depot/Lab02_N/net/rras/netsh/ip/protocols/qos.c#1 - add default change (text)
//depot/Lab02_N/net/rras/netsh/ip/protocols/qoscfg.c#1 - add default change (text)
//depot/Lab02_N/net/rras/netsh/ip/protocols/qosopt.c#1 - add default change (text)
//depot/Lab02_N/net/rras/netsh/ip/protocols/qosp.h#1 - add default change (text)
//depot/Lab02_N/Net/rras/netsh/ip/protocols/sources#2 - edit default change (text)
//depot/Lab02_N/Net/rras/netsh/ip/protocols/strdefs.h#1 - edit default change (text)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\netshell\diffserv\qos-protocol\readme.txt ===
Notes:

1. The reg file qos.reg has to be created in order to use this extension. For now, run regedit qos.reg, but later on 
   move it to the correct inf.

2. Fix all the qos specific help messages to be more compatible with existing ones. eg:
   add dsrule ? (prints only the usage). 

   If you look at other modules like rip, it prints usage, detailed explanation, and examples. Need PM work
   for this.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\pschdprf\pschdprf.ini ===
[info]
drivername=PSched
symbolfile=PschdCnt.h

[objects]
PSCHED_009_NAME=QoS Packet Scheduler

[languages] 
009=English

[text]  
PSCHED_FLOW_OBJ_009_NAME=PSched Flow
PSCHED_FLOW_OBJ_009_HELP=Flow statistics from the packet scheduler
PSCHED_PIPE_OBJ_009_NAME=PSched Pipe
PSCHED_PIPE_OBJ_009_HELP=Pipe statistics from the packet scheduler

FLOW_PACKETS_DROPPED_009_NAME=Packets dropped
FLOW_PACKETS_DROPPED_009_HELP=The number of packets dropped by the packet scheduler
FLOW_PACKETS_SCHEDULED_009_NAME=Packets scheduled
FLOW_PACKETS_SCHEDULED_009_HELP=The number of packets which got scheduled in some way (rather than just being directly sent to the underlying miniport)
FLOW_PACKETS_TRANSMITTED_009_NAME=Packets transmitted
FLOW_PACKETS_TRANSMITTED_009_HELP=The number of packets from this flow which have been sent
FLOW_AVE_PACKETS_IN_SHAPER_009_NAME=Average packets in shaper
FLOW_AVE_PACKETS_IN_SHAPER_009_HELP=The average number of packets in the shaper over the last sampling period
FLOW_MAX_PACKETS_IN_SHAPER_009_NAME=Max packets in shaper
FLOW_MAX_PACKETS_IN_SHAPER_009_HELP=The maximum number of packets that have ever simultaneously been in the shaper
FLOW_AVE_PACKETS_IN_SEQ_009_NAME=Average packets in sequencer
FLOW_AVE_PACKETS_IN_SEQ_009_HELP=The average number of packets in the sequencer over the last sampling period
FLOW_MAX_PACKETS_IN_SEQ_009_NAME=Max packets in sequencer
FLOW_MAX_PACKETS_IN_SEQ_009_HELP=The maximum number of packets that have ever simultaneously been in the sequencer
FLOW_BYTES_SCHEDULED_009_NAME=Bytes scheduled
FLOW_BYTES_SCHEDULED_009_HELP=The number of bytes which got scheduled in some way (rather than just being directly sent to the underlying miniport)
FLOW_BYTES_TRANSMITTED_009_NAME=Bytes transmitted
FLOW_BYTES_TRANSMITTED_009_HELP=The number of bytes from this flow which have been sent
FLOW_BYTES_TRANSMITTED_PERSEC_009_NAME=Bytes transmitted/sec
FLOW_BYTES_TRANSMITTED_PERSEC_009_HELP=The number of bytes per second from this flow which have been sent
FLOW_BYTES_SCHEDULED_PERSEC_009_NAME=Bytes scheduled/sec
FLOW_BYTES_SCHEDULED_PERSEC_009_HELP=The number of bytes per second from this flow which have been scheduled
FLOW_PACKETS_TRANSMITTED_PERSEC_009_NAME=Packets transmitted/sec
FLOW_PACKETS_TRANSMITTED_PERSEC_009_HELP=The number of packets per second from this flow which have been sent
FLOW_PACKETS_SCHEDULED_PERSEC_009_NAME=Packets scheduled/sec
FLOW_PACKETS_SCHEDULED_PERSEC_009_HELP=The number of packets per second from this flow which have been scheduled
FLOW_PACKETS_DROPPED_PERSEC_009_NAME=Packets dropped/sec
FLOW_PACKETS_DROPPED_PERSEC_009_HELP=The number of packets dropped by the packet scheduler from this flow per second
FLOW_NONCONF_PACKETS_SCHEDULED_009_NAME=Nonconforming packets scheduled
FLOW_NONCONF_PACKETS_SCHEDULED_009_HELP=The number of packets that have entered the packet scheduler at a rate which exceeded the flow parameters
FLOW_NONCONF_PACKETS_SCHEDULED_PERSEC_009_NAME=Nonconforming packets scheduled/sec
FLOW_NONCONF_PACKETS_SCHEDULED_PERSEC_009_HELP=The rate at which nonconforming packets have entered the packet scheduler
FLOW_NONCONF_PACKETS_TRANSMITTED_009_NAME=Nonconforming packets transmitted
FLOW_NONCONF_PACKETS_TRANSMITTED_009_HELP=The number of packets that have been sent by the packet scheduler at a rate which exceeded the flow parameters
FLOW_NONCONF_PACKETS_TRANSMITTED_PERSEC_009_NAME=Nonconforming packets transmitted/sec
FLOW_NONCONF_PACKETS_TRANSMITTED_PERSEC_009_HELP=The rate at which nonconforming packets have been sent by the packet scheduler
FLOW_MAX_PACKETS_IN_NETCARD_009_NAME=Maximum Packets in netcard
FLOW_MAX_PACKETS_IN_NETCARD_009_HELP=The maximum number of packets that have been queued in the netcard by this flow.
FLOW_AVE_PACKETS_IN_NETCARD_009_NAME=Average Packets in netcard
FLOW_AVE_PACKETS_IN_NETCARD_009_HELP=The average number of packets that have been queued in the netcard by this flow.

PIPE_OUT_OF_PACKETS_009_NAME=Out of packets
PIPE_OUT_OF_PACKETS_009_HELP=The number of times PSched has been unable to allocate a packet
PIPE_FLOWS_OPENED_009_NAME=Flows opened
PIPE_FLOWS_OPENED_009_HELP=The number of flows opened on this pipe (some of which may now be closed)
PIPE_FLOWS_CLOSED_009_NAME=Flows closed
PIPE_FLOWS_CLOSED_009_HELP=The number of flows that have been closed
PIPE_FLOWS_REJECTED_009_NAME=Flows rejected
PIPE_FLOWS_REJECTED_009_HELP=The number of flow creations that were rejected
PIPE_FLOWS_MODIFIED_009_NAME=Flows modified
PIPE_FLOWS_MODIFIED_009_HELP=The of times a flow has been modified
PIPE_FLOW_MODS_REJECTED_009_NAME=Flow mods rejected
PIPE_FLOW_MODS_REJECTED_009_HELP=The number of times a flow modification has been rejected
PIPE_MAX_SIMULTANEOUS_FLOWS_009_NAME=Max simultaneous flows
PIPE_MAX_SIMULTANEOUS_FLOWS_009_HELP=The maximum number of flows that have been simultaneously open on this pipe
PIPE_NONCONF_PACKETS_SCHEDULED_009_NAME=Nonconforming packets scheduled
PIPE_NONCONF_PACKETS_SCHEDULED_009_HELP=The number of packets that have entered the packet scheduler at a rate which exceeded that packet's flow parameters
PIPE_NONCONF_PACKETS_SCHEDULED_PERSEC_009_NAME=Nonconforming packets scheduled/sec
PIPE_NONCONF_PACKETS_SCHEDULED_PERSEC_009_HELP=The rate at which nonconforming packets have entered the packet scheduler
PIPE_NONCONF_PACKETS_TRANSMITTED_009_NAME=Nonconforming packets transmitted
PIPE_NONCONF_PACKETS_TRANSMITTED_009_HELP=The number of packets that have been sent by the packet scheduler at a rate which exceeded that packet's flow parameters
PIPE_NONCONF_PACKETS_TRANSMITTED_PERSEC_009_NAME=Nonconforming packets transmitted/sec
PIPE_NONCONF_PACKETS_TRANSMITTED_PERSEC_009_HELP=The rate at which nonconforming packets have been sent by the packet scheduler
PIPE_AVE_PACKETS_IN_SHAPER_009_NAME=Average packets in shaper
PIPE_AVE_PACKETS_IN_SHAPER_009_HELP=The average number of packets in the shaper over the last sampling period
PIPE_MAX_PACKETS_IN_SHAPER_009_NAME=Max packets in shaper
PIPE_MAX_PACKETS_IN_SHAPER_009_HELP=The maximum number of packets that have ever simultaneously been in the shaper
PIPE_AVE_PACKETS_IN_SEQ_009_NAME=Average packets in sequencer
PIPE_AVE_PACKETS_IN_SEQ_009_HELP=The average number of packets in the sequencer over the last sampling period
PIPE_MAX_PACKETS_IN_SEQ_009_NAME=Max packets in sequencer
PIPE_MAX_PACKETS_IN_SEQ_009_HELP=The maximum number of packets that have ever simultaneously been in the sequencer
PIPE_MAX_PACKETS_IN_NETCARD_009_NAME=Max packets in netcard
PIPE_MAX_PACKETS_IN_NETCARD_009_HELP=The maximum number of packets ever simultaneously in the network card
PIPE_AVE_PACKETS_IN_NETCARD_009_NAME=Average packets in netcard
PIPE_AVE_PACKETS_IN_NETCARD_009_HELP=The average number of packets in the network card over the last sampling period
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tools\qtcp\qtc.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoftg Use of qtcp for Measurement of Network Characteristics Title _PID_HLINKSUse of qtcp for Measurement of Network Characteristics Yoram Normal.dot John Holmes Microsoft Word 9.0bjbjU Use of qtcp for Measurement of Network Service Quality Version History Original document created by Yoram Bernet (yoramb@microsoft.com) 6/17/99 Revised for qtcp version 0.9.1 by John Holmes (  HYPERLINK "mailto:t-johnh@microsoft.com"  t-johnh@microsoft.com  HYPERLINK "mailto:jsholmes@mit.edu"  jsholmes@mit.edu 6/22/99 Revised for qtcp version 0.9.2 by John Holmes 6/29/99 Revised for qtcp version 0.9.3 by John Holmes 7/8/99 Revised for qtcp version 0.9.4 by John Holmes 7/20/99 Revised for qtcp version 0.9.6 by John Holmes 7/28/99 Revised for qtcp version 0.9.8 by John Holmes 8/4/99 Revised for qtcp version 0.9.9 by John Holmes 8/6/99 Revised for qtcp version 1.0.0 by John Holmes Introduction qtcp is a tool, derived from ttcp, which can be used to measure end-to-end network service quality. qtcp sends a sequence of test packets through a network, then reports on the queuing delay experienced by each packet. Packets that do not arrive at the destination are recorded as dropped packets. qtcp relies on a kernel timestamping module that can be run only on Win2000. qtcp may be used on either a production network or on a controlled network that may be artificially congested.  Features of qtcp: qtcp is able to report very precise delay variations, on the order of microseconds.  By default, qtcp invokes network QoS and is useful for the purpose of evaluating QoS mechanisms. qtcp can simulate traffic flows for a range of user selectable packet sizes. qtcp can simulate traffic flows shaped to a range of token bucket parameters. qtcp can be used on an isolated, controlled network or a production network. qtcp generates detailed result logs. qtcp can collate a bunch of .sta files and produce a statistics summary across variables. Network Under Test qtcp may be used on either a production network or on a controlled network that may be artificially congested. Devices in the network under test may provide quality of service through any nuber of QoS mechanisms or may not provide quality of service at all. The following diagram illustrates the usage of qtcp in a production network: In this diagram, a qtcp sender and a qtcp receiver are located at opposite ends of the network. The network under test is a production network. Other senders and receivers compete with the qtcp session for network resources. In this scenario, the qtcp user has no control over the current network load. The following diagram illustrates the use of qtcp on a controlled network: In this diagram, the qtcp sender and receiver are again located at the opposite ends of the network under test. In these scenarios, the network under test tends to be smaller and simpler to facilitate the evaluation of specific network elements in isolation. Note that, unlike the production network, there are only four hosts attached to this network. Two hosts are used to run the qtcp test session. The other two hosts act as a noise source and noise sink. In these type of tests, the user controls the amount of noise generated across the network during any specific test run. Generally, noise sources are selected to mimic the distribution of packet sizes and the traffic level that would be encountered on a production network.  Theory of Operation A qtcp session is invoked on both a sending and a receiving host. After invocation, qtcp sets up a TCP control channel between sender and receiver to properly negotiate the test. At the same time, it uses the GQoS API (part of Winsock2) to invoke QoS from local traffic control and from the network. The qtcp sender will cause an RSVP PATH message to be sent towards the receiver and will wait until a response is received. The qtcp receiver will wait for an RSVP PATH message from the sender and will respond by transmitting an RSVP RESV message.  Receipt of the RESV message at the sender triggers the measurement phase. At this time, the sender begins submitting buffers to the kernel for transmission. (Note that kernel traffic control must be installed). The kernel paces the transmission of traffic according to the token bucket parameters and service type selected by the user via the qtcp command line. As packets are transmitted, the timestmp module stamps a sequence number and the local time (to a precision of 100ns) in each packet. If the timestmp module is not installed, qtcp uses a user mode timestamp that is less accurate than the kernel mode module. When packets are received at the receiver's traffic control, the timestmp module stamps in each packet the local time of the receiving host, then passes the packet up to the receiving qtcp peer. The receiving qtcp process maintains a list of all received packets, including the packet sequence number, the time sent and the time received.  The test terminates on the sending side when the transmitter has sent the required number of packets (default is 2048 packets, may be overriden via the qtcp command line). Following transmission of the last packet, the sender sends a terminating sequence of ten 'termination' packets. The test terminates on the receiving side upon receipt of a termination packet or upon receipt of the required number of packets (default 2048, may be overriden via the receiver qtcp command line). Note that, on particularly congested links, the receiver may never receive the required number of packets and the termination packets may be dropped. The TCP control channel should still get through its   message, in which case the receiver will terminate normally. If both of these methods fail, the receiver may be terminated manually, by typing 'q' <return>. Upon termination, the receiver qtcp parses and processes the log of received packets. Three logs are generated; filename.sta, filename.raw and filename.log. The first of these contains summary statistics. It reports the total number of packets received and specifies the sequence number of each dropped packet. The second file (.raw) contains a detailed log showing normalized send time and receive time for each packet, the latency (difference between sent and received time), packet size and sequence number. Finally, the third file (.log) is a result of normalizing the results of the second file, to acount for clock drift between the two hosts (see Appendix A). Usage The simplest invocation of qtcp is as follows: On sender: qtcp -l64 -t 2.3.4.5 On receiver: qtcp -f"filename" -r The -l option on the sender specifies the buffer size to be used in the test. The -t option specifies that this is the qtcp sender. This option must be followed by the IP address of the receiving host. On the receiver, the -f option is used to specify the prefix of the report files that will be generated. The -r option indicates that this is the qtcp receiver. Initially, the sender will print the message: Initiated QoS connection. Waiting for receiver. The receiver will print the message: Waiting for QoS sender to initiate QoS connection. At this time, the receiver and the sender are awaiting the required exchange of RSVP messages before beginning the data transfer. Once the data transfer begins, the sender will start sending 64 byte buffers (as specified in the -l option on the sender), to kernel traffic control, for transmission to the receiver at address 2.3.4.5. By default, kernel traffic control will pace transmitted packets to a rate of 100 KBps (kilobytes per second).  qtcp will print a series of dots to the console, both on the receiver and on the sender. Each dot corresponds to 100 packets sent or received. Note that the first dot is printed on the receiver prior to the actual receipt of the first 100 packets. The dots should be used as an indication that qtcp is 'alive'. Upon transmission of the specified number of packets (2048 by default), the sender terminates with a message regarding the transmission rate. Note that the transmission rate and other statistics printed by the sender are from its perspective alone. That is, the rate it prints is the rate at which it sends packets and does not necessarily correspond to the rate at which packets are received. Upon receipt of the required number of packets (or the termination packets) at the receiver, it terminates with the message: Received 2048 buffers. This is followed by statistics, which are not reliable. At this time, the receiving qtcp will generate the files: filename.sta, filename.raw and filename.log. Usage Variations In this section, we'll discuss the various usage variations and optional parameters that may be used. In the table below, the third column indicates whether each option is useful on the qtcp sender (T), qtcp receiver (R) or both (B).  Optional Parameters Option Description Default and Range This is the Token Bucket size. The token bucket size represents the largest burst that traffic control will transmit to the network. It should generally be set to be equal to the buffer size. See notes below.  Default is 64 bytes. Must be no smaller than buffer size and no smaller than MTU size.  Minimum policed size advertised by RSVP signaling. Default is buffer size. This is the Token Rate. The token rate is the average rate at which data will be transmitted in Kbytes per second. This parameter may be used to control the inter-packet gap on the sending host. See notes below. Default is 100 Kbytes. Should be lower than the media rate. -R##B Token Rate as above expressed in bytes per second. See above. This is the intserv service type that will be signaled to the network and that will be used for local traffic control. See notes below. GR or CL. This option forces shaping to the token rate Default is off (GR shapes, CL does not) This will suppress waiting for an RSVP reservation. See notes below. No parameters. This option is used to set up an RSVP reservation only and then wait for the user to exit. No data is sent. Data is sent by default. This option is used to specify the prefix name for the logging and statistics files on the receiver.  By default no files will be generated. This option is used to convert a raw file to a log file. See notes below. Number of buffers transmitted.  See notes below. Number of calibration buffers to be sent. See notes below. 0: Do not calculate clock skew 1: Calculate clock skew based on a linear regression with goodness of fit measured by sum of squared error. 2: Calculate clock skew based on a bracketing and bisection root finding method with goodness of fit measured by sum of absolute error. 3: Same as 2, except also try to compensate for clock jumps (see appendix A). Default is 2 This option skips waiting for user confirmation to continue after the calibration phase has been completed. Default is to wait for confirmation. Destination IP port number on receiving host. In order to run multiple simultaneous qtcp tests between the same pair of hosts, it is necessary to use separate ports for each test. This option may be used to force a specific port to be used. Otherwise all streams will attempt to send to the default port on the receiver. This option must be used on both sender and receiver. Default is port 5003. Length of user level buffers generated by qtcp. See notes below on relationship of buffer size to token bucket size and MTU size. Default is 1472. Must be greater than 48 bytes. By default, dropped packets omitted from the log. If this option is specified, they are represented by dummy entries in the log files showing a sent and received timestamp of zero and the maximum latency experienced by any packet in the test run. This option can be used to facilitate accommodate different types of log file post processing. Default is no dummy entries. Causes raw file to be dumped after normalization. Default is pre-normalization. See notes below. MaxSDUSize to be used in signaling messages Default is buffer size. Suppresses console reporting of dropped packets. Default is to report. Report user-mode timestamps in logfiles. Default is kernel mode. Use more compressible data in the packets. Default is less compressible. Log only every nth packet. For instance, -q2 will log every other packet (0,2,4, Default is  q1 (log every packet) Used to tell qtcp to collate all the .sta files in a directory and produce a statistics summary output. For instance, to collect the results in c:\results, you would enter qtcp  c:\results Not involved in default operation. Notes Regarding Parameter Usage Fragmentation Avoidance - Relationship of Token Bucket Size, Buffer Size and Packet Size Under certain conditions, the protocol stack on the sending host would have to fragment user level buffers into multiple packets in order to transmit them over the network. Fragmentation is undesirable for a number of reasons, as described below: Certain network QoS mechanisms are unable to handle fragmented packets. The loss of a single packet results in loss of the entire corresponding buffer at the receiving host, even though all packets may have successfully traversed the network. The user level qtcp process on the receiving host recognizes buffers, not individual packets. As a result timestamps and sequence numbers would be recovered only from the first packet comprising eah buffer. Information stamped by the sending timestmp module in the remaining packets of the buffer, would not be recoverable. The size of user level buffers generated by the sending qtcp is determined by the -l option (default is 1472 bytes since 1472(buf size)+20(IP Header)+8(UDP Header) = 1500(MTU size)). If the buffer is larger than the token bucket size (selected by the -B option) used by traffic control, or larger then the MTU size defined for the network interface, then the sending protocol stack will have to fragment each buffer into multiple packets. Since fragmentation is undesirable, this condition is to be avoided. qtcp will prevent the user from defining a buffer size that is larger than the token bucket size. However, the user is responsible for determining the MTU size for the interface and assuring that the buffer size is no larger than the MTU size.  On the other hand, if the buffer size is smaller than the token bucket size, then multiple user level buffers may be transmitted by sending traffic control in a single burst. As a result, the transmit timestamps in these packets will be closely related. This tends to distort the results of the measurement. Optimal results are obtained when packets are sent at a steady rate with equal inter-packet gaps between successive packets. In conclusion, for best results, it is recommended that the buffer size be equal to the token bucket size and that both are equal or smaller to the MTU size. Token Rate As discussed previously, optimal results are obtained when the sending host sends packets at a constant rate. If the token bucket size is chosen to be equal to the buffer size, then the token rate (determined by the -R option) will determine the constant packet rate. So, for example, for a token bucket and buffer size of 64 bytes and a token rate of 16, packets will be sent at the uniform rate of 250 packets per second. Each packet can be considered to be taking a snapshot of the network conditions at the time it is sent. Thus, the token rate can be used to select a sampling interval for the network under test. Too low a sampling interval may cause transient network conditions to be missed. On the other hand, the token rate should be selected so that the packet rate is relatively low compared to the measuring processes in the sending and receiving hosts. Measurement error increases with higher packet rates.  The token rate selected should be lower than the media rate. When using qtcp to evaluate the effects of QoS on telephony traffic (for example), we usually select token rates on the order of 3 - 10 Kbytes per second.   Service Type The service type (selected by the -S option) can be used to select the intserv service type requested by the RSVP signaling messages and to control the mode of the sending host's traffic control. The two types of service are GR (guaranteed service) and CL (controlled load) service. See RFC 2210 for a description of these services. Guaranteed service is selected by default. If there are RSVP/Intserv aware devices in the network under test, then the choice of service type will affect the handling of the test traffic by these devices (as described in RFC 2210). Regardless of the existence of RSVP/Intserv aware network devices, the choice of service will affect traffic control on the sending host by determining the mode in which the packet scheduler operates. Unless configured otherwise, the packet scheduler on the sending host will operate in shape mode for guaranteed service and in borrow mode for controlled load service. In shape mode, the packet scheduler will shape transmitted traffic to the token bucket parameters. In borrow mode, the packet scheduler will not shape traffic to the token bucket parameters. Instead, it will transmit traffic up to the media rate, demoting in priority, those packets that are transmitted in excess of the media rate.  Operating qtcp in borrow mode tends to result in bursty traffic and is not recommended for measurement purposes. However, it may be desirable to select controlled load service to compare the effect of various service types when there are RSVP/Intserv aware devices in the network under test. In this case, we recommend configuring the packet scheduler to operate in shape mode for controlled load flows. This can be accomplished by specifying the  e flag when running qtcp.  No Wait Flag By default, qtcp will not begin data transmission until an RSVP reservation is in place. The -W option allows data transmission to proceed even when there is no reservation in place. This option can be invoked in order to enable testing when the network under test prevents a reservation from being installed. This could happen for the following reasons: A firewall in the path between sender and receiver is configured to block RSVP messages. An RSVP aware device in the network is rejecting the RSVP request due to lack of resources, policy or other reasons. Note that by using the -W option, the synchronization inherent in RSVP is lost. This means that the sender will not wait for the receiver to be started. Thus, it is necessary to start the receiver before the sender. Number of Buffers The -n option can be used to select the number of buffers which the transmitter sends or which the receiver expects to receive during a test run.  Too small a number of buffers will result in the error message "Time interval too short for valid measurement."  Too large a number of buffers on the receiver will result in the error message "Could not allocate X bytes for log buffer.", indicating that the receiver was unable to allocate sufficient memory to record timing data for the number of buffers it would have to receive.  Note that both sender and receiver use 2048 as the default number of buffers. If the -n option is used on the sender to restrict the number of buffers sent to less than the default, then no action is required on the receiver. However, if the sender is configured to transmit more than the default, then the corresponding option must also be selected on the receiver to prevent it from terminating after the default number of buffers have been received. If you would like to send buffers for an approximate amount of time, you can use the   suffix to the n parameter. If, for example, you want to send buffers for 3600 seconds, you would specify  n3600s. Calibration The -c option can be selected to enforce a calibration phase. This option takes a number of calibration buffers as an argument. On the sender, the specified number of calibration buffers is sent in addition to the number of buffers specified by the -n parameter (or the default of 2048). On the receiver, the best-fit curve calculations used to normalize for clock skew (see Appendix A) are based on the calibration buffers received only (unless none are specified, in which case they are based on all buffers). (Other statistics are based on all buffers including both calibration buffers and none-calibration buffers). When calibration buffers are specified on the sender, it sends the number of calibration buffers specified then pauses and prompts the user with the message "Calibration complete. Type 'c' to continue." When the network under test is isolated and under user control, this mechanism facilitates the evaluation of the network. In this case, the user should begin the test run on a quiescent network. Data obtained during the calibration phase of the run is used by the receiving qtcp to improve the integrity of the latency reports generated and of clock skew normalizing (see Appendix A). Once the calibration phase has completed, the user should start any noise generating tools being used to congest the network under test. After noise generation has been started, the user should type 'c' to continue with the measurement phase of the test.  The following sample invocation may be used: On sender: qtcp -c1000 -n1000 -l64 -t 2.3.4.5 On receiver: qtcp -c1000 -f"filename" -r This will cause the sender to transmit 1000 calibration buffers, followed by 1000 non-calibration buffers. The receiver will use the first 1000 buffers received to normalize for clock skew. Converting a raw file F option will convert a given raw file into a log file, sending no network traffic of any kind. This can be used in case there are improvements to the normalizing algorithm, for instance, on an old raw file. If you used calibration packets in the run that created the raw file, you should specify their number when invoking this conversion by adding the  c## option; i.e., for 1000 calibration packets, -c1000. Example: To convert test.raw into a log file, use qtcp  The output will be in test.log Diffserv Codepoint, TOS/Precedence and 802.1p Because qtcp invokes QoS on the sending host, it will cause traffic control to mark transmitted packets for certain QoS service levels. Specifically, traffic control will mark the diffserv codepoint (DSCP, formerly known as TOS and precedence bits) in the IP header. It will also mark 802.1p tags in the MAC header of packets sent on an 802.1p capable network (such as 802.1p enabled Ethernet). The user should consider the effects of these packet markings when evaluating the results of qtcp tests. The user may control the markings applied by traffic control in order to study the effects of particular markings on network service quality. By default, packet markings are determined by the service level (guaranteed or controlled load) selected for test traffic. Default mappings are as follow: Service Level 802.1p Guaranteed IP precedence 5 Controlled Load IP precedence 3 Best effort IP precedence 0 Non-conforming traffic IP precedence 0 The user may alter the markings by creating a marking table in the registry under the Psched/Parameter key for the appropriate interface. Usage Hints and Troubleshooting Waiting for RSVP Reservations Before qtcp begins sending test data, it waits for an RSVP reservation to be established between the sender and receiver. Reservations may take up to 30 seconds to be established and may not be established at all under certain conditions. If an RSVP reservation is failing to be established it may be because there is a network device in the path between sender and receiver, which is rejecting or blocking the reservation. Firewalls may do so by simply blocking all RSVP messages. RSVP enabled routers may do so if they are not provisioned to allow the requested reservation. Check for the presence of such devices. If it is not possible to complete the RSVP reservation, it may be necessary to run using the -W flag, which allows qtcp to transmit test data without a reservation in place. TCMON TCMon enables the user to observe traffic control behaviour. Install tcmon on the qtcp sender, then select the interface over which qtcp will be running and enable auto-refresh. As soon as qtcp is invoked on the sender, tcmon should indicate two flows - one for the RSVP messages themselves (identifiable by the service type Network Control). The other flow is for the qtcp data. This flow is identifiable initially by the service type Best Effort. However, upon completion of the RSVP reservation, the service type of the data flow should change to either Guaranteed or Controlled Load. Note that the rate indicated for the data flow will actually be higher than the token rate specified. This is because the QoS service provider prorates the requested data rate to account for network layer packet headers. As data is being sent, the Bytes Sent counter in tcmon should increase in value. Invalid Log File Data If the data in the .log file appears invalid, it may be as a result of a number of conditions. The receive and send timestamps should each be monotonically increasing. If either the receive timestamps or the send timestamps are all equal, it is likely that the timestmp module did not install correctly on the corresponding host. Remove and re-install the timestmp module. If timestamps are not equal, but appear to vary widely, it may be the result of an error in the processing step that normalizes for clock skew. This can be confirmed by comparing the contents of the .log file to the contents of the .raw file. The .raw file is generated any normalizing processing is applied. The results in the .raw file may be used if clock skew is considered negligible. If the .log file is completely empty, check the .sta file. It may indicate that all packets have been dropped. Receiver Termination If the network under test is extremely congested, the qtcp receiver may not receive its termination sequence and may not receive sufficient packets to terminate automatically. It should still get the message to terminate over its control channel. If it does not, however, type  <return> at the receiver console some time after the sender has indicated that its transmission is complete. This will terminate the receiver session causing the log files to be generated based on whatever data was successfully received at that time.  Error Messages Network transmission rejected - This error indicates that the sender attempted to send to a closed socket. This can occur when the RSVP session is torn down by an RSVP aware network device on the path from sender to receiver. In this case, the offending device should be corrected and the test should be re-run. This message may also be received under normal conditions at the end of a test. In this case, it indicates that one of the first termination sequences caused the receiving qtcp session to shut down the qtcp receiving socket, sending an RSVP teardown message to the sender. This may cause the sending socket to close before the last termination sequence has been submitted to the network, resulting in the behaviour described. In this case, the logged data can be considered valid.   Appendix A Upon receiver termination and before the qtcp receiving application exits, it parses the list of sent and received times in its received packet log. Assume for the purpose of this example that receiving timestamps are always later than sender timestamps (logic is implemented to allow for the case in which the receiver's timestamps are actually earlier than the sender's timestamps). qtcp looks for the lowest sent time stamp (should be the first) and for the lowest difference between sent time and received time across all pairs of timestamps (lowest latency). It records these two values as 'LowestSendTime' and 'LowestLatency'. These are used in the subsequent normalizing process. Once qtcp has completed parsing the list, it subtracts the LowestSendTime from all sent timestamps. This has the effect of normalizing the first packet's send timestamp to zero and each following packet's timestamp to the difference between the time the first packet was sent and the time the following packet was sent. Next qtcp subtracts the LowestSendTime from all received timestamps. Finally, qtcp subtracts LowestLatency, from each packet's received timestamp. This has the effect of normalizing all received timestamps such that they represent the latency in excess of the minimum latency seen. For example, consider the following set of timestamps: TimeSent TimeReceived Latency Upon parsing the records, qtcp determines that LowestSendTime is 10 and  LowestLatency is 3.  After the first normalizing step, the table looks as follows: TimeSent TimeReceived Latency During the next normalizing step, LowestSendTime is subtracted from all received time stamps, yielding the following results: TimeSent TimeReceived Latency In the final normalizing step, LowestLatency is subtracted from all received time stamps and the latency is updated to reflect the difference between the normalized send and receive time stamp pairs. This yields the following results: TimeSent TimeReceived Latency Note that the first packet shows a latency of zero. This does not mean that the transmission delay is zero. Rather, it means that this packet's delay represents the best case or fixed delay that occurs between sender and receiver. Normalized latencies that are greater than zero indicate the amount of delay beyond the fixed delay or beyond the minimum delay. As such, these latencies represent the variable delay component that results from queuing and congestion. This is considered more interesting than the fixed delay component from the perspective of qtcp. Validity of Results No attempts are made to determine the actual latency between sender and receiver. Instead, qtcp attempts to determine the variable delay component that is considered to be indicative of queuing delays and congestion effects. This approach will not always yield valid results. It is based on the assumption that one of the following two requirements are met: 1. The test includes a calibration phase - if the network under test is an isolated network, controlled exclusively by the tester, then it is recommended that the calibration option (-c) be used. During the calibration phase, no noise should be generated on the network. This assures that queues in network devices will be empty and that the minimal latency logged by qtcp will indeed be indicative of the fixed delay component of the network.  2. Sufficient packets are sent - if a large enough number of packets is sent during a test run, it is statistically very likely that at least one of the packets will end up in a very short (or zero length) queue and will not be subjected to congestion delay. The minimum delay used by qtcp will be the delay experienced by this packet. This assumption fails on a heavily congested network in which queues never drop to zero length. Normalizing for Clock Skew - Difference Between .raw and .log Files PC clocks are based on a crystal oscillator timebase. Oscillators are subject to deviation from their nominal frequency, which is on the order of several parts per million. As a result, send time stamps and receiving timestamps are generated based on a slightly different speed clock. When measuring queuing delays on the order of milliseconds over a period of seconds or minutes, the skew between the sending oscillator's rate and the receiving oscillator's rate is negligible. However, when measuring queuing delays that are much lower (such as on a high speed LAN) or when measuring delays over a long period of time, the clock skew may become significant. To compensate for the clock skew, qtcp normalizes the output of the raw file into the log file. This normalizing step is based on the assumption that the clock skew is constant, while queing delay is variable. In order to normalize for the effects of clock skew, qtcp attempts to fit the latency reports to a constant slope line. There are several options for this clock skew normalization. The  k0 option turns off the normalization.  k1 fits to a straight line using the sum of squared error as the goodness of fit measure (this makes an implicit assumption that latency is normally distributed). The default, -k2, option uses absolute deviation as the goodness of fit measure (the assumption here is that latency is more like a double exponential about the mean). k3 option is only to be used in special cases. It is designed to fix a known problem. On certain machines, those with a piix4 timer chip (qtcp should warn you if you have a clock chip whose frequency matches that of the piix4), the clock sets itself forward backward a specific amount every so often. The  k3 option tells qtcp to try to detect and compensate for this. It is not certain to detect the clock jumps and only the clock jumps, but it has succeeded in all tests so far. As a consequence of all this, any constant variation in latency will be removed from the log file. In the rare case that the user is interested in measuring constant changes in latency over time, the user should work from the raw file (not the log file) and should account for the fact that part of the latency is attributable to clock skew. (Clock skew measured on current technology PCs between two PCs is on the order of 10 microseconds per second). Appendix B - Known Bugs Disclaimer - qtcp has not been subjected to extensive testing and is provided 'as is', with no guarantees. Comments, suggestions and questions may be sent to t-johnh@microsoft.com. qtcp has been used over a limited range of parameter values and has been found to operate correctly over these values. The following parameter values have been used and as such, can be considered to have been partially tested: Option Values Tested Primarily 64 bytes. Occasional testing up to 1500 bytes.  Never used. Primarily 3 to 8 Kbytes. Occasional use up to 100 Kbytes. Rarely used. Most often defaulted to guaranteed service. Used occasionally. Always used.  Primarily 1000 - 2000. Occasionally up to 10000.  Primarily 1000, occasionally less. Never used. Primarily 64 bytes. Occasional testing up to 1500 bytes. Rarely used.  Rarely used. Occasionally increased from default of 3, to 20. The following are known bugs: 1. None   Appendix C - Post Processing The .log file and the .raw file data should be interpreted as follows: Column 1: Send time stamp in units of 100 nsec. Column 2: Receive time stamp in units of 100 nsec. Column 3: Latency in units of 100 nsec. Column 4: Packet size. Column 5: Sequence number. It is helpful to plot the data captured in the .log file in order to interpret the results of the test runs. We use a Microsoft Excel macro contained in the file qtcpmacros.xls to read the log file and plot the results. Instructions are contained in the .xls file itself. If you do not have this macro file, simply use the File Open menu to load the data file. Specify that a colon will be used as the delimiter. Once Excel has loaded the data file, highlight the third column (latency) . Next, chart it using the Line chart. You may also select the Data Analysis tools to obtain statistics and histograms regarding the distributions of latencies. When applying the data analysis tools, be sure not to include log entries generated during the calibration phase of the test (if calibration was used), as this will skew the results. Appendix D - Sample Results Here we present sample results. Two test trials were run. Both trials were run across an isolated network consisting of two RSVP capable routers connected by a 128 Kbps serial line. Each router was also equipped with an ethernet interface. The qtcp sender was connected to one of the router's ethernet interfaces, the qtcp receiver was connected to the other.  In addition, the sending port of a 'Smartbits' noise generator was connected to the same ethernet network as the qtcp sender. The receiving port of the 'Smartbits' was connected to the same ethernet network as the qtcp receiver. The 'Smartbits' was programmed to send 100 Kbps of noise traffic from sending port to receiving port such that the traffic generated by the 'Smartbits' would compete with the traffic generated by the qtcp session for resources on the 128 Kbps link. The 'Smartbits' was programmed to generate a mix of packet sizes that simulates the typical load on a real corporate WAN link. qtcp was invoked in a manner intended to simulate a telephony traffic flow. The following parameters were used: Sender: qtcp -l64 -R3 -c1000 -n1000 -t 2.2.2.2 Receiver: qtcp -f"test" -c1000 -r This results in a test traffic flow of 64 byte packets sent at a rate of 24 Kbps.  The purpose of the test was to examine the utility of RSVP in protecting the signal flow on a WAN link driven to near saturation. To this end, the first trial was run without RSVP enabled on the routers. The second trial was run with RSVP enabled on the routers. In both cases, RSVP signaling was used between the sender and reciever. The results are illustrated below. Plots were generated using the technique described in Appendix C. The X-axis represents the packet sequence number. The Y-axis represents the normalized latency in units of 100 nsec. This plot illustrates the latency experienced by the signal packets without RSVP protection. Note that the first 1000 packets (sent during the no-noise calibration phase) show negligible latency. The second 1000 packets however, sent while background noise was generated) show a steadily increasing latency, up to over 1.6 seconds. Also, note the set of points aligned horizontally near the top of the plot. These correspond to the entries generated for dropped packets (which are represented by the maximum latency experienced by any of the received packets).  This plot illustrates the latency experienced by the signal packets with RSVP protection. Again, the first 1000 calibration packets show very low latency (note that the Y-axis scale is different between the two plots). The second 1000 packets show a distribution of latencies. However, the maximum latency is limited to 100 msec. Furthermore, no packets have been dropped. HD1:n  g l4v L|/|- b#z/u NKtJu vhjKrb x;y;{ o'NJtO 8OSW  5;t8S w`u*O $q.l7 |QIb4lw b&5(i $q3s% Py_6u Py_6u Py_6u Py_6u Py_6u P1c/e P1c/e P1c/e \8!x. -y<v< $nd&5( $nc&5 d&5(i c&5(i f8QIb13 ,1*I,e&5(iF fmRIb Ff4m; o}}RI" {[HF) m0(qV e&5(iF $Nc&5 mg1WjG \iPR_ }(*WD= }?H\D PIb,3 *ILb&5(iv m whG  *7F= Ca[5J SIb8lW E)T&( icGPoPCP 9|&ODZ $Pp80?  wRrxw% @d+hW8^mu _U~Vjx {yWOn vOdWP 4/N`; e+;|? 4QZK/ 8VR;]N t7Bku Fq$;J* -N&W}: (#DZz BP=-l@ND0 -t!'" 2,t!'" C-t!'"b -t!'" bB%'g[ :@9&T -t!'" ,t!'"Z ?-t!'" _v3Yf&(*V, lc^"mQC HFmoD R1T3j'  /:I4@g ]&(}6 ybo\> kW:o1 !t>i2 T7d=o Fyw&v O&nO\ >O:'6 1T3j+ \f['h .u>.t 14x_X Y\Esy JS\ij JS\i* |>HP3+ #rr]M >"7jQ R1Ts\ 1rS9: hZ3/p P((}6 Le`rg k<:I, 4IPznH' oQZ~M' Eiset yT:Il R1T3j bjy>H 47w=Z R1T3j Bt^m2 xt^g2 C6XZPz C6XVPznH sJt>m2 C6XWP JS\i* W3j2B y37jQ BL!bZ ]?|]r Ib*ToQ# ]!(=7 *y>H\i Z"YcE w#Fm0 1T3jC Sbo\f 2^MR^ 1d<OPz 2^ (= -'(}^ AFyw" n[_cE ?'{&^H2j W3j2B >EL?( jFm.bZ iuo&/ >>GOK ]wzr\bX 1T3j?" z5W\2B -!(}f ZKPzu Ib[(#(} =-(}. $FB/X JS\i* +:I4A#-j \s^:/2 <t^m2 JS\i* |>HPs R1T3jO! >G_l;> W3j2B ELi>c ksG1j z5W\2B }-(}f S OPz (4FPznH' :QP%~ Eiset 9[:It *y>H\i <lm3f &.4%|2,< f#]6R f3]6S f-.kIz 4KsYZ '=+rY .#i]F 0G*K* uI-K. {KR-1j %4ga} 1G*K* <alGy hlw{K2-1j UX_tuYE xKjZ6P yKR-1j %4eX_ FKli45 %F-!,-2K= _j1ZbK YvRK%, llwk, 4QK3, e[$-e RF-;`) TQK5, ^fYO- HfYE- 2K9,e2 4PK#, %F-!,-2K e;,[e 4PK#, jX*#Y 4QK3, ZBXZd 4PK#, VcYK- ZfYO- ]fYG- Zwh`;JU e5,+e aySfy ~9R6G ?`y[fy w`yKfy `y@fy a9_f9 VcY@- JuYL-K`9- 3a9]fY [rMv0 ,s"i9 Q!FKl A-3a) e4FKl PK_Xz ;ZbK/3- YzPKOX Kz$-] #`9Lf9 ,C1Zb dPK&, 2XhYD- dPK&, xsz`+ Y&QK., e<,ce ,#1Zb %AWh5 >2K7j ,Y2K_j =c2K&, B~gk~ ;=o^& ={>r?S[ mk-mmlk e[/i{ fokm[+m m;-mgl;#mgm;+m YZRK+X KhY:RK'X:8 1RYBi/ e8,Ce ,MXfQK iYA-+aY -Aj)3 ,MXVS 4aYK- \_t{I giVK) I1%2K( ^.a/9 X:PKGX PKkX^ ZNArBfYA-+aY. YVRK4,+d TPK%, e7,;e Zbp#+e 2DfYO- YzRK/Xz e9,Ke 2Of9F- %Nf9J- ,q2K1 e=,ke e9,Ke ,)2K1 ,%2KoL ,e2K6 YVRK4,+d FfYG- Y:PKGX ,92K+jy YZRK+X ,y2K?j TPK%, rPf9I- %Kf9B-Ga9, 2OfYO- %Kf9K- Gf9C-ga9- e8,Ce %NfYK- e<,ce s^gh5 2[f9B-Ga9, 2KfYE- Vc9F- 2YfYJ- YFRK$, ZRa9/ XfiC-mai- e7,;e e7,;e QK",{e oYe:{ QK2,ge ZfYD- YzPKOX 2NfY@- e:,Se %Mf9A-'a9. QK9,A %@-AXJe 2KfYE- o9oFx ,)2K1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tools\timestmp\timestmp.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Corp. Installing and using kernel time stamping support for QTCP Title _PID_HLINKSInstalling and using kernel time stamping support for QTCP Shreedhar Madhavapeddi Normal Shreedhar Madhavapeddi Microsoft Word 9.0G44F;d5fbjbjU Installing and using kernel time stamping support for QTCP.EXE TIMESTMP.SYS is the component that provides kernel mode time-stamping support for QTCP.EXE. It works as a pluggable module in the Packet Scheduler framework. TSINSTL.EXE is the program that installs and configures this on a host machine. How does it operate? On the sending side, it picks up packets that are destined to port 5003 and time-stamps the current system tickcount in a pre-determined field in the packet. On the receiver, it time-stamps the system tickcount into a different field. Having TIMESTMP installed will enhance the accuracy of results produced by QTCP.EXE. s the installation procedure? Run the installation application called TSINSTL.EXE (also available in the dump directory of your Windows 2000 CD). TIMESTMP.SYS can be configured to operate on specific adapters in the host machine. It can also be configured to be Auto or Manual Start.  The thing to remember however, is that once TIMESTMP.SYS is configured on an Interface (network adapter), the Packet Scheduler will not bind to TCP/IP (TCPIP.SYS) until it is started. What this means is that the Interface will not have an IP address until TIMESTMP.SYS is started. After running TSINSTL.EXE, copy TIMESTMP.SYS to your current drivers directory (%windir%\system32\drivers). A reboot will be required for the driver to be operational. ve got it installed   What next? Use QTCP.EXE to diagnose the network behavior (details about running it are described in a different document called qtc.doc). TIMESTMP will help in the accuracy of the results. m done with my experiments. You can leave TIMESTMP installed with negligible overhead. Alternatively, you can un-install TIMESTMP using TSINSTL.EXE (remove option). A reboot will be required for this to take effect. I want to upgrade my machine. Timestmp.sys does not get upgraded to its latest version by the NT SETUP (winnt32). This is for obvious reasons. Please uninstall QoS Packet Scheduler first. Then uninstall Timestmp using TSINSTL.EXE (remove option) before upgrading your machine. After your machine has been upgraded to the lastest build, follow the install procedure again to start experimenting. m having problems installing TIMESTMP. If you want to revert to your original settings, run TSINSTL.EXE and run the  remove  option. This opens your registry (regedt32.exe) and deletes some keys under HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\. Namely the PSCHED\Profiles key and the TIMESTMP key. You could also contact Sharon Maffet or Shreedhar Madhavapeddi (  HYPERLINK mailto:ShreeM@microsoft.com  ShreeM@microsoft.com ) for help.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\readme.txt ===
These are the binaries generated from here, and the names of files
on release media.

RNDISMP:
1. WinXP: sys\obj\*\rndismp.sys - <Use in-build binary, don't copy from disk>
2. Win2K: win2k\obj\i386\rndismp.sys - rndismp.sys
3. WinMe: win2k\obj\i386\rndismp.sys - rndismpm.sys
4. Win98Gold and SE: win9x\obj\i386\rndismp.sys - rndismpw.sys


USB8023:
1. WinXP: sys\obj\*\usb8023.sys - <Use in-build binary, don't copy from disk>
2. Win2K: sys\obj\i386\usb8023.sys - usb8023.sys
3. WinMe: sys\obj\i386\usb8023.sys - usb8023m.sys
4. Win98Gold and SE: win9x\obj\i386\usb8023.sys - usb8023w.sys
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\inf\usa\usb8023.txt ===
;
; Localizable strings
;
[Strings]
Microsoft                       = "Microsoft"
Peracom                         = "Peracom"
USB\VID_0565&PID_0041           = "Peracom USB Remote NDIS Ethernet Adapter"
CommonServiceDisplayName        = "USB Communications Class"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\help\readme32.txt ===
======================================================================
             Microsoft Connection Manager 1.3 Readme File

                            October 2000                  
======================================================================
           (C) Copyright Microsoft Corporation, 1995-2000

This document contains important, late-breaking information about 
Microsoft(r) Connection Manager 1.3. Before installing Connection 
Manager, please review this entire document. It contains critical 
information to ensure proper installation and use of the product.

------------------------------------------------
HOW TO USE THIS DOCUMENT
------------------------------------------------
      
You can view the Readme file on-screen in Windows Notepad. To print 
the Readme file, open it in Notepad or another word processor, and 
then on the File menu, click Print.

-----------------
CONTENTS
-----------------

1. SYSTEM REQUIREMENTS

2. USING CONNECTION MANAGER 1.3

    2.1 Using the Dialer
    2.2 Uninstalling Connection Manager
    2.3 Technical Support

3. KNOWN ISSUES WITH MICROSOFT CONNECTION MANAGER 1.3

-------------------------------------------
1. SYSTEM REQUIREMENTS
-------------------------------------------

This version is intended for users of Windows 95, Windows 98, 
Windows NT Workstation 4.0 with Service Pack 6a or higher, 
Windows NT Server 4.0 with Service Pack 6a or higher, 
Windows 2000 Professional, Windows 2000 Server, Windows 
Millennium Edition, Windows Whistler Personal, Windows Whistler
Professional, Windows Whistler Server, Windows Whistler Advanced Server,
and Windows Whistler Server 64-bit edition.  To use this release,
you need one of these operating systems with at least 2 MB of 
space available on your hard disk and a 9600 Baud or faster modem 
(for dial-up connections).

---------------------------------------------------------
2. USING CONNECTION MANAGER 1.3
---------------------------------------------------------

2.1 Using the Dialer
--------------------------
To start a connection with Microsoft Connection Manager 1.3, 
double-click the icon for your service located on the Windows 
desktop. The Connection Manager logon dialog box should appear. 
Enter your username and password. Click the Properties button. 
If available, click the Phone Book button and select a phone 
number from the list. If the Phone Book button is not available, 
then type a phone number directly into the Phone Number box. 
Click OK. Then, in the logon dialog box, click the Connect button.


2.2 Uninstalling Connection Manager
-------------------------------------------------
To uninstall Connection Manager from any operating system other than
Windows 2000 or Windows Whistler, click Start, point to Settings,
and then click Control Panel. Double-click Add/Remove Programs.
Select Microsoft Connection Manager, and then click Add/Remove.

Connection Manager cannot be uninstalled from Windows 2000 or
Windows Whistler installations.

To uninstall your service profile from any operating system other than
Windows 2000 or Windows Whistler, right-click your service's program
icon on the desktop, and then click Delete.  To uninstall your service
profile from Windows 2000 or Windows Whistler, right-click your service's
program icon in the Network and Dial-up Connections folder (Windows 2000)
or the Network Connections folder (Windows Whistler) and then click 
delete.

2.3 Technical Support
----------------------------
Contact your network administrator or service provider for support on 
this product.

----------------------------------------------------------------------     
3. KNOWN ISSUES WITH MICROSOFT CONNECTION MANAGER 1.3
----------------------------------------------------------------------    
* If you are running Windows NT 4.0, you must manually configure 
Point-to-Point Tunneling Protocol (PPTP) for your virtual private 
network (VPN). To configure PPTP for VPN on Windows NT 4.0:

  1. Click Start, point to Settings, click Control Panel, and then 
     double-click Network.
  2. On the Protocols tab, click Add, and then click Point To Point 
     Tunneling Protocol.  
  3. Click OK. 
  4. In Number of Virtual Private Networks, enter 1. 
  5. In the Remote Access Setup window, click Add. 
  6. In the Add RAS Device dialog box, select VPN1 - RASPPTPM, and 
     then click OK. 
  7. Select VPN1, and then click Configure. 
  8. In the Configure Port Usage dialog box, select Dial-Out Only, if 
     it is not already selected, and then click OK. 
  9. Click Network and make sure that TCP/IP is selected and then 
     complete the installation. 

* If you are running Windows NT 4.0 and are using a Connection Manager 
service profile that requires Dial-up Scripting, you must install 
Windows NT Service Pack 6a or later. It is recommended that you install 
the latest upgrade (currently Window NT Service Pack 6a). If you have 
problems with Connection Manager that you cannot resolve using the 
Connection Manager troubleshooting Help, uninstall RAS, re-install it, 
and then re-install the Windows NT service pack. Verify in RAS that 
VPN1 is configured for "Dial-Out Only." (See the above procedure for 
the method for configuring VPN1.)

* On Windows NT 4.0, if you try to establish more than one connection, 
you might see the message, "The modem (or other connecting device) is 
already in use or is not configured properly." This sometimes happens 
if you try to dial too quickly, or if you start Connection Manager 
when a connection has already been established using Dial-Up Networking. 
Use one connection at a time. 

* If you are running Windows NT 4.0 and you change the Disconnect 
If Idle setting, the change will not take effect until you quit 
Connection Manager and restart it. 

* If you want to install a Connection Manager service profile on a 
computer running Windows 98, you should uninstall the VPN1 adapter 
before installing Connection Manager 1.3. Connection Manager installs 
it but may not be able to reinstall over an existing VPN adapter. 

* Connection Manager does not support displaying a terminal window except
  on Windows Whistler. 

* If you are using Windows CE Services, you must use version 3.0 
(ActiveSync 3.0) or greater.

* When you install a version 1.0 Connection Manager profile on a Windows
2000 or Windows Whistler computer, you will receive an error which states
?The dynamic link library MSVCRT20.dll could not be found in the 
specified path ??.  Installation of the profile will succeed, but
you will have to depress F5 (function key 5) or restart your computer
for the desktop icon to display.

* Connection Manager only supports single channel ISDN, except on
Windows 2000, Windows Millennium and Windows Whistler, where the 
Administrator has specifically configured the service profile for 
dual channel ISDN. The Bandwidth Allocation Protocol (BAP) is not 
supported.

* Connection Manager 1.3 is currently unable to update the Connection
Manager binaries that shipped as a part of Windows 2000.  Thus Connection
Manager 1.3 profiles installed on Windows 2000 will not be able to
take advantage of features that were not available in the Windows 2000
version of Connection Manager, although the profiles will otherwise work
normally.

* In this beta release, the new logging feature is not supported when 
using a Connection Manager profile to log on to Windows.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\help\cmctx32.rtf ===
{\rtf1\ansi \deff4\deflang1033{\fonttbl{\f4\froman\fcharset0\fprq2 Times New Roman;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif{\*\falt AvantGarde};}{\f11\fmodern\fcharset0\fprq1 Courier New{\*\falt Courier};}} {\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0; \red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\widctlpar \f4\fs20 \snext0 Normal;}{\s1\sb280\sa40\widctlpar \b\f4\fs20 \sbasedon0\snext0 heading 1;}{\s2\sb120\widctlpar  \b\f4\fs20 \sbasedon0\snext0 heading 2;}{\s3\sb120\sa60\widctlpar \f4\fs20 \sbasedon0\snext0 heading 3;}{\s4\fi-245\li360\widctlpar \f4\fs20 \sbasedon0\snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}{\s15\fi-187\li274\sl-120\slmult0 \widctlpar\brdrb\brdrs\brdrw15\brsp20 \tx302 \f4\fs20 \sbasedon0\snext0 a/k link;}{\*\cs16 \additive\cf6 \sbasedon10 annotation reference;}{\s17\widctlpar \f4\fs20 \sbasedon0\snext17 annotation text;}{\s18\li115\ri130\sb120\sa120\widctlpar \f7\fs16  \snext0 bitmap;}{\s19\widctlpar \f4\fs20 \sbasedon0\snext0 Context;}{\*\cs20 \additive\up6 \sbasedon10 footnote reference;}{\s21\widctlpar \f4\fs20 \sbasedon0\snext0 footnote text;}{\s22\widctlpar \f4\fs20 \sbasedon0\snext22 Jl;}{ \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 \sbasedon0\snext24 Lb1;}{\s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 \sbasedon23\snext24 Lb2;}{\s25\fi-158\li461\sb48\widctlpar\tx461 \f4\fs20 \sbasedon24\snext25 Lb3;}{\s26\li302\sb60\widctlpar\tx302  \f4\fs20 \sbasedon24\snext24 Lp1;}{\s27\li720\widctlpar \f4\fs20 \sbasedon0\snext0 Normal Indent;}{\s28\fi-187\li274\sl-120\slmult0\widctlpar\tx302 \f4\fs20 \sbasedon15\snext28 oem a/k link;}{\s29\fi-302\li418\ri86\sa120\widctlpar \f4\fs20  \sbasedon0\snext29 oem button;}{\s30\fi-302\li418\ri86\sb160\sa120\widctlpar\tx720 \f4\fs20 \sbasedon29\snext30 oem button1;}{\s31\fi-187\li302\sb160\widctlpar\tx302 \f4\fs20 \sbasedon0\snext31 oem Lb1;}{\s32\sb160\widctlpar \f4\fs20 \sbasedon0\snext32  oem normal;}{\s33\ri2160\sb160\widctlpar \f4\fs20 \sbasedon0\snext33 oem popup;}{\s34\ri2160\widctlpar \f4\fs12 \sbasedon33\snext34 oem popup end;}{\s35\fi-187\li302\ri2160\sb160\widctlpar\tx302 \f4\fs20 \sbasedon31\snext35 oem popup Lb1;}{ \s36\sb240\widctlpar \b\f4\fs20 \sbasedon0\snext36 oem proc head;}{\s37\ri86\widctlpar \f4\fs20 \sbasedon0\snext0 oem tb text;}{\s38\li58\widctlpar \f4\fs20 \sbasedon0\snext38 oem tb text 2;}{\s39\fi-187\li245\widctlpar\tx245\tx302 \f4\fs20  \sbasedon23\snext39 oem tb text 2 Lb1;}{\s40\fi-187\li245\sb48\widctlpar\tx245\tx302 \f4\fs20 \sbasedon24\snext40 oem tb text 2 Lb2;}{\s41\fi-158\li403\sb48\widctlpar\tx403\tx461 \f4\fs20 \sbasedon25\snext41 oem tb text 2 Lb3;}{\s42\widctlpar \f4\fs20  \sbasedon0\snext42 Pop-up;}{\s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \snext23 proc head;}{\s44\li115\ri86\sb280\widctlpar \f4\fs20 \sbasedon29\snext29 table top;}{\s45\li58\sb280\widctlpar \f4\fs20 \sbasedon44\snext38 table top 2;}{ \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \sbasedon24\snext46 Tbr1;}{\s47\widctlpar \f4\fs20 \sbasedon0\snext0 Tech Rev;}{\s48\li58\sb80\widctlpar \f4\fs20 \sbasedon44\snext48 vertrule;}{\*\cs49 \additive\b \sbasedon10 UI;}{\*\cs50 \additive \scaps\fs14 \sbasedon10 Smallcaps;}{\s51\widctlpar\brdrb\brdrs\brdrw15\brsp20 \f4\fs20 \sbasedon38\snext51 Table row w/rule;}{\s52\fi-302\li388\widctlpar\tqr\tx274\tx389 \f4\fs20 \sbasedon23\snext52 Lb1a;}{\s53\fi-302\li388\sb48\widctlpar\tqr\tx274\tx389  \f4\fs20 \sbasedon52\snext53 Lb2a;}{\s54\fi-547\li662\ri187\sb60\sa60\sl240\slmult0\nowidctlpar\tx660 \f4\fs20 \sbasedon0\snext54 Np;}{\s55\widctlpar \f11\fs20 \sbasedon0\snext0 Code;}{\*\cs56 \additive\cf12 \sbasedon10 HTML;}}{\info {\title Create Help files for Winhelp 4.0}{\author Linda Wells}{\operator Linda Wells}{\creatim\yr1997\mo6\dy26\hr15\min32}{\revtim\yr1998\mo10\dy16\hr15\min21}{\printim\yr1998\mo1\dy7\hr12\min5}{\version2}{\edmins1}{\nofpages37}{\nofwords1281} {\nofchars7304}{\*\company Microsoft Corporation}{\vern57443}}\margl1440\margr1440 \widowctrl\ftnbj\aenddoc\linkstyles\hyphcaps0\formshade \fet0\sectd \linex0\endnhere {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2 \pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6 \pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain \widctlpar \f4\fs20 {\v\cf6 IDH_LOGON_NAME }{\cs20\cf1\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_LOGON_NAME}} Specifies the name you use to log on to the service.{\*\atrfstart 970056375}  This is the name that uniquely identifies you to the service and that is associated with your password.{\*\atrfend 970056375} \par {\up6 \page }{\v\cf6 IDH_LOGON_PSWD }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_LOGON_PSWD}} Specifies the password required to log on to your service. The text you type appears as asterisks ({\b *} ) to protect the confidentiality of your password. \par {\up6 \page }{\v\cf6 IDH_LOGON_NEW }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_LOGON_NEW}} Specifies a new password. \par {\up6 \page }{\v\cf6 IDH_LOGON_SAVEPW }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_LOGON_SAVEPW}} Specifies whether your password is automatically filled in each time you connect to the service. \par If you select this check box, other people with access to this computer might be able to access your {\*\atrfstart 970056376}Internet{\*\atrfend 970056376} service account using your user name and password. \par {\up6 \page }{\v\cf6 IDH_LOGON_DOMAIN }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_LOGON_DOMAIN}} Specifies, if necessary, the name of the domain on your private network which you want to log on to. \par {\up6 \page }{\v\cf6 IDH_LOGON_AUTOCONN }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_LOGON_AUTOCONN}}  Specifies whether to connect automatically when you start your service. If you select this check box, you do not need to click {\cs49\b Connect }to access the service. This option takes effect after you select the option and close the logon dialog box. \par {\up6 \page }{\v\cf6 IDH_LOGON_SVCMSG }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_LOGON_SVCMSG}} Displays support information if available.  \par {\up6 \page }{\v\cf6 IDH_LOGON_CONNECT_STAT }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_LOGON_CONNECT_STAT}}  Displays information on the status of the connection and prompts you for information you must provide to connect to the service. \par {\up6 \page }{\v\cf6 IDH_LOGON_CONNECT }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #}IDH_LOGON_CONNECT}} Initiates a connection to your service. \par After you connect, the logon{\cs49\b  }dialog box closes and an icon appears in the status area of the taskbar. To see the status of the connection, double-click the icon. To disconnect from the service, right-click the icon, and then click {\cs49\b  Disconnect}. \par {\up6 \page }{\v\cf6 IDH_LOGON_CANCEL }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_LOGON_CANCEL}} Closes the {\cs49 logon} dialog box without dialing. If the call is in progress, click to cancel the call. \par {\up6 \page }{\v\cf6 IDH_LOGON_PROPERTIES }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_LOGON_PROPERTIES}} Displays the {\b Properties}  dialog box, which you can use to change the connection information for your service, including dialing information and modem settings, where required.  \par {\up6 \page }{\v\cf6 IDH_STATUS_DISCONNECT }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_STATUS_DISCONNECT}} Disconnects you from the service. \par {\up6 \page }{\v\cf6 IDH_GENERAL_ALREADY }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_GENERAL_ALREADY}} Specifies that you have a direct connection (such as LAN, ADSL, or cable) established on your computer. \par {\up6 \page }{\v\cf6 IDH_GENERAL_DIALTHIS }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_GENERAL_DIALTHIS}} Specifies that you will use a dial-up connection to access your service. \par {\up6 \page }{\v\cf6 IDH_GENERAL_PHONENUM }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_GENERAL_PHONENUM}} Specifies the first phone number that your computer dials to access the service. \par If your computer cannot connect to the service using this access number, it automatically dials the number specified in {\b Backup number}, if you have provided one. You can use {\cs49\b Phone Book} if you want to specify a new access number. \par You can type a number instead of selecting an access number from {\b Phone Book}. However, you must type any dialing codes (such as 1 for long distanc e, 9 to access an outside line, or *70 to disable call waiting) as part of the number. If you have trouble dialing, especially in areas that use 10-digit dialing, try typing the number, exactly as it should be dialed. \par {\up6 \page }{\v\cf6 IDH_GENERAL_BACKUPNUM }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_GENERAL_BACKUPNUM}}  Specifies the phone number your computer dials if it cannot connect to the service by using the access number specified in {\b Phone number}. You can use {\cs49\b Phone Book} to specify a new access number. \par You can type a number instead of selecting an access number from {\b Phone Book} . However, you must type any dialing codes (such as 1 for long distance, 9 to access an outside line, or *70 to disable call waiting) as part of the number. If you have trouble dialing, especially in areas that use 10-digit dialing, try typing the number,  exactly as it should be dialed. \par {\up6 \page }{\v\cf6 IDH_GENERAL_PHONEBOOK }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_GENERAL_PHONEBOOK}} Click to view or change the access numbers available as your primary access number. \par {\up6 \page }{\v\cf6 IDH_GENERAL_PHONEBOOKB }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_GENERAL_PHONEBOOKB}}Click to view or change the access numbers available as your backup access number. \par {\up6 \page }{\v\cf6 IDH_GENERAL_DIALRULE }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_GENERAL_DIALRULE}}  Click to view or change the information about the location from which you are dialing and the dialing options for this location, including any dialing codes required to access local or long-distance lines. \par These dialing rules apply only to access numbers selected using {\b Phone Book}. If you type a number in {\cs49\b Phone number} or {\cs49\b Backup number} instead of selecting a number from the phone book, you must type  the dialing codes (such as 1 for long distance, 9 to access an outside line, or *70 to disable call waiting) as part of the number. \par {\up6 \page }{\v\cf6 IDH_GENERAL_USE_DIAL_RULE }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_GENERAL_USE_DIAL_RULE}} Specifies whether to use the rules configured in the {\b Dialing Properties } dialog box when dialing the primary phone number last selected from the phone book. To set up or change rules so that they are appropriate for your current location, click {\b Dialing Rules}. \par If the number you are dialing has the same area code as your current location, but is a long-distance number, you may need to clear this check box and type the complete number in {\b Phone number} , including the access codes required to dial long-distance calls. If you clear this check box and type the phone number, you must type all information required to complete the call. This includes all of the dialing information, such as any credit card nu mber and numbers required to access an outside line, that would have been taken from the {\b Dialing Properties} dialog box if {\b Use dialing rules} were selected. \par {\up6 \page }{\v\cf6 IDH_GENERAL_USE_DIAL_RULEB }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_GENERAL_USE_DIAL_RULEB}} Specifies whether to use the rules configured in the {\b Dialing Properties } dialog box when dialing the backup phone numbers last selected from the phone book. To set up or change rules so that they are appropriate for your current location, click {\b Dialing Rules}. \par If the number you are dialing has the same area code as your current location, but is a long-distance number, you may need to clear this check box and type the complete number in {\b Backup number} , including the access codes required to dial long-distance calls. If you clear this check box and type the phone number, you must type all information required to complete the call. This includes all of the dialing information, such as any credit card nu mber and numbers required to access an outside line, that would have been taken from the {\b Dialing Properties} dialog box if {\b Use dialing rules} were selected. \par {\up6 \page }{\v\cf6 IDH_GENERAL_CONNECT_MODEM }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_GENERAL_CONNECT_MODEM}} Displays the modem used to conne ct to your service. If more than one modem is installed on your computer, you can use a different modem by selecting it in this list. \par {\up6 \page }{\v\cf6 IDH_INTERNET_USER_NAME }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_INTERNET_USER_NAME}}  Specifies the name you use to connect to the Internet using a secure connection. This name is different from the name you use to connect to your private network. \par {\up6 \page }{\v\cf6 IDH_INTERNET_PASSWORD }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_INTERNET_PASSWORD}}  Specifies the password that is associated with the user name you use to connect to the Internet using a secure connection. The text you type appears as asterisks ({\b *}) to protect the confidentiality of your password. \par {\up6 \page }{\v\cf6 IDH_INTERNET_SAVEPASS }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_INTERNET_SAVEPASS}}  Specifies whether your user name and password are automatically filled in each time you connect to the Internet using a secure connection. \par If you select this check box, other people with access to this computer might be able to access your Internet service account using your user name and password. \par {\up6 \page }{\v\cf6 IDH_OPTIONS_IDLEDIS }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_OPTIONS_IDLEDIS}} Specifies the maximum number of minutes the connection can remain inactive before the call is automatically  {\*\atrfstart 970056377}cancelled{\*\atrfend 970056377}. \par {\up6 \page }{\v\cf6 IDH_OPTIONS_REDIAL }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_OPTIONS_REDIAL}}  Specifies the maximum number of times the number is redialed (without successfully connecting) before the call is automatically cancelled. \par {\up6 \page }{\v\cf6 IDH_PHONEBOOK_SERVICETYP }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_PHONEBOOK_SERVICETYP}} Lists the service types (such as modem or ISDN) that your  service supports. Each service type has its own set of access numbers. Only phone numbers that support the selected service type appear in {\cs49\b Access numbers}. \par {\up6 \page }{\v\cf6 IDH_PHONEBOOK_COUNTRY }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_PHONEBOOK_COUNTRY}}  Lists the countries and regions with phone numbers you can use to access your service. Each country or region has its own set of access numbers. Only phone numbers for the selected country or region appear in {\cs49\b Access numbers}. \par {\up6 \page }{\v\cf6 IDH_PHONEBOOK_STATEREG }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_PHONEBOOK_STATEREG}} Lists the states or provinces wi th phone numbers you can use to access your service. Each state or province has its own set of access numbers. Only phone numbers for the selected area appear in {\cs49\b Access numbers}. \par {\up6 \page }{\v\cf6 IDH_PHONEBOOK_ACCESSNUMS }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_PHONEBOOK_ACCESSNUMS}}  Lists the phone numbers available for accessing your service. The available access numbers include only those numbers that are supported by the service type, country or region, and state or province that you have selected. \par The service provider can periodically add new numbers for one or more service types or service areas. \par {\up6 \page }{\v\cf6 IDH_PHONEBOOK_MORENUMS }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_PHONEBOOK_MORENUMS}}  Lists additional phone numbers that you can use to access your service. If you use one of these phone numbers, you might be charged an additional fee. For more information, see your customer service agreement. \par {\up6 \page }{\v\cf6 IDH_PHONEBOOK_SVCMSG }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_PHONEBOOK_SVCMSG}} Displays support information if available. \par {\up6 \page }{\v\cf6 IDH_CMHELP }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_CMHELP}} Starts a troubleshooter that can help resolve problems with connecting to the service. \par {\up6 \page }{\v\cf6 IDH_DETAILS }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_DETAILS}} Displays more information about this connection. \par {\up6 \page }{\v\cf6 IDH_OK_CONNECTED }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} IDH_OK_CONNECTED}} Closes the {\b Connected} dialog box. \par {\up6 \page } \par }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\help\cmtrb32.rtf ===
{\rtf1\ansi \deff4\deflang1033{\fonttbl{\f0\froman\fcharset0\fprq2 Tms Rmn{\*\falt Times New Roman};}{\f1\froman\fcharset2\fprq2 Symbol;}{\f2\fswiss\fcharset0\fprq2 Helv{\*\falt Arial};}{\f3\fmodern\fcharset0\fprq1 Courier;} {\f4\froman\fcharset0\fprq2 Times New Roman;}{\f5\fswiss\fcharset0\fprq2 Arial;}{\f6\froman\fcharset0\fprq2 MS Serif;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif{\*\falt AvantGarde};}{\f8\froman\fcharset0\fprq2 Times;}{\f9\fswiss\fcharset0\fprq2 Helvetica;} {\f10\fswiss\fcharset0\fprq2 System{\*\falt \'82c\'82ePOP\'91\'cc};}{\f11\fmodern\fcharset0\fprq1 Courier New{\*\falt Courier};}{\f12\froman\fcharset0\fprq2 New York{\*\falt Times New Roman};}{\f13\fswiss\fcharset0\fprq2 Geneva{\*\falt Arial};} {\f14\fswiss\fcharset0\fprq2 AvantGarde;}{\f15\froman\fcharset0\fprq2 ITC Bookman;}{\f16\fswiss\fcharset0\fprq2 Helvetica-Narrow;}{\f17\froman\fcharset0\fprq2 NewCenturySchlbk;}{\f18\froman\fcharset0\fprq2 Palatino;} {\f19\froman\fcharset0\fprq2 ZapfChancery;}{\f20\fdecor\fcharset2\fprq2 ZapfDingbats;}{\f21\fnil\fcharset2\fprq2 Marlett;}{\f22\fmodern\fcharset0\fprq1 Lucida Console;}{\f23\fswiss\fcharset0\fprq2 Lucida Sans Unicode;} {\f24\fnil\fcharset2\fprq2 Wingdings;}{\f25\fswiss\fcharset0\fprq2 Tahoma;}{\f26\froman\fcharset0\fprq2 Bookman Old Style;}{\f27\fnil\fcharset2\fprq2 Monotype Sorts;}{\f28\fnil\fcharset2\fprq2 MS Outlook;}{\f29\fswiss\fcharset0\fprq2 Haettenschweiler;} {\f30\froman\fcharset0\fprq2 Garamond;}{\f31\fmodern\fcharset2\fprq1 MS LineDraw;}{\f32\fnil\fcharset2\fprq2 MSIcons;}{\f33\fswiss\fcharset0\fprq2 Arial Narrow;}{\f34\fmodern\fcharset0\fprq1 Lucida Sans Typewriter;}{\f35\froman\fcharset2\fprq2 Webdings;} {\f36\fswiss\fcharset0\fprq2 Arial Black;}{\f37\fscript\fcharset0\fprq2 Comic Sans MS;}{\f38\fswiss\fcharset0\fprq2 Impact;}{\f39\fswiss\fcharset0\fprq2 Verdana;}{\f40\fswiss\fcharset0\fprq2 Arial Rounded MT Bold;} {\f41\froman\fcharset0\fprq2 Book Antiqua;}{\f42\fscript\fcharset0\fprq2 Brush Script MT;}{\f43\fswiss\fcharset0\fprq2 Century Gothic;}{\f44\froman\fcharset0\fprq2 Century Schoolbook;}{\f45\froman\fcharset0\fprq2 Georgia;} {\f46\fswiss\fcharset0\fprq2 Trebuchet MS;}{\f47\fdecor\fcharset0\fprq2 Beesknees ITC;}{\f48\fscript\fcharset0\fprq2 Bradley Hand ITC;}{\f49\froman\fcharset0\fprq2 Calisto MT;}{\f50\fdecor\fcharset0\fprq2 Curlz MT;}{\f51\froman\fcharset0\fprq2 Elephant;} {\f52\fswiss\fcharset0\fprq2 Eras Bold ITC;}{\f53\fswiss\fcharset0\fprq2 Eras Demi ITC;}{\f54\fswiss\fcharset0\fprq2 Eras Light ITC;}{\f55\fswiss\fcharset0\fprq2 Eras Medium ITC;}{\f56\fswiss\fcharset0\fprq2 Eras Ultra ITC;} {\f57\fdecor\fcharset0\fprq2 Juice ITC;}{\f58\fdecor\fcharset0\fprq2 Matisse ITC;}{\f59\froman\fcharset0\fprq2 Rockwell;}{\f60\froman\fcharset0\fprq2 Rockwell Extra Bold;}{\f61\fdecor\fcharset0\fprq2 Snap ITC;} {\f62\fdecor\fcharset0\fprq2 Tempus Sans ITC;}{\f63\fscript\fcharset0\fprq2 Viner Hand ITC;}{\f64\froman\fcharset0\fprq2 Wide Latin;}{\f65\froman\fcharset255\fprq2 Roman;}{\f66\fscript\fcharset255\fprq2 Script;}{\f67\fmodern\fcharset255\fprq2 Modern;} {\f68\fswiss\fcharset0\fprq1 MS Dialog;}{\f69\fmodern\fcharset0\fprq1 LinePrinter;}{\f70\froman\fcharset0\fprq2 CG Times{\*\falt Times New Roman};}{\f71\fswiss\fcharset0\fprq2 Univers{\*\falt Arial};}{\f72\fswiss\fcharset0\fprq2 Univers Condensed;} {\f73\fswiss\fcharset0\fprq2 Antique Olive;}{\f74\fswiss\fcharset0\fprq2 CG Omega;}{\f75\fswiss\fcharset0\fprq2 Albertus Medium;}{\f76\fswiss\fcharset0\fprq2 Albertus Extra Bold;}{\f77\froman\fcharset0\fprq2 Clarendon Condensed;} {\f78\fscript\fcharset0\fprq2 Coronet;}{\f79\fmodern\fcharset0\fprq1 Letter Gothic{\*\falt Courier New};}{\f80\fscript\fcharset0\fprq2 Marigold;}{\f81\fnil\fcharset0\fprq2 Microsoft Logo;}{\f82\fswiss\fcharset2\fprq2 Bookshelf Symbol 1;} {\f83\fnil\fcharset2\fprq2 Bookshelf Symbol 2;}{\f84\froman\fcharset2\fprq2 Bookshelf Symbol 3;}{\f85\fdecor\fcharset0\fprq2 Algerian;}{\f86\fdecor\fcharset0\fprq2 Braggadocio;}{\f87\fswiss\fcharset0\fprq2 Britannic Bold;} {\f88\fdecor\fcharset0\fprq2 Colonna MT;}{\f89\fdecor\fcharset0\fprq2 Desdemona;}{\f90\froman\fcharset0\fprq2 Footlight MT Light;}{\f91\fdecor\fcharset0\fprq2 Kino MT;}{\f92\fscript\fcharset0\fprq2 Matura MT Script Capitals;} {\f93\fdecor\fcharset0\fprq2 Playbill;}{\f94\fswiss\fcharset0\fprq2 Microsoft Sans Serif;}{\f95\fdecor\fcharset0\fprq2 Bauhaus 93;}{\f96\fscript\fcharset0\fprq2 Gradl;}{\f97\fscript\fcharset0\fprq2 Mistral;}{\f98\fdecor\fcharset0\fprq2 Stencil;} {\f99\fscript\fcharset0\fprq2 Vivaldi;}{\f100\fscript\fcharset0\fprq2 Lucida Handwriting;}{\f101\fnil\fcharset2\fprq2 MS Reference 1;}{\f102\fnil\fcharset2\fprq2 MS Reference 2;}{\f103\fswiss\fcharset2\fprq2 Arial Special G1;} {\f104\fswiss\fcharset2\fprq2 Arial Special G2;}{\f105\fswiss\fcharset2\fprq2 Arial Narrow Special G1;}{\f106\fswiss\fcharset2\fprq2 Arial Narrow Special G2;}{\f107\froman\fcharset2\fprq2 Times New Roman Special G1;} {\f108\froman\fcharset2\fprq2 Times New Roman Special G2;}{\f109\froman\fcharset0\fprq2 Map Symbols;}{\f110\fmodern\fcharset255\fprq1 Terminal;}{\f111\fmodern\fcharset0\fprq1 Fixedsys;}{\f112\fswiss\fcharset0\fprq2 Small Fonts;} {\f113\fswiss\fcharset0\fprq2 MS Dialog Light;}{\f114\fswiss\fcharset0\fprq2 MS SystemEx;}{\f115\froman\fcharset0\fprq0 boldPS;}{\f116\froman\fcharset161\fprq0 Times New Roman Greek{\*\falt Times};} {\f117\froman\fcharset238\fprq0 Times New Roman CE{\*\falt Times};}{\f118\froman\fcharset204\fprq0 Times New Roman Cyr{\*\falt Times};}{\f119\froman\fcharset162\fprq0 Times New Roman Turkish{\*\falt Bookman Old Style};} {\f120\froman\fcharset186\fprq0 Times New Roman Baltic{\*\falt Times};}{\f121\fswiss\fcharset161\fprq0 Arial Greek{\*\falt Helvetica};}{\f122\fswiss\fcharset238\fprq0 Arial CE{\*\falt Helvetica};} {\f123\fswiss\fcharset204\fprq0 Arial Cyr{\*\falt Helvetica};}{\f124\fswiss\fcharset162\fprq0 Arial Turkish{\*\falt Tahoma};}{\f125\fswiss\fcharset186\fprq0 Arial Baltic{\*\falt Helvetica};}{\f126\froman\fcharset2\fprq2 Wingdings 3;} {\f127\fswiss\fcharset0\fprq2 Abadi MT Condensed Extra Bold;}{\f128\fswiss\fcharset0\fprq2 Abadi MT Condensed Light;}{\f129\fswiss\fcharset0\fprq2 Copperplate Gothic Bold;}{\f130\fswiss\fcharset0\fprq2 Copperplate Gothic Light;} {\f131\froman\fcharset0\fprq2 Engravers MT;}{\f132\fswiss\fcharset0\fprq2 Eurostile;}{\f133\fdecor\fcharset0\fprq2 Felix Titling;}{\f134\fdecor\fcharset0\fprq2 Flexure;}{\f135\fscript\fcharset0\fprq2 French Script MT;} {\f136\froman\fcharset0\fprq2 Goudy Old Style;}{\f137\froman\fcharset0\fprq2 Goudy Stout;}{\f138\fdecor\fcharset0\fprq2 Harrington;}{\f139\fdecor\fcharset0\fprq2 Imprint MT Shadow;}{\f140\fscript\fcharset0\fprq2 Lucida Calligraphy;} {\f141\fswiss\fcharset0\fprq2 Lucida Sans;}{\f142\fswiss\fcharset0\fprq2 Maiandra GD;}{\f143\fnil\fcharset0\fprq2 Mead Bold;}{\f144\fnil\fcharset0\fprq2 Mercurius Script MT Bold;}{\f145\froman\fcharset0\fprq2 Modern No. 20;} {\f146\fmodern\fcharset0\fprq2 OCR A Extended;}{\f147\froman\fcharset0\fprq2 Rockwell Condensed;}{\f148\fnil\fcharset2\fprq2 Vacation MT;}{\f149\froman\fcharset2\fprq2 Wingdings 2;}{\f150\froman\fcharset0\fprq2 Baskerville Old Face;} {\f151\froman\fcharset0\fprq0 i;}{\f152\fmodern\fcharset2\fprq2 OCR-A;}{\f153\fmodern\fcharset0\fprq2 QuickType Mono;}{\f154\fswiss\fcharset0\fprq2 QuickType;}{\f155\fswiss\fcharset0\fprq2 QuickType Condensed;}{\f156\fnil\fcharset2\fprq2 QuickType Pi;} {\f157\fswiss\fcharset0\fprq2 Abadi MT Condensed;}{\f158\fscript\fcharset0\fprq2 American Uncial;}{\f159\fdecor\fcharset0\fprq2 Augsburger Initials;}{\f160\fdecor\fcharset0\fprq2 Broadway;}{\f161\froman\fcharset0\fprq2 Castellar;} {\f162\fdecor\fcharset0\fprq2 Edda;}{\f163\fdecor\fcharset0\fprq2 Harlow Solid Italic;}{\f164\froman\fcharset2\fprq2 Monotype Sorts 2;}{\f165\fmodern\fcharset0\fprq1 OCRB;}{\f166\fscript\fcharset0\fprq2 Old English Text MT;} {\f167\fscript\fcharset0\fprq2 Palace Script MT;}{\f168\fscript\fcharset0\fprq2 Parade;}{\f169\froman\fcharset0\fprq2 Runic MT Condensed;}{\f170\fdecor\fcharset0\fprq2 Stop;}{\f171\froman\fcharset0\fprq2 Aldine721 BT;} {\f172\fswiss\fcharset0\fprq2 Futura Md BT;}{\f173\fscript\fcharset0\fprq2 BrushScript BT;}{\f174\froman\fcharset0\fprq2 ClassGarmnd BT;}{\f175\fdecor\fcharset0\fprq2 UnivrstyRoman Bd BT;}{\f176\froman\fcharset0\fprq2 Windsor LtCn BT;} {\f177\froman\fcharset0\fprq2 Cooper Md BT;}{\f178\fscript\fcharset0\fprq2 DomCasual BT;}{\f179\froman\fcharset0\fprq2 ElegaGarmnd BT;}{\f180\fscript\fcharset0\fprq2 Kaufmann Bd BT;}{\f181\fswiss\fcharset0\fprq2 VAGRounded BT;} {\f182\fscript\fcharset0\fprq2 English157 BT;}{\f183\fscript\fcharset0\fprq2 MurrayHill Bd BT;}{\f184\fscript\fcharset0\fprq2 Cataneo BT;}{\f185\fscript\fcharset0\fprq2 Amazone BT;}{\f186\fscript\fcharset0\fprq2 Freehand591 BT;} {\f187\fscript\fcharset0\fprq2 Freehand575 BT;}{\f188\froman\fcharset0\fprq2 DellaRobbia BT;}{\f189\fscript\fcharset0\fprq2 Formal436 BT;}{\f190\fdecor\fcharset0\fprq2 Tango BT;}{\f191\fdecor\fcharset0\fprq2 OldDreadfulNo7 BT;} {\f192\fscript\fcharset0\fprq2 Kunstler Script;}{\f193\fscript\fcharset0\fprq2 Pepita MT;}{\f194\fscript\fcharset0\fprq2 Rage Italic;}{\f195\fscript\fcharset0\fprq2 Script MT Bold;}{\f196\fswiss\fcharset0\fprq2 Tw Cen MT;} {\f197\fscript\fcharset0\fprq2 Vladimir Script;}{\f198\fscript\fcharset0\fprq2 Forte;}{\f199\fswiss\fcharset0\fprq2 Gill Sans MT Ext Condensed Bold;}{\f200\fnil\fcharset0\fprq2 Lucida Blackletter;} {\f201\fscript\fcharset0\fprq2 Monotype Corsiva{\*\falt ZapfChancery};}{\f202\fswiss\fcharset0\fprq2 Placard Condensed;}{\f203\fnil\fcharset2\fprq2 Signs MT;}{\f204\fnil\fcharset2\fprq2 Almanac MT;}{\f205\froman\fcharset0\fprq2 Bell MT;} {\f206\froman\fcharset0\fprq2 Bernard MT Condensed;}{\f207\fnil\fcharset2\fprq2 Bon Apetit MT;}{\f208\froman\fcharset0\fprq2 Cooper Black;}{\f209\fnil\fcharset2\fprq2 Directions MT;}{\f210\fswiss\fcharset0\fprq2 Franklin Gothic Book{\*\falt Tahoma};} {\f211\fswiss\fcharset0\fprq2 Franklin Gothic Demi{\*\falt Times New Roman};}{\f212\fswiss\fcharset0\fprq2 Franklin Gothic Demi Cond;}{\f213\fswiss\fcharset0\fprq2 Franklin Gothic Heavy;}{\f214\fswiss\fcharset0\fprq2 Franklin Gothic Medium;} {\f215\fswiss\fcharset0\fprq2 Franklin Gothic Medium Cond;}{\f216\froman\fcharset0\fprq2 Gloucester MT Extra Condensed;}{\f217\fnil\fcharset2\fprq2 Holidays MT;}{\f218\froman\fcharset0\fprq2 Lucida Bright;}{\f219\froman\fcharset0\fprq2 Lucida Fax;} {\f220\fswiss\fcharset0\fprq2 News Gothic MT;}{\f221\fdecor\fcharset0\fprq2 Onyx;}{\f222\fnil\fcharset2\fprq2 Parties MT;}{\f223\froman\fcharset0\fprq2 Perpetua{\*\falt Times New Roman};}{\f224\froman\fcharset0\fprq2 Perpetua Titling MT;} {\f225\fdecor\fcharset0\fprq2 Ransom;}{\f226\fnil\fcharset2\fprq2 Sports Two MT;}{\f227\fnil\fcharset2\fprq2 Sports Three MT;}{\f228\fnil\fcharset2\fprq2 Transport MT;}{\f229\fnil\fcharset2\fprq2 Keystrokes MT;} {\f230\froman\fcharset162\fprq2 Times New Roman Tur{\*\falt Times};}{\f231\fswiss\fcharset162\fprq2 Arial Tur{\*\falt Helvetica};}{\f232\fmodern\fcharset238\fprq1 Courier New CE{\*\falt Courier};} {\f233\fmodern\fcharset204\fprq1 Courier New Cyr{\*\falt Courier};}{\f234\fmodern\fcharset161\fprq1 Courier New Greek{\*\falt Courier};}{\f235\fmodern\fcharset162\fprq1 Courier New Tur{\*\falt Courier};} {\f236\fmodern\fcharset186\fprq1 Courier New Baltic{\*\falt Courier};}{\f237\fswiss\fcharset238\fprq2 Tahoma CE{\*\falt ?l?r ??\'92c};}{\f238\fswiss\fcharset204\fprq2 Tahoma Cyr{\*\falt ?l?r ??\'92c};} {\f239\fswiss\fcharset161\fprq2 Tahoma Greek{\*\falt ?l?r ??\'92c};}{\f240\fswiss\fcharset162\fprq2 Tahoma Tur{\*\falt ?l?r ??\'92c};}{\f241\fswiss\fcharset186\fprq2 Tahoma Baltic{\*\falt ?l?r ??\'92c};} {\f242\fmodern\fcharset238\fprq1 Lucida Console CE{\*\falt Tahoma};}{\f243\fmodern\fcharset204\fprq1 Lucida Console Cyr{\*\falt Tahoma};}{\f244\fmodern\fcharset161\fprq1 Lucida Console Greek{\*\falt Tahoma};} {\f245\fmodern\fcharset162\fprq1 Lucida Console Tur{\*\falt Tahoma};}{\f246\fswiss\fcharset238\fprq2 Lucida Sans Unicode CE{\*\falt Tahoma};}{\f247\fswiss\fcharset204\fprq2 Lucida Sans Unicode Cyr{\*\falt Tahoma};} {\f248\fswiss\fcharset161\fprq2 Lucida Sans Unicode Greek{\*\falt Tahoma};}{\f249\fswiss\fcharset162\fprq2 Lucida Sans Unicode Tur{\*\falt Tahoma};}{\f250\fswiss\fcharset238\fprq2 Arial Narrow CE;}{\f251\fswiss\fcharset204\fprq2 Arial Narrow Cyr;} {\f252\fswiss\fcharset161\fprq2 Arial Narrow Greek;}{\f253\fswiss\fcharset162\fprq2 Arial Narrow Tur;}{\f254\fswiss\fcharset186\fprq2 Arial Narrow Baltic;}{\f255\fswiss\fcharset238\fprq2 Arial Black CE;}{\f256\fswiss\fcharset204\fprq2 Arial Black Cyr;} {\f257\fswiss\fcharset161\fprq2 Arial Black Greek;}{\f258\fswiss\fcharset162\fprq2 Arial Black Tur;}{\f259\fswiss\fcharset186\fprq2 Arial Black Baltic;}{\f260\froman\fcharset238\fprq2 Bookman Old Style CE;} {\f261\froman\fcharset204\fprq2 Bookman Old Style Cyr;}{\f262\froman\fcharset161\fprq2 Bookman Old Style Greek;}{\f263\froman\fcharset162\fprq2 Bookman Old Style Tur;}{\f264\froman\fcharset186\fprq2 Bookman Old Style Baltic;} {\f265\froman\fcharset238\fprq2 Garamond CE;}{\f266\froman\fcharset204\fprq2 Garamond Cyr;}{\f267\froman\fcharset161\fprq2 Garamond Greek;}{\f268\froman\fcharset162\fprq2 Garamond Tur;}{\f269\froman\fcharset186\fprq2 Garamond Baltic;} {\f270\fswiss\fcharset238\fprq2 Impact CE;}{\f271\fswiss\fcharset204\fprq2 Impact Cyr;}{\f272\fswiss\fcharset161\fprq2 Impact Greek;}{\f273\fswiss\fcharset162\fprq2 Impact Tur;}{\f274\fswiss\fcharset186\fprq2 Impact Baltic;} {\f275\froman\fcharset0\fprq2 Code39;}{\f276\fdecor\fcharset0\fprq2 BSDICONS;}{\f277\fdecor\fcharset0\fprq2 Peignot Medium;}{\f278\fswiss\fcharset0\fprq2 Gill Sans Ultra Bold;}{\f279\fswiss\fcharset0\fprq2 Futura;} {\f280\fscript\fcharset0\fprq2 BriemScript;}{\f281\fscript\fcharset0\fprq2 Contemporary Brush;}{\f282\fscript\fcharset0\fprq2 Eckmann;}{\f283\froman\fcharset0\fprq2 New Caledonia;}{\f284\froman\fcharset0\fprq2 Centaur;} {\f285\fnil\fcharset2\fprq2 Lucida Bright Math Symbol;}{\f286\fnil\fcharset2\fprq2 Lucida Bright Math Extension;}{\f287\fnil\fcharset2\fprq2 Lucida Bright Math Italic;}{\f288\fswiss\fcharset0\fprq2 OLBwds;}{\f289\fswiss\fcharset0\fprq2 Arial Super;} {\f290\froman\fcharset2\fprq2 MT Extra;}{\f291\froman\fcharset0\fprq2 Bookman{\*\falt Bookman Old Style};}{\f292\fswiss\fcharset0\fprq2 Akiba;}{\f293\fswiss\fcharset0\fprq2 Akiba Hollow;}{\f294\fnil\fcharset0\fprq2 Hartin2;} {\f295\fnil\fcharset0\fprq2 Black Chancery;}{\f296\fnil\fcharset0\fprq2 Aerial Bold FW;}{\f297\froman\fcharset0\fprq0 Univers (WN);}{\f298\froman\fcharset0\fprq0 CG Times (WN);}{\f299\fnil\fcharset0\fprq2 Rockwell Condensed Bold;} {\f300\froman\fcharset0\fprq0 redmond;}{\f301\froman\fcharset0\fprq0 TmsRoman;}{\f302\fmodern\fcharset0\fprq0 prestige;}{\f303\fdecor\fcharset2\fprq2 ITC Zapf Dingbats (D1);}{\f304\fdecor\fcharset2\fprq2 ITC Zapf Dingbats (D2);} {\f305\fdecor\fcharset2\fprq2 ITC Zapf Dingbats (D3);}{\f306\fdecor\fcharset2\fprq2 ITC Zapf Dingbats (DS);}{\f307\fdecor\fcharset2\fprq2 ITC Zapf Dingbats (DV);}{\f308\fmodern\fcharset0\fprq1 Courier Bold;}{\f309\fmodern\fcharset0\fprq1 Courier Italic;} {\f310\fswiss\fcharset0\fprq0 Chicago{\*\falt Arial};}{\f311\fmodern\fcharset0\fprq0 Monaco{\*\falt Courier New};}{\f312\fnil\fcharset0\fprq0 BI Letter Gothic BoldSlanted;}{\f313\fnil\fcharset0\fprq0 I Letter Gothic Slanted;} {\f314\fnil\fcharset0\fprq0 CB Helvetica Condensed Bold;}{\f315\fnil\fcharset0\fprq0 CLB Helvetica Condensed Black;}{\f316\fnil\fcharset0\fprq0 CBI Helvetica Condensed BoldObl;}{\f317\fnil\fcharset0\fprq0 CL Helvetica Condensed Light;} {\f318\fnil\fcharset0\fprq0 CLBI Helvetica Condensed BlackO;}{\f319\fnil\fcharset0\fprq0 CLI Helvetica Condensed LightOb;}{\f320\fnil\fcharset0\fprq0 B Letter Gothic Bold;}{\f321\fnil\fcharset0\fprq0 C Helvetica Condensed;} {\f322\fnil\fcharset0\fprq0 CI Helvetica Condensed Oblique;}{\f323\fnil\fcharset0\fprq0 MS San Serif;}{\f324\froman\fcharset0\fprq0 4 mode;}{\f325\froman\fcharset0\fprq0 Times Roman{\*\falt Times New Roman};}{\f326\fnil\fcharset0\fprq2 Arial MT Black;} {\f327\froman\fcharset0\fprq2 CG Times Bold;}{\f328\froman\fcharset0\fprq2 CG Times Italic;}{\f329\fnil\fcharset2\fprq2 MS Shell Dlg;}{\f330\fnil\fcharset0\fprq2 Univers Medium Condensed;}{\f331\fswiss\fcharset0\fprq2 LetterGothic;} {\f332\fnil\fcharset2\fprq2 Lucida Stars;}{\f333\fswiss\fcharset0\fprq2 CB Univers 67 CondensedBold;}{\f334\fmodern\fcharset0\fprq2 Letter Gothic MS;}{\f335\fswiss\fcharset0\fprq2 C Univers 57 Condensed;} {\f336\froman\fcharset0\fprq0 CG Times (W1){\*\falt Times New Roman};}{\f337\fswiss\fcharset0\fprq0 Univers (W1){\*\falt Arial};}{\f338\froman\fcharset0\fprq0 Hekv;}{\f339\fdecor\fcharset0\fprq0 MSIcons2;}{\f340\fmodern\fcharset0\fprq0 pica;} {\f341\fswiss\fcharset0\fprq0 HelveticaCondensed;}{\f342\froman\fcharset0\fprq0 rom the o;}{\f343\fnil\fcharset0\fprq0 Fences;}{\f344\fdecor\fcharset0\fprq0 MT Symbol{\*\falt Symbol};}{\f345\fmodern\fcharset0\fprq0 TaxType Mono;} {\f346\fnil\fcharset0\fprq0 TaxType;}{\f347\fnil\fcharset0\fprq0 TaxTypeCondensed;}{\f348\fnil\fcharset0\fprq0 TaxType Pi;}{\f349\froman\fcharset0\fprq0 th;}{\f350\fmodern\fcharset0\fprq1 Courier 12cpi;}{\f351\fmodern\fcharset0\fprq1 Courier 06cpi;} {\f352\fmodern\fcharset0\fprq1 Courier 10cpi;}{\f353\fmodern\fcharset0\fprq1 Courier 05cpi;}{\f354\fmodern\fcharset0\fprq1 Courier 15cpi;}{\f355\fmodern\fcharset0\fprq1 Courier 17cpi;}{\f356\fmodern\fcharset0\fprq1 Courier 20cpi;} {\f357\froman\fcharset0\fprq2 Courier PS;}{\f358\fmodern\fcharset0\fprq1 Gothic 05cpi;}{\f359\fmodern\fcharset0\fprq1 Gothic 06cpi;}{\f360\fmodern\fcharset0\fprq1 Gothic 10cpi;}{\f361\fmodern\fcharset0\fprq1 Gothic 12cpi;} {\f362\fmodern\fcharset0\fprq1 Gothic 15cpi;}{\f363\fmodern\fcharset0\fprq1 Gothic 17cpi;}{\f364\fmodern\fcharset0\fprq1 Gothic 20cpi;}{\f365\fswiss\fcharset0\fprq2 Gothic PS;}{\f366\fmodern\fcharset0\fprq1 Prestige 05cpi;} {\f367\fmodern\fcharset0\fprq1 Prestige 06cpi;}{\f368\fmodern\fcharset0\fprq1 Prestige 10cpi;}{\f369\fmodern\fcharset0\fprq1 Prestige 12cpi;}{\f370\fmodern\fcharset0\fprq1 Prestige 15cpi;}{\f371\fdecor\fcharset0\fprq1 Prestige 17cpi;} {\f372\fmodern\fcharset0\fprq1 Prestige 20cpi;}{\f373\froman\fcharset0\fprq2 Prestige PS;}{\f374\fdecor\fcharset0\fprq2 Billboard;}{\f375\fswiss\fcharset0\fprq2 Excalibur Logotype;}{\f376\fswiss\fcharset0\fprq2 Excalibur Monospace;} {\f377\fswiss\fcharset0\fprq2 Excalibur Script;}{\f378\fswiss\fcharset0\fprq2 Kool;}{\f379\fdecor\fcharset0\fprq2 Olde English;}{\f380\fdecor\fcharset0\fprq2 Tapestry;}{\f381\fmodern\fcharset0\fprq0 cubicPS{\*\falt Century Gothic};} {\f382\froman\fcharset0\fprq0 ^p;}{\f383\froman\fcharset0\fprq0 helf;}{\f384\froman\fcharset0\fprq0 1;}{\f385\froman\fcharset0\fprq2 Garamond Italic;}{\f386\froman\fcharset0\fprq0 timesroman{\*\falt Times New Roman};} {\f387\fscript\fcharset0\fprq0 Venice;}{\f388\fnil\fcharset0\fprq0 Zapf Dingbats{\*\falt Monotype Sorts};}{\f389\froman\fcharset0\fprq0 ITC Bookman Light;}{\f390\fdecor\fcharset0\fprq0 zapf chancery{\*\falt ZapfChancery};} {\f391\fnil\fcharset0\fprq0 Mobile;}{\f392\fnil\fcharset0\fprq0 New Century Schlbk{\*\falt Century Schoolbook};}{\f393\fnil\fcharset0\fprq0 Images;}{\f394\fnil\fcharset0\fprq0 Gray Chicago;}{\f395\fnil\fcharset0\fprq0 ITC Garamond;} {\f396\fnil\fcharset0\fprq0 MicroBoston;}{\f397\fnil\fcharset0\fprq0 MicroSoft;}{\f398\fdecor\fcharset0\fprq0 Westminster;}{\f399\froman\fcharset0\fprq0 Garamond MT{\*\falt Garamond};}{\f400\fswiss\fcharset0\fprq0 Albertus (W1);} {\f401\fswiss\fcharset0\fprq0 Albertus Xb (W1);}{\f402\fswiss\fcharset0\fprq0 Antique Olv (W1);}{\f403\fswiss\fcharset0\fprq0 CG Omega (W1);}{\f404\froman\fcharset0\fprq0 Clarendon Cd (W1);}{\f405\fscript\fcharset0\fprq0 Coronet (W1);} {\f406\fmodern\fcharset0\fprq0 Courier (W1);}{\f407\froman\fcharset0\fprq0 Garmond (W1);}{\f408\fmodern\fcharset0\fprq0 Letter Gothic (W1);}{\f409\fscript\fcharset0\fprq0 Marigold (W1);}{\f410\fswiss\fcharset0\fprq0 Univers Cd (W1);} {\f411\froman\fcharset0\fprq0 Engravers Bold;}{\f412\fnil\fcharset0\fprq0 ITC Garamond\'a8;}{\f413\froman\fcharset0\fprq0 (normal text);}{\f414\fmodern\fcharset0\fprq0 avantegarde;}{\f415\froman\fcharset0\fprq0 century;} {\f416\fswiss\fcharset0\fprq2 Helv (AS);}{\f417\fmodern\fcharset0\fprq1 Courier 10 Pitch;}{\f418\fmodern\fcharset0\fprq1 Courier 20 Pitch;}{\f419\fmodern\fcharset0\fprq1 Courier 5 Pitch;}{\f420\fmodern\fcharset0\fprq1 Letter Gothic 12 Pitch;} {\f421\fmodern\fcharset0\fprq1 Letter Gothic 24 Pitch;}{\f422\fmodern\fcharset0\fprq1 Letter Gothic 6 Pitch;}{\f423\fmodern\fcharset0\fprq1 Courier 16.67 Pitch;}{\f424\fnil\fcharset2\fprq2 Hyena;}{\f425\fdecor\fcharset0\fprq2 McZee;} {\f426\froman\fcharset0\fprq0 m;}{\f427\froman\fcharset0\fprq2 Bookman Old Style Bold;}{\f428\fscript\fcharset0\fprq2 Calgary;}{\f429\fnil\fcharset0\fprq2 Sputopia;}{\f430\froman\fcharset0\fprq0 MA Sans Serif;} {\f431\fmodern\fcharset255\fprq1 Courier New (OEM);}{\f432\froman\fcharset0\fprq2 Galliard;}{\f433\fmodern\fcharset0\fprq1 Radius;}{\f434\froman\fcharset128\fprq1 \'82l\'82r \'96\'be\'92\'a9{\*\falt Wingdings};}{\f435\froman\fcharset0\fprq0 ?;} {\f436\fmodern\fcharset0\fprq1 LettrGoth12 BT;}{\f437\froman\fcharset128\fprq1 l\'82r \'96\'be\'92\'a9{\*\falt Wingdings};}{\f438\froman\fcharset222\fprq2 CordiaUPC;}{\f439\fmodern\fcharset0\fprq0 elite;}{\f440\fnil\fcharset2\fprq2 Microsoft Logo 95;} {\f441\fswiss\fcharset0\fprq2 Aardvark;}{\f442\fswiss\fcharset0\fprq2 Adelaide;}{\f443\fswiss\fcharset2\fprq2 Alefbet;}{\f444\fswiss\fcharset0\fprq2 Algiers;}{\f445\fswiss\fcharset0\fprq2 Alto;}{\f446\fswiss\fcharset0\fprq2 Amherst;} {\f447\fswiss\fcharset0\fprq2 Amy;}{\f448\fswiss\fcharset0\fprq2 ProseAntique;}{\f449\fswiss\fcharset0\fprq2 Arabia;}{\f450\fswiss\fcharset0\fprq2 Architecture;}{\f451\fswiss\fcharset0\fprq2 Avalon;}{\f452\fswiss\fcharset0\fprq2 BahamasHeavy;} {\f453\fswiss\fcharset0\fprq2 BahamasLight;}{\f454\fswiss\fcharset0\fprq2 Bahamas;}{\f455\fswiss\fcharset0\fprq2 BallroomTango;}{\f456\fswiss\fcharset0\fprq2 Banff;}{\f457\fswiss\fcharset0\fprq2 Bangkok;}{\f458\fswiss\fcharset0\fprq2 Bard;} {\f459\fswiss\fcharset0\fprq2 Bassoon;}{\f460\fswiss\fcharset0\fprq2 Bedrock;}{\f461\fnil\fcharset0\fprq2 Beehive;}{\f462\fswiss\fcharset0\fprq2 BigTop;}{\f463\fswiss\fcharset0\fprq2 Bodnoff;}{\f464\fswiss\fcharset0\fprq2 Bosanova;} {\f465\fswiss\fcharset0\fprq2 BravoEngraved;}{\f466\fswiss\fcharset0\fprq2 Bravo;}{\f467\fswiss\fcharset0\fprq2 Briquet;}{\f468\fswiss\fcharset0\fprq2 Brisk;}{\f469\fswiss\fcharset0\fprq2 Brochure;}{\f470\fswiss\fcharset0\fprq2 Brooklyn;} {\f471\fswiss\fcharset0\fprq2 NewBrunswick;}{\f472\fswiss\fcharset0\fprq2 Busker;}{\f473\fswiss\fcharset0\fprq2 Campaign;}{\f474\fswiss\fcharset0\fprq2 Cancun;}{\f475\fnil\fcharset0\fprq2 Carino;}{\f476\fswiss\fcharset0\fprq2 Carleton;} {\f477\fswiss\fcharset0\fprq2 CasablancaAntique;}{\f478\fswiss\fcharset0\fprq2 Casablanca;}{\f479\fswiss\fcharset0\fprq2 CasperOpenFace;}{\f480\fswiss\fcharset0\fprq2 Castanet;}{\f481\fswiss\fcharset0\fprq2 DawnCastle;} {\f482\fswiss\fcharset0\fprq2 CenturionOld;}{\f483\fswiss\fcharset0\fprq2 Chalk;}{\f484\fswiss\fcharset0\fprq2 Charlesworth;}{\f485\fswiss\fcharset2\fprq2 CommonBullets;}{\f486\fswiss\fcharset0\fprq2 CopperPot;}{\f487\fswiss\fcharset0\fprq2 CosmicTwo;} {\f488\fswiss\fcharset0\fprq2 Cosmic;}{\f489\fswiss\fcharset0\fprq2 Cottage;}{\f490\fswiss\fcharset0\fprq2 Crescent;}{\f491\fswiss\fcharset0\fprq2 Cupertino;}{\f492\fswiss\fcharset0\fprq2 Czar;}{\f493\fswiss\fcharset0\fprq2 Dauphin;} {\f494\fswiss\fcharset2\fprq2 Dixieland;}{\f495\fswiss\fcharset0\fprq2 Eklektic;}{\f496\fswiss\fcharset0\fprq2 Envision;}{\f497\fswiss\fcharset0\fprq2 ErieContour;}{\f498\fswiss\fcharset0\fprq2 Erie;}{\f499\fswiss\fcharset0\fprq2 ErieBlack;} {\f500\fswiss\fcharset0\fprq2 ErieLight;}{\f501\fswiss\fcharset0\fprq2 Euromode;}{\f502\fswiss\fcharset0\fprq2 Expo;}{\f503\fswiss\fcharset0\fprq2 Florence;}{\f504\fswiss\fcharset0\fprq2 France;}{\f505\fswiss\fcharset0\fprq2 FrankfurtGothicHeavy;} {\f506\fswiss\fcharset0\fprq2 FrankfurtGothic;}{\f507\fswiss\fcharset0\fprq2 FrankHighlight;}{\f508\fswiss\fcharset0\fprq2 Freeport;}{\f509\fswiss\fcharset0\fprq2 Frankenstein;}{\f510\fswiss\fcharset0\fprq2 Fujiyama2;} {\f511\fnil\fcharset0\fprq2 Fujiyama;}{\f512\fswiss\fcharset0\fprq2 FujiyamaBlack;}{\f513\fswiss\fcharset0\fprq2 FujiyamaExtraBold;}{\f514\fswiss\fcharset0\fprq2 FujiyamaLight;}{\f515\fswiss\fcharset0\fprq2 Galleria;} {\f516\fswiss\fcharset0\fprq2 Gatineau;}{\f517\fswiss\fcharset2\fprq2 GeographicSymbols;}{\f518\fswiss\fcharset0\fprq2 GilbertUltraBold;}{\f519\fswiss\fcharset0\fprq2 Glacier;}{\f520\fswiss\fcharset0\fprq2 GoldenOldStyle;} {\f521\fswiss\fcharset0\fprq2 GoldMine;}{\f522\fswiss\fcharset0\fprq2 GriffonShadow;}{\f523\fnil\fcharset0\fprq2 Griffon;}{\f524\fswiss\fcharset0\fprq2 Harpoon;}{\f525\fswiss\fcharset0\fprq2 Heidelberg;}{\f526\fswiss\fcharset0\fprq2 Hollow;} {\f527\fswiss\fcharset0\fprq2 HomewardBound;}{\f528\fswiss\fcharset0\fprq2 Indiana;}{\f529\fswiss\fcharset0\fprq2 IndianaSolid;}{\f530\fswiss\fcharset0\fprq2 Ireland;}{\f531\fswiss\fcharset0\fprq2 Jupiter;}{\f532\fswiss\fcharset0\fprq2 KabanaBold;} {\f533\fswiss\fcharset0\fprq2 KabanaBook;}{\f534\fswiss\fcharset0\fprq2 Kastler;}{\f535\fswiss\fcharset0\fprq2 Keypunch;}{\f536\fswiss\fcharset2\fprq2 Keystroke;}{\f537\fswiss\fcharset0\fprq2 Kids;}{\f538\fswiss\fcharset0\fprq2 Koala;} {\f539\fswiss\fcharset0\fprq2 Korinthia;}{\f540\fswiss\fcharset0\fprq2 Lincoln;}{\f541\fswiss\fcharset0\fprq2 Linus;}{\f542\fswiss\fcharset0\fprq2 LiquidCrystal;}{\f543\fswiss\fcharset0\fprq2 Lithograph;}{\f544\fswiss\fcharset0\fprq2 LithographLight;} {\f545\fswiss\fcharset0\fprq2 Memorandum;}{\f546\fswiss\fcharset0\fprq2 Merlin;}{\f547\fswiss\fcharset0\fprq2 Monospaced;}{\f548\fswiss\fcharset0\fprq2 Motor;}{\f549\fswiss\fcharset2\fprq2 MusicalSymbols;}{\f550\fswiss\fcharset0\fprq2 Mystical;} {\f551\fswiss\fcharset0\fprq2 Nebraska;}{\f552\fswiss\fcharset0\fprq2 NewOrder;}{\f553\fnil\fcharset0\fprq2 NewOrderEngraved;}{\f554\fswiss\fcharset0\fprq2 Nuance;}{\f555\fswiss\fcharset0\fprq2 Newfoundland;}{\f556\fswiss\fcharset0\fprq2 Ottawa;} {\f557\fswiss\fcharset0\fprq2 Palette;}{\f558\fswiss\fcharset0\fprq2 PalmSprings;}{\f559\fswiss\fcharset0\fprq2 Paradise;}{\f560\fswiss\fcharset0\fprq2 Paragon;}{\f561\fswiss\fcharset0\fprq2 PenguinLight;}{\f562\fswiss\fcharset0\fprq2 Penguin;} {\f563\fswiss\fcharset0\fprq2 Pepper;}{\f564\fswiss\fcharset0\fprq2 Pipeline;}{\f565\fswiss\fcharset0\fprq2 Playwright;}{\f566\fswiss\fcharset0\fprq2 Posse;}{\f567\fswiss\fcharset0\fprq2 PowerLine;}{\f568\fswiss\fcharset0\fprq2 President;} {\f569\fswiss\fcharset0\fprq2 Quantum;}{\f570\fswiss\fcharset0\fprq2 Renfrew;}{\f571\fswiss\fcharset0\fprq2 Scott;}{\f572\fswiss\fcharset0\fprq2 Scribe;}{\f573\fswiss\fcharset0\fprq2 Shogun;}{\f574\fswiss\fcharset0\fprq2 Southern;} {\f575\fswiss\fcharset0\fprq2 Stamp;}{\f576\fswiss\fcharset0\fprq2 Surreal;}{\f577\fswiss\fcharset0\fprq2 Switzerland;}{\f578\fswiss\fcharset0\fprq2 SwitzerlandBlack;}{\f579\fswiss\fcharset0\fprq2 SwitzerlandCondBlack;} {\f580\fnil\fcharset0\fprq2 SwitzerlandCondensed;}{\f581\fswiss\fcharset0\fprq2 SwitzerlandCondLight;}{\f582\fswiss\fcharset0\fprq2 SwitzerlandInserat;}{\f583\fswiss\fcharset0\fprq2 SwitzerlandLight;}{\f584\fswiss\fcharset0\fprq2 SwitzerlandNarrow;} {\f585\fswiss\fcharset2\fprq2 GreekMathSymbols;}{\f586\fswiss\fcharset0\fprq2 Technical;}{\f587\fswiss\fcharset0\fprq2 ThunderBay;}{\f588\fnil\fcharset0\fprq2 Timpani;}{\f589\fswiss\fcharset0\fprq2 TimpaniHeavy;}{\f590\fswiss\fcharset0\fprq2 Toronto;} {\f591\fswiss\fcharset0\fprq2 Trafalgar;}{\f592\fswiss\fcharset0\fprq2 Umbrella;}{\f593\fswiss\fcharset0\fprq2 Unicorn;}{\f594\fswiss\fcharset0\fprq2 Uptown;}{\f595\fswiss\fcharset0\fprq2 USABlack;}{\f596\fswiss\fcharset0\fprq2 USALight;} {\f597\fswiss\fcharset0\fprq2 Viking;}{\f598\fswiss\fcharset0\fprq2 Vivienne;}{\f599\fswiss\fcharset0\fprq2 Vogue;}{\f600\fswiss\fcharset0\fprq2 ZurichCalligraphic;}{\f601\froman\fcharset0\fprq2 AGaramond;}{\f602\froman\fcharset0\fprq2 AGaramond Bold;} {\f603\froman\fcharset0\fprq2 Partition OldStyle SSi;}{\f604\froman\fcharset0\fprq2 Partition SSi;}{\f605\fnil\fcharset0\fprq2 Palisade;}{\f606\froman\fcharset0\fprq0 Keycaps;}{\f607\froman\fcharset0\fprq0 ballmer;} {\f608\fdecor\fcharset0\fprq2 SmileyfaceFont;}{\f609\fnil\fcharset0\fprq2 Gallaudet;}{\f610\fnil\fcharset136\fprq2 \'b7s\'b2\'d3\'a9\'fa\'c5\'e9;}{\f611\fmodern\fcharset136\fprq1 \'b2\'d3\'a9\'fa\'c5\'e9;} {\f612\fmodern\fcharset136\fprq1 \'82l\'82r \'83S\'83V\'83b\'83N;}{\f613\fnil\fcharset136\fprq2 @\'b7s\'b2\'d3\'a9\'fa\'c5\'e9;}{\f614\fmodern\fcharset136\fprq1 @\'b2\'d3\'a9\'fa\'c5\'e9;}{\f615\fmodern\fcharset136\fprq1 @\'82l\'82r \'83S\'83V\'83b\'83N;} {\f616\fnil\fcharset0\fprq2 !Ps2OcuAe;}{\f617\fmodern\fcharset0\fprq1 2OcuAe;}{\f618\fmodern\fcharset0\fprq1 @2OcuAe;}{\f619\fnil\fcharset0\fprq2 @!Ps2OcuAe;}{\f620\fmodern\fcharset136\fprq1 \'bc\'d0\'b7\'a2\'c5\'e9;} {\f621\fmodern\fcharset136\fprq1 @\'bc\'d0\'b7\'a2\'c5\'e9;}{\f622\fmodern\fcharset0\fprq1 ?D!P\'a2FFAe;}{\f623\fmodern\fcharset0\fprq1 @?D!P\'a2FFAe;} {\f624\fmodern\fcharset136\fprq1 \'b5\'d8\'b1d\'a4\'a4\'b7\'a2\'c5\'e9{\*\falt \'b2\'d3\'a9\'fa\'c5\'e9};}{\f625\fmodern\fcharset136\fprq1 @\'b5\'d8\'b1d\'a4\'a4\'b7\'a2\'c5\'e9;} {\f626\fmodern\fcharset136\fprq1 \'b5\'d8\'b1d\'b7\'a2\'ae\'d1\'c5\'e9W3{\*\falt \'b2\'d3\'a9\'fa\'c5\'e9};}{\f627\fmodern\fcharset136\fprq1 @\'b5\'d8\'b1d\'b7\'a2\'ae\'d1\'c5\'e9W3;}{\f628\fnil\fcharset0\fprq2 \'a1Ps2OcuAe;} {\f629\fnil\fcharset0\fprq2 @\'a1Ps2OcuAe;}{\f630\fmodern\fcharset0\fprq1 ?D\'a1P\'a2FAe;}{\f631\fmodern\fcharset0\fprq1 @?D\'a1P\'a2FAe;}{\f632\fswiss\fcharset0\fprq0 Arial-Narrow;}{\f633\fnil\fcharset2\fprq2 Infestia;} {\f634\fnil\fcharset2\fprq2 insectile;}{\f635\fnil\fcharset2\fprq2 InsectileSolid;}{\f636\fnil\fcharset0\fprq2 Metalcut;}{\f637\fnil\fcharset0\fprq2 FranklinGotTDemCon;}{\f638\fnil\fcharset0\fprq2 FranklinGotTBoo;}{\f639\fswiss\fcharset0\fprq2 Borg-9;} {\f640\fnil\fcharset0\fprq2 ChickenScratch;}{\f641\fnil\fcharset0\fprq2 Crop\'a9Bats;}{\f642\fnil\fcharset0\fprq2 CType;}{\f643\fnil\fcharset0\fprq2 DeadGrit;}{\f644\fnil\fcharset0\fprq2 Electric Hermes;}{\f645\fnil\fcharset0\fprq2 Kinderfeld;} {\f646\fnil\fcharset0\fprq2 Lochen;}{\f647\fnil\fcharset0\fprq2 Minya;}{\f648\fnil\fcharset0\fprq2 Prick;}{\f649\fswiss\fcharset0\fprq2 Quinquefoliolate;}{\f650\fnil\fcharset0\fprq2 Schizm;}{\f651\fnil\fcharset0\fprq2 Schrill;} {\f652\fnil\fcharset0\fprq2 Scrawn;}{\f653\fnil\fcharset0\fprq2 OBodoni-Open;}{\f654\fnil\fcharset0\fprq2 OCopperplate-Heavy;}{\f655\fnil\fcharset0\fprq2 OCopperplate-Plain;}{\f656\fnil\fcharset0\fprq2 OPCIVET-Light;} {\f657\fnil\fcharset0\fprq2 OPDelphin-TWO;}{\f658\fnil\fcharset0\fprq2 SI-Heavyweight;}{\f659\fnil\fcharset0\fprq2 SI-Middleweight;}{\f660\fswiss\fcharset0\fprq2 Humnst777 BT;}{\f661\fswiss\fcharset0\fprq2 Humnst777 Cn BT;} {\f662\fmodern\fcharset128\fprq0 \'82l\'82r \'82o\'83S\'83V\'83b\'83N;}{\f663\froman\fcharset0\fprq0 CG Times (E1);}{\f664\froman\fcharset162\fprq2 Aldine721 BT Tur{\*\falt Bookman Old Style};} {\f665\fswiss\fcharset162\fprq2 Futura Md BT Tur{\*\falt Tahoma};}{\f666\fscript\fcharset162\fprq2 BrushScript BT Tur{\*\falt Bookman Old Style};}{\f667\froman\fcharset162\fprq2 ClassGarmnd BT Tur{\*\falt Bookman Old Style};} {\f668\fdecor\fcharset162\fprq2 UnivrstyRoman Bd BT Tur{\*\falt Bookman Old Style};}{\f669\froman\fcharset162\fprq2 Windsor LtCn BT Tur{\*\falt Bookman Old Style};}{\f670\froman\fcharset162\fprq2 Cooper Md BT Tur{\*\falt Bookman Old Style};} {\f671\fscript\fcharset162\fprq2 DomCasual BT Tur{\*\falt Bookman Old Style};}{\f672\froman\fcharset162\fprq2 ElegaGarmnd BT Tur{\*\falt Bookman Old Style};}{\f673\fscript\fcharset162\fprq2 Kaufmann Bd BT Tur{\*\falt Bookman Old Style};} {\f674\fswiss\fcharset162\fprq2 VAGRounded BT Tur{\*\falt Tahoma};}{\f675\fscript\fcharset162\fprq2 English157 BT Tur{\*\falt Bookman Old Style};}{\f676\fscript\fcharset162\fprq2 MurrayHill Bd BT Tur{\*\falt Bookman Old Style};} {\f677\fscript\fcharset162\fprq2 Cataneo BT Tur{\*\falt Bookman Old Style};}{\f678\fscript\fcharset162\fprq2 Amazone BT Tur{\*\falt Bookman Old Style};}{\f679\fscript\fcharset162\fprq2 Freehand591 BT Tur{\*\falt Bookman Old Style};} {\f680\fscript\fcharset162\fprq2 Freehand575 BT Tur{\*\falt Bookman Old Style};}{\f681\froman\fcharset162\fprq2 DellaRobbia BT Tur{\*\falt Bookman Old Style};}{\f682\fscript\fcharset162\fprq2 Formal436 BT Tur{\*\falt Bookman Old Style};} {\f683\fdecor\fcharset162\fprq2 Tango BT Tur{\*\falt Bookman Old Style};}{\f684\fdecor\fcharset162\fprq2 OldDreadfulNo7 BT Tur{\*\falt Bookman Old Style};}{\f685\froman\fcharset128\fprq1 \'96\'be\'92\'a9;}{\f686\fswiss\fcharset0\fprq2 Gill Sans;} {\f687\froman\fcharset0\fprq2 Ort Israel Classic;}{\f688\fswiss\fcharset0\fprq2 Web Hebrew AD;}{\f689\fmodern\fcharset0\fprq1 Web Hebrew Monospace;}{\f690\fmodern\fcharset128\fprq2 MS P????;}{\f691\fswiss\fcharset0\fprq0  ;} {\f692\fswiss\fcharset0\fprq2 Morningstar 1;}{\f693\fnil\fcharset2\fprq2 WP TypographicSymbols;}{\f694\fmodern\fcharset128\fprq0 gothicPS;}{\f695\fmodern\fcharset128\fprq0 spartan;}{\f696\fmodern\fcharset128\fprq0 metro;} {\f697\fmodern\fcharset128\fprq0 presentation;}{\f698\fmodern\fcharset128\fprq0 APL;}{\f699\fmodern\fcharset128\fprq0 OCRA;}{\f700\froman\fcharset128\fprq0 emperorPS;}{\f701\froman\fcharset128\fprq0 madaleine;} {\f702\froman\fcharset128\fprq0 zapf humanist;}{\f703\froman\fcharset128\fprq0 classic;}{\f704\froman\fcharset128\fprq0 roman f;}{\f705\froman\fcharset128\fprq0 roman g;}{\f706\froman\fcharset128\fprq0 roman h;}{\f707\froman\fcharset128\fprq0 palantino;} {\f708\froman\fcharset128\fprq0 souvenir;}{\f709\froman\fcharset128\fprq0 caledonia;}{\f710\froman\fcharset128\fprq0 bodini;}{\f711\fnil\fcharset0\fprq2 University;}{\f712\fscript\fcharset128\fprq0 scriptPS;}{\f713\fscript\fcharset128\fprq0 script c;} {\f714\fscript\fcharset128\fprq0 script d;}{\f715\fscript\fcharset128\fprq0 commercial script;}{\f716\fnil\fcharset0\fprq2 Park Avenue;}{\f717\fscript\fcharset128\fprq0 script h;}{\f718\froman\fcharset128\fprq0 greek;} {\f719\froman\fcharset128\fprq0 kana;}{\f720\froman\fcharset128\fprq0 hebrew;}{\f721\froman\fcharset128\fprq0 roman s;}{\f722\froman\fcharset128\fprq0 russian;}{\f723\froman\fcharset128\fprq0 roman u;}{\f724\froman\fcharset128\fprq0 roman v;} {\f725\froman\fcharset128\fprq0 roman w;}{\f726\fdecor\fcharset128\fprq0 narrator;}{\f727\fdecor\fcharset128\fprq0 emphasis;}{\f728\fdecor\fcharset128\fprq0 decor d;}{\f729\fdecor\fcharset128\fprq0 old english;}{\f730\fdecor\fcharset128\fprq0 decor f;} {\f731\fdecor\fcharset128\fprq0 decor g;}{\f732\fnil\fcharset128\fprq0 linedraw;}{\f733\fnil\fcharset128\fprq0 math7;}{\f734\fnil\fcharset128\fprq0 math8;}{\f735\fnil\fcharset128\fprq0 bar3of9;}{\f736\fnil\fcharset128\fprq0 EAN;} {\f737\fnil\fcharset128\fprq0 pcline;}{\f738\fnil\fcharset128\fprq0 tech h;}{\f739\fdecor\fcharset0\fprq2 ITC Zapf Dingbats;}{\f740\froman\fcharset0\fprq2 Trixie-Plain;}{\f741\fmodern\fcharset0\fprq1 MsMail3;} {\f742\fmodern\fcharset129\fprq2 \'b1\'bc\'b8\'b2;}{\f743\fnil\fcharset0\fprq2 Flange-Light;}{\f744\fnil\fcharset136\fprq2 s\'b2\'d3\'a9\'fa\'c5\'e9;}{\f745\fnil\fcharset0\fprq2 FranklinGothhvy;} {\f746\fswiss\fcharset222\fprq2 Cordia New{\*\falt Times New Roman};}{\f747\fswiss\fcharset0\fprq2 Tw Cen MT Condensed;}{\f748\fnil\fcharset77\fprq2 AdobeCorpID MinionRg;}{\f749\fswiss\fcharset238\fprq2 Franklin Gothic Book CE{\*\falt Tahoma};} {\f750\fswiss\fcharset204\fprq2 Franklin Gothic Book Cyr{\*\falt Tahoma};}{\f751\fswiss\fcharset161\fprq2 Franklin Gothic Book Greek{\*\falt Tahoma};}{\f752\fswiss\fcharset162\fprq2 Franklin Gothic Book Tur{\*\falt Tahoma};} {\f753\fswiss\fcharset186\fprq2 Franklin Gothic Book Baltic{\*\falt Tahoma};}{\f754\fswiss\fcharset238\fprq2 Franklin Gothic Demi CE{\*\falt Times};}{\f755\fswiss\fcharset204\fprq2 Franklin Gothic Demi Cyr{\*\falt Times};} {\f756\fswiss\fcharset161\fprq2 Franklin Gothic Demi Greek{\*\falt Times};}{\f757\fswiss\fcharset162\fprq2 Franklin Gothic Demi Tur{\*\falt Times};}{\f758\fswiss\fcharset186\fprq2 Franklin Gothic Demi Baltic{\*\falt Times};} {\f759\froman\fcharset238\fprq2 Map Symbols CE{\*\falt Bookman Old Style};}{\f760\froman\fcharset161\fprq2 Map Symbols Greek{\*\falt Bookman Old Style};}{\f761\froman\fcharset162\fprq2 Map Symbols Tur{\*\falt Bookman Old Style};} {\f762\froman\fcharset186\fprq2 Map Symbols Baltic{\*\falt Bookman Old Style};}{\f763\fswiss\fcharset238\fprq2 Franklin Gothic Demi Cond CE{\*\falt Tahoma};}{\f764\fswiss\fcharset204\fprq2 Franklin Gothic Demi Cond Cyr{\*\falt Tahoma};} {\f765\fswiss\fcharset161\fprq2 Franklin Gothic Demi Cond Greek{\*\falt Tahoma};}{\f766\fswiss\fcharset162\fprq2 Franklin Gothic Demi Cond Tur{\*\falt Tahoma};}{\f767\fswiss\fcharset186\fprq2 Franklin Gothic Demi Cond Balti{\*\falt Tahoma};} {\f768\fswiss\fcharset238\fprq2 Franklin Gothic Heavy CE{\*\falt Tahoma};}{\f769\fswiss\fcharset204\fprq2 Franklin Gothic Heavy Cyr{\*\falt Tahoma};}{\f770\fswiss\fcharset161\fprq2 Franklin Gothic Heavy Greek{\*\falt Tahoma};} {\f771\fswiss\fcharset162\fprq2 Franklin Gothic Heavy Tur{\*\falt Tahoma};}{\f772\fswiss\fcharset186\fprq2 Franklin Gothic Heavy Baltic{\*\falt Tahoma};}{\f773\fswiss\fcharset238\fprq2 Franklin Gothic Medium CE{\*\falt Tahoma};} {\f774\fswiss\fcharset204\fprq2 Franklin Gothic Medium Cyr{\*\falt Tahoma};}{\f775\fswiss\fcharset161\fprq2 Franklin Gothic Medium Greek{\*\falt Tahoma};}{\f776\fswiss\fcharset162\fprq2 Franklin Gothic Medium Tur{\*\falt Tahoma};} {\f777\fswiss\fcharset186\fprq2 Franklin Gothic Medium Baltic{\*\falt Tahoma};}{\f778\fswiss\fcharset238\fprq2 Franklin Gothic Medium Cond CE{\*\falt Tahoma};}{\f779\fswiss\fcharset204\fprq2 Franklin Gothic Medium Cond Cyr{\*\falt Tahoma};} {\f780\fswiss\fcharset161\fprq2 Franklin Gothic Medium Cond Gre{\*\falt Tahoma};}{\f781\fswiss\fcharset162\fprq2 Franklin Gothic Medium Cond Tur{\*\falt Tahoma};}{\f782\fswiss\fcharset186\fprq2 Franklin Gothic Medium Cond Bal{\*\falt Tahoma};} {\f783\froman\fcharset0\fprq2 HM Phonetic;}{\f784\froman\fcharset136\fprq0 \'a9\'fa\'c5\'e9;}{\f785\froman\fcharset136\fprq0 \'fa\'c5\'e9;}{\f786\fnil\fcharset134\fprq2 \'cb\'ce\'cc\'e5;}{\f787\froman\fcharset0\fprq2 Palatino Black;} {\f788\froman\fcharset0\fprq2 Palatino Light;}{\f789\fswiss\fcharset0\fprq2 GillSans Light;}{\f790\fswiss\fcharset0\fprq2 GillSans;}{\f791\froman\fcharset0\fprq0 MicrosoftLogo95;} {\f792\fmodern\fcharset136\fprq1 d\'b7\'a2\'ae\'d1\'c5\'e9W3{\*\falt \'b2\'d3\'a9\'fa\'c5\'e9};}{\f793\fmodern\fcharset136\fprq1 \'d8\'b1d\'b7\'a2\'ae\'d1\'c5\'e9W3{\*\falt \'b2\'d3\'a9\'fa\'c5\'e9};}{\f794\froman\fcharset128\fprq1 \'92\'a9;} {\f795\froman\fcharset0\fprq2 TimesNewRomanPS;}{\f796\froman\fcharset0\fprq2 Book Antiqua Alt;}{\f797\fswiss\fcharset0\fprq2 News Gothic Condensed DK;}{\f798\fscript\fcharset0\fprq2 Benguiat Frisky ATT;}{\f799\froman\fcharset0\fprq2 Poster Bodoni ATT;} {\f800\fswiss\fcharset0\fprq2 Gill Sans MT Shadow;}{\f801\froman\fcharset0\fprq2 Goudy Old Style ATT;}{\f802\fscript\fcharset0\fprq2 Graphite Light ATT;}{\f803\fscript\fcharset0\fprq2 Graphite Light Narrow ATT;} {\f804\fscript\fcharset0\fprq2 Lucida Casual;}{\f805\fnil\fcharset2\fprq2 Milestones;}{\f806\fscript\fcharset0\fprq2 Phyllis ATT;}{\f807\fscript\fcharset0\fprq2 Signet Roundhand ATT;}{\f808\fnil\fcharset2\fprq2 AstGlyphs;} {\f809\fswiss\fcharset0\fprq2 AHD Symbol Sans;}{\f810\froman\fcharset0\fprq2 AHD Symbol;}{\f811\froman\fcharset0\fprq2 Times New Roman MT Extra Bold;}{\f812\fmodern\fcharset0\fprq1 Letter Gothic MT;}{\f813\fswiss\fcharset0\fprq2 Frame5 Font;} {\f814\froman\fcharset0\fprq0 MS Sans Seric;}{\f815\froman\fcharset0\fprq2 Sabon;}{\f816\fswiss\fcharset0\fprq2 GillSans Condensed;}{\f817\fswiss\fcharset0\fprq2 GillSans ExtraBold;}{\f818\fswiss\fcharset0\fprq2 GillSans UltraBold;} {\f819\fswiss\fcharset0\fprq2 GillSans UltraBoldCondensed;}{\f820\fnil\fcharset0\fprq2 Grinder;}{\f821\fnil\fcharset0\fprq2 AdLib;}{\f822\fnil\fcharset0\fprq2 AmericanUncial;}{\f823\fnil\fcharset0\fprq2 ArnoldBoecklin;} {\f824\fnil\fcharset0\fprq2 Baskerville;}{\f825\fnil\fcharset2\fprq2 BaskervilleExpert;}{\f826\froman\fcharset0\fprq2 Bergamo;}{\f827\fnil\fcharset2\fprq2 BergamoExpert;}{\f828\fnil\fcharset0\fprq2 BergamoSmCaps;} {\f829\fnil\fcharset0\fprq2 BerlinerGrotesk;}{\f830\fnil\fcharset0\fprq2 Binner;}{\f831\fnil\fcharset0\fprq2 Bodoni;}{\f832\fnil\fcharset2\fprq2 BodoniExpert;}{\f833\fnil\fcharset0\fprq2 BodoniH;}{\f834\fnil\fcharset0\fprq2 BodoniSmCaps;} {\f835\fnil\fcharset0\fprq2 Caslon;}{\f836\fdecor\fcharset0\fprq2 CaslonAntique;}{\f837\fnil\fcharset2\fprq2 CaslonExpert;}{\f838\fdecor\fcharset0\fprq2 Celt;}{\f839\fnil\fcharset0\fprq2 Chantilly;}{\f840\fnil\fcharset0\fprq2 ChantillyLH;} {\f841\fnil\fcharset0\fprq2 ChantillyUB;}{\f842\fdecor\fcharset0\fprq2 Chromatic;}{\f843\fnil\fcharset0\fprq2 Clarendon;}{\f844\fnil\fcharset0\fprq2 ClarendonLH;}{\f845\fnil\fcharset0\fprq2 CommercialScript;}{\f846\fnil\fcharset0\fprq2 CopperplateGothic;} {\f847\fnil\fcharset0\fprq2 CopperplateGothicCondensed;}{\f848\fnil\fcharset0\fprq2 Davida;}{\f849\fdecor\fcharset0\fprq2 DeannaBorders;}{\f850\fdecor\fcharset0\fprq2 DeannaFlowers;}{\f851\fscript\fcharset0\fprq2 DeannaScript;} {\f852\fscript\fcharset0\fprq2 DeannaSwash;}{\f853\fdecor\fcharset0\fprq2 DelphianOpenTitling;}{\f854\fnil\fcharset0\fprq2 FetteFraktur;}{\f855\fnil\fcharset0\fprq2 FetteGotisch;}{\f856\fswiss\fcharset0\fprq2 FranklinGothic;} {\f857\fswiss\fcharset0\fprq2 FranklinGothicCond;}{\f858\fswiss\fcharset0\fprq2 FranklinGothicCondSmCaps;}{\f859\fswiss\fcharset0\fprq2 FranklinGothicH;}{\f860\fnil\fcharset0\fprq2 Function;}{\f861\fnil\fcharset0\fprq2 FunctionCond;} {\f862\fnil\fcharset0\fprq2 FunctionCondLH;}{\f863\fnil\fcharset0\fprq2 FunctionDisplay;}{\f864\fnil\fcharset0\fprq2 FunctionLH;}{\f865\fnil\fcharset0\fprq2 FunctionLHSmCaps;}{\f866\fnil\fcharset0\fprq2 FunctionSmCaps;}{\f867\fnil\fcharset0\fprq2 Gareth;} {\f868\fnil\fcharset0\fprq2 GilliesGothic;}{\f869\froman\fcharset0\fprq2 GlaserStencil;}{\f870\fnil\fcharset0\fprq2 Glytus;}{\f871\fnil\fcharset0\fprq2 GlytusLH;}{\f872\fnil\fcharset0\fprq2 GoudyHandtooled;}{\f873\fnil\fcharset0\fprq2 GoudySans;} {\f874\fnil\fcharset0\fprq2 HandelGothic;}{\f875\fnil\fcharset0\fprq2 Hobo;}{\f876\fnil\fcharset0\fprq2 Honeymoon;}{\f877\fnil\fcharset0\fprq2 Horndon;}{\f878\fnil\fcharset0\fprq2 Hudson;}{\f879\fnil\fcharset0\fprq2 Legend;} {\f880\fnil\fcharset0\fprq1 LetterGothicEB;}{\f881\fnil\fcharset0\fprq2 Mercedes;}{\f882\fnil\fcharset0\fprq2 Modern216;}{\f883\fnil\fcharset0\fprq2 MonaLisa;}{\f884\fnil\fcharset0\fprq2 NewBaskerville;}{\f885\fnil\fcharset0\fprq2 OldeEnglish;} {\f886\fnil\fcharset0\fprq2 Opus;}{\f887\fnil\fcharset0\fprq2 OpusSmCaps;}{\f888\fnil\fcharset0\fprq2 ParkAvenue;}{\f889\fnil\fcharset0\fprq2 Phyllis;}{\f890\fnil\fcharset0\fprq2 PhyllisSwash;}{\f891\fdecor\fcharset0\fprq2 Picto;} {\f892\fnil\fcharset0\fprq2 Plakette;}{\f893\fdecor\fcharset0\fprq2 Reflex;}{\f894\fnil\fcharset0\fprq2 Rosslaire;}{\f895\fnil\fcharset0\fprq2 Salut;}{\f896\fnil\fcharset0\fprq2 Savoy;}{\f897\fnil\fcharset2\fprq2 SavoyExpert;} {\f898\fnil\fcharset0\fprq2 SavoySmCaps;}{\f899\fdecor\fcharset0\fprq2 SeanSymbols;}{\f900\fnil\fcharset0\fprq2 Syntax;}{\f901\fnil\fcharset0\fprq2 SyntaxH;}{\f902\froman\fcharset0\fprq2 Toxica;}{\f903\fnil\fcharset0\fprq2 Typewriter;} {\f904\fnil\fcharset0\fprq2 TypewriterCondensed;}{\f905\fnil\fcharset0\fprq2 URWAntiqua;}{\f906\fnil\fcharset0\fprq2 URWPalladio;}{\f907\fnil\fcharset2\fprq2 URWPalladioExpert;}{\f908\fnil\fcharset0\fprq2 VAGRounded;}{\f909\fnil\fcharset0\fprq2 Vendome;} {\f910\fnil\fcharset0\fprq2 Walbaum;}{\f911\froman\fcharset0\fprq0 as;}{\f912\froman\fcharset0\fprq0 MS Sans;}{\f913\fnil\fcharset0\fprq2 CRL_1;}{\f914\froman\fcharset0\fprq0 ms sans seriff{\*\falt Times New Roman};} {\f915\fnil\fcharset77\fprq0 BodegaSans-Medium;}{\f916\fnil\fcharset0\fprq0 BodegaSans;}{\f917\fnil\fcharset0\fprq0 BodegaSansMedium;}{\f918\fnil\fcharset77\fprq0 BodegaSans-Black;}{\f919\fnil\fcharset77\fprq0 OfficinaSans-Normal;} {\f920\fnil\fcharset0\fprq0 OfficinaSansNormal;}{\f921\fnil\fcharset77\fprq0 B Futura Bold;}{\f922\fnil\fcharset0\fprq0 OfficinaSansBold;}{\f923\froman\fcharset128\fprq1 \'be\'92\'a9;}{\f924\froman\fcharset0\fprq0 TimesNewRoman,Italic;} {\f925\fswiss\fcharset0\fprq0 Arial,BoldItalic;}{\f926\froman\fcharset0\fprq0 MS Sans Sserif;}{\f927\fmodern\fcharset0\fprq2 ?l?r ?o?S?V?b?N;}{\f928\fswiss\fcharset238\fprq2 Trebuchet MS CE;}{\f929\fswiss\fcharset162\fprq2 Trebuchet MS Tur;} {\f930\fnil\fcharset161\fprq2 BodegaSansMedium Greek;}{\f931\fnil\fcharset0\fprq2 Groening Plain;}{\f932\froman\fcharset128\fprq1 MS ??{\*\falt Wingdings};}{\f933\froman\fcharset128\fprq1 lS ??{\*\falt Wingdings};}{\f934\fnil\fcharset136\fprq2 ????;} {\f935\froman\fcharset136\fprq0 ???;}{\f936\froman\fcharset128\fprq1 ??;}{\f937\fnil\fcharset136\fprq2 s???;}{\f938\froman\fcharset204\fprq2 Symbol Cyr;}{\f939\froman\fcharset161\fprq2 Symbol Greek;}{\f940\froman\fcharset162\fprq2 Symbol Tur;} {\f941\fscript\fcharset162\fprq2 Comic Sans MS Tur;}{\f942\fdecor\fcharset0\fprq2 Business/Industrial Dingbats;}{\f943\fnil\fcharset0\fprq2 Cartoon-Normal;}{\f944\fnil\fcharset0\fprq2 Cursive;}{\f945\fnil\fcharset0\fprq2 Dragonwick;} {\f946\fmodern\fcharset2\fprq1 FoxPrint;}{\f947\fnil\fcharset0\fprq2 Windows Logo;}{\f948\fdecor\fcharset0\fprq2 Microsoft Canada;}{\f949\fnil\fcharset0\fprq2 Tabatha;}{\f950\fnil\fcharset0\fprq2 Keyboard KeysBT;} {\f951\fnil\fcharset0\fprq2 Keyboard KeysCn Condensed;}{\f952\fnil\fcharset0\fprq2 Keyboard KeysEx Expanded;}{\f953\fnil\fcharset0\fprq2 Keyboard KeysHo Hollow;}{\f954\fnil\fcharset0\fprq2 Keyboard KeysWd Wide;} {\f955\froman\fcharset162\fprq2 New Caledonia Tur;}{\f956\fnil\fcharset162\fprq2 Rockwell Condensed Bold Tur;}{\f957\fnil\fcharset162\fprq2 Chicago Tur;}{\f958\fnil\fcharset238\fprq2 Cartoon-Normal CE;}{\f959\fnil\fcharset162\fprq2 Cartoon-Normal Tur;} {\f960\fnil\fcharset238\fprq2 Tabatha CE;}{\f961\fnil\fcharset162\fprq2 Tabatha Tur;}{\f962\fnil\fcharset238\fprq2 Keyboard KeysBT CE;}{\f963\fnil\fcharset162\fprq2 Keyboard KeysBT Tur;}{\f964\fnil\fcharset238\fprq2 Keyboard KeysCn Condensed CE;} {\f965\fnil\fcharset162\fprq2 Keyboard KeysCn Condensed Tur;}{\f966\fnil\fcharset238\fprq2 Keyboard KeysEx Expanded CE;}{\f967\fnil\fcharset162\fprq2 Keyboard KeysEx Expanded Tur;}{\f968\fnil\fcharset238\fprq2 Keyboard KeysHo Hollow CE;} {\f969\fnil\fcharset162\fprq2 Keyboard KeysHo Hollow Tur;}{\f970\fnil\fcharset238\fprq2 Keyboard KeysWd Wide CE;}{\f971\fnil\fcharset162\fprq2 Keyboard KeysWd Wide Tur;}{\f972\fmodern\fcharset255\fprq1 8514oem;} {\f973\fmodern\fcharset128\fprq0 l\'82r \'82o\'83S\'83V\'83b\'83N;}{\f974\froman\fcharset238\fprq2 TIMES CE{\*\falt Times New Roman};}{\f975\froman\fcharset204\fprq2 TIMES Cyr{\*\falt Times New Roman};} {\f976\froman\fcharset161\fprq2 TIMES Greek{\*\falt Times New Roman};}{\f977\froman\fcharset162\fprq2 TIMES Tur{\*\falt Times New Roman};}{\f978\froman\fcharset186\fprq2 TIMES Baltic{\*\falt Times New Roman};} {\f979\fswiss\fcharset238\fprq2 HELVETICA CE{\*\falt Arial};}{\f980\fswiss\fcharset204\fprq2 HELVETICA Cyr{\*\falt Arial};}{\f981\fswiss\fcharset161\fprq2 HELVETICA Greek{\*\falt Arial};}{\f982\fswiss\fcharset162\fprq2 HELVETICA Tur{\*\falt Arial};} {\f983\fswiss\fcharset186\fprq2 HELVETICA Baltic{\*\falt Arial};}{\f984\fswiss\fcharset238\fprq2 Verdana CE{\*\falt Tahoma};}{\f985\fswiss\fcharset204\fprq2 Verdana Cyr{\*\falt Tahoma};}{\f986\fswiss\fcharset161\fprq2 Verdana Greek{\*\falt Tahoma};} {\f987\fswiss\fcharset162\fprq2 Verdana Tur{\*\falt Tahoma};}{\f988\fswiss\fcharset186\fprq2 Verdana Baltic{\*\falt Tahoma};}{\f989\fdecor\fcharset161\fprq2 Desdemona Greek;}{\f990\fmodern\fcharset162\fprq0 Courier New Turkish{\*\falt Tahoma};} {\f991\froman\fcharset204\fprq0 Times New Roman Cyrillic{\*\falt Bookman Old Style};}{\f992\fswiss\fcharset204\fprq0 Arial Cyrillic{\*\falt Tahoma};}{\f993\fmodern\fcharset204\fprq0 Courier New Cyrillic{\*\falt Tahoma};} {\f994\fnil\fcharset0\fprq2 Times New Roman(Western);}{\f995\fswiss\fcharset0\fprq2 Maiandra GD Italic;}{\f996\fnil\fcharset0\fprq2 Andy;}{\f997\fscript\fcharset0\fprq2 Blackadder ITC;}{\f998\fdecor\fcharset0\fprq2 Chiller;} {\f999\fscript\fcharset0\fprq2 Edwardian Script ITC;}{\f1000\fnil\fcharset0\fprq2 Enviro;}{\f1001\fnil\fcharset0\fprq2 Freestyle Script;}{\f1002\fdecor\fcharset0\fprq2 Gigi;}{\f1003\fnil\fcharset0\fprq2 Informal Roman;} {\f1004\fdecor\fcharset0\fprq2 Jokerman;}{\f1005\fnil\fcharset0\fprq2 Papyrus;}{\f1006\fscript\fcharset0\fprq2 Parchment;}{\f1007\froman\fcharset0\fprq2 Poor Richard;}{\f1008\fscript\fcharset0\fprq2 Pristina;}{\f1009\fscript\fcharset0\fprq2 Kristen ITC;} {\f1010\froman\fcharset0\fprq0 ! ms sans serif;}{\f1011\froman\fcharset0\fprq0 [!] ms sans serif;}{\f1012\froman\fcharset0\fprq0 MSPLetterGothicAB;}{\f1013\fswiss\fcharset0\fprq0 Cosmos ExtraBold;}{\f1014\fswiss\fcharset0\fprq0 Cosmos Light;} {\f1015\fmodern\fcharset128\fprq1 MS Gothic;}{\f1016\fnil\fcharset0\fprq2 PixieFont;}{\f1017\fnil\fcharset0\fprq2 Victorias;}{\f1018\fnil\fcharset0\fprq2 PostCrypt;}{\f1019\fnil\fcharset0\fprq2 BlackChancery;} {\f1020\froman\fcharset0\fprq2 Caslon Antique Italic;}{\f1021\froman\fcharset0\fprq2 Caslon Antique;}{\f1022\froman\fcharset0\fprq2 Barbe Display SSi;}{\f1023\fnil\fcharset0\fprq2 Andes;}{\f1024\froman\fcharset0\fprq2 CenturyOldStyle;} {\f1025\fswiss\fcharset0\fprq2 Frutiger 55;}{\f1026\fswiss\fcharset0\fprq2 Frutiger 45;}{\f1027\fswiss\fcharset0\fprq2 Mozart;}{\f1028\fnil\fcharset0\fprq2 wchords;}{\f1029\fswiss\fcharset2\fprq2 WP Phonetic;} {\f1030\fnil\fcharset2\fprq2 WP MathExtendedB;}{\f1031\fmodern\fcharset0\fprq1 WP BoxDrawing;}{\f1032\fnil\fcharset2\fprq2 WP IconicSymbolsB;}{\f1033\fnil\fcharset2\fprq2 WP Greek Helve;}{\f1034\fnil\fcharset2\fprq2 WP MathExtendedA;} {\f1035\froman\fcharset2\fprq2 WP CyrillicA;}{\f1036\fnil\fcharset2\fprq2 WP Japanese;}{\f1037\fnil\fcharset2\fprq2 WP MathB;}{\f1038\fnil\fcharset2\fprq2 WP IconicSymbolsA;}{\f1039\fnil\fcharset2\fprq2 WP Arabic Sihafa;} {\f1040\froman\fcharset2\fprq2 WP MultinationalA Roman;}{\f1041\fnil\fcharset0\fprq2 WP CyrillicB;}{\f1042\fnil\fcharset2\fprq2 WP MultinationalB Roman;}{\f1043\fmodern\fcharset2\fprq1 WP Greek Courier;}{\f1044\fnil\fcharset2\fprq2 WP MathA;} {\f1045\fnil\fcharset2\fprq2 WP ArabicScript Sihafa;}{\f1046\fnil\fcharset2\fprq2 WP Greek Century;}{\f1047\fnil\fcharset2\fprq2 WP Hebrew David;}{\f1048\fnil\fcharset2\fprq2 WP MultinationalA Helve;}{\f1049\fnil\fcharset2\fprq2 WP MultinationalB Helve;} {\f1050\fmodern\fcharset2\fprq1 WP MultinationalA Courier;}{\f1051\fmodern\fcharset2\fprq1 WP MultinationalB Courier;}{\f1052\fscript\fcharset0\fprq2 Ribbon131 Bd BT;}{\f1053\froman\fcharset0\fprq2 Humanst521 Lt BT;} {\f1054\froman\fcharset0\fprq2 GeoSlab703 Lt BT;}{\f1055\fswiss\fcharset0\fprq2 Swis721 BlkEx BT;}{\f1056\fswiss\fcharset0\fprq2 Humanst521 Cn BT;}{\f1057\fdecor\fcharset0\fprq2 Onyx BT;}{\f1058\fdecor\fcharset0\fprq2 CaslonOpnface BT;} {\f1059\fswiss\fcharset0\fprq2 EngraversGothic BT;}{\f1060\fscript\fcharset0\fprq2 ShelleyVolante BT;}{\f1061\froman\fcharset0\fprq2 BernhardMod BT;}{\f1062\froman\fcharset0\fprq2 Arrus BT;}{\f1063\fscript\fcharset0\fprq2 OzHandicraft BT;} {\f1064\fnil\fcharset0\fprq2 Serpentine;}{\f1065\fnil\fcharset0\fprq2 Aero;}{\f1066\fswiss\fcharset0\fprq2 Zurich BT;}{\f1067\fnil\fcharset0\fprq2 Eurotype;}{\f1068\fnil\fcharset77\fprq2 B Garamond Bold{\*\falt Times New Roman};}} {\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0; \red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\widctlpar \f4\fs20 \snext0 Normal;}{\s1\sb280\sa40\widctlpar \b\f4\fs20 \sbasedon0\snext0 heading 1;}{\s2\sb120\widctlpar  \b\f4\fs20 \sbasedon0\snext0 heading 2;}{\s3\sb120\sa60\widctlpar \f4\fs20 \sbasedon0\snext0 heading 3;}{\s4\fi-245\li360\widctlpar \f4\fs20 \sbasedon0\snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}{\s15\fi-187\li274\sl-120\slmult0 \widctlpar\brdrb\brdrs\brdrw15\brsp20 \tx302 \f4\fs20 \sbasedon0\snext0 a/k link;}{\*\cs16 \additive\cf6 \sbasedon10 annotation reference;}{\s17\widctlpar \f4\fs20 \sbasedon0\snext17 annotation text;}{\s18\li115\ri130\sb120\sa120\widctlpar \f7\fs16  \snext0 bitmap;}{\s19\widctlpar \f4\fs20 \sbasedon0\snext0 Context;}{\*\cs20 \additive\up6 \sbasedon10 footnote reference;}{\s21\widctlpar \f4\fs20 \sbasedon0\snext0 footnote text;}{\s22\widctlpar \f4\fs20 \sbasedon0\snext22 Jl;}{ \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 \sbasedon0\snext24 Lb1;}{\s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 \sbasedon23\snext24 Lb2;}{\s25\fi-158\li461\sb48\widctlpar\tx461 \f4\fs20 \sbasedon24\snext25 Lb3;}{\s26\li302\sb60\widctlpar\tx302  \f4\fs20 \sbasedon24\snext24 Lp1;}{\s27\li720\widctlpar \f4\fs20 \sbasedon0\snext0 Normal Indent;}{\s28\fi-187\li274\sl-120\slmult0\widctlpar\tx302 \f4\fs20 \sbasedon15\snext28 oem a/k link;}{\s29\fi-302\li418\ri86\sa120\widctlpar \f4\fs20  \sbasedon0\snext29 oem button;}{\s30\fi-302\li418\ri86\sb160\sa120\widctlpar\tx720 \f4\fs20 \sbasedon29\snext30 oem button1;}{\s31\fi-187\li302\sb160\widctlpar\tx302 \f4\fs20 \sbasedon0\snext31 oem Lb1;}{\s32\sb160\widctlpar \f4\fs20 \sbasedon0\snext32  oem normal;}{\s33\ri2160\sb160\widctlpar \f4\fs20 \sbasedon0\snext33 oem popup;}{\s34\ri2160\widctlpar \f4\fs12 \sbasedon33\snext34 oem popup end;}{\s35\fi-187\li302\ri2160\sb160\widctlpar\tx302 \f4\fs20 \sbasedon31\snext35 oem popup Lb1;}{ \s36\sb240\widctlpar \b\f4\fs20 \sbasedon0\snext36 oem proc head;}{\s37\ri86\widctlpar \f4\fs20 \sbasedon0\snext0 oem tb text;}{\s38\li58\widctlpar \f4\fs20 \sbasedon0\snext38 oem tb text 2;}{\s39\fi-187\li245\widctlpar\tx245\tx302 \f4\fs20  \sbasedon23\snext39 oem tb text 2 Lb1;}{\s40\fi-187\li245\sb48\widctlpar\tx245\tx302 \f4\fs20 \sbasedon24\snext40 oem tb text 2 Lb2;}{\s41\fi-158\li403\sb48\widctlpar\tx403\tx461 \f4\fs20 \sbasedon25\snext41 oem tb text 2 Lb3;}{\s42\widctlpar \f4\fs20  \sbasedon0\snext42 Pop-up;}{\s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 \snext23 proc head;}{\s44\li115\ri86\sb280\widctlpar \f4\fs20 \sbasedon29\snext29 table top;}{\s45\li58\sb280\widctlpar \f4\fs20 \sbasedon44\snext38 table top 2;}{ \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \sbasedon24\snext46 Tbr1;}{\s47\widctlpar \f4\fs20 \sbasedon0\snext0 Tech Rev;}{\s48\li58\sb80\widctlpar \f4\fs20 \sbasedon44\snext48 vertrule;}{\*\cs49 \additive\b \sbasedon10 UI;}{\s50\widctlpar \brdrb\brdrs\brdrw15\brsp20 \f4\fs20 \sbasedon38\snext50 Table row w/rule;}{\*\cs51 \additive\scaps\fs14 \sbasedon10 Smallcaps;}{\s52\fi-302\li388\widctlpar\tqr\tx274\tx389 \f4\fs20 \sbasedon23\snext52 Lb1a;}{ \s53\fi-302\li388\sb48\widctlpar\tqr\tx274\tx389 \f4\fs20 \sbasedon52\snext53 Lb2a;}{\s54\fi-547\li662\ri187\sb60\sa60\sl240\slmult0\nowidctlpar\tx660 \f4\fs20 \sbasedon0\snext54 Np;}{\s55\widctlpar \f11\fs20 \sbasedon0\snext0 Code;}{\*\cs56 \additive \cf12 \sbasedon10 HTML;}}{\info{\title Create Help files for Winhelp 4.0}{\author Linda Wells}{\operator Linda Wells}{\creatim\yr1997\mo6\dy26\hr17\min22}{\revtim\yr1998\mo10\dy16\hr16\min50}{\printim\yr1998\mo1\dy7\hr12\min7}{\version2}{\edmins1} {\nofpages41}{\nofwords3790}{\nofchars21603}{\*\company Microsoft Corporation}{\vern57443}}\margl1440\margr5040 \widowctrl\ftnbj\aenddoc\linkstyles\hyphcaps0\formshade \fet0\sectd \linex0\endnhere {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (} {\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9 \pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\v\cf6 dummy_contents }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} dummy_contents}} { \cs20\up6 !{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 !} JumpId(>proc4, contents)}}  \par {\b0\up6 \page }{\v\cf6 contents }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} contents}} {\cs20\up6 ${\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 $} Help for Sign-In}} {\cs20\up6 !{\footnote \pard\plain  \s21\widctlpar \f4\fs20 {\cs20\up6 !} CloseWindow(main)}} {\cs20\up6 >{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 >} proc4}}Help for logging on to your service \par \pard\plain \widctlpar \f4\fs20 This is the troubleshooter for logging on to your service. For information about any item in the {\cs49 logon} dialog boxes, right-click the item, and then click {\cs49\b What's This?}. \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>proc4,ICM_TRB)\}{\uldb \tab Troubleshooting.}{\v\cf6 %ICM_TRB>proc4} \par \{button ,CloseWindow("proc4")\}{\uldb \tab Close this window now.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB}} {\cs20\up6 ${\footnote \pard\plain \s21\widctlpar \f4\fs20 { \cs20\up6 $} Sign-In Troubleshooter}} {\cs20\up6 >{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 >} proc4}}Logon troubleshooter \par \pard\plain \widctlpar \f4\fs20 This troubleshooter can help you solve problems that you encounter while logging on to your service. Click to answer the questions, and try the suggested steps to solve the problem. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 What is wrong? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>proc4,ICM_TRB_ERRMSG)\}{\uldb \tab }{\cs49\b\uldb Connection status}{\uldb  shows an error message.}{\v\cf6 %ICM_TRB_ERRMSG>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_OPERMSG)\}{\uldb \tab I hear a message from the operator.}{\v\cf6 %ICM_TRB_OPERMSG>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_DIALINGPROP)\}{\uldb \tab I hear a ring, but either there is no answer or a person answers.}{\v\cf6 %ICM_TRB_DIALINGPROP>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_PHONE_PICKUP_DIS)\}{\uldb \tab My modem disconnects while I am logging on or using the service.}{\v\cf6 %ICM_TRB_PHONE_PICKUP_DIS>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_CHANGE_NUMBER)\}{\uldb \tab My modem is working properly, but I still cannot connect.}{\v\cf6 %ICM_TRB_CHANGE_NUMBER>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_CHANGE_NUMBER)\}{\uldb \tab I can connect to the service, but I cannot use e-mail, read newsgroups, or connect to a Web site.}{\v\cf6 %ICM_TRB_CHANGE_NUMBER>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_TUNNEL_OS)\}{\uldb \tab I cannot connect to my private network using a VPN connection.}{\v\cf6 %ICM_TRB_TUNNEL_OS>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_LOGON)\}{\uldb \tab I cannot save my user name and password.}{\v\cf6 %ICM_TRB_LOGON>proc4} \par \pard\plain \s15\fi-187\li274\sl-120\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \tx302 \f4\fs20  \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>moreinfo,ICM_TRB_CUSTSUP_NUMS)\}{\uldb \tab Contact customer support}{\v\cf6  %ICM_TRB_CUSTSUP_NUMS>moreinfo} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_ERRMSG }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_ERRMSG}}What is the error message? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>proc4,ICM_TRB_NAMEPWD)\}{\uldb \tab You must type your user name, password, or domain name before you can connect.}{\v\cf6 %ICM_TRB_NAMEPWD>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_PHONENUM)\}{\uldb \tab You must provide a valid phone number before you can connect.}{\v\cf6 %ICM_TRB_PHONENUM>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_CHKIDPWD)\}{\uldb \tab The password is incorrect.}{\v\cf6 %ICM_TRB_CHKIDPWD>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_REINSTALL_MODEM)\}{\uldb \tab The modem is not configured correctly.}{\v\cf6 %ICM_TRB_REINSTALL_MODEM>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_CHKCABLES2)\}{\uldb \tab The modem is not responding.}{\v\cf6 %ICM_TRB_CHKCABLES2>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_CLOSEPROGS)\}{\uldb \tab Another application is using the modem.}{\v\cf6 %ICM_TRB_CLOSEPROGS>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_CHKCABLES)\}{\uldb \tab The modem could not detect a dial tone.}{\v\cf6 %ICM_TRB_CHKCABLES>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_REDIAL)\}{\uldb \tab There was a busy signal or no answer.}{\v\cf6 %ICM_TRB_REDIAL>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_PHONE_PICKUP_CARRIER)\}{\uldb \tab I cannot establish a connection.} \par {\v\cf6 %ICM_TRB_PHONE_PICKUP_CARRIER>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_REDIAL)\}{\uldb \tab There is an error other than those listed above.}{\v\cf6 %ICM_TRB_REDIAL>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_NAMEPWD }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_NAMEPWD}}Type your user name, password, and domain name \par \pard\plain \widctlpar \f4\fs20 When you start Connection Manager, the logon dialog box appears. You must enter the following information to connect to your service. \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab In {\b User name}, type the name you use to identify yourself to the service. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab In {\b Password}, type your password. \par 3\tab In {\b Logon} {\cs49\b Domain}, type your domain name, if necessary. \par \pard\plain \s26\li302\sb60\widctlpar\tx302 \f4\fs20 {\b Logon} {\b Domain} appears in the logon dialog box only if your service requires it. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 4\tab Click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_NAMEPWD2)\}{\uldb \tab No. I cannot remember my user name or password.}{\v\cf6 %ICM_TRB_NAMEPWD2} \par \{button ,JumpID(>proc4,ICM_TRB_ERRMSG)\}{\uldb \tab No. I get another message in }{\cs49\b\uldb Connection status}{\uldb .}{\v\cf6 %ICM_TRB_ERRMSG} \par \{button ,JumpID(>proc4,ICM_TRB)\}{\uldb \tab No. There is another problem. Go back to the beginning of this troubleshooter.}{\v\cf6 %ICM_TRB} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_NAMEPWD2 }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_NAMEPWD2}}Contact customer support for your service \par \pard\plain \widctlpar \f4\fs20 If you have forgotten the name and password you use to log on to the service, contact customer support to get a new name and password.  \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Close this troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \pard\plain \s15\fi-187\li274\sl-120\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \tx302 \f4\fs20  \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>moreinfo,ICM_TRB_CUSTSUP_NUMS)\}{\uldb \tab Contact customer support}{\v\cf6  %ICM_TRB_CUSTSUP_NUMS>moreinfo} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_PHONENUM }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_PHONENUM}}Select a phone number from Phone Book \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab In the logon{\cs49\b  }dialog box, click {\cs49\b Properties}. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab In the {\b Properties} dialog box, next to {\b Phone number}, click {\cs49\b Phone Book}. \par 3\tab Change the settings in {\cs49\b Service type}, {\cs49\b Country or Region}, and {\cs49\b State or Province}{\cs49 ,} as needed. \par 4\tab In {\cs49\b Access numbers}, click the phone number you want. \par 5\tab Click {\cs49\b OK} in two places, as prompted. \par 6\tab In the logon dialog box, click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Notes \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 \{bmc bullet.bmp\}\tab You can also assign a backup number to dial (in case the first phone number is busy), or you can type a number instead of selecting one from {\b Phone Book}. If you type a  number, you must include any dialing rules (such as numbers required to access external or long-distance lines) because Connection Manager dialing rules are automatically applied only to numbers selected from {\b Phone Book}. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 \{bmc bullet.bmp\}\tab If {\cs49\b Phone Book} is unavailable, contact customer support for your service and ask for alternate phone numbers. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_ERRMSG)\}{\uldb \tab No. I get another message in }{\cs49\b\uldb Connection status}{\uldb .}{\v\cf6 %ICM_TRB_ERRMSG} \par \{button ,JumpID(>proc4,ICM_TRB_NUMMODEMS)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_NUMMODEMS} \par \pard\plain \s15\fi-187\li274\sl-120\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \tx302 \f4\fs20  \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>moreinfo,ICM_TRB_CUSTSUP_NUMS)\}{\uldb \tab Contact customer support}{\v\cf6  %ICM_TRB_CUSTSUP_NUMS>moreinfo} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_NUMMODEMS }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_NUMMODEMS}} Is there more than one connection device available? \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab In the logon dialog box, click {\cs49\b Properties}. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab In the {\b Properties} dialog box, click the arrow in {\cs49\b Connect using}{\cs49  to list the available connection devices}. \par 3\tab Are there two or more connection devices listed? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>proc4,ICM_TRB_MULTMODEMS)\}{\uldb \tab Yes, at least two connection devices are available on my computer.}{\v\cf6 %ICM_TRB_MULTMODEMS>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_REINSTALL_MODEM)\}{\uldb \tab No, there is only one connection device listed.}{\v\cf6 %ICM_TRB_REINSTALL_MODEM>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_MULTMODEMS }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_MULTMODEMS}}Select a different modem \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab In the logon dialog box, click {\cs49\b Properties}. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab In the {\b Properties} dialog box, in {\cs49\b Connect using}{\cs49 ,} click the modem you want to use. \par 3\tab Click {\cs49\b OK}{\cs49 ,} and then click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_REINSTALL_MODEM)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_REINSTALL_MODEM>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_CLOSEPROGS }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_CLOSEPROGS}}Close other programs \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab Close all programs that might be using the same communication port as your modem, such as any fax software, HyperTerminal, or Phone Dialer. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab In the logon dialog box, click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_MODEM_ONOFF)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_MODEM_ONOFF} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_CHKCABLES2 }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_CHKCABLES2}}Check your cables \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab Make sure the {\i Wall} or {\i Line} end of your modem cable is connected to a telephone service jack in the wall and that the modem cable is connected both to your modem and to your computer. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab If you are using an external modem, make sure that it is turned on. \par 3\tab Make sure all cables are securely connected. \par 4\tab Verify that your telephone cable is working by trying it with your telephone or replacing it with a cable that you know works. \par 5\tab In the {\cs49 logon} dialog box, click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_MODEM_ONOFF)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_MODEM_ONOFF>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_MODEM_ONOFF }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_MODEM_ONOFF}}Reset power to the external modem \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab If you are using an external modem, leave your computer turned on while you turn your modem off and then on. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab In the {\cs49 logon} dialog box, click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_REINSTALL_MODEM)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_REINSTALL_MODEM} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_REINSTALL_MODEM }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_REINSTALL_MODEM}} Uninstall and reinstall your modem \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab Click here {\uldb \{bmc shortcut.bmp\}}{\v\cf6 !ExecFIle(modem.cpl,Modems)} to open the {\b Modems Properties} dialog box. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab Select the modem you are trying to use to log on to the service, and then click {\cs49\b Remove}. \par 3\tab Click {\cs49\b Add}, and then reinstall the modem. \par 4\tab Try logging on to the service again. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6  %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_ERRMSG)\}{\uldb \tab No. I get another message in }{\cs49\b\uldb Connection status}{\uldb .}{\v\cf6 %ICM_TRB_ERRMSG} \par \{button ,JumpID(>proc4,ICM_TRB_GIVEUP_MODEM)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_GIVEUP_MODEM} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_CHKCABLES }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_CHKCABLES}}Check your cables \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab Make sure the {\i Wall} or {\i Line} end of your modem cable is connected to a telephone service jack and that the modem cable is connected both to your modem and to your computer. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab If you are using an external modem, make sure that it is turned on. \par 3\tab Make sure all cables are securely connected. \par 4\tab Verify that your telephone cable is working by trying it with your telephone or replacing it with a cable that you know works. \par 5\tab In the logon dialog box, click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_TONE_LISTEN)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_TONE_LISTEN>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_TONE_LISTEN }{\cs20\up6 #{\footnote \pard\plain \widctlpar \f4\fs20 {\cs20\b\up6 #}{\b  }ICM_TRB_TONE_LISTEN}}Listen for a dial tone \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab Click here {\uldb \{bmc shortcut.bmp\}}{\v\cf6 !ExecFIle(modem.cpl,Modems)} to open the {\b Modems Properties} dialog box. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab Select the modem you are using, and then click {\cs49\b Properties}. \par 3\tab If {\cs49\b Speaker volume} is available, make sure it is not set to {\cs49\b Low }or {\cs49\b Off}, and then click {\b OK}. \par 4\tab In the {\cs49\b Modems Properties} dialog box, click {\cs49\b Close}. \par 5\tab In the {\cs49 logon} dialog box, click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did you hear a dial tone? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>proc4,ICM_TRB_TONEPULSE)\}{\uldb \tab Yes. What should I do next?}{\v\cf6 %ICM_TRB_TONEPULSE>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_NODIALTONE)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_NODIALTONE>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_TONEPULSE }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_TONEPULSE}}Check the tone/pulse dialing setting \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab In the logon dialog box, click {\cs49\b Properties}. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab In the {\b Properties} dialog box, click {\cs49\b Dialing Rules}. \par 3\tab Under {\b When dialing from here}, make sure the selection for {\cs49\b Tone dialing} or {\cs49\b Pulse dialing} is correct for your telephone system. \par 4\tab Click {\cs49\b OK} in two places, as prompted. \par 5\tab In the {\cs49 logon} dialog box, click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_BADMODEM)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_BADMODEM>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_BADMODEM }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_BADMODEM}}You might have an incompatible modem \par \pard\plain \widctlpar \f4\fs20 Your modem might be incompatible with your telephone system.  \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 \{bmc onestep.bmp\}\tab For more information, see the documentation that comes with your modem.  \par \pard\plain \s26\li302\sb60\widctlpar\tx302 \f4\fs20 You can also try contacting your telephone company or your telephone system administrator. \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>proc4,ICM_TRB)\}{\uldb \tab Go back to the beginning of the troubleshooter.}{\v\cf6 %ICM_TRB>proc4} \par \{button ,CloseWindow("proc4")\}{\uldb \tab Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_NODIALTONE }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_NODIALTONE}}Contact your te lephone company or telephone system administrator \par \pard\plain \widctlpar \f4\fs20 If you do not hear a dial tone, your organization or telephone might not support this type of outside call, or you might need to dial an additional access code.  \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 \{bmc onestep.bmp\}\tab Contact your local telephone company or telephone system administrator. \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>proc4,ICM_TRB)\}{\uldb \tab Go back to the beginning of the troubleshooter.}{\v\cf6 %ICM_TRB>proc4} \par \{button ,CloseWindow("proc4")\}{\uldb \tab Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_REDIAL }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_REDIAL}}Try the call again \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 \{bmc onestep.bmp\}\tab  If you have successfully connected to the service from this computer before and you are using the same modem at the same location, the telephone line might be busy. Try again later. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_CHANGE_NUMBER)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_CHANGE_NUMBER>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_CHANGE_NUMBER }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_CHANGE_NUMBER}}Try a different phone number  \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab In the {\cs49 logon} dialog box, click {\cs49\b Properties}. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab In the {\cs49\b Properties} dialog box, next to {\b Phone number}, click {\cs49\b Phone Book}. \par 3\tab Verify the {\b Country or Region} and {\b State or Province} selections, and then, in {\cs49\b Access numbers}, select a new phone number. \par 4\tab Click {\cs49\b OK} in two places, as prompted. \par 5\tab In the {\cs49 logon} dialog box, click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Note \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 \{bmc bullet.bmp\}\tab If {\cs49\b Phone Book} is unavailable, contact customer support for your service and ask for the alternate phone numbers. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_GIVEUP)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_GIVEUP} \par \pard\plain \s15\fi-187\li274\sl-120\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \tx302 \f4\fs20  \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>moreinfo,ICM_TRB_CUSTSUP_NUMS)\}{\uldb \tab Contact customer support}{\v\cf6  %ICM_TRB_CUSTSUP_NUMS>moreinfo} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_OPERMSG }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_OPERMSG}}What operator message do you get? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>proc4,ICM_TRB_LONGDISTANCE)\}{\uldb \tab I get a message indicating that this call must be dialed as a long-distance call.}{\v\cf6 %ICM_TRB_LONGDISTANCE>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_CHANGE_NUMBER)\}{\uldb \tab I get a different operator message.}{\v\cf6 %ICM_TRB_CHANGE_NUMBER>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_LONGDISTANCE }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_LONGDISTANCE}}Specify the call as long distance \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab In the {\cs49 logon} dialog box, click {\cs49\b Properties}. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab In the {\cs49\b Properties} dialog box, click {\cs49\b Dialing Rules}{\cs49 . \par 3.\tab In }{\cs49\b The area code is}{\cs49 , enter }{\cs49\b 000}{\cs49   so that Connection Manager will treat this as a long-distance number. This is necessary to correctly dial long-distance numbers that have the same area code as the number from which you are dialing.} \par 4\tab Click {\cs49\b OK}, and then click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Note \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 \{bmc bullet.bmp\}\tab If you type a phone number into {\cs49\b Phone number} or {\cs49\b Backup number} instead of selecting a phone number in {\b Phone Book}, the dialing rules you select in the { \cs49\b Dialing Rules} dialog box are not applied. If you edit a number from {\b Phone Book}, the dialing rules are not applied. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_CHANGE_NUMBER)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_CHANGE_NUMBER>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_DIALINGPROP }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_DIALINGPROP}} Check the dialing settings for your location \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab In the{\cs49  logon} dialog box, click {\cs49\b Properties}. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab In the {\cs49\b Properties} dialog box, click {\cs49\b Dialing Rules}. \par 3\tab Under {\b How I dial from this location}, make sure the settings are correct for your telephone system. \par \pard\plain \s26\li302\sb60\widctlpar\tx302 \f4\fs20 For example, some company telephone systems require you to dial 9 to make a local call outside of the company. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 4\tab Make sure the setting for {\cs49\b Tone dialing} or {\cs49\b Pulse dialing} is correct for your telephone system. \par 5\tab Click {\cs49\b OK} in two places, as prompted. \par 6\tab In the logon dialog box, click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Note \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 \{bmc bullet.bmp\}\tab If you type a phone number into {\cs49\b Phone number} or {\cs49\b Backup number} instead of selecting a phone number in {\b Phone Book}, the dialing rules you select in the { \cs49\b Dialing Rules} dialog box are not applied. You must type the dialing codes in {\cs49\b Phone number} or {\cs49\b Backup number} as part of any phone number that is not taken from {\b Phone Book}. If you edit a number from {\b Phone Book} , the dialing rules are not applied. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_CHANGE_NUMBER)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_CHANGE_NUMBER>proc4}  \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_SETCALLWAIT }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_SETCALLWAIT}}Check the call-waiting setting \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab In the {\cs49 logon} dialog box, click {\cs49\b Properties}. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab In the {\cs49\b Properties} dialog box, click{\cs49\b  Dialing Rules}. \par 3\tab If your telephone system has call waiting, turn it off using the procedure defined by your telephone system. \par \pard\plain \s26\li302\sb60\widctlpar\tx302 \f4\fs20  For example, for many telephone systems, *70 temporarily turns off call waiting. The appropriate procedure can usually be found in the front of the phone book provided for your telephone system. If you are not sure what value to use, contact your telephon e company or your telephone system administrator. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 4\tab Click {\cs49\b OK} in two places, as prompted. \par 5\tab In the{\cs49  logon} dialog box, click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_MODEM_DIAG)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_MODEM_DIAG>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_MODEM_SET }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_MODEM_SET}}Check error and flow control settings \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab Click here {\uldb \{bmc shortcut.bmp\}}{\v\cf6 !ExecFIle(modem.cpl,Modems)} to open the {\cs49\b Modems Properties}{\cs49  dialog box.} \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab Select the modem you are using, click {\cs49\b Properties}, and make sure the {\cs49\b Only connect at this speed} check box is cleared (not selected). \par 3\tab If {\cs49\b Speaker volume} is available, make sure the volume is not set to {\cs49\b Low} or {\b Off}. \par \pard\plain \s26\li302\sb60\widctlpar\tx302 \f4\fs20 Listening to the modem speaker can help you troubleshoot problems with your modem. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 4\tab On the {\cs49\b Connection} tab of the {\cs49\b Properties} dialog box, click {\cs49\b Advanced}, and confirm the following settings: \par \pard\plain \s25\fi-158\li461\sb48\widctlpar\tx461 \f4\fs20 \{bmc bullet.bmp\}\tab If the {\cs49\b Use error control} and {\cs49\b Compress data} check boxes are available, make sure that they are selected, and that the {\cs49\b Required to connect}  check box is cleared (not selected). \par \{bmc bullet.bmp\}\tab If the {\cs49\b Use flow control} and {\cs49\b Hardware (RTS/CTS)} check boxes are available, make sure they are selected. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 5\tab Click {\cs49\b Record a log file}{\cs49 ,} to create a log file named Modemlog.txt in your Windows folder. \par \pard\plain \s26\li302\sb60\widctlpar\tx302 \f4\fs20 A log file is useful if you have to call customer support for your service. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 6\tab Click {\cs49\b OK} in two places, as prompted, and then, in the {\cs49\b Modems Properties} dialog box, click {\cs49\b Close}. \par 7\tab In the logon dialog box, click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_RESTART)\}{\uldb \tab Error and flow control settings are not available.}{\v\cf6 %ICM_TRB_RESTART>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_OS)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_OS>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_OS }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_OS}}Which operating system are you running? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>proc4,ICM_TRB_MODEM_DIAG)\}{\uldb \tab Windows\~95 or later.}{\v\cf6 %ICM_TRB_MODEM_DIAG>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_RESTART)\}{\uldb \tab Windows\~NT Workstation or Windows\~NT Server.}{\v\cf6 %ICM_TRB_RESTART>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_MODEM_DIAG }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_MODEM_DIAG}} Run modem diagnostics and adjust maximum speed \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab Close all programs that use the communication port that is currently selected. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab Click here {\uldb \{bmc shortcut.bmp\}}{\v\cf6 !ExecFIle(modem.cpl,Modems)} to open the {\cs49\b Modems Properties}{\cs49  dialog box.} \par 3\tab If the {\cs49\b Diagnostics} tab appears, click the communication port you are using. (If the {\cs49\b Diagnostics} tab is unavailable, skip the remainder of this procedure and click {\b No. What else could be wrong?}  to continue with the troubleshooter.) \par 4\tab Click {\cs49\b More Info}, note the highest speed, and then click {\b OK}. \par \pard\plain \s26\li302\sb60\widctlpar\tx302 \f4\fs20 The port information section contains the highest speed your UART (Universal Asynchronous Receiver Transmitter) can support. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 5\tab On the {\cs49\b General} tab, click {\cs49\b Properties}, and set the maximum speed to the highest speed listed in Step 4. \par 6\tab Click {\cs49\b OK}, and then, in the {\cs49\b Modems Properties} dialog box, click {\cs49\b Close}. \par 7\tab In the{\cs49  logon} dialog box, click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_RESTART)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_RESTART>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_RESTART }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_RESTART}}Restart your computer \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab Close all programs that are currently running on your computer. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab Shut down and restart your computer. \par 3\tab Start{\*\atrfstart 970061716} the service {\*\atrfend 970061716}and try again. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_REINSTALL_CM)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_REINSTALL_CM>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_REINSTALL_CM }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_REINSTALL_CM}}Uninstall and reinstall the service \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab On the desktop, right-click the icon for your service. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab On the shortcut menu, click {\cs49\b Delete.} \par 3\tab Reinstall the service and try again. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_GIVEUP)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_GIVEUP>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_CHKIDPWD }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_CHKIDPWD}}Check your user name and password \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 \{bmc onestep.bmp\}\tab Make sure you typed your user name and password correctly. Passwords are case sensitive. Before entering your password, be sure CAPS LOCK is not on. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_GIVEUP)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_GIVEUP>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_PHONE_PICKUP_DIS }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_PHONE_PICKUP_DIS}} Check whether someone else is trying to use the same telephone line \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 \{bmc onestep.bmp\}\tab If someone else picks up a telephone that uses the same telephone line as your modem, this interrupts your connection. After the other person hangs up the telephone, click { \cs49\b Connect}{\cs49  }in the logon dialog box to reconnect. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_SETCALLWAIT)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_SETCALLWAIT>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_PHONE_PICKUP_CARRIER }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_PHONE_PICKUP_CARRIER}} Redial the current phone number \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 \{bmc onestep.bmp\}\tab In the logon dialog box, click {\cs49\b Connect} to try logging on to the service with the current phone number. If necessary, click {\b Connect} again a few times.  \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_CHANGE_NUMBER2)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_}{\v\f5\cf6 CHANGE}{\v\cf6 _NUMBER2>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_CHANGE_NUMBER2 }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_CHANGE_NUMBER2}}Try a different phone number \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab In the logon dialog box, click {\cs49\b Properties}. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab In the {\cs49\b Properties} dialog box, next to {\b Phone number}, click {\cs49\b Phone Book}. \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 3\tab Verify the {\b Country or Region} and {\b State or Province} selections, and then, in {\cs49\b Access numbers}, select a new phone number. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 4\tab Click {\cs49\b OK} in two places, as prompted, and then click {\cs49\b Connect}. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Note \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 \{bmc bullet.bmp\}\tab If {\cs49\b Phone Book} is unavailable, contact customer support for your service and ask for alternate phone numbers. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_MODEM_SET)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_MODEM_SET} \par \pard\plain \s15\fi-187\li274\sl-120\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \tx302 \f4\fs20  \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>moreinfo,ICM_TRB_CUSTSUP_NUMS)\}{\uldb \tab Contact customer support}{\v\cf6  %ICM_TRB_CUSTSUP_NUMS>moreinfo} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_LOGON }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_LOGON}}Log on to Windows \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab Click {\cs49\b Start}, and then click {\cs49\b Shut Down}. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab Click {\cs49\b Close all programs and log on as a different user}. \par 3\tab Click {\cs49\b Yes}. \par 4\tab Follow the instructions on the screen for logging on to Windows. \par 5\tab When prompted, enter your user name and password. \par 6.\tab Start Connection Manager, enter your {\b User name} and {\b Password}, and then select the {\b Save Password} check box. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_GIVEUP_PHONE)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_GIVEUP_PHONE} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_GIVEUP }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_GIVEUP}}Next steps \par \pard\plain \widctlpar \f4\fs20 You have a problem that this troubleshooter can{\revdttm1713453830 not}  help you solve. The network or the server to which you are trying to connect might be offline for updates or repairs. Wait for a while, and then try connecting again. If necessary, try dialing a different number. \par If you still encounter problems, contact customer support for your service. \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>proc4,ICM_TRB)\}{\uldb \tab Go back to the beginning of this troubleshooter.}{\v\cf6 %ICM_TRB>proc4} \par \{button ,CloseWindow("proc4")\}{\uldb \tab Close this troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \pard\plain \s15\fi-187\li274\sl-120\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \tx302 \f4\fs20  \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>moreinfo,ICM_TRB_CUSTSUP_NUMS)\}{\uldb \tab Contact customer support}{\v\cf6  %ICM_TRB_CUSTSUP_NUMS>moreinfo} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_GIVEUP_PHONE }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_GIVEUP_PHONE}}Next steps \par \pard\plain \widctlpar \f4\fs20 You have a problem that this troubleshooter cannot help you solve. Your phone book file might be damaged, or there might a problem with the access numbers in your area. \par For more information, contact customer support for your service. \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>proc4,ICM_TRB)\}{\uldb \tab Go back to the beginning of this troubleshooter.}{\v\cf6 %ICM_TRB>proc4} \par \{button ,CloseWindow("proc4")\}{\uldb \tab Close this troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \pard\plain \s15\fi-187\li274\sl-120\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \tx302 \f4\fs20  \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>moreinfo,ICM_TRB_CUSTSUP_NUMS)\}{\uldb \tab Contact customer support}{\v\cf6  %ICM_TRB_CUSTSUP_NUMS>moreinfo} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_GIVEUP_MODEM }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_GIVEUP_MODEM}}Next steps \par \pard\plain \widctlpar \f4\fs20 You have a problem that this troubleshooter cannot help you solve. Your modem might be damaged, or there might a problem with your system configuration. \par For more information, contact customer support for your service. \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>proc4,ICM_TRB)\}{\uldb \tab Go back to the beginning of this troubleshooter.}{\v\cf6 %ICM_TRB>proc4} \par \{button ,CloseWindow("proc4")\}{\uldb \tab Close this troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \pard\plain \s15\fi-187\li274\sl-120\slmult0\widctlpar\brdrb\brdrs\brdrw15\brsp20 \tx302 \f4\fs20  \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>moreinfo,ICM_TRB_CUSTSUP_NUMS)\}{\uldb \tab Contact customer support}{\v\cf6  %ICM_TRB_CUSTSUP_NUMS>moreinfo} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_TUNNEL_OS }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_TUNNEL_OS}}Which operating system are you running? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,JumpID(>proc4,ICM_TRB_TUNNEL)\}{\uldb \tab Windows\~95 or later.}{\v\cf6 %ICM_TRB_TUNNEL>proc4} \par \{button ,JumpID(>proc4,ICM_TRB_TUNNEL_RCV_ONLY_NT)\}{\uldb \tab Windows\~NT Workstation or Windows\~NT Server.}{\cf6  }{\v\cf6 %ICM_TRB_TUNNEL_RCV_ONLY_NT>proc4} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_TUNNEL_RCV_ONLY_NT}{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_TUNNEL_RCV_ONLY_NT}} Check your VPN adapter settings \par \pard\plain \widctlpar \f4\fs20 If you are using Windows\~NT Workstation or Windows\~NT Server and a VPN adapter: \par \pard\plain \s23\fi-187\li302\widctlpar\tx302 \f4\fs20 1\tab Click here {\uldb \{bmc shortcut.bmp\}}{\v\cf6 !ExecFIle(ncpa.cpl)} to open the{\b  Network }dialog box. \par \pard\plain \s24\fi-187\li302\sb48\widctlpar\tx302 \f4\fs20 2\tab On the {\b Services} tab, click {\b Remote Access Service}, and then click {\b Properties}. \par 3\tab In the{\b  Remote Access Setup} dialog box, select your VPN adapter (device RASPPTPM), and then click {\b Configure}. If the list does not contain the VPN adapter, click {\b Add}, select it from {\b RAS Capable Devices}, and then click {\b OK}. \par 4\tab In the {\b Configure Port Usage} dialog box, click {\b Dial out only}, and then click {\b OK}. \par 5\tab Click {\b Network}. \par 6\tab In the {\b Network Configuration} dialog box, ensure that {\b TCP/IP} is selected, and then click {\b OK}. \par 7\tab Click {\b Continue}, click {\b Close}, and then click {\b Yes} when prompted, to restart your computer. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_GIVEUP)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_GIVEUP} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_TUNNEL }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_TUNNEL}}Contact your network administrator \par \pard\plain \widctlpar \f4\fs20 You might be missing some software required for connecting to your private network using a VPN connection. For information about obtaining this software, contact your network administrator. \par \pard\plain \s2\sb120\widctlpar \b\f4\fs20 Did this fix the problem? \par \pard\plain \s46\fi-317\li432\sb120\widctlpar\tx432\tx576 \f4\fs20 \{button ,CloseWindow("proc4")\}{\uldb \tab Yes. Close the troubleshooter.}{\v\cf6 %!CLOSEWINDOW("proc4")} \par \{button ,JumpID(>proc4,ICM_TRB_GIVEUP_PHONE)\}{\uldb \tab No. What else could be wrong?}{\v\cf6 %ICM_TRB_GIVEUP_PHONE} \par \pard\plain \s43\li115\ri130\sb120\sa40\sl-240\slmult0\widctlpar \b\f7\fs16 {\b0\up6 \page }{\v\cf6 ICM_TRB_CUSTSUP_NUMS }{\cs20\up6 #{\footnote \pard\plain \s21\widctlpar \f4\fs20 {\cs20\up6 #} ICM_TRB_CUSTSUP_NUMS}}Contact customer support \par \pard\plain \widctlpar \f4\fs20 Contact customer support for your service, using the telephone numbers provided in your service documentation or sign-up information.  \par  \par }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmmon\abstract.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Abstract of project CMMON: Title _PID_GUIDAbstract of project CMMON: Feng Sun Normal.dot Feng Sun Microsoft Word 8.0Abstract of project CMMON: CMMON32.exe manages connected connections. fengsun created 5/6/98 Classes/Files: Connection.h Connection.cpp Class CcmConnection : manages a single connection.   Monitor.h Monitor.cpp Class Cmonitor : Manage all connected CM conaction.  It also manage the communication with CMDIAL.DLL.   ModalDlg.h ModalDlg.cpp class CwindowWithHelp : A general window class that has context help class CmodalDlg : A general modal dialog class class CmodelessDlg : A general modeless dialog StatusDlg.h StatusDlg.cpp Class CstatusDlg : status/count-down dialog ReconnectDlg.h ReconnectDlg.cpp Class CreconnectDlg : Reconnect prompt dialog LoadLib.h Class CloadLib : A class that will unload the library on destructor WatchProcess.h Class CwatchProcessList : Manage to list of process handle.  Tell whether all the processes are terminated ArrayPtr.h ArrayPtr.cpp Class CptrArray : A array of void*, which grows dynamicly.  This class is exactly the same as the one defined by MFC.  Help on the class also comes with vc help trayicon.h trayicon.cpp Class CTrayIcon : Manage CM taskbar trayicon MbsLogon.h MbsLogon.cpp Class CMbsLogonDll : Call MbsLgn32 Connect/Disconnec action ShellDll.h ShellDll.cpp Class CShellDll : Dynamic load/unload shell32.dll Utility.cpp Utility function rnawnd.cpp Kill the DUN Reconnect dialog for Win95 Gold
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\customactions\cmsample\testfiles\proxy.txt ===
[Manual Proxy]
ProxyEnable=1
ProxyOverride=<local>
ProxyServer=SWIPROXY:80
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\customactions\cmsample\testfiles\tunneladdress.txt ===
[Tunnel Address]
cxn-ams.microsoft.com=nlproxy:80
cxn-clt.microsoft.com=ncproxy:80
cxn-chi.microsoft.com=crdproxy:80
cxn-eoc.microsoft.com=europroxy:80
cxn-hkg.microsoft.com=HKPROXY:80
cxn-lac.microsoft.com=lcproxy:80
cxn-lul.microsoft.com=lulproxy:80
cxn-mad.microsoft.com=madproxy:80
cxn-mil.microsoft.com=milproxy:80
cxn-muc.microsoft.com=deproxy:80
cxn-tvp.microsoft.com=ukproxy:80
cxn-redmond.microsoft.com=itgproxy:80
cxn-svc.microsoft.com=svcproxy:80
cxn-singapore.microsoft.com=sinproxy:80
cxn-sto.microsoft.com=stoproxy:80
cxn-syd.microsoft.com=sprproxy:80
cxn-japan.microsoft.com=jpproxy:80
cxn-webtv.webtv.net=svcproxy:80
cxn-zur.microsoft.com=SWIPROXY:80
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\migrate\placefil.txt ===
migrate.dll    win9xmig\cmmgr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\profwiz\docs\cmakeula.txt ===
[TEXT: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\uapi\00howto.txt ===
Instructions for adding a Win32 API function to CmUtoA
======================================================

Note that all the files referenced below contain functions or declarations in alphabetical order.
This sort order should be maintained.

For these instructions, I will use an imaginary Win32 API function named DoSomething.


In cm\common\inc\cmutoa.h
=========================

(a) search \nt\public\sdk\inc\*.h for the 'W' version of the function declaration, and copy it into
    the declarations section at the top, then modify to match the surrounding functions.
(b) Add an entry within the _tagUAPIInit union.
(c) Increment the size of ppvUapiFun by 1.


In cm\common\inc\uapi.h
=======================

add an extern declaration for DoSomethingU.


In cm\uapi\uapiinit\uapiinit.cpp
================================

(a) add a declaration for DoSomethingU
(b) add the function check to the big return statement in CheckUAPIFunctionPointers
(c) add the assignment for DoSomethingU to both the 'then' and 'else' portions of the
    if (IsWindowsNT) statement in InitUnicodeAPI.


In cm\uapi\cmutoa\cmutoa.cpp
============================

(a) add an initialization line to InitCmUToA
(b) create the wrapper function DoSomethingAU in this file (maintain sort order).
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pba\00readme.txt ===
This file contains information about:
 
- working with the Phone Book Administrator (pbadmin.exe)
- packaging this into the PBA install package (pbainst.exe)

Working With the Phone Book Administrator
-----------------------------------------

This is a VB application.  To edit this, it is best to copy the 'source' subdirectory,
where the required files are located, to another directory, then edit the VB
project using Visual Basic (the current version used is VB6).  When done with editing,
compare the files with the originals, check out the ones that have changed and
check in the updated files.  You must also use Visual Basic to generate PBADMIN.exe,
which is checked in separately, see below.

Changing resource strings
-------------------------

This one is special :-)  Most of the string resources used by PBA are in a .res file,
pbadmin.res.  Look for the string you need to change - if it is actually in a form you
can just make the changes using VB6 (as above).

Otherwise, check out pba_res.rc for editing and make the changes needed. See if your
razzle window has a variable named INCLUDE, with the Windows header files on it.  If not:

>  set INCLUDE=%_NTDRIVE%%_NTROOT%\public\sdk\inc

Now build the new .res file:

>  nmake pba_res.res

Now check out pbadmin.res, and copy pba_res.res to pbadmin.res.  Using the new .res
file, start up VB6, generate PBADMIN.exe as above, and check in all the changes.

Creating the PBA install package
--------------------------------

To build this, you need several support files (which probably will not change),
as well as the PBADMIN.exe you've created above.  The required common files are
checked in under the 'buildit' subdirectory.  Under buildit, 'sources0' contains
"external" support files and 'sources1' contains other ("internal") support files.

PBAINST.exe is automatically built during the PostBuild process, using the script
%_NTBINDIR%\tools\PostBuildScripts\PbaInst.cmd.  In preparation for this, during
the compile phase any required files must be binplace'd to %_NTTREE%\PbaInst as
needed.  Once built, PBAINST.exe is placed in Valueadd\Msft\Mgmt\Pba.

Directory Structure
-------------------

\pba
    - contains 00README.txt (this file)
    - contains PBAINST.ex (which gets binplaced into %_NTTREE%\PbaInst)
    - contains README.HTM (which gets binplaced into %_NTTREE%\PbaInst)
      
\pba\source
    - contains VB project for pbadmin
        
\pba\buildit
    - contains .SED file needed to build PBAINST.exe
    
\pba\buildit\sources0
    - "external" support files (which get binplaced into %_NTTREE%\PbaInst\Sources0)
    
\pba\buildit\sources1
    - "internal" support files (which get binplaced into %_NTTREE%\PbaInst\Sources1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pba\buildit\sources1\country.txt ===
1,United States of America
101,Anguilla
102,Antigua
103,Bahamas
104,Barbados
105,Bermuda
106,British Virgin Islands
107,Canada
108,Cayman Islands
109,Dominica
110,Dominican Republic
111,Grenada
112,Jamaica
113,Montserrat
115,St. Kitts and Nevis
116,St. Vincent and the Grenadines
117,Trinidad and Tobago
118,Turks and Caicos Islands
120,Barbuda
121,Puerto Rico
122,Saint Lucia
123,United States Virgin Islands
124,Guam
20,Egypt
212,Morocco
213,Algeria
216,Tunisia
218,Libya
220,Gambia
221,Senegal
222,Mauritania
223,Mali
224,Guinea
225,Cote d'Ivoire
226,Burkina Faso
227,Niger
228,Togo
229,Benin
230,Mauritius
231,Liberia
232,Sierra Leone
233,Ghana
234,Nigeria
235,Chad
236,Central African Republic
237,Cameroon
238,Cape Verde
239,Sao Tome and Principe
240,Equatorial Guinea
241,Gabon
242,Congo
243,Congo (DRC)
244,Angola
245,Guinea-Bissau
246,Diego Garcia
247,Ascension Island
248,Seychelle Islands
249,Sudan
250,Rwanda
251,Ethiopia
252,Somalia
253,Djibouti
254,Kenya
255,Tanzania
256,Uganda
257,Burundi
258,Mozambique
260,Zambia
261,Madagascar
262,Reunion Island
263,Zimbabwe
264,Namibia
265,Malawi
266,Lesotho
267,Botswana
268,Swaziland
269,Mayotte
2691,Comoros
27,South Africa
290,St. Helena
291,Eritrea
297,Aruba
298,Faroe Islands
299,Greenland
30,Greece
31,Netherlands
32,Belgium
33,France
34,Spain
350,Gibraltar
351,Portugal
352,Luxembourg
353,Ireland
354,Iceland
355,Albania
356,Malta
357,Cyprus
358,Finland
359,Bulgaria
36,Hungary
370,Lithuania
371,Latvia
372,Estonia
373,Moldova
374,Armenia
375,Belarus
376,Andorra
377,Monaco
378,San Marino
379,Vatican City
380,Ukraine
381,Yugoslavia
385,Croatia
386,Slovenia
387,Bosnia and Herzegovina
389,F.Y.R.O.M. (Former Yugoslav Republic of Macedonia)
39,Italy
40,Romania
41,Switzerland
420,Czech Republic
421,Slovak Republic
423,Liechtenstein
43,Austria
44,United Kingdom
45,Denmark
46,Sweden
47,Norway
48,Poland
49,Germany
500,Falkland Islands (Islas Malvinas)
501,Belize
502,Guatemala
503,El Salvador
504,Honduras
505,Nicaragua
506,Costa Rica
507,Panama
508,St. Pierre and Miquelon
509,Haiti
51,Peru
52,Mexico
53,Cuba
5399,Guantanamo Bay
54,Argentina
55,Brazil
56,Chile
57,Colombia
58,Venezuela
590,Guadeloupe
5901,French Antilles
591,Bolivia
592,Guyana
593,Ecuador
594,French Guiana
595,Paraguay
596,Martinique
597,Suriname
598,Uruguay
599,Netherlands Antilles
60,Malaysia
61,Australia
6101,Cocos-Keeling Islands
62,Indonesia
63,Philippines
64,New Zealand
65,Singapore
66,Thailand
670,East Timor
672,Christmas Island
6722,Norfolk Island
673,Brunei
674,Nauru
675,Papua New Guinea
676,Tonga
677,Solomon Islands
678,Vanuatu
679,Fiji Islands
680,Palau
681,Wallis and Futuna Islands
682,Cook Islands
683,Niue
684,American Samoa
685,Samoa
686,Kiribati Republic
687,New Caledonia
688,Tuvalu
689,French Polynesia
690,Tokelau
691,Micronesia, Federated States of
692,Marshall Islands
7,Russia
705,Kazakhstan
800,International Freephone Service
81,Japan
82,Korea (Republic of)
84,Vietnam
850,Korea (North)
852,Hong Kong S.A.R.
853,Macau S.A.R.
855,Cambodia
856,Lao P.D.R.
86,China
870,INMARSAT
871,INMARSAT (Atlantic-East)
872,INMARSAT (Pacific)
873,INMARSAT (Indian)
874,INMARSAT (Atlantic-West)
880,Bangladesh
886,Taiwan
90,Turkey
91,India
92,Pakistan
93,Afghanistan
94,Sri Lanka
95,Myanmar
960,Maldives
961,Lebanon
962,Jordan
963,Syria
964,Iraq
965,Kuwait
966,Saudi Arabia
967,Yemen
968,Oman
971,United Arab Emirates
972,Israel
973,Bahrain
974,Qatar
975,Bhutan
976,Mongolia
977,Nepal
98,Iran
992,Tajikistan
993,Turkmenistan
994,Azerbaijan
995,Georgia
996,Kyrgyz Republic
998,Uzbekistan
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pba\buildit\placefil.txt ===
pbainst.sed    pbainst
readme.htm     pbainst
comctl32.ocx   pbainst\sources0
comdlg32.ocx   pbainst\sources0
cps_ops.chm    pbainst\sources0
msinet.ocx     pbainst\sources0
pbadmin.hlp    pbainst\sources0
pbserver.mdb   pbainst\sources0
tabctl32.ocx   pbainst\sources0
base.ddf       pbainst\sources1
country.txt    pbainst\sources1
dta.bat        pbainst\sources1
dta.ddf        pbainst\sources1
empty_pb.mdb   pbainst\sources1
full.bat       pbainst\sources1
full.ddf       pbainst\sources1
hhwrap.dll     pbainst\sources1
pbadmin.exe    pbainst\sources1
pbainst.exe    pbainst\sources1
pbasetup.exe   pbainst\sources1
pbasetup.inf   pbainst\sources1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pba\source\pbadmin.ini ===
[General]
LastPhonebookUsed=wilbur

[Phonebooks]
five=five.mdb
just try=just try.mdb
new one=new one.mdb
three copy=three copy.mdb
bigbook2=bigbook2.mdb
new=new.mdb
copy of new=copy of new.mdb
Test2=Test2.mdb
Test1=Test1.mdb
NewTest=NewTest.mdb
wilbur=wilbur.mdb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbserver\readme_debugging.txt ===
PBS (Phone Book Server) is an ISAPI dll, and debugging it is something of a challenge.

PBS runs "out-of-process", in dllhost.exe.  The first step is to change the identity PBS
runs under, so that we can attach a debugger.

1. From the "Start" menu, go to "Programs" and "Administrative Tools". Pick "Component Services".
2. Navigate to "Console Root"->"Component Services"->"Computers"->"My Computer"->"COM+ Applications".
3. Right click on "IIS Out-Of-Process Pooled Applications" and pick "Properties".
4. On the "Identity" page, select "Interactive user - the current logged on user".
5. Click "OK". 

Now, to actually debug:

1. Shut down IIS by running "net stop iisadmin /y" from a console.
2. Use the "Component Services" tool to configure the OOP pool to start under a debugger.
2a. From the "Start" menu, go to "Programs" and "Administrative Tools". Pick "Component Services".
2b. Navigate to "Console Root"->"Component Services"->"Computers"->"My Computer"->"COM+ Applications".
2c. Right click on "IIS Out-Of-Process Pooled Applications" and pick "Properties"
2d. On the "Advanced" page, check "Launch in debugger".
2e. In the "Debugger Path" text box, type in the path to msdev.exe as the first argument (the second
argument will be "dllhost.exe" and the third will be "/ProcessID:" - these arguments will already
be present in the box).
2f. Click "OK", and say "Yes" to the warning about applications created by...
3. Start the server with "net start w3svc" from a console. 

Once you're done debugging, you'll want to get PBS back to where it was before you started.  To do
so, run this script (it's already on your machine).

    \Inetpub\AdminScripts\synciwam.vbs

This sets the identity for PBS (and all other ISAPIs) back to the !IWAM account that IIS was
using before you changed it above.

Owners and websites change so the following information may be outdated, but at the time of writing (Feb 2001):
- the above information is condensed from : http://caress_of_steel/isapi5debugging.htm
- Mr. ISAPI is Wade Hilmo (WadeH)
- Cindy Du (XinliD) and Bhavesh Doshi (BhaveshD) have also been very helpful.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cps\pbsmon\cpssym.ini ===
[info]
  drivername=PBServerMonitor
  symbolfile=CpsSym.h
  trusted=

  [languages]
  004=Chinese
  007=German
  009=English
  00A=Spanish
  00C=French
  011=Japanese
  012=Korean
  013=Dutch
  016=Portuguese
  01D=Swedish

  [text]
  ;004
  OBJECT_CPS_SERVER_004_NAME=PBServer Monitor
  OBJECT_CPS_SERVER_004_HELP=Displays performance statistics

  COUNTER_TOTAL_HITS_004_NAME=Total Hits
  COUNTER_TOTAL_HITS_004_HELP=Displays total number of hits

  COUNTER_NO_UPGRADE_004_NAME=No Upgrade Hits
  COUNTER_NO_UPGRADE_004_HELP=Displays number of no-upgrade-hits since the server started

  COUNTER_DELTA_UPGRADE_004_NAME=Delta Upgrade Hits
  COUNTER_DELTA_UPGRADE_004_HELP=Displays number of delta-upgrade-hits

  COUNTER_FULL_UPGRADE_004_NAME=Full Upgrade Hits
  COUNTER_FULL_UPGRADE_004_HELP=Displays number of full-upgrade-hits
	
  COUNTER_ERRORS_004_NAME=Error Hits	
  COUNTER_ERRORS_004_HELP=Diaplays the number of hits resulting in errors

  COUNTER_TOTAL_HITS_PER_SEC_004_NAME=Total Hits/Sec
  COUNTER_TOTAL_HITS_PER_SEC_004_HELP=Displays total number of hits/sec

  COUNTER_NO_UPGRADE_PER_SEC_004_NAME=No Upgrade Hits/Sec
  COUNTER_NO_UPGRADE_PER_SEC_004_HELP=Displays number of no-upgrade-hits/sec

  COUNTER_DELTA_UPGRADE_PER_SEC_004_NAME=Delta Upgrade Hits/Sec
  COUNTER_DELTA_UPGRADE_PER_SEC_004_HELP=Displays number of delta-upgrade-hits/sec

  COUNTER_FULL_UPGRADE_PER_SEC_004_NAME=Full Upgrade Hits/Sec
  COUNTER_FULL_UPGRADE_PER_SEC_004_HELP=Displays number of full-upgrade-hits/sec

  COUNTER_ERRORS_PER_SEC_004_NAME=Error Hits/Sec	
  COUNTER_ERRORS_PER_SEC_004_HELP=Diaplays the number of hits resulting in errors/Sec

  ;007
  OBJECT_CPS_SERVER_007_NAME=PBServer Monitor
  OBJECT_CPS_SERVER_007_HELP=Displays performance statistics

  COUNTER_TOTAL_HITS_007_NAME=Total Hits
  COUNTER_TOTAL_HITS_007_HELP=Displays total number of hits

  COUNTER_NO_UPGRADE_007_NAME=No Upgrade Hits
  COUNTER_NO_UPGRADE_007_HELP=Displays number of no-upgrade-hits since the server started

  COUNTER_DELTA_UPGRADE_007_NAME=Delta Upgrade Hits
  COUNTER_DELTA_UPGRADE_007_HELP=Displays number of delta-upgrade-hits

  COUNTER_FULL_UPGRADE_007_NAME=Full Upgrade Hits
  COUNTER_FULL_UPGRADE_007_HELP=Displays number of full-upgrade-hits
	
  COUNTER_ERRORS_007_NAME=Error Hits	
  COUNTER_ERRORS_007_HELP=Diaplays the number of hits resulting in errors

  COUNTER_TOTAL_HITS_PER_SEC_007_NAME=Total Hits/Sec
  COUNTER_TOTAL_HITS_PER_SEC_007_HELP=Displays total number of hits/sec

  COUNTER_NO_UPGRADE_PER_SEC_007_NAME=No Upgrade Hits/Sec
  COUNTER_NO_UPGRADE_PER_SEC_007_HELP=Displays number of no-upgrade-hits/sec

  COUNTER_DELTA_UPGRADE_PER_SEC_007_NAME=Delta Upgrade Hits/Sec
  COUNTER_DELTA_UPGRADE_PER_SEC_007_HELP=Displays number of delta-upgrade-hits/sec

  COUNTER_FULL_UPGRADE_PER_SEC_007_NAME=Full Upgrade Hits/Sec
  COUNTER_FULL_UPGRADE_PER_SEC_007_HELP=Displays number of full-upgrade-hits/sec

  COUNTER_ERRORS_PER_SEC_007_NAME=Error Hits/Sec	
  COUNTER_ERRORS_PER_SEC_007_HELP=Diaplays the number of hits resulting in errors/Sec

  ;009
  OBJECT_CPS_SERVER_009_NAME=PBServer Monitor
  OBJECT_CPS_SERVER_009_HELP=Displays performance statistics

  COUNTER_TOTAL_HITS_009_NAME=Total Hits
  COUNTER_TOTAL_HITS_009_HELP=Displays total number of hits

  COUNTER_NO_UPGRADE_009_NAME=No Upgrade Hits
  COUNTER_NO_UPGRADE_009_HELP=Displays number of no-upgrade-hits since the server started

  COUNTER_DELTA_UPGRADE_009_NAME=Delta Upgrade Hits
  COUNTER_DELTA_UPGRADE_009_HELP=Displays number of delta-upgrade-hits

  COUNTER_FULL_UPGRADE_009_NAME=Full Upgrade Hits
  COUNTER_FULL_UPGRADE_009_HELP=Displays number of full-upgrade-hits
	
  COUNTER_ERRORS_009_NAME=Error Hits	
  COUNTER_ERRORS_009_HELP=Diaplays the number of hits resulting in errors

  COUNTER_TOTAL_HITS_PER_SEC_009_NAME=Total Hits/Sec
  COUNTER_TOTAL_HITS_PER_SEC_009_HELP=Displays total number of hits/sec

  COUNTER_NO_UPGRADE_PER_SEC_009_NAME=No Upgrade Hits/Sec
  COUNTER_NO_UPGRADE_PER_SEC_009_HELP=Displays number of no-upgrade-hits/sec

  COUNTER_DELTA_UPGRADE_PER_SEC_009_NAME=Delta Upgrade Hits/Sec
  COUNTER_DELTA_UPGRADE_PER_SEC_009_HELP=Displays number of delta-upgrade-hits/sec

  COUNTER_FULL_UPGRADE_PER_SEC_009_NAME=Full Upgrade Hits/Sec
  COUNTER_FULL_UPGRADE_PER_SEC_009_HELP=Displays number of full-upgrade-hits/sec

  COUNTER_ERRORS_PER_SEC_009_NAME=Error Hits/Sec	
  COUNTER_ERRORS_PER_SEC_009_HELP=Diaplays the number of hits resulting in errors/Sec

  ;00A
  OBJECT_CPS_SERVER_00A_NAME=PBServer Monitor
  OBJECT_CPS_SERVER_00A_HELP=Displays performance statistics

  COUNTER_TOTAL_HITS_00A_NAME=Total Hits
  COUNTER_TOTAL_HITS_00A_HELP=Displays total number of hits

  COUNTER_NO_UPGRADE_00A_NAME=No Upgrade Hits
  COUNTER_NO_UPGRADE_00A_HELP=Displays number of no-upgrade-hits since the server started

  COUNTER_DELTA_UPGRADE_00A_NAME=Delta Upgrade Hits
  COUNTER_DELTA_UPGRADE_00A_HELP=Displays number of delta-upgrade-hits

  COUNTER_FULL_UPGRADE_00A_NAME=Full Upgrade Hits
  COUNTER_FULL_UPGRADE_00A_HELP=Displays number of full-upgrade-hits
	
  COUNTER_ERRORS_00A_NAME=Error Hits	
  COUNTER_ERRORS_00A_HELP=Diaplays the number of hits resulting in errors

  COUNTER_TOTAL_HITS_PER_SEC_00A_NAME=Total Hits/Sec
  COUNTER_TOTAL_HITS_PER_SEC_00A_HELP=Displays total number of hits/sec

  COUNTER_NO_UPGRADE_PER_SEC_00A_NAME=No Upgrade Hits/Sec
  COUNTER_NO_UPGRADE_PER_SEC_00A_HELP=Displays number of no-upgrade-hits/sec

  COUNTER_DELTA_UPGRADE_PER_SEC_00A_NAME=Delta Upgrade Hits/Sec
  COUNTER_DELTA_UPGRADE_PER_SEC_00A_HELP=Displays number of delta-upgrade-hits/sec

  COUNTER_FULL_UPGRADE_PER_SEC_00A_NAME=Full Upgrade Hits/Sec
  COUNTER_FULL_UPGRADE_PER_SEC_00A_HELP=Displays number of full-upgrade-hits/sec

  COUNTER_ERRORS_PER_SEC_00A_NAME=Error Hits/Sec	
  COUNTER_ERRORS_PER_SEC_00A_HELP=Diaplays the number of hits resulting in errors/Sec

  ;00C
  OBJECT_CPS_SERVER_00C_NAME=PBServer Monitor
  OBJECT_CPS_SERVER_00C_HELP=Displays performance statistics

  COUNTER_TOTAL_HITS_00C_NAME=Total Hits
  COUNTER_TOTAL_HITS_00C_HELP=Displays total number of hits

  COUNTER_NO_UPGRADE_00C_NAME=No Upgrade Hits
  COUNTER_NO_UPGRADE_00C_HELP=Displays number of no-upgrade-hits since the server started

  COUNTER_DELTA_UPGRADE_00C_NAME=Delta Upgrade Hits
  COUNTER_DELTA_UPGRADE_00C_HELP=Displays number of delta-upgrade-hits

  COUNTER_FULL_UPGRADE_00C_NAME=Full Upgrade Hits
  COUNTER_FULL_UPGRADE_00C_HELP=Displays number of full-upgrade-hits
	
  COUNTER_ERRORS_00C_NAME=Error Hits	
  COUNTER_ERRORS_00C_HELP=Diaplays the number of hits resulting in errors

  COUNTER_TOTAL_HITS_PER_SEC_00C_NAME=Total Hits/Sec
  COUNTER_TOTAL_HITS_PER_SEC_00C_HELP=Displays total number of hits/sec

  COUNTER_NO_UPGRADE_PER_SEC_00C_NAME=No Upgrade Hits/Sec
  COUNTER_NO_UPGRADE_PER_SEC_00C_HELP=Displays number of no-upgrade-hits/sec

  COUNTER_DELTA_UPGRADE_PER_SEC_00C_NAME=Delta Upgrade Hits/Sec
  COUNTER_DELTA_UPGRADE_PER_SEC_00C_HELP=Displays number of delta-upgrade-hits/sec

  COUNTER_FULL_UPGRADE_PER_SEC_00C_NAME=Full Upgrade Hits/Sec
  COUNTER_FULL_UPGRADE_PER_SEC_00C_HELP=Displays number of full-upgrade-hits/sec

  COUNTER_ERRORS_PER_SEC_00C_NAME=Error Hits/Sec	
  COUNTER_ERRORS_PER_SEC_00C_HELP=Diaplays the number of hits resulting in errors/Sec

  ;011
  OBJECT_CPS_SERVER_011_NAME=PBServer Monitor
  OBJECT_CPS_SERVER_011_HELP=Displays performance statistics

  COUNTER_TOTAL_HITS_011_NAME=Total Hits
  COUNTER_TOTAL_HITS_011_HELP=Displays total number of hits

  COUNTER_NO_UPGRADE_011_NAME=No Upgrade Hits
  COUNTER_NO_UPGRADE_011_HELP=Displays number of no-upgrade-hits since the server started

  COUNTER_DELTA_UPGRADE_011_NAME=Delta Upgrade Hits
  COUNTER_DELTA_UPGRADE_011_HELP=Displays number of delta-upgrade-hits

  COUNTER_FULL_UPGRADE_011_NAME=Full Upgrade Hits
  COUNTER_FULL_UPGRADE_011_HELP=Displays number of full-upgrade-hits
	
  COUNTER_ERRORS_011_NAME=Error Hits	
  COUNTER_ERRORS_011_HELP=Diaplays the number of hits resulting in errors

  COUNTER_TOTAL_HITS_PER_SEC_011_NAME=Total Hits/Sec
  COUNTER_TOTAL_HITS_PER_SEC_011_HELP=Displays total number of hits/sec

  COUNTER_NO_UPGRADE_PER_SEC_011_NAME=No Upgrade Hits/Sec
  COUNTER_NO_UPGRADE_PER_SEC_011_HELP=Displays number of no-upgrade-hits/sec

  COUNTER_DELTA_UPGRADE_PER_SEC_011_NAME=Delta Upgrade Hits/Sec
  COUNTER_DELTA_UPGRADE_PER_SEC_011_HELP=Displays number of delta-upgrade-hits/sec

  COUNTER_FULL_UPGRADE_PER_SEC_011_NAME=Full Upgrade Hits/Sec
  COUNTER_FULL_UPGRADE_PER_SEC_011_HELP=Displays number of full-upgrade-hits/sec

  COUNTER_ERRORS_PER_SEC_011_NAME=Error Hits/Sec	
  COUNTER_ERRORS_PER_SEC_011_HELP=Diaplays the number of hits resulting in errors/Sec

  ;012
  OBJECT_CPS_SERVER_012_NAME=PBServer Monitor
  OBJECT_CPS_SERVER_012_HELP=Displays performance statistics

  COUNTER_TOTAL_HITS_012_NAME=Total Hits
  COUNTER_TOTAL_HITS_012_HELP=Displays total number of hits

  COUNTER_NO_UPGRADE_012_NAME=No Upgrade Hits
  COUNTER_NO_UPGRADE_012_HELP=Displays number of no-upgrade-hits since the server started

  COUNTER_DELTA_UPGRADE_012_NAME=Delta Upgrade Hits
  COUNTER_DELTA_UPGRADE_012_HELP=Displays number of delta-upgrade-hits

  COUNTER_FULL_UPGRADE_012_NAME=Full Upgrade Hits
  COUNTER_FULL_UPGRADE_012_HELP=Displays number of full-upgrade-hits
	
  COUNTER_ERRORS_012_NAME=Error Hits	
  COUNTER_ERRORS_012_HELP=Diaplays the number of hits resulting in errors

  COUNTER_TOTAL_HITS_PER_SEC_012_NAME=Total Hits/Sec
  COUNTER_TOTAL_HITS_PER_SEC_012_HELP=Displays total number of hits/sec

  COUNTER_NO_UPGRADE_PER_SEC_012_NAME=No Upgrade Hits/Sec
  COUNTER_NO_UPGRADE_PER_SEC_012_HELP=Displays number of no-upgrade-hits/sec

  COUNTER_DELTA_UPGRADE_PER_SEC_012_NAME=Delta Upgrade Hits/Sec
  COUNTER_DELTA_UPGRADE_PER_SEC_012_HELP=Displays number of delta-upgrade-hits/sec

  COUNTER_FULL_UPGRADE_PER_SEC_012_NAME=Full Upgrade Hits/Sec
  COUNTER_FULL_UPGRADE_PER_SEC_012_HELP=Displays number of full-upgrade-hits/sec

  COUNTER_ERRORS_PER_SEC_012_NAME=Error Hits/Sec	
  COUNTER_ERRORS_PER_SEC_012_HELP=Diaplays the number of hits resulting in errors/Sec

  ;013
  OBJECT_CPS_SERVER_013_NAME=PBServer Monitor
  OBJECT_CPS_SERVER_013_HELP=Displays performance statistics

  COUNTER_TOTAL_HITS_013_NAME=Total Hits
  COUNTER_TOTAL_HITS_013_HELP=Displays total number of hits

  COUNTER_NO_UPGRADE_013_NAME=No Upgrade Hits
  COUNTER_NO_UPGRADE_013_HELP=Displays number of no-upgrade-hits since the server started

  COUNTER_DELTA_UPGRADE_013_NAME=Delta Upgrade Hits
  COUNTER_DELTA_UPGRADE_013_HELP=Displays number of delta-upgrade-hits

  COUNTER_FULL_UPGRADE_013_NAME=Full Upgrade Hits
  COUNTER_FULL_UPGRADE_013_HELP=Displays number of full-upgrade-hits
	
  COUNTER_ERRORS_013_NAME=Error Hits	
  COUNTER_ERRORS_013_HELP=Diaplays the number of hits resulting in errors

  COUNTER_TOTAL_HITS_PER_SEC_013_NAME=Total Hits/Sec
  COUNTER_TOTAL_HITS_PER_SEC_013_HELP=Displays total number of hits/sec

  COUNTER_NO_UPGRADE_PER_SEC_013_NAME=No Upgrade Hits/Sec
  COUNTER_NO_UPGRADE_PER_SEC_013_HELP=Displays number of no-upgrade-hits/sec

  COUNTER_DELTA_UPGRADE_PER_SEC_013_NAME=Delta Upgrade Hits/Sec
  COUNTER_DELTA_UPGRADE_PER_SEC_013_HELP=Displays number of delta-upgrade-hits/sec

  COUNTER_FULL_UPGRADE_PER_SEC_013_NAME=Full Upgrade Hits/Sec
  COUNTER_FULL_UPGRADE_PER_SEC_013_HELP=Displays number of full-upgrade-hits/sec

  COUNTER_ERRORS_PER_SEC_013_NAME=Error Hits/Sec	
  COUNTER_ERRORS_PER_SEC_013_HELP=Diaplays the number of hits resulting in errors/Sec

  ;016
  OBJECT_CPS_SERVER_016_NAME=PBServer Monitor
  OBJECT_CPS_SERVER_016_HELP=Displays performance statistics

  COUNTER_TOTAL_HITS_016_NAME=Total Hits
  COUNTER_TOTAL_HITS_016_HELP=Displays total number of hits

  COUNTER_NO_UPGRADE_016_NAME=No Upgrade Hits
  COUNTER_NO_UPGRADE_016_HELP=Displays number of no-upgrade-hits since the server started

  COUNTER_DELTA_UPGRADE_016_NAME=Delta Upgrade Hits
  COUNTER_DELTA_UPGRADE_016_HELP=Displays number of delta-upgrade-hits

  COUNTER_FULL_UPGRADE_016_NAME=Full Upgrade Hits
  COUNTER_FULL_UPGRADE_016_HELP=Displays number of full-upgrade-hits
	
  COUNTER_ERRORS_016_NAME=Error Hits	
  COUNTER_ERRORS_016_HELP=Diaplays the number of hits resulting in errors

  COUNTER_TOTAL_HITS_PER_SEC_016_NAME=Total Hits/Sec
  COUNTER_TOTAL_HITS_PER_SEC_016_HELP=Displays total number of hits/sec

  COUNTER_NO_UPGRADE_PER_SEC_016_NAME=No Upgrade Hits/Sec
  COUNTER_NO_UPGRADE_PER_SEC_016_HELP=Displays number of no-upgrade-hits/sec

  COUNTER_DELTA_UPGRADE_PER_SEC_016_NAME=Delta Upgrade Hits/Sec
  COUNTER_DELTA_UPGRADE_PER_SEC_016_HELP=Displays number of delta-upgrade-hits/sec

  COUNTER_FULL_UPGRADE_PER_SEC_016_NAME=Full Upgrade Hits/Sec
  COUNTER_FULL_UPGRADE_PER_SEC_016_HELP=Displays number of full-upgrade-hits/sec

  COUNTER_ERRORS_PER_SEC_016_NAME=Error Hits/Sec	
  COUNTER_ERRORS_PER_SEC_016_HELP=Diaplays the number of hits resulting in errors/Sec

  ;01D
  OBJECT_CPS_SERVER_01D_NAME=PBServer Monitor
  OBJECT_CPS_SERVER_01D_HELP=Displays performance statistics

  COUNTER_TOTAL_HITS_01D_NAME=Total Hits
  COUNTER_TOTAL_HITS_01D_HELP=Displays total number of hits

  COUNTER_NO_UPGRADE_01D_NAME=No Upgrade Hits
  COUNTER_NO_UPGRADE_01D_HELP=Displays number of no-upgrade-hits since the server started

  COUNTER_DELTA_UPGRADE_01D_NAME=Delta Upgrade Hits
  COUNTER_DELTA_UPGRADE_01D_HELP=Displays number of delta-upgrade-hits

  COUNTER_FULL_UPGRADE_01D_NAME=Full Upgrade Hits
  COUNTER_FULL_UPGRADE_01D_HELP=Displays number of full-upgrade-hits
	
  COUNTER_ERRORS_01D_NAME=Error Hits	
  COUNTER_ERRORS_01D_HELP=Diaplays the number of hits resulting in errors

  COUNTER_TOTAL_HITS_PER_SEC_01D_NAME=Total Hits/Sec
  COUNTER_TOTAL_HITS_PER_SEC_01D_HELP=Displays total number of hits/sec

  COUNTER_NO_UPGRADE_PER_SEC_01D_NAME=No Upgrade Hits/Sec
  COUNTER_NO_UPGRADE_PER_SEC_01D_HELP=Displays number of no-upgrade-hits/sec

  COUNTER_DELTA_UPGRADE_PER_SEC_01D_NAME=Delta Upgrade Hits/Sec
  COUNTER_DELTA_UPGRADE_PER_SEC_01D_HELP=Displays number of delta-upgrade-hits/sec

  COUNTER_FULL_UPGRADE_PER_SEC_01D_NAME=Full Upgrade Hits/Sec
  COUNTER_FULL_UPGRADE_PER_SEC_01D_HELP=Displays number of full-upgrade-hits/sec

  COUNTER_ERRORS_PER_SEC_01D_NAME=Error Hits/Sec	
  COUNTER_ERRORS_PER_SEC_01D_HELP=Diaplays the number of hits resulting in errors/Sec
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\ipinip\ipinip.ini ===
\Registry\Machine
    System
      CurrentControlSet
        Services
            IPINIP
                DisplayName = REG_SZ IP in IP Tunnel Driver
                DependOnService = REG_MULTI_SZ Tcpip
                ErrorControl = REG_DWORD 0x1
                Group = REG_SZ PNP_TDI
                ImagePath = REG_EXPAND_SZ \SystemRoot\system32\drivers\ipinip.sys
                Start = REG_DWORD 0x3
                Type = REG_DWORD 0x1

                Parameters
                    DebugBreak = REG_DWORD 0
                    DebugLevel = REG_DWORD 0x00
                    DebugComp  = REG_DWORD 0xFFFFFFFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\ipnat.ini ===
\Registry\Machine
    Software
        Microsoft
            Router
                CurrentVersion
                    RouterManagers
                        IP
                            IPNAT
                                ConfigDll = REG_SZ ipadmin.dll
                                ProtocolId = REG_DWORD 0xffff0008
                                Title = REG_SZ IP Network Address Translator
    System
      CurrentControlSet
        Services
            IPNAT
                DisplayName = REG_SZ IP Network Address Translator
                ErrorControl = REG_DWORD 0x1
                ImagePath = REG_EXPAND_SZ \SystemRoot\system32\drivers\ipnat.sys
                Start = REG_DWORD 0x3
                Type = REG_DWORD 0x1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nat\direct\ipnatdir.ini ===
\registry\machine\system\currentcontrolset\services\ipnatdir
    DisplayName = REG_SZ NAT Sample Director
    ErrorControl = REG_DWORD 0x1
    ImagePath = REG_EXPAND_SZ \SystemRoot\system32\drivers\ipnatdir.sys
    Start = REG_DWORD 0x3
    Type = REG_DWORD 0x1
    Parameters
        ServerPort = REG_DWORD 80
        ServerProtocol = REG_SZ TCP
        ServerList = REG_MULTI_SZ "192.168.0.127"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dll\ipnathlp.ini ===
\Registry\Machine\
    Software
        Microsoft
            Router
               CurrentVersion
                 RouterManagers
                    IP
                        IPNAT
                            ProtocolId = REG_DWORD 0x81372715
                            Flags = REG_DWORD 0
                            Title = Connection Sharing
                            DLLName = IPNATHLP.DLL
                            ConfigDLL = REG_EXPAND_SZ ipadmin.dll
                            ConfigClsid = {C2FE450A-D6C2-11D0-A37B-00C04FC9DA04}
                            VendorName = Microsoft
                        AUTODHCP
                            ProtocolId = REG_DWORD 0x81372714
                            Flags = REG_DWORD 1
                            Title = DHCP Allocator
                            DLLName = IPNATHLP.DLL
                            ConfigDLL = REG_EXPAND_SZ ipadmin.dll
                            ConfigClsid = {C2FE450A-D6C2-11D0-A37B-00C04FC9DA04}
                            VendorName = Microsoft
                        DNSPROXY
                            ProtocolId = REG_DWORD 0x81372713
                            Flags = REG_DWORD 1
                            Title = DNS Proxy Agent
                            DLLName = IPNATHLP.DLL
                            ConfigDLL = REG_EXPAND_SZ ipadmin.dll
                            ConfigClsid = {C2FE450A-D6C2-11D0-A37B-00C04FC9DA04}
                            VendorName = Microsoft
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\todo.txt ===
1. Mark dest as holdown.
2. Write and supply export methods
3. Consider using entity specific ptr in route to store whether hold down has 
already been triggered.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\sample\ipsample.log ===
[1220] 15:40:05: Hello World!!!
[1220] 15:40:05: ip sample has successfully started
[1220] 15:40:05: StartProtocol 0
[1220] 15:40:05: Configuration Entry...
[1220] 15:40:05: ActivityCount 0, LogLevel 3, NumInterfaces 0
[1220] 15:40:05: Network Entry...
[1220] 15:40:05: Interface Table Size 0
[1220] 15:40:05: Interface Table...
[1220] 15:40:05: Index Sorted List...
[1220] 15:40:05: EventQueue...
[1220] 15:40:05: ...AddInterface 0
[1220] 15:40:05: Configuration Entry...
[1220] 15:40:05: ActivityCount 0, LogLevel 3, NumInterfaces 2
[1220] 15:40:05: Network Entry...
[1220] 15:40:05: Interface Table Size 2
[1220] 15:40:05: Interface Table...
[1220] 15:40:05: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:05: NumBindings 0
[1220] 15:40:05: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:05: Metric 1, NumPackets 0
[1220] 15:40:05: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:05: NumBindings 0
[1220] 15:40:05: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:05: Metric 1, NumPackets 0
[1220] 15:40:05: Index Sorted List...
[1220] 15:40:05: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:05: NumBindings 0
[1220] 15:40:05: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:05: Metric 1, NumPackets 0
[1220] 15:40:05: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:05: NumBindings 0
[1220] 15:40:05: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:05: Metric 1, NumPackets 0
[1220] 15:40:05: EventQueue...
[1220] 15:40:05: ...BindInterface 0
[1220] 15:40:05: Configuration Entry...
[1220] 15:40:05: ActivityCount 0, LogLevel 3, NumInterfaces 2
[1220] 15:40:05: Network Entry...
[1220] 15:40:05: Interface Table Size 2
[1220] 15:40:05: Interface Table...
[1220] 15:40:05: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:05: NumBindings 3
[1220] 15:40:05: ipAddress 0.0.0.0
[1220] 15:40:05: ipMask 255.255.255.255
[1220] 15:40:05: ipAddress 0.0.0.0
[1220] 15:40:05: ipMask 255.255.255.255
[1220] 15:40:05: ipAddress 254.255.255.255
[1220] 15:40:05: ipMask 255.255.255.255
[1220] 15:40:05: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:05: Metric 1, NumPackets 0
[1220] 15:40:05: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:05: NumBindings 3
[1220] 15:40:05: ipAddress 1.0.0.0
[1220] 15:40:05: ipMask 255.255.255.255
[1220] 15:40:05: ipAddress 0.0.0.0
[1220] 15:40:05: ipMask 255.255.255.255
[1220] 15:40:05: ipAddress 254.255.255.255
[1220] 15:40:05: ipMask 255.255.255.255
[1220] 15:40:05: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:05: Metric 1, NumPackets 0
[1220] 15:40:05: Index Sorted List...
[1220] 15:40:05: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:05: NumBindings 3
[1220] 15:40:05: ipAddress 0.0.0.0
[1220] 15:40:05: ipMask 255.255.255.255
[1220] 15:40:05: ipAddress 0.0.0.0
[1220] 15:40:05: ipMask 255.255.255.255
[1220] 15:40:05: ipAddress 254.255.255.255
[1220] 15:40:05: ipMask 255.255.255.255
[1220] 15:40:05: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:05: Metric 1, NumPackets 0
[1220] 15:40:05: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:05: NumBindings 3
[1220] 15:40:05: ipAddress 1.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 0.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 254.255.255.255
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:06: Metric 1, NumPackets 0
[1220] 15:40:06: EventQueue...
[1220] 15:40:06: Error 10042 setting linger option on 0.0.0.0, continuing...
[1220] 15:40:06: Error 10042 setting linger option on 0.0.0.0, continuing...
[1220] 15:40:06: ...ActivateInterface 0
[1220] 15:40:06: Configuration Entry...
[1220] 15:40:06: ActivityCount 0, LogLevel 3, NumInterfaces 2
[1220] 15:40:06: Network Entry...
[1220] 15:40:06: Interface Table Size 2
[1220] 15:40:06: Interface Table...
[1220] 15:40:06: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:06: NumBindings 3
[1220] 15:40:06: ipAddress 0.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 0.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 254.255.255.255
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:06: Metric 1, NumPackets 0
[1220] 15:40:06: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:06: NumBindings 3
[1220] 15:40:06: ipAddress 1.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 0.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 254.255.255.255
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:06: Metric 1, NumPackets 0
[1220] 15:40:06: Index Sorted List...
[1220] 15:40:06: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:06: NumBindings 3
[1220] 15:40:06: ipAddress 0.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 0.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 254.255.255.255
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:06: Metric 1, NumPackets 0
[1220] 15:40:06: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:06: NumBindings 3
[1220] 15:40:06: ipAddress 1.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 0.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 254.255.255.255
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:06: Metric 1, NumPackets 0
[1220] 15:40:06: EventQueue...
[1220] 15:40:06: DidUpdateRoutes 3 0
[1220] 15:40:06: DidUpdateRoutes 3 0
[1220] 15:40:06: ...DoUpdateRoutes 0
[1220] 15:40:06: Configuration Entry...
[1220] 15:40:06: ActivityCount 0, LogLevel 3, NumInterfaces 2
[1220] 15:40:06: Network Entry...
[1220] 15:40:06: Interface Table Size 2
[1220] 15:40:06: Interface Table...
[1220] 15:40:06: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:06: NumBindings 3
[1220] 15:40:06: ipAddress 0.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 0.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 254.255.255.255
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:06: Metric 1, NumPackets 0
[1220] 15:40:06: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:06: NumBindings 3
[1220] 15:40:06: ipAddress 1.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 0.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 254.255.255.255
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:06: Metric 1, NumPackets 0
[1220] 15:40:06: Index Sorted List...
[1220] 15:40:06: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:06: NumBindings 3
[1220] 15:40:06: ipAddress 0.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 0.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 254.255.255.255
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:06: Metric 1, NumPackets 0
[1220] 15:40:06: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:06: NumBindings 3
[1220] 15:40:06: ipAddress 1.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:06: ipAddress 0.0.0.0
[1220] 15:40:06: ipMask 255.255.255.255
[1220] 15:40:07: ipAddress 254.255.255.255
[1220] 15:40:07: ipMask 255.255.255.255
[1220] 15:40:07: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:07: Metric 1, NumPackets 0
[1220] 15:40:07: EventQueue...
[1220] 15:40:07: Sleeping...
[1548] 15:40:10: Entering NM_CallbackNetworkEvent: 0
[1548] 15:40:10: Packet... Source 157.59.143.174, Length 32, Buffer 45000020336e000001c8785a9d3b8faee000006468656c6c6f20776f726c6421
[1548] 15:40:10: Leaving  NM_CallbackNetworkEvent
[1548] 15:40:10: Entering NM_CallbackNetworkEvent: 1
[1548] 15:40:10: Packet... Source 157.59.143.174, Length 32, Buffer 45000020336e000001c8785a9d3b8faee000006468656c6c6f20776f726c6421
[1548] 15:40:10: Leaving  NM_CallbackNetworkEvent
[1548] 15:40:11: Entering NM_CallbackPeriodicTimer: 0
[1548] 15:40:11: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[1548] 15:40:11: Leaving  NM_CallbackPeriodicTimer
[1548] 15:40:11: Entering NM_CallbackPeriodicTimer: 1
[1548] 15:40:11: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[1548] 15:40:11: Leaving  NM_CallbackPeriodicTimer
[652] 15:40:11: Entering SocketCallbackSendCompletion: 0 12 0x00772334
[652] 15:40:11: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[652] 15:40:11: Leaving  SocketCallbackSendCompletion
[652] 15:40:11: Entering SocketCallbackSendCompletion: 0 12 0x0077255c
[652] 15:40:11: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[652] 15:40:11: Leaving  SocketCallbackSendCompletion
[1548] 15:40:15: Entering NM_CallbackNetworkEvent: 0
[1548] 15:40:15: Packet... Source 157.59.143.174, Length 32, Buffer 450000203370000001c878589d3b8faee000006468656c6c6f20776f726c6421
[1548] 15:40:15: Leaving  NM_CallbackNetworkEvent
[536] 15:40:15: Entering NM_CallbackNetworkEvent: 1
[536] 15:40:15: Packet... Source 157.59.143.174, Length 32, Buffer 450000203370000001c878589d3b8faee000006468656c6c6f20776f726c6421
[536] 15:40:15: Leaving  NM_CallbackNetworkEvent
[536] 15:40:16: Entering NM_CallbackPeriodicTimer: 0
[536] 15:40:16: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[536] 15:40:16: Leaving  NM_CallbackPeriodicTimer
[652] 15:40:16: Entering SocketCallbackSendCompletion: 0 12 0x0077255c
[652] 15:40:16: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[652] 15:40:16: Leaving  SocketCallbackSendCompletion
[536] 15:40:16: Entering NM_CallbackPeriodicTimer: 1
[536] 15:40:16: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[536] 15:40:16: Leaving  NM_CallbackPeriodicTimer
[652] 15:40:16: Entering SocketCallbackSendCompletion: 0 12 0x0077255c
[652] 15:40:16: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[652] 15:40:16: Leaving  SocketCallbackSendCompletion
[536] 15:40:20: Entering NM_CallbackNetworkEvent: 0
[536] 15:40:20: Packet... Source 157.59.143.174, Length 32, Buffer 450000203374000001c878549d3b8faee000006468656c6c6f20776f726c6421
[536] 15:40:20: Leaving  NM_CallbackNetworkEvent
[536] 15:40:20: Entering NM_CallbackNetworkEvent: 1
[536] 15:40:20: Packet... Source 157.59.143.174, Length 32, Buffer 450000203374000001c878549d3b8faee000006468656c6c6f20776f726c6421
[536] 15:40:20: Leaving  NM_CallbackNetworkEvent
[536] 15:40:21: Entering NM_CallbackPeriodicTimer: 0
[536] 15:40:21: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[536] 15:40:21: Leaving  NM_CallbackPeriodicTimer
[652] 15:40:21: Entering SocketCallbackSendCompletion: 0 12 0x0077255c
[652] 15:40:21: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[652] 15:40:21: Leaving  SocketCallbackSendCompletion
[536] 15:40:21: Entering NM_CallbackPeriodicTimer: 1
[536] 15:40:21: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[536] 15:40:21: Leaving  NM_CallbackPeriodicTimer
[652] 15:40:21: Entering SocketCallbackSendCompletion: 0 12 0x0077255c
[652] 15:40:21: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[652] 15:40:21: Leaving  SocketCallbackSendCompletion
[1220] 15:40:22: ...Awake
[1220] 15:40:22: MIB SET: 1 1
[1220] 15:40:22: SetMib 1
[1220] 15:40:22: CM_GetGlobalInfo: *ulBufferSize 0
[1220] 15:40:22: MIB GET: 12 1 4
[1220] 15:40:22: MIB GET: 12 1 1
[1220] 15:40:22: MIB GET: 40 1 1 1
[1220] 15:40:22: MIB GET: 40 4 3 3 0
[1220] 15:40:22: MIB GET: 40 4 3 3
[1220] 15:40:22: MIB GET: 40 4 3 3 1
[1220] 15:40:22: MIB SET: 3
[1220] 15:40:22: SetMib 2
[1220] 15:40:22: NM_GetInterfaceInfo: *ulBufferSize 0
[1220] 15:40:22: MIB GET: 12 3 4
[1220] 15:40:22: MIB GET: 12 3 0
[1220] 15:40:22: ...MM_Test
[1220] 15:40:22: ...DeactivateInterface 0
[1220] 15:40:22: Configuration Entry...
[1220] 15:40:22: ActivityCount 0, LogLevel 1, NumInterfaces 2
[1220] 15:40:22: Network Entry...
[1220] 15:40:22: Interface Table Size 2
[1220] 15:40:22: Interface Table...
[1220] 15:40:22: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:22: NumBindings 3
[1220] 15:40:22: ipAddress 0.0.0.0
[1220] 15:40:22: ipMask 255.255.255.255
[1220] 15:40:22: ipAddress 0.0.0.0
[1220] 15:40:22: ipMask 255.255.255.255
[1220] 15:40:22: ipAddress 254.255.255.255
[1220] 15:40:22: ipMask 255.255.255.255
[1220] 15:40:22: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:22: Metric 0, NumPackets 3
[1220] 15:40:22: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:22: NumBindings 3
[1220] 15:40:22: ipAddress 1.0.0.0
[1220] 15:40:22: ipMask 255.255.255.255
[1220] 15:40:22: ipAddress 0.0.0.0
[1220] 15:40:22: ipMask 255.255.255.255
[1220] 15:40:22: ipAddress 254.255.255.255
[1220] 15:40:22: ipMask 255.255.255.255
[1220] 15:40:22: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:22: Metric 1, NumPackets 3
[1220] 15:40:22: Index Sorted List...
[1220] 15:40:22: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:22: NumBindings 3
[1220] 15:40:22: ipAddress 0.0.0.0
[1220] 15:40:22: ipMask 255.255.255.255
[1220] 15:40:22: ipAddress 0.0.0.0
[1220] 15:40:22: ipMask 255.255.255.255
[1220] 15:40:22: ipAddress 254.255.255.255
[1220] 15:40:22: ipMask 255.255.255.255
[1220] 15:40:22: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:22: Metric 0, NumPackets 3
[1220] 15:40:22: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:22: NumBindings 3
[1220] 15:40:22: ipAddress 1.0.0.0
[1220] 15:40:22: ipMask 255.255.255.255
[1220] 15:40:22: ipAddress 0.0.0.0
[1220] 15:40:22: ipMask 255.255.255.255
[1220] 15:40:22: ipAddress 254.255.255.255
[1220] 15:40:22: ipMask 255.255.255.255
[1220] 15:40:22: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:22: Metric 1, NumPackets 3
[1220] 15:40:22: EventQueue...
[1220] 15:40:22: ...UnbindInterface 0
[1220] 15:40:22: Configuration Entry...
[1220] 15:40:22: ActivityCount 0, LogLevel 1, NumInterfaces 2
[1220] 15:40:22: Network Entry...
[1220] 15:40:22: Interface Table Size 2
[1220] 15:40:22: Interface Table...
[1220] 15:40:22: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:22: NumBindings 0
[1220] 15:40:22: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:22: Metric 0, NumPackets 3
[1220] 15:40:22: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:22: NumBindings 0
[1220] 15:40:22: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:22: Metric 1, NumPackets 3
[1220] 15:40:22: Index Sorted List...
[1220] 15:40:22: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:22: NumBindings 0
[1220] 15:40:22: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:22: Metric 0, NumPackets 3
[1220] 15:40:22: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:22: NumBindings 0
[1220] 15:40:22: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:22: Metric 1, NumPackets 3
[1220] 15:40:22: EventQueue...
[1220] 15:40:22: ...DeleteInterface 0
[1220] 15:40:22: Configuration Entry...
[1220] 15:40:22: ActivityCount 0, LogLevel 1, NumInterfaces 0
[1220] 15:40:22: Network Entry...
[1220] 15:40:22: Interface Table Size 0
[1220] 15:40:22: Interface Table...
[1220] 15:40:22: Index Sorted List...
[1220] 15:40:22: EventQueue...
[1220] 15:40:22: ...NM_Test
[1220] 15:40:22: 0 threads are active in SAMPLE
[1220] 15:40:22: StopProtocol 907
[1220] 15:40:23: Configuration Entry...
[1220] 15:40:23: ActivityCount 0, LogLevel 1, NumInterfaces 0
[1220] 15:40:23: Network Entry...
[1220] 15:40:23: Interface Table Size 0
[1220] 15:40:23: Interface Table...
[1220] 15:40:23: Index Sorted List...
[1220] 15:40:23: EventQueue...
[536] 15:40:23: Entering WorkerFinishStopProtocol: active threads 0
[1220] 15:40:23: Stopped 0 0
[1220] 15:40:23: Configuration Entry...
[1220] 15:40:23: ActivityCount 0, LogLevel 1, NumInterfaces 0
[1220] 15:40:23: EventQueue...
[1220] 15:40:23: ...CM_Test (0)
[1220] 15:40:23: ip sample has successfully started
[1220] 15:40:23: StartProtocol 0
[1220] 15:40:23: Configuration Entry...
[1220] 15:40:23: ActivityCount 0, LogLevel 3, NumInterfaces 0
[1220] 15:40:23: Network Entry...
[1220] 15:40:23: Interface Table Size 0
[1220] 15:40:23: Interface Table...
[1220] 15:40:23: Index Sorted List...
[1220] 15:40:23: EventQueue...
[1220] 15:40:23: ...AddInterface 0
[1220] 15:40:23: Configuration Entry...
[1220] 15:40:23: ActivityCount 0, LogLevel 3, NumInterfaces 2
[1220] 15:40:23: Network Entry...
[1220] 15:40:23: Interface Table Size 2
[1220] 15:40:23: Interface Table...
[1220] 15:40:23: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:23: NumBindings 0
[1220] 15:40:23: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:23: Metric 1, NumPackets 0
[1220] 15:40:23: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:23: NumBindings 0
[1220] 15:40:23: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:23: Metric 1, NumPackets 0
[1220] 15:40:23: Index Sorted List...
[1220] 15:40:23: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:23: NumBindings 0
[1220] 15:40:23: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:23: Metric 1, NumPackets 0
[1220] 15:40:23: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:23: NumBindings 0
[1220] 15:40:23: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:23: Metric 1, NumPackets 0
[1220] 15:40:23: EventQueue...
[1220] 15:40:23: ...BindInterface 0
[1220] 15:40:23: Configuration Entry...
[1220] 15:40:23: ActivityCount 0, LogLevel 3, NumInterfaces 2
[1220] 15:40:23: Network Entry...
[1220] 15:40:23: Interface Table Size 2
[1220] 15:40:23: Interface Table...
[1220] 15:40:23: IfName if0, IfIndex 0, AccessType 0
[536] 15:40:23: Leaving  WorkerFinishStopProtocol
[1220] 15:40:23: NumBindings 3
[1220] 15:40:23: ipAddress 0.0.0.0
[1220] 15:40:23: ipMask 255.255.255.255
[1220] 15:40:23: ipAddress 0.0.0.0
[1220] 15:40:23: ipMask 255.255.255.255
[1220] 15:40:23: ipAddress 254.255.255.255
[1220] 15:40:23: ipMask 255.255.255.255
[1220] 15:40:23: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:23: Metric 1, NumPackets 0
[1220] 15:40:23: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:23: NumBindings 3
[1220] 15:40:23: ipAddress 1.0.0.0
[1220] 15:40:23: ipMask 255.255.255.255
[1220] 15:40:23: ipAddress 0.0.0.0
[1220] 15:40:23: ipMask 255.255.255.255
[1220] 15:40:23: ipAddress 254.255.255.255
[1220] 15:40:23: ipMask 255.255.255.255
[1220] 15:40:23: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:23: Metric 1, NumPackets 0
[1220] 15:40:23: Index Sorted List...
[1220] 15:40:23: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:23: NumBindings 3
[1220] 15:40:23: ipAddress 0.0.0.0
[1220] 15:40:23: ipMask 255.255.255.255
[1220] 15:40:23: ipAddress 0.0.0.0
[1220] 15:40:23: ipMask 255.255.255.255
[1220] 15:40:23: ipAddress 254.255.255.255
[1220] 15:40:23: ipMask 255.255.255.255
[1220] 15:40:23: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:23: Metric 1, NumPackets 0
[1220] 15:40:23: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:23: NumBindings 3
[1220] 15:40:23: ipAddress 1.0.0.0
[1220] 15:40:23: ipMask 255.255.255.255
[1220] 15:40:23: ipAddress 0.0.0.0
[1220] 15:40:23: ipMask 255.255.255.255
[1220] 15:40:23: ipAddress 254.255.255.255
[1220] 15:40:23: ipMask 255.255.255.255
[1220] 15:40:23: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:23: Metric 1, NumPackets 0
[1220] 15:40:23: EventQueue...
[1220] 15:40:23: Error 10042 setting linger option on 0.0.0.0, continuing...
[1220] 15:40:23: Error 10042 setting linger option on 0.0.0.0, continuing...
[1220] 15:40:23: ...ActivateInterface 0
[1220] 15:40:23: Configuration Entry...
[1220] 15:40:23: ActivityCount 0, LogLevel 3, NumInterfaces 2
[1220] 15:40:23: Network Entry...
[1220] 15:40:23: Interface Table Size 2
[1220] 15:40:23: Interface Table...
[1220] 15:40:24: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:24: NumBindings 3
[1220] 15:40:24: ipAddress 0.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 0.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 254.255.255.255
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:24: Metric 1, NumPackets 0
[1220] 15:40:24: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:24: NumBindings 3
[1220] 15:40:24: ipAddress 1.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 0.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 254.255.255.255
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:24: Metric 1, NumPackets 0
[1220] 15:40:24: Index Sorted List...
[1220] 15:40:24: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:24: NumBindings 3
[1220] 15:40:24: ipAddress 0.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 0.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 254.255.255.255
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:24: Metric 1, NumPackets 0
[1220] 15:40:24: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:24: NumBindings 3
[1220] 15:40:24: ipAddress 1.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 0.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 254.255.255.255
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:24: Metric 1, NumPackets 0
[1220] 15:40:24: EventQueue...
[1220] 15:40:24: DidUpdateRoutes 3 0
[1220] 15:40:24: DidUpdateRoutes 3 0
[1220] 15:40:24: ...DoUpdateRoutes 0
[1220] 15:40:24: Configuration Entry...
[1220] 15:40:24: ActivityCount 0, LogLevel 3, NumInterfaces 2
[1220] 15:40:24: Network Entry...
[1220] 15:40:24: Interface Table Size 2
[1220] 15:40:24: Interface Table...
[1220] 15:40:24: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:24: NumBindings 3
[1220] 15:40:24: ipAddress 0.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 0.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 254.255.255.255
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:24: Metric 1, NumPackets 0
[1220] 15:40:24: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:24: NumBindings 3
[1220] 15:40:24: ipAddress 1.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 0.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 254.255.255.255
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:24: Metric 1, NumPackets 0
[1220] 15:40:24: Index Sorted List...
[1220] 15:40:24: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:24: NumBindings 3
[1220] 15:40:24: ipAddress 0.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 0.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 254.255.255.255
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:24: Metric 1, NumPackets 0
[1220] 15:40:24: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:24: NumBindings 3
[1220] 15:40:24: ipAddress 1.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 0.0.0.0
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: ipAddress 254.255.255.255
[1220] 15:40:24: ipMask 255.255.255.255
[1220] 15:40:24: IfAddress 0.0.0.0 Flags 3
[1220] 15:40:24: Metric 1, NumPackets 0
[1220] 15:40:24: EventQueue...
[1220] 15:40:24: Sleeping...
[536] 15:40:25: Entering NM_CallbackNetworkEvent: 1
[536] 15:40:25: Packet... Source 157.59.143.174, Length 32, Buffer 45000020339e000001c8782a9d3b8faee000006468656c6c6f20776f726c6421
[536] 15:40:25: Leaving  NM_CallbackNetworkEvent
[536] 15:40:25: Entering NM_CallbackNetworkEvent: 0
[536] 15:40:25: Packet... Source 157.59.143.174, Length 32, Buffer 45000020339e000001c8782a9d3b8faee000006468656c6c6f20776f726c6421
[536] 15:40:25: Leaving  NM_CallbackNetworkEvent
[536] 15:40:29: Entering NM_CallbackPeriodicTimer: 0
[536] 15:40:29: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[536] 15:40:29: Leaving  NM_CallbackPeriodicTimer
[536] 15:40:29: Entering NM_CallbackPeriodicTimer: 1
[536] 15:40:29: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[536] 15:40:29: Leaving  NM_CallbackPeriodicTimer
[652] 15:40:29: Entering SocketCallbackSendCompletion: 0 12 0x0077255c
[652] 15:40:29: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[652] 15:40:29: Leaving  SocketCallbackSendCompletion
[652] 15:40:29: Entering SocketCallbackSendCompletion: 0 12 0x00772334
[652] 15:40:29: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[652] 15:40:29: Leaving  SocketCallbackSendCompletion
[536] 15:40:30: Entering NM_CallbackNetworkEvent: 1
[536] 15:40:30: Packet... Source 157.59.143.174, Length 32, Buffer 4500002033b1000001c878179d3b8faee000006468656c6c6f20776f726c6421
[536] 15:40:30: Leaving  NM_CallbackNetworkEvent
[536] 15:40:30: Entering NM_CallbackNetworkEvent: 0
[536] 15:40:30: Packet... Source 157.59.143.174, Length 32, Buffer 4500002033b1000001c878179d3b8faee000006468656c6c6f20776f726c6421
[536] 15:40:30: Leaving  NM_CallbackNetworkEvent
[536] 15:40:34: Entering NM_CallbackPeriodicTimer: 0
[536] 15:40:34: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[652] 15:40:34: Entering SocketCallbackSendCompletion: 0 12 0x00772334
[652] 15:40:34: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[652] 15:40:34: Leaving  SocketCallbackSendCompletion
[536] 15:40:34: Leaving  NM_CallbackPeriodicTimer
[536] 15:40:34: Entering NM_CallbackPeriodicTimer: 1
[536] 15:40:34: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[536] 15:40:34: Leaving  NM_CallbackPeriodicTimer
[652] 15:40:34: Entering SocketCallbackSendCompletion: 0 12 0x00772334
[652] 15:40:34: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[652] 15:40:34: Leaving  SocketCallbackSendCompletion
[536] 15:40:35: Entering NM_CallbackNetworkEvent: 1
[536] 15:40:35: Packet... Source 157.59.143.174, Length 32, Buffer 4500002033cc000001c877fc9d3b8faee000006468656c6c6f20776f726c6421
[536] 15:40:35: Leaving  NM_CallbackNetworkEvent
[536] 15:40:35: Entering NM_CallbackNetworkEvent: 0
[536] 15:40:35: Packet... Source 157.59.143.174, Length 32, Buffer 4500002033cc000001c877fc9d3b8faee000006468656c6c6f20776f726c6421
[536] 15:40:35: Leaving  NM_CallbackNetworkEvent
[536] 15:40:39: Entering NM_CallbackPeriodicTimer: 0
[536] 15:40:39: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[652] 15:40:39: Entering SocketCallbackSendCompletion: 0 12 0x00772334
[652] 15:40:39: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[536] 15:40:39: Leaving  NM_CallbackPeriodicTimer
[652] 15:40:39: Leaving  SocketCallbackSendCompletion
[536] 15:40:39: Entering NM_CallbackPeriodicTimer: 1
[536] 15:40:39: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[536] 15:40:39: Leaving  NM_CallbackPeriodicTimer
[652] 15:40:39: Entering SocketCallbackSendCompletion: 0 12 0x00772334
[652] 15:40:39: Packet... Source 0.0.0.0, Length 12, Buffer 68656c6c6f20776f726c6421
[652] 15:40:39: Leaving  SocketCallbackSendCompletion
[1220] 15:40:39: ...Awake
[1220] 15:40:39: MIB SET: 1 1
[1220] 15:40:39: SetMib 1
[1220] 15:40:39: CM_GetGlobalInfo: *ulBufferSize 0
[1220] 15:40:39: MIB GET: 12 1 4
[1220] 15:40:39: MIB GET: 12 1 1
[1220] 15:40:39: MIB GET: 40 1 1 1
[1220] 15:40:39: MIB GET: 40 4 3 3 0
[1220] 15:40:39: MIB GET: 40 4 3 3
[1220] 15:40:39: MIB GET: 40 4 3 3 1
[1220] 15:40:39: MIB SET: 3
[1220] 15:40:39: SetMib 2
[1220] 15:40:40: NM_GetInterfaceInfo: *ulBufferSize 0
[1220] 15:40:40: MIB GET: 12 3 4
[1220] 15:40:40: MIB GET: 12 3 0
[1220] 15:40:40: ...MM_Test
[1220] 15:40:40: ...DeactivateInterface 0
[1220] 15:40:40: Configuration Entry...
[1220] 15:40:40: ActivityCount 0, LogLevel 1, NumInterfaces 2
[1220] 15:40:40: Network Entry...
[1220] 15:40:40: Interface Table Size 2
[1220] 15:40:40: Interface Table...
[1220] 15:40:40: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:40: NumBindings 3
[1220] 15:40:40: ipAddress 0.0.0.0
[1220] 15:40:40: ipMask 255.255.255.255
[1220] 15:40:40: ipAddress 0.0.0.0
[1220] 15:40:40: ipMask 255.255.255.255
[1220] 15:40:40: ipAddress 254.255.255.255
[1220] 15:40:40: ipMask 255.255.255.255
[1220] 15:40:40: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:40: Metric 0, NumPackets 3
[1220] 15:40:40: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:40: NumBindings 3
[1220] 15:40:40: ipAddress 1.0.0.0
[1220] 15:40:40: ipMask 255.255.255.255
[1220] 15:40:40: ipAddress 0.0.0.0
[1220] 15:40:40: ipMask 255.255.255.255
[1220] 15:40:40: ipAddress 254.255.255.255
[1220] 15:40:40: ipMask 255.255.255.255
[1220] 15:40:40: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:40: Metric 1, NumPackets 3
[1220] 15:40:40: Index Sorted List...
[1220] 15:40:40: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:40: NumBindings 3
[1220] 15:40:40: ipAddress 0.0.0.0
[1220] 15:40:40: ipMask 255.255.255.255
[1220] 15:40:40: ipAddress 0.0.0.0
[1220] 15:40:40: ipMask 255.255.255.255
[1220] 15:40:40: ipAddress 254.255.255.255
[1220] 15:40:40: ipMask 255.255.255.255
[1220] 15:40:40: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:40: Metric 0, NumPackets 3
[1220] 15:40:40: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:40: NumBindings 3
[1220] 15:40:40: ipAddress 1.0.0.0
[1220] 15:40:40: ipMask 255.255.255.255
[1220] 15:40:40: ipAddress 0.0.0.0
[1220] 15:40:40: ipMask 255.255.255.255
[1220] 15:40:40: ipAddress 254.255.255.255
[1220] 15:40:40: ipMask 255.255.255.255
[1220] 15:40:40: IfAddress 0.0.0.0 Flags 2
[1220] 15:40:40: Metric 1, NumPackets 3
[1220] 15:40:40: EventQueue...
[1220] 15:40:40: ...UnbindInterface 0
[1220] 15:40:40: Configuration Entry...
[1220] 15:40:40: ActivityCount 0, LogLevel 1, NumInterfaces 2
[1220] 15:40:40: Network Entry...
[1220] 15:40:40: Interface Table Size 2
[1220] 15:40:40: Interface Table...
[1220] 15:40:40: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:40: NumBindings 0
[1220] 15:40:40: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:40: Metric 0, NumPackets 3
[1220] 15:40:40: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:40: NumBindings 0
[1220] 15:40:40: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:40: Metric 1, NumPackets 3
[1220] 15:40:40: Index Sorted List...
[1220] 15:40:40: IfName if0, IfIndex 0, AccessType 0
[1220] 15:40:40: NumBindings 0
[1220] 15:40:40: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:40: Metric 0, NumPackets 3
[1220] 15:40:40: IfName if1, IfIndex 1, AccessType 0
[1220] 15:40:40: NumBindings 0
[1220] 15:40:40: IfAddress 0.0.0.0 Flags 0
[1220] 15:40:40: Metric 1, NumPackets 3
[1220] 15:40:40: EventQueue...
[1220] 15:40:40: ...DeleteInterface 0
[1220] 15:40:40: Configuration Entry...
[1220] 15:40:40: ActivityCount 0, LogLevel 1, NumInterfaces 0
[1220] 15:40:40: Network Entry...
[1220] 15:40:40: Interface Table Size 0
[1220] 15:40:40: Interface Table...
[1220] 15:40:40: Index Sorted List...
[1220] 15:40:40: EventQueue...
[1220] 15:40:40: ...NM_Test
[1220] 15:40:40: 0 threads are active in SAMPLE
[536] 15:40:40: Entering WorkerFinishStopProtocol: active threads 0
[536] 15:40:40: Leaving  WorkerFinishStopProtocol
[1220] 15:40:40: StopProtocol 907
[1220] 15:40:40: Configuration Entry...
[1220] 15:40:40: ActivityCount 0, LogLevel 1, NumInterfaces 0
[1220] 15:40:40: EventQueue...
[1220] 15:40:40: Event 0
[1220] 15:40:40: Stopped 0 0
[1220] 15:40:40: Configuration Entry...
[1220] 15:40:40: ActivityCount 0, LogLevel 1, NumInterfaces 0
[1220] 15:40:40: EventQueue...
[1220] 15:40:40: ...CM_Test (1)
[1220] 15:40:40: Hash Table Size 230
[1220] 15:40:40: NumDeleted 115 Hash Table Size 115
[1220] 15:40:41: NumGotten 115
[1220] 15:40:41: ...HT_Test
[1220] 15:40:41: ERROR_CAN_NOT_COMPLETE: 1003
[1220] 15:40:41: ERROR_INSUFFICIENT_BUFFER: 122
[1220] 15:40:41: ERROR_NO_MORE_ITEMS: 259
[1220] 15:40:41: ERROR_INVALID_PARAMETER: 87
[1220] 15:40:41: ...ErrorCodes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\sample\readme.txt ===
This code provides a sample implementation of an IP routing protocol.  It
illustrates the interaction with the IP Router Manager and the Route Table
Manager (v2).  It also provides guidelines for efficient use of the event
logging and tracing facilities provided with the Routing SDK. The code uses
WinSock2 functionality for optimized execution.  It also contains comments
about the preferred usage of NT and Routing functionalities (such as worker
threads, etc).

To run the sample, you need to build the LoadProtocol sample, which will load
this sample protocol. Please see ..\LoadProtocol for more info.

The sample protocol DLL (ipsample.dll) needs to be copied to the 
%SytemRoot%system32 folder

The sample protocol should be registered in the following registry
location (invoke ipsample.reg to effect these changes):


\HKEY_LOCAL_MACHINE
 \Software
  \Microsoft
   \Router
    \CurrentVersion
     \RouterManagers
      \IP
       \IPSAMPLE
        VendorName      = Microsoft (Value Type: REG_SZ)
        Title           = Sample IP Routing Protocol (Value Type: REG_SZ)
        ProtocolId      = 0x00c8 (Value Type:REG_DWORD)
        Flags           = 0  (Value Type:REG_DWORD)
        DLLName         = IPSAMPLE.DLL (Value Type: REG_SZ)
        ConfigDLL       = admin application dll (Value Type: REG_EXPAND_SZ)
        ConfigClsid     = admin application CLSID (Value Type: REG_SZ)


DESCRIPTION

Once the sample protocol is installed, it will periodically send out hello
messages on every active (enabled and bound) interface.  These are received
by all routers on the subnet running the sample protocol.  The MIB api
allows one to get and set the global and interface specific configuration
and to obtain the interface bindings as well as the global and interface
statistics.  These structures are defined in <ipsamplerm.h>...


CAVEAT

At this moment the sample does not support unnumbered interfaces.  This
feature will be demonstrated in a future release.


FILES

README          this file

makefile        unchanged
makefile.inc    build instructions for resources
makefile.sdk    build instructions for external distribution
sources         compilation instructions for sample.dll and sampletest.exe

ipsample.def    functions and variables exported by sample.dll

list.h
hashtable.[ch]
sync.h
utils.[ch]
packet.[ch]
socket.[ch]
networkentry.[ch]
networkmgr.[ch]
configentry.[ch]
configmgr.[ch]
mibmgr.[ch]
rtmapi.[ch]
rmapi.[ch]
test.c

log.h           localizable error codes
ipsample.rc     dll resources file
ipsample.[ch]   dll main file

pchsample.h     precompiled header

sampletest.rc   test resources file
sampletest.h    test header file
sampletest.cxx  test main file (cxx extention precludes pch inclusion)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\ndproxy\kdext\pxext.txt ===
PX_TAPI_LINE
PX_TAPI_ADDR
PX_TAPI_PROVIDER
TAPI_TSP_CB
TAPI_LINE_TABLE
TAPI_ADDR_TABLE
LINE_DEV_CAPS
LINE_ADDRESS_CAPS
LINE_ADDRESS_STATUS
LINE_DEV_STATUS

TSP_EVENT_LIST

VC_TABLE

PX_DEVICE_EXTENSION
PX_ADAPTER
PX_CM_AF
PX_CM_SAP
PX_CL_AF
PX_CL_SAP
PX_VC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\rasl2tp\kdext\l2tpext.txt ===
ADAPTERCB
TUNNELCB
VCCB
CONTROLRECEIVED
CONTROLSENT
PAYLOADRECEIVED
PAYLOADSENT
CALLSTATS

BUFFERPOOL
BUFFERBLOCKHEAD
BUFFERHEAD

PACKETPOOL
PACKETBLOCKHEAD
PACKETHEAD

TDIXCONTEXT

TIMERQ
TIMERQITEM

L2TPHEADERINFO
AVPINFO
CONTROLMSGINFO
TUNNELWORK
INCALLSETUP
LINKSTATUSINFO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\embedded\netsh.txt ===
NETSH:
======
Netsh is a command-line scripting utility that allows you to, either locally or remotely, display or modify the network configuration of a computer that is currently running. Netsh also provides a scripting feature that allows you to run a group of commands in batch mode against a specified computer. Netsh can also save a configuration script in a text file for archival purposes or to help you configure other servers.

Netsh interacts with other operating system components using dynamic-link library (DLL) files. Each Netsh helper DLL provides an extensive set of features called a context, which is a group of commands specific to a networking component. These contexts extend the functionality of netsh by providing configuration and monitoring support for one or more services, utilities, or protocols. For example, Dhcpmon.dll provides netsh the context and set of commands necessary to configure and manage DHCP servers.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\hlp\rasread.txt ===
RELEASE NOTES 
Remote Access Service Version 3.51

To easily view this file on screen, maximize the 
Notepad window, and then, from the Edit menu, 
choose Word Wrap.

CONTENTS ----------------------------------------

GENERAL NOTES
   Starting the Remote Access Server
   Browsing Remote Networks
   RAS Authentication
   Using Winchat with RAS
   Registry Key Name Changes and Additions
   RAS Compression
   Remote Access Support for Security Dynamics ACE Server
   Shadow RAM Conflicts
   NetBEUI Bindings on Computers with Multiple Network Cards 
   Using RAS with PCMCIA Cards
   
CONNECTING TO WINDOWS NT 3.51 RAS SERVERS
WITH THIRD-PARTY PPP CLIENTS
   NetManage Chameleon and Chameleon NFS 
     Version 4.1 Clients Required
   Third-Party FTP Software
   Wollongong Software

CONNECTING TO THIRD-PARTY PPP SERVERS
WITH WINDOWS NT 3.51 RAS CLIENTS
   Connecting to Internet Service Providers 
     that Use Older PPP Software
   Cisco Router Software
   3Com Access Builder Software
   Using Terminal Mode in RAS
   PPP Service Providers

RAS AND TCP/IP
   Resetting DHCP Leases on RAS Servers

RAS AND IPX
   Using NetBIOS Applications on IPX
   Using Shiva Remote Version 3.2 Client Software and IPX

ISDN
   Reinstalling RAS with ISDN
   Removing and Adding an ISDN Port to RAS Configuration
   Installing a PCIMAC ISDN Card on 
     a Gateway 2000 Pentium
   Installing New Modems with ISDN Cards

X.25 NETWORKS
   Eicon Drivers
   Configuring Null Modem Connections on X.25 Networks
   Creating Reliable Links Using Dial-up PADs
   Configuring a RAS Server for X.25
   X.25 Buffering
   Server Bandwidth and the Total Number of Clients
   Troubleshooting Remote Disconnections

FREQUENTLY ASKED QUESTIONS

-------------------------------------------------

For best printed results, open this document 
in Windows NT Write or another word processor, 
select the entire document, set the margins, and 
then format the text in 10 point Courier before printing.


=================================================
GENERAL NOTES
=================================================

Starting the Remote Access Server
---------------------------------
If the Remote Access server fails to start, check the Windows NT Event Viewer for more information.


Browsing Remote Networks
------------------------
To browse a remote network, the remote RAS computer must belong to a workgroup or domain on the network.  If the computer is not a member of a valid workgroup or domain on the network, the remote computer will not be able to browse the network from File Manager. 

Note:  You can still connect to servers directly using File Manager even if your RAS computer is not a member of a valid workgroup or domain. For example, in the File Manager Connect Network Drive dialog box, you can enter a server name and share name and connect to that server and share, even though the server does not appear in the browse box.


RAS Authentication
------------------
When you are dialing a number, the domain name you enter in the Authentication dialog box should be the Windows NT domain that the Windows NT RAS server is in. This is not the DNS domain name given by some PPP/SLIP providers. For example, you would enter accounting, not www.halcyon.com.

Using Winchat with RAS
----------------------
When using WINCHAT.EXE on a remote client, you must change a Registry key on the RAS server.

Using REGEDT32.EXE, change 

HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\
  RemoteAccess\Parameters\NetBiosGateway\RemoteListen 

from 1 (the default) to 2.


Registry Key Name Changes and Additions
---------------------------------------
In the Windows NT Server RAS book, in Appendix C, the IPXRouter Parameters section incorrectly refers to the IPXRouter Registry key. The correct key name is NwLnkRip. All other information in the IPXRouter Parameters section is correct. The Registry path for this entry is:
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NwLnkRip\Parameters

In Appendix C, in the IP Parameters section, you should change all the parameters in a RAS server's Registry, not a RAS client's Registry. In the NdisWan Parameters section,  disregard paragraphs two and three. In the AsyncMac Parameters section, the XonXoff parameter is no longer a valid parameter.

The following Registry keys are not printed in Appendix C, "Modifying Registry Parameters". For information about each entry, see Remote Access Help.

PPP Subkey IPCP entries:
   AcceptVJCompression
   PriorityBasedOnSubNetwork
   RequestNameServerAddresses
   RequestVJCompression

RasArp Parameter
   FilterBroadcasts

Nbf Parameter
   InitUIFrames

NwlnkIpx Parameter
   DisableDialinNetbios


RAS Compression
---------------
Support for RAS software compression between Windows for Workgroups and Windows NT has been added.

The formulas used for calculating compression statistics in the Port Status dialog box are different for Windows for Workgroups 3.11 and Windows NT 3.51.

(1)	Bytes Transmitted/Received:
	
	On Windows for Workgroups, the values shown represent the
	number of bytes of data actually transmitted on the wire.
	Thus, 100K of user data that compressed by 40K will show
	as 60K Bytes Transmitted/Received.

	On Windows NT 3.51, the values shown represent the full
	number of bytes transferred.  In this example, 100K.

(2)	Percent of Compression:

	On all platforms RAS compression predetermines what data
	should or should not be compressed for optimal performance.

	On Windows for Workgroups 3.11 the "Compression%" value
	represents the ratio of compression achieved, accounting only
	for that data on which compression was attempted.

	On Windows NT 3.51, the "Compression%" accounts for all data,
	including the data on which compression was not attempted.  As
	a result, the reported "Compression%" figures for Windows NT 3.51
	will run lower than those shown on Windows for Workgroups 3.11.


Remote Access Support for Security Dynamics ACE Server ---------------------------------------------------------------------- 
Windows NT 3.51 Remote Access has the capability to authenticate dial-in
users using the Security Dynamics ACE Server. To enable authentication with the Security Dynamics ACE Server, you need to install a special module from Security Dynamics Inc. You can reach Security Dynamics Inc. at the following address:

 Security Dynamics  
 One AleWife Center
 Cambridge, MA 02140-2312
 Tel: (617) 547 7820
 Fax: (617) 354 8836
 

Shadow RAM Conflicts
--------------------
Computers that use Shadow RAM may experience problems with memory conflicts. You may need to disable BIOS Shadow RAM using the computer setup program provided by the computer manufacturer. See your computer documentation or manufacturer for more information.


NetBEUI Bindings on Computers with Multiple Network Cards
---------------------------------------------------------
RAS installs NetBEUI by default. If a computer has two network cards, NetBEUI is bound to both cards. This will cause your workstation service not to start due to duplicate computer names on the network. 
So, if your computer has more than one network card and you are installing RAS, during the installation process make sure NetBEUI is bound to only one of the network cards. You can change the bindings in the Network Control Panel icon by choosing the Bindings button in the Network Settings dialog box.
During RAS installation, you can also choose not to install NetBEUI by choosing the Network button in the Remote Access Setup dialog box. In the Network Configuration dialog box, clear the NetBEUI check box. 


Using RAS with PCMCIA Cards
---------------------------
If you are using RAS with a PCMCIA card and are experiencing difficulty with your computer, such as lock-ups or error messages about hardware failure, use the Terminal program in the Program Manager Accessories group to assure that the PCMCIA card is functioning properly. 
If Terminal locks up, the problem could be one of the following:
* The modem is not recognized by Windows NT
* FIFO needs to be disabled
* An incorrect IRQ or I/O address is being used
To reconfigure the communications port, in the Control Panel Ports icon, choose the Settings button, and then choose the Advanced button. Then, in the Registry, add the following entry for the new port key:
Pcmcia:REG_DWORD 1

If Terminal functions properly, verify that the modem type is being detected correctly and that the speed is set correctly. For information on speed settings, refer to the modem manufacturer's manual.



=================================================
CONNECTING TO WINDOWS NT 3.51 RAS SERVERS
WITH THIRD-PARTY PPP CLIENTS
=================================================

NetManage Chameleon and Chameleon NFS Version 4.1 Clients Required
------------------------------------------------------------------
Versions of NetManage Chameleon prior to 4.1 do not interoperate with Windows NT. You must update to version 4.1 to connect to Windows NT 3.51 RAS servers.

Also, you must make the following change in the SLIP.INI file located in the \NETMANAG directory, before connecting a NetManage client to a Windows NT RAS server.

[ppp]
SCRIPT=-n
TYPE=PPP

In order to configure the NetManage client to request an IP address from the Windows NT RAS server, set the client IP address to 0.0.0.0.

If you want the NetManage client to request a specific IP address, you must configure the RAS server IP configuration to allow remote clients to request their own IP addresses. You configure the RAS server using the Network option of Control Panel.


Third-Party FTP Software
------------------------
PC/TCP OnNet version 1.1 or later is required for Windows NT. Previous version of FTP Software Inc. client software do not work with Windows NT.

In order to have the Remote Access server assign an IP address for you, set your IP address to 0.0.0.0 before dialing.  You can set your IP address from the Configure screen of the Dialer application.


Wollongong Software
-------------------
Wollongong PPP software now interoperates with Windows NT 3.51. Contact The Wollongong Group for more information or updates:
The Wollongong Group Inc.  
1129, San Antonio Rd.  
Palo Alto, CA 94303-4310
Tel# (800) 872-8649 


=================================================
CONNECTING TO THIRD-PARTY PPP SERVERS
WITH WINDOWS NT 3.51 RAS CLIENTS
=================================================

Connecting to Internet Service Providers that Use Older PPP Software
--------------------------------------------------------------------
If you connect to an Internet service provider and TCP/IP utilities do not work (such as FTP or TELNET) the problem may be due to Van Jacobson (VJ) header compression and older PPP software on the Internet service provider system. Older PPP server software may be unable to match the VJ header compression settings on your computer.

To solve the problem, you must disable VJ header compression for that entry. To disable VJ header compression, select the entry in your phone book. Choose the Edit button. Choose the Advanced button (if the Network button is not visible). Choose the Network Button. Choose the TCP/IP Settings button. Clear the Use VJ Header Compression check box. Choose the OK button until you return to the main Remote Access dialog box. You should be able to successfully connect to the entry and use TCP/IP utilities.


Cisco Router Software
---------------------
You can use Windows NT RAS to connect through a Cisco router. If you have a Cisco router using version 9.21 or earlier, you must upgrade your Cisco router software to the most recent release. Contact Cisco Systems for more information at 800-553-NETS, or via electronic mail at tac@cisco.com.


3Com Access Builder Software
----------------------------
You can use Windows NT RAS to connect to 3Com Access Builder remote access servers. If you have installed Access Builder products prior to September 1994, you must upgrade your 3Com Access Builder software to the most recent release. Contact your 3Com representative for information about upgrading your Access Builder software. If you do not have a 3Com representative, contact the 3Com Corporation product information line at 800-638-3266. You can also call 408-764-5000 and ask for the product information line.


Using Terminal Mode in RAS
--------------------------
Some Internet providers require new users to register using terminal mode after connecting the first time. Try using the terminal mode provided by Remote Access and select Dumb Terminal from the terminal mode emulations offered at connect time by the Internet provider. If the terminal emulation provided in RAS does not work, use the Terminal program in the Program Manager Accessories group.

PPP Service Providers
----------------------
The following service providers have been successfully tested with Windows NT. These are additions to the PPP service providers provided in RAS Help.

Maestro Technologies, Inc.
New York, NY
Phone 212-240-9600
PPP

Network 23, Co.
New York, NY
Phone 917-424-8806
PPP

International Internet Association (IIA)
Herndon, VA
Phone 703-904-4100
PPP/SLIP

Eskimo North
Seattle, WA
Phone 206-367-7457
PPP

DKnet
Koebenhavn Oe, Denmark
Phone 45-39-17-99-00
PPP

WinNet
Harrow, England
Phone 44-181-863-1191
PPP

EUnet Finland
Helsinki, Finland
Phone 358-0-400-2060
PPP/SLIP

COM
Les Ulis, France
Phone 33-1-69-28-85-15
PPP

Individual Network e.V. (IN)
Oldenburg, Germany
Phone 49-441-980-8556
PPP

SANGONeT
Johannesburg, South Africa
Phone 27-11-838-6943/4
PPP

ZAMNET Communications Systems Ltd
Lusaka, Zambia
Phone 260-1-293-317 or 260-1-252-507
PPP


=================================================
RAS AND TCP/IP
=================================================

Resetting DHCP Leases on RAS Servers
------------------------------------
If you configure a new set of IP addresses at the DHCP server and you want RAS servers to re-synchronize with the new DHCP configuration, you must delete the RAS server's DHCP cache and reset the lease on the RAS server. This is accomplished by deleting a Registry key and restarting the Remote Access server, as described below.

At the command prompt, type:

start regedt32.exe

In the \HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
\RemoteAccess\Parameters\IP entry, delete the entire DhcpAddresses key. Restart the Remote Access Server service.



=================================================
RAS AND IPX
=================================================

Using NetBIOS Applications on IPX
------------------------------
RAS supports running NetBIOS applications on IPX. No configuration is necessary if the RAS remote client is the application client and the NetBIOS application server is on the LAN. However, if the NetBIOS application server is the remote computer, you may need to set one or both of the following Registry entries to ensure the IPX type 20 packets used for initial contact between the NetBIOS IPX client and server are forwarded correctly. 

To set where NetBIOS broadcast packets from dial-in lines are broadcast, change the following Registry key:
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services
\NwlnkIpx\Parameters\DisableDialinNetbios.

To set whether packets are broadcast to or from the LAN through the RAS IPX router, change the following Registry key:
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services
\NwlnkRip\Parameters\NetbiosRouting. The DisableDialinNetbios parameter must be set correctly in addition to NetbiosRouting.

For more information, see the appropriate Registry topics in Remote Access Help.


Using Shiva Remote Version 3.2 Client Software and IPX
------------------------------------------------------
If you are using the IPX protocol with Shiva remote client software, you must configure the Windows NT 3.51 RAS server IPX settings to allow remote clients to request an IPX node number. You configure the RAS server using the Network option of Control Panel.



=================================================
ISDN
=================================================



Reinstalling RAS with ISDN
--------------------------
If you remove and then reinstall RAS on a computer that was previously configured with RAS and ISDN, you will not be able to add the ISDN ports in RAS setup. You must reconfigure the ISDN driver as follows before reinstalling and reconfiguring RAS with ISDN ports.

Removing and Adding an ISDN Port to RAS Configuration
-----------------------------------------------------
If you remove any non-serial ports from RAS configuration, you must reconfigure the hardware before you add the port back into RAS configuration. For example, suppose you  have RAS configured with COM1 and PcimacISDN1 ports. You remove the PcimacISDN1 port which is the only ISDN port configured, and restart the computer. Now, when you configure RAS, you are not able to add the PcimacISDN1 port. 
To add the ISDN port to RAS configuration, you must reconfigure the ISDN hardware adapter. This ensures that the port information is added back to the Registry and will  enable you to add the removed port to RAS configuration.


Installing a PCIMAC ISDN Card on a Gateway 2000 Pentium
-------------------------------------------------------
You must disable BIOS Shadow RAM of 32K at d0000 on Gateway 2000 Pentium computers when a PCIMAC ISDN card is present and the card's base address is d0000. If you do not disable the BIOS Shadow RAM at d0000, the PCIMAC card appears to initialize correctly but does not work.

To disable BIOS Shadow RAM of 32K at d0000, use the computer setup program by pressing F1 after the memory check, and then choosing Advanced Options. The Disable Shadow RAM and the Shadow RAM Base options appear in this screen.


Installing New Modems with ISDN Cards
-------------------------------------
If you have a laptop computer that uses an ISDN card when plugged into a docking station and you install a new modem while away from the docking station, you must use RAS Setup to add the ISDN ports when you return to the docking station.



=================================================
X.25 NETWORKS
=================================================


Eicon Drivers
-------------
Contact Eicon Customer Services and request version V3R2a or later of WAN Services for Windows NT 3.51. Previous versions of Eicon's X.25 drivers do not work with Windows NT 3.51.

US customers can reach Eicon Customer Service at: 214-490-3270, from 9AM to 5PM CST.

Canadian customers can reach Eicon at: (514) 631-5246, from 8:30AM to 6PM EST. FAX: (514) 631-1006, 24 hours a day, 7 days a week

NOTE: Outside of North America, contact your distributor for help.
If you are a CompuServe member, type:   go eicon


Eicon Technology's company names are printed incorrectly in Appendix A. The correct names are:

Montreal:      Eicon Technology Corporation
United States: Eicon Technology, Inc.
Europe:        Eicon Technology Ltd.


Configuring Null Modem Connections on X.25 Networks
---------------------------------------------------
When using a null-modem connection on X.25 networks, the server X.25 port must be set to DCE and the client should be set to DTE. If the port on both computers is set to DTE, you cannot connect.

The X.25 null modem should be configured for DCE and internal clocking before an X.25 null-modem client can connect. To configure the X.25 null modem, in Control Panel choose Network. In the Network Settings dialog box, choose the X.25 card driver in the list of adapters, then choose Configure. Select the null modem port, choose X.25 and change the node type to DCE. Select X.25 and set the clocking to Internal. Save the configuration and restart the system.


Creating Reliable Links Using Dial-up PADs
------------------------------------------
The following is recommended on all workstations that are going to access a dial-up PAD to connect through X.25 to a RAS server using an EiconCard.

Establish all modem connections using a reliable link (either V.42, LAPM, or MNP4) and enable hardware handshaking between your local modem and the workstation. Enable these settings by editing the Remote Access entry's modem settings. Select the check box for modem error correction and the check box for hardware flow control.

Using this feature ensures that there is end-to-end flow control and no data will be lost between the dial-up PAD and the client workstation. You may encounter problems unless these modem settings are made.


Configuring a RAS Server for X.25
-----------------------------------
When configuring a RAS Server to use X.25 over an EiconCard, several steps must be followed to define the number of clients that can connect to the server.

 1. Define the total number of virtual circuits that the EiconCard will be configured for.

    a. Choose the Network option in Control Panel.

    b. In the Network Settings dialog box, select the EiconCard driver in the Installed Adapter Cards box.

    c. Choose the Configure button. 

    d. Follow the instructions in your Eicon WAN Services for Windows NT System Guide on how to configure the total number of virtual circuits.

       The sum of the two-way virtual circuits (TVC) and incoming virtual circuits (IVC) in the X.25 configuration screen must equal the number of incoming X.25 clients the server will support at one time. You may have to find out how many TVCs and IVCs your X.25 line has by contacting your X.25 vendor.

 2. Define the number of communication ports to be available for RAS in the XPAD 
    configuration program.

    a. Choose the Network option in Control Panel.

    b. In the Network Settings dialog box, select the Eicon X.PAD Driver in the
      Installed Network Software box.

    c. Choose the Configure button. 

    d. Configure the total number of COM ports by selecting the COM ports from the Available Ports list and then choosing the Add button.

       It is recommended that the number of communication ports should be equal to the number of virtual circuits (TVC+IVC) configured.

 3. Configure the number of communication ports (Eicon XPAD's) in RAS using the Network option in Control Panel.


X.25 Buffering
--------------
On each communication port in the Eicon PAD configuration, it is recommended that the packet length supported be left at the default of 128.  This will give optimum performance on the server.


Server Bandwidth and the Total Number of Clients
------------------------------------------------
To obtain maximum performance in the RAS clients and to ensure reliable connections, ensure that the aggregate throughput of all clients does not exceed the bandwidth of the RAS server.

For example, four clients running at 2400 bits per second (bps) can be connected to a server with a 9600 bps X.25 line. However, attaching a fifth client at 2400 bps will exceed the server's bandwidth. This will cause all clients to operate at speeds below 2400 bps.  If a virtual circuit, communication port, and RAS port are defined for five ports, then five clients can connect using X.25. However, connecting five clients at one time is not recommended since the throughput of each client will be very low and will cause time-outs in the network protocols running over RAS.


Troubleshooting Remote Disconnections
-------------------------------------
When a client connection is cleared, the system event log of the RAS server running X.25 can be examined for an error message. The event log can record why the remote client or the remote network disconnected.

If the remote client (through a dial-up PAD or local PAD) disconnects, the following warning message will appear in the system event log.

"Remote DTE cleared the X.25 call on XPADxxx, X.25 Return Codes: Cause yy (hex) Diagnostic yy (hex)"

The "XPADxxx" is the port name defined in the XPAD configuration.  "yy" is a hex string.  For DTE clearing the cause will always be 00.  The Diagnostic code can be 00--indicating that the remote client requested a disconnect--or another non-zero value.  When the diagnostic code is non-zero it indicates a clearing due to the remote client's dial-up PAD service.  Contact the remote client's X.25 service provider to determine the problem.

If the X.25 network disconnects, the following warning message will appear in the system event log.

"Network cleared the X.25 call on XPADxxx, X.25 Return Codes: Cause yy (hex) Diagnostic yy (hex)"

The "XPADxxx" is the port name defined in the XPAD configuration.  "yy" is a hex string.  For a network clearing the cause value will always be a non-zero value.  The diagnostic code in the cause can be any value. Consult your local X.25 service provider with the cause and diagnostic value to determine the exact reason for the network disconnect.


=================================================
FREQUENTLY ASKED QUESTIONS
=================================================
This section contains questions and answers from public bulletin boards, such as CompuServe. It is included to help customers with similiar questions.
You can find more information in the RAS online Help file or in Microsoft's whitepaper on RAS located on ftp.microsoft.com or www.microsoft.com.

QUESTION:
I had my DHCP server configured for an address pool.  I then
changed it to a different pool.  Now all my RAS clients continue to get addresses from the initial pool.  Why?

ANSWER:
See the section, "Resetting DHCP Leases on RAS Servers" earlier in this file.

---------------------------------------------------
QUESTION:
My site has a Shiva network modem which I can use to call into and 
establish a connection on the Novell network. Can I use the RAS client software to dial in and establish a connection directly with Shiva, without having to setup a Windows NT Server computer as a RAS server? If so, how would I go about doing this?

ANSWER:
The Windows NT RAS client will dial into a Shiva network modem.  You
need to install RAS on the Windows NT client.  Then dial in using a valid username and password.  

If you have problems, there are many things to check.  You can check to see if the client is requesting its own IP address, but the server is not configured to supply one.  Also, you must select PPP protocols that are supported on the server; for example, IP or IPX.

------------------------------------------
QUESTION:
I have an internal Intel SatisFAXtion/400 modem, which is installed on COM4.
When I try to setup RAS for this modem, it only lists Port 2 and Port 3 as
options.  It says if I want to access other ports to get a driver from the
manufacturer.  Does this mean that I need a SatisFAXtion driver for Windows NT from Intel?

ANSWER:
This means you probably do not have the modem configured correctly for COM4. The system is not recognizing a device on COM4, so COM4 is not being offered in RAS setup.  Try using Terminal to dial out through COM4. If the modem is correctly configured for COM4, you may have an IRQ conflict that is causing the problem.  Check the Windows NT Event Viewer to see if there are any
problems listed there.

---------------------------------------------------
QUESTION:
Does anyone have a fix for the SMC 16550 UART.... I get error messages when using RAS to connect to a computer above 19200. Is there a fix besides changing my serial card or going to an internal modem?

ANSWER: You can try setting the port speed a bit lower.  This is the speed at which the machine talks to the modem,
rather than the speed of the modem.  By default it is 38400.  Try setting it to the same speed as his modem.  To set this, edit the
phone book entry and choose the Modem button at the bottom of the
dialog.  Select a speed in the Initial Speed (bps) box.

----------------------------------------------------
QUESTION:
How, on a Windows NT Server version 3.5 network, do I provide primary DNS service?  Do I need to put a UNIX box on my LAN just to provide DNS?  Or is there a DNS Server that will run under the Windows NT Services system?

ANSWER:
Windows NT Server version 3.5 does not have a DNS service. A DNS server for Windows NT is available in the Windows NT 3.5 Resource Kit.

---------------------------------------------------
QUESTION:
Are there any plans to provide an upgrade for Windows for Workgroups RAS clients and Windows NT version 3.1 RAS clients so that they will be compatible 
with the new software compression scheme in Windows NT version 3.5?

ANSWER:
Support for Windows for Workgroups 3.11 RAS and Windows NT version 3.1 RAS software compression is available in the Windows NT version 3.51 release.

---------------------------------------------------
QUESTION:
1.  I can successfully connect using RAS on a Windows NT Workstation version 3.5 with a Windows NT Server version 3.1 running RAS.  However, I get the following message in the Connection Information dialog on the Windows NT version 3.5 client: "Using Down-Level RAS Protocol". 

2.  The connection information also shows that I am getting 0% compression. This message occured when I switched from a Windows for Workgroups 3.11 RAS client to a Windows NT Workstation version 3.5 RAS client. Any suggestions for getting my compression back?

ANSWER:
1.  Windows NT version 3.1 RAS does not support PPP, which the Windows NT version 3.5 RAS client is attempting to use when connecting. Windows NT version 3.5 RAS falls back to the older protocol to make the connection and displays the "Using Down-Level RAS Protocol" message.

2.  To get software compression with Windows NT version 3.5 RAS calling a Windows NT version 3.1 RAS server, upgrade your RAS client to Windows NT version 3.51 which supports the older software compression algorithm used in Windows NT version 3.1.

---------------------------------------------------
QUESTION:
Windows NT version 3.5 has PPP/SLIP built into RAS, so you can use the RAS client software to connect your Windows NT computer to the Internet.
Suppose I have a LAN which includes a bunch of Windows for Workgroups version 3.11 systems networked to a system running Windows NT version 3.5. If the Windows NT system uses RAS to connect to an Internet provider, and if I have the TCP/IP protocol on all computers on the LAN, will the Windows NT computer connect the two ends? That is, will it act as a gateway, allowing the Windows for Workgroups computers to see the Internet on the other end of the RAS connection?
If so, is it automatic, or do I have to do something to enable it? If not, is there any way to get this capability?  Is it in Windows NT Server or some third-party product?

ANSWER:
LAN to LAN routing is not supported today.  Look for it in the Windows NT 3.51 Service Pack release in the next few months.
For more information, see the Windows NT 3.5 Resource Kit or the following Knowledge Base article:
Enabling Routing of IP Packets on RAS Clients
ID: Q121877

---------------------------------------------------
QUESTION:
What are all the steps necessary to make a RAS connection from Windows for Workgroups to Windows NT version 3.5 with a null modem setup?

ANSWER:
1.  Install RAS on the RAS server.  Configure it for a null modem, at 9600 bps.
2.  On the RAS server, create an account for the user dialing in.
3.  On the RAS server, in RAS Admin, select the Permissions command under the Users menu. Grant dial-in permission for that user account.
4.  Install RAS on the Windows for Workgroups client.  Configure it for a null modem.
5.  In Remote Access, create a phonebook entry to the server you are dialing.  Enter 1 (or some random number) for the phone number.
6.  Choose the Dial button.  The rest happens exactly like an analog connection.
     Make sure you are using a standard null modem cable. See the RAS on-line Help topic "Cabling Requirements" for details.

---------------------------------------------------
QUESTION:
I have TCP/IP installed on both my RAS server and client, but when I dial in, I get an error saying PPP is not installed.

ANSWER:
You need to enable TCP/IP for RAS.
To enable a protocol for RAS, start the Control Panel Network icon.
In the Network Settings dialog box, select Remote Access Service and choose the Configure button. In the Remote Access Setup dialog box, choose the Network button. In the Network Configuration dialog box, make sure the appropriate protocols are checked in the Dial Out Protocols box.
---------------------------------------------------
QUESTION:
We would like to use RAS to administer a remote Windows NT Server computer version 3.5 at a client's site. What kind of software do we need to have on our side? Do we need to dial the server from our Windows NT Server computer version 3.5 or can we dial in from any computer?

ANSWER:
This is easiest if you dial them from a Windows NT Server computer. That way all you have to do is run the administrative tools already found on the Windows NT Server computer and point them at the remote client.

You can also install the Windows NT Server tools found on the Windows NT Server CD on a Windows NT Workstation computer. Then you can use that workstation to dial in and manage Windows NT Server computers on the remote network.

To install the Windows NT Server Tools on a computer running Windows NT Workstation, obtain a Windows NT Server CD and run the \CLIENT\SRVTOOLS\WINNT\SETUP.BAT batch file.

There are also Windows NT Server tools for use on computers running MS-DOS 5.0 or later, Windows version 3.1x (with LAN Manager for MS-DOS), or Windows for Workgroups 3.1x.
To install the Windows NT Server Tools obtain a Windows NT Server CD and follow the instructions in the README.TXT file in the \CLIENT\SRVTOOLS\WINDOWS directory.

---------------------------------------------------
QUESTION:
Does anyone have any experience tying two Windows NT computers together via null modem?  
I have two computers on my desk running Windows NT 3.5 and I have no other networking 
hardware, so I'm trying to use RAS and my null modem cable to link them together. But, everytime
I try to dial I get a message of hardware failure.
I've checked my cable for continuity, and it matches the table supplied in the Windows NT Help file.  Also, I've tried it with all the modem options (things like "enable hardware flow control")
turned off, as well as with a smattering of them turned on, but to no effect. 

ANSWER:
Are you using a 25-pin to 9-pin converter for either of the COM ports?
If so, make sure it is not the 25-9 adapter that ships with the Microsoft Mouse.  That is not a true converter, and will cause this problem.

If that is not the problem, double check that both client and server have the same speed Null Modem entry selected in the Configure Port dialog in RAS.
Also, make sure you are not using a standard null modem cable. See the RAS on-line Help topic "Cabling Requirements" for details.

---------------------------------------------------
QUESTION:
I was wondering how many RAS connections Windows NT Server version 3.5 supports, and what hardware for these connections was recommended (I.E. Dialogic, etc.).
Also, do you have any additional information on the optimum server (hardware/system) for X+ users?

ANSWER:
The RAS server for Windows NT version 3.5 or later will support up to 256 clients per server. To do that I would recommend 2 Digiboard EPC controllers and a 4-processor RISC computer for your RAS server.

Here are some very general guidelines for servers:
    Up to 40 clients, 486/66 with 48M of RAM
    Up to 64 clients, axp or MIPS with 64M of RAM, or P5 2-processor with 64M of RAM
    Up to 100 clients, MIPS or axp 2-processor with 64M RAM  (Yields about 70% CPU utilization.)
    More than 150 or so, use a 4-processor or better RISC computer.

For COM hardware, the Digiboard C/X controller is good.  For large client loads (70+)
on a single computer, I would recommend the Digiboard EPC controller, or two, to share
the load.

---------------------------------------------------
QUESTION:
RAS will not dial out. It shows on the screen that it is dialing out, but then returns an error stating that my modem and/or serial card is not functioning. This is strange since I can connect to CompuServe without errors. 

ANSWER:
COM software and RAS have different cabling needs. So, the fact that your COM software works does not assure that RAS will work.
Are you using a 25-pin to 9-pin Mouse cable adapter?  Or does your serial cable plug directly into the COM port on the computer and modem?

See the RAS on-line Help topic "Cabling Requirements" for details.

---------------------------------------------------
QUESTION:
How do I change the default timeout? I have searched the Registry and all other files 
and found nothing. Also, what do you define as idle, as I have had a 24-hour connection established, 
with absolutely no processing?

ANSWER:
You can change the idle timeout value in the Registry at HKEY_LOCAL_MACHINE on Local
Machine\SYSTEM\CurrentControlSet\Services\RemoteAccess\Parameters\Autodisconnect.
By default this value will be 0x14 (20 minutes). Change it to something like 0x5.

Idle is defined as no significant traffic over the link.  You can have a computer
connected with no visible processes running, but keep in mind things like the browser,
replication, etc. that run on the system without any user intervention.  These processes
can keep the RAS link alive.

---------------------------------------------------
QUESTION:
I've loaded RAS on a Windows NT Server computer that is a member server, not a domain controller. When I run RAS Administrator to grant dial-in privileges, I only see the local users -- Administrator and Guest, not the domain users. I can run User Manager for Domains and see the domain users, but RAS Administrator does not see them.  Must I load RAS on a domain controller to support people calling into my domain? 

ANSWER:
It sounds like you have RAS Administrator focused on the local computer instead of the domain.
In RAS Admin, from the Server menu, select the Select Domain or Server command and enter the domain name.
When the screen refreshes you should be able to view the domain RAS accounts.

---------------------------------------------------
QUESTION:
I connect often to a SLIP server using Netmanage Chamelion on my Windows for Workgroups computer every day. When I try to use my Windows NT Server version 3.5, I cannot connect and get a 611 error instead. I enter my login and password fine, but when I choose the Done button I instantly get the 611 error. It tells me the route is unknown. What can I do to get this up and running?

ANSWER:
Windows NT RAS cannot accept incoming SLIP calls. It will accept incoming PPP calls, and it will make outgoing PPP or SLIP calls. 
Configure your client software, Netmanage Chamelion on your Windows for Workgroups computer, to use PPP when it dials a Windows NT RAS server.

---------------------------------------------------
QUESTION:
I have a phone system that needs to let it ring at least twice before answering. Is there any way I can control how many rings occur before my RAS server answers a client call?
I have a US Robotics Sportster 14400 modem handling my calls.  Supposedly, an ATS0=2 command should do what I want but where can I enter this command?

ANSWER:
Edit your MODEM.INF file in the \systemroot\SYSTEM32\ras directory. Search for the
section [US Robotics Sportster 14400], and change the ATS0= entry to 2 or 3.

---------------------------------------------------
QUESTION:
I'm having problems being authenticated on the network after using RAS to connect from my home computer.
On my computer at home, the computer name is \\HOME and my user name is greg. 
When I start RAS from home and contact the office I can logon as Administrator, Greg, or
Guest and all three give me an Access Denied message when I try to access a share on the office computer. The office computer name is \\GREG.  The three above user accounts all exist on the \\GREG computer which is running RAS Administrator. Why am I getting this message?

ANSWER:
What is happening is that after logging into your local computer, your local credentials are being cached and used when you are trying to access your network. The RAS authentication does not override your cached credentials. Follow the steps below for explanation.

What's Happening:
1.  You logon locally to your computer at home. Your computer name is home, your user name is greg, and your password is password. (ex. \\HOME\greg password)
2.  Using RAS, you dial into your corporate network. An authentication dialog box appears and you supply your RAS logon credentials. Your domain name is corp, your user name on the domain is greg, and your password is password. (ex. \\CORP\greg password)
3.  The connection succeeds and you then try to connect to a computer in the domain, for example, your office computer \\GREG. This is where you get an Access Denied message.

Why:
The reason is that in step two above, your RAS logon does not log you onto the network. It only verifies that you are allowed physical access to the network. Therefore, here is the situation:
You are logged on locally as \\HOME\greg password. These credentials are cached and used for all resource access locally and on the network. When you dialed into the network using RAS, your cached creditials did not change. Therefore, when you try to connect to a resource on the network, you give it:
\\HOME\greg password and it is expecting \\CORP\greg password. 

Two Possible Solutions:
1.  In step three above, when you are tying to connect to a computer on the network, provide your network creditials to override your local creditials. For example, at a DOS prompt, you would type
NET USE * \\GREG\PUBLIC /U:CORP\GREG. Or, in File Manager, in the Network Connect Drive dialog box, you would type CORP\GREG in the Connect As box. 

2.  You can join the domain from home. This causes your domain creditials to be cached on your home computer. To do this, have an Administrator add the name of your computer at home, \\HOME, to the domain and change your workgroup or domain name to corp. Then, follow the steps described in the online Help topic "Joining a Domain."

---------------------------------------------------
QUESTION:
When I run NetDDE on my Windows NT Server version 3.5, I cannot chat with anyone
who logs into my server via RAS or see their computer even if they have connected to a drive
on my computer. 

ANSWER:
Have the person you are trying to talk to start CHAT on their computer, then connect to them, or refer to the section above "Using Winchat with RAS". 

---------------------------------------------------
QUESTION:
When I connect to my local Internet host I use a script file to logon. But, when the script is finished I still have to manually press the Done button at the bottom of the window.
How can I automate this? It would be nice if some command in the script file could signal
"DONE", that way I could easily run a batch file via the AT service that would start a RAS 
connection and get my mail and news in the middle of the night, etc.

ANSWER:
There is no way to do this with terminal.  You can however, write a script that bypasses terminal and automates your logon. Once you have that working, you can use RASDIAL.EXE with the AT command. For more information about scripting, see the online Help topics about writing scripts.

---------------------------------------------------
QUESTION:
RAS gives the possibility to manage modem pooling connections, but I also need a dial-out service for Windows NT Server, like in NetWare Connect. Can you suggest a way?

ANSWER:
There is a Third-party modem pooling solution available for Windows NT, called Spartacom SAPS. You can reach Spartacom at Tel: (404) 455-0701 or Fax: (404) 457-9500.

---------------------------------------------------
QUESTION:
My RAS server presently uses DHCP to provide IP addresses to remote clients. If I understand 
the protocol correctly, this means that a large number of RAS sessions could exhaust the DHCP pool space, as the lease period is three days, and 'used' IP addresses do not get returned to the pool until after the three days are up.
For example if I had two RAS ports, eight DHCP addresses in the pool, and nine different
users accessed the server via RAS during one day, wouldn't the ninth find that there were no free IP address to allocate?
Is it therefore more prudent to use the static IP pool facility of RAS rather than DHCP, or is there something I have missed?

ANSWER:
For your two port server, you will only use three IP addresses: two for RAS clients and one for the server.  When a client calls in, it is given an IP address.  When the client hangs up, that address is returned to the RAS server for use with the next client.  So, no matter how many clients call in, at most you will use three addresses on your two port server at any given time.

---------------------------------------------------
QUESTION:
My LAN consists of one Novell 3.12 server and one Windows NT Server version 3.5. I would like to be able to remotely administer the Windows NT Server computer like I can using Rconsole in Novell.

I am going to be on the road much of the year and would like to be able to dial back into my Windows NT Server computer and troubleshoot remotely from my home computer or from my notebook computer like I can with Novell. I have talked with my local vendor and they have come back with the suggestion to install Windows NT Server version 3.5 on my home system and through RAS dial into my office server. Is this possible and is this the best way to do it?

ANSWER:
You do not need to install Windows NT Server on your home computer, you can do remote administration with Windows NT Workstation. If you install RAS on your office computer, you can then run RAS from the laptop to connect to it and do remote administration. 

For more information refer to the QUESTION and ANSWER section above which discusses an answer to your question in more detail.

---------------------------------------------------
QUESTION:
I'm getting the following Administrator Alert message from my Primary Domain Controller (PDC):
"Failed to authenticate with <UNKNOWN>, a Windows NT Domain Controller for
domain SITE2."

\\NTPDC is my primary domain controller at work and \\SITE2 is the domain controller at a second site.  They are set up to allow dial-in access from one to the other.  They both run Windows NT Server version 3.5.  What is this message trying to say and why does it occur hourly?

ANSWER:
The alert is telling you that one domain controller tried to connect with the other domain controller
to sync up the accounts, but the second domain controller could not be reached.
If you have a trust relationship between the two, and they are only connected via RAS, 
then you will get this alert when the connection is not active.

---------------------------------------------------
QUESTION:
Can I configure my Windows NT Server version 3.5 as a SLIP server for Windows for Workgroups clients? If so, what
do I need to do on the Windows NT Server side? What software will I need on the Windows for Workgroups client side?

ANSWER:
RAS is configurable as a PPP server, not as a SLIP server.  Unless there is a strong reason for using SLIP, just use the RAS that ships with Windows for Workgroups to connect to the Windows NT RAS server.
If you need IP instead of NetBEUI, use a third party PPP package on the Windows for Workgroups computer to give you PPP access.

---------------------------------------------------
QUESTION:
We have an Windows NT Server computer for our Windows for Workgroups clients. Is there a way for a Windows for Workgroups client to dial out
on the modem on the Windows NT Server using software like QuickLinks or Procom? Windows NT
is great for dialing in using RAS to connect to our network, but we need to share the modem at
the Windows NT Server to dial out from our workstations to access various BBSs or CompuServe.

ANSWER:
You will need to install a modem pooling package in order for this to work. You can use Spartacom software for this. Spartacom can be reached at Tel: (404) 455-0701 or Fax: (404) 457-9500.

---------------------------------------------------
QUESTION:
I have the call waiting service on my line at home - if someone calls me and my line is engaged then they are asked to wait and I get a gentle beep to tell me someone is waiting. This is a great idea for voice communication but my line goes down during data communication. I manually de-activate call waiting by phoning #43#. Can I automate this using RAS? I use RAS and Microsoft MSMail to connect to the office system from home.

ANSWER:
Add #43# to the beginning of the phone number Remote Access dials.

---------------------------------------------------
QUESTION:
After I modified the AutoDisconnect entry to five minutes, I restarted the computer, connected to our Internet Service Provider, and waited.  Ten minutes later the connection was still up. Maybe the ISP is pinging us? Or maybe the RAS AutoDisconnect feature just does not work?

ANSWER:
The RAS autodisconnect feature is tested regularly, and does work. Watch Remote Access Monitor to see if any packets are being sent. Just one packet will reset the idle disconnect timer to 0.
The autodisconnect is a Windows NT Server feature only. A RAS client does not autodisconnect.

---------------------------------------------------
QUESTION:
1) We have a Windows NT Server computer connected to a Novell network. We are using a
client/server package which communicates via IPX (NWIPXSPX.DLL), Gupta SQLBase
and a SQLWindows client application. We want clients to be able to use RAS to get to the Windows NT
Server computer, but also be able to hit the SQLBase NLM with an IPX protocol. Is this
possible?

2) Currently, RAS clients have a wide selection of COM ports to choose from.
Are there plans for RAS clients to use a NASI or network modem pool as their modem?
If so, how do we do this?

ANSWER:
1.) Have your RAS clients dial in using IPX.  They should then be able to access your IPX applications. Windows NT Workstation and Windows 95 RAS clients support IPX.

2.) There are plans for RAS to support modem pools in a future release. For now, you can use a package like SpartaCom for modem pooling on Windows NT.  You can reach Spartacom at Tel: (404) 455-0701 or Fax: (404) 457-9500.

---------------------------------------------------
QUESTION:
I am having a problem with my Hayes modem and RAS. Although I can connect to various 
locations with RAS without any problems, it normally takes a good ten or fifteen seconds to
hang up the modem (when selecting hang-up or exiting RAS completely).
I don't know if this is a RAS problem, modem problem or Windows NT problem. Has anyone
experienced this problem and, if so, can a remedy be given?

ANSWER:
In MODEM.INF, set the S3 value in the INIT string for your modem to something low like 1. 

---------------------------------------------------
QUESTION:
I have two Windows NT computers running RAS. One is running TCP/IP and is connected to the
Internet. The other Windows NT computer is on an isolated LAN. From this computer, I want to be able to connect to the first computer and access the Internet.
Does my second Windows NT computer need an IP address that will be recognized on
the Internet, or is the first Windows NT computer the one that actually communicates on the
Internet? When I am connected to the first Windows NT computer will I be a part of its subnet, or will I need my own subnet?

ANSWER:
See documentation in the Windows NT 3.5 Resource Kit on how to make this work.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\hlp\script.doc ===
Microsoft Word Document MSWordDoc Word.Document.6Microsoft CorporationNormal.dot Microsoft Word for Windows 95Dial-Up Scripting Command Language For Dial-Up Networking Scripting Support Copyright (c) 1995 Microsoft Corp. Table of Contents Overview Basic Structure of a Script Variables System Variables String Literals Expressions Comments Keywords Commands Reserved Words 1.0   Overview Many Internet service providers and online services require you to manually enter information, such as your user name and password, to establish a connection. With Scripting support for Dial-Up Networking, you can write a script to automate this process.  A script is a text file that contains a series of commands, parameters, and expressions required by your Internet service provider or online service to establish the connection and use the service. You can use any text editor, such as Microsoft Notepad, to create a script file. Once you've created your script file, you can then assign it to a specific Dial-Up Networking connection by running the Dial-Up Scripting Tool. 2.0   Basic Structure of a Script A command is the basic instruction that a script file contains. Some commands require parameters that further define what the command should do. An expression is a combination of operators and arguments that create a result. Expressions can be used as values in any command.  Examples of expressions include arithmetic, relational comparisons, and string concatenations. The basic form of a script for Dial-Up Networking follows: ; A comment begins with a semi-colon and extends to  ; the end of the line. proc main ;  A script can have any number of variables  ;  and commands variable declarations command block endproc A script must have a main procedure, specified by the proc keyword, and a matching endproc keyword, indicating the end of the procedure.   You must declare variables before you add commands. The first command in the main procedure is executed, and then any subsequent commands are executed in the order they appear in the script. The script ends when the end of the main procedure is reached. 3.0   Variables Scripts may contain variables. Variable names must begin with a letter or an underscore ('_'), and may contain any sequence of upper- or lower-case letters, digits, and underscores. You cannot use a reserved word as a variable name. For more information, see the list of reserved words at the end of this document. You must declare variables before you use them. When you declare a variable, you must also define its type. A variable of a certain type may only contain values of that same type. The following three types of variables are supported: Description integer A negative or positive number, such as 7, -12, or 5698. string A series of characters enclosed in double-quotes; for example, "Hello world!" or "Enter password:". boolean A logical boolean value of TRUE or FALSE. Variables are assigned values using the following assignment statement: variable = expression The variable gets the evaluated expression.   Examples: integer count = 5 integer timeout = (4 * 3) integer i boolean bDone = FALSE string szIP = (getip 2) set ipaddr szIP 3.1   System Variables System variables are set by scripting commands or are determined by the information your enter when you set up a Dial-Up Networking connection. System variables are read-only, which means they cannot be changed within the script. The system variables are: Description $USERID String The user identification for the current connection. This variable is  the value of the user name specified in the Dial-Up Networking  Connect To dialog box. $PASSWORD String The password for the current connection. This variable is the  value of the user name specified in the Dial-Up Networking  Connect To dialog box. $SUCCESS Boolean This variable is set by certain commands to indicate  whether or not the command succeeded. A script can make  decisions based upon the value of this variable. $FAILURE Boolean This variable is set by certain commands to indicate  whether or not the command failed. A script can make decisions  based upon the value of this variable. These variables may be used wherever an expression of a similar type is used. For example,  transmit $USERID is a valid command because $USERID is a variable of type string. 4.0   String Literals Scripting for Dial-Up Networking supports escape sequences and caret translations, as described below. String Literal Description ^char Caret translation If char is a value between '@' and '_', the character sequence is translated into a single-byte value between 0 and 31.  For example, ^M is converted to a carriage return. If char is a value between a and z, the character sequence is translated into a single-byte value between 1 and 26. If char is any other value, the character sequence is not specially treated. Carriage return Linefeed Double-quote Single caret Single '<' Backslash Examples: transmit "^M" transmit "Joe^M" transmit "<cr><lf>" waitfor "<cr><lf>" 5.0    Expressions An expression is a combination of operators and arguments that evaluates to a result.  Expressions can be used as values in any command. An expression can combine any variable, or integer, string, or boolean values with any of the unary and binary operators in the following tables. All unary operators take the highest precedence. The precedence of binary operators is indicated by their position in the table.  The unary operators are: Operator Type of Operation Unary minus One's complement The binary operators are listed in the following table in their order of precedence. Operators with higher precedence are listed first: Operators Type of Operation Type Restrictions                                      Multiplicative Integers +  -  Additive integers  Strings (+ only) < > <= >= Relational Integers == != Equality Integers, strings, booleans Logical AND Booleans Logical OR Booleans Examples: count = 3 + 5 * 40 transmit "Hello" + " there" delay 24 / (7 - 1) 6.0   Comments All text on a line following a semicolon is ignored. Examples: ; this is a comment transmit "hello" ; transmit the string "hello" 7.0   Keywords Keywords specify the structure of the script. Unlike commands, they do not perform an action. The keywords are listed below. proc name  Indicates the beginning of a procedure. All scripts must have a main procedure (proc main). Script execution starts at the main procedure and terminates at the end of the main procedure. endproc Indicates the end of a procedure. When the script is executed to the endproc statement for the main procedure, Dial-Up Networking will start PPP or SLIP.  integer name [ = value ]  Declares a variable of type integer. You can use any numerical expression or variable to  initialize the variable. string name [ = value ]  Declares a variable of type string. You can use any string literal or variable to initialize the variable. boolean name [ = value ]  Declares a variable of type boolean. You can use any boolean expression or variable to initialize the variable. 8.0   Commands All commands are reserved words, which means you cannot declare variables that have the same names as the commands. The commands are listed below: delay nSeconds Pauses for the number of seconds specified by nSeconds before executing the next command in the script. Examples: delay 2 ; pauses for 2 seconds delay x * 3 ; pauses for x * 3 seconds getip  value Waits for an IP address to be received from the remote computer. If your Internet service provider returns several IP addresses in a string, use the value parameter to specify which IP address the script should use. Examples: ; get the second IP address  set ipaddr getip 2 ; assign the first received IP address to a variable szAddress = getip goto label Jumps to the location in the script specified by label and continues executing the commands following it. Example:   waitfor "Prompt>" until 10   if !$SUCCESS then goto BailOut ; jumps to BailOut and executes commands  ; following it   endif   transmit "bbs^M"   goto End BailOut:   transmit "^M" Stops the script. This command does not remove the terminal dialog window. You must click Continue to establish the connection. You cannot restart the script. if condition then commands endif Executes the series of commands if condition is TRUE. Example: if $USERID == "John" then transmit "Johnny^M" endif label : Specifies the place in the script to jump to. A label must be a unique name and follow the naming conventions of variables. set port databits 5 | 6 | 7 | 8 Changes the number of bits in the bytes that are transmitted and received during the session. The number of bits can be between 5 and 8. If you do not include this command, Dial-Up Networking will use the properties settings specified for the connection. Example: set port databits 7 set port parity none | odd | even | mark | space Changes the parity scheme for the port during the session. If you do not include this command, Dial-Up Networking will use the properties settings specified for the connection. Example: set port parity even set port stopbits 1 | 2 Changes the number of stop bits for the port during the session. This number can be either 1 or 2. If you do not include this command, Dial-Up Networking uses the properties settings specified for the connection. Example: set port stopbits 2 set screen keyboard  on | off Enables or disables keyboard input in the scripting terminal window. Example: set screen keyboard on set ipaddr string Specifies the IP address of the workstation for the session. String must be in the form of an IP address. Examples: szIPAddress = "11.543.23.13" set ipaddr szIPAddress set ipaddr "11.543.23.13" set ipaddr getip transmit string [ , raw ] Sends the characters specified by string to the remote computer.  The remote computer will recognize escape sequences and caret translations, unless you include the raw parameter with the command. The raw parameter is useful when transmitting $USERID and $PASSWORD system variables when the user name or password contains character sequences that, without the raw parameter, would be interpreted as caret or escape sequences. Examples: transmit "slip" + "^M" transmit $USERID, raw waitfor string [ , matchcase ] [ then label  { , string [ , matchcase ] then label } ] [ until time ] Waits until your computer receives one or more of the specified strings from the remote computer. The string parameter is case-insensitive, unless you include the matchcase parameter. If a matching string is received and the then label parameter is used, this command will jump to the place in the script file designated by label. The optional until time parameter defines the maximum number of seconds that your computer will wait to receive the string before it execute the next command. Without this parameter, your computer will wait forever. If your computer receives one of the specified strings, the system variable $SUCCESS is set to TRUE. Otherwise, it is set to FALSE if the number of seconds specified by time elapses before the string is received.   Examples: waitfor "Login:" waitfor "Password?", matchcase waitfor "prompt>" until 10 waitfor "Login:" then DoLogin, "Password:" then DoPassword, "BBS:" then DoBBS, "Other:" then DoOther   until 10 while condition do commands endwhile Executes the series of commands until condition is FALSE. Example: integer count = 0 while count < 4 do transmit "^M" waitfor "Login:" until 10 if $SUCCESS then goto DoLogin endif count = count + 1 endwhile 9.0   Reserved Words The following words are reserved and may not be used as variable names. boolean databits delay endif endproc endwhile FALSE getip integer ipaddr keyboard matchcase parity screen space stopbits string transmit until waitfor while Normal Default Paragraph Font @\\NTPRINT\26N/1MC CORPI.PS 157.55.80.244 Ne03: winspool \\NTPRINT\26N/1MC CORPI.PS 157.55.80.244 HP LaserJet 4Si/4Si MX PS Letter HP LaserJet 4Si/4Si MX PS Letter Times New Roman Symbol Arial Courier New MS Sans Serif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ini\shared~1.ini ===
[Contents.Server]
00000001=0
00000002=0
00000003=0
00000004=0
00000005=0
00000006=0
00000007=0
[Server.00000001]
Title=FTP Server
Protocol=TCP
Port=21
InternalPort=21
BuiltIn=1
[Server.00000002]
Title=Telnet Server
Protocol=TCP
Port=23
InternalPort=23
BuiltIn=1
[Server.00000003]
Title=Internet Mail Server (SMTP)
Protocol=TCP
Port=25
InternalPort=25
BuiltIn=1
[Server.00000004]
Title=Post-Office Protocol Version 3 (POP3)
Protocol=TCP
Port=110
InternalPort=110
BuiltIn=1
[Server.00000005]
Title=Internet Mail Access Protocol Version 3 (IMAP3)
Protocol=TCP
Port=220
InternalPort=220
BuiltIn=1
[Server.00000006]
Title=Internet Mail Access Protocol Version 4 (IMAP4)
Protocol=TCP
Port=143
InternalPort=143
BuiltIn=1
[Server.00000007]
Title=Web Server (HTTP)
Protocol=TCP
Port=80
InternalPort=80
BuiltIn=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\auth\radius\radclnt.ini ===
[info]
drivername=Radclnt
symbolfile=perfmon.h

[languages]
009=English

[text]
RADIUS_CLIENT_COUNTER_OBJECT_009_NAME=RADIUS Client
RADIUS_CLIENT_COUNTER_OBJECT_009_HELP=RADIUS Client specific counters.
AUTHREQSENT_009_NAME=Authentication Requests Sent
AUTHREQSENT_009_HELP=The total number authentication requests sent.
AUTHREQFAILED_009_NAME=Authentication Requests Failed
AUTHREQFAILED_009_HELP=The total number failed authentication requests.
AUTHREQSUCCEDED_009_NAME=Authentication Requests Succeded
AUTHREQSUCCEDED_009_HELP=The total number successful authentication requests.
AUTHREQTIMEOUT_009_NAME=Authentication Requests Timeouts
AUTHREQTIMEOUT_009_HELP=The total number timeouts that occured for authentication requests.
ACCTREQSENT_009_NAME=Accounting Requests Sent
ACCTREQSENT_009_HELP=The total number accounting requests sent.
ACCTBADPACK_009_NAME=Bad accounting packets
ACCTBADPACK_009_HELP=The total number bad accounting packets.
ACCTREQSUCCEDED_009_NAME=Accounting Requests Succeded
ACCTREQSUCCEDED_009_HELP=The total number successful accounting requests.
ACCTREQTIMEOUT_009_NAME=Accounting Requests Timeouts
ACCTREQTIMEOUT_009_HELP=The total number timeouts that occured for accounting requests.
AUTHBADPACK_009_NAME=Bad authentication packets
AUTHBADPACK_009_HELP=The total number bad authentication packets.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raschap\chapx.txt ===
Network Working Group                                            S. Cobb
Informational Memo                                             Microsoft
Revision 1.3                                                  March 1997


                     Microsoft PPP CHAP Extensions


Status of this Memo

    This document has no official Internet Engineering Task Force
    status.  It is submitted as an example of one vendor's working
    solution to several authentication issues not yet standardized by
    the Point-to-Point Working Group.

    The protocol described is implemented in Microsoft Windows NT 3.5
    and 3.51 and in Microsoft Windows95.  Differences between the
    platforms are noted in the text.  This information, plus that in
    the references, is believed sufficient to implement an
    interoperating peer.

    Distribution of this memo is unlimited.


Abstract

    The Point-to-Point Protocol (PPP) [1] provides a standard method
    for transporting multi-protocol datagrams over point-to-point
    links.  PPP defines an extensible Link Control Protocol and a
    family of Network Control Protocols (NCPs) for establishing and
    configuring different network-layer protocols.

    This document describes Microsoft's PPP CHAP dialect (MS-CHAP),
    which extends the user authentication functionality provided on
    Windows networks to remote workstations.  MS-CHAP is closely
    derived from the PPP Challenge/Handshake Authentication Protocol
    described in RFC 1334 [2], which the reader should have at hand.


History

    Rev 1.21: (Sect 6) Fix error in implicit challenge description
    Rev 1.22: (Sect 7) Fix error in sub-field table ordering
    Rev 1.3:  (Sect 10) Added hash example section








Cobb                                                            [Page 1]

Memo                Microsoft PPP CHAP Extensions             March 1997


Table Of Contents

    1.  Introduction................................................3
    2.  LCP Configuration...........................................4
    3.  Challenge Packet............................................4
    4.  Response Packet.............................................4
    5.  Success Packet..............................................8
    6.  Failure Packet..............................................8
    7.  Change Password Packet (version 1)..........................9
    8.  Change Password Packet (version 2).........................12
    9.  Negotiation Examples.......................................16
    10. Hash Example...............................................16

    REFERENCES.....................................................18
    CHAIR'S ADDRESS................................................19
    AUTHOR'S ADDRESS...............................................19







































Cobb                                                            [Page 2]

Memo                Microsoft PPP CHAP Extensions             March 1997


1. Introduction

    Microsoft created MS-CHAP to authenticate remote Windows
    workstations, providing the functionality to which LAN-based users
    are accustomed.

    The closest fit available in standard PPP is CHAP which is
    primarily used for mutual secure authentication between WAN-aware
    routers.  Unfortunately, CHAP is not widely used in support of
    remote workstations where providers commonly require an insecure
    text login session in place of PPP authentication protocols.  To
    date, several remote workstation issues have not been adequately
    addressed in CHAP.  MS-CHAP addresses these issues and also
    integrates the encryption and hashing algorithms used on Windows
    networks.

    Where possible, MS-CHAP is consistent with standard CHAP, and the
    differences are easily modularized.  Microsoft implements MS-CHAP
    as extensions to it's standard CHAP code base.  Briefly,
    differences between MS-CHAP and standard CHAP are:

      * MS-CHAP is enabled by negotiating CHAP Algorithm 0x80 in LCP
        option 3, Authentication Protocol.

      * The MS-CHAP Response packet is in a format designed for
        compatibility with Microsoft Windows NT 3.5 and 3.51,
        Microsoft Windows95, and Microsoft LAN Manager 2.x networking
        products.  The MS-CHAP format does not require the
        authenticator to store a clear or reversibly encrypted
        password.

      * MS-CHAP provides an authenticator controlled authentication
        retry mechanism.

      * MS-CHAP provides an authenticator controlled change password
        mechanism.

      * MS-CHAP defines a set of reason-for-failure codes returned in
        the Failure packet Message field.
















Cobb                                                            [Page 3]

Memo                Microsoft PPP CHAP Extensions             March 1997


2. LCP Configuration

    The LCP configuration for MS-CHAP is identical to that for
    standard CHAP, except that the Algorithm field has value 0x80,
    rather than the MD5 value 0x05.  Non-MS-CHAP-aware implementations
    that correctly implement LCP Config-Rej have no problem dealing
    with this non-standard option.

    Microsoft currently negotiates authentication only on the
    server->workstation configuration.  Mutual authentication may be
    supported in the future.


3. Challenge Packet

    The MS-CHAP Challenge packet is identical in format to the
    standard CHAP Challenge packet.

    MS-CHAP authenticators send an 8-octet challenge Value field.  It
    is not necessary for peers to duplicate Microsoft's algorithm for
    selecting the 8-octet value, but the CHAP guidelines on randomness
    should be observed.

    Microsoft authenticators do not currently provide information in
    the Name field.  This may change in the future.


4. Response Packet

    The MS-CHAP Response packet is identical in format to the standard
    CHAP Response packet.  However, the Value field is sub-formatted
    differently as follows:

        24 octets: LAN Manager compatible challenge response
        24 octets: Windows NT compatible challenge response
         1 octet : "Use Windows NT compatible challenge response" flag

    The LAN Manager compatible challenge response is an encoded
    function of the password and the received challenge as output by
    the pseudo-code routine LmChallengeResponse below.  LAN Manager
    passwords are limited to 14 case-insensitive OEM characters.














Cobb                                                            [Page 4]

Memo                Microsoft PPP CHAP Extensions             March 1997


        LmChallengeResponse(
            IN  8-octet          Challenge,
            IN  0-to-14-oem-char Password,
            OUT 24-octet         Response )
        {
            LmPasswordHash(
                Password,
                giving PasswordHash )

            ChallengeResponse(
                Challenge,
                PasswordHash,
                giving Response )
        }

        LmPasswordHash(
            IN  0-to-14-oem-char Password,
            OUT 16-octet         PasswordHash )
        {
            Set UcasePassword to the uppercased Password
            Zero pad UcasePassword to 14 characters

            DesHash(
                1st 7-octets of UcasePassword,
                giving 1st 8-octets of PasswordHash )

            DesHash(
                2nd 7-octets of UcasePassword,
                giving 2nd 8-octets of PasswordHash )
        }

        DesHash(
            IN  7-octet Clear,
            OUT 8-octet Cypher )
        {
            Make Cypher an irreversibly encrypted form of Clear by
            encrypting known text [6] using Clear as the secret key,
            that is...

            DesEncrypt(
                StdText,
                Clear,
                giving Cypher )
        }











Cobb                                                            [Page 5]

Memo                Microsoft PPP CHAP Extensions             March 1997


        DesEncrypt(
            IN  8-octet Clear,
            IN  7-octet Key,
            OUT 8-octet Cypher )
        {
            Use the DES encryption algorithm [3] to encrypt Clear into
            Cypher such that Cypher can only be decrypted back to
            Clear by providing Key.  Note that the DES algorithm takes
            as input a 64-bit stream where the 8th, 16th, 24th, etc
            bits are parity bits ignored by the encrypting algorithm.
            Unless you write your own DES to accept 56-bit input
            without parity, you will need to insert the parity bits
            yourself.
        }

        ChallengeResponse(
            IN  8-octet  Challenge,
            IN  16-octet PasswordHash,
            OUT 24-octet Response )
        {
            Set ZPasswordHash to PasswordHash zero padded to 21 octets

            DesEncrypt(
                Challenge,
                1st 7-octets of ZPasswordHash,
                giving 1st 8-octets of Response )

            DesEncrypt(
                Challenge,
                2nd 7-octets of ZPasswordHash,
                giving 2nd 8-octets of Response )

            DesEncrypt(
                Challenge,
                3rd 7-octets of ZPasswordHash,
                giving 3rd 8-octets of Response )
        }


    The Windows NT compatible challenge response is an encoded
    function of the password and the received challenge as output by
    the NtChallengeResponse routine below.  The Windows NT password is
    a string of 0 to (theoretically) 256 case-sensitive Unicode
    characters.  Current versions of Windows NT limit passwords to 14
    characters, mainly for compatibility reasons, though this may
    change in the future.









Cobb                                                            [Page 6]

Memo                Microsoft PPP CHAP Extensions             March 1997


        NtChallengeResponse(
            IN  8-octet               Challenge,
            IN  0-to-256-unicode-char Password,
            OUT 24-octet              Response )
        {
            NtPasswordHash(
                Password,
                giving PasswordHash )

            ChallengeResponse(
                Challenge,
                PasswordHash,
                giving Response )
        }

        NtPasswordHash(
            IN  0-to-256-unicode-char Password,
            OUT 16-octet              PasswordHash )
        {
            Use the MD4 algorithm [4] to irreversibly hash Password
            into PasswordHash.  Only the password is hashed without
            including any terminating 0.
        }

    The "use Windows NT compatible challenge response" flag, if 1,
    indicates that the Windows NT response is provided and should be
    used in preference to the LAN Manager response.  The LAN Manager
    response will still be used if the account does not have a Windows
    NT password hash, e.g. if the password has not been changed since
    the account was uploaded from a LAN Manager 2.x account database.
    The LAN Manager response need not be provided (set to 0's) if the
    implementation expects all user accounts to be stored only in
    fresh Windows NT account databases or ones where all uploaded
    passwords have been changed.  However, doing so may sacrifice
    downward compatibility with non-Windows-NT servers.

    If the flag is 0, the Windows NT response is ignored and the LAN
    Manager response is used.  If the password is LAN Manager
    compatible, interoperability may be achieved without providing the
    Windows NT challenge response (set to 0's), and providing only the
    LAN Manager response.  This is what Microsoft Windows95 does,
    though this may change in the future.  Doing so may sacrifice
    interoperability with OEM-specific versions of Windows NT designed
    for maximum security in Windows-NT-only networks.

    Implementors seeking the broadest possible interoperability are
    advised to supply both responses when the password is LAN Manager
    compatible.  This is what Microsoft Windows NT does.







Cobb                                                            [Page 7]

Memo                Microsoft PPP CHAP Extensions             March 1997


    The Name field identifies the authenticatee's user account name.
    The Windows NT domain name may prefix the user's account name in
    the typical Windows NT format, e.g. "redmond\stevec" where
    "redmond" is a Windows NT domain containing the user account
    "stevec".  If a domain is not provided, the backslash should also
    be omitted, e.g. "stevec".


5. Success Packet

    The Success packet is identical in format to the standard CHAP
    Success packet.


6. Failure Packet

    The Failure packet is identical in format to the standard CHAP
    Failure packet.  There is, however, formatted text stored in the
    Message field which, contrary to the standard CHAP rules, does
    affect the protocol.  The Message field format is:

        "E=eeeeeeeeee R=r C=cccccccccccccccc V=vvvvvvvvvv"

    where

        The "eeeeeeeeee" is the decimal error code (need not be 10
        digits) corresponding to one of those listed below, though
        implementations should deal with codes not on this list
        gracefully.

            646 ERROR_RESTRICTED_LOGON_HOURS
            647 ERROR_ACCT_DISABLED
            648 ERROR_PASSWD_EXPIRED
            649 ERROR_NO_DIALIN_PERMISSION
            691 ERROR_AUTHENTICATION_FAILURE
            709 ERROR_CHANGING_PASSWORD

        The "r" is a flag set to "1" if a retry is allowed, and "0" if
        not.  When authenticator sets this flag to "1" it disables
        short timeouts, expecting the authenticatee to prompt the user
        for new credentials and resubmit the response.

        The "cccccccccccccccc" is 16 hex digits representing an ASCII
        representation of a new challenge value.  This field is
        optional.  If it is not sent, authenticator expects the
        resubmitted response to be calculated based on the previous
        challenge value plus decimal 23 in the first octet, i.e. the
        one immediately following the Value Size field.  Windows95
        authenticators may send this field.  Windows NT authenticators
        do not, but may in the future.  Both systems implement
        authenticatee support of this field.




Cobb                                                            [Page 8]

Memo                Microsoft PPP CHAP Extensions             March 1997


        The "vvvvvvvvvv" is the decimal version code (need not be 10
        digits) indicating the MS-CHAP protocol version supported on
        the server.  Currently, this is interesting only in selecting
        a Change Password packet type.  If the field is not present
        the version should be assumed 1.

    Implementations should accept but ignore additional text they do
    not recognize.


7. Change Password Packet (version 1)

    The version 1 Change Password packet does not appear in standard
    CHAP.  It allows the authenticatee to change the password on the
    account specified in the previous Response packet.  The version 1
    Change Password packet should be sent only if the authenticator
    reports ERROR_PASSWD_EXPIRED (E=648) in the Message field of the
    Failure packet.

    This packet type is supported by Windows NT 3.5 and 3.51.  It is
    not supported by Windows95, though this may change in the future.
    See also Change Password Packet (version 2).

    The format of this packet is as follows:

       1 octet : Code (=5)
       1 octet : Identifier
       2 octets: Length (=72)
      16 octets: Encrypted LAN Manager Old password Hash
      16 octets: Encrypted LAN Manager New Password Hash
      16 octets: Encrypted Windows NT Old Password Hash
      16 octets: Encrypted Windows NT New Password Hash
       2 octets: Password Length
       2 octets: Flags


    Code

        5


    Identifier

        The Identifier field is one octet and aids in matching
        requests and replies.  The value is the Identifier of the
        received Failure packet to which this packet responds plus 1.


    Length

        72




Cobb                                                            [Page 9]

Memo                Microsoft PPP CHAP Extensions             March 1997


    Encrypted LAN Manager New Password Hash
    Encrypted LAN Manager Old Password Hash

        These fields contain the LAN Manager password hash of the new
        and old passwords encrypted with an 8-octet key value [6], as
        output by the pseudo-code routine LmEncryptedPasswordHash
        below.

        LmEncryptedPasswordHash(
            IN  0-to-14-oem-char Password,
            IN  8-octet          KeyValue,
            OUT 16-octet         Cypher )
        {
            LmPasswordHash(
                Password,
                giving PasswordHash )

            PasswordHashEncryptedWithBlock(
                PasswordHash,
                KeyValue,
                giving Cypher )
        }

        PasswordHashEncryptedWithBlock(
            IN  16-octet PasswordHash,
            IN  7-octet  Block,
            OUT 16-octet Cypher )
        {
            DesEncrypt(
                1st 8-octets PasswordHash,
                1st 7-octets Block,
                giving 1st 8-octets Cypher )

            DesEncrypt(
                2nd 8-octets PasswordHash,
                1st 7-octets Block,
                giving 2nd 8-octets Cypher )
        }


    Encrypted Windows NT New Password Hash
    Encrypted Windows NT Old Password Hash

        These fields contain the Windows NT password hash of the new
        and old passwords encrypted with an 8-octet key value [6], as
        output by the pseudo-code routine NtEncryptedPasswordHash
        below.








Cobb                                                           [Page 10]

Memo                Microsoft PPP CHAP Extensions             March 1997


        NtEncryptedPasswordHash(
            IN  0-to-14-oem-char Password
            IN  8-octet          Challenge
            OUT 16-octet         Cypher )
        {
            NtPasswordHash(
                Password,
                giving PasswordHash )

            PasswordHashEncryptedWithBlock(
                PasswordHash,
                Challenge,
                giving Cypher )
        }


    Password Length

        The length in octets of the LAN Manager compatible form of the
        new password.  If this value is less than or equal to 14 it is
        assumed that the encrypted LAN Manager password hash fields
        are valid.  Otherwise, it is assumed these fields are not
        valid, in which case the Windows NT compatible passwords must
        be provided.


    Flags

        Bit field of option flags where 0 is the least significant bit
        of the 16-bit quantity:

            0    : Set 1 indicates that the encrypted Windows NT
                   hashed passwords are valid and should be used.  If
                   0, the Windows NT fields are not used and the LAN
                   Manager fields must be provided.

                   For the broadest possible interoperability,
                   implementations are encouraged to provide both the
                   Windows NT and LAN Manager fields when the password
                   is LAN Manager compatible.  This is what Windows NT
                   does.

            1-15 : Reserved, always set 0.












Cobb                                                           [Page 11]

Memo                Microsoft PPP CHAP Extensions             March 1997


8. Change Password Packet (version 2)

    The version 2 Change Password packet does not appear in standard
    CHAP.  It allows the authenticatee to change the password on the
    account specified in the previous Response packet.  The version 2
    Change Password packet should be sent only if the authenticator
    reports ERROR_PASSWD_EXPIRED (E=648) and a version of 2 or more in
    the Message field of the Failure packet.

    This packet type is supported by Windows NT 3.51.  It is not
    supported by Windows NT 3.5 or Windows95, though the latter may
    change in the future.  The version 2 change password packet type
    is preferable to the version 1 type and should be offered and
    accepted where possible.

    The format of this packet is as follows:

         1 octet  : Code (=6)
         1 octet  : Identifier
         2 octet  : Length (=1070)
       516 octets : Password Encrypted with Old NT Hash
        16 octets : Old NT Hash Encrypted with New NT Hash
       516 octets : Password Encrypted with Old LM Hash
        16 octets : Old LM Hash Encrypted With New NT Hash
        24 octets : LAN Manager compatible challenge response
        24 octets : Windows NT compatible challenge response
         2-octet  : Flags


    Code

        6


    Identifier

        The Identifier field is one octet and aids in matching
        requests and replies.  The value is the Identifier of the
        received Failure packet to which this packet responds plus 1.


    Length

        1118


    Password Encrypted with Old NT Hash

        This field contains the PWBLOCK form of the new Windows NT
        password encrypted with the old Windows NT password hash, as
        output by the NewPasswordEncryptedWithOldNtPasswordHash
        routine below:



Cobb                                                           [Page 12]

Memo                Microsoft PPP CHAP Extensions             March 1997


        datatype-PWBLOCK
        {
            256-unicode-char Password
            4-octets         PasswordLength
        }

        NewPasswordEncryptedWithOldNtPasswordHash(
            IN  0-to-256-unicode-char NewPassword,
            IN  0-to-256-unicode-char OldPassword,
            OUT datatype-PWBLOCK      EncryptedPwBlock )
        {
            NtPasswordHash(
                OldPassword,
                giving PasswordHash )

            EncryptPwBlockWithPasswordHash(
                NewPassword,
                PasswordHash,
                giving EncryptedPwBlock )
        }

        EncryptPwBlockWithPasswordHash(
            IN  0-to-256-unicode-char Password,
            IN  16-octet              PasswordHash,
            OUT datatype-PWBLOCK      PwBlock )
        {
            Fill ClearPwBlock with random octet values
            lstrcpyW( to ClearPwBlock.Password, from Password )
            ClearPwBlock.PasswordLength = lstrlenW( Password )

            Rc4Encrypt(
                ClearPwBlock,
                sizeof( ClearPwBlock ),
                PasswordHash,
                sizeof( PasswordHash ),
                giving PwBlock )
        }

        Rc4Encrypt(
            IN  x-octet Clear,
            IN  integer ClearLength,
            IN  y-octet Key,
            IN  integer KeyLength,
            OUT x-octet Cypher )
        {
            Use the RC4 encryption algorithm [5] to encrypt Clear of
            length ClearLength octets into a Cypher of the same length
            such that the Cypher can only be decrypted back to Clear
            by providing a Key of length KeyLength octets.
        }





Cobb                                                           [Page 13]

Memo                Microsoft PPP CHAP Extensions             March 1997


    Old NT Hash Encrypted with New NT Hash

        This field contains the old Windows NT password hash encrypted
        with the new Windows NT password hash, as output by the
        OldNtPasswordHashEncryptedWithNewNtPasswordHash routine below:

        OldNtPasswordHashEncryptedWithNewNtPasswordHash(
            IN  0-to-256-unicode-char NewPassword,
            IN  0-to-256-unicode-char OldPassword,
            OUT 16-octet              EncryptedPasswordHash )
        {
            NtPasswordHash(
                OldPassword,
                giving OldPasswordHash )

            NtPasswordHash(
                NewPassword,
                giving NewPasswordHash )

            PasswordHashEncryptedWithBlock(
                OldPasswordHash,
                NewPasswordHash,
                giving EncrytptedPasswordHash )
        }


    Password Encrypted with Old LM Hash

        This field contains the PWBLOCK form of the new Windows NT
        password encrypted with the old LAN Manager password hash, as
        output by the NewPasswordEncryptedWithOldLmPasswordHash
        routine below:

        NewPasswordEncryptedWithOldLmPasswordHash(
            IN  0-to-256-unicode-char NewPassword,
            IN  0-to-256-unicode-char OldPassword,
            OUT datatype-PWBLOCK      EncryptedPwBlock )
        {
            LmPasswordHash(
                OldPassword,
                giving PasswordHash )

            EncryptPwBlockWithPasswordHash(
                NewPassword,
                PasswordHash,
                giving EncryptedPwBlock )
        }








Cobb                                                           [Page 14]

Memo                Microsoft PPP CHAP Extensions             March 1997


    Old LM Hash Encrypted with New NT Hash

        This field contains the old LAN Manager password hash encrypted
        with the new Windows NT password hash, as output by the
        OldLmPasswordHashEncryptedWithNewNtPasswordHash routine below:

        OldLmPasswordHashEncryptedWithNewNtPasswordHash(
            IN  0-to-256-unicode-char NewPassword,
            IN  0-to-256-unicode-char OldPassword,
            OUT 16-octet              EncryptedPasswordHash )
        {
            LmPasswordHash(
                OldPassword,
                giving OldPasswordHash )

            NtPasswordHash(
                NewPassword,
                giving NewPasswordHash )

            PasswordHashEncryptedWithBlock(
                OldPasswordHash,
                NewPasswordHash,
                giving EncrytptedPasswordHash )
        }


    LAN Manager compatible challenge response
    Windows NT compatible challenge response

        The challenge response fields as described in the Response
        packet description, but calculated on the new password and the
        same challenge used in the last response.


    Flags

        Bit field of option flags:

            0    : The "use Windows NT compatible challenge response"
                   flag as described in the Response packet.

            1    : Set 1 indicates that the "Password Encrypted with
                   Old LM Hash" and "Old LM Hash Encrypted With New NT
                   Hash" fields are valid and should be used.  Set 0
                   indicates these fields are not valid.

                   For the broadest possible interoperability,
                   implementations are encouraged to provide both the
                   Windows NT and LAN Manager fields when the password
                   is LAN Manager compatible.  This is what Windows NT
                   does.

            2-15 : Reserved, always set 0.


Cobb                                                           [Page 15]

Memo                Microsoft PPP CHAP Extensions             March 1997


9. Negotiation Examples

    Here are some examples of typical negotiations.  The authenticatee
    is on the left and the authenticator is on the right.

    The packet sequence ID is incremented on each authentication retry
    Response and on the change password response.  All cases where the
    packet sequence ID is updated are noted below.

    Response retry is never allowed after either Change Password.
    Change Password may occur after Response retry.  The implied
    challenge form is shown in the examples, though all cases of
    "first challenge+23" should be replaced by the
    "C=cccccccccccccccc" challenge if authenticator supplies it in the
    Failure packet.


    Successful authentication

            <- Challenge
        Response ->
            <- Success


    Failed authentication with no retry allowed

            <- Challenge
        Response ->
            <- Failure (E=691 R=0)


    Successful authentication after retry

            <- Challenge
        Response ->
            <- Failure (E=691 R=1), disable short timeout
        Response (++ID) to first challenge+23 ->
            <- Success


    Failed hack attack with 3 attempts allowed

            <- Challenge
        Response ->
            <- Failure (E=691 R=1), disable short timeout
        Response (++ID) to first challenge+23 ->
            <- Failure (E=691 R=1), disable short timeout
        Response (++ID) to first challenge+23+23 ->
            <- Failure (E=691 R=0)






Cobb                                                           [Page 16]

Memo                Microsoft PPP CHAP Extensions             March 1997


    Successful authentication with password change

            <- Challenge
        Response ->
            <- Failure (E=648 R=0), disable short timeout
        ChangePassword (++ID) to first challenge ->
            <- Success

    Successful authentication with retry and password change

            <- Challenge
        Response ->
            <- Failure (E=691 R=1), disable short timeout
        Response (++ID) to first challenge+23 ->
            <- Failure (E=648 R=0), disable short timeout
        ChangePassword (++ID) to first challenge+23 ->
            <- Success


10. Hash Example

    Intermediate values for password "MyPw".

    8-octet Challenge:
    10 2D B5 DF 08 5D 30 41

    0-to-14-oem-char LmPassword:
    4D 59 50 57

    16-octet LmPasswordHash:
    75 BA 30 19 8E 6D 19 75 AA D3 B4 35 B5 14 04 EE

    24-octet LmChallengeResponse:
    91 88 1D 01 52 AB 0C 33 C5 24 13 5E C2 4A 95 EE
    64 E2 3C DC 2D 33 34 7D

    0-to-256-unicode-char NtPassword:
    4D 00 79 00 50 00 77 00

    16-octet NtPasswordHash:
    FC 15 6A F7 ED CD 6C 0E DD E3 33 7D 42 7F 4E AC

    24-octet NtChallengeResponse:
    4E 9D 3C 8F 9C FD 38 5D 5B F4 D3 24 67 91 95 6C
    A4 C3 51 AB 40 9A 3D 61










Cobb                                                           [Page 17]

Memo                Microsoft PPP CHAP Extensions             March 1997


REFERENCES

    [1] Simpson, W., "The Point-to-Point Protocol (PPP)", RFC 1331,
        Daydreamer, May 1992

    [2] LLoyd, B and Simpson, W., "PPP Authentication Protocols",
        RFC 1334, L&A and Daydreamer respectively, Octobet 1992

    [3] "Data Encryption Standard (DES)" is Federal Information
        Processing Standard publication 46, National Institute of
        Standard and Techology.

    [4] Rivest, R., "MD4 Message Digest Algorithm", RFC 1320, MIT
        Laboratory for Computer Science and RSA Data Security, Inc.,
        April 1992.

    [5] RC4 is an encryption standard available from RSA Data Security
        Inc.

    [6] The 8-octet StdText string used in the LAN Manager compatible
        password hashing and the 8-octet KeyValue used in the Change
        Password (version 1) packet are not available for public
        distribution at this time.  Contact the Microsoft Developer
        Relations group (at time of writing dbeaver@microsoft.com) for
        details on obtaining these values.  On this particular point
        the author can't help you.





























Cobb                                                           [Page 18]

Memo                Microsoft PPP CHAP Extensions             March 1997


CHAIR'S ADDRESS

    The working group can be contacted via the current chair:

        Fred Baker
        Email: fred@cisco.com



AUTHOR'S ADDRESS

    The author is a developer in Microsoft's Windows NT
    Internetworking group, which monitors the ietf-ppp@merit.edu
    discussions.  Questions can also be directed as below, where email
    is preferred.

        Steve Cobb
        Microsoft Corporation
        One Microsoft Way
        Redmond, WA  98052-6399

        Email: stevec@microsoft.com

    The author maintains an informal mailing list of persons
    interested in MS-CHAP and other news regarding Windows NT support
    for PPP authentication protocols.  Send email if interested.





























Cobb                                                           [Page 19]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ppp\raseap\test\readme.txt ===
This directory contains the source files for a sample Extensible 
Authentication Protocol (EAP) DLL.

ceapcfg.cpp
ceapcfg.h
ceapcfg.rgs
eap.c
eap.def
eap.h
eap.rc
exports.cpp
resource.h

This sample requires ATL v2.1 or ATL v3.0.

To run the sample EAP DLL, do the following:

On the server:

1) run "regsvr32 eap.dll"
2) In the Routing and RemoteAccess Properties, check EAP in the Security tab.
3) Check "Grant Remote Access Permission" in the Remote Access Policy.
4) Edit the profile, check EAP and choose the Sample EAP.
5) Reboot.

On the client:

1) run "regsvr32 eap.dll"
2) Reboot.

For more information about developing for EAP on Windows, see the SDK documentation and the raseapif.h header file.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\common\pbk\notes.txt ===
-------------------------------------------
Notes on phonebook changes between versions
-------------------------------------------



Notes on phonebook changes for NT5/Connections
----------------------------------------------

PBK.LIB is a private static library shared by RASDLG.DLL, RASAPI32.DLL, and
RASMON.EXE.  It's purpose is to encapsulate phonebook file manipulation,
presenting an easy to handle linked-list-of-phonebook-entry structures to the
caller along with appropriate helper routines.  The library provides a finer
granularity of control than the public Win32 RasGetEntryProperties API which
depends on this library.

PBK.LIB has existed for several versions of the product.  It includes code to
automatically upgrade entries from previous versions on the fly.  Converting
them to the current format when read, and writing them in the current format
when written.  This will carry forward to Connections.

Following is a summary of conversions from NT4 to NT5/Connections:

    * "Guid" is generated and assigned to each entry on creation.  Upgrade
      adds the Guid if it doesn't exist.

    * AreaCode, CountryCode, CountryID, and UseDialingRules are now associated
      with each individual phone number instead of one for the set.  This
      requires changes to the separate phonenum.lib and possibly to RASAPI32.
      Upgrade will duplicate any existing single setting for each alternate
      number.

    * Comments are now associated with each individual phone number instead of
      one Description for the entry.  Upgrade will associate any existing
      Description with the first phone number.

    * New "SharedPhoneNumbers" flag identifies whether phone number for first
      link is same as all subsequent links.  For RASAPI32's convenience, the
      phone numbers will be written to subsequent links anyway, but this flag
      eliminates the need to compare lists of phone numbers each time the
      entry is read, and returns user to what he entered in a case where he
      explicitly enters the same phone numbers for each device.  Upgrade will
      calculate the value of the flag once and it will be maintained by the
      UI.

    * New "ShowMonitorIconInTaskbar", "PreviewUserPw", "PreviewPhoneNumber"
      and "DisplayProgress" flags per UI prototype.  Upgrade will set the
      flags according to the corresponding global user preference settings.
      They will thereafter have fixed defaults.

    * New "TryNextAlternateOnFail" flags per device.  RASAPI must provide the
      functionality.

    * AR_Custom bit added to AuthRestrictions for EAP.

    * DE_Ipsec* codes added.  Old 'DE_Weak' renamed DE_Mppe40bit.  Old
      'DE_Strong' renamed 'DE_Mppe128bit'.

    * dwScriptMode is replaced with fScriptXxx and fScriptXxxTerminal flags.
      This is because the UI now gives user control over whether the terminal
      window appears with the script running.  This used to occur always on
      "after" scripts and never on "before" scripts.

    * New "PrerequisiteEntry" key storing name of WAN entry VPN depends on for
      double dialing.

    * On upgrade of old entries, "OverridePref" bits for redial
      attepts/seconds, idle disconnect seconds, and redial on link failure are
      set, if clear, and the field value set to the user preference settings.

    * Port/Device

        TAPI tries to be a device-centric model, while RASMAN is a
        port-centric model.  In NT4 the phonebook in port-centric.  While the
        NT5/Connections UI is device-centric, i.e. port names are no longer
        displayed *sigh*, the phonebook will remain as in NT4 with regard to
        port/device handling EXCEPT that the lookup of the PBPORT associated
        with a pair of Port/Device keys will be by Device, rather than by
        Port.

        Regarding ISDN B-channel naming, the NT5/Connections UI will not
        distinguish between two B-channels by port name as was done in the
        past.  All B-channels on the same adapter will have the same device
        name.

        RASMAN is the one responsible for mapping ISDN B-channel ports to any
        available ISDN B-channel, i.e. ignoring the explicit ISDNx port
        written in the phonebook.

    * MXS modems are retired.  Any MXS modem entries are assigned to first
      Unimodem port.


Entry format change details:

    [ENTRY]                         ;same
    Type=<RASET-code>               ;New
    Description=<description>       ;Deleted, becomes "Comment" of 1st phone#
    AutoLogon=<1/0>                 ;same
    DialParamsUID=<unique-ID>       ;same, or need upgrade to GUID?
    Guid=<guid>                     ;New, for use by ShaunCo across systems
    UsePwForNetwork=<1/0>           ;Deleted, unused
    ServerType=<ST-code>            ;Deleted, unused
    BaseProtocol=<BP-code>          ;same
    Authentication=<AS-code>        ;same
    ExcludedProtocols=<NP-bits>     ;same
    LcpExtensions=<1/0>             ;same
    DataEncryption=<DE-code>        ;same, but new codes for IpSec
    SkipNwcWarning=<1/0>            ;same
    SkipDownLevelDialog=<1/0>       ;same
    SwCompression=<1/0>             ;same
    UseCountryAndAreaCodes=<1/0>    ;Deleted, becomes "UseDRules" of 1st phone#
    AreaCode=<string>               ;Deleted, becomes "AreaCode" of 1st phone#
    CountryID=<id>                  ;Deleted, becomes "CountryID" of 1st #
    CountryCode=<code>              ;Deleted, becomes "CountryCode" of 1st #
    ShowMonitorIconInTaskBar=<1/0>  ;New
    CustomAuthKey=<EAP-code>        ;New, an option read from registry
    CustomAuthData=<hexdump>        ;New, blob returned by custom auth DLL
    AuthRestrictions=<AR-code>      ;same, but AR_Custom added for EAP
    OverridePref=<RASOR-bits>       ;same, but all existing bits set by default
    DialMode=<DM-code>              ;same, but RASEDM_DialFirstAvailable added
    DialPercent=<0-100>             ;same
    DialSeconds=<1-n>               ;same
    HangUpPercent=<0-100>           ;same
    HangUpSeconds=<1-n>             ;same
    RedialAttempts=<n>              ;same
    RedialSeconds=<n>               ;same
    IdleDisconnectSeconds=<-1,0-n>  ;same
    RedialOnLinkFailure=<1/0>       ;same
    CallbackMode=<1/0>              ;same
    CustomDialDll=<path>            ;same, i.e. NYI
    CustomDialFunc=<func-name>      ;same, i.e. NYI
    AuthenticateServer=<1/0>        ;same
    SecureLocalFiles=<1/0>          ;Deleted, replaced with...
    ShareMsFilePrint=<1/0>          ;New
    BindMsNetClient=<1/0>           ;New
    SharedPhoneNumbers=<1/0>        ;New
    PrerequisiteEntry=<entry-name>  ;New
    PreviewUserPw=<1/0>             ;New
    PreviewDomain=<1/0>             ;New
    PreviewPhoneNumber=<1/0>        ;New
    ShowDialingProgress=<1/0>       ;New

    IpPrioritizeRemote=<1/0>        ;same (PPP/SLIP only)
    IpHeaderCompression=<1/0>       ;same (PPP/SLIP only)
    IpAddress=<a.b.c.d>             ;same (PPP/SLIP only)
    IpAssign=<ASRC-code>            ;same (PPP/SLIP only)
    IpDnsAddress=<a.b.c.d>          ;same (PPP/SLIP only)
    IpDns2Address=<a.b.c.d>         ;same (PPP/SLIP only)
    IpWinsAddress=<a.b.c.d>         ;same (PPP/SLIP only)
    IpWins2Address=<a.b.c.d>        ;same (PPP/SLIP only)
    IpNameAssign=<ASRC-code>        ;same (PPP/SLIP only)
    IpFrameSize=<1006/1500>         ;same (SLIP only)

    In general each section contains subsections delimited by
    MEDIA=<something> and DEVICE=<something> lines.  There can be any number
    of DEVICE subsections.  There can be multiple MEDIA/DEVICE sets where the
    position of the set determines it's sub-entry index, the first being 1,
    the second 2, etc.

    For serial media, the program currently expects 1 to 4 DEVICE subsections,
    representing a preconnect switch, modem, X.25 PAD, and postconnect switch.
    Following is a full entry:

    MEDIA=serial                    ;same
    Port=<port-name>                ;same
    Device=<device-name>            ;same
    ConnectBps=<bps>                ;same, for old MXS support only

    DEVICE=switch                   ;same
    Type=<switchname or Terminal>   ;Deleted, converted to 2 fields below
    Name=<switchname>               ;New, name of switch or empty if none
    Terminal=<1/0>                  ;New, terminal is to run with/without above

    DEVICE=modem                    ;same

    PhoneNumber=<phonenumber1>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-text1>       ;New, 'Description' from upgrade
    ...
    PhoneNumber=<phonenumber2>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-text2>       ;New
    ...
    PhoneNumber=<phonenumberN>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-textn>       ;New

    LastSelectedPhone=<index>       ;New
    PromoteAlternates=<1/0>         ;same
    TryNextAlternateOnFail=<1/0>    ;New

    TapiBlob=<hexdump>              ;same, i.e. #if 0'd out
    ManualDial=<1/0>                ;For old MXS support only
    HwFlowControl=<1/0>             ;For old MXS support only
    Protocol=<1/0>                  ;For old MXS support only
    Compression=<1/0>               ;For old MXS support only

    DEVICE=pad                      ;same
    X25Pad=<padtype>                ;same
    X25Address=<X121address>        ;same
    UserData=<userdata>             ;same
    Facilities=<facilities>         ;same

    DEVICE=switch                   ;same
    Type=<switchname or Terminal>   ;Deleted, converted to 2 fields below
    Name=<switchname>               ;New, name/path of switch or empty if none
    Terminal=<1/0>                  ;New, terminal is to run with/without above

    For ISDN media, the program expects exactly 1 DEVICE subsection.  Note
    that ISDN is now identical to the "other" case.

    MEDIA=isdn                      ;same
    Port=<port-name>                ;same
    Device=<device-name>            ;same

    DEVICE=isdn                     ;same

    PhoneNumber=<phonenumber1>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-text1>       ;New, 'Description' from upgrade
    ...
    PhoneNumber=<phonenumber2>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-text2>       ;New
    ...
    PhoneNumber=<phonenumberN>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-textn>       ;New

    LastSelectedPhone=<index>       ;New
    PromoteAlternates=<1/0>         ;same
    TryNextPhoneNumberOnFail=<1/0>  ;New

    LineType=<0/1/2>                ;same
    Fallback=<1/0>                  ;same
    EnableCompression=<1/0>         ;For old protocol only
    ChannelAggregation=<channels>   ;For old protocol only

    For X.25 media, the program expects exactly 1 DEVICE subsection.

    MEDIA=x25                       ;same
    Port=<port-name>                ;same
    Device=<device-name>            ;same

    DEVICE=x25                      ;same
    X25Address=<X121address>        ;same
    UserData=<userdata>             ;same
    Facilities=<facilities>         ;same

    For other media, the program expects exactly one DEVICE subsection with
    device name matching the media.  "Other" media and devices are created for
    entries assigned to all non-serial medias including ISDN which now matches
    the rules for "other".

    MEDIA=<media>                   ;same
    Port=<port-name>                ;same
    Device=<device-name>            ;same

    DEVICE=<media>                  ;same

    PhoneNumber=<phonenumber1>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-text1>       ;New, 'Description' from upgrade
    ...
    PhoneNumber=<phonenumber2>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-text2>       ;New
    ...
    PhoneNumber=<phonenumberN>      ;same
    AreaCode=<area-code1>           ;New
    CountryID=<id>                  ;New
    CountryCode=<country-code>      ;New
    UseDialingRules=<1/0>           ;New
    Comment=<arbitrary-textn>       ;New

    LastSelectedPhone=<index>       ;New
    PromoteAlternates=<1/0>         ;same
    TryNextPhoneNumberOnFail=<1/0>  ;New

    The phonebook also supports the concept of "custom" entries, i.e. entries
    that fit the MEDIA followed by DEVICE subsection rules but which do not
    include certain expected key fields.  A custom entry is not editable with
    the UI, but may be chosen for connection.  This gives us a story for new
    drivers added by 3rd parties or after release and not yet fully supported
    in the UI. (NOTE: Support for this may be dropped in RAS API)




------------------------------------------------
Notes on conversion from NT3.51 PBENGINE for NT4
------------------------------------------------

This library is a reworking of the PBENGINE.LIB shared by the NT 3.51
RASPHONE.EXE and RASAPI32.DLL.  It's purpose is to encapsulate phonebook file
manipulation, presenting an easy to handle linked-list-of-phonebook-entry
structures to the caller along with appropriate helper routines.


Conversions:

    * Becomes strictly Win32 for increased portability.
        * Replace CRT calls with Win32 where possible.
            Exceptions: qsort, ltoa
        * Eliminate CRT string function usage on all non-numeric strings.
        * Eliminate BLT usage.

    * Becomes multi-thread-safe.  RASDLG can be called from multiple threads
      in a process so the use of global state information, like 'Pbdata' is
      eliminated in favor of returned context blocks.  Further, index
      references into global device lists previously read once at
      initialization are removed, i.e. everything becomes "look up by name"
      when needed.  This will be needed for plug-n-play later anyway.
      (Callers must make similar adjustment)

    * Upper level now uses TCHARs rather than CHARs, where UNICODE is built
      for NT.  The actual file is still written out in MB ANSI using
      RASFIL32.DLL and RASMAN is still ANSI.  This change confines
      UNICODE->ANSI translations to this one thin layer (specifically the
      StrDupAFromT/TFromA routines) simplifying a possible UI port back to
      W95.  The .PBK file itself could be UNICODE and be editable with
      notepad.exe, but that would be a change to the shared RASFIL32.DLL and
      is currently judged "not worth it".

    * Uses new RTUTIL.DLL tracing instead of old "sdebug" style.

    * Built in upgrade of NT 3.51 phonebooks.

    * Explicit "Any <device>" concept is dropped.  It's all implicit now based
      on the type of the selected "preferred" device.  This change requested
      by Gibbs who claims "any port" is extremely expensive in DDM.  (This is
      questionable and will want to watch the reaction carefully.  For
      example, this is a problem for stress scripts?)

    * VALUE_* changed to prefixes and INDEX_No* changed to *_None to associate
      these values more clearly with a set of values.

    * Modem connect response deleted as this is not available from TAPI.

    * PBENTRY: Now contains a list of PBLINK rather than built-in "single
      link".  See below for old field mappings.

    * PBPORT: Modem specific fields only used for MXS support as this are part
      of the new TAPI device blob for Unimodem.

    * PBLINK contains all multi-linkable information, including the new TAPI
      device blob.

    * PBGLOBALS: Global settings are no longer associated with each phonebook
      file but are stored in the CURRENT_USER registry.  They should now be
      read and written separately from the phonebook using the new
      Get/SetUserPreferences calls which phonebook-related enough to be
      provided in pbk.lib.  For the most part, PBGLOBALS->PBUSER.

      Prefix/suffix settings within the phonebook are dropped.  These may be
      implemented in the HKCU preferences.  Note the TAPI location settings
      now optionally handle this functionality.

    * USERDATA, Get/SetRasUserData calls, and CloseFailedLinkPort call are no
      longer in the phonebook library.  These were in pbengine.lib only so
      RASPHONE could figure out which connected entries were actually dialed
      by RASAPI32 to CloseFailedLinkPorts and figure out which ports were
      disconnected due to "link failure" for redial.  These issues must be
      handled by RASMAN/RASAUTO in new model.  If RASAPI engine is moved into
      RASMAN, the USERDATA info can simply be fields in RASCONNCB.

    * The BPS lists are dropped, since they are now provided in the TAPI
      device blob.  For MXS, BPS list is moved into the UI which will display
      an unknown value at the end of it's standard list if encountered.


Port/Device

    TAPI tries to be a device-centric model, while RASMAN is a port-centric
    model.

    RASMAN will return the TAPI device ID for each RASMAN port.  A device ID
    of 0xFFFFFFFF indicates an MXS modem port.  In this case, the port name is
    guaranteed to be unique, but the device name is not (old behavior).  When
    the device ID is not 0xFFFFFFFF, the device name is guaranteed to be
    unique, but the port name is not (because it may not be available).

    How port and device in a phonebook entry are updated/converted:

        If the entry has a "Port" key, it is an old format entry or a new
        format MXS entry.  With these entries, an unconfigured port is
        converted to the first configured port of the same type.  If there is
        no port of the same type the entry is made an "unknown" device with
        the original port name.  Note that "any port" is caught and converted
        by the above rule.

        If the entry has a "PreferredDevice" key it is a new format non-MXS
        entry with no "Port" field.  With these entries, an unconfigured
        device is not converted.  This is in anticipation of Plug-n-Play where
        such conversion is not desirable.

        The UI must disallow "Configure" on unknown or unconfigured devices.

        Note that RasDial will search for the selected "port" or "device"
        first, but if not found will go on and try other ports of the selected
        ports type.  Unimodem and MXS are both tried for "modem" type.  The
        API will apply the blob or the MXS modem settings only to the
        preferred device, not to alternates.

        Old phonebook test cases:

            * Specifies configured MXS port

                - Shows "device (port)" and works as before except tries other
                  modems on open failure

            * Specifies "any modem" port

                - Shows "1st-modem-device (first-modem-port)" and works as
                  before.

                - If no modem ports, shows "unavailable device (Any modem)"
                  and dial attempt fails with "PORT_NOT_FOUND", which is
                  essentially also working as before.

            * Specifies existing unimodem port

                - Shows "device (port)" or "device" and dials the port first
                  trying other unimodem ports on open failure.


Organization:

    The files are organized similar to pbengine.lib where...

        <ras>\ui\common\inc\pbengine.h-><ras>\ui\inc\pbk.h

        Upper level routines and general utilities:
            pbengine.c->pbk.c
            pbengin2.c->pbk.c

        RasMan packaging routines:
            pbrasman.c->rasman.c =
            pbrasma2.c->rasman.c

        Convert list<->file routines and utilities:
            pbfile.c->file.c
            pbfile2.c->file.c

        pbkp.h is added for private library definitions.

    The "2" files were the basic routines needed by only RASAPI32.  With the
    inclusion of the phonebook editing APIs this distinction is much less
    significant and has been dropped.


Entry format change details:

    [ENTRY]                         ;Max raised to 256
    Description=<description>       ;Same
    AutoLogon=<1/0>                 ;same
    User=<username>                 ;Deleted, now LSA secret
    Domain=<domain>                 ;Deleted, now LSA secret
    DialParamsUID=<unique-ID>       ;Post NT 3.51
    UsePwForNetwork=<1/0>           ;New
    ServerType=<ST-code>            ;New, not used by RASAPI
    BaseProtocol=<BP-code>          ;same*
    Authentication=<AS-code>        ;same*
    ExcludedProtocols=<NP-bits>     ;same*
    LcpExtensions=<1/0>             ;same
    DataEncryption=<1/0>            ;same
    SkipNwcWarning=<1/0>            ;same
    SwCompression=<1/0>             ;New
    UseCountryAndAreaCodes=<1/0>    ;Post NT 3.51
    AreaCode=<string>               ;Post NT 3.51
    CountryID=<id>                  ;Post NT 3.51
    CountryCode=<code>              ;Post NT 3.51
    AuthRestrictions=<AR-code>      ;New, used by SLIP also
    SkipDownLevelDialog=<1/0>       ;same
    DialMode=<DM-code>              ;Post NT 3.51
    DialPercent=<0-100>             ;Post NT 3.51
    DialSeconds=<1-n>               ;Post NT 3.51
    HangUpPercent=<0-100>           ;Post NT 3.51
    HangUpSeconds=<1-n>             ;Post NT 3.51
    IdleDisconnectSeconds=<-1,0-n>  ;Post NT 3.51
    SecureLocalFiles=<1/0>          ;Post NT 3.51
    CustomDialDll=<path>            ;Post NT 3.51
    CustomDialFunc=<func-name>      ;Post NT 3.51
    PppTextAuthentication=<AR-code> ;Deleted, becomes AuthRestrictions above.

    The following single set of IP parameters appear in place of the
    equivalent separate sets of PppXxx or SlipXxx parameters in the previous
    phonebook.

    IpPrioritizeRemote=<1/0>        ;Was PPP specific
    IpHeaderCompression=<1/0>       ;Was PPP specific
    IpAddress=<a.b.c.d>             ;Was PPP specific
    IpAssign=<ASRC-code>            ;Was PPP specific
    IpDnsAddress=<a.b.c.d>          ;Was PPP specific
    IpDns2Address=<a.b.c.d>         ;Was PPP specific
    IpWinsAddress=<a.b.c.d>         ;Was PPP specific
    IpWins2Address=<a.b.c.d>        ;Was PPP specific
    IpNameAssign=<ASRC-code>        ;Was PPP specific
    IpFrameSize=<1006/1500>         ;Still SLIP specific

    In general each section contains subsections delimited by
    MEDIA=<something> and DEVICE=<something> lines.  In pbengine.lib, there
    MUST be exactly one MEDIA subsection and it must be the first subsection
    of the section.  There can be any number of DEVICE subsections.  In
    pbk.lib, there can be multiple MEDIA/DEVICE sets where the position of the
    set determines it's sub-entry index, the first being 1, the second 2, etc.

    For serial media, the program currently expects 1 to 4 DEVICE subsections,
    representing a preconnect switch, modem, X.25 PAD, and postconnect switch.
    Following is a full entry:

    MEDIA=serial                    ;same
    Port=<port-name>                ;No longer set to "Any modem"
    Device=<device-name>            ;New, not passed to RASMAN
    ConnectBps=<bps>                ;For old MXS support only

    DEVICE=switch                   ;same
    Type=<switchname or Terminal>   ;same

    DEVICE=modem                    ;same
    PhoneNumber=<phonenumber1>      ;same
    PhoneNumber=<phonenumber2>      ;same
    PhoneNumber=<phonenumberN>      ;same
    PromoteAlternates=<1/0>         ;New, not passed to RASMAN
    TapiBlob=<hexdump>              ;New
    ManualDial=<1/0>                ;For old MXS support only
    HwFlowControl=<1/0>             ;For old MXS support only
    Protocol=<1/0>                  ;For old MXS support only
    Compression=<1/0>               ;For old MXS support only

    DEVICE=pad                      ;same
    X25Pad=<padtype>                ;same
    X25Address=<X121address>        ;same
    UserData=<userdata>             ;same
    Facilities=<facilities>         ;same

    DEVICE=switch                   ;same
    Type=<switchname or Terminal>   ;Switchname can be path

    For ISDN media, the program expects exactly 1 DEVICE subsection.  Note
    that ISDN is now identical to the "other" case.

    MEDIA=isdn                      ;same
    Port=<port-name>                ;No longer set to "Any ISDN"
    Device=<device-name>            ;New, not passed to RASMAN

    DEVICE=isdn                     ;same
    PhoneNumber=<phonenumber1>      ;same
    PhoneNumber=<phonenumber2>      ;same
    PhoneNumber=<phonenumberN>      ;same
    PromoteAlternates=<1/0>         ;New, not passed to RASMAN
    LineType=<0/1/2>                ;same
    Fallback=<1/0>                  ;same
    EnableCompression=<1/0>         ;For old protocol only
    ChannelAggregation=<channels>   ;For old protocol only

    For X.25 media, the program expects exactly 1 DEVICE subsection.

    MEDIA=x25                       ;same
    Port=<port-name>                ;No longer set to "Any X25"
    Device=<device-name>            ;New, not passed to RASMAN

    DEVICE=x25                      ;same
    X25Address=<X121address>        ;same
    UserData=<userdata>             ;same
    Facilities=<facilities>         ;same

    For other media, the program expects exactly one DEVICE subsection with
    device name matching the media.  "Other" media and devices are created for
    entries assigned to all non-serial medias including ISDN which now matches
    the rules for "other".

    MEDIA=<media>                   ;same
    Port=<port-name>                ;same
    Device=<device-name>            ;New, not passed to RASMAN

    DEVICE=<media>                  ;same
    PhoneNumber=<phonenumber1>      ;same
    PhoneNumber=<phonenumber2>      ;same
    PhoneNumber=<phonenumberN>      ;same
    PromoteAlternates=<1/0>         ;New, not passed to RASMAN

    The phonebook also supports the concept of "custom" entries, i.e. entries
    that fit the MEDIA followed by DEVICE subsection rules but which do not
    include certain expected key fields.  A custom entry is not editable with
    the UI, but may be chosen for connection.  This gives us a story for new
    drivers added by 3rd parties or after release and not yet fully supported
    in the UI. (NOTE: This may be dropped in RAS API)

    (*) Parameter changes internally to use new set-descriptive constants
        rather than VALUE_*.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\common\pbk\notes.txt ===
Notes on conversion from PBENGINE
---------------------------------

This library is a reworking of the PBENGINE.LIB shared by the NT 3.51
RASPHONE.EXE and RASAPI32.DLL.  It's purpose is to encapsulate phonebook file
manipulation, presenting an easy to handle linked-list-of-phonebook-entry
structures to the caller along with appropriate helper routines.


Conversions:

    * Becomes strictly Win32 for increased portability.
        * Replace CRT calls with Win32 where possible.
            Exceptions: qsort, ltoa
        * Eliminate CRT string function usage on all non-numeric strings.
        * Eliminate BLT usage.

    * Becomes multi-thread-safe.  RASDLG can be called from multiple threads
      in a process so the use of global state information, like 'Pbdata' is
      eliminated in favor of returned context blocks.  Further, index
      references into global device lists previously read once at
      initialization are removed, i.e. everything becomes "look up by name"
      when needed.  This will be needed for plug-n-play later anyway.
      (Callers must make similar adjustment)

    * Upper level now uses TCHARs rather than CHARs, where UNICODE is built
      for NT.  The actual file is still written out in MB ANSI using
      RASFIL32.DLL and RASMAN is still ANSI.  This change confines
      UNICODE->ANSI translations to this one thin layer (specifically the
      StrDupAFromT/TFromA routines) simplifying a possible UI port back to
      W95.  The .PBK file itself could be UNICODE and be editable with
      notepad.exe, but that would be a change to the shared RASFIL32.DLL and
      is currently judged "not worth it".

    * Uses new RTUTIL.DLL tracing instead of old "sdebug" style.

    * Built in upgrade of NT 3.51 phonebooks.

    * Explicit "Any <device>" concept is dropped.  It's all implicit now based
      on the type of the selected "preferred" device.  This change requested
      by Gibbs who claims "any port" is extremely expensive in DDM.  (This is
      questionable and will want to watch the reaction carefully.  For
      example, this is a problem for stress scripts?)

    * VALUE_* changed to prefixes and INDEX_No* changed to *_None to associate
      these values more clearly with a set of values.

    * Modem connect response deleted as this is not available from TAPI.

    * PBENTRY: Now contains a list of PBLINK rather than built-in "single
      link".  See below for old field mappings.

    * PBPORT: Modem specific fields only used for MXS support as this are part
      of the new TAPI device blob for Unimodem.

    * PBLINK contains all multi-linkable information, including the new TAPI
      device blob.

    * PBGLOBALS: Global settings are no longer associated with each phonebook
      file but are stored in the CURRENT_USER registry.  They should now be
      read and written separately from the phonebook using the new
      Get/SetUserPreferences calls which phonebook-related enough to be
      provided in pbk.lib.  For the most part, PBGLOBALS->PBUSER.

      Prefix/suffix settings within the phonebook are dropped.  These may be
      implemented in the HKCU preferences.  Note the TAPI location settings
      now optionally handle this functionality.

    * USERDATA, Get/SetRasUserData calls, and CloseFailedLinkPort call are no
      longer in the phonebook library.  These were in pbengine.lib only so
      RASPHONE could figure out which connected entries were actually dialed
      by RASAPI32 to CloseFailedLinkPorts and figure out which ports were
      disconnected due to "link failure" for redial.  These issues must be
      handled by RASMAN/RASAUTO in new model.  If RASAPI engine is moved into
      RASMAN, the USERDATA info can simply be fields in RASCONNCB.

    * The BPS lists are dropped, since they are now provided in the TAPI
      device blob.  For MXS, BPS list is moved into the UI which will display
      an unknown value at the end of it's standard list if encountered.


Port/Device

    TAPI tries to be a device-centric model, while RASMAN is a port-centric
    model.

    RASMAN will return the TAPI device ID for each RASMAN port.  A device ID
    of 0xFFFFFFFF indicates an MXS modem port.  In this case, the port name is
    guaranteed to be unique, but the device name is not (old behavior).  When
    the device ID is not 0xFFFFFFFF, the device name is guaranteed to be
    unique, but the port name is not (because it may not be available).

    How port and device in a phonebook entry are updated/converted:

        If the entry has a "Port" key, it is an old format entry or a new
        format MXS entry.  With these entries, an unconfigured port is
        converted to the first configured port of the same type.  If there is
        no port of the same type the entry is made an "unknown" device with
        the original port name.  Note that "any port" is caught and converted
        by the above rule.

        If the entry has a "PreferredDevice" key it is a new format non-MXS
        entry with no "Port" field.  With these entries, an unconfigured
        device is not converted.  This is in anticipation of Plug-n-Play where
        such conversion is not desirable.

        The UI must disallow "Configure" on unknown or unconfigured devices.

        Note that RasDial will search for the selected "port" or "device"
        first, but if not found will go on and try other ports of the selected
        ports type.  Unimodem and MXS are both tried for "modem" type.  The
        API will apply the blob or the MXS modem settings only to the
        preferred device, not to alternates.

        Old phonebook test cases:

            * Specifies configured MXS port

                - Shows "device (port)" and works as before except tries other
                  modems on open failure

            * Specifies "any modem" port

                - Shows "1st-modem-device (first-modem-port)" and works as
                  before.

                - If no modem ports, shows "unavailable device (Any modem)"
                  and dial attempt fails with "PORT_NOT_FOUND", which is
                  essentially also working as before.

            * Specifies existing unimodem port

                - Shows "device (port)" or "device" and dials the port first
                  trying other unimodem ports on open failure.


Organization:

    The files are organized similar to pbengine.lib where...

        <ras>\ui\common\inc\pbengine.h-><ras>\ui\inc\pbk.h

        Upper level routines and general utilities:
            pbengine.c->pbk.c
            pbengin2.c->pbk.c

        RasMan packaging routines:
            pbrasman.c->rasman.c =
            pbrasma2.c->rasman.c

        Convert list<->file routines and utilities:
            pbfile.c->file.c
            pbfile2.c->file.c

        pbkp.h is added for private library definitions.

    The "2" files were the basic routines needed by only RASAPI32.  With the
    inclusion of the phonebook editing APIs this distinction is much less
    significant and has been dropped.


Entry format change details:

    [ENTRY]                         ;Max raised to 256
    Description=<description>       ;Same
    AutoLogon=<1/0>                 ;same
    User=<username>                 ;Deleted, now LSA secret
    Domain=<domain>                 ;Deleted, now LSA secret
    DialParamsUID=<unique-ID>       ;Post NT 3.51
    UsePwForNetwork=<1/0>           ;New
    ServerType=<ST-code>            ;New, not used by RASAPI
    BaseProtocol=<BP-code>          ;same*
    Authentication=<AS-code>        ;same*
    ExcludedProtocols=<NP-bits>     ;same*
    LcpExtensions=<1/0>             ;same
    DataEncryption=<1/0>            ;same
    SkipNwcWarning=<1/0>            ;same
    SwCompression=<1/0>             ;New
    UseCountryAndAreaCodes=<1/0>    ;Post NT 3.51
    AreaCode=<string>               ;Post NT 3.51
    CountryID=<id>                  ;Post NT 3.51
    CountryCode=<code>              ;Post NT 3.51
    AuthRestrictions=<AR-code>      ;New, used by SLIP also
    SkipDownLevelDialog=<1/0>       ;same
    DialMode=<DM-code>              ;Post NT 3.51
    DialPercent=<0-100>             ;Post NT 3.51
    DialSeconds=<1-n>               ;Post NT 3.51
    HangUpPercent=<0-100>           ;Post NT 3.51
    HangUpSeconds=<1-n>             ;Post NT 3.51
    IdleDisconnectSeconds=<-1,0-n>  ;Post NT 3.51
    SecureLocalFiles=<1/0>          ;Post NT 3.51
    CustomDialDll=<path>            ;Post NT 3.51
    CustomDialFunc=<func-name>      ;Post NT 3.51
    PppTextAuthentication=<AR-code> ;Deleted, becomes AuthRestrictions above.

    The following single set of IP parameters appear in place of the
    equivalent separate sets of PppXxx or SlipXxx parameters in the previous
    phonebook.

    IpPrioritizeRemote=<1/0>        ;Was PPP specific
    IpHeaderCompression=<1/0>       ;Was PPP specific
    IpAddress=<a.b.c.d>             ;Was PPP specific
    IpAssign=<ASRC-code>            ;Was PPP specific
    IpDnsAddress=<a.b.c.d>          ;Was PPP specific
    IpDns2Address=<a.b.c.d>         ;Was PPP specific
    IpWinsAddress=<a.b.c.d>         ;Was PPP specific
    IpWins2Address=<a.b.c.d>        ;Was PPP specific
    IpNameAssign=<ASRC-code>        ;Was PPP specific
    IpFrameSize=<1006/1500>         ;Still SLIP specific

    In general each section contains subsections delimited by
    MEDIA=<something> and DEVICE=<something> lines.  In pbengine.lib, there
    MUST be exactly one MEDIA subsection and it must be the first subsection
    of the section.  There can be any number of DEVICE subsections.  In
    pbk.lib, there can be multiple MEDIA/DEVICE sets where the position of the
    set determines it's sub-entry index, the first being 1, the second 2, etc.

    For serial media, the program currently expects 1 to 4 DEVICE subsections,
    representing a preconnect switch, modem, X.25 PAD, and postconnect switch.
    Following is a full entry:

    MEDIA=serial                    ;same
    Port=<port-name>                ;No longer set to "Any modem"
    Device=<device-name>            ;New, not passed to RASMAN
    ConnectBps=<bps>                ;For old MXS support only

    DEVICE=switch                   ;same
    Type=<switchname or Terminal>   ;same

    DEVICE=modem                    ;same
    PhoneNumber=<phonenumber1>      ;same
    PhoneNumber=<phonenumber2>      ;same
    PhoneNumber=<phonenumberN>      ;same
    PromoteAlternates=<1/0>         ;New, not passed to RASMAN
    TapiBlob=<hexdump>              ;New
    ManualDial=<1/0>                ;For old MXS support only
    HwFlowControl=<1/0>             ;For old MXS support only
    Protocol=<1/0>                  ;For old MXS support only
    Compression=<1/0>               ;For old MXS support only

    DEVICE=pad                      ;same
    X25Pad=<padtype>                ;same
    X25Address=<X121address>        ;same
    UserData=<userdata>             ;same
    Facilities=<facilities>         ;same

    DEVICE=switch                   ;same
    Type=<switchname or Terminal>   ;Switchname can be path

    For ISDN media, the program expects exactly 1 DEVICE subsection.  Note
    that ISDN is now identical to the "other" case.

    MEDIA=isdn                      ;same
    Port=<port-name>                ;No longer set to "Any ISDN"
    Device=<device-name>            ;New, not passed to RASMAN

    DEVICE=isdn                     ;same
    PhoneNumber=<phonenumber1>      ;same
    PhoneNumber=<phonenumber2>      ;same
    PhoneNumber=<phonenumberN>      ;same
    PromoteAlternates=<1/0>         ;New, not passed to RASMAN
    LineType=<0/1/2>                ;same
    Fallback=<1/0>                  ;same
    EnableCompression=<1/0>         ;For old protocol only
    ChannelAggregation=<channels>   ;For old protocol only

    For X.25 media, the program expects exactly 1 DEVICE subsection.

    MEDIA=x25                       ;same
    Port=<port-name>                ;No longer set to "Any X25"
    Device=<device-name>            ;New, not passed to RASMAN

    DEVICE=x25                      ;same
    X25Address=<X121address>        ;same
    UserData=<userdata>             ;same
    Facilities=<facilities>         ;same

    For other media, the program expects exactly one DEVICE subsection with
    device name matching the media.  "Other" media and devices are created for
    entries assigned to all non-serial medias including ISDN which now matches
    the rules for "other".

    MEDIA=<media>                   ;same
    Port=<port-name>                ;same
    Device=<device-name>            ;New, not passed to RASMAN

    DEVICE=<media>                  ;same
    PhoneNumber=<phonenumber1>      ;same
    PhoneNumber=<phonenumber2>      ;same
    PhoneNumber=<phonenumberN>      ;same
    PromoteAlternates=<1/0>         ;New, not passed to RASMAN

    The phonebook also supports the concept of "custom" entries, i.e. entries
    that fit the MEDIA followed by DEVICE subsection rules but which do not
    include certain expected key fields.  A custom entry is not editable with
    the UI, but may be chosen for connection.  This gives us a story for new
    drivers added by 3rd parties or after release and not yet fully supported
    in the UI. (NOTE: This may be dropped in RAS API)

    (*) Parameter changes internally to use new set-descriptive constants
        rather than VALUE_*.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\perf\rasctrs.ini ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rasctrs.ini 

Abstract:

    This file contains the English language counters and help text for
    Remote Access 

Created:

    Russ Blake			24 Feb 93
    Thomas J. Dimitri	        28 May 93

Revision History

    Patrick Y. Ng               12 Aug 93
    Ram Cherala                 04 Nov 93   Added this header


--*/
[info]
drivername=RemoteAccess
symbolfile=rasctrnm.h

[languages]
009=English

[text]
RASPORTOBJ_009_NAME=RAS Port
RASPORTOBJ_009_HELP=The RAS Object Type handles individual ports of the RAS device on your system.

BYTESTX_009_NAME=Bytes Transmitted
BYTESTX_009_HELP=The number of bytes transmitted total for this connection.
BYTESRX_009_NAME=Bytes Received
BYTESRX_009_HELP=The number of bytes received total for this connection.

FRAMESTX_009_NAME=Frames Transmitted
FRAMESTX_009_HELP=The number of data frames transmitted total for this connection.
FRAMESRX_009_NAME=Frames Received
FRAMESRX_009_HELP=The number of data frames received total for this connection.

PERCENTTXC_009_NAME=Percent Compression Out
PERCENTTXC_009_HELP=The compression ratio for bytes being transmitted.
PERCENTRXC_009_NAME=Percent Compression In
PERCENTRXC_009_HELP=The compression ratio for bytes being received.

CRCERRORS_009_NAME=CRC Errors
CRCERRORS_009_HELP=The total number of CRC Errors for this connection.  CRC Errors occur when the frame received contains erroneous data.
TIMEOUTERRORS_009_NAME=Timeout Errors
TIMEOUTERRORS_009_HELP=The total number of Timeout Errors for this connection.  Timeout Errors occur when an expected is not received in time.
SERIALOVERRUNS_009_NAME=Serial Overrun Errors
SERIALOVERRUNS_009_HELP=The total number of Serial Overrun Errors for this connection.  Serial Overrun Errors occur when the hardware cannot handle the rate at which data is received.
ALIGNMENTERRORS_009_NAME=Alignment Errors
ALIGNMENTERRORS_009_HELP=The total number of Alignment Errors for this connection.  Alignment Errors occur when a byte received is different from the byte expected.
BUFFEROVERRUNS_009_NAME=Buffer Overrun Errors
BUFFEROVERRUNS_009_HELP=The total number of Buffer Overrun Errors for this connection.  Buffer Overrun Errors when the software cannot handle the rate at which data is received.

TOTALERRORS_009_NAME=Total Errors
TOTALERRORS_009_HELP=The total number of CRC, Timeout, Serial Overrun, Alignment, and Buffer Overrun Errors for this connection.

BYTESTXSEC_009_NAME=Bytes Transmitted/Sec
BYTESTXSEC_009_HELP=The number of bytes transmitted per second.
BYTESRXSEC_009_NAME=Bytes Received/Sec
BYTESRXSEC_009_HELP=The number of bytes received per second.

FRAMESTXSEC_009_NAME=Frames Transmitted/Sec
FRAMESTXSEC_009_HELP=The number of frames transmitted per second.
FRAMESRXSEC_009_NAME=Frames Received/Sec
FRAMESRXSEC_009_HELP=The number of frames received per second.

TOTALERRORSSEC_009_NAME=Total Errors/Sec
TOTALERRORSSEC_009_HELP=The total number of CRC, Timeout, Serial Overrun, Alignment, and Buffer Overrun Errors per second.



RASTOTALOBJ_009_NAME=RAS Total
RASTOTALOBJ_009_HELP=The RAS Object Type handles all combined ports of the RAS device on your system.

TOTALCONNECTIONS_009_NAME=Total Connections
TOTALCONNECTIONS_009_HELP=The total number of Remote Access connections.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\arch.txt ===
// ===============================================
// ===============================================
	This file explains the design and architecture
	of the Connections Ras Server UI project.
// ===============================================
// ===============================================


Databases
=========
	Each property sheet tab accesses databases to do the work behind the 
	scenes.  The following databases are included:
		Device Database:	Getting/setting of ras device properties (devicedb.h)
		User Database:		Getting/setting of local user parameters (userdb.h)
		Protocol Database:	Getting/setting of protocol parameters. (protdb.h)
		Miscellaneous DB:	Getting/setting of other misc. properties (miscdb.h)

	The function RasSrvGetDatabaseHandle allows access to the given databases.


UI
==
	The following files define the ui for the property sheets:
		gentab.c			The general tab
		usertab.c			The user tab, callback dialog, new user dialog
		advantab.c			The advanced tab
		tcpipui.c			The tcpip properties dialog
		ipxui.c				The ipxui properties dialog
		multilink.c			The multilink tab properties dialog


Error reporting and handling policies
=====================================
	Only functions that display ui (in the files listed in the UI section) can
	display error dialog boxes and are responsible for doing so correctly.

	All other functions can print trace statements.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\dialup.rtf ===
{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deftab360{\fonttbl {\f0\fswiss\fcharset0 Arial;}} {\colortbl ;\red0\green0\blue0;\red0\green0\blue255;} \uc1\pard\fi-1800\li1800\tx1800\cf1\b\f0\fs20 Paul Mayfield\par From:\b0\tab Paul Mayfield\par \b Sent:\b0\tab Friday, October 17, 1997 10:50 PM\par \b To:\b0\tab Daniel Dedu-Constantin; Rose Bigham\par \b Cc:\b0\tab Javed Rasool; Narendra Gidwani; Shaun Cox; Paul Mayfield\par \b Subject:\b0\tab Connections Ras Server UI update\par \pard\li360\cf0\protect Location:\par \tab\\\\scratch\\scratch\\pmay\\dialup\par \ul\par Current Status:\par \b\ul0 1. Device Management (General Tab)\par \b0\tab a. Display Devices (modems, DCC ports, VPN)\tab\tab\tab Ok. \par \tab b. Set Device Properities\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab\tab i.  Enable/Disable ports for dialin\tab\tab\tab\tab\tab\tab Not implemented\par \tab\tab ii.  Enable multilink on all devices\tab\tab\tab\tab\tab Ok\par \tab\tab iv. Enable showing icons in task bar \tab\tab\tab\tab\tab Ok\par \tab\tab v.  "Properties Button"\tab\tab\tab\tab\tab\tab\tab\tab Not implemented\b\par \b0\tab c. Enable vpn to for dialup\tab\tab\tab\tab\tab\tab\tab\tab Setting will be saved but has no effect on system\b\par \b0\par \b 2. User Management (User Tab)\b0\par \tab a. Display Local Users\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab b. Grant/Revoke Local User Dialin Priveleges\tab\tab\tab\tab Ok\par \tab c. Add New Local Users\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\tab\par \tab d. Callback properties\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab d. Launch MMC \tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \b 3. Protocol Management (Advanced Tab)\par \b0\tab a. Enable/Disable protocol for dialin\tab\tab\tab\tab\tab\tab Ok\par \tab b. Tcpip properties\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab\tab i. Use dhcp\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab\tab ii. Use pool\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab\tab iii. Allow static \tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab c. Ipx properties\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab\tab i. Auto assign net nums\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \b\tab\tab\b0 ii. Assign pool\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \b\tab\tab\b0 iii. Assign same addr to all clients\tab\tab\tab\tab\tab Ok\par \tab d. Enabling the exposing of the server's network\tab\tab\tab Ok\par \tab e. Display Protocol description\tab\tab\tab\tab\tab\tab\tab Ok\par \tab f.  Add protocol\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Not implemented (INetConfig)\par \tab g. Remove protocol\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Not implemented (INetConfig)\par \tab h. Show protocol description\tab\tab\tab\tab\tab\tab\tab\tab Ok.  Wrong description displayed.\par \tab\b\par 4. Connections Folder \par \tab\b0 a. Enumerate Connections \tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab b. Hangup Connections \tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \b 5. Status\par \tab\b0 a. Show connection stats\tab\tab\tab\tab\tab\tab\tab\tab Ok \par \tab b. Disconnect connection\tab\tab\tab\tab\tab\tab\tab\tab Ok \par \b\tab\b0 c. \i Multilink Tab\i0\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \b\tab\tab\b0 i. Display ports in the connection\tab\tab\tab\tab\tab\tab Ok\par \b\tab\tab\b0 ii. Allow hangup of individual ports\tab\tab\tab\tab\tab Ok\par \b\tab\tab\b0 iii. Allow status of individual ports\tab\tab\tab\tab\tab\tab Ok\par \b\par 6. Wizard Pages\par \b0\tab a. Icoming Devices Tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab b. Incoming Virtual Private... Tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab c. Allowed Users Tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab d. Allowed Protocols Tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab e. Finish Tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok \par \b\protect0 7. Remote Acesss Service\par \tab\b0 a. Install if not installed\tab\tab\tab\tab\tab\tab\tab\tab\tab Not implemented\par \tab b. Start\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Not implemented\par \tab c. Mark Autostart\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Not implemented\par \tab d. Stop\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Not implemented\par \tab e. Mark Disabled\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Not implemented\b\par \b0\protect\par \b 8. Error handling\par \tab\b0 a. Remote Access \tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Not implemented\par \tab\tab i. Dependency problems\tab\tab\tab\tab\tab\tab\tab\tab Not implemented\par \tab\tab ii. Running in Domain and DC wont allow\tab\tab\tab\tab Not implemented\par \tab\tab iii. Service specific errors\tab\tab\tab\tab\tab\tab\tab Not implemented\par \tab\tab iv. Start remoteacess if not started when ui launched\tab Not implemented\par \tab b. General problems\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab\tab i. Insufficient privilege to modify vpn usage\tab\tab\tab Ok\par \tab\tab ii. Device wont allow usage modification\tab\tab\tab\tab Ok\par \tab c. User problems\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab\tab i. Insufficient privilege to add/modify users\tab\tab\tab Ok\par \tab d. Protocol\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab\tab Ok\par \tab\tab i. Insufficient privilege to modify protocols\tab\tab\tab\tab Ok\par \b 9. Help\par \tab\b0 a.  Add support for online help as supplied by UA\tab\tab\tab Not implemented\b\par \b0\par \b 10. Finishing Touches\par \tab\b0 a.  Make sure that error dialogs display string resources\tab Ok\par \tab b.  Design smart error messages\tab\tab\tab\tab\tab\tab\tab Ok\b\par \tab\b0 c\b .  \b0 Finishing UI Tweaks as per stevefal\b\tab\tab\tab\tab\tab\b0 Not implemented\b\par \b0\par \tab\tab\b\par Notes:\b0\par 1. Pressing cancel will remove all users added from the user tab and rollback all callback settings \par    (this is the desired behavior).\par 2. Pressing cancel will not rollback any changes made by pressing the "Properties" button from the general tab.\par     (this is by design).\par \cf2 3. Pressing cancel on the property sheet will no rollback changes made to the protocol properties by design.\cf0\par 4. [5.a] and [5.b] do not show up in test.exe as these will be implemented/tested by cwill.\par \protect0\pard\protect\fi-1800\li1800\tx1800\cf1\protect0\par
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\icons.txt ===
;
; This file contains the default contents of the \Registry database
; All keys are specified relative to the \Registry root key.
;

\Registry\Machine

    System
      CurrentControlSet

        Services
            AfpServer
		Parameters
		    ICONS
			LMANDEXE = REG_MULTI_SZ "CREATOR=LMAN" "TYPE=DEXE" "ICONTYPE=1" "LENGTH=256" "DATA=00000000007FFF000040018000400140004E31200049491000494108004E41FC0048487C0048300400400004004FFFE4004000043FFFFFC42000080420000FE42000080420000FC4200008043FFFFFE43FFFF8043FFFFFC43FFFF8043FE7FFE43FE7F8043FFFFFC43FFFF8043FFFF8043FFFFFFC3FFFF8003FFFF8003FFFF80000000000007FFF00007FFF80007FFFC0007FFFE0007FFFF0007FFFF8007FFFFC007FFFFC007FFFFC007FFFFC007FFFFC007FFFFC007FFFFC3FFFFFFC3FFFFFFC3FFFFFFC3FFFFFFC3FFFFFFC3FFFFFFC3FFFFFFC3FFFFFFC3FFFFFFC3FFFFFFC3FFFFFFC3FFFFFFC3FFFFFFC3FFFFFFC3FFFFFFC3FFFF8003FFFF8003FFFF800"
			LMANTEXT = REG_MULTI_SZ "CREATOR=LMAN" "TYPE=TEXT" "ICONTYPE=1" "LENGTH=256" "DATA=0FFFFE000800050009E30480091484400914042009E40410090487F0090301F0080000100800001009EF7E1008000010081DBA1008000010081B761008000010081EDE100800001009DEF61008000010097DDE1008000010081B6E100800001009BBB61008000010081F76100800001009DB361008000010080000100FFFFFF00FFFFE000FFFFF000FFFFF800FFFFFC00FFFFFE00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF0"
			SRVRSRVR = REG_MULTI_SZ "CREATOR=SRVR" "TYPE=SRVR" "ICONTYPE=0" "LENGTH=256" "DATA=00000000450000146C0000245536D9FE454552A445454AA445359B2400000000FFF1FFFF000A0000FFE4FFFF00110000003F800000208000003F8000000A0000000A0000000A00001FFFFFF02000000820000018200000182000001827FFFF982000001827FFFF98200000182180001821800018200000182FFFFFF81FFFFFF0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF001F0000003F8000003F8000003F8000000E0000000E0000000E00001FFFFFF03FFFFFF83FFFFFF83FFFFFF83FFFFFF83FFFFFF83FFFFFF83FFFFFF83FFFFFF83FFFFFF83FFFFFF83FFFFFF83FFFFFF81FFFFFF0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\cairosfm.doc ===
Microsoft Word 6.0 Document MSWordDoc Word.Document.6E:\WORDNT\TEMPLATE\Normal.dot Sue Adams Sue Adams Microsoft Word 6.0Requirements for Supporting Macintosh (HFS ) Clients on NT The following list is compiled from issues that arose during implementation of  Services For Macintosh (SFM) AppleTalk Filing Protocol (AFP) Server for NT: Multiple Named Attributes (a.k.a. streams, forks) Mac HFS files have 2 forks, data fork and resource fork  Must be available on both files and directories Sharing modes required on individual streams.  SFM server keeps track of open modes for performance reasons (checks for conflicts on fork opens) ByteRange Locks required on individual streams.  SFM server keeps track of locks for performance reasons (checks range conflicts for lock,unlock,read,write) Future version of Mac FS may support multiple forks SFM uses additional streams to store the information about a mac file or directory which does not map to anything on NTFS,  i.e. AFP_Afpinfo stream is currently used to store backup time, 32 bit file/dir ID, distinction of NT READ permission between Mac s Seefiles and SeeFolders permission, FinderInfo, ProDOS info, mapping of NTFS ReadOnly file attribute into multiple mac attributes (RenameInhibit, DeleteInhibit, WriteInhibit). AFP_Desktop stream used to store HFS desktop information, i.e.  APPL mappings, Icons. This stream is created on the directory which represents the root of the Mac volume. AFP_Idindex stream holds information about the Mac volume, i.e. last allocated 32 bit file/dir ID, Volume Create, Modify and Backup times. This stream is created on the directory which represents the root of the Mac volume. Oplocks should break for delete of a file/dir no matter what stream is open If file/dir has its ReadOnly attribute set, SFM server must temporarily remove this attribute to write out the info to its private streams, then must restore the attribute. HFS Information that Does Not Directly Map to NT FS Feature SeeFiles vs. SeeFolders permissions RenameInhibit file/dir attribute WriteInhibit file/dir attribute DeleteInhibit file/dir attribute MultiUser file attribute Copy Protect file attribute  DataFork Already Open file attribute ResourceFork Already Open file attribute FinderInfo (includes file type and creator, Mac Finder flags, etc) ProDOS info Desktop Info - APPL  mappings, Icons Backup time 32 bit unique file/dir ID Directory Enumeration Performance Issues - Potential ChangeNotify Improvements Don't return us our own changes (based on what?? ProcessId?  ThreadID?).  Today we receive notification for changes that we initiated, and have to filter them out from being processed by comparing path names.  Return IDs instead of paths for faster lookup when filtering out our own changes? Define more action flags (more specific) i.e. FILE_ACTION_MODIFIED is extremely vague. what was modified? Make sure all pathnames (links) that can be used to get to a directory will trigger the notify (e.g. NTFS has both a longname and a shortname for a file)  Possible to be notified when a file is open by ID?  Does FS allow methods other than by name to open a file.  Will these all generate a change notification? Allow reposting of notify during completion routine so as not to open a window where notifies could be missed Allow dynamic growth of notify buffer Never return STATUS_NOTIFY_ENUM_DIR which means the caller must reenumerate the entire tree ChangeNotification is posted on an entire directory tree representing the Mac volume Is there a way to handle nested volumes? (SFM does NOT currently support nested volumes) Mac Filenames Mapping Mac ANSI character set to Unicode and back again.  Uses Mac CodePage. SFM today  munges  unicode characters that are illegal in NT file system to the Private Use Area of Unicode  Mac File/Dir names ending in space and period (or other whitespace chars) vs. Win32 namespace.  Currently SFM  munges  these characters at the end of a name to Private Use Area Unicode as well so they may be accessed by FileManager, cmd.exe (Win32 apis) Mac HFS filenames are 31 characters maximum.  If a NT filename is longer than 31 chars, SFM uses the DOS style NTFS shortname for the Mac name. Mac ProDOS clients always see the NTFS shortname. Extension mapping to type-creator becomes what in OFS?? Timestamps Parent directory Modified timestamp should be updated when a file/dir within it is:  created, deleted, renamed, moved, Create or Mod time changes, type/creator changes Changes to disk update the  Volume  modified time AFP APIs Requiring Special Support AfpCatSearch - Catalog search for files by attribute other than its name (NOT currently implemented by SFM) AfpExchangeFiles - used to preserve existing file Ids when an application wishes to perform the  Save As...  functions. (currently implemented brute force by SFM) AfpCopyFile - must copy each stream individually (currently implemented by SFM) CDFS support for HFS and ISO 9660 formats  Resource forks (multiple forks in future Mac FS) Finder info (type,creator,coordinates,FinderAttributes etc.) Desktop info Other Issues, Not Necessarily FileSystem Related: Security Issues Setting and querying a user primary group  (can it be done from Kernel mode?) Impersonating mac clients for I/O Converting cairo user, group, domain IDs into 32 bit mac ID equivalents  (can it be done in kernel mode?) Logging on mac clients--mapping Cairo authentication methods to Apple's methods (i.e. No User Authentication method for logging on 'guests', Cleartext passwords, Microsoft UAM --what does it become? Blank Access Privileges  - when a folder has its blank access privilege bit set, then the other access privilege bits are ignored, and it uses the access privilege bits of its parent. (NOT currently implemented by SFM) Change Password Mac style permissions - SeeFiles, SeeFolders, MakeChanges for Owner, Group, Everyone.  Owner can be a group, group can be an individual user.   Ancestor permissions (currently NOT supported by SFM--performance hit), Drop Folders. Backup/Restore must understand SFM filenames (i.e.  Munged  unicode characters) and streams on both files and directories.  Must go beyond normal Win32 APIs to fully support SFM files (e.g. special  Win32 BackupApis were created for this purpose). How can we support nested Mac volumes?  Is this a requirement? (FileID issues, changenotify...) Need better Event/Error Logging Support from Kernel Mode, i.e. longer insertion strings, more data so we don t have to call up to user mode to log AppleSearch (Apple s content index product), AOCE Directory Service.  How do we support these? Mac 6.x and 7.1.x clients only support volumes up to 2Gig in size.  System 7.5 will support up to 4Gig. Network Trash Folder - SFM server creates this hidden directory in directory which represents root of Mac volume.  Mac clients (Finder) manage their own individual trashcan directories within this directory if it is present. Volume Icon.  Stored in hidden file called  Icon<0x0D>  in directory which represents root of Mac volume.  If Mac client finds this file present, it uses the contents to display the icon for the server volume on the Finder desktop.  Hierarchical File System  APPL mapping maps a Finder  Creator  to the name of the application which supports files with that creator.  Also each APPL mapping has a tag to distinguish it from other mappings for the same creator.  SFM File server caches its own view of the directory tree that represents the Mac volume.  It relies on directory change notifications to update its view of the tree which is seen by Mac clients.  This is required for performance numbers of AfpEnumerate to be in the same universe as Novell.    See also raid #2707 in NTRAID ntissues database for other timestamp changing observations  When a folder with blank access privileges is moved around within a folder hierarchy, it always reflects the access privileges of its containing folder.  However, once the blank access privileges bit has been cleared for a folder, its access privileges  stick  to that folder, and remain unchanged no matter where the folder is moved.  Although blank access privileges are an optional feature of AFP 2.1, it is highly recommented that this feature be included in your particular AFP 2.1 implementation since it has subtle human interface repercussions.  (AppleTalk Filing Protocol Specification Version 2.1, Apple Computer, Inc., Feb 22, 1991)  If the disk partition that the SFM volume resides on is > 2Gig, we must lie and say it is 2G-1 (same for free space) since the mac Finder treats it as a signed integer.  Mac Finder versions less than 7.5 will die with divide by zero errors if we return values greater than this.   Version 7.5 has not been tested. Normal Heading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Heading 7 Heading 8 Heading 9 Default Paragraph Font Footnote Text Footnote Reference Sue Adams-C:\NT\PRIVATE\NET\SFM\AFP\SERVER\CAIROSFM.DOC @\\MSPRINT35\1/2088 CORPG 14ABEE Ne00: winspool HP LaserJet IIISi PostScript v52.3 \\MSPRINT35\1/2088 CORPG 14ABEE Letter PRIV   N N N \\MSPRINT35\1/2088 CORPG 14ABEE Letter PRIV   N N N Times New Roman Symbol Arial Tms Rmn Sue Adams Sue Adams
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\sfmctrs\sfmctrs.ini ===
[info]
drivername=MacSrv
symbolfile=sfmctrnm.h

[languages]
009=English

[text]
SFMOBJ_009_NAME=MacFile Server
SFMOBJ_009_HELP=Services for Macintosh AFP File Server.

MAXPAGD_009_NAME=Max Paged Memory
MAXPAGD_009_HELP=The maximum amount of paged memory resources used by the MacFile Server.
CURPAGD_009_NAME=Current Paged Memory
CURPAGD_009_HELP=The current amount of paged memory resources used by the MacFile Server.
MAXNONPAGD_009_NAME=Max NonPaged Memory
MAXNONPAGD_009_HELP=The maximum amount of nonpaged memory resources use by the MacFile Server.
CURNONPAGD_009_NAME=Current NonPaged memory
CURNONPAGD_009_HELP=The current amount of nonpaged memory resources used by the MacFile Server.

CURSESSIONS_009_NAME=Current Sessions
CURSESSIONS_009_HELP=The number of sessions currently connected to the MacFile server.  Indicates current server activity.
MAXSESSIONS_009_NAME=Maximum Sessions
MAXSESSIONS_009_HELP=The maximum number of sessions connected at one time to the MacFile server.  Indicates usage level of server.

CURFILESOPEN_009_NAME=Current Files Open
CURFILESOPEN_009_HELP=The number of internal files currently open in the MacFile server. This count does not include files opened on behalf of Macintosh clients.
MAXFILESOPEN_009_NAME=Maximum Files Open
MAXFILESOPEN_009_HELP=The maximum number of internal files open at one time in the MacFile server.  This count does not include files opened on behalf of Macintosh clients.

NUMFAILEDLOGINS_009_NAME=Failed Logons
NUMFAILEDLOGINS_009_HELP=The number of failed logon attempts to the MacFile server.  Can indicate whether password guessing programs are being used to crack the security on the server.

DATAREAD_009_NAME=Data Read/sec
DATAREAD_009_HELP=The number of bytes read from disk per second.
DATAWRITTEN_009_NAME=Data Written/sec
DATAWRITTEN_009_HELP=The number of bytes written to disk per second.

DATAIN_009_NAME=Data Received/sec
DATAIN_009_HELP=The number of bytes received from the network per second.  Indicates how busy the server is.
DATAOUT_009_NAME=Data Transmitted/sec
DATAOUT_009_HELP=The number of bytes sent on the network per second.  Indicates how busy the server is.

CURQUEUELEN_009_NAME=Current Queue Length
CURQUEUELEN_009_HELP=The number of outstanding work items waiting to be processed.
MAXQUEUELEN_009_NAME=Maximum Queue Length
MAXQUEUELEN_009_HELP=The maximum number of outstanding work items waiting at one time.

CURTHREADS_009_NAME=Current Threads
CURTHREADS_009_HELP=The current number of threads used by MacFile server.  Indicates how busy the server is.
MAXTHREADS_009_NAME=Maximum Threads
MAXTHREADS_009_HELP=The maximum number of threads used by MacFile server.  Indicates peak usage level of server.






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\perfctrs\atkctrs.ini ===
[info]
drivername=AppleTalk
symbolfile=atkctrnm.h

[languages]
009=English

[text]
ATKOBJ_009_NAME=AppleTalk
ATKOBJ_009_HELP=AppleTalk Protocol

PKTSIN_009_NAME=Packets In/sec
PKTSIN_009_HELP=Number of packets received per second by Appletalk on this port.
PKTSOUT_009_NAME=Packets Out/sec
PKTSOUT_009_HELP=Number of packets sent per second by Appletalk on this port.
DATAIN_009_NAME=Bytes In/sec
DATAIN_009_HELP=Number of bytes received per second by Appletalk on this port.
DATAOUT_009_NAME=Bytes Out/sec
DATAOUT_009_HELP=Number of bytes sent per second by Appletalk on this port.

DDPAVGTIME_009_NAME=Average Time/DDP Packet
DDPAVGTIME_009_HELP=Average time in milliseconds to process a DDP packet on this port.
DDPPKTIN_009_NAME=DDP Packets/sec
DDPPKTIN_009_HELP=Number of DDP packets per second received by Appletalk on this port.

AARPAVGTIME_009_NAME=Average Time/AARP Packet
AARPAVGTIME_009_HELP=Average time in milliseconds to process an AARP packet on this port.
AARPPKTIN_009_NAME=AARP Packets/sec
AARPPKTIN_009_HELP=Number of AARP packets per second received by Appletalk on this port.

ATPAVGTIME_009_NAME=Average Time/ATP Packet
ATPAVGTIME_009_HELP=Average time in milliseconds to process an ATP packet on this port.
ATPPKTIN_009_NAME=ATP Packets/sec
ATPPKTIN_009_HELP=Number of ATP packets per second received by Appletalk on this port.

NBPAVGTIME_009_NAME=Average Time/NBP Packet
NBPAVGTIME_009_HELP=Average time in milliseconds to process an NBP packet on this port.
NBPPKTIN_009_NAME=NBP Packets/sec
NBPPKTIN_009_HELP=Number of NBP packets per second received by Appletalk on this port.

ZIPAVGTIME_009_NAME=Average Time/ZIP Packet
ZIPAVGTIME_009_HELP=Average time in milliseconds to process a ZIP packet on this port.
ZIPPKTIN_009_NAME=ZIP Packets/sec
ZIPPKTIN_009_HELP=Number of ZIP packets per second received by Appletalk on this port.

RTMPAVGTIME_009_NAME=Average Time/RTMP Packet
RTMPAVGTIME_009_HELP=Average time in milliseconds to process an RTMP packet on this port.
RTMPPKTIN_009_NAME=RTMP Packets/sec
RTMPPKTIN_009_HELP=Number of RTMP packets per second received by Appletalk on this port.

ATPLOCALRETRIES_009_NAME=ATP Retries
ATPLOCALRETRIES_009_HELP=Number of local ATP requests retransmitted on this port.
ATPREMOTERETRIES_009_NAME=ATP Retries
ATPREMOTERETRIES_009_HELP=Number of remote ATP requests retransmitted on this port.
ATPRESPTIMEOUT_009_NAME=ATP Response Timouts
ATPRESPTIMEOUT_009_HELP=Number of ATP release timers that have expired on this port.
ATPXORESP_009_NAME=ATP XO Response/Sec
ATPXORESP_009_HELP=Number of ATP Exactly-once transaction responses per second on this port.
ATPALORESP_009_NAME=ATP ALO Response/Sec
ATPALORESP_009_HELP=Number of ATP At-least-once transaction responses per second on this port.
ATPRECDREL_009_NAME=ATP Recvd Release/Sec
ATPRECDREL_009_HELP=Number of ATP transaction release packets per second received on this port.

CURPOOL_009_NAME=Current NonPaged Pool
CURPOOL_009_HELP=The current amount of nonpaged memory resources used by AppleTalk.

PKTROUTEDIN_009_NAME=Packets Routed In/Sec
PKTROUTED_009_HELP=Number of packets routed in on this port.

PKTROUTEDOUT_009_NAME=Packets Routed Out/Sec
PKTROUTEDOUT_009_HELP=Number of packets routed out on this port.

PKTDROPPED_009_NAME=Packets dropped
PKTDROPPED_009_HELP=Number of packets dropped due to resource limitations on this port.


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\sfmuam.txt ===
Microsoft Windows 2000 Server
                                 Services for Macintosh Release Notes
            INSTALLATION OF THE MACINTOSH WORKSTATION SOFTWARE AND
                                QUICK REFERENCE FOR MACINTOSH USERS

INSTALLING THE MACINTOSH WORKSTATION SOFTWARE

The following instructions describe how to install the Macintosh(c) workstation software that provides secure logon to a Microsoft(c) Windows(c) 2000 Server.

User Authentication

A user authentication module (UAM) is a software program that prompts users for an account name and password before they log on to a server. The Macintosh Chooser has a standard UAM built in, which uses the clear-text password or Apple's RandNum Exchange  method of security.

Microsoft Authentication offers an additional level of security  because the password is used as a key to encrypt a random number. If the system administrator for the computer running Windows 2000 Server has determined that encryption is an important security measure, you may be asked to use Microsoft Authentication when you log on to the server.

Minimum Requirements for MS UAM 5.0

To use the new Microsoft UAM v5.0, you must have a Macintosh client running AppleShare Client 3.8 or newer or Mac OS 8.5 or newer. If you do not meet these minimum requirements, the MS UAM Installer will install the old MS UAM v1.0 module. If you upgrade your system software, you will need to re-run the MS UAM Installer.

NOTE: Microsoft does not support AppleShare 3.7 for use with Windows 2000 Server and Services For Macintosh. If you are using version 3.7 of the AppleShare Client, Microsoft strongly recommends that you upgrade to AppleShare Client 3.8 or newer.

Microsoft Authentication 1.0

MS UAM 1.0 is not compatible with AFP over TCP/IP. If you attempt to log onto a Windows 2000 Server using MS UAM 1.0 and TCP/IP is available, the UAM will close after clicking "OK" and will not provide any error message.

For authentication over TCP/IP, you must install MS UAM 5.0. See minimum requirement for MS UAM 5.0 earlier in this document.

Installing User Authentication

Log on to the Microsoft UAM Volume on the computer running Windows 2000 Server to access the MS UAM file. Then drag this file to your AppleShare(c) Folder in your System Folder. Instructions follow. (Users outside North America, see the "International Concerns" section later in these Release Notes before proceeding.)

To gain access to the Microsoft Authentication files on the computer running Windows 2000 Server

1. On the Macintosh Apple menu, click Chooser.

2. Double-click the AppleShare icon, and then click the AppleTalk(c) zone in which the computer running Windows 2000 Server, with Services for Macintosh, resides. (Ask your system administrator if you're not sure of the zone.)

3. From the list of file servers, select the Windows 2000 Server computer, and then click OK.

4. Click the Registered User or Guest option, as appropriate, and then click OK.

5. Click the Microsoft UAM Volume, and then click OK.

6. Close the Chooser dialog box.

To install the authentication files on the Macintosh workstation

1. On the Macintosh Desktop, double-click the Microsoft UAM Volume.

2. Locate the "MS UAM Installer" file on the Microsoft UAM Volume, then double-click it.

3. Click Continue in the installer welcome screen.

The installer will report whether the installation succeeded.

If the installation has succeeded, when Macintosh users of this workstation connect to the Windows 2000 Server computer, they will be offered Microsoft Authentication.


QUICK REFERENCE FOR MACINTOSH USERS

As a Macintosh user, you can share files and folders with users of Intel-based computers by saving the files and folders to a computer running Windows 2000 Server with Services for Macintosh. You do this by mounting a Macintosh-accessible volume onto your desktop and saving the files and folders you want to share on it. (A Macintosh-accessible volume is a directory on the computer running Windows 2000 Server that has been designated as a volume that Macintosh computers can use.) If you're sharing files with MS-DOS users, it's a good idea to name files and folders using the 8.3 standard (eight characters, followed by a period, and then a three-character extension) used by MS-DOS-based computers -- for example, Chapter.doc. If you use the 8.3 standard, MS-DOS users of shared files can easily find the file on the computer running Windows 2000 Server.

For more information about sharing files and printing on a computer running Windows 2000 Server, see the Microsoft Windows 2000 Server Services for Macintosh manual and the Microsoft Windows 2000 Server System Guide. For general information about using Macintosh computers, see your Macintosh user manuals.

Logging On to a Computer Running Windows 2000 Server

Logging on to a computer running Windows 2000 Server with Services for Macintosh is much like logging on to any other server on an AppleTalk network. During this procedure, you will be asked to specify a logon method -- either Apple Standard UAM (user authentication module) or Microsoft Authentication (which provides secure logon to the computer running Windows 2000 Server). Consult your system administrator if you are not offered Microsoft Authentication. Your system administrator may want you to install the files necessary to run it. (For more information, refer to earlier sections of this file.)

Privileges and Permissions

When you create a folder on a Macintosh computer, you can set access privileges for it. By setting privileges, you can determine who can see and change the folder and the files in it. You do this on your Macintosh computer by selecting the folder and, on the Finder's File menu, clicking Sharing. The access privileges you set on folders in Macintosh-accessible volumes are translated to Windows 2000-style permissions on the corresponding directory on the Windows 2000 computer.

Note that Windows 2000-based users can set permissions (on files and folders), which are translated to access privileges. These access privileges affect your ability to use files and folders saved by users of Intel-based computers. Therefore,  if you're having trouble using a file on the computer running Windows 2000 Server, you may not have the necessary privileges. Consult the system administrator or the owner of the file to get the permissions you need.


Troubleshooting Hints

I can't find a volume.

The volume might be configured as a private volume. A private volume is any volume in which the Owner, Primary Group, and Everyone categories have no access privileges -- only the owner has permissions. Ask the owner or administrator to give you the permissions you need to use it.

I can't find a folder or file.

You may not have privileges to see the files or folders. Ask the owner or administrator to give you the privileges you need to use it.

I forgot my password.

Ask the system administrator to reset your password.

I can't save a file with an 8.3 name.

This name may already exist on the computer running Windows 2000 Server. Give the file a different filename. If MS-DOS users are going to need it, using the 8.3 standard makes it easier for them to identify it. (A short name is automatically generated by the computer running Windows 2000 Server. However, it may not be as easily identifiable to users as one you create.) If no MS-DOS users will need the file, the filename can be as long as Macintosh computers allows -- 31 characters.

I can't find the Windows 2000 Server with Services for Macintosh.

Ask your system administrator to help you.

A user of an Intel-based computer with whom I'm sharing files can't see the contents of a folder.

The folder's owner needs to give the user of the Intel-based computer both the See Files and See Folders access privileges (also called permissions on a Windows 2000 computer).

I can't mount a Macintosh-accessible volume using an alias.

The volume may have a password, or you may have connected to the volume using Microsoft Authentication. If the volume has a password, you can mount the volume through the Chooser and then use the alias. Or you can specify that it be opened at system startup when you mount the volume. If you are using Microsoft Authentication to log on to the server, you must mount the volume through the Chooser and then use the alias.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\docs\snmp.doc ===
Microsoft Word Document MSWordDoc Word.Document.6Peter Brundrett Microsoft ACL EditorACL Editor Security Don Ryan Security, design, NT 5.0, ACLs, User Interface This document describes the design of the Session Announcement Protocol (SAP) support for Windows NT 5.0. Don Ryan Microsoft Word for Windows 95VISIO 4 Drawing VISIO 4.0 Shapes Visio.Drawing.4"Arial NT 5.0 Extensible Agent "System "Arial Subagent Registry Region OID Object Resolver Region OID. Region OID NT 5.0 Subagent DLL Object Repository Callbackg Callback Callback Relative OIDg Relative OID Relative OID Instrumentation Instrumentation Instrumentation Downlevel Object Resolver NT 5.0 VarBind Resolver3 Code Generator6 SMI Compiler6 MIB Definition File Downlevel Subagent DLL Object Resolver AgentX ObjectM Resolver Object Resolver NT 5.0b Object Resolver AgentX% Process SNMPSFX.DLL NT 5.0C Subagent FrameworkdonryanVisio (TM) Drawing  Arial) s New Ro #P@w?l_ aopso %@U i e3?E2 K?]?o? ?&2=E aP1V? dPobj 4+\`a M___y QX!X$\2 ?-?7Z PRINT44\ 26S/1MC  CORPV 15 Lette winspo \\MSP RINT44\2 6S/1MC C ORPV 157 .55.80.2 Ne01: This s ymbol re presents  any kin d of pro cessing  function  Doubl e-click  to add s ub-page. `9Copyr ight  995 Visi o Corpor ation.   eserved. ape.hlp! #18035 Proce h=kI h= o@bo@2o@ TO:p5 ,Enter  the c ssociate d with s p]3 ###,/P.00 GdhT {of Sstep Resou]r_0 Stask %Custom} \0perti Se sel  To Page `a;no pshdw  eDo_cumen h')Q4 Generi c box wi th text  and conn ection p oints. C an be st retched  y dimwens opyright  1995  Visio Co rporatio n.  All  s reser Shape. hlp!#150 k@tk@< er Name the u entory N umber Repres ents a d atabase,~  sourc or other torage  device. Shape.hl p!#11010 pyright   1995 V isio Cor poration .  All  s reserv  @!6moN#b }(1Z] SsiZ! t Name Enter  the a Inventor y NumberW ustom Pr operties7 selected  sw"g er Name the u entory N umber Use wi th satel lite, ish, etc . to ind  a co mmun!  link. ?X/j& `Qps- Shape.h lp!#1102 opyright  1995  Visio Co rporatio n.  All  2s reser v3PPn t Name Enter  the a Invento ry Numbe Uvn_r Custom P ropertieos bselectegd s Use to  create  either a  straigh t or cur ved conn ector. trol? handl ge shape7 of t"zz K#H& `9Copyr ight  995 Visi o Corpor ation.   eserved. ape.hlp! #11040 Use to  create  either a  straigh t or cur ved conn ector. M trol? handl ge shape7 of t"zz K#H& `9Copyr ight  995 Visi o Corpor ation.   eserved. ape.hlp! #18150 TGWvn{S Connec t the to p or bot tom of o ne shap `9Copy right  1995 Vis io Corpo ration.   All T2s  reserved hape.hlp !#18145 Open o r closed  arrow.  Place o gains t edg another ing to F ront". opyright  1995  Visio Co rporatio n.  All  R"s reser Shape. hlp!#150o20 n Tail scj ch.c;1 ~@l:93w K2end of  arrow. $K7-k Q(-DT 2H@#5HAl o3e%# _@.P! Use to  create  either a  straigh t or cur ved conn ector. trol? handl ge shape7 of ?@/R&  s#p& `9Copy right  1995 Vis io Corpo ration.   All  reserved hape.hlp !#15050 ccentricwitya@ Connec t the to p or bot tom of o ne shap `9Copy right  1995 Vis io Corpo ration.   All T2s  reserved hape.hlp !#11035 Connec t the si de of on hape to top or  bottom `9Cop yright   1995 Vi sio Corp oration.   All T2s  reserve Shape.hl p!#11035 Connec tor with  up to 5  legs. G lue shap es pointo-to- press Ct  method 7/I/[$ @"<@rP Copyrigh  1995  Visio C orporati on.  All  TRs rese rved. Shape .hlp!#11 ~B|a~E fca@( n#CWr CBufo`ug` Arm_ PosinQ Connec t the bo ttom of  one obj opyright  1995  Visio Co rporatio n.  All  2s reser Shape. hlp!#110 "IA,G@ [DMHCA cIDEA Y Posi of Arm1 Connec t the si de of on se hori zontal f get 9"' pyright   1995 V isio Cor poration .  All  s reserv Shape.h lp!#1814 QxCiG X Posi  of Arm+ Connec t the si de of on hape to top or  bottom opyright  1995  Visio Co rporatio n.  All  T2s reser Shape. hlp!#181 L&G+> Connec t the si de of on `9Cop yright   1995 Vi sio Corp oration.   All   reserve Shape.hl p!#18145 A@-lPA $aA A% 1 of Akrm+ Connec tor with  up to 5  legs. G lue shap es pointo-to- press Ct  method Copyrigh  1995  Visio C orporati on.  All  ,Rs rese rved. Shape .hlp!#18  BfWBPaWE ``e'c {`Efw A@rVd @ug`@  PosiFQ Connec t the to p of one -4*4^ `9Copy right  1995 Vis io Corpo ration.   All  reserved hape.hlp !#181451 ]AUcIDEA Connec t the bo ttom of  one obj opyright  1995  Visio Co rporatio n.  All  2s reser Shape. hlp!#181 "IA,G@ [DMHCA ]AUcIDEA Y Pos 1 of Ar5m1 ,:vn_ Ivn}. ,PvnV $R'vnF' vns/H )/;/M/_/q/ c:\wi n32app\v isio\ste ncils dard\Flo wchart S hapes.vsUs block work s >j'$?/$C AXV0Vj_ gentX ject Res_olvero f\ono ProcWess  5.0 Ext ensible  fposi/tory Suba~ ~-??? w[?m? @I?o8 Objec =/O/a/s/+I &?:LG8@F[?m:@H qon/ OID^p XKOgg "_4_: NT_ 5.0 .O@OROdL ?+o@+T SNMPSFX. 4?F?X?"om Subag ent Fram_ework CallWbac ak?^{ ownlevelA  W/i/{/ >?P?b?I hRelati ve OID trum| Y*C/P/ T*j/|/ :+,?>?P? ogOyO _._@_R_ Downleve Object  Resolve NT 5. VarBi :mV % 6oHoZh~f 9?K?[g oT!@) Code Gen erator DxSMI  Compil DxMIB Def inition AF Page-1 Black  _White Green Yellow 10% x Long d 1Gpxl Hairq rial ck e?red top left Connec !. arr\ endG"$"c textG"Pro  Dura our{  t-Thi  ataba erName !/Opaq& /bottom N)D16 ?d!@}0 4&A&CUni $3&G22 T@@.27 T4%H4%P3 @&C`V O* A9 epiep^epZ epXepAep5ep)jep hrcsn iS"hW"2c  /5?<3 ?J3h/& !O3OEOWO _._@_R_BNT 5.0 Network Management SNMP Framework snmp.doc Windows NT 5.0 Design Team - Don Ryan Version 2.2 Monday, October 21, 1996 Distribution: Microsoft Internal Distribution  Copyright Microsoft Corporation, 1996. All Rights Reserved Microsoft Confidential Printed on  date \@ M/d/yy 11/18/96 time \@ "h:mm AM/PM" 8:08 PM Note: This documentation is an early release of the final product documentation. It is meant to accompany software that is still in development. Some of the information in this documentation may be inaccurate or may not be an accurate representation of the functionality of the final retail product. Microsoft assumes no responsibility for any damages that might occur either directly or indirectly from these inaccuracies. Table of Contents  TOC \o "1-3"  1. Introduction  GOTOBUTTON _Toc372981953    PAGEREF _Toc372981953  2. Requirements  GOTOBUTTON _Toc372981954    PAGEREF _Toc372981954  2.1 SNMPv1 Support  GOTOBUTTON _Toc372981955    PAGEREF _Toc372981955  2.2 SNMPv2c Support  GOTOBUTTON _Toc372981956    PAGEREF _Toc372981956  2.3 AgentX Compatibility  GOTOBUTTON _Toc372981957    PAGEREF _Toc372981957  2.4 Subagent Development Support  GOTOBUTTON _Toc372981958    PAGEREF _Toc372981958  3. Block Diagram  GOTOBUTTON _Toc372981959    PAGEREF _Toc372981959  4. Terminology  GOTOBUTTON _Toc372981960    PAGEREF _Toc372981960  4.1 Agent  GOTOBUTTON _Toc372981961    PAGEREF _Toc372981961  4.2 Manager  GOTOBUTTON _Toc372981962    PAGEREF _Toc372981962  4.3 Object Identifier (OID)  GOTOBUTTON _Toc372981963    PAGEREF _Toc372981963  4.4 Management Information Base (MIB)  GOTOBUTTON _Toc372981964    PAGEREF _Toc372981964  4.5 Extensible Agent  GOTOBUTTON _Toc372981965    PAGEREF _Toc372981965  4.6 Supported View  GOTOBUTTON _Toc372981966    PAGEREF _Toc372981966  4.7 Subagent  GOTOBUTTON _Toc372981967    PAGEREF _Toc372981967  5. Overview  GOTOBUTTON _Toc372981968    PAGEREF _Toc372981968  5.1 Subagent Developer  GOTOBUTTON _Toc372981969    PAGEREF _Toc372981969  5.2 Extensible Agent  GOTOBUTTON _Toc372981970    PAGEREF _Toc372981970  5.3 Subagent Framework  GOTOBUTTON _Toc372981971    PAGEREF _Toc372981971  6. Subagent Provider Interface  GOTOBUTTON _Toc372981972    PAGEREF _Toc372981972  6.1 Data Structures  GOTOBUTTON _Toc372981973    PAGEREF _Toc372981973  6.1.1 SNMP_AGENTPROCTABLE  GOTOBUTTON _Toc372981974    PAGEREF _Toc372981974  6.1.2 SNMP_EXTENSIONPROCTABLE  GOTOBUTTON _Toc372981975    PAGEREF _Toc372981975  6.2 Subagent Entry Point  GOTOBUTTON _Toc372981976    PAGEREF _Toc372981976  6.2.1 SnmpExtensionStartup  GOTOBUTTON _Toc372981977    PAGEREF _Toc372981977  6.3 Agent Procedure Table  GOTOBUTTON _Toc372981978    PAGEREF _Toc372981978  6.3.1 SnmpAgtOpen  GOTOBUTTON _Toc372981979    PAGEREF _Toc372981979  6.3.2 SnmpAgtClose  GOTOBUTTON _Toc372981980    PAGEREF _Toc372981980  6.3.3 SnmpAgtRegister  GOTOBUTTON _Toc372981981    PAGEREF _Toc372981981  6.3.4 SnmpAgtUnregister  GOTOBUTTON _Toc372981982    PAGEREF _Toc372981982  6.3.5 SnmpAgtNotify  GOTOBUTTON _Toc372981983    PAGEREF _Toc372981983  6.3.6 SnmpAgtReserveIndex  GOTOBUTTON _Toc372981984    PAGEREF _Toc372981984  6.3.7 SnmpAgtUnreserveIndex  GOTOBUTTON _Toc372981985    PAGEREF _Toc372981985  6.3.8 SnmpAgtAddCaps  GOTOBUTTON _Toc372981986    PAGEREF _Toc372981986  6.3.9 SnmpAgtRemoveCaps  GOTOBUTTON _Toc372981987    PAGEREF _Toc372981987  6.4 Extension Procedure Table  GOTOBUTTON _Toc372981988    PAGEREF _Toc372981988  6.4.1 SnmpExtGet  GOTOBUTTON _Toc372981989    PAGEREF _Toc372981989  6.4.2 SnmpExtGetNext  GOTOBUTTON _Toc372981990    PAGEREF _Toc372981990  6.4.3 SnmpExtGetBulk  GOTOBUTTON _Toc372981991    PAGEREF _Toc372981991  6.4.4 SnmpExtTestSet  GOTOBUTTON _Toc372981992    PAGEREF _Toc372981992  6.4.5 SnmpExtCommitSet  GOTOBUTTON _Toc372981993    PAGEREF _Toc372981993  6.4.6 SnmpExtUndoSet  GOTOBUTTON _Toc372981994    PAGEREF _Toc372981994  6.4.7 SnmpExtCleanupSet  GOTOBUTTON _Toc372981995    PAGEREF _Toc372981995  6.4.8 SnmpExtShutdown  GOTOBUTTON _Toc372981996    PAGEREF _Toc372981996  7. Subagent Framework  GOTOBUTTON _Toc372981997    PAGEREF _Toc372981997  7.1 Data Structures  GOTOBUTTON _Toc372981998    PAGEREF _Toc372981998  7.1.1 MIB_REGION  GOTOBUTTON _Toc372981999    PAGEREF _Toc372981999  7.1.2 MIB_OBJECT  GOTOBUTTON _Toc372982000    PAGEREF _Toc372982000  7.1.3 MIB_PROPERTY  GOTOBUTTON _Toc372982001    PAGEREF _Toc372982001  7.1.4 MIB_TABLE  GOTOBUTTON _Toc372982002    PAGEREF _Toc372982002  7.1.5 MIB_RANGE  GOTOBUTTON _Toc372982003    PAGEREF _Toc372982003  7.1.6 MIB_INSTRUMENTATION  GOTOBUTTON _Toc372982004    PAGEREF _Toc372982004  7.1.7 MIB_REQUEST  GOTOBUTTON _Toc372982005    PAGEREF _Toc372982005  7.2 Instrumentation Callbacks  GOTOBUTTON _Toc372982006    PAGEREF _Toc372982006  7.2.1 MIB_CALLBACK  GOTOBUTTON _Toc372982007    PAGEREF _Toc372982007  7.2.2 MIB_ACTION_GET  GOTOBUTTON _Toc372982008    PAGEREF _Toc372982008  7.2.3 MIB_ACTION_GETNEXT  GOTOBUTTON _Toc372982009    PAGEREF _Toc372982009  7.2.4 MIB_ACTION_TEST  GOTOBUTTON _Toc372982010    PAGEREF _Toc372982010  7.2.5 MIB_ACTION_COMMIT  GOTOBUTTON _Toc372982011    PAGEREF _Toc372982011  7.2.6 MIB_ACTION_UNDO  GOTOBUTTON _Toc372982012    PAGEREF _Toc372982012  7.2.7 MIB_ACTION_CLEANUP  GOTOBUTTON _Toc372982013    PAGEREF _Toc372982013  7.3 Framework Entry Points  GOTOBUTTON _Toc372982014    PAGEREF _Toc372982014  7.3.1 SnmpSfxOpen  GOTOBUTTON _Toc372982015    PAGEREF _Toc372982015  7.3.2 SnmpSfxClose  GOTOBUTTON _Toc372982016    PAGEREF _Toc372982016  7.3.3 SnmpSfxRegister  GOTOBUTTON _Toc372982017    PAGEREF _Toc372982017  7.3.4 SnmpSfxUnregister  GOTOBUTTON _Toc372982018    PAGEREF _Toc372982018  7.3.5 SnmpSfxResolveVarBinds  GOTOBUTTON _Toc372982019    PAGEREF _Toc372982019  8. Subagent Code Generator  GOTOBUTTON _Toc372982020    PAGEREF _Toc372982020  8.1 Data Structures  GOTOBUTTON _Toc372982021    PAGEREF _Toc372982021  8.1.1 MIB_ENTRY  GOTOBUTTON _Toc372982022    PAGEREF _Toc372982022  8.2 Building Symbol Table  GOTOBUTTON _Toc372982023    PAGEREF _Toc372982023  8.2.1 SnmpSfxLoadMibEntries  GOTOBUTTON _Toc372982024    PAGEREF _Toc372982024  8.2.2 SnmpSfxFreeMibEntries  GOTOBUTTON _Toc372982025    PAGEREF _Toc372982025  8.3 Generating Subagent Code  GOTOBUTTON _Toc372982026    PAGEREF _Toc372982026  8.3.1 Generating MIB Objects Data File  GOTOBUTTON _Toc372982027    PAGEREF _Toc372982027  8.3.2 Generating MIB Objects Header File  GOTOBUTTON _Toc372982028    PAGEREF _Toc372982028  8.3.3 Generating Instrumentation Header File  GOTOBUTTON _Toc372982029    PAGEREF _Toc372982029  8.3.4 Generating Instrumentation Skeleton Code  GOTOBUTTON _Toc372982030    PAGEREF _Toc372982030  9. Extensible Agent  GOTOBUTTON _Toc372982031    PAGEREF _Toc372982031  9.1 SNMPv2c Support  GOTOBUTTON _Toc372982032    PAGEREF _Toc372982032  9.2 Downlevel Subagent Heap Validation  GOTOBUTTON _Toc372982033    PAGEREF _Toc372982033  9.3 Registry Settings  GOTOBUTTON _Toc372982034    PAGEREF _Toc372982034  9.3.1 ExtensionAgents  GOTOBUTTON _Toc372982035    PAGEREF _Toc372982035  9.3.2 TrapDestinations  GOTOBUTTON _Toc372982036    PAGEREF _Toc372982036  9.3.3 PermittedManagers  GOTOBUTTON _Toc372982037    PAGEREF _Toc372982037  9.3.4 ReadWriteCommunities  GOTOBUTTON _Toc372982038    PAGEREF _Toc372982038  9.3.5 ReadOnlyCommunities  GOTOBUTTON _Toc372982039    PAGEREF _Toc372982039  9.3.6 EnableAuthenticationTraps  GOTOBUTTON _Toc372982040    PAGEREF _Toc372982040  9.3.7 AuditingFlags  GOTOBUTTON _Toc372982041    PAGEREF _Toc372982041  9.3.8 LogLevel  GOTOBUTTON _Toc372982042    PAGEREF _Toc372982042  9.3.9 LogType  GOTOBUTTON _Toc372982043    PAGEREF _Toc372982043  9.3.10 SystemName  GOTOBUTTON _Toc372982044    PAGEREF _Toc372982044  9.3.11 SystemContact  GOTOBUTTON _Toc372982045    PAGEREF _Toc372982045  9.3.12 SystemLocation  GOTOBUTTON _Toc372982046    PAGEREF _Toc372982046  9.3.13 SystemServices  GOTOBUTTON _Toc372982047    PAGEREF _Toc372982047  10. References  GOTOBUTTON _Toc372982048    PAGEREF _Toc372982048  Introduction This document describes the design of the Windows NT 5.0 SNMP framework. Requirements SNMPv1 Support The extensible agent and subagent framework must support RFCs 1155, 1157, and 1212. The MIB-II subagent must implement all groups listed in RFC 1213 save the EGP group. The LMMIB-II subagent must implement all groups in the LANMgr-MIB-II draft. SNMPv2c Support The extensible agent and subagent framework must support RFCs 1901-1906, and 1908. The extensible agent must implement the SNMPv2 MIB as described in RFC 1907. AgentX Compatibility The extensible agent and subagent framework must provide functionality equivalent to that of the latest draft of the AgentX intra-agent protocol proposed by the IETF Agent Extensibility working group. The extensible agent should provide support for the AgentX protocol once it becomes a Proposed Standard.  This would allow developers to export MIBs from separate processes as well as over the network. Subagent Development Support The subagent framework must include code generation tools which produce all of the functions and data structures necessary to interface with the extensible agent. The subagent framework must relieve subagent developers of writing common processing code and simply require them to fill in instrumentation callbacks for each MIB object. Block Diagram  EMBED Visio.Drawing.4   Figure   SEQ Figure \* ARABIC   Windows NT 5.0 SNMP Framework Terminology Agent An SNMP agent is a software process running on a network device that services requests for management information from interested SNMP managers.  An agent is also responsible for notifying registered managers of extraordinary events that occur on that device.   Manager An SNMP manager is a software process running on a host workstation that monitors and modifies the managerment information of a network device made available via an SNMP agent.  A manager is also responsible for listening for SNMP agent notifications (also known as traps). Object Identifier (OID) An SNMP agent supplies management information in the form of managed objects.  Each object supplied by the agent has a unique object identifier consisting of the object s type and additional information describing the object s instance.  Each object identifier is an array of integers which correspond to the object s position in a global hierarchical namespace.  The prefix for all objects in SNMP is iso.org.dod.internet (1.3.6.1) which is referred to simply as internet.  Objects defined by the Internet standards body are placed under the mgmt subtree (internet.2) or SNMPv2 subtree (internet.6) whereas objects defined by private organizations are placed under the private subtree (internet.4).  For example, the internet.mgmt.mib-2.system.sysDescr (1.3.1.6.2.1.1.1) object type represents a textual description of the network device on which the agent resides.   Since only one such object exists on a network device, the manager would ask the agent for the default instance of the object by appending a zero to the type identifier (sysDescr.0).  Other objects require much more elaborate instance information.  An entry in the tcpConnTable, for example, needs the local address, local port, remote address, and remote port appended to the object type. Management Information Base (MIB) A Management Information Base is a text file describing a collection of managed objects in a subtree of the global namespace.  The root of this subtree is called the MIB prefix.  All of the object identifiers in the subtree are enumerated and each managed object s textual description, syntax, access level, and display hints are given.  It is important to remember that an agent may or may not implement all of the objects listed in a MIB.  It serves mainly as a schema. Extensible Agent An extensible agent is one which allows independent developers to create MIB implementations and add them to the collection of managed objects supported by the agent without compilation. Supported View A collection of managed objects from one or more MIBs supported by an extensible agent. Subagent An entity which supplies a region of the extensible agent s supported view. Overview The purpose of the Windows NT 5.0 SNMP framework is to make the process of creating subagents easier.  By defining data structures which represent the management information available in a MIB module and by describing how this information relates to the underlying instrumentation, functionality common to all subagents can be collected into a framework which independent subagent developers can leverage.  Code generation utilities can then be introduced that produce these data structures as well as skeletons of the associated instrumentation callbacks thus making the process of implementing a MIB module much more manageable. Subagent Developer  Relying on the new subagent framework, subagent developers simply: input desired MIB module into the SFXGEN code generation utility included in the Win32 SDK.   customize the instrumentation callbacks and their associated data structures so that they more accurately reflect the design of the subagent developer s component. complete the instrumentation callbacks. The SFXGEN code generation utility produces a file containing an internal representation of the MIB module that the subagent framework can understand (see Object Repository above) as well as a file containing an empty instrumentation callback for each group and conceptual table defined within the MIB module. Extensible Agent  During initialization the extensible agent does the following: loads each subagent DLL via the pathname stored in the Win32 registry database. invokes SnmpExtensionStartup entry point to exchange procedure tables and initialize subagent. updates Subagent Registry with the MIB regions the subagent specifies in calls to the extensible agent s SnmpAgtRegister upcall.   After receiving an incoming manager request, the extensible agent: decodes the request and creates a list of incoming variable-bindings. examines each variable name and determines which Object Resolver supplies the instrumentation.   invokes Object Resolver via the extension procedure table passing in all relevant variable-bindings. constructs the outgoing variable-binding list from all of the Object Resolver responses. encodes the outgoing variable-binding list and sends response back to the manager. Subagent Framework  If the NT 5.0 Subagent Framework is not being used then the subagent must implement each function in the subagent procedure table and process the incoming requests itself.  If the NT 5.0 Subagent Framework is being leveraged then a stub NT 5.0 Object Resolver registers the subagent s Object Repository with the NT 5.0 Subagent Framework and the framework handles the incoming requests by invoking the subagent s instrumentation routines. The NT 5.0 Subagent Framework does the following: examines each variable name and locates the associated object in the specified Object Repository (or the next appropriate object in the case of a GETNEXT or GETBULK request). applies access restrictions based on the request type and any local configuration settings. verifies correct type specified for SET requests. verifies range and enumeration restrictions have been respected for SET requests. initializes a buffer for the instrumentation callback associated with the MIB object.  If the same callback is specified for multiple variables then the same buffer is used for all of them.  parses instance information from the variable name and adds any index objects to buffer. invokes instrumentation callback with the initialized instrumentation buffer. verifies data returned and reconstructs variable name using updated index objects. passes modified variable-binding list back to the stub NT 5.0 Object Resolver. Subagent Provider Interface The existing subagent API is based on a set of entry points that a subagent exports.  The subagent has no way to communicate with the extensible agent except through the API return codes and the event handle exchanged at initialization (and that only signals the extensible agent to call the subagent s SnmpExtensionTrap entry point).  The NT 5.0 Subagent Provider Interface (SPI) is an extensible means by which the extensible agent and subagent can communicate efficiently. Data Structures SNMP_AGENTPROCTABLE typedef struct _SNMP_AGENTPROCTABLE {     PFNSNMPAGTOPEN            pfnSnmpAgtOpen;     PFNSNMPAGTCLOSE           pfnSnmpAgtClose;     PFNSNMPAGTREGISTER        pfnSnmpAgtRegister;     PFNSNMPAGTUNREGISTER      pfnSnmpAgtUnregister;     PFNSNMPAGTNOTIFY          pfnSnmpAgtNotify;     PFNSNMPAGTRESERVEINDEX    pfnSnmpAgtReserveIndex;     PFNSNMPAGTUNRESERVEINDEX  pfnSnmpAgtUnreserveIndex;     PFNSNMPAGTADDCAPS         pfnSnmpAgtAddCaps;     PFNSNMPAGTREMOVECAPS      pfnSnmpAgtRemoveCaps; } SNMP_AGENTPROCTABLE, *PSNMP_AGENTPROCTABLE; Members: pfnSnmpAgtOpen - Pointer to agent s SnmpAgtOpen upcall. pfnSnmpAgtClose - Pointer to agent s SnmpAgtClose upcall. pfnSnmpAgtRegister - Pointer to agent s SnmpAgtRegister upcall. pfnSnmpAgtUnregister - Pointer to agent s SnmpAgtUnregister upcall. pfnSnmpAgtNotify - Pointer to agent s SnmpAgtNotify upcall. pfnSnmpAgtReserveIndex - Pointer to agent s SnmpAgtReserveIndex upcall. pfnSnmpAgtUnreserveIndex - Pointer to agent s SnmpAgtUnreserveIndex upcall. pfnSnmpAgtAddCaps - Pointer to agent s SnmpAgtAddCaps upcall. pfnSnmpAgtRemoveCaps - Pointer to agent s SnmpAgtRemoveCaps upcall. SNMP_EXTENSIONPROCTABLE typedef struct _SNMP_EXTENSIONPROCTABLE {     PFNSNMPEXTGET        pfnSnmpExtGet;     PFNSNMPEXTGETNEXT    pfnSnmpExtGetNext;     PFNSNMPEXTGETBULK    pfnSnmpExtGetBulk;     PFNSNMPEXTTESTSET    pfnSnmpExtTestSet;     PFNSNMPEXTCOMMITSET  pfnSnmpExtCommitSet;     PFNSNMPEXTUNDOSET    pfnSnmpExtUndoSet;     PFNSNMPEXTCLEANUPSET pfnSnmpExtCleanupSet;     PFNSNMPEXTSHUTDOWN   pfnSnmpExtShutdown; } SNMP_EXTENSIONPROCTABLE, *PSNMP_EXTENSIONPROCTABLE; Members: pfnSnmpExtGet - Pointer to subagent s SnmpExtGet callback. pfnSnmpExtGetNext - Pointer to subagent s SnmpExtGetNext callback. pfnSnmpExtGetBulk - Pointer to subagent s SnmpExtGetBulk callback. pfnSnmpExtTestSet - Pointer to subagent s SnmpExtTestSet callback. pfnSnmpExtCommitSet - Pointer to subagent s SnmpExtCommitSet callback. pfnSnmpExtUndoSet - Pointer to subagent s SnmpExtUndoSet callback. pfnSnmpExtCleanupSet - Pointer to subagent s SnmpExtCleanupSet callback. pfnSnmpExtShutdown - Pointer to subagent s SnmpExtShutdown callback. Subagent Entry Point SnmpExtensionStartup BOOL WINAPI SnmpExtensionStartup(     IN     PSNMP_AGENTPROCTABLE     pAgentProcTable,        OUT PSNMP_EXTENSIONPROCTABLE pExtensionProcTable     ); Arguments: pAgentProcTable - Pointer to agent s procedure table. pExtensionProcTable - Pointer to receive subagent s procedure table. Return Status: Returns TRUE is successful. Routine Description: The master agent calls this entry point in order to initialize a subagent.  Agent Procedure Table SnmpAgtOpen typedef BOOL (CALLBACK * PFNSNMPAGTOPEN)(     IN     PSNMP_OID     pSubagentId,     IN     PSNMP_OCTETS  pSubagentDescr,     IN     PSNMP_CONTEXT pSubagentContext,     IN     DWORD         SubagentTimeout,        OUT PSNMP_HANDLE  pSubagentHandle,        OUT PDWORD        pDefaultUpTime Arguments: pSubagentId - Unique identifier of subagent (optional). pSubagentDescr- String uniquely describing subagent. pSubagentContext - Context of subagent logical connection (optional). SubagentTimeout - The length of time, in seconds, that a master agent should allow to elapse after dispatching a message to a subagent before it regards the subagent as not responding.  This is a         subagent-wide default value that may be overridden by values associated with specific registered MIB regions.  The default value of `0' indicates that no subagent-wide value is         requested. pSubagentHandle - Pointer to receive handle from extensible agent. pDefaultUpTime - Pointer to receive sysUpTime.0 from default context. Return Status: Returns TRUE if successful. Routine Description: The subagent calls this routine in order to establish a logical connection to the master agent.  The handle returned is used in all subsequent calls to the extensible agent. Note the subagent can open as many logical connections to the master agent as is needed.  For example, a subagent acting as a proxy to other subagents may wish to establish a logical connection for every subagent it is servicing. SnmpAgtClose typedef BOOL (CALLBACK * PFNSNMPAGTCLOSE)(     IN SNMP_HANDLE SubagentHandle,     IN DWORD       Status     ); Arguments: SubagentHandle - Handle returned in the SnmpAgtOpen upcall. Status - Reason that subagent closed logical connection to extensible agent. Return Status: Returns TRUE if successful. Routine Description: The subagent calls this routine in order to close a logical connection to the master agent. SnmpAgtRegister typedef BOOL (CALLBACK * PFNSNMPAGTREGISTER)(     IN SNMP_HANDLE   SubagentHandle,     IN PSNMP_CONTEXT pNamingContext,     IN PSNMP_CONTEXT pSearchContext,     IN PSNMP_OID     pRegionPrefix,     IN PSNMP_OID     pRegionPrefixLimit,     IN DWORD         Priority,     IN DWORD         Timeout     ); Arguments: SubagentHandle - Handle returned in the SnmpAgtOpen upcall. pNamingContext - Naming context in which the subagent wishs to register the MIB region.  A null value indicates the region should be registered under the extensible agent s default context. pSearchContext - Pointer to optional context supported by subagent used by the master agent to identify related regions that a subagent supports on the same logical connection.  The context will be passed back during subagent callbacks. pRegionPrefix - Object identifier describing the start of the MIB region being registered. pRegionPrefixLimit - Object identifier describing the end of the MIB region being registered.  This value is optional and used mainly to simplify the process of registering view ranges. Priority - A value between 1 and 255, used to achieve a desired configuration when different subagents register identical or overlapping regions.  Subagents with no particular knowledge of priority should register with the default value of `255' (lowest priority). In the master agent's dispatching algorithm, smaller values of priority take precedence over larger values. Timeout - The length of time, in seconds, that a master agent should  allow to elapse after dispatching a message to a subagent before it regards the subagent as not responding.  This timeout applies only to messages that concern MIB objects within the region above.  It overrides both the subagent-wide value (if any) indicated in the SnmpAgtOpen upcall and the master agent's default timeout.  The default value for the timeout is `0' (no override). Return Status: Returns TRUE if successful. Routine Description: The subagent calls this routine in order to notify the extensible agent that the subagent is ready to process manager requests for a particular MIB region. SnmpAgtUnregister typedef BOOL (CALLBACK * PFNSNMPAGTUNREGISTER)(     IN SNMP_HANDLE   SubagentHandle,     IN PSNMP_CONTEXT pNamingContext,     IN PSNMP_CONTEXT pSearchContext,     IN PSNMP_OID     pRegionPrefix,     IN PSNMP_OID     pRegionPrefixLimit     ); Arguments: SubagentHandle - Handle returned in the SnmpAgtOpen upcall. pNamingContext - Naming context in which the subagent wishs to remove the MIB region.  A null value indicates the region should be removed from the extensible agent s default context. pSearchContext - Pointer to context supported by subagent for searching MIB region. pRegionPrefix - Object identifier describing the start of the MIB region being registered. pRegionPrefixLimit - Object identifier describing the end of the MIB region being registered.  This value is optional and used mainly to simplify the process of registering view ranges. Return Status: Returns TRUE if successful. Routine Description: The subagent calls this routine in order to notify the extensible agent that it is unable to process manager requests for a particular MIB region any longer. SnmpAgtNotify typedef BOOL (CALLBACK * PFNSNMPAGTNOTIFY)(     IN SNMP_HANDLE       SubagentHandle,     IN PSNMP_CONTEXT     pNamingContext,     IN PSNMP_VARBINDLIST pVarBindList     ); Arguments: SubagentHandle - Handle returned in the SnmpAgtOpen upcall. pNamingContext - Naming context in which the subagent wishs to send the trap.  A null value indicates the trap should be sent from the extensible agent s default context. pVarBindList - List of variables to be included in the trap message.  If the subagent supplies sysUpTime.0, it must be present as the first varbind.  Note snmpTrapOID.0 must be present, as the second varbind if sysUpTime.0 was supplied, as the first if it was not. Return Status: Returns TRUE if successful. Routine Description: The subagent calls this routine in order to notify the extensible agent that it is needs to have a trap sent to all of the interested managers registered with the extensible agent. SnmpAgtReserveIndex typedef BOOL (CALLBACK * PFNSNMPAGTRESERVEINDEX)(     IN     SNMP_HANDLE       SubagentHandle,     IN     PSNMP_CONTEXT     pNamingContext,     IN OUT PSNMP_VARBINDLIST pVarBindList,     IN     DWORD             Options     ); Arguments: SubagentHandle - Handle returned in the SnmpAgtOpen upcall. pNamingContext - Naming context in which the subagent wishs to reserve index.  A null value indicates the index should be reserved in the extensible agent s default context. pVarBindList - List of variable names describing the indices the subagent wishes to have reserved. Options - Optional characteristics of reserved index: SNMP_FLAGS_ANY_INDEX - Indicates the master agent can return any index value. SNMP_FLAGS_NEW_INDEX - Indicates the master agent should generate the next available index value. Return Status: Returns TRUE if successful. Routine Description: The subagent calls this routine in order to request that the extensible agent set aside for specific set of indices. SnmpAgtUnreserveIndex typedef BOOL (CALLBACK * PFNSNMPAGTUNRESERVEINDEX)(     IN SNMP_HANDLE       SubagentHandle,     IN PSNMP_CONTEXT     pNamingContext,     IN PSNMP_VARBINDLIST pVarBindList     ); Arguments: SubagentHandle - Handle returned in the SnmpAgtOpen upcall. pNamingContext - Naming context in which the subagent wishs to unreserve index.  A null value indicates the index should be unreserved in the extensible agent s default context. pVarBindList - List of variable names describing the indices subagent wishes to have unreserved. Return Status: Returns TRUE if successful. Routine Description: The subagent calls this routine in order to request that the extensible agent release a specific set of reserved indices. SnmpAgtAddCaps typedef BOOL (CALLBACK * PFNSNMPAGTADDCAPS)(     IN     SNMP_HANDLE   SubagentHandle,     IN     PSNMP_CONTEXT pNamingContext,     IN     PSNMP_OID     pSubagentCapsId,     IN     PSNMP_OCTETS  pSubagentCapsDescr     ); Arguments: SubagentHandle - Handle returned in the SnmpAgtOpen upcall. pNamingContext - Naming context in which the subagent wishs to add agent caps.  A null value indicates the agent caps should be added in the extensible agent s default context. pSubagentCapsId - Unique identifier of subagent capabilities. pSubagentCapsDescr - String describing subagent capabilities. Return Status: Returns TRUE if successful. Routine Description: The subagent calls this routine in order to add a agent capabilities statement to that of the extensible agent. SnmpAgtRemoveCaps typedef BOOL (CALLBACK * PFNSNMPAGTREMOVECAPS)(     IN     SNMP_HANDLE   SubagentHandle,     IN     PSNMP_CONTEXT pNamingContext,     IN     PSNMP_OID     pSubagentCapsId     ); Arguments: SubagentHandle - Handle returned in the SnmpAgtOpen upcall. pNamingContext - Naming context in which the subagent wishs to add agent caps.  A null value indicates the agent caps should be added in the extensible agent s default context. pSubagentCapsId - Unique identifier of subagent capabilities. Return Status: Returns TRUE if successful. Routine Description: The subagent calls this routine in order to remove a agent capabilities statement to that of the extensible agent. Extension Procedure Table SnmpExtGet typedef BOOL (CALLBACK * PFNSNMPEXTGET)(     IN     PSNMP_CONTEXT     pSubagentContext,     IN     PSNMP_CONTEXT     pNamingContext,     IN     PSNMP_CONTEXT     pSearchContext,     IN OUT PSNMP_VARBINDLIST pVarBindList,        OUT PDWORD            pErrorStatus,        OUT PDWORD            pErrorIndex     ); Arguments: pSubagentContext - Pointer to subagent logical connection context. pNamingContext - Pointer to naming context in which request was receieved. pSearchContext - Pointer to search context used when resolving varbind. pVarBindList - List of variable-bindings in the above context which the subagent needs to resolve. pErrorStatus - Pointer to receive the error status of the subagent request. pErrorIndex - Pointer to receive the index of any errant variable-binding. Return Status: Returns TRUE if successful. Routine Description: The extensible agent calls this routine in order to resolve variable-bindings from a SNMP_PDU_GET request.. SnmpExtGetNext typedef BOOL (CALLBACK * PFNSNMPEXTGETNEXT)(     IN     PSNMP_CONTEXT         pSubagentContext,     IN     PSNMP_CONTEXT         pNamingContext,     IN     PSNMP_CONTEXT         pSearchContext,     IN OUT PSNMP_SEARCHRANGELIST pSearchRangeList,        OUT PDWORD                pErrorStatus,        OUT PDWORD                pErrorIndex     ); Arguments: pSubagentContext - Pointer to subagent logical connection context. pNamingContext - Pointer to naming context in which request was receieved. pSearchContext - Pointer to search context used when resolving varbind. pSearchRangeList - List of bounded variable-bindings which the subagent needs to resolve.  If no object can be resolved within the speficied range then SNMP_SYNTAX_ENDOFMIBVIEW    should be returned as the variable type. pErrorStatus - Pointer to receive the error status of the subagent request. pErrorIndex - Pointer to receive the index of any errant variable-binding. Return Status: Returns TRUE if successful. Routine Description: The extensible agent calls this routine in order to resolve variable-bindings from a SNMP_PDU_GETNEXT request. SnmpExtGetBulk typedef BOOL (CALLBACK * PFNSNMPEXTGETBULK)(     IN     PSNMP_CONTEXT         pSubagentContext,     IN     PSNMP_CONTEXT         pNamingContext,     IN     PSNMP_CONTEXT         pSearchContext,     IN     DWORD                 NonRepeaters,     IN     DWORD                 MaxRepetitions,     IN OUT PSNMP_SEARCHRANGELIST pSearchRangeList,        OUT PDWORD                pErrorStatus,        OUT PDWORD                pErrorIndex     ); Arguments: pSubagentContext - Pointer to subagent logical connection context. pNamingContext - Pointer to naming context in which request was receieved. pSearchContext - Pointer to search context used when resolving varbind. NonRepeaters - Number of variable-bindings at the beginning of the list which do not repeat.  . MaxRepetitions - Number of repetitions which should be performed on the rest of the bindings. pSearchRangeList - List of bounded variable-bindings which the subagent needs to resolve.  If no object can be resolved within the speficied range then SNMP_SYNTAX_ENDOFMIBVIEW    should be returned as the variable type. pErrorStatus - Pointer to receive the error status of the subagent request. pErrorIndex - Pointer to receive the index of any errant variable-binding. Return Status: Returns TRUE if successful. Routine Description: The extensible agent calls this routine in order to resolve variable-bindings from a SNMP_PDU_GETBULK request. SnmpExtTestSet typedef BOOL (CALLBACK * PFNSNMPEXTTESTSET)(     IN     PSNMP_CONTEXT     pSubagentContext,     IN     PSNMP_CONTEXT     pNamingContext,     IN     PSNMP_CONTEXT     pSearchContext,        OUT PSNMP_CONTEXT     pSetContext,     IN     PSNMP_VARBINDLIST pVarBindList,        OUT PDWORD            pErrorStatus,        OUT PDWORD            pErrorIndex     ); Arguments: pSubagentContext - Pointer to subagent logical connection context. pNamingContext - Pointer to naming context in which request was receieved. pSearchContext - Pointer to search context used when resolving varbind. pSetContext - Pointer to receive subagent-defined context to be passed back during the other stages of multi-phase write operation. pVarBindList - List of variable-bindings to be verified during this the first phase of a multi-phase write operation.  The subagent should do everything possible during this call to maximize the probability of the commit phase of the write opertation succeeding. pErrorStatus - Pointer to receive the error status of the subagent request. pErrorIndex - Pointer to receive the index of any errant variable-binding. Return Status: Returns TRUE if successful. Routine Description: The extensible agent calls this routine in order to verify the variable-bindings in a SNMP_PDU_SET request. SnmpExtCommitSet typedef BOOL (CALLBACK * PFNSNMPEXTCOMMITSET)(     IN     PSNMP_CONTEXT     pSubagentContext,     IN     PSNMP_CONTEXT     pNamingContext,     IN     PSNMP_CONTEXT     pSearchContext,     IN     PSNMP_CONTEXT     pSetContext,     IN     PSNMP_VARBINDLIST pVarBindList,        OUT PDWORD            pErrorStatus,        OUT PDWORD            pErrorIndex     ); Arguments: pSubagentContext - Pointer to subagent logical connection context. pNamingContext - Pointer to naming context in which request was receieved. pSearchContext - Pointer to search context used when resolving varbind. pSetContext - Pointer to context allocated in the SnmpExtTestSet callback. pVarBindList - List of variable-bindings to be committed during this the second phase of a multi-phase write operation.  The subagent should be prepared to rollback these changes if another subagent commit in the same manager request fails. pErrorStatus - Pointer to receive the error status of the subagent request. pErrorIndex - Pointer to receive the index of any errant variable-binding. Return Status: Returns TRUE if successful. Routine Description: The extensible agent calls this routine in order to commit the variable-bindings in a SNMP_PDU_SET request. SnmpExtUndoSet typedef BOOL (CALLBACK * PFNSNMPEXTUNDOSET)(     IN     PSNMP_CONTEXT     pSubagentContext,     IN     PSNMP_CONTEXT     pNamingContext,     IN     PSNMP_CONTEXT     pSearchContext,     IN     PSNMP_CONTEXT     pSetContext,     IN     PSNMP_VARBINDLIST pVarBindList,        OUT PDWORD            pErrorStatus,        OUT PDWORD            pErrorIndex     ); Arguments: pSubagentContext - Pointer to subagent logical connection context. pNamingContext - Pointer to naming context in which request was receieved. pSearchContext - Pointer to search context used when resolving varbind. pSetContext - Pointer to context allocated in the SnmpExtTestSet callback. pVarBindList - List of variable-bindings to be restored to their original state after one or more commits failed during a multi-phase write operation.  The subagent should be prepared to rollback changes if another subagent commit in the same manager request fails. pErrorStatus - Pointer to receive the error status of the subagent request. pErrorIndex - Pointer to receive the index of any errant variable-binding. Return Status: Returns TRUE if successful. Routine Description: The extensible agent calls this routine in order to rollback the changes from a SnmpExtCommit callback. SnmpExtCleanupSet typedef BOOL (CALLBACK * PFNSNMPEXTCLEANUPSET)(     IN     PSNMP_CONTEXT     pSubagentContext,     IN     PSNMP_CONTEXT     pNamingContext,     IN     PSNMP_CONTEXT     pSearchContext,     IN     PSNMP_CONTEXT     pSetContext,     IN     PSNMP_VARBINDLIST pVarBindList,        OUT PDWORD            pErrorStatus,        OUT PDWORD            pErrorIndex     ); Arguments: pSubagentContext - Pointer to subagent logical connection context. pNamingContext - Pointer to naming context in which request was receieved. pSearchContext - Pointer to search context used when resolving varbind. pSetContext - Pointer to context allocated in the SnmpExtTestSet callback. pVarBindList - List of variable-bindings to be set in a multi-phase write operation.   pErrorStatus - Pointer to receive the error status of the subagent request. pErrorIndex - Pointer to receive the index of any errant variable-binding. Return Status: Returns TRUE if successful. Routine Description: The extensible agent calls this routine in order to cleanup resources allocated by the subagent during a multi-phase write operation.  This routine is called whether the actual write succeeded or not. SnmpExtShutdown typedef BOOL (CALLBACK * PFNSNMPEXTSHUTDOWN)(     IN DWORD Status     ); Arguments: Status- Status of the extensible agent during the shutdown request.  This value can be used by the subagent to determine the reason the extensible agent is requesting a shutdown. Return Status: Returns TRUE if successful. Routine Description: The extensible agent calls this routine in order to notify the subagent that the agent is unloading or that the agent wishes the subagent to unload.  The subagent should perform any necessary cleanup before returning from this call. Subagent Framework As mentioned above, the goal of the subagent framework is to provide a mechanism by which protocol processing is centralized in a helper library so that subagent developers implementing MIBs can concentrate on instrumentation. Data Structures MIB_REGION typedef struct _MIB_REGION {     SNMP_OID     Prefix;     SNMP_OID     PrefixLimit;     PSNMP_OCTETS pNamingContext;     PMIB_OBJECT  pObjects;     DWORD        Priority;     DWORD        Timeout; } MIB_REGION, *PMIB_REGION; Members: Prefix - Object identifier describing the root of the subagent s supported MIB region. PrefixLimit - Object identifier describing the end of the subagent s supported MIB region.  This value is optional and used mainly to simplify the process of registering ranges. pNamingContext - Context in which the subagent wishs to add the supported MIB region specified above.  A null value indicates the MIB region should be added to the extensible agent s default context. pObjects - Pointer to the null-terminated list of objects in the supported MIB region.  Priority - A value between 1 and 255, used to achieve a desired configuration when different subagents register identical or overlapping regions.  Subagents with no particular knowledge of priority should register with the default value of `255' (lowest priority). In the master agent's dispatching algorithm, smaller values of priority take precedence over larger values. Timeout - The length of time, in seconds, that a master agent should  allow to elapse after dispatching a message to a subagent before it regards the subagent as not responding.  This timeout applies only to messages that concern MIB objects within the region above.  It overrides both the subagent-wide value (if any) and the master agent's default timeout.  The default value for the timeout is `0' (no override). MIB_OBJECT typedef struct _MIB_OBJECT {     SNMP_OID             Name;     BYTE                 Syntax;     BYTE                 Access;     WORD                 Flags;     PMIB_PROPERTY        pProperties;     struct _MIB_OBJECT * pTableEntry;     struct _MIB_OBJECT * pNextScalar;      MIB_INSTRUMENTATION  Instrumentation; } MIB_OBJECT, *PMIB_OBJECT; Members: Name - Object identifier relative to the prefix of the MIB region. Syntax - Type specifier defined in SMIv2 [6] or private SNMP_SYNTAX_AGGREGATE. Access - Maximum level of access to the object defined to be one of the following: MIB_ACCESS_NONE - Indicates this object cannot be read or written. MIB_ACCESS_NOTIFY - Indicates this object cannot be read or written but can be used in a notification message sent from the master agent. MIB_ACCESS_READ_ONLY - Indicates this object can be read but not written. MIB_ACCESS_READ_WRITE - Indicates this object can be read and written. MIB_ACCESS_READ_CREATE - Indicates this object can be read and written and new instances of the object can be created. Flags - Any one of the following: MIB_FLAGS_TABLE_INDEX - Indicates this is a columnar object that forms part of a table s instance identifier. MIB_FLAGS_LENGTH_IMPLIED - Indicates this is a columnar object that forms the last part of a table s instance identifier and it s length is equal to the remainder of the object identifier. MIB_FLAGS_SIZE_RESTRICTED - Indicates this object is restricted by size and that a MIB_RANGE structure is included in the property list describing this restriction. MIB_FLAGS_RANGE_RESTRICTED - Indicates this object is restricted by one or more ranges and that one or more MIB_RANGE structures are included in the property list.  Enumerations are treated as range restrictions. MIB_FLAGS_DEFAULT_INCLUDED - Indicates this object has a default value and that a SNMP_VALUE structure is included in the property list. MIB_FLAGS_WRITE_REDIRECTED - Indicates that this object is instrumented differently for write operations and that a MIB_INSTRUMENTATION structure is included in the property list. pProperties - Pointer to a list detailing the object s properties. pTableEntry - Pointer to parent object containing table properties if this object is columnar. pNextScalar - Pointer to next scalar object following this one in the name space. Instrumentation - Details about the object s instrumentation information. MIB_PROPERTY typedef struct _MIB_PROPERTY {     DWORD                  Type;     PVOID                  pValue;     struct _MIB_PROPERTY * pNextValue;     struct _MIB_PROPERTY * pNextProperty; } MIB_PROPERTY, *PMIB_PROPERTY; Members: Type - Type of property described by the pointer below. MIB_PROPERTY_TABLE - Indicates that pValue points to a MIB_TABLE structure describing a conceptual table.  MIB_PROPERTY_RANGE - Indicates that pValue points to a MIB_RANGE structure describing one or more ranges restrictions. MIB_PROPERTY_DEFAULT_VALUE - Indicates that pValue points to an SNMP_VALUE structure describing the object s default value. MIB_PROPERTY_INSTRUMENTATION - Indicates that pValue points to an MIB_INSTRUMENTATION structure used for write operations. pValue - Opaque pointer to one of the properties defined above. pNextValue - Pointer to next property value in value list. pNextProperty - Pointer to next property in property list. MIB_TABLE typedef struct _MIB_TABLE {     DWORD         NumberOfColumns;     DWORD         NumberOfIndices;     PMIB_OBJECT   pColumns;     PMIB_OBJECT * ppIndices; } MIB_TABLE, *PMIB_TABLE; Members: NumberOfColumns - Number of columnar objects in conceptual table. NumberOfIndices - Number of columnar objects comprising table index. pColumns - Pointer to first columnar object in the conceptual table. ppIndices - Pointer to list of object pointers describing the index of a conceptual table.  This value can be null indicating the table indices are contiguous entries starting from pColumns. MIB_RANGE typedef struct _MIB_RANGE {     DWORD LowerLimit;     DWORD UpperLimit; } MIB_RANGE, *PMIB_RANGE; Members: LowerLimit - lower limit of range, enumeration, or size restriction. UpperLimit - upper limit of range, enumeration, or size restriction. MIB_INSTRUMENTATION typedef struct _MIB_INSTRUMENTATION {     WORD            BufferOffset;     WORD            BufferLength;     PFNMIB_CALLBACK pfnCallback; } MIB_INSTRUMENTATION, *PMIB_INSTRUMENTATION; Members: BufferOffset - Entry s offset into instrumentaion buffer. BufferLength - Total length of the instrumentation buffer. pfnCallback - Address of entry s instrumentation routine. MIB_REQUEST typedef struct _MIB_REQUEST {     DWORD         ActionId;       DWORD         RequestId;         PSNMP_VALUE   pObjectArray;     PSNMP_CONTEXT pNamingContext;     DWORD         ErrorStatus;     DWORD         ErrorIndex; } MIB_REQUEST, *PMIB_REQUEST; Members: ActionId - identifies the specific action requested of the subagent: MIB_ACTION_GET - Indicates that the subagent should read the specified values into the instrumentation buffer. MIB_ACTION_GETNEXT - Indicates that the subagent should read the lexographic successor of the specified values into the instrumentation buffer. MIB_ACTION_TEST - Indicates that the subagent should verify the specified values in the instrumentation buffer can be successfully set. MIB_ACTION_COMMIT - Indicates that the subagent should write out the specified values in the instrumentation buffer. MIB_ACTION_UNDO - Indicates that the subagent should attempt to rollback changes just committed. MIB_ACTION_CLEANUP - Indicates that the subagent should clean up any resources allocated to service a particular request. RequestId - Identifies PDU for which action is being taken. pObjectArray - Array of object associated with instrumentation buffer. pNamingContext - Naming context in which request is being made. ErrorStatus - One of the SNMP error codes specified in [6]. ErrorIndex - Index into the pObjectArray of any errant variable. Instrumentation Callbacks MIB_CALLBACK typedef DWORD (CALLBACK * PFNMIB_CALLBACK)(     PMIB_REQUEST pRequest     ); Arguments: pRequest - Subagent command block (described above). Return Status: Any Win32 error but the following have special meaning: MIB_S_SUCCESS - Indicates the subagent successfully processed the specified action. MIB_S_NOT_SUPPORTED - Indicates the subagent does not support specified action. MIB_S_NO_MORE_ENTRIES - Indicates the end of a MIB table was encountered. MIB_S_ENTRY_NOT_FOUND - Indicates a MIB object instance could not be located. MIB_S_INVALID_PARAMETER - Indicates one of the parameters was invalid. Routine Description: Each instrumentation callback has a buffer associated with it.  At the beginning of each buffer is an array of SNMP_VALUE structures representing the components of the group or table supplied by that callback.  The code generation utility creates this structure based on the supplied MIB module but the subagent developer can rearrange or add new callbacks as needed.  Subagent developers can also append context information to the end of the buffer.   A description of each action follows below but the basic idea is that the subagent will fill in the asnValue element of each flagged SNMP_VALUE structure for GET requests, write out the asnValue of each flagged SNMP_VALUE structure for SET requests and so on.  The return code of the callback is used to notify the extensible agent that the action was processed successfully not necessary that the action succeeded.  This means that the ErrorStatus field of the MIB_ACTION structure is ignored by the agent when the return code is not equal to MIB_S_SUCCESS.   MIB_ACTION_GET The extensible agent will call a subagent s instrumentation callback with MIB_ACTION_GET when one or more variables in an incoming GET PDU contain an OID which matchs that of any MIB_OBJECT associated with the callback.  All of the variables in the GET PDU that are associated with the callback are queried simultaneously and requested items in the SNMP_VALUE array are flagged by having a non-zero asnType. The SNMP_VALUE structures which are part of a conceptual table s index are filled in before the callback is entered with any values specified in the incoming request.  The subagent should read this values directly from the ObjectArray. MIB_ACTION_GETNEXT The extensible agent will call a subagent s callback with the action MIB_ACTION_GETNEXT when one or more variables in an incoming GETNEXT PDU immediately precede the OID of a MIB_OBJECT that is associated with the callback and is the entry represents a columnar object. The subagent should expect that the SNMP_VALUE structures which are part of a conceptual table s index will contain the values corresponding to the row in the table immediately preceeding the one of interest.  Besides filling the asnValue of each of the elements of the SNMP_VALUE array which are flagged with a non-zero asnType, all of the index values must be updated with values that correspond to the row of interest.  MIB_ACTION_TEST The extensible agent will call a subagent s callback with the action MIB_ACTION_TEST when one or more variables in the incoming SET PDU contain an OID which matchs that of any MIB_OBJECT associated with the callback.  A subagent s callback is called multiple times with the normal processing being TEST, COMMIT, and CLEANUP in that order.  An UNDO action is specified when a rollback of the commited values is being requested.  All of the variables in the PDU that are associated with a given callback are set simultaneously.  As in MIB_ACTION_GET, requested elements of the SNMP_VALUE array are flagged by having a non-zero asnType.  The subagent should validate that all supplied values are acceptable and that any non-supplied variables can be ignored or default values for them are available.  This same ObjectArray will be passed back during the MIB_ACTION_COMMIT and the MIB_ACTION_CLEANUP call so context information can be allocated and stored at the end of the instrumentation buffer. MIB_ACTION_COMMIT The extensible agent will call a subagent s instrumentation callback with the action MIB_ACTION_COMMIT when all of the subagents involved in the original SET PDU request have successfully validated their individual requests.   MIB_ACTION_UNDO The extensible agent will call a subagent s instrumentaion callback with MIB_ACTION_UNDO when a COMMIT request has failed and the original state of the subagent must be restored. MIB_ACTION_CLEANUP The extensible agent will call a subagent s instrumentation callback with the action MIB_ACTION_CLEANUP when after each COMMIT request has failed or succeeded. Framework Entry Points The following are functions to initialize the subagent framework and leverage it using older NT extensible agents. SnmpSfxOpen SNMP_HANDLE SnmpSfxOpen(     IN     PSNMP_AGENTPROCTABLE     pAgentProcTable,        OUT PSNMP_EXTENSIONPROCTABLE pExtensionProcTable     ); Arguments: pAgentProcTable - Pointer to agent s procedure table. pExtensionProcTable - Pointer to receive subagent s procedure table. Return Status: Returns a handle to the subagent framework. Routine Description: The subagent uses this routine to obtain a handle to the subagent framework.  If the subagent is being loaded from a NT 5.0 extensible agent then this routine would be called during SnmpExtensionStartup and the extensible agent s procedure table would be passed along to the subagent framework. If the subagent is being loaded from a downlevel extensible agent then this routine would be called during SnmpExtensionInit and null would be specified for the agent s procedure table.   SnmpSfxClose DWORD SnmpSfxClose(     SNMP_HANDLE SfxHandle     ); Arguments: SfxHandle - Handle to subagent framework. Return Status: Returns NO_ERROR if successful. Routine Description: The subagent uses this routine to release a handle to the subagent framework obtained via SnmpSfxOpen.  SnmpSfxRegister DWORD SnmpSfxRegister(     SNMP_HANDLE SfxHandle,     PMIB_REGION pSupportedRegion     ); Arguments: SfxHandle - Handle to subagent framework. pSupportedRegion - Subagent supported MIB region to be registered with subagent framework. Return Status: Returns NO_ERROR if successful. Routine Description: The subagent uses this routine to register a supported MIB region with the subagent framework.  SnmpSfxUnregister DWORD SnmpSfxUnregister(     SNMP_HANDLE SfxHandle,     PMIB_REGION pSupportedRegion     ); Arguments: SfxHandle - Handle to subagent framework. pSupportedRegion - Subagent supported MIB region to be unregistered with subagent framework. Return Status: Returns NO_ERROR if successful. Routine Description: The subagent uses this routine to unregister a supported MIB region with the subagent framework. SnmpSfxResolveVarBinds DWORD SnmpSfxResolveVarBinds(     SNMP_HANDLE        SfxHandle,     BYTE               RequestType,     PSNMP_VARBINDLIST  pVarBindList,     PDWORD             pErrorStatus,     PDWORD             pErrorIndex     ); Arguments: SfxHandle - Handle to subagent framework. RequestType - Type of SNMP request (only supports GET, GETNEXT, or SET). pVarBindList - Pointer to variable bindings to be resolved by the subagent framework. pErrorStatus - Pointer to receive the error status of the subagent request. pErrorIndex - Pointer to receive the index of any errant variable-binding. Return Status: Returns NO_ERROR if successful. Routine Description: The subagent uses this forward a downlevel query to the subagent framework. Subagent Code Generator By gathering all of the common functionality into a subagent framework, developers are shielded from the details of the SNMP protocol.  Similarly, by producing a subagent code generator which takes a MIB and outputs the data structures and related functions needed by the framework then the developers are shielded from the details on the framework itself and can concentrate on the task of implementing the instrumentation code.  Windows NT 5.0 will include a utility which takes MOSY output and converts it into code for use with the framework mentioned above. Data Structures The data structures for the code generator are similar to the ones described above but also include naming information not needed by the subagent framework. MIB_ENTRY typedef struct _MIB_ENTRY {     PSTR                   Name;     PSTR                   Definition;     PSTR                   Identifier;     BYTE                   Syntax;     BYTE                   Access;     WORD                   Flags;     struct _MIB_ENTRY *    pParent;     struct _MIB_ENTRY *    pChildren;     struct _MIB_ENTRY *    pSiblings;     struct _MIB_MODIFIER * pModifiers; } MIB_ENTRY, *PMIB_ENTRY; Members: Name - Relative name of the object (e.g.,  sysDescr Definition - Description in terms of known objects though normally parent (e.g.,  system 1 Identifier - Object identifier relative to  internet  (e.g.,  mgmt.mib-2.system.sysDescr Syntax - Type identifier (same as MIB_OBJECT). Access - Maximum level of access (same as MIB_OBJECT). Flags - Optional characteristics of object.  None currently defined. pParent - Pointer to the object s parent.  pChildren - Pointer to a list of the object s children.  pSiblings - Pointer to a list of the object s siblings.  pModifiers - Pointer to a list of structures detailing the properties of the object. Building Symbol Table The code generation utility relies on the MOSY compiler to perform syntax checking and to convert the MIB into an easy-to-parse format. Each line in the MOSY output file is either an object definition or an object modifier.  If the code generator encounters an object definition then the name is added to the symbol table and the related MIB_ENTRY structure is filled in.  If an object modifier is encountered then the associated symbol is looked up via a hash table and a MIB_MODIFIER structure is added to the object s MIB_ENTRY structure.  Once all of the symbols have been added to the table, the object lineage is resolved by walking the symbol table and recursing through the object definitions.  Once all of the object identifiers have been qualified up to a point ( iso.org.dod.internet ) then the information is ready to be handed over to the code generation routines. SnmpSfxLoadMibEntries DWORD SnmpSfxLoadMibEntries(     IN    PSTR         pDefsFile,       OUT PMIB_ENTRY * ppEntries     ); Arguments: pDefsFile - Name of file containing mib entries. ppEntries - Pointer to receive pointer to tree of mib entries. Return Status: Returns NO_ERROR if successful. Routine Description: This routine is used to load mib objects from a .defs file. SnmpSfxFreeMibEntries DWORD SnmpSfxFreeMibEntries(     PMIB_ENTRY pEntries     ); Arguments: pEntries - Pointer to tree of mib entries. Return Status: Returns NO_ERROR if successful. Routine Description: This routine simply deallocates the memory allocated by SnmpSfxLoadMibEntries. Generating Subagent Code The five pieces of the subagent framework that need to be generated are the MIB entry data file, the MIB entry header file, the instrumentation callback header file, the instrumentation callback skeleton code file, and the subagent entry point file (with optional downlevel support). Generating MIB Objects Data File The MIB object data file contains all of the static structures describing the subagent s view.  The first component written to disk are the integer arrays which form the basis of the OIDs.  All of the MIB_OBJECT structures and objects are written to the file as: static DWORD <table1>IDS = {1}; static DWORD <entry1>IDS = {1,1}; static DWORD <scalar1>IDS = {1,1,1}; static DWORD <scalar2>IDS = {1,1,2}; For any object with properties, a property list is then written immediately below: static MIB_PROPERTY <entry1>PROP1 = {  static MIB_PROPERTY <scalar2>PROP1 = {  The MIB object array is then generated:   MIB_OBJECT <module>OBJS[] = {     {         DEFINE_OID(<table1>IDS),         SNMP_SYNTAX_AGGREGATE,         MIB_ACCESS_NONE,         0,         NULL,         NULL,         &<module>OBJS[<scalar1>INDEX],         DEFINE_NO_INSTR()     },     {         DEFINE_OID(<entry1>IDS),         SNMP_SYNTAX_AGGREGATE,         MIB_ACCESS_NONE,         0,         &<entry1>PROP1,         &<module>OBJS[<table1>INDEX],         &<module>OBJS[<scalar1>INDEX],         DEFINE_NO_INSTR()     },     {         DEFINE_OID(<scalar1>IDS),         SNMP_SYNTAX_INT32,         MIB_ACCESS_READ_ONLY,         MIB_FLAGS_TABLE_INDEX,         NULL,         &<module>OBJS[<entry1>INDEX],         &<module>OBJS[<scalar2>INDEX],         DEFINE_INSTR(<scalar1>,<entry1>DATA,<entry1>PROC)     },     {         DEFINE_OID(<scalar2>IDS),         SNMP_SYNTAX_INT32,         MIB_ACCESS_READ_ONLY,         MIB_FLAGS_TABLE_INDEX,         &<scalar2>PROPS,         &<module>OBJS[<entry1>INDEX],         NULL,         DEFINE_INSTR(<scalar2>,<entry1>DATA,<entry1>PROC)     } Finally, all of the elements are brought together to form the view structure. MIB_VIEW <module>VIEW = DEFINE_VIEW(<module>IDS,<module>OBJS); Generating MIB Objects Header File The MIB object header file contains the indices of the OBJS array.   #define <table1>INDEX #define <entry1>INDEX  <table1>INDEX+1 #define <scalar1>INDEX <entry1>INDEX+1 #define <scalar2>INDEX <scalar1>INDEX+1 Generating Instrumentation Header File The instrumentation header file contains all of the prototypes for the subagent callbacks as well as the type definitions for their respective data buffers.  Each group or table has a callback. typedef struct {     SNMP_VALUE <scalar1>;     SNMP_VALUE <scalar2>; } <entry1>DATA; DWORD  CALLBACK <entry1>PROC(     PMIB_ACTION pAction     ); Generating Instrumentation Skeleton Code The skeleton code is then just a matter of copying the prototypes into a file. DWORD  CALLBACK <entry1>PROC(       PMIB_ACTION pAction     )     return MIB_S_UNSUPPORTED; Extensible Agent In order be compatible with AgentX functionality, the NT 5.0 extensible agent will be modified to support subagent requests via a callback procedure table which can be invoked after initialization to perform such tasks as dynamically adding or removing supported views, reserving table indices, etc. (see next section). Depending upon the progress of the IETF Agent Extensibility working group, support for the AgentX protocol itself may or may not be included in this release.  The NT 5.0 extensible agent will be modified to be bilingual supporting both SNMPv1 and SNMPv2c including support for the SNMPv2 MIB (which includes the MIB-II system group).  Heap validation will be added to the initialization code to protect against any ill-behaved downlevel subagents.  SNMPv2c Support Agent support of SNMPv2c consists mainly of handling: new PDUs (GetBulkRequest-PDU, SNMPv2-Trap-PDU) new simple object types (BITS) new application object types (Integer32, Uinteger32, Counter32, Gauge32, Counter64) new object type extensions (UNITS, MAX-ACCESS, IMPLIED, AUGMENTS) new error codes (noAccess,  wrongType, wrongLength, wrongEncoding, wrongValue, noCreation, inconsistentValue, resourceUnavailable, commitFailed, undoFailed, authorizationError, notWritable, inconsistentName) subagent registration of sysORID for sysORTable.  Downlevel Subagent Heap Validation The Windows NT 3.1 and 3.5 subagent interface required developers to allocate memory via malloc() and release dynamically-allocated memory via free().  This proved to be a poor decision because it was based on the assumption that the runtime each subagent used resolved to the same system heap.  In Windows NT 3.51, it was decided to use GlobalAlloc()/GlobalFree() instead but many subagent developers were using old SDKs with the malloc()/free() macros causing the NT agent to appear to be quite unstable when mismatching heaps were encountered during a request.   In Windows NT 4.0, these macros were eliminated and a subagent utility DLL was introduced with an memory allocation API (SnmpUtilMemAlloc()/SnmpUtilMemFree()) which map directly to GlobalAlloc()/GlobalFree().  It is important that the Windows NT 5.0 agent be protected from earlier agents using bogus memory allocation schemes.  Since it is the subagent s responsibility to pass back a dynamically allocated variable-binding name when the original does not match the value being returned, the following scheme is to be deployed to detect ill-behaved subagents: allocate test variable-binding with OID 0.0 and type ASN_NULL. pass variable-binding into downlevel subagent s SnmpExtensionQuery entry point with the PDU request type of GETNEXT. downlevel subagent returns the first object in that particular MIB view and in doing so should dynamically allocate new OID via some memory allocation routine and free our dynamically allocated OID via some memory deallocation routine. if an exception is raised when the subagent attempts to release the OID 0.0 then the view is ignored and the subagent DLL is unloaded. if the subagent successfully passes back an OID then it is passed to HeapValidate() along with the handle of the process heap.   the subagent DLL is allowed to remain loaded only if this function returns success Registry Settings The Windows NT 5.0 extensible agent must be much more configurable than it s predessors and updates to the registry should be immediately reflected in the service.  The following are the new registry settings for the SNMP service (HKLM\System\CurrentControlSet\Services\SNMP).  All are values under the Parameters key except ExtensionAgents which is a separate subkey. ExtensionAgents For downlevel compatibility, this registry subkey has not changed.  As in previous versions of NT, this subkey consists of a monotonically increasing list of integer values which serve as an index into the table of registered subagents.  Each subagent registers a separate registry subkey under the next available integer value and this serves as an indirection to the subagent specific data such as DLL path etc.  The following is an example:   Key Name: SYSTEM\CurrentControlSet\Services\SNMP\Parameters\ExtensionAgents Value Name: 1       Type: REG_SZ       Data: SOFTWARE\Microsoft\LANManagerMIB2Agent\CurrentVersion Value Name: 2       Type: REG_SZ       Data: SOFTWARE\Microsoft\RFC1156Agent\CurrentVersion The subagent registry key would then look like:   Key Name: SOFTWARE\Microsoft\RFC1156Agent\CurrentVersion Value Name: Pathname       Type: REG_EXPAND_SZ       Data: %SystemRoot%\System32\inetmib1.dll where Pathname is the path of the subagent DLL.  Note this is the only subagent specific value that developers need to specify here.  Other optional settings may be added in the future but no changes will be made that inhibit compatibility with downlevel extensible agents. TrapDestinations This value contains a list of managers who wish to receive traps from the extensible agent.  Each trap destination entry also specifies the community string to place in the outgoing trap PDU.  The manager data string can be a host name, an IP address, or an IPX address.  In Windows NT 5.0, the trap destination list will look like the following:    Key Name: SYSTEM\CurrentControlSet\Services\SNMP\Parameters Value Name: TrapDestinations       Type: REG_MULTI_SZ       Data: manager1             community1             manager2             community2             manager3             community3 PermittedManagers This value contains a list of managers who have permission to send requests to the extensible agent. This value replaces the PermittedManagers registry subkey.   Key Name: SYSTEM\CurrentControlSet\Services\SNMP\Parameters Value Name: PermittedManagers       Type: REG_MULTI_SZ       Data: manager1             manager2             manager3 ReadWriteCommunities This value contains a list of communities which have read-write access to the extensible agent s managed objects.  This value replaces the ValidCommunities registry subkey.   Key Name: SYSTEM\CurrentControlSet\Services\SNMP\Parameters Value Name: ReadWriteCommunities       Type: REG_MULTI_SZ       Data: community1             community2             community3 ReadOnlyCommunities This value contains a list of communities which have read-only access to the extensible agent s managed objects.  This value is new for Windows NT 5.0.   Key Name: SYSTEM\CurrentControlSet\Services\SNMP\Parameters Value Name: ReadOnlyCommunities       Type: REG_MULTI_SZ       Data: community1             community2             community3 EnableAuthenticationTraps This boolean specifies whether or not authentication traps should be sent if an invalid community is encountered in an incoming PDU. This value replaces the EnableAuthenticationTraps registry subkey.   Key Name: SYSTEM\CurrentControlSet\Services\SNMP\Parameters Value Name: EnableAuthenticationTraps       Type: REG_DWORD       Data: 0x1 AuditingFlags The value specifies the auditing level desired.  The following options are available: #define SNMP_AUDIT_NONE          (0x00000000L) #define SNMP_AUDIT_WRITE_SUCCESS (0x00000001L) #define SNMP_AUDIT_WRITE_FAILURE (0x00000002L) #define SNMP_AUDIT_READ_SUCCESS  (0x00000004L) #define SNMP_AUDIT_READ_FAILURE  (0x00000008L) This value is new for Windows NT 5.0.   Key Name: SYSTEM\CurrentControlSet\Services\SNMP\Parameters Value Name: AuditingFlags       Type: REG_DWORD       Data: 0x1 LogLevel This value specifies the logging level desired.  The following levels are available: #define SNMP_LOGLEVEL_SILENT  (0x00000000L) #define SNMP_LOGLEVEL_FATAL   (0x00000001L) #define SNMP_LOGLEVEL_ERROR   (0x00000002L) #define SNMP_LOGLEVEL_WARNING (0x00000003L) #define SNMP_LOGLEVEL_TRACE   (0x00000004L) #define SNMP_LOGLEVEL_VERBOSE (0x00000005L) This value is new for Windows NT 5.0.   Key Name: SYSTEM\CurrentControlSet\Services\SNMP\Parameters Value Name: LogLevel       Type: REG_DWORD       Data: 0x1 LogType This value specifies the type of log desired.  The following types are available: #define SNMP_LOGTYPE_CONSOLE   (0x00000001L) #define SNMP_LOGTYPE_LOGFILE   (0x00000002L) #define SNMP_LOGTYPE_EVENTLOG  (0x00000004L) #define SNMP_LOGTYPE_DEBUGGER  (0x00000008L) This value is new for Windows NT 5.0.   Key Name: SYSTEM\CurrentControlSet\Services\SNMP\Parameters Value Name: LogType       Type: REG_DWORD       Data: 0x1 SystemName  This value contains the admin-assigned name of the host on which the extensible agent resides and is returned by the extensible agent as mib-2.system.sysName.   This value replaces the value SYSTEM\CurrentControlSet\Services\SNMP\Parameters\RFC1156Agent\sysName.   Key Name: SYSTEM\CurrentControlSet\Services\SNMP\Parameters Value Name: SystemName       Type: REG_SZ       Data: HOST1 SystemContact This value contains the name of the contact person for the host on which the extensible agent resides and is returned by the extensible agent as mib-2.system.sysContact.   This value replaces the value SYSTEM\CurrentControlSet\Services\SNMP\Parameters\RFC1156Agent\sysContact.   Key Name: SYSTEM\CurrentControlSet\Services\SNMP\Parameters Value Name: SystemContact       Type: REG_SZ       Data: ADMIN1 SystemLocation This value contains the location of the host on which the extensible agent resides and is returned by the extensible agent as mib-2.system.sysLocation.   This value replaces the value SYSTEM\CurrentControlSet\Services\SNMP\Parameters\RFC1156Agent\sysLocation.   Key Name: SYSTEM\CurrentControlSet\Services\SNMP\Parameters Value Name: SystemLocation       Type: REG_SZ       Data: LOCATION1 SystemServices This value indicates the set of services that the host primarily offers and is returned by the extensible agent as mib-2.system.sysServices.  The defined services are described in [4].   This replaces SYSTEM\CurrentControlSet\Services\SNMP\Parameters\RFC1156Agent\sysServices.   Key Name: SYSTEM\CurrentControlSet\Services\SNMP\Parameters Value Name: SystemServices       Type: REG_DWORD       Data: 0x4c References [1]  Rose, M., and K. McCloghrie, "Structure and Identification of      Management Information for TCP/IP-based internets", STD 16, RFC      1155, May 1990. [2]  Case, J., Fedor, M., Schoffstall, M., Davin, J., "Simple Network      Management Protocol", STD 15, RFC 1157, SNMP Research, Performance      Systems International, MIT Laboratory for Computer Science, May      1990. [3]  Rose, M., and K. McCloghrie, "Concise MIB Definitions", STD 16,      RFC 1212, March 1991. [4] Rose M., Editor, "Management Information Base for Network        Management of TCP/IP-based internets: MIB-II", RFC 1213,        Performance Systems International, March 1991. [5]  SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and      S. Waldbusser, " Introduction to Community-based SNMPv2", RFC 1901,      January 1996. [6]  SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and      S. Waldbusser, "Structure of Management Information for Version 2      of the Simple Network Management Protocol (SNMPv2)", RFC 1902,      January 1996. [7]  SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and      S. Waldbusser, "Textual Conventions for Version 2 of the Simple      Network Management Protocol (SNMPv2)", RFC 1903, January 1996. [8]  SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and      S. Waldbusser, "Conformance Statements for Version 2 of the Simple      Network Management Protocol (SNMPv2)", RFC 1904, January 1996. [9]  SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and      S. Waldbusser, "Protocol Operations for Version 2 of the Simple      Network Management Protocol (SNMPv2)", RFC 1905, January 1996. [10]  SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and      S. Waldbusser, "Transport Mappings for Version 2 of the Simple      Network Management Protocol (SNMPv2)", RFC 1906, January 1996. [11]  SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and      S. Waldbusser, "Management Information Base for Version 2 of the      Simple Network Management Protocol (SNMPv2)", RFC 1907,      January 1996. [12]  SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and      S. Waldbusser, "Coexistence between Version 1 and Version 2      of the Internet-standard Network Management Framework", RFC 1908,      January 1996. PAGE   PAGE   <111896808PM55555567777777788889999101010101111121313131414151515161617171819191919202121212222232323232424242424242525252626262627272728282929292929303030313131313132323232333333331 Normal Heading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Heading 7 Heading 8 Heading 9 Default Paragraph Font Body Sub Normal Indent Annotation Reference Annotation Text TOC 8 TOC 1 TOC 7 TOC 6 TOC 5 TOC 4 TOC 3 TOC 2 Index 7 Index 1 Index 6 Index 5 Index 4 Index 3 Index 2 Line Number Index Heading Footer Header Footnote Reference Footnote Text Code Example Endnote Reference TOC 9 Page Number Abstract Body Sub Sub Sub Body Sub Sub Title Body Sub-Hang Annotation Table Entry Table Label Table Head Annotation Box Byline Illustration Table Entry - Small @@@@@@ Table Head - Small @@@@@@ Figure Caption Table Label - Small Pseudocode Title Large Title Medium Title Small Time Stamp Body Sub Sub-Hang Table Lable Term Definition Picture Paragraph Table Lable -Small Method Clause Method Heading @B @B!@B Annotation Public body sib-hang ProjectName DesignTeam Version Distribution _Toc365228822 _Toc372981953 _Toc365228823 _Toc372981954 _Toc365228824 _Toc372981955 _Toc365228825 _Toc372981956 _Toc372981957 _Toc365228826 _Toc372981958 _Toc365228827 _Toc372981959 _Toc365228828 _Toc372981960 _Toc365228829 _Toc372981961 _Toc365228830 _Toc372981962 _Toc365228831 _Toc372981963 _Toc365228832 _Toc372981964 _Toc365228833 _Toc372981965 _Toc365228834 _Toc372981966 _Toc365228835 _Toc372981967 _Toc365228836 _Toc372981968 _Toc365228837 _Toc372981969 _Toc365228838 _Toc372981970 _Toc365228839 _Toc372981971 _Toc365228871 _Toc372981972 _Toc363359632 _Toc365228889 _Toc372981973 _Toc372981974 _Toc372981975 _Toc372981976 _Toc372981977 _Toc372981978 _Toc372981979 _Toc372981980 _Toc372981981 _Toc372981982 _Toc372981983 _Toc372981984 _Toc372981985 _Toc372981986 _Toc372981987 _Toc372981988 _Toc372981989 _Toc372981990 _Toc372981991 _Toc372981992 _Toc372981993 _Toc372981994 _Toc372981995 _Toc372981996 _Toc372981997 _Toc363359614 _Toc365228872 _Toc372981998 _Toc363359615 _Toc365228873 _Toc363359592 _Toc365228859 _Toc372981999 _Toc372982000 _Toc363359596 _Toc365228863 _Toc372982001 _Toc363359599 _Toc365228865 _Toc372982002 _Toc363359600 _Toc372982003 _Toc363359601 _Toc372982004 _Toc372982005 _Toc363359616 _Toc365228874 _Toc372982006 _Toc363359617 _Toc365228875 _Toc372982007 _Toc363359618 _Toc365228876 _Toc372982008 _Toc363359619 _Toc365228877 _Toc372982009 _Toc363359620 _Toc365228878 _Toc372982010 _Toc363359621 _Toc365228879 _Toc372982011 _Toc363359622 _Toc365228880 _Toc372982012 _Toc363359623 _Toc365228881 _Toc372982013 _Toc363359631 _Toc365228888 _Toc363359625 _Toc365228882 _Toc372982014 _Toc363359626 _Toc365228883 _Toc372982015 _Toc365228884 _Toc372982016 _Toc365228885 _Toc372982017 _Toc363359627 _Toc365228886 _Toc372982018 _Toc363359628 _Toc365228887 _Toc372982019 _Toc365228899 _Toc372982020 _Toc363301703 _Toc365228901 _Toc372982021 _Toc372982022 _Toc363301708 _Toc365228903 _Toc372982023 _Toc363301709 _Toc365228904 _Toc372982024 _Toc363301710 _Toc365228905 _Toc372982025 _Toc363301711 _Toc365228906 _Toc372982026 _Toc363301712 _Toc365228907 _Toc372982027 _Toc363301713 _Toc365228908 _Toc372982028 _Toc363301714 _Toc365228909 _Toc372982029 _Toc363301715 _Toc365228910 _Toc372982030 _Toc365228912 _Toc365228840 _Toc372982031 _Toc365228841 _Toc372982032 _Toc365228842 _Toc372982033 _Toc365228843 _Toc372982034 _Toc365228844 _Toc372982035 _Toc365228845 _Toc372982036 _Toc365228846 _Toc372982037 _Toc365228847 _Toc372982038 _Toc365228848 _Toc372982039 _Toc365228849 _Toc372982040 _Toc365228850 _Toc372982041 _Toc365228851 _Toc372982042 _Toc365228852 _Toc372982043 _Toc365228853 _Toc372982044 _Toc365228854 _Toc372982045 _Toc365228855 _Toc372982046 _Toc365228856 _Toc372982047 _Toc372982048 _Toc359045497 Don Ryan C:\TEMP\snmpdocs\snmp.doc Don Ryan C:\TEMP\snmpdocs\snmp.doc Don Ryan C:\TEMP\snmpdocs\snmp.doc Don Ryan C:\TEMP\snmpdocs\snmp.doc Don Ryan C:\TEMP\snmpdocs\snmp.doc Don Ryan C:\TEMP\snmpdocs\snmp.doc Don Ryan C:\TEMP\snmpdocs\snmp.doc Don Ryan C:\TEMP\snmpdocs\snmp.doc Don Ryan$C:\nt\private\net\snmp\docs\snmp.doc Don Ryan$C:\nt\private\net\snmp\docs\snmp.doc @\\MSPRINT44\26S/1MC CORPV 157.55.80.239 Ne01: winspool \\MSPRINT44\26S/1MC CORPV 157.55.80.239 \\MSPRINT44\26S/1MC CORPV 157.5 Letter \\MSPRINT44\26S/1MC CORPV 157.5 Letter Times New Roman Symbol Arial Courier New Times Helvetica LinePrinter Courier  D:\apps\office\Templates\nt5.dot ACL Editor Security.Security, design, NT 5.0, ACLs, User InterfaceiThis document describes the design of the Session Announcement Protocol (SAP) support for Windows NT 5.0. Don Ryan Don Ryan
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\docs\readme.txt ===
NetPlus WinSNMP Developer Kit                    August 8, 1998

Current version of ACE*COMM's wsnmp32.dll:

	String value: v2.32.19980808
	Binary value: 2.0.0.25

Change log:

v2.32.19980808: No external changes...function error
		reporting mechanisms normalized across
		all internal modules.

v2.32.19980705: Fixed an internal error return test that
                would have caused the SnmpCreateVbl()
                function to encounter an access violatoin
                when passed a varbind with the (obsolete)
                SNMP_SYNTAX_BITS syntax value.

v2.32.19980622: Improved some internal error checking.
                Improved timeout interval handling for
                intervals larger than 429,496,729 centiseconds.

v2.32.19980608: Fixed some flawed logic concerning freeing
		entities which are acting as agents.
                Repaired a memory leak in the implementation
                of the RFC 2089 automatic SNMPv2 to SNMPv1
                trap mapping algorithm.

v2.32.19980522: Modified SnmpContextToStr() code to return the
                "raw" context value if the function is called
                in SNMPAPI_TRANSLATED mode and the subject
                hContext had been created in SNMPAPI_UNTRANSLATED
                (v1 or v2) mode.

v2.32.19980507: Fixed a problem which caused some trap sending
                apps to fail if they issued multiple consecutive
                traps to a given HSNMP_ENTITY value.  Added
                error return (SNMPAPI_TL_OTHER) to SnmpSendMsg()
                when WinSock sendto() fails for any reason.

v2.32.19980424: Internal integrity improvements in low-level
                parsing routines...accept case when IPX header
                indicates packet length greater than actual
                SNMP message length.

v2.32.19980416: Fixed a problem in the interface with the
                SNMPTRAP service that prevented non-admin users
                from accessing the service.  See the explanatory
                note in a separate section later in this file for
                more details.  Also, made some (minor) reliability
                and performance improvements to SNMPTRAP itself
                (its version is now 4.0.1381.4).

v2.32.19980402: Fixed a problem that caused a comm failure on Win95
                systems *only* when using WinSock v2 ws2_32.dll) with
                *both* TCP/IP *and* IPX protocols installed.

v2.32.19980330: Fixed a failure in SnmpCreateSession() to return
                SNMPAPI_HWND_INVALID when called in SnmpOpen() mode
                (i.e., fCallBack is NULL) and the hWnd parameter
                failed the Win32 IsWindow() check.

v2.32.19980323: Made improvements to session notification dispatching
                algorithm for improved performance and reliability
                specifically related to using callback notification
                mode in multi-threaded/multi-session applications.

v2.32.19980318: Fixed SnmpOidToStr() to return the correct byte count
                upon successful completion...previously it was not
                counting the terminating NULL byte of the output
                string as required by the WinSNMP spec...most apps
                tested only for the SNMPAPI_FAILURE case, so there
                were no field reports of this discrepancy.  Also,
                added the SNMPAPI_NOOP extended error code return
                to cover the case of a NULL scrOID input parameter.
                Again, there had been no field reports of this
                deficiency.

v2.32.19980309: Fixed a bug and made a modest performance improvement
                in SnmpCancelMsg().

v2.32.19980216: "Fix" added to enable SNMP request/response messages
                over IPX for Win95.  Required adding an otherwise
                ill-advised bind() call.

v2.32.19980113: Improvements to internal message buffer management
                scheme (to optimize for early release of resources
                used for out-going messages that will not receive
                a response (ie., traps and response PDUs).

                Simplification of the housekeeping timer thread.

                Rationalization of the method of invoking a
                session's callback function that prevents multiple
                instances of the callback being invoked concurrently.

v2.32.19971222: Improvements to internal message memory allocation
                scheme (to handle large numbers of outstanding messages
                more efficiently).

v2.32.19971216:	Improvements to worker thread termination logic.
------------------------------------------------------------------------
Additional WinSNMP-related files may be freely obtained from the file
download site, www.winsnmp.com.
------------------------------------------------------------------------
If you develop WinSNMP management applications or agents and would like
to participate in a co-marketing program with ACE*COMM, please contact
Ben Gray, bgray@acecomm.com.
------------------------------------------------------------------------
If you are new to WinSNMP development, please read the following
documents before proceeding, in the following order:

	- winsnmp2.txt
	- winsnmp.doc

The first is the WinSNMP v2.0 Addendum.  It clarifies certain aspects
of WinSNMP that were ambiguous in the previous version (v1.1a, defined
in winsnmp.doc) of the API and it describes the five new functions
added for v2.0.

This version of ACE*COMM's NetPlus WinSNMP implementation for Win32
fully implements WinSNMP v2.0 and incorporates many architectural and
performance improvements over earlier releases.  It is designed to work
identically over NT (3.51 through 5) and Win95, with a single difference
in runtime files for received trap dispatching for NT (SNMPTRAP.EXE) vs
Win95 (NP_WSX95.EXE).

Current users please note:
This wsnmp32.dll does not require the np_wsx32.exe "helper" app of
previous versions...instead you will need either snmptrap.exe (for NT)
or np_wsx95.exe (for Win95).  For clarity's sake, you should remove any
np_wsx32.exe from a machine running this version of wsnmp32.dll--or at
least move it to a directory off the execution path.  Nothing bad happens
if you don't, except some wasted disk space and an increased possibility
for confusion.
------------------------------------------------------------------------
SNMPTRAP Info (NT only):
This snmptrap.exe is a plug-replacement for the one MS ships (it will
eventually *be* the one that MS ships). It is functionally identical
(with some minor performance improvements), but does not have any
internal dependencies on either the wsnmp32.dll or the mgmtapi.dll,
although it services both.

Our wsnmp32.dll will create and install the service on the first call
to SnmpRegister() if it finds that the sevice has not been previously
installed.  The Win32 CreateService() API requires that the caller
have admin priviledges.

One we have created and installed the service, our wsnmp32.dll will
auto-start it if it's not already running when the first app successfully
calls SnmpRegister().

[If you are installing our runtime files by hand--rather than via the
Developer Kit automated install/setup package--then you must copy
snmptrap.exe to "%SystemRoot%\system32\".  If you did not previously
have the SNMPTRAP service installed, then we will auto-install it,
per above.  If you already had the original MS version installed, then
you should use an admin tool (such as sc.exe from the MS Resource Kit)
to remove/delete it.

If you are using the automated InstallShield procedure, then it will
perform as much of the above as it can for you; but depending upon
system security settings for any pre-existing SNMPTRAP installation,
you may still have to perform the service remove/delete operation.
------------------------------------------------------------------------
Win95 users please note:
The snmptrap.exe does not apply and you do not need to have it on your
system.  Instead, however, you must have np_wsx95.exe accessible for
auto-loading/termination by wsnmp32.dll (in response to SnmpRegister()
calls).
------------------------------------------------------------------------
You will note that the winsnmp.def does not contain any exports for
proprietary functions.  If you previously used any of our pre-standard
implementations of:

	- SnmpSetPort()
	- SnmpListen()
	- NPWSNMPSetV1TrapPduData()

you will need to at least re-link (for SnmpSetPort(), whose ordinal
changed) or re-build (SnmpListen() has slightly different calling
parameters in v2.0 than our pre-standard implementation and
NPWSNMPSetV1TrapPduData() no longer exists, since SNMPv1 trap PDU
generation is handled automatically by wsnmp32.dll).

Also, this version does not use any "shared" memory across processes.
Hence, there is no need to fiddle with the resource limits in the
[Startup] section of the np_wsnmp.ini file (in fact, that section can
be completely deleted from np_wsnmp.ini, if you want).

You will find information about our MIB compiler and the MIB access
routines in the underlying libraries in the NP_MIB++ directory.
You are free to use our MIB compiler technology in your own apps, but
please note that doing so will mean that you are using our proprietary
interfaces, rather than some industry-standard (which does not yet
exist anyway).

For information on HP's SNMP++ DLL and sample applications, please
refer to their web site at:

   http://rosegarden.external.hp.com/snmp++

Please report any problems/questions with this release directly to
Bob Natale, bnatale@acecomm.com.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\docs\winsnmp.doc ===
Microsoft Word Document MSWordDoc Word.Document.8ACE*COMM Combo Document Title _PID_GUIDCombo Document Robert C. Natale Normal FlorinT Microsoft Word 8.0@\\msprint44\corpm Ne01: winspool HP LaserJet 4Si/4Si MX PS \\msprint44\corpm Letter \\msprint44\corpm Letter@\\msprint44\corpm Ne01: winspool HP LaserJet 4Si/4Si MX PS \\msprint44\corpm Letter \\msprint44\corpm LetterjwosN(fE 'NVNn c>N9B MapH"w IXNU+Y 9>-p6 , FXH^a1y OXNNa% "u/hM7 !eyxXYF [|Q>5 XZ>AJ; Zs~W4. Fx!>_xJ m!+cBf M{&}3 q>St4c \}XWoe J[HbL !_Qe# 's_wO) 7Ve=UYWE H\"kh eu;QS O 6!T Y[Ae8c Zj0.1 `$]4c$ Z$O4' ,Hme" gWSr7f> @9I.! WMIf, C[HfL C[HfL Xksr6' 'ye7%Tu V9M[8 3uw&o7%% ]7z.b [`+}[ ?O_:r L-/3_!x od-{kY 1j<Jm=^ z4>m0 B\Oa[G F\mFBc #oDMF /C{Qx iA8G\Windows SNMP An Open Interface for Programming Network Management Applications  using the  Simple Network Management Protocol under Microsoft SYMBOL 226 \f "Symbol"  Windows WinSNMP/Manager API Version 1.1a 9 August 1995 Bob Natale ACE*COMM Copyright  SYMBOL 211 \f "Symbol"  1993-1997 by Bob Natale, ACE*COMM Corporation All rights reserved. This document may be freely redistributed in any form, electronic or otherwise, provided that it is distributed in its entirety and that the copyright and this notice are included.  Comments or questions may be submitted via electronic mail to winsnmp@mailbag.intel.com.  Requests to be added to the Windows SNMP mailing list should be addressed as follows: To:  Majordomo@mailbag.intel.com Subject:  <leave blank> subscribe WinSNMP This specification and other information on Windows SNMP are available via anonymous FTP from the host SunSITE.unc.edu under the  directory path /pub/micro/pc-stuff/ms-windows/WinSNMP. Questions about products conforming to this specification should be addressed to the vendors of the products. Author's Contact Information Bob Natale bnatale@acecomm.com Director, Network Management Products ACE*COMM 704 Quince Orchard Road Gaithersburg MD  20878 301-721-3000 (Tel) 301-721-3001 (Fax) http://www.acecomm.com Abbreviated Revision History Editor Editor's Address January 25, 1993 Microsoft dwaink@microsoft.com April 28,1993 Amatzia Ben-Artzi amatzia@netmanage.com September 13, 1993 Bob Natale natale@acec.com (working) DRAFT February 14, 1994 Bob Natale natale@acec.com (bake-off) DRAFT May 16,1994 Bob Natale natale@acec.com (draft) June 12, 1994 Bob Natale natale@acec.com (production) August 9, 1995 Bob Natale natale@acec.com (clarifications) WinSNMP/Manager API Specification Table of Contents TOC \o 1. INTRODUCTION  GOTOBUTTON _Toc332606616    PAGEREF _Toc332606616  1.1. What is Windows SNMP?  GOTOBUTTON _Toc332606617    PAGEREF _Toc332606617  1.2. Compliance  GOTOBUTTON _Toc332606618    PAGEREF _Toc332606618  1.3. SNMP  GOTOBUTTON _Toc332606619    PAGEREF _Toc332606619  1.4. Microsoft Windows  GOTOBUTTON _Toc332606620    PAGEREF _Toc332606620  1.5. The Status of this Specification  GOTOBUTTON _Toc332606621    PAGEREF _Toc332606621  1.6.  References  GOTOBUTTON _Toc332606622    PAGEREF _Toc332606622  1.6.1. Primary Sources  GOTOBUTTON _Toc332606623    PAGEREF _Toc332606623  1.6.2.  Secondary Sources  GOTOBUTTON _Toc332606624    PAGEREF _Toc332606624  1.7.  Glossary:  Abbreviations, Acronyms, and Definitions  GOTOBUTTON _Toc332606625    PAGEREF _Toc332606625  1.8.  Contributors  GOTOBUTTON _Toc332606626    PAGEREF _Toc332606626  1.8.1.  Special Acknowledgments  GOTOBUTTON _Toc332606627    PAGEREF _Toc332606627  1.8.2. Individual Contributors  GOTOBUTTON _Toc332606628    PAGEREF _Toc332606628  2.  PROGRAMMING WITH WINDOWS SNMP  GOTOBUTTON _Toc332606629    PAGEREF _Toc332606629  2.1. Levels of SNMP Support  GOTOBUTTON _Toc332606630    PAGEREF _Toc332606630  2.1.1. Implementations  GOTOBUTTON _Toc332606631    PAGEREF _Toc332606631  2.1.1.1. "Level 0" Implementations  GOTOBUTTON _Toc332606632    PAGEREF _Toc332606632  2.1.1.2. "Level 1" Implementations  GOTOBUTTON _Toc332606633    PAGEREF _Toc332606633  2.1.1.3. "Level 2" Implementations  GOTOBUTTON _Toc332606634    PAGEREF _Toc332606634  2.1.1.4. "Level 3" Implementations  GOTOBUTTON _Toc332606635    PAGEREF _Toc332606635  2.1.2. Applications  GOTOBUTTON _Toc332606636    PAGEREF _Toc332606636  2.2. Transport Interface Support  GOTOBUTTON _Toc332606637    PAGEREF _Toc332606637  2.3. Entity/Context Translation Modes  GOTOBUTTON _Toc332606638    PAGEREF _Toc332606638  2.3.1. SNMPAPI_TRANSLATED Mode  GOTOBUTTON _Toc332606639    PAGEREF _Toc332606639  2.3.2. SNMPAPI_UNTRANSLATED_V1 Mode  GOTOBUTTON _Toc332606640    PAGEREF _Toc332606640  2.3.3. SNMPAPI_UNTRANSLATED_V2 Mode  GOTOBUTTON _Toc332606641    PAGEREF _Toc332606641  2.4. Local Database  GOTOBUTTON _Toc332606642    PAGEREF _Toc332606642  2.5. Sessions  GOTOBUTTON _Toc332606643    PAGEREF _Toc332606643  2.6. Memory Management  GOTOBUTTON _Toc332606644    PAGEREF _Toc332606644  2.6.1. HANDLE d Resources  GOTOBUTTON _Toc332606645    PAGEREF _Toc332606645  2.6.2. C-Style Strings  GOTOBUTTON _Toc332606646    PAGEREF _Toc332606646  2.6.3. Descriptors  GOTOBUTTON _Toc332606647    PAGEREF _Toc332606647  2.6.4. Summary  GOTOBUTTON _Toc332606648    PAGEREF _Toc332606648  2.7. Asynchronous Model  GOTOBUTTON _Toc332606649    PAGEREF _Toc332606649  2.8. Polling and Retransmission  GOTOBUTTON _Toc332606650    PAGEREF _Toc332606650  2.9. RequestIDs  GOTOBUTTON _Toc332606651    PAGEREF _Toc332606651  2.10. Error Handling  GOTOBUTTON _Toc332606652    PAGEREF _Toc332606652  2.10.1. Common Error Codes  GOTOBUTTON _Toc332606653    PAGEREF _Toc332606653  2.10.2. Context-Specific Error Codes  GOTOBUTTON _Toc332606654    PAGEREF _Toc332606654  2.10.3. Transport Error Reporting  GOTOBUTTON _Toc332606655    PAGEREF _Toc332606655  2.11. WinSNMP Data Types  GOTOBUTTON _Toc332606656    PAGEREF _Toc332606656  2.11.1. Integers  GOTOBUTTON _Toc332606657    PAGEREF _Toc332606657  2.11.2. Pointers  GOTOBUTTON _Toc332606658    PAGEREF _Toc332606658  2.11.3. Function Returns  GOTOBUTTON _Toc332606659    PAGEREF _Toc332606659  2.11.4. Descriptors  GOTOBUTTON _Toc332606660    PAGEREF _Toc332606660  3.  WINDOWS SNMP INTERFACES  GOTOBUTTON _Toc332606661    PAGEREF _Toc332606661  3.1. Local Database Functions  GOTOBUTTON _Toc332606662    PAGEREF _Toc332606662  3.1.1. SnmpGetTranslateMode()  GOTOBUTTON _Toc332606663    PAGEREF _Toc332606663  3.1.2. SnmpSetTranslateMode()  GOTOBUTTON _Toc332606664    PAGEREF _Toc332606664  3.1.3. SnmpGetRetransmitMode()  GOTOBUTTON _Toc332606665    PAGEREF _Toc332606665  3.1.4. SnmpSetRetransmitMode()  GOTOBUTTON _Toc332606666    PAGEREF _Toc332606666  3.1.5. SnmpGetTimeout()  GOTOBUTTON _Toc332606667    PAGEREF _Toc332606667  3.1.6. SnmpSetTimeout()  GOTOBUTTON _Toc332606668    PAGEREF _Toc332606668  3.1.7. SnmpGetRetry()  GOTOBUTTON _Toc332606669    PAGEREF _Toc332606669  3.1.8. SnmpSetRetry()  GOTOBUTTON _Toc332606670    PAGEREF _Toc332606670  3.2. Communications Functions  GOTOBUTTON _Toc332606671    PAGEREF _Toc332606671  3.2.1. SnmpStartup()  GOTOBUTTON _Toc332606672    PAGEREF _Toc332606672  3.2.2. SnmpCleanup()  GOTOBUTTON _Toc332606673    PAGEREF _Toc332606673  3.2.3. SnmpOpen()  GOTOBUTTON _Toc332606674    PAGEREF _Toc332606674  3.2.4. SnmpClose()  GOTOBUTTON _Toc332606675    PAGEREF _Toc332606675  3.2.5. SnmpSendMsg()  GOTOBUTTON _Toc332606676    PAGEREF _Toc332606676  3.2.6. SnmpRecvMsg()  GOTOBUTTON _Toc332606677    PAGEREF _Toc332606677  3.2.7. SnmpRegister()  GOTOBUTTON _Toc332606678    PAGEREF _Toc332606678  3.3. Entity/Context Functions  GOTOBUTTON _Toc332606679    PAGEREF _Toc332606679  3.3.1. SnmpStrToEntity()  GOTOBUTTON _Toc332606680    PAGEREF _Toc332606680  3.3.2. SnmpEntityToStr()  GOTOBUTTON _Toc332606681    PAGEREF _Toc332606681  3.3.3. SnmpFreeEntity()  GOTOBUTTON _Toc332606682    PAGEREF _Toc332606682  3.3.4. SnmpStrToContext()  GOTOBUTTON _Toc332606683    PAGEREF _Toc332606683  3.3.5. SnmpContextToStr()  GOTOBUTTON _Toc332606684    PAGEREF _Toc332606684  3.3.6. SnmpFreeContext()  GOTOBUTTON _Toc332606685    PAGEREF _Toc332606685  3.4. PDU Functions  GOTOBUTTON _Toc332606686    PAGEREF _Toc332606686  3.4.1. SnmpCreatePdu()  GOTOBUTTON _Toc332606687    PAGEREF _Toc332606687  3.4.2. SnmpGetPduData()  GOTOBUTTON _Toc332606688    PAGEREF _Toc332606688  3.4.3. SnmpSetPduData()  GOTOBUTTON _Toc332606689    PAGEREF _Toc332606689  3.4.4. SnmpDuplicatePdu()  GOTOBUTTON _Toc332606690    PAGEREF _Toc332606690  3.4.5. SnmpFreePdu()  GOTOBUTTON _Toc332606691    PAGEREF _Toc332606691  3.5. Variable Binding Functions  GOTOBUTTON _Toc332606692    PAGEREF _Toc332606692  3.5.1. SnmpCreateVbl()  GOTOBUTTON _Toc332606693    PAGEREF _Toc332606693  3.5.2. SnmpDuplicateVbl()  GOTOBUTTON _Toc332606694    PAGEREF _Toc332606694  3.5.3. SnmpFreeVbl()  GOTOBUTTON _Toc332606695    PAGEREF _Toc332606695  3.5.4. SnmpCountVbl()  GOTOBUTTON _Toc332606696    PAGEREF _Toc332606696  3.5.5. SnmpGetVb()  GOTOBUTTON _Toc332606697    PAGEREF _Toc332606697  3.5.6. SnmpSetVb()  GOTOBUTTON _Toc332606698    PAGEREF _Toc332606698  3.5.7. SnmpDeleteVb()  GOTOBUTTON _Toc332606699    PAGEREF _Toc332606699  3.6. Utility Functions  GOTOBUTTON _Toc332606700    PAGEREF _Toc332606700  3.6.1. SnmpGetLastError()  GOTOBUTTON _Toc332606701    PAGEREF _Toc332606701  3.6.2. SnmpStrToOid()  GOTOBUTTON _Toc332606702    PAGEREF _Toc332606702  3.6.3. SnmpOidToStr()  GOTOBUTTON _Toc332606703    PAGEREF _Toc332606703  3.6.4. SnmpOidCopy()  GOTOBUTTON _Toc332606704    PAGEREF _Toc332606704  3.6.5. SnmpOidCompare()  GOTOBUTTON _Toc332606705    PAGEREF _Toc332606705  3.6.6. SnmpEncodeMsg()  GOTOBUTTON _Toc332606706    PAGEREF _Toc332606706  3.6.7. SnmpDecodeMsg()  GOTOBUTTON _Toc332606707    PAGEREF _Toc332606707  3.6.8. SnmpFreeDescriptor()  GOTOBUTTON _Toc332606708    PAGEREF _Toc332606708  4. Declarations  GOTOBUTTON _Toc332606709    PAGEREF _Toc332606709  Appendix A. Mapping Traps Between SNMPv1 and SNMPv2  GOTOBUTTON _Toc332606710    PAGEREF _Toc332606710  Appendix B. Usage Example  GOTOBUTTON _Toc332606711    PAGEREF _Toc332606711  Appendix C.  WinSNMP++ Prototype  GOTOBUTTON _Toc332606712    PAGEREF _Toc332606712  autonumlgl   INTRODUCTION The Windows SNMP API specification defines a programming interface for network management applications running under the Microsoft Windows family of GUI/operating system products, enabling those applications to make use of a logically external SNMP engine or service layer. For the purpose of exposition, the original Internet-standard Network Management Framework, as described in RFCs 1155, 1157, and 1212, is termed the SNMP version 1 framework (SNMPv1).  The new framework that is currently a proposed Internet standard, as described in RFCs 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, and 1452, is termed the SNMP version 2 framework (SNMPv2).  In addition, there are three proposed Internet standards, as described in RFCs 1418, 1419, and 1420, that address the use of transports other than UDP over IP for SNMPv1.  These RFCs describe SNMPv1 over OSI, AppleTalk, and IPX.  Note that these transports are directly addressed in SNMPv2 by RFC 1449. The Windows SNMP API specification introduces no constraints on the use of SNMPv1 or SNMPv2, nor on the functionality supported by those protocols as prescribed in the relevant Internet RFCs. For the purposes of this specification, SNMPv1 is seen as a subset of SNMPv2. Hereinafter the terms "WinSNMP",  WinSNMP/Manager , and "Windows SNMP" will be used as shorthand for "the Windows SNMP Manager API Specification" (which is the full and formal name for this document itself). This specification avoids introducing new or different meanings for terms which have established definitions in the existing SNMP literature (especially the RFCs).  Readers are encouraged to consult the "Glossary" and "References" sections (and to point out lapses in terminological correctness). autonumlgl   What is Windows SNMP? The purpose of WinSNMP is to promote the development of SNMP-based network management applications running under the Microsoft Windows family of GUI/operating system products. WinSNMP provides a single interface to which application developers can program and multiple SNMP software vendors can conform.  This specification thus defines the procedure calls, data types, data structures, and associated semantics to which an application developer can program and which an SNMP software vendor can implement.  The following diagram shows where WinSNMP fits in one possible scenario of end-to-end SNMP connectivity from an entity acting in a manager role (far left) to an entity acting in an agent role (far right).  This diagram is a high-level rendition of the model embodied in the current version of WinSNMP.  Other models are both possible and supported by the specification, particularly as regards network transport independence. In summary, WinSNMP offers these major benefits--all intended to accelerate the development, dissemination, and use of SNMP network management applications: SNMP enabling technology for functional network management applications (i.e.,  hides   ASN.1, BER, and SNMP protocol details). SNMP service provider independence.  A WinSNMP application will run against any compliant WinSNMP implementation. Uniform SNMPv1 and SNMPv2 support.  A WinSNMP application does not have to know the SNMP version level of  the target SNMP entities acting in an agent role.  The WinSNMP implementation will perform any and all necessary mappings  between SNMPv1 and SNMPv2 in accordance with the appropriate RFCs. autonumlgl   Compliance Software which conforms to this Windows SNMP specification will be considered "WinSNMP compliant". Suppliers of implementations which are "WinSNMP compliant" shall be referred to as "WinSNMP suppliers".  Nothing in the WinSNMP specification is meant to dictate or preclude particular implementation strategies.  This specification allows for various overlapping levels of SNMP support on the part of an implementation: SYMBOL 183 \f "Symbol" \s 10 \h Level 0 = Message encoding/decoding only SYMBOL 183 \f "Symbol" \s 10 \h Level 1 = Level 0 + interaction with SNMPv1 agents SYMBOL 183 \f "Symbol" \s 10 \h Level 2 = Level 1 + interaction with SNMPv2 agents SYMBOL 183 \f "Symbol" \s 10 \h Level 3 = Level 2 + interaction with other SNMPv2 managers To be WinSNMP compliant, a vendor must implement 100% of this WinSNMP specification, as appropriate to the level of SNMP interaction the given implementation supports.  WinSNMP vendors are encouraged to state clearly the level of SNMP interaction they support in all of their marketing and technical literature. Applications which are capable of operating with any "WinSNMP compliant" implementation which supports at least the level of SNMP interaction required by the application will be considered as having a "WinSNMP interface" and will be referred to as "WinSNMP applications". This version of the WinSNMP specification defines and documents the use of the API by management applications.  A future revision or separate extension may include features for use by SNMP agents.  A companion document, the  WinSNMP/MIB API Specification , provides definitions of elements used as operands to SNMP operations. autonumlgl   SNMP SNMP is a request-response protocol used to transfer management information between entities acting in a manager role and entities acting in an agent role.  Managers are often configured as management stations and agents are often configured as managed nodes.  A manager can also act as an agent to another manager in both vertical (hierarchical) and horizontal (distributed) relationships.  Likewise, a physical node might be managed by multiple agents, and an agent might manage multiple physical nodes.  When hereinafter we use the prototypical management station/managed node perspective for the sake of simplicity and clarity of presentation, that practice is not meant to preclude other forms of SNMP interactions. Each managed device or application contains monitoring and (possibly) control instrumentation.  This instrumentation is accessed by the agent.  The agent represents its access to this instrumentation to the manager via a MIB, filtered by the SNMP security mechanisms.  Management applications communicate with agents via SNMP to monitor and (possibly) control managed devices or applications. A management application may issue several requests to an agent, without waiting for a response.  Alternatively, it may issue a request and wait for a response, operating in a lock-step fashion with the agent.  Furthermore, SNMP may be implemented on a wide range of transport protocols, each with varying delivery mechanisms and reliability characteristics.  The normal transmission mechanism (UDP) is through non-guaranteed messages which may be dropped, duplicated, or re-ordered.  Thus, with SNMP, it is the responsibility of each management application to determine and implement the desired level of reliability for its communications.  This means that the management application decides on its own retransmission and timeout strategy. Note, also, that an agent may send asynchronous messages--called traps (SNMPv1) or notifications (SNMPv2)--to a management application.  This important feature of SNMP is also fully supported by WinSNMP.  Note that in this document, the term "traps" is used to refer both to traps and notifications, unless specifically qualified as otherwise in a given instance. autonumlgl   Microsoft Windows This API is intended to be usable within all implementations and versions of Microsoft Windows "family" of operating systems and graphical user interface environments from Microsoft Windows Version 3.0 onwards, including Windows v3.1, Windows for Workgroups v3.11, and Windows NT (among others).  It thus provides for WinSNMP implementations and WinSNMP applications in both 16- and 32-bit operating environments, and in both single- and multi-threaded execution environments. WinSNMP makes provisions for multi-threaded Windows processes.  A process contains one or more threads of execution.  In the Win16 non-multi-threaded world, a task corresponds to a process with a single thread.  All references to threads in this document refer to actual "threads" in multi-threaded Windows environments.  In single-threaded environments (such as Windows 3.0 and Windows 3.1), use of the term thread refers to a Windows process. autonumlgl   The Status of this Specification This specification is released for stable implementation as of this revision (v1.1).  It is the product of collaboration among an informal, ad hoc, self-organized group of vendors, developers, and users with an interest in SNMP-based network management applications and the Microsoft Windows family of development and runtime supporting environments for such applications. Readers of this specification are assumed to have a high degree of knowledge and understanding of SNMP (through SNMPv2) and Microsoft Windows programming conventions.  Contributions aimed at reducing the level of detailed knowledge of these specific technologies required for users of this specification are invited. At the present time, it is believed that this version (v1.1) of the WinSNMP/Manager API specification permits the development of interoperable implementations and applications supporting at least "SNMP Level 1" as defined herein and that applications developed in accordance with this version of the specification will, additionally, be structured for future compatibility through "SNMP Level 3" as defined herein.  Due to limitations in the understanding and specification of "local database" functions in the current version, it is unlikely that full SNMPv2 operational support can be achieved without additional functions and data structures being defined.  It is expected that implementation, development, and interoperability experience gained with this v1.1 of this specification will identify those additions, and that they will appear in v2.0 of the specification in early 1995. Consensus on the release of the previous version of the specification was reached on the mailing list and confirmed at the third BOF meeting of the WinSNMP group held at the August '93 Interop in San Francisco.  This was followed by an interoperability testing event, hosted by NetManage in Cupertino in February 1994.  On-going edits to v1.1 will be accepted to: correct errors and inconsistencies; add explanatory and/or expository text and graphics; add essential new functions, variables, error codes, data types, or data structures required for usability of the baseline specification. Contributions oriented toward new and/or expanded functionality outside the scope of the preceding three objectives will be accepted, but will be considered for inclusion in v2.0 of this specification. autonumlgl    References This section consists of two parts:  Primary sources (mainly RFCs) and secondary sources. autonumlgl   Primary Sources Title Author(s) Comments SNMP over Ethernet M.L. Schoffstall, C. Davin, M. Fedor, J.D. Case Feb 1989 Simple Network Management Protocol (SNMP) J.D. Case, M. Fedor, M.L. Schoffstall, C. Davin Apr 1989 OBSOLETES: RFC1067, OBSOLETED-BY: RFC1157 Structure and Identification of Management Information for TCP/IP-based Internets M. T. Rose, K. Z. McCloghrie May 1990 OBSOLETES: RFC1065 Management Information Base for Network Management of TCP/IP-based Internets K. Z. McCloghrie, M. T. Rose May 1990 OBSOLETES: RFC1066 Simple Network Management Protocol (SNMP) J.D. Case, M. Fedor, M.L. Schoffstall, C. Davin May 1990 OBSOLETES: RFC1098 Management Information Base for Network Management of TCP/IP- based Internets:  MIB-II M. T. Rose May 1990 OBSOLETED-BY: RFC1213 SNMP over OSI M.T. Rose Jun 1990 OBSOLETED-BY: RFC1418 Bulk table retrieval with the SNMP M.T. Rose, K. McCloghrie, J.R. Davin Oct 1990 Management Information Base for Network Management of TCP/IP- based Internets:  MIB-II K. Z. McCloghrie, M. T. Rose Mar 1991 OBSOLETES: RFC1158 Convention for defining traps for use with the SNMP M.T. Rose Mar 1991 SNMP MUX protocol and MIB M.T. Rose May 1991 SNMP communications services F. Kastenholz Oct 1991 SNMP over OSI M. Rose Dec 1991 OBSOLETED-BY: RFC1418 Definitions of Managed Objects for the Ethernet-like Interface Types J. Cook Dec 1991 FDDI Management Information Base J. Case Jan 1992 Definitions of Managed Objects for Bridges E. Decker, P. Langille, A. Rijsinghani, K. McCloghrie Dec 1991 DECnet Phase IV MIB Extensions J. Saperia Dec 1991 SNMP over IPX R. Wormley, S. Bostock Feb 1992 OBSOLETED-BY: RFC1420 A Convention for Describing SNMP-based Agents K. McCloghrie, M. Rose Feb 1992 SEE-ALSO: RFC1155, RFC1212, RFC1213, RFC1157 SNMP Administrative Model J. Davin,J. Galvin,K. McCloghrie Jul 1992 SNMP Security Protocols J. Galvin,K. McCloghrie,J. Davin Jul 1992 SNMP MIB Extension for X.25 LAPB D. Throop, F. Baker Nov 1992 SNMP MIB Extension for the X.25 Packet Layer D. Throop Nov 1992 Definitions of Managed Objects for the DS3/E3 Interface Type Tracy A. Cox, Kaj Tesink Jan 1993 OBSOLETES: RFC1233 Identification MIB M. StJohns & M. Rose Jan 1993 SNMP over OSI M. Rose Feb 1993 OBSOLETES: RFC1161, RFC1283 SNMP over AppleTalk G. Minshall & M. Ritter Feb 1993 SNMP over IPX S. Bostock Feb 1993 OBSOLETES: RFC1298 Introduction to version 2 of the Internet-standard Network Management Framework J. Case, K. McCloghrie, M. Rose, & S. Waldbusser Apr 1993 Structure of Management Information for version 2 of the Simple Network Management Protocol (SNMPv2) J. Case, K. McCloghrie, M. Rose, & S. Waldbusser Apr 1993 Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2) J. Case, K. McCloghrie, M. Rose, & S. Waldbusser Apr 1993 Conformance Statements for version 2 of the Simple Network Management Protocol (SNMPv2) J. Case, K. McCloghrie, M. Rose, & S. Waldbusser Apr 1993 Administrative Model for version 2 of the Simple Network Management Protocol (SNMPv2) J. Galvin & K. McCloghrie Apr 1993 Security Protocols for version 2 of the Simple Network Management Protocol (SNMPv2) J. Galvin & K. McCloghrie Apr 1993 Party MIB for version 2 of the Simple Network Management Protocol (SNMPv2) K. McCloghrie & J. Galvin Apr 1993 Protocol Operations for version 2 of the Simple Network Management Protocol (SNMPv2) J. Case, K. McCloghrie, M. Rose, & S. Waldbusser Apr 1993 Transport Mappings for version 2 of the Simple Network Management Protocol (SNMPv2) J. Case, K. McCloghrie, M. Rose, & S. Waldbusser Apr 1993 Management Information Base for version 2 of the Simple Network Management Protocol (SNMPv2) J. Case, K. McCloghrie, M. Rose, & S. Waldbusser Apr 1993 Manager-to-Manager Management Information Base J. Case, K. McCloghrie, M. Rose, & S. Waldbusser Apr 1993 Coexistence between version 1 and version 2 of the Internet-standard Network Management Framework J. Case, K. McCloghrie, M. Rose, & S. Waldbusser Apr 1993 autonumlgl    Secondary Sources Black, Uyless D.  TCP/IP and Related Protocols.  McGraw-Hill, 1992. Comer, Douglas E., and Stevens, David L.  Internetworking with TCP/IP - Volume II:  Design, Implementation, and Internals.  Prentice-Hall, 1991.  (Chaps. 18-20.) Feit, Sidnie.  SNMP:  A Guide to Network Management.  McGraw-Hill, 1994. Feit, Sidnie.  TCP/IP: Architecture, Protocols, and Implementation.  McGraw-Hill, 1993. Harnedy, Sean J.  Total SNMP:  Exploring the Simple Network Management Protocol.  CBM Books, 1994. Hein, Mathis, and Griffiths,David.  SNMP Version 1 & 2:  Simple Network Management Protocol Theory and Practice.  International Thomson Computer Press, 1995.  ISBN 1-850-32139-6. Leinwand, Allan, and Fang, Karen.  Network Management:  A Practical Perspective.  Addison-Wesley, 1993. Leinwand, Allan, and Conroy , Karen Fang.  Network Management:  A Practical Perspective.  2nd ed.  Addison-Wesley, 1996.  ISBN 0-201-60999-1. Miller, Mark E., P.E.,  Managing Internetworks with SNMP:  The Definitive Guide to the Simple Network Management Protocol (SNMP) and SNMP version 2.  M&T Books, 1993. Perkins, David, and McGinnis, Evan.  Understanding SNMP MIBS.  Prentice-Hall, 1997. Rose, Marshall T.. and McCloghrie, Keith Z.  How to Manage Your Network Using SNMP:  The Network Management Practicum.  Prentice-Hall, 1995 (published in 1994). Rose, Marshall T.  The Simple Book:  An Introduction to Management of TCP/IP-based Networks.  Prentice-Hall, 1990. Rose, Marshall T.  The Simple Book:  An Introduction to Internet Management.  2nd ed.  Prentice-Hall, 1994 (published in 1993). Stallings, William.  SNMP, SNMPv2, and CMIP:  The Practical Guide to Network Management Standards.  Addison-Wesley, 1993. Steedman, Douglas.  Abstract Syntax Notation One (ASN.1):  The Tutorial and Reference.  Technology Appraisals, Ltd., 1990 (with Errata sheet dated March 14, 1991).  ISBN 1-871802-06-7. autonumlgl    Glossary:  Abbreviations, Acronyms, and Definitions The following table of abbreviations and definitions presents terms frequently used in the SNMP RFCs and related literature along with the official, customary, or consensus meaning(s).  An editing objective of this specification is to use none of these terms in any sense other than that shown in the corresponding definition, nor to invent or employ new terms with meanings functionally equivalent to those of these established terms. Short Definition Access Control Restriction of access to MIB objects either in scope or function or both, on the basis of party. Access Control List An indication of what actions (aclPrivileges) may be performed by a given party (aclTarget) on behalf of another party (aclSubject) within a given context (aclResources). Application Programming Interface A defined set of procedure calls, data types, data structures, and associated semantics used to incorporate a logically external service layer into an application program. Authentication Verification of message source and timeliness. Achieved in SNMPv2 normally by message component transformation via secret codes. Authorization Defining and controlling the levels of legitimate access to data and/or resources.  Achieved in SNMPv2 with the use of ACLs, and in SNMPv1 with the use of Community strings. Bilingual Entity A protocol entity that can handle both SNMPv1 and SNMPv2 operations, semantics, and communications. Community An administrative relationship between SNMPv1 entities; identified by a "community string". Context A collection of managed object resources accessible by an SNMP entity. Dual-Role Entity A protocol entity capable of acting in both a manager and an agent role. Entity Protocol Entity An SNMP-conversant process, operating in either and agent role or in a manager role, or both, which performs network management operations by generating and/or responding to SNMP protocol messages. Graphical User Interface A visually rich user interface (as contrasted with a Command Line Interface [CLI]). Local Database An entity-specific collection of information about parties, contexts, views, and access control policies. Manager-to-Manager MIB Used to define conditions and thresholds at a manager that will trigger notifications to other managers. Management Information Base A virtual information store holding a collection of managed object definitions. MIB View A subset of the universal set of all instances of all MIB objects; defined as a collection of view subtrees. Mid-Level Manager A dual-role protocol entity acting primarily in a manager role except when acting in an agent role vis- -vis other managers. Object Identifier A data type denoting an authoritatively named object; a sequence of non-negative integers. Party A conceptual, virtual execution environment who operation is restricted to an administratively defined subset of all possible operations of a particular entity.  A set of specific security characteristics. Party MIB Used to configure parties at protocol entities with various security characteristics, including use or non-use of authentication and/or privacy and access control constraints. Privacy Protection of transmitted data from eavesdropping.  Achieved in SNMPv2 normally by message component encryption. Protocol Data Unit A data structure containing SNMP message components and used for communication between SNMP entities. Proxy Proxy Agent Request for Comments The document series describing the Internet suite of protocols and related experiments. Simple Network Management Protocol The application protocol offering network management service in the Internet suite of protocols.  Abbreviation used for both SNMPv1 and SNMPv2. variable SNMP variable An object's identity and its instance value encoded as an OID. varbind Variable-Binding A pairing of an object instance name and an associated value or pseudo-value and syntax. varbindlist Variable-Bindings List A grouping of one or more variable-bindings autonumlgl    Contributors  AUTONUMLGL    Special Acknowledgments Special acknowledgment is made to the following individuals and organizations for critical contributions to the origination, evolution, and realization of the WinSNMP/Manager API: Amatzia Ben-Artzi, NetManage, for contributing original SNMP API specifications to be used a starting point for the WinSNMP/Manager API and for hosting the first WinSNMP interoperability tests in February 1993. Dwain Kinghorn, Microsoft, for contributing original SNMP API specifications to be used as a starting point for the WinSNMP/Manager API. Marshall Rose, Dover Beach Consulting, for a major enhancement to the early WinSNMP/ Manager API to provide for transparent SNMPv1 and SNMPv2 support and to enable transport independence.  Marshall, of course, is a beacon of SNMP understanding and a bastion of SNMP authority. Two other notable SNMP authorities--Jeff Case of SNMP Research and Dave Perkins of Synoptics--contributed extensive reviews of the pre-1.0 versions of this specification.  In addition, three other equally qualified SNMP experts--Bob Stewart of Xyplex, Keith McCloghrie of Cisco, and Karl Auerbach--provided invaluable insights and guidance at various stages of the working groups deliberations. Bob Natale, American Computer & Electronics Corp, for serving as group moderator and editor of the WinSNMP family of APIs--WinSNMP/Manager, WinSNMP/MIB, and WinSNMP/Agent. Mark Towfiq and Simon Spero, SunSITE, for their generosity, patience, and effort with respect to WinSNMP mailing list and file archive administration. Also, several specific technical contributions deserve mention:  Maria Greene (while at Xyplex) for the  strawman  C++ Appendix; Mary Quinn of FTP Software for the transport layer error codes; Reuben Sivan of MultiPort Software for the  const  types; and Kee Lai of FTP Software for the trap processing example Appendix.  Each of those contributions involved not just an idea expressed via e-mail, but some actual work in writing and testing proposed code.  There have been many good ideas expressed on the WinSNMP mailing list by many people--hopefully all of them are listed below.  However, one additional individual deserves special mention here because he participated in almost all of the technical discussions with patience, imagination, and persistence...many of the low-level specifics of the WinSNMP/Manager API have been affected (positively :-) by the input of Chris Young of Cabletron. In addition, the individuals listed in the next section and their sponsoring organizations have contributed ideas, time, and (in some cases) other valuable resources, to the creation of the Windows SNMP API specification.  (Other individuals have indicated a desire to help with some of the planned extensions to the WinSNMP/Manager API...look for their names in the v2.0 document next year!)  AUTONUMLGL   Individual Contributors Tom Abraham abraham@acec.com Ed Alcoff oldera@nat.com James  Allard jallard@microsoft.com Karl Auerbach auerbach@ssds.com Larry Backman backman@ftp.com John Bartas jbartas@sunlight.com jrb@ibeam.ht.intel.com Amatzia Ben-Artzi amatzia@netmanage.com Chris Bologna chris@distinct.com Jeff Case case@snmp.com Seung   Chin schin@novell.com David Corbello corb@acc.com William Dunn williy@netmanage.com Hope Fabian hope@ralvm12.vnet.ibm.com Nick Gandin gandin@acec.com Maria Greene maria@maelstrom.timeplex.com Michael Greenberg arnoff@ftp.com Jim Greuel j_greuel@hpcnd.cnd.hp.com Dwain Kinghorn dwaink@microsoft.com Guenther Kroenert Guenther.Kroenert@sto.mchp.sni.de Kee Lai klai@ftp.com Ray C. Langford ray@frontiertech.com Osip Liitsci osip@netmanage.com Keith McCloghrie kzm@cisco.com Evan McGinnis bem@nsd.3com.com Victoria J. McGuire victoria@ralvm12.vnet.ibm.com John F. Moehrke john@frontiertech.com Bob Natale natale@acec.com Scott Neal scott_neal@hp0800.desk.hp.com Bill Norton wbn@merit.edu Barbara Packard bpackard@ppg01.sc.hp.com Sudhir Pendse sudhir@netcom.com Dave Perkins dperkins@synoptics.com Eric Peterson ericpe@microsoft.com Mary Quinn mquinn@ftp.com Marshall T. Rose mrose@dbc.mtview.ca.us Rick Segal rsegal@microsoft.com Reuben Sivan rds@world.std.com Simon E. Spero ses@tipper.oit.unc.edu Bob Stewart rlstewart@eng.xyplex.com Wayne F. Tackabury wayne@cayman.com Ling Thio H.L.Thio@et.tudelft.nl Mark Towfiq towfiq@sunsite.unc.edu Chuck Townsend townsend@ctron.com Alex Tudor alex@hpssdat.sc.hp.com Chuck Wegrzyn wegrzyn@nic.cerf.net Pete Wilson pwilson@world.std.com Boris Yanovsky boris@netmanage.com Chris Young cyoung@ctron.com Dennis Young young@telebit.com autonumlgl    PROGRAMMING WITH WINDOWS SNMP This section outlines some of the high level considerations relevant to the programming "model" envisioned by WinSNMP.  This model is meant to add background and context for evaluating the specification itself.  In general, although it is not possible to eschew all references to implementation details in the MS Windows environments, the WinSNMP specifications try to openly state any and all relevant implementation assumptions. The primary assumption is that the WinSNMP/Manager API will be implemented by (or for) the SNMP service provider as a dynamic link library (WINSNMP.DLL).  This DLL might perform the SNMP functions locally or might be a  helper  DLL that ships application requests to an SNMP service on a remote platform and, in return, routes responses from that platform back to the target applications on the local MS Windows machine. In either case, the major aspects of WinSNMP implementation that affect application development include: Levels of SNMP Support Transport Interface Support Entity/Context Translation Modes Local Database Information Session Characteristics Memory Management Asynchronous Model Polling and Retransmission Error Handling Data Types autonumlgl   Levels of SNMP Support This specification allows for multiple levels of SNMP support--explicitly for implementations and implicitly for applications. Note that these "Levels" are independent of and unrelated to the "Modes" of interpretation of entity and context arguments (described later). Note that the implementation will report its maximum level of SNMP support in response to the SnmpStartup function (described later). autonumlgl   Implementations The WinSNMP API specification allows an implementation to support any of four overlapping levels of SNMP operations: SYMBOL 183 \f "Symbol" \s 10 \h Level 0 = Message encoding/decoding only SYMBOL 183 \f "Symbol" \s 10 \h Level 1 = Level 0 + interaction with SNMPv1 agents SYMBOL 183 \f "Symbol" \s 10 \h Level 2 = Level 1 + interaction with SNMPv2 agents SYMBOL 183 \f "Symbol" \s 10 \h Level 3 = Level 2 + interaction with other SNMPv2 managers autonumlgl   "Level 0" Implementations "Level 0" implementations must support all WinSNMP specifications except those which require communication with other SNMP entities, namely: SYMBOL 183 \f "Symbol" \s 10 \h SnmpSendMsg SYMBOL 183 \f "Symbol" \s 10 \h SnmpRecvMsg SYMBOL 183 \f "Symbol" \s 10 \h SnmpRegister "Level 0" implementations exist to provide SNMP message encoding and decoding services to applications which do not require the communications transport services of the WinSNMP implementation, but still require WinSNMP services, such as: SYMBOL 183 \f "Symbol" \s 10 \h Local Database Functions SYMBOL 183 \f "Symbol" \s 10 \h SnmpEncodeMsg SYMBOL 183 \f "Symbol" \s 10 \h SnmpDecodeMsg All WinSNMP implementations must include full "Level 0" support. autonumlgl   "Level 1" Implementations "Level 1" implementations support communications with SNMPv1 agents, in addition to providing full "Level 0" support. Since WinSNMP applications are structured to support SNMPv2, "Level 1" implementations must support the requisite transformations specified in the "Coexistence" document (RFC1452).  For example, if a WinSNMP application submits a GetBulkRequest PDU to a "Level 1" implementation, the WinSNMP implementation will transform this into a GetNextRequest PDU, per Section 3.1.1.(2) of RFC1452, and proceed accordingly. Note that WinSNMP always returns traps in SNMPv2 format, whether the trap emanates from an SNMPv1 agent or, as a notification, from an SNMPv2 agent.  This behavior is also defined by RFC1452. "Level 1" implementations must support the use of target agent addresses and community strings; but are not required to support any SNMPv2 mechanisms, other than the "Coexistence" transformations mentioned above. autonumlgl   "Level 2" Implementations "Level 2" implementations support communications with SNMPv2 agents, in addition to providing full "Level 1" and "Level 0" support. In particular, "Level 2" implementations must support the Party MIB and the use of parties, contexts, authentication, and privacy mechanisms, but are not required to support the Manager-to-Manager MIB or protocol operations relating to the InformRequest PDU type. autonumlgl   "Level 3" Implementations "Level 3" implementations support communications with other SNMPv2 management entities via the Manager-to-Manager MIB and protocol operations relating to the InformRequest PDU type, in addition to providing full "Level 2", "Level 1", and "Level 0" support. autonumlgl   Applications The WinSNMP API is oriented toward the writing of applications which are SNMPv2-enabled, at least in terms of their structure.  A WinSNMP application may always use the relevant PDU types defined for SNMPv2 (as specified in WinSNMP.h, the "Declarations" section of this document) with the assurance that the implementation will perform the necessary transformations--in accordance with the "Coexistence" document (RFC1452)--when communicating with an SNMPv1 agent on behalf of the application.  Likewise, a WinSNMP application will always receive Trap PDUs (via SnmpRecvMsg from the implementation) as SNMPv2 traps, even when the issuing entity is an SNMPv1 agent. Note that it is possible for WinSNMP applications to operate in such a way as to utilize the implementation merely for SNMP message encoding and decoding and to bypass the WinSNMP implementation with respect to communications with the destination entities.  In this mode, the application must perform the necessary GetResponse and Trap PDU transformations for itself, at its own discretion.  AUTONUMLGL   Transport Interface Support For everything above  Level 0 , the WinSNMP implementation conducts the communications transactions with the SNMP agents on behalf of the applications.  Nothing in the WinSNMP specification attempts to dictate how an implementation (and/or an application) will actually execute the communications process with remote entities. A number of options exist.  They are not necessarily mutually exclusive--several might be used by an implementation with one or more in the same or a different combination being used by its client applications. Possible approaches include the following:  Embedded Stack, Proprietary Stack API, Windows Sockets API, Multi-Protocol API, RPC. In the  embedded stack  approach, the implementation incorporates the transport layer, without overt reliance on any external components.  Note that in this context  embedded  simply means that it is part of the WinSNMP implementation package and  external  means  not provided by the WinSNMP provider .  In other words, an  embedded  transport could actually reside in a separate physical module (e.g., a DLL or virtual driver (VxD) of its own). Using the  proprietary stack API  approach, a WinSNMP implementation supports the development API of a transport stack vendor.  Such a technique might be used for competitive, marketing, or performance reasons (among others).  This approach can often yield access to low-level protocol elements that are sometimes not available in the vendor-independent and multi-protocol options. Windows Sockets API  (WinSock) approach affords an implementation--and, consequently its users--a very comfortable degree of independence and flexibility.   WinSock is fast becoming an industry standard for TCP/IP applications programming.  It enables stack vendors to exploit their proprietary APIs on the back end while offering application developers a single interface on the front end.  The WinSock approach is the one that is assumed (but not required) by the WinSNMP API specifications, as shown in Figure 1. Multi-Protocol API  approach allows an implementation to include support for a diverse set of transport interfaces.  The APP2SOCK.DLL supplied by Spry is an example of such an API.  Enhanced flexibility is the main advantage of this approach, while limited support for some of the lower-level details of the underlying protocols and potential performance impacts are possible disadvantages.  It is anticipated that v2 of the WinSock API will include support for multiple transport protocols (including TCP/IP, of course). Finally, the RPC approach permits implementations which function only as  mediators  between applications on the local MS Windows desktop and a remote SNMP service provider on, for example, a UNIX platform. The main point of this survey of available communications strategies is that there are options; they are not necessarily mutually exclusive; they can be mixed and matched across both WinSNMP implementations and applications. autonumlgl   Entity/Context Translation Modes WinSNMP applications have the capability of instructing the implementation to interpret entity and context arguments as either literal SNMPv1 agent address and community string, respectively, or as literal SNMPv2 party and context IDs, respectively.  An alternative to either of these modes is that in which these arguments are interpreted as user- or application-friendly names for entities and managed object collections to be dereferenced ("translated") into their respective SNMPv1 or SNMPv2 components via the implementation's local database. The three entity/context translation modes are: SNMPAPI_TRANSLATED    = Translate via Local Database look-up SNMPAPI_UNTRANSLATED_V1 = Literal transport address and community string SNMPAPI_UNTRANSLATED_V2 = Literal SNMPv2 party and context IDs The WinSNMP implementation will always identify its current default entity/context translation mode setting in the return value from the SnmpStartup function (which is idempotent).  A WinSNMP application may request a different entity/context translation mode setting at any time with the SnmpSetTranslateMode function.  An implementation may elect to not support a requested translation mode, in which case it must return an error and set SnmpGetLastError to SNMPAPI_MODE_INVALID. All WinSNMP implementations and applications are encouraged to support SNMPAPI_TRANSLATED mode as their default mode of operation, to assist in fostering bilingual (SNMPv1 and SNMPv2) applications deployment. Note that the sample code which follows in sections 2.3.1 through 2.3.4 includes literal string representations of some of the arguments to the WinSNMP functions.  This is merely for expository purposes.  In the interests of internationalization and localization--and generally good software engineering practices--application writers are encouraged to isolate all such text string values in StringTables in separate resource files or to use some similar technique to modularize such strings out of the operating logic of their applications. Also, note that context  string  arguments are passed as  octet string  structures (smiOCTETS descriptors) since SNMPv1  community strings  can contain any values, not just those from the NVT ASCII or  DisplayString  character set. autonumlgl   SNMPAPI_TRANSLATED Mode When the translation mode is set to SNMPAPI_TRANSLATED, an application will make calls similar to the following: LPCSTR entityName =  Main_Hub smiOCTETS contextName; contextName.ptr =  Traffic_Stats contextName.len = lstrlen (contextName.ptr); hAgent = SnmpStrToEntity (hSomeSessin, entityName); hView   = SnmpStrToContext (hSomeSession, const &contextName); The implementation will use its selected access method to look-up "Main_Hub" and "Traffic_Stats" in its local database and, if successful, will assemble the appropriate internal data structures and return HANDLE values for use by the application. autonumlgl   SNMPAPI_UNTRANSLATED_V1 Mode When the translation mode is set to SNMPAPI_UNTRANSLATED_V1, an application will make calls similar to the following: LPCSTR entityName =  192.151.207.34 smiOCTETS contextName; contextName.ptr =  public contextName.len = lstrlen (contextName.ptr); hAgent = SnmpStrToEntity (hSomeSessin, entityName); hView   = SnmpStrToContext (hSomeSession, const &contextName); The implementation will assume--based on the SNMPAPI_UNTRANSLATED_V1 setting for hSomeSession--that "192.151.207.34" equates to an IP address to be reached via UDP port 161, and that this value is being passed as a far pointer to a constant NULL terminated text string (LPCSTR) that it must first convert to dotted decimal notation. autonumlgl   SNMPAPI_UNTRANSLATED_V2 Mode When the translation mode is set to SNMPAPI_UNTRANSLATED_V2, an application will make calls similar to the following: LPCSTR entityName =  1.3.6.1.6.3.3.1.3.134.141.40.162.1 smiOCTETS contextName; contextName.ptr =  1.3.6.1.6.3.3.1.4.134.141.40.162.1 contextName.len = lstrlen (contextName.ptr); hAgent = SnmpStrToEntity (hSomeSessin, entityName); hView   = SnmpStrToContext (hSomeSession, const &contextName); The first string is an initialPartyID with an agent from 134.141.40.162; the second string is an intialContextID with the same agent. The implementation will assume--based on the SNMPAPI_UNTRANSLATED_V2 setting for hSomeSession--that "1.3.6.1.6.3.3.1.3.134.141.40.162.1" equates to an a PartyID instance at IP address 134.141.40.162 to be reached via UDP port 161, and that this value is being passed as a far pointer to a constant NULL terminated text string (LPCSTR) that it must first convert to an OID. autonumlgl   Local Database An SNMPv1 message includes version information and a community string, in addition to the PDU.  An SNMPv2 message includes source party, destination party, context, and authentication information, in addition to the PDU (and the entire message may optionally be encrypted).  Given these facts and the stated mission to accommodate both existing versions of SNMP, WinSNMP must meet at least the following four objectives: A WinSNMP application must have full access to all components of the SNMP message issued by the WinSNMP implementation.  At the extreme, the SnmpEncodeMsg and SnmpDecodeMsg functions enable access to and manipulation of fully-serialized, "ready-for-transport" SNMP messages. A WinSNMP application must not have to incorporate WinSNMP implementation-specific routines or data structures to utilize any of the functionality defined by WinSNMP itself.  Each WinSNMP implementation may use private mechanisms external to the WinSNMP applications, but any and all necessary interfaces to these mechanisms will be via the defined WinSNMP APIs only. A WinSNMP application must not have to know the SNMP version level of  the target SNMP entities acting in an agent role.  The WinSNMP implementation will perform any and all necessary mappings between SNMPv1 and SNMPv2 in accordance with the appropriate RFCs, and especially RFC 1452.  With respect to agent addressing, this is particular true for  TRANSLATED  mode access; for protocol operations it holds regardless of the entity/context translation mode in effect. One implication of the foregoing requirement is that the SNMPv1 message format must fit neatly within the structure adopted for the SNMPv2 message format.  This statement applies to WinSNMP "messages" only--it is not meant in any way to limit or modify anything in the "Coexistence" RFC. Taking the view that SNMPv1 message semantics can be housed within SNMPv2 message semantics, we will first focus on the SNMPv2 message components: For SNMPv2 communications, the "source party" (srcEntity) components refer to the management application and will largely be supplied by the WinSNMP implementation layer via the Local Database.  For SNMPv1 communications, srcEntity basically is a no-op. For SNMPv2 communications, the "destination party" (dstEntity) components refer to the target agent and must come, at least in part, from logically remote SNMP entities.  Given a dstEntity transport address and protocol and the assumption of at least one noAuth/noPriv "entrance" into the target agent (i.e., InitialPartyID), an application can initiate SNMP exchanges via the WinSNMP implementation.  For SNMPv1 communications, dstEntity refers to the transport address of the target agent entity. For SNMPv2 communications, the "context" identifies a collection of managed object resources accessible to a management application under the control of the target agent.  For SNMPv1 communications, the context parameter refers to "community string". A driving force behind the approach taken in this specification with respect to these issues is the need to accommodate SNMPv2 administrative and protocol constructs in a symmetrical fashion, and at the same time transparently subsume SNMPv1 administrative and protocol constructs. The major assumption is that the implementation s "local database"--at least for  TRANSLATED  mode operations--contains source party, destination party, and context entries (and possibly other data).  Consequently, the SnmpSendMsg function does not need to include "qos", "timeout", "retry", or similar values since these are available in the Local Database. autonumlgl   Sessions The "session" created by the SnmpOpen function is used to manage the link between the WinSNMP application and the WinSNMP interface implementation.  That is, the session is the unit of resource and communications management between a calling WinSNMP application and its supporting WinSNMP implementation.  A well-behaved WinSNMP application will use the session construct to logically organize its operations and to minimize resource requirements on the implementation.  The following statements summarize the role and certain attributes of WinSNMP sessions: A "session" is opened with SnmpOpen, and closed with SnmpClose. A "session-id" is returned by the SnmpOpen function to the application as a HANDLE variable, which the implementation may use internally to manage resources. An application can have multiple sessions open at one time, subject to the limitations stated below. The minimum number of concurrent sessions which an implementation must support is one. The maximum is undefined and is implementation-specific and, possibly, resource-dependent. When an application's request to open a session cannot be granted because of the limitations stated above, the implementation will return SNMPAPI_FAILURE to SnmpOpen and will set SnmpGetLastError to report SNMPAPI_ALLOC_ERROR. All WinSNMP API functions--except SnmpOpen--which return HANDLE variables will include a "session-id" handle as an input parameter, so that the implementation can use it internally to manage and account for resources on behalf of the session. HANDLE variables created under one open session can be utilized by other open sessions (if any) within a given application (task). Optionally, an implementation may internally share HANDLE variables among sessions in separate applications. Note this optional resource efficiency, if it is supported by an implementation, is totally transparent to the application. When an application closes a session by executing the SnmpClose function, all resources created on behalf of that session by the implementation, and not previously freed by the application, will be freed automatically by the implementation.  If an implementation supports the optional sharing of HANDLE variables among open sessions across multiple applications, then the resources will not be physically freed until the final open session which "created" the resources closes. Sessions may have other attributes, above and beyond those discussed above (e.g., the 'dstEntity' and 'context' interpretation modes of TRANSLATED, UNTRANSLATED_V1, and UNTRANSLATED_V2).  AUTONUMLGL   Memory Management The allocation, ownership, deallocation, and  garbage collection  of memory objects is often a troublesome issue in a complex multi-provider MS Windows programming arrangement.  It really is not a question of adequate capabilities being provided by the environment.  It is a question of understanding the options and the rules, agreeing to a division of labor, authority, and responsibility among the components; and, finally, competence and diligence in implementing such an agreement. In MS Windows programming, it is important to remember that the implementation, as a DLL, is actually just an extension of the calling application.  Applications can allocate, use, and deallocate memory; if they terminate without freeing allocated memory, MS Windows deallocates it for them automatically.  If a DLL allocates memory (without taking explicit actions to the contrary by declaring the GMEM_SHARE option), then it is actually  owned  by the currently connected application and is identical to memory allocated directly by the application.  A DLL can also deallocate application-owned memory on behalf of the calling application.  A DLL can invoke the GMEM_SHARE option (not recommended if portability to Windows-NT is desired) to allocate memory that it will  , and/or it can allocate memory out of its local dataspace to provide for  persistent objects  that might be shared among diverse applications. The WinSNMP  arrangement  includes three different kinds of memory "objects": HANDLE'd resources C-style (NULL terminated) strings Non-scalar WinSNMP API data types of variable length  AUTONUMLGL   HANDLE d Resources There are five varieties of HANDLE'd resources: Sessions Entities Contexts Protocol Data Units (PDUs) VarBindLists (VBLs) These objects are accessed via handles for two reasons: To hide their structures from the applications; and to permit implementations to optimize and/or differentiate themselves vis- -vis their construction and manipulation of these objects "behind" the API. All HANDLE'd objects are of data type  HSNMP_<object_tag>  and are always "owned" by the implementation.  An application may request their creation and may signal their eligibility for deletion and reclamation, but these operations (like all others concerning these objects) are indirect...the realization is up to the implementation. An implementation that wants to permit sharing of HANDLE d resources (most likely) allocates them out of its local data space.  If it wanted to restrict them to the calling application s scope, it would allocate them out of global memory without the GMEM_SHARE option.  Both approaches can be employed in an implementation -- for example, it might make sense to share Entity and Context objects across multiple applications, but it is less likely that Sessions, PDUs, and VarBindLists would benefit significantly from such treatment.  AUTONUMLGL   C-Style Strings The C-style (NULL terminated) strings are provided mainly for convenience to easily convert Entity and OID objects to and from the most common string representation.  The WinSNMP functions which use C-style strings are limited to:  SnmpStrToEntity, SnmpEntityToStr, SnmpStrToOid, and SnmpOidToStr.  (The inclusion of   in the name is a bit misleading in the case of the SnmpStrToContext and SnmpContextToString functions, as the  context  parameter in these functions must be an SNMP-style  octet string  to accommodate the legal data values.) The application is entirely responsible for allocating, managing, and freeing this memory, as might be appropriate to its specific operating requirements and/or circumstances.  This will require passing a   parameter to the implementation in functions which use pointers to C-style string  variables as output arguments (i.e., SnmpEntityToStr and SnmpOidToStr).  AUTONUMLGL   Descriptors There are three non-scalar WinSNMP API data types, of variable length: smiOCTETS smiOID smiVALUE. All three are structures.  The first two are both "descriptor" structures, consisting of two members: "len" and "ptr".  For smiOCTETS, "len" is an unsigned long integer (smiUINT32) value indicating the number of bytes in the subject octet string (no necessary NULL terminating byte) and "ptr" is a far pointer to a byte array containing the octet string.  For smiOID, "len" is an unsigned long integer value indicating the number of unsigned long integers in the subject OID and "ptr" is a far pointer to an array of unsigned long integers representing the OID s sub-identifiers. The smiVALUE structure is different and a bit more complex.  It too consists of just two members.  The first is an unsigned long integer indicating the "syntax" of the second member.  The second member is the union of all the possible WinSNMP API data types.  A calling application must first check the "syntax" member of a returned smiVALUE structure to know how to dereference the second member, which might be a simple scalar value or might be one of the WinSNMP API structures with defined syntax (including an smiOCTETS, or one of its derivatives such as smiIPADDR, or an smiOID).  In general, this is pretty typical SNMP API fare.  In actuality, the smiVALUE structure is not a problem--it is always of a fixed size. It is only when its  syntax  member indicates that the  value  member is either an smiOCTETS or an smiOID structure (which contain pointers to variable length data) that the memory management  agreement  becomes important.  Specifically, who assigns the pointers (i.e., allocates the memory), who fills in the "len" members, who owns these objects, and who is responsible for freeing the resources when they are no longer needed or in cases of memory shortage? Fortunately, the statement of this problem is more complex than the statement of its resolution! For input parameters, the application provides the structure and populates its members (i.e., allocates the memory for the variable length objects). For output parameters, the application again provides the structure, but the implementation populates its members (i.e., allocates the memory for the variable length objects). The application must use an appropriate functions (e.g., GlobalFreePtr) to free the memory that it has allocated for such input parameters and must use the SnmpFreeDescriptor WinSNMP function to free the memory allocated by the implementation for these output parameters. See Section   REF _Ref296104548 \* MERGEFORMAT  2.11.4. Descriptors , in Section   REF _Ref296138180 \* MERGEFORMAT  2.11. WinSNMP Data Types The combined effects of this particular  agreement  yield substantial benefits: It clearly delineates a small number of cooperative memory management requirements. It clearly assigns responsibility in each case. It reduces the likelihood of over-allocation of temporary buffer space. It reduces the likelihood of unnecessary buffer copying (from max-sized temporary buffers to right-sized working buffers). It leverages the  natural  memory management posture of MS Windows while providing independent flexibility in this area to both applications and implementations alike.  AUTONUMLGL   Summary As a general rule, the WinSNMP application is responsible for freeing all WinSNMP resources allocated via calls to the WinSNMP API using the following functions:       SnmpFree<xxx>: Entity, Context, Pdu, Vbl, Descriptor  SnmpClose: Session SnmpCleanup:       These calls are 'cumulative', in the sense that SnmpFree<xxx> frees a single specific HANDLE'd resource; SnmpClose frees all  such resources allocated to a given session within the calling task, and the session HANDLE'd resource itself; SnmpCleanup  performs (in effect) an SnmpClose on all open sessions within  the task.  Applications are encouraged to use these in the  order shown as appropriate to the application s processing logic.       It is also very important to note that every time a WinSNMP function calls results in the return of a HANDLE d object resource to the application, each and every such resource will be a new resource.  In this context,   means a unique value for that kind of resource at that instant in the calling application.  This means, for example, that it is safe--with respect to a subsequent SnmpRecvMsg call-- to free the srcEntity, dstEntity, context, and pdu resources right after calling SnmpSendMsg,  But a given app might need or want to retain them, of course.  If you built these resources for, say, a polling operation, then you will probably want to retain them for the next iteration...and in many cases you will want to match up out-bound RequestIDs with received RequestIDs.       An allocated HANDLE d object resource is never freed by the implementation except upon request by the application using one of the three types of calls outlined at the top of this sub-section or--as an optional capability of an implementation--upon ungraceful termination of an application which otherwise left resources allocated.  It is the application s responsibility to request the creation of and the deletion of all WinSNMP HANDLE d object resources.  The implementation is free to perform these operations any way it wants internally, as long as the external appearance to the application accords with this set of specifications. autonumlgl   Asynchronous Model One contemporary programming model has applications "driven" by the receipt and processing of asynchronous message-events.  This asynchronous message-driven model maps well to modern object-oriented theory, the SNMP distributed management paradigm, and the Microsoft Windows programming and runtime environments.  Likewise, although WinSNMP does not presume any particular transport mechanism for the conveyance of SNMP messages between managers and agents, it is to be noted that, fundamentally, SNMP is a datagram-based protocol, in which no actual channel (virtual circuit) is established between remote entities.  This behavior also maps well to the message-driven programming model.  For those reasons, among others, this is the programming model adopted by WinSNMP. Modern message-driven applications typically must respond to other kinds of important events, some of which may rely on synchronous relationships.  Actually, all of the functions specified in the WinSNMP API have a synchronous component--most are totally synchronous; three critical ones have an asynchronous dimension: SYMBOL 183 \f "Symbol" \s 10 \h SnmpSendMsg SYMBOL 183 \f "Symbol" \s 10 \h SnmpRecvMsg SYMBOL 183 \f "Symbol" \s 10 \h SnmpRegister Of these, SnmpRecvMsg has the most impact on asynchronous operations. The basic asynchronous model for programming with WinSNMP follows these steps: The application opens a session with the WinSNMP implementation (with the SnmpOpen function). If the application is interested in receiving traps, it indicates this (with the SnmpRegister function). The application prepares one or more PDUs for transmission to and processing by the WinSNMP implementation via WinSNMP "messages" (using SnmpCreatePdu and other PDU, Variable-Binding, and Utility functions).  The application submits one or more asynchronous requests consisting of an SNMP PDU and message "wrapper" elements (with the SnmpSendMsg function). The application receives notification that a response to a request is available or that a registered trap has occurred (via the message "channel" specified in the SnmpOpen function). The application retrieves the response (with the SnmpRecvMsg function). The application processes the response as appropriate (using application-specific logic). The application closes the WinSNMP session (with the SnmpClose function). Note that, in general, steps 2 through 7 can take place in nearly any order and at any time during program execution. autonumlgl   Polling and Retransmission Given the asynchronous nature of both SNMP itself and the WinSNMP SnmpSendMsg, SnmpRecvMsg, and SnmpRegister functions, users of this specification (i.e., implementors and applications writers) must be concerned with timeout and retry issues.  Taken together, timeout and retry will be referred to hereinafter as "retransmission".  (Note that no "back-off" mechanisms are currently included.) Applications have sole responsibility for polling:  establishing the frequency, initiating transactions, and timer management, among other things.  This ensures that applications have knowledge of the  request-id  component of the out-going PDUs. With respect to retransmission, applications clearly have the primary responsibility, regarding both policy and execution.  Implementations must provide retransmission policy support (via their local database) and may optionally provide retransmission execution support.   Accordingly, in WinSNMP applications the timeout period, in practice, refers to the elapsed time between an application's issuance of an SnmpSendMsg request and receipt of the corresponding message via the SnmpRecvMsg function.   From the perspective of the implementation, the timeout period will refer to the elapsed time between the actual sending of an SNMP request message to a destination entity and the receipt of the SNMP response message from that destination. The fundamental retransmission policy mechanism will be the Local Database.  Each potential destination entity entry in the Local Database will include--among other attributes--timeout (elapsed time in seconds) and retry (count) elements.  These values can be stored in and retrieved from the Local Database by an application with the Snmp[Get|Set]Timeout and Snmp[Get/Set]Retry functions.  At runtime, an application may elect to use, update, or ignore the default values in the Local Database.  When an implementation which supports retransmit execution is operating in retransmit mode, it must use the timeout and retry values from the Local Database for the respective destination entities. Note that none of the foregoing precludes or impedes the "out-of-the-box" mode of operation.  An implementation can (and should) "boot up" with some generic default values in its (conceptual) Local Database for use when an application initializes entities in the SNMPAPI_UNTRANSLATED_V[1|2] modes. So, for WinSNMP, the following summarizes the timeout/retry approach: The application manages the policy via the Local Database functions by storing  desired  values for each destination entity.  Optionally, the implementation may also update the  actual  observed values in its local database for subsequent use by the application in adjusting the  desired  (policy) values.. The application executes the policy, at its discretion.  That is, when it issues a request (via SnmpSendMsg) and wants to monitor the time-out event, it sets a timer (most likely using the  desired  time-out value retrieved from the local database).   If the response comes in before the timer goes off, it cancels the timer and that's the end of it.  If the timer expires, it decides then whether to retry (most likely, but not only, based on the retry count value retrieved from the local database). If, during the course of execution, the application determines that either the default time-out and/or retry values are inappropriate in can either ignore that fact, or change its runtime behavior accordingly, and/or modify the default values for the respective entities in the Local Database. It may well be, given the above, that certain "network smart" apps might populate and update the default values in the Local Database, while many more "network agnostic" applications just use the default values, whether just for its policy (when the implementation actually does the execution) or for both policy and execution purposes. Applications may request that the implementation execute the retransmission policy (using the values in the Local Database) via the SnmpSetRetransmitMode function, with (SNMPAPI_ON).  A valid response to this request by a compliant implementation is either SNMPAPI_SUCCESS or SNMPAPI_MODE_INVALID. In the former case, the application may elect to leave retransmission execution entirely to the implementation or to augment it with its own execution, if desired.  An application can use SnmpSetRetransmit again, with (SNMPAPI_OFF), to "turn off' the implementation in this regard. When the implementation executes the retransmission policy, it repeats the original request-id component in each retransmitted PDU. When the implementation responds to the SnmpSetRetransmitMode (SNMPAPI_ON) request with the SNMPAPI_MODE_INVALID error, the application must assume all responsibility for execution of the retransmission policy. A "standard" set of timer support functions for use by WinSNMP applications developers might be added to the WinSNMP specification at a future date.  AUTONUMLGL   RequestIDs The original release of the v1.1 specification indicated that the SnmpSendMsg and SnmpRecvMsg functions returned the RequestID of the associated PDU.  This proved to be an unworkable mechanism due to the need to accept a zero-valued RequestID as a legitimate value.  This v1.1a release corrects that error, to wit: RequestID of 0 must be allowed in PDUs, ergo: WinSNMP API functions cannot use RequestID as a return value, since SNMPAPI_FAILURE == 0; ergo: SnmpSendMsg and SnmpRecvMsg will return either SNMPAPI_SUCCESS [1] or SNMPAPI_FAILURE [0], not the RequestID. Applications can use the SnmpGetPduData function to retrieve a PDU's RequestID when necessary. An application can ask the implementation to generate and assign a RequestID to a PDU by passing zero in the RequestID parameter of the SnmpCreatePdu function and can then determine that value, if desired with the SnmpGetPduData function, per above. The implementation will use its best efforts to generate RequestIDs which are temporally unique internally (i.e., a simple incrementing algorithm will suffice).  It does not have to avoid conflicts with externally generated RequestIDs.  It may assign zero as a generated RequestID in the normal course of events. An application that wants to force a RequestID of zero (or any other value) can use the SnmpSetPduData function to do so. This correction required corresponding changes to the descriptive text (only) of the SnmpSendMsg and SnmpRecvMsg functions to specify the correct return values and to the SnmpCreatePdu function to explain the effect of passing RequestID=0 in this function, per above. Note that, overall, this approach is somewhat less attractive from the application's point of view, since automatic RequestID generation/assignment is a one-short deal per PDU in this scenario.  On the other hand, it is likely that most apps will want to generate their own RequestIDs (not hard and simplifies things) or just will not care (i.e., use the Session parameters to distinguish response channels anyway). autonumlgl   Error Handling All WinSNMP functions have an immediate return value.  If this value is SNMPAPI_FAILURE (0), it means that the implementation detected or encountered an error of some kind.  The application must then call the SnmpGetLastError function to retrieve the extended error information describing the specific problem encountered. The bifurcation into "common" and "context-specific" error codes in this section serves merely to allow an abbreviation of error condition descriptions in the function reference sections.  The distinction between "SNMP error codes" and "SNMP API error codes" in the "context-specific" section is somewhat more significant.  The former are fixed by the RFCs; the latter are creations of this specification. autonumlgl   Common Error Codes Any WinSNMP function can fail with any one of the following error codes returned via SnmpGetLastError: SNMPAPI_NOT_INITIALIZED SNMPAPI_ALLOC_ERROR SNMPAPI_OTHER_ERROR SNMPAPI_NOT_INITIALIZED signals that SnmpStartup was not successfully executed, either since program execution began or since SnmpCleanup successfully completed.  Note that if SnmpStartup fails, an immediate call to SnmpGetLastError (i.e., before any other WinSNMP calls) will return the error code applicable to the failure of SnmpStartup; all subsequent calls to WinSNMP functions before a successful SnmpStartup execution will fail with SNMPAPI_NOT_INITIALIZED. SNMPAPI_ALLOC_ERROR signals that the implementation was unable to obtain sufficient resources to carry out the requested action.  Applications should respond by freeing resources, or by reducing the resource requirements of the request, or by informing the user (e.g., via MessageBox or log file entry) and facilitating a graceful shutdown via SnmpClose calls and/or SnmpCleanup. SNMPAPI_OTHER_ERROR signals an unknown, undefined, or otherwise indeterminate error occurred.  Implementations may provide an optional, ancillary, and independent means of providing additional feedback to the user for subsequent problem resolution.  In most cases, applications should attempt to shutdown gracefully via SnmpClose calls and/or SnmpCleanup after receiving this error. Since each of these error conditions could arise on each and any of the WinSNMP API functions, they are documented here only.  The error information section of each function description refers to these collectively as "Common Error Codes" and documents any other error conditions which might be specific to the given function. autonumlgl   Context-Specific Error Codes The following lists are excerpted from the "Declarations" section of this document (which essentially constitutes the WinSNMP.h include file).  They are included here mainly as a place-holder for a future elaboration of each error condition, similar to what was done in the preceding section for "Common Error Codes". /* Syntax Values for Exception Conditions in SNMPv2 Response Varbinds */ #define SNMP_VALUE_NOSUCHOBJECT (ASN_CONTEXT | ASN_PRIMITIVE | 0x0) #define SNMP_VALUE_NOSUCHINSTANCE (ASN_CONTEXT | ASN_PRIMITIVE | 0x1) #define SNMP_VALUE_ENDOFMIBVIEW (ASN_CONTEXT | ASN_PRIMITIVE | 0x2) /* SNMP Error Codes Returned in Error_status Field of PDU...Not API Error Codes */ /* Error Codes Common to SNMPv1 and SNMPv2 */ #define SNMP_ERROR_NOERROR #define SNMP_ERROR_TOOBIG #define SNMP_ERROR_NOSUCHNAME #define SNMP_ERROR_BADVALUE #define SNMP_ERROR_READONLY #define SNMP_ERROR_GENERR /* Error Codes Added for SNMPv2 */ #define SNMP_ERROR_NOACCESS #define SNMP_ERROR_WRONGTYPE #define SNMP_ERROR_WRONGLENGTH #define SNMP_ERROR_WRONGENCODING #define SNMP_ERROR_WRONGVALUE #define SNMP_ERROR_NOCREATION #define SNMP_ERROR_INCONSISTENTVALUE #define SNMP_ERROR_RESOURCEUNAVAILABLE #define SNMP_ERROR_COMMITFAILED #define SNMP_ERROR_UNDOFAILED #define SNMP_ERROR_AUTHORIZATIONERROR #define SNMP_ERROR_NOTWRITABLE #define SNMP_ERROR_INCONSISTENTNAME /* WinSNMP API Function Return Codes */ #define SNMPAPI_FAILURE /* Generic error code */ #define SNMPAPI_SUCCESS /* Generic success code */ /* WinSNMP API Error Codes (for SnmpGetLastError) */ #define SNMPAPI_ALLOC_ERROR /* Error allocating memory */ #define SNMPAPI_CONTEXT_INVALID /* Invalid context parameter */ #define SNMPAPI_CONTEXT_UNKNOWN /* Unknown context parameter */ #define SNMPAPI_ENTITY_INVALID /* Invalid entity parameter */ #define SNMPAPI_ENTITY_UNKNOWN /* Unknown entity parameter */ #define SNMPAPI_INDEX_INVALID /* Invalid VBL index parameter */ #define SNMPAPI_NOOP /* No operation performed */ #define SNMPAPI_OID_INVALID /* Invalid OID parameter */ #define SNMPAPI_OPERATION_INVALID /* Invalid/unsupported operation */ #define SNMPAPI_OUTPUT_TRUNCATED /* Insufficient output buf len */ #define SNMPAPI_PDU_INVALID /* Invalid PDU parameter */ #define SNMPAPI_SESSION_INVALID /* Invalid session parameter */ #define SNMPAPI_SYNTAX_INVALID /* Invalid syntax in smiVALUE */ #define SNMPAPI_VBL_INVALID /* Invalid VBL parameter */ #define SNMPAPI_MODE_INVALID /* Invalid mode parameter */ #define SNMPAPI_SIZE_INVALID /* Invalid size/length parameter */ #define SNMPAPI_NOT_INITIALIZED /* SnmpStartup failed/not called */ #define SNMPAPI_MESSAGE_INVALID /* Invalid SNMP message format */ #define SNMPAPI_HWND_INVALID /* Invalid Window handle */ /* Others will be added as needed */ #define SNMPAPI_OTHER_ERROR /* For internal/undefined errors */  AUTONUMLGL   Transport Error Reporting In the case of errors which are detected at the time of accepting a request to send or receive a packet, these are returned synchronously by SnmpSendMsg, SnmpRecvMsg, or SnmpRegister via a return code of SNMPAPI_FAILURE (which the application must follow-up with a call to SnmpGetLastError (to retrieve the extended error code).  In the case of errors which are detected after the packet has gone out onto the wire, the WinSNMP implementation sends a packet receipt notification to the affected session and these errors are returned via an SNMPAPI_FAILURE indication from the next SnmpRecvMsg call on that session. The generic transport layer (TL) error codes for the WinSNMP/Manager API are: #define SNMPAPI_TL_NOT_INITIALIZED /* Transport layer not initialized */ #define SNMPAPI_TL_NOT_SUPPORTED /* Transport does not support protocol */ #define SNMPAPI_TL_NOT_AVAILABLE  /* Network subsystem has failed */ #define SNMPAPI_TL_RESOURCE_ERROR /* Transport resource error */ #define SNMPAPI_TL_UNDELIVERABLE  /* Destination unreachable */ #define SNMPAPI_TL_SRC_INVALID /* Source endpoint invalid */ #define SNMPAPI_TL_INVALID_PARAM  /* Input parameter invalid */ #define SNMPAPI_TL_IN_USE /* Source endpoint in use already */ #define SNMPAPI_TL_TIMEOUT /* No response within Timeout interval */ #define SNMPAPI_TL_TOO_BIG /* PDU too big for send/receive */ #define SNMPAPI_TL_OTHER /* Undefined transport error */   Specific transport layer errors are listed as appropriate in the definitions of the SnmpRegister, SnmpSendMsg, and SnmpRecvMsg functions later in this document. Implementations should attempt to map specific transport errors to one of the generic transport errors.  If no such mapping is possible, the implementation should return SNMPAPI_TL_OTHER.  This error is preferred over SNMPAPI_OTHER_ERROR, for un-mapped transport layer errors.. autonumlgl   WinSNMP Data Types The following is an excerpt from the "Declarations" section of this document (and is part of the standard WinSNMP.h include file): /* WinSNMP API Type Definitions  */ typedef  HANDLE HSNMP_SESSION,  FAR *LPHSNMP_SESSION; typedef  HANDLE HSNMP_ENTITY,   FAR *LPHSNMP_ENTITY; typedef  HANDLE HSNMP_CONTEXT,  FAR *LPHSNMP_CONTEXT; typedef  HANDLE HSNMP_PDU, FAR *LPHSNMP_PDU; typedef  HANDLE HSNMP_VBL, FAR *LPHSNMP_VBL; typedef unsigned char smiBYTE, FAR *smiLPBYTE; /* SNMP-related types from RFC1442 (SMI) */ typedef signed long smiINT, FAR *smiLPINT; typedef smiINT smiINT32, FAR *smiLPINT32; typedef unsigned long smiUINT32, FAR *smiLPUINT32; typedef struct {      smiUINT32 len;      smiLPBYTE ptr;} smiOCTETS, FAR *smiLPOCTETS; typedef const smiOCTETS FAR *smiLPCOCTETS; typedef smiOCTETS smiBITS, FAR *smiLPBITS; typedef struct {      smiUINT32   len;      smiLPUINT32 ptr;} smiOID, FAR *smiLPOID; typedef const smiOID FAR *smiLPCOID; typedef smiOCTETS smiIPADDR, FAR *smiLPIPADDR; typedef smiUINT32 smiCNTR32, FAR *smiLPCNTR32; typedef smiUINT32 smiGAUGE32, FAR *smiLPGAUGE32; typedef smiUINT32 smiTIMETICKS, FAR *smiLPTIMETICKS; typedef smiOCTETS smiOPAQUE, FAR *smiLPOPAQUE; typedef smiOCTETS smiNSAPADDR, FAR *smiLPNSAPADDR; typedef struct {         smiUINT32 hipart;         smiUINT32 lopart;} smiCNTR64, FAR *smiLPCNTR64; /* Structure used to compose a value member for a variable binding */ typedef struct { /* smiVALUE portion of VarBind */ smiUINT32 syntax; /* Insert SNMP_SYNTAX_<type> */ union { smiINT sNumber; /* SNMP_SYNTAX_INT    SNMP_SYNTAX_INT32 */ smiUINT32 uNumber; /* SNMP_SYNTAX_UINT32                                        SNMP_SYNTAX_CNTR32                                        SNMP_SYNTAX_GAUGE32                                        SNMP_SYNTAX_TIMETICKS */ smiCNTR64 hNumber; /* SNMP_SYNTAX_CNTR64 */ smiOCTETS string; /* SNMP_SYNTAX_OCTETS    SNMP_SYNTAX_BITS    SNMP_SYNTAX_OPAQUE    SNMP_SYNTAX_IPADDR    SNMP_SYNTAX_NSAPADDR */ smiOID /* SNMP_SYNTAX_OID */ smiBYTE empty; /* SNMP_SYNTAX_NULL    SNMP_SYNTAX_NOSUCHOBJECT    SNMP_SYNTAX_NOSUCHINSTANCE    SNMP_SYNTAX_ENDOFMIBVIEW */         } value; /* union */ smiVALUE, FAR *smiLPVALUE; typedef const smiVALUE FAR *smiLPCVALUE; autonumlgl   Integers The "standard" integer type used in this specification is "unsigned long" (smiUINT32).  In a few places, parameters are specified as "signed long" (smiINT) to comply with data elements defined in the respective RFCs.  (This is especially true of some of the PDU components.) autonumlgl   Pointers All pointer variables used in this specification are "far" pointers; large model programming is assumed. autonumlgl   Function Returns All return values from WinSNMP functions fall into two categories: SYMBOL 183 \f "Symbol" \s 10 \h A HANDLE to a resource allocated by the implementation on behalf of the application, including: SYMBOL 183 \f "Symbol" \s 10 \h Sessions (HSNMP_SESSION) SYMBOL 183 \f "Symbol" \s 10 \h Entities (HSNMP_ENTITY) SYMBOL 183 \f "Symbol" \s 10 \h Contexts (HSNMP_CONTEXT) SYMBOL 183 \f "Symbol" \s 10 \h PDUs (HSNMP_PDU) SYMBOL 183 \f "Symbol" \s 10 \h Variable Binding Lists (HSNMP_VBL) SYMBOL 183 \f "Symbol" \s 10 \h A long unsigned integer (smiUINT32) value representing a status (SNMPAPI_STATUS). SYMBOL 183 \f "Symbol" \s 10 \h SNMPAPI_FAILURE (equates to 0 or NULL) SYMBOL 183 \f "Symbol" \s 10 \h SNMPAPI_SUCCESS (equates to 1 or a positive count) autonumlgl   Descriptors See Section   REF _Ref296138036 \* MERGEFORMAT  2.6.3. Descriptors , in Section   REF _Ref296138066 \* MERGEFORMAT  2.6. Memory Management Two important WinSNMP data types--namely, Octet Strings and Object Identifiers--take the form of "descriptors".  A descriptor is a structure consisting of a length member ("len") and a pointer member ( ), of the appropriate type (i.e., smiLPBYTE or smiLPUINT32, respectively),  to the actual data item of interest.  Note that either of these two descriptor types can occur in the  value  member of an smiVALUE structure, as can any of the  scalar  WinSNMP types. When a descriptor which has been allocated by the application is actually populated (i.e., has its   and   members defined for it) by the implementation, the application must eventually call the SnmpFreeDescriptor function to enable the implementation to release the resources associated with   member. autonumlgl    WINDOWS SNMP INTERFACES This section comprises the function reference for WinSNMP.  In general, not a lot of significance attaches to the categorization or ordering of the functions.  Some may argue that the "Entity/Context Functions" belong in the "Local Database Functions" category, or that the "Variable Binding Functions" belong in the "PDU Functions" category.  Those, and similar assertions, could be true.  The point for now is simply not to attach any significance to the grouping or the order of appearance. SYMBOL 183 \f "Symbol" \s 10 \h Local Database Functions SYMBOL 183 \f "Symbol" \s 10 \h Communications Functions SYMBOL 183 \f "Symbol" \s 10 \h Entity/Context Functions SYMBOL 183 \f "Symbol" \s 10 \h PDU Functions SYMBOL 183 \f "Symbol" \s 10 \h Variable Binding Functions SYMBOL 183 \f "Symbol" \s 10 \h Utility Functions autonumlgl   Local Database Functions The functions in this section concern manipulation of the "local database" of SNMP administrative information. The term "database" in this context is not meant to imply any particular data storage, access, or manipulation techniques.  The WinSNMP implementation is the "owner" of the "local database" and may utilize any proprietary mechanisms it considers best, as long as all the functions defined in this section are fully supported and no additional implementation-specific functions are required of a WinSNMP application to utilize the "local database".  Compliant WinSNMP implementations may require additional implementation-specific mechanisms external to a WinSNMP application (e.g., setting an environment variable in AUTOEXEC.BAT to point to a "local database" file or adjusting settings in a private <app>.ini file). The functions in this section are: Return Type Procedure Name Parameters SNMPAPI_STATUS SnmpGetTranslateMode (OUT smiLPUINT32 nTranslateMode); SNMPAPI_STATUS SnmpSetTranslateMode (IN smiUINT32 nTranslateMode); SNMPAPI_STATUS SnmpGetRetransmitMode (OUT smiLPUINT32 nRetransmitMode); SNMPAPI_STATUS SnmpSetRetransmitMode (IN smiUINT32 nRetransmitMode); SNMPAPI_STATUS SnmpGetTimeout (IN HSNMP_ENTITY hEntity, OUT smiLPTIMETICKS nPolicyTimeout, OUT smiLPTIMETICKS nActualTimeout); SNMPAPI_STATUS SnmpSetTimeout (IN HSNMP_ENTITY hEntity, IN smiTIMETICKS nPolicyTimeout); SNMPAPI_STATUS SnmpGetRetry (IN HSNMP_ENTITY hEntity, OUT smiLPUINT32 nPolicyRetry, OUT smiLPUINT32 nActualRetry); SNMPAPI_STATUS SnmpSetRetry (IN HSNMP_ENTITY hEntity, IN smiUINT32 nPolicyRetry); autonumlgl   SnmpGetTranslateMode() The SnmpGetTranslateMode function informs the calling application as to the entity/context translation mode in effect at the time of the call.. Syntax: SNMPAPI_STATUS SnmpGetTranslateMode ( OUT smiLPUINT32 nTranslateMode); Parameter Description nTranslateMode Pointer to variable to receive the current translation mode. Returns: The SnmpGetTranslateMode function returns SNMPAPI_SUCCESS if successful.  In this case, the resultant value of nTranslateMode will be one of the following: SNMPAPI_TRANSLATED            = Translate via Local Database look-up SNMPAPI_UNTRANSLATED_V1 = Literal transport address and community string SNMPAPI_UNTRANSLATED_V2 = Literal SNMPv2 party and context IDs The SnmpGetTranslateMode function returns SNMPAPI_FAILURE if it fails.  In this case, the value of nTranslateMode is undefined and meaningless to the application, and the value of SnmpGetLastError will be set to one of the following: SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295971085 \* MERGEFORMAT  2.10.1. Common Error Codes Comments: See Section   REF _Ref295970943 \* MERGEFORMAT  2.3. Entity/Context Translation Modes autonumlgl   SnmpSetTranslateMode() The SnmpSetTranslateMode function enables the calling application to inform the implementation as the desired entity/context translation mode to use for subsequent SnmpStrToEntity and SnmpStrToContext function calls... Syntax: SNMPAPI_STATUS SnmpSetTranslateMode ( IN smiUINT32 nTranslateMode); Parameter Description nTranslateMode Value used to set the current translation mode--must be one of the following: SNMPAPI_TRANSLATED SNMPAPI_UNTRANSLATED_V1 SNMPAPI_UNTRANSLATED_V2 Returns: The SnmpSetTranslateMode function returns SNMPAPI_SUCCESS if successful.  The SnmpSetTranslateMode function returns SNMPAPI_FAILURE if it fails and the value of SnmpGetLastError will be set to one of the following: SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295971157 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_MODE_INVALID Indicates that the implementation does not support the requested translation mode. Comments: See Section   REF _Ref295971218 \* MERGEFORMAT  2.3. Entity/Context Translation Modes SNMPAPI_TRANSLATED    = Translate via Local Database look-up SNMPAPI_UNTRANSLATED_V1 = Literal transport address and community string SNMPAPI_UNTRANSLATED_V2 = Literal SNMPv2 party and context IDs Upon successful execution of the SnmpSetTranslateMode function, the requested translation mode remains in effect for all subsequent SnmpStrToEntity and SnmpStrToContext function calls until another SnmpSetTranslateMode call with a different nTranslateMode value is executed successfully. autonumlgl   SnmpGetRetransmitMode() The SnmpGetRetransmitMode function informs the calling application as to the retransmission mode in effect at the time of the call.. Syntax: SNMPAPI_STATUS SnmpGetRetransmitMode ( OUT smiLPUINT32 nRetransmitMode); Parameter Description nRetransmitMode Pointer to variable to receive the current retransmission mode. Returns: The SnmpGetRetransmitMode function returns SNMPAPI_SUCCESS if successful.  In this case, the resultant value of nRetransmitMode will be one of the following: SNMPAPI_ON   = The implementation is doing retransmission. SNMPAPI_OFF = The implementation is not doing retransmission. The SnmpGetRetransmitMode function returns SNMPAPI_FAILURE if it fails.  In this case, the value of nRetransmitMode is undefined and meaningless to the application, and the value of SnmpGetLastError will be set to one of the following: SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295971289 \* MERGEFORMAT  2.10.1. Common Error Codes Comments: See Section   REF _Ref295971340 \* MERGEFORMAT  2.8. Polling and Retransmission autonumlgl   SnmpSetRetransmitMode() The SnmpSetRetransmitMode function enables the calling application to inform the implementation as to the desired retransmission mode (i.e., timeout/retry) for subsequent SnmpSendMsg operations. Syntax: SNMPAPI_STATUS SnmpSetRetransmitMode ( IN smiUINT32 nRetransmitMode); Parameter Description nRetransmitMode Value used to set the current retransmission mode--must be one of the following: SNMPAPI_ON SNMPAPI_OFF Returns: The SnmpSetRetransmitMode function returns SNMPAPI_SUCCESS if successful.  The SnmpSetRetransmitMode function returns SNMPAPI_FAILURE if it fails and the value of SnmpGetLastError will be set to one of the following: SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295971374 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_MODE_INVALID Indicates that the implementation does not support the requested translation mode. Comments: SNMPAPI_ON   = The implementation is doing retransmission. SNMPAPI_OFF = The implementation is not doing retransmission. Changing the retransmission mode from SNMPAPI_OFF to SNMPAPI_ON has no effect on any SNMP communications initiated via SnmpSendMsg function calls which might be outstanding prior to successful return from the subject SnmpSetRetransmitMode function call.  That is, an implementation does not have to execute the retransmission policy for messages which it initially sent when the retransmission mode was set to SNMPAPI_OFF and to which it has not yet received a response.  An implementation may elect to execute the retransmission policy on behalf of such messages in this case, but this behavior is not a requirement and applications should not count on it.  The purpose of this particular specification is to enable the implementations to take maximum advantage of the SNMPAPI_OFF retransmission mode when it is in effect. When an application changes the retransmission mode from SNMPAPI_ON to SNMPAPI_OFF, the implementation should (but is not required to) cancel all further retransmission attempts for any outstanding SNMP communications operations in effect prior to the call (and, of course, must not initiate any for subsequent SnmpSendMsg functions until the application might set the mode back to SNMPAPI_ON).  Applications, however, should assume that the implementation has done so.  The reason this behavior is so specified is that it might not be possible for an implementation run through a list of outstanding SNMP communications operations and turn each one off, while also receiving new SnmpSendMsg requests and traps and notifications from prior SnmpRegister requests, without one or more previously set retransmit timers waking up.  Since this may be the "critical loop" for WinSNMP implementations, we need to ensure that the implementations can handle it efficiently. autonumlgl   SnmpGetTimeout() The SnmpGetTimeout function returns current values for the retransmission timeout value on a per-entity basis.  The timeout value is expressed in units of hundredths of seconds.  The nPolicyTimeout value refers to the timeout value currently stored in the local database for the subject agent.  The nActualTimeout value refers to the last measured or estimated response receipt interval reported by the implementation.  Syntax: SNMPAPI_STATUS SnmpGetTimeout ( IN HSNMP_ENTITY hEntity, OUT smiLPTIMETICKS nPolicyTimeout, OUT smiLPTIMETICKS nActualTimeout); Parameter Description hEntity Indicates the destination entity of interest. nPolicyTimeout Points to a variable to receive the timeout value for this entity as stored in the implementation's local database. nActualTimeout Points to a variable to receive the last measured or estimated response time interval from the destination agent. Returns: The SnmpGetTimeout function returns SNMPAPI_SUCCESS if successful.  The SnmpGetTimeout function returns SNMPAPI_FAILURE if it fails and the value of SnmpGetLastError will be set to one of the following: SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295971426 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_ENTITY_INVALID Indicates that an entity parameter is invalid. Comments: See Section   REF _Ref295971478 \* MERGEFORMAT  2.8. Polling and Retransmission Implementations may provide utilities to load initial timeout values for the retransmission policy on a per destination entity basis, or may automatically assign some initial default value.  Subsequent modifications to this value are made by applications with the SnmpSetTimeout function. Implementations may or may not return measured or estimated values for the "actual timeout" parameter to the SnmpGetTimeout function.  In the latter case, the implementation should return zero. Applications should monitor the "actual timeout" value...if it is near, equal to, or greater than then current "policy timeout" value, the latter should be increased accordingly (or other corrective action taken). autonumlgl   SnmpSetTimeout() The SnmpSetTimeout function enables an application to set the "policy timeout" value--in units of hundredths of seconds--on a per destination entity basis in the implementation's local database. Syntax: SNMPAPI_STATUS SnmpSetTimeout ( IN HSNMP_ENTITY hEntity, IN smiTIMETICKS  nPolicyTimeout); Parameter Description hEntity Indicates the destination entity of interest. nPolicyTimeout Indicates the timeout value for this entity to be stored in the implementation's local database. Returns: The SnmpSetTimeout function returns SNMPAPI_SUCCESS if successful.  The SnmpSetTimeout function returns SNMPAPI_FAILURE if it fails and the value of SnmpGetLastError will be set to one of the following: SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295971511 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_ENTITY_INVALID Indicates that an entity parameter is invalid. Comments: See Section   REF _Ref295971544 \* MERGEFORMAT  2.8. Polling and Retransmission The timeout value is expressed in units of hundredths of seconds.  If this value is zero, and both the application and the implementation agree to SnmpSetRetransmitMode (SNMPAPI_ON), then the implementation will select an operating value for this parameter when actually executing the retransmission policy. autonumlgl   SnmpGetRetry() The SnmpGetRetry function returns current values for the retransmission retry value on a per-entity basis.  The retry value is expressed as a unit count.  The nPolicyRetry value refers to the retry value currently stored in the local database for the subject agent.  The nActualRetry value refers to the last measured or estimated response retry count reported by the implementation.  Syntax: SNMPAPI_STATUS SnmpGetRetry ( IN HSNMP_ENTITY  hEntity, OUT smiLPUINT32  nPolicyRetry, OUT smiLPUINT32   nActualRetry); Parameter Description hEntity Indicates the destination entity of interest. nPolicyRetry Points to a variable to receive the retry count value for this entity as stored in the implementation's local database. nActualRetry Points to a variable to receive the last measured or estimated response retry count from the destination agent. Returns: The SnmpGetRetry function returns SNMPAPI_SUCCESS if successful.  The SnmpGetRetry function returns SNMPAPI_FAILURE if it fails and the value of SnmpGetLastError will be set to one of the following: SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295971601 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_ENTITY_INVALID Indicates that an entity parameter is invalid. Comments: See Section   REF _Ref295971630 \* MERGEFORMAT  2.8. Polling and Retransmission Implementations may provide utilities to load initial retry count values for the retransmission policy on a per destination entity basis, or may automatically assign some initial default value.  Subsequent modifications to this value are made by applications with the SnmpSetRetry function. Implementations may or may not return measured or estimated values for the "actual retry" parameter to the SnmpGetRetry function.  In the latter case, the implementation should return zero. Applications should monitor the "actual retry" value...if it is near, equal to, or greater than then current "policy retry" value, the latter should be increased accordingly (or other corrective action taken). autonumlgl   SnmpSetRetry() The SnmpSetRetry function enables an application to set the "policy retry" count on a per destination entity basis in the implementation's local database. Syntax: SNMPAPI_STATUS SnmpSetRetry ( IN HSNMP_ENTITY hEntity, IN smiUINT32  nPolicyRetry); Parameter Description hEntity Indicates the destination entity of interest. nPolicyRetry Indicates the retry count for this entity to be stored in the implementation's local database. Returns: The SnmpSetRetry function returns SNMPAPI_SUCCESS if successful.  The SnmpSetRetry function returns SNMPAPI_FAILURE if it fails and the value of SnmpGetLastError will be set to one of the following: SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295971660 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_ENTITY_INVALID Indicates that an entity parameter is invalid. Comments: See Section   REF _Ref295971688 \* MERGEFORMAT  2.8. Polling and Retransmission The retry value is expressed as a simple unit count.  If this value is zero, and the application and the implementation have agreed to SnmpSetRetransmitMode (SNMPAPI_ON), then the implementation will select an operating value for this parameter when actually executing the retransmission policy. autonumlgl   Communications Functions The functions in this section concern communications between the calling WinSNMP application and the serving WinSNMP implementation.  Communications to and from other management entities--whether they reside on the local machine, on a connected LAN or WAN, or an internet--are handled by the WinSNMP implementation on behalf of the WinSNMP application, and without any overt orchestration by the latter. The functions in this section are: Return Type Procedure Name Parameters SNMPAPI_STATUS SnmpStartup (OUT smiLPUINT32 nMajorVersion, OUT smiLPUINT32 nMinorVersion, OUT smiLPUINT32 nLevel, OUT smiLPUINT32 nTranslateMode, OUT smiLPUINT32 nRetransmitMode); SNMPAPI_STATUS SnmpCleanup (void); HSNMP_SESSION SnmpOpen (IN HWND hWnd, IN UINT wMsg); SNMPAPI_STATUS SnmpClose (IN HSNMP_SESSION session); SNMPAPI_STATUS SnmpSendMsg (IN HSNMP_SESSION session, IN HSNMP_ENTITY srcEntity, IN HSNMP_ENTITY dstEntity, IN HSNMP_CONTEXT context, IN HSNMP_PDU pdu); SNMPAPI_STATUS SnmpRecvMsg (IN HSNMP_SESSION session, OUT LPHSNMP_ENTITY srcEntity, OUT LPHSNMP_ENTITY dstEntity, OUT LPHSNMP_CONTEXT  context OUT LPHSNMP_PDU pdu); SNMPAPI_STATUS SnmpRegister (IN HSNMP_SESSION session, IN HSNMP_ENTITY srcEntity, IN HSNMP_ENTITY dstEntity, IN HSNMP_CONTEXT context, IN smiLPCOID notification, IN smiUINT32 state); autonumlgl   SnmpStartup() The SnmpStartup function notifies the implementation that the calling application is going to use its services, enabling the implementation to perform any required start-up procedures and allocations and to return some useful housekeeping information to the application.   Syntax: SNMPAPI_STATUS SnmpStartup ( OUT smiLPUINT32 nMajorVersion, OUT smiLPUINT32 nMinorVersion, OUT smiLPUINT32 nLevel, OUT smiLPUINT32 nTranslateMode OUT smiLPUINT32 nRetransmitMode); Parameter Description nMajorVersion Pointer to variable to receive the major version number of the WinSNMP API implemented. nMinorVersion  Pointer to variable to receive the minor version number of the WinSNMP API implemented. nLevel  Pointer to variable to receive the highest level of SNMP communications supported by the implementation. nTranslateMode Pointer to variable to receive the default entity/context translation mode in effect for the implementation. nRetransmitMode Pointer to variable to receive the default retransmission mode in effect for the implementation. Returns: Upon success, the return value will be SNMPAPI_SUCCESS.  In this case, the output parameters will contain appropriate values, as follows: nMajorVersion will contain the major version number of the WinSNMP API implemented--the only legal value at this time is 1 (v1.nMinorVersion). nMinorVersion will contain the minor version number of the WinSNMP API implemented--legal values at this time are 0 (v1.0) and 1 (v1.1). nLevel will contain the highest level of SNMP communications supported by the implementation.  This value may be one of the following: SNMPAPI_NO_SUPPORT    = "Level 0" ( Message builder) SNMPAPI_V1_SUPPORT     = "Level 1" (SNMPv1 agents) SNMPAPI_V2_SUPPORT     = "Level 2" (SNMPv2 agents) SNMPAPI_M2M_SUPPORT = "Level 3" (Manager-to-Manager) nTranslateMode  will contain the current default mode of translation of the entity and context parameters when used as inputs to SnmpStrToEntity and SnmpStrToContext functions.  This value may be one of the following: SNMPAPI_TRANSLATED            = Friendly names for translation via the Local Database SNMPAPI_UNTRANSLATED_V1 = Literal SNMPv1 transport address and community string SNMPAPI_UNTRANSLATED_V2 = Literal SNMPv2 partyID and contextID nRetransmitMode will contain the current default retransmission mode in effect for the implementation.  This value may be one of the following: SNMPAPI_OFF = The implementation is not executing the retransmission policy SNMPAPI_ON   = The implementation is executing the retransmission policy If this call fails, it will return SNMPAPI_FAILURE, and the application must use SnmpGetLastError to determine the reason. SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295971741 \* MERGEFORMAT  2.10.1. Common Error Codes Comments: Note:  Every WinSNMP application must call SnmpStartup at least once and this call must precede any other WinSNMP API function call. See Section   REF _Ref295971806 \* MERGEFORMAT  2.1. Levels of SNMP Support When this call fails, the application must not make any further WinSNMP API calls, other than SnmpGetLastError and, if appropriate, retries to SnmpStartup.  If an application calls other WinSNMP API functions without a preceding successful SnmpStartup, the implementation should, if possible, return SNMPAPI_NOT_INITIALIZED. An application which receives SNMPAPI_FAILURE and SNMP_ALLOC_ERROR in response to SnmpStartup may elect to wait or do other tasks and try again later in the hope that the implementation will have adequate free resources. SnmpStartup is idempotent.  This means that an application can call it multiple times with impunity.  Multiple SnmpStartup calls do not require multiple SnmpCleanup calls.  Every application must call SnmpStartup at least once, before any other WinSNMP API call, and must call SnmpCleanup at least once, as the last WinSNMP API call. autonumlgl   SnmpCleanup() The SnmpCleanup function informs the implementation that the calling application is disconnecting and no longer requires any open resources which might be allocated to it by the implementation.  The implementation will deallocate all resources allocated to the application, unless they have also been allocated to other active applications. Syntax: SNMPAPI_STATUS SnmpCleanup (void); Returns: The SnmpCleanup function returns SNMPAPI_SUCCESS if successful.  Every subsequent WinSNMP API function call--until another successful SnmpStartup call--will return SNMPAPI_FAILURE with SnmpGetLastError set to report SNMPAPI_NOT_INITIALIZED. The SnmpCleanup function returns SNMPAPI_FAILURE if it fails.  The application should behave as though it had returned  SNMPAPI_SUCCESS.  As an additional step the application could call SnmpGetLastError to ascertain the reason for failure: SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295971835 \* MERGEFORMAT  2.10.1. Common Error Codes Comments: Note:  It is the responsibility of an application to use the respective SnmpFree<xxx> functions to free specific resources created an its behalf and to use SnmpClose to clean-up after every session opened via SnmpOpen.  However, in the event that an application must perform an emergency exit and call SnmpCleanup without performing those steps, an implementation must perform all necessary clean-up of any resources under its control which were created on behalf of or otherwise allocated to that application.  Even in this emergency situation, however, the application must call SnmpCleanup to enable this functionality in the implementation. autonumlgl   SnmpOpen() The SnmpOpen function enables the implementation to allocate and initialize memory, resources, and/or communications mechanisms and data structures for the application.  The application will continue to use the "session identifier" returned by the implementation in subsequent WinSNMP function calls to facilitate resource accounting on a per session basis.  This mechanism will enable the implementation to perform an orderly release of resources in response to a subsequent SnmpClose function call for a given session. Syntax: HSNMP_SESSION SnmpOpen ( IN HWND  hWnd, IN UINT  wMsg); Parameter Description Identifies the application's notification window. Identifies the application's notification message. Returns: If the function is successful, the return value is a HANDLE which identifies the WinSNMP session opened by the implementation on behalf of the calling application.  If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295971875 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_HWND_INVALID  The hWnd parameter is not a valid window handle. Comments: See Section   REF _Ref295971908 \* MERGEFORMAT  2.5. Sessions An application can open multiple sessions.  Each such session for the same hWnd should provide a different wMsg, but this is not required.  A successful SnmpOpen call using always returns a unique session handle (with respect to all other currently open sessions for the calling application). The hWnd parameter specifies the window handle to be notified when an asynchronous request completes or trap/notification occurs and the wMsg parameter specifies the message number that the window will be sent.  Upon receipt of this message, the application should call SnmpRecvMsg to retrieve the subject PDU for immediate or subsequent processing. In other programming models (e.g., synchronous, CLI-driven, or "curtained" applications), the WinSNMP implementation may interpret hWnd and hMsg differently.  Likewise, the session model may be used to facilitate multi-threaded programming in supporting environments. Note:  A well-behaved WinSNMP application will call SnmpClose for each session opened by SnmpOpen.  When an emergency exit is required of the application, it must at least call SnmpCleanup.  A well-behaved WinSNMP implementation must react to an SnmpCleanup call as though it were a series of SnmpClose calls for each open session allocated to the calling application. autonumlgl   SnmpClose() The SnmpClose function causes the implementation to deallocate and/or close memory, resources, communications mechanisms and data structures associated with the specified session, on behalf of the calling application. Syntax: SNMPAPI_STATUS SnmpClose ( IN HSNMP_SESSION session); Parameter Description session A handle specifying the session to close. Returns: SNMPAPI_SUCCESS if the function successfully closes the WinSNMP session If SnmpClose fails, it will return SNMPAPI_FAILURE.  Use SnmpGetLastError to obtain extended error information. SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295971956 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_SESSION_INVALID Indicates session parameter is invalid. Comments: Closing a session on which asynchronous requests are outstanding will cause any outstanding requests and/or replies for that session to be discarded by the implementation. Note:  A well-behaved WinSNMP application will call SnmpClose for each session opened by SnmpOpen.  When an emergency exit is required of the application, it must at least call SnmpCleanup.  A well-behaved WinSNMP implementation must react to an SnmpCleanup call as though it were a series of SnmpClose calls for each open session allocated to the calling application. autonumlgl   SnmpSendMsg() The SnmpSendMsg function requests the specified PDU be transmitted to the destination entity, using the specified context and--for SNMPv2 communications--the designated source entity When a transmission request is received by the implementation via the SnmpSendMsg function, the WinSNMP implementation determines which version of SNMP and which transport to use based on its own capabilities and the corresponding properties associated with the requesting session and with the remote entity which holds the context to be accessed, based on values in the Local Database. Syntax: SNMPAPI_STATUS SnmpSendMsg ( IN  HSNMP_SESSION session, IN HSNMP_ENTITY srcEntity, IN HSNMP_ENTITY dstEntity, IN HSNMP_CONTEXT context, IN  HSNMP_PDU pdu); Parameter Description session  Identifies the session that will perform the operation.   srcEntity Identifies the subject management entity. dstEntity Identifies the target management entity. context Identifies the target context of interest. Identifies the SNMP protocol data unit containing the operation. Returns: If the function is successful, the return value is SNMPAPI_SUCCESS. If the function fails, the return value is SNMPAPI_FAILURE.  Use SnmpGetLastError to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295971999 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_SESSION_INVALID Indicates that a session parameter is invalid. SNMPAPI_ENTITY_INVALID Indicates that an entity parameter is invalid. SNMPAPI_CONTEXT_INVALID Indicates that the context parameter is invalid. SNMPAPI_PDU_INVALID Indicates that the PDU parameter is invalid. SNMPAPI_OPERATION_INVALID Indicates that the PDU_type element is inappropriate for the destination entity. SNMPAPI_TL_NOT_INITIALIZED       Transport layer not initialized SNMPAPI_TL_NOT_SUPPORTED        Transport does not support protocol SNMPAPI_TL_NOT_AVAILABLE         Network subsystem has failed SNMPAPI_TL_RESOURCE_ERROR        Transport resource error SNMPAPI_TL_SRC_INVALID           Source endpoint invalid SNMPAPI_TL_INVALID_PARAM         Invalid parameter to transport call SNMPAPI_TL_PDU_TOO_BIG           PDU was too big for transport SNMPAPI_TL_OTHER An undefined transport error occurred Comments: See Section   REF _Ref295972073 \* MERGEFORMAT  2.2. Transport Interface Support , Section   REF _Ref295972168 \* MERGEFORMAT  2.7. Asynchronous Model , Section   REF _Ref295971340 \* MERGEFORMAT  2.8. Polling and Retransmission , and Section   REF _Ref332606533 \* MERGEFORMAT  2.9. RequestIDs  for related background information. This function returns immediately.  If the return indicates an error, SnmpGetLastError should be called immediately to find out the error type.  When the asynchronous request completes, the hWnd specified in the SnmpOpen call is sent the wMsg specified.  The application should call SnmpRecvMsg with this HSNMP_SESSION to retrieve the results from the request. Note:  It is the responsibility of the WinSNMP implementation to verify the correctness of the PDU structure (and other arguments) and to return failure to the caller and an extended error code via SnmpGetLastError.  For example, for a PDU_type other than SNMP_PDU_GETBULK and SNMP_PDU_RESPONSE (if allowed), passed values (other than zero) for error_status and/or error_index would constitute an invalid PDU structure and the implementation should return SNMPAPI_FAILURE and set SnmpGetLastError to report SNMPAPI_PDU_INVALID. Note:  An application may assign a RequestID to a PDU at any time via the SnmpCreatePdu or SnmpSetPduData functions.  If the RequestID component is zero at the time of the SnmpCreatePdu call, the implementation will assign a non-zero RequestID to the PDU.  An application that wants to use a zero-valued RequestID must set it to that value with the SnmpSetPduData function. Note:  As SNMP replies do not necessarily come back in the same order as requests were sent, the application should check the RequestID of the received message to match it with the appropriate request. If an SNMPv2 feature is requested, but the dstEntity implies an entity using SNMPv1, then the down-grading procedures defined in the SNMPv2 "coexistence" specification (RFC1452) are used.  If down-grading is not possible (e.g., an InformRequest-PDU directed at an SNMPv1 agent), then the function will fail and SnmpGetLastError will return SNMPAPI_OPERATION_INVALID. autonumlgl   SnmpRecvMsg() The SnmpRecvMsg function retrieves the results from a completed asynchronous request made on a given HSNMP_SESSION.  It also receives traps registered for that session. Syntax: SNMPAPI_STATUS SnmpRecvMsg ( IN  HSNMP_SESSION session, OUT LPHSNMP_ENTITY srcEntity, OUT LPHSNMP_ENTITY dstEntity, OUT LPHSNMP_CONTEXT   context OUT LPHSNMP_PDU pdu); Parameter Description session  Specifies the session that will receive the SNMP message. srcEntity Identifies the entity (agent role) which sent the message. dstEntity Identifies the entity (manager role) which is to receive the message. context Identifies the context from which the srcEntity issued the message. Identifies the PDU component of the received message. Returns: If the function is successful, the return value is SNMPAPI_SUCCESS, and the OUT parameters are populated with their corresponding values. If the function fails, the return value is SNMPAPI_FAILURE.  Note that for the Transport Layer (TL) errors, the OUT parameters are populated with their corresponding values to enable applications to recover gracefully.  Use the SnmpGetLastError function to obtain extended error information.     SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_SESSION_INVALID Indicates that the session parameter is invalid. SNMPAPI_NOOP Indicates that this session has no messages in its queue at this time SNMPAPI_TL_NOT_INITIALIZED       Transport layer not initialized SNMPAPI_TL_NOT_SUPPORTED        Transport does not support protocol SNMPAPI_TL_NOT_AVAILABLE         Network subsystem has failed SNMPAPI_TL_RESOURCE_ERROR        Transport resource error SNMPAPI_TL_UNDELIVERABLE         Destination unreachable SNMPAPI_TL_SRC_INVALID           Source endpoint invalid SNMPAPI_TL_INVALID_PARAM         Invalid parameter to transport call SNMPAPI_TL_PDU_TOO_BIG           PDU was too big for transport SNMPAPI_TL_TIMEOUT               No response within Timeout Interval SNMPAPI_TL_OTHER                 Undefined transport error         Comments: See Section   REF _Ref295972073 \* MERGEFORMAT  2.2. Transport Interface Support , Section   REF _Ref295972168 \* MERGEFORMAT  2.7. Asynchronous Model , Section   REF _Ref295971340 \* MERGEFORMAT  2.8. Polling and Retransmission , and Section   REF _Ref332606533 \* MERGEFORMAT  2.9. RequestIDs  for related background information. The implementation is only required to deliver information via SnmpRecvMsg that it has access to in the SNMP message it received from the transport layer.  For SNMPv2, all components are included in the SNMP message itself.  For SNMPv1, an implementation  has several choices:  It might have access to additional transport layer data and elect to use that; it can probably associate an in-bound GetResponse PDU with an out-bound request PDU and use the srcEntity and dstEntity values from that; or it can return NULL for components missing from the received SNMP message. The application is responsible for freeing the HANDLE object resources returned by this function when it is no longer needed by the application, by calling the SnmpFreePdu, SnmpFreeEntity, and SnmpFreeContext functions when appropriate. Note that there are four HANDLE objects instantiated by a successful SnmpRecvMsg operation (i.e., the varbindlist component of the returned PDU is not instantiated until called for by the application via the SnmpGetPduData function. Replies are not necessarily received in the same order as their originating requests were sent.  For traps received from SNMPv1 entities, in addition to mapping them to SNMPv2 format, the implementation must assign a non-zero RequestID.  A RequestID value delivered via trap notification can possibly duplicate a RequestID used by an application on a request PDU; applications need to check for this occurrence. When a trap is delivered by SnmpRecvMsg, it is returned in the SNMPv2 format, even if a SNMPv1 entity generated the trap.  The SNMPv2 "coexistence" specification, as described in RFC 1452, specifies the mapping rules between the SNMPv1 and SNMPv2 trap formats.  However, for the convenience of management applications, the final variable binding for a SNMPv1-generated trap will always be snmpTrapEnterpriseOID.0, even if the trap is a generic trap such as coldStart.  See   REF _Ref296141175 \* MERGEFORMAT  Appendix A. Mapping Traps Between SNMPv1 and SNMPv2 autonumlgl   SnmpRegister() The SnmpRegister function registers the application's desire to receive or discontinue trap and inform notifications from the specified entity of interest (dstEntity), which will act in an agent role. Syntax: SNMPAPI_STATUS SnmpRegister ( IN HSNMP_SESSION session, IN HSNMP_ENTITY srcEntity, IN HSNMP_ENTITY dstEntity, IN HSNMP_CONTEXT context, IN smiLPCOID  notification, IN smiUINT32 status); Parameter Description session Identifies the session which is interested in registering. srcEntity Identifies the management entity (manager role) of interest--this will be the trap recipient.  (This is the  source  of the notification request.) dstEntity Identifies the management entity (agent role) of interest--this will be the trap sender.  (This is the  target  of the notification request.) context Identifies the context of interest.  notification Identifies the trap/notification OID matching sequence to be registered or un-registered. status Indicates whether to register (SNMPAPI_ON) or un-register (SNMPAPI_OFF) for the subject notification.. Returns: If the function is successful, the return value is SNMPAPI_SUCCESS. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.  SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_SESSION_INVALID Indicates that the session parameter is invalid. SNMPAPI_ENTITY_INVALID Indicates that the entity parameter is invalid. SNMPAPI_CONTEXT_INVALID Indicates that the context parameter is invalid. SNMPAPI_OID_INVALID Indicates that the notification parameter is invalid. SNMPAPI_TL_NOT_INITIALIZED Transport layer not initialized SNMPAPI_TL_IN_USE Trap port not available SNMPAPI_TL_NOT_AVAILABLE Network subsystem has failed Comments: In WinSNMP all traps are delivered to the applications are SNMPv2  traps.  If an implementation receives an SNMPv1 trap from an SNMPv1 agent, it must convert it to an SNMPv2 trap in accordance with RFC 1452 (the  Coexistence  document).  REF _Ref296138582 \* MERGEFORMAT  Appendix A. Mapping Traps Between SNMPv1 and SNMPv2 Notifications, traps or informs, are defined using OBJECT IDENTIFIERs, as specified in SNMPv2. Hence, an application interested in receiving coldStart traps should construct an OBJECT IDENTIFIER corresponding to this trap based upon the SNMPv2 MIB (RFC 1450) and use this as the notification parameter. The value of the notification parameter is used for pattern matching against the OIDs of received traps and notifications.  That is, if the first   sub-ids of a received SnmpTrapOID match all the sub-ids ( ) of a notification value passed to SnmpRegister, than that SnmpTrapOID is a match.  Accordingly, a  received SnmpTrapOID with fewer sub-ids than a given notification parameters must fail the matching process with respect to that particular notification parameter. An application may pass NULL for any or all of the srcEntity, dstEntity, context, and notification parameters.  The significance of NULL in any of these parameters is, effectively, to tell the implementation to not filter out any received traps or notifications on the basis of this parameter. If the notification parameter is NULL, then the application is indicating that it is interested in registering or unregistering for any and all notifications from the dstEntity, as indicated by the status parameter. If the status parameter contains any value other than SNMPAPI_OFF or SNMPAPI_ON, it will be treated as though it were SNMPAPI_ON. Upon receipt of a trap/notification, the hWnd parameter specified in the SnmpOpen call for the registered session is sent the wMsg specified. The application should call SnmpRecvMsg with this session to retrieve the appropriate results. Note that it is the responsibility of a Level 3 implementation to acknowledge the receipt of an InformRequest-PDU.  This tells the issuing management entity that the inform made it to the implementation "platform", but not necessarily to any particular application(s). In the case where a NULL dstEntity parameter to SnmpRegister results in the implementation creating an entity object for the srcEntity parameter on a future SnmpRecvMsg call, the entity will "belong" to the application as though it had caused its creation with SnmpStrToEntity.  Put differently, the behavior in this respect will be the same as for SnmpDecodeMsg.  This is equally true--although perhaps less likely to occur--with respect to the srcEntity and context parameters as well. Note that this functionality relates to [not] filtering traps/notifications received by the implementation.  It does not address the issue of how such traps/notifications get directed to the implementation in the first place.  This is assumed to occur "out-of-band" from the perspective of application making use of NULL filtering parameters as described above. autonumlgl   Entity/Context Functions The functions in this section enable the application to use human-oriented string identifiers for the entity and context "objects" and concepts, while permitting the WinSNMP implementation to adopt proprietary repository, access method, and runtime representation strategies vis- -vis the "local database", entities, parties, and contexts. The functions in this section are: Return Type Procedure Name Parameters HSNMP_ENTITY SnmpStrToEntity  (IN HSNMP_SESSION session, IN LPCSTR  entity); SNMPAPI_STATUS SnmpEntityToStr  (IN HSNMP_ENTITY entity, IN smiUINT32 size, OUT LPSTR string); SNMPAPI_STATUS SnmpFreeEntity  (IN HSNMP_ENTITY entity); HSNMP_CONTEXT SnmpStrToContext  (IN HSNMP_SESSION session, IN smiLPCOCTETS string); SNMPAPI_STATUS SnmpContextToStr  (IN HSNMP_CONTEXT context, OUT smiLPOCTETS string); SNMPAPI_STATUS SnmpFreeContext  (IN HSNMP_CONTEXT context); autonumlgl   SnmpStrToEntity() The SnmpStrToEntity function accepts a pointer to a null-terminated text string identifying an entity of interest and, if successful, returns a handle to an implementation-specific representation of entity information.  Note that the resulting entity handle may be used as either a srcEntity value or as a dstEntity value.  Note, also, that the semantics of the input string are governed by the value of entity/context translation mode in effect at the time of the call. Syntax:  HSNMP_ENTITY SnmpStrToEntity ( IN HSNMP_SESSION session, IN LPCSTR  entity); Parameter Description session Handle of the allocating session. entity Pointer to a NULL-terminated text string identifying the management entity of interest.  Returns: If the function is successful, the return value is an HSNMP_ENTITY handle. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_SESSION_INVALID Indicates an invalid session handle.  SNMPAPI_ENTITY_UNKNOWN Indicates entity parameter is unknown. Comments: See Section   REF _Ref296070774 \* MERGEFORMAT  2.3. Entity/Context Translation Modes When the application no longer needs to utilize this entity handle, the SnmpFreeEntity function should be called to release the resources associated with it. When the current entity/context translation mode is SNMPAPI_TRANSLATED, the "entity" parameter is assumed to be a user-friendly textual name to be de-referenced via the Local Database. When the current entity/context translation mode is SNMPAPI_UNTRANSLATED_V1, the "entity" parameter is assumed to be a literal transport address (in textual form).  The implementation will attempt to identify Local Database resources associated with this SNMPv1 "address" and will supply working defaults when no such entry exists in the Local Database.  This is to enable "out-of-the-box" SNMPv1/UDP operation with WinSNMP. When the current entity/context translation mode is SNMPAPI_UNTRANSLATED_V2, the "entity" parameter is assumed to be a literal PartyID (in textual form).  The implementation will attempt to identify Local Database resources associated with this SNMPv2 "party" and will supply working defaults when no such entry exists in the Local Database.  This is to enable "out-of-the-box" SNMPv2/ InitialPartyID operation with WinSNMP. autonumlgl   SnmpEntityToStr() The SnmpEntityToStr function returns a string value identifying an entity. Syntax: SNMPAPI_STATUS SnmpEntityToStr ( IN HSNMP_ENTITY entity, IN smiUINT32 size, OUT LPSTR  string); Parameter Description entity A handle specifying an entity. The size of the buffer the application is providing to contain the string. string Points to a buffer that will receive the NULL-terminated string that identifies the management entity. Returns: If the function is successful, the return value is the number of bytes, including the NULL terminating byte, output to "string"--this value may be less than or equal to "size", but not greater. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information. SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_ENTITY_INVALID Indicates entity parameter is unknown. SNMPAPI_OUTPUT_TRUNCATED Indicates that the buffer was too small. Comments: See Section   REF _Ref296070774 \* MERGEFORMAT  2.3. Entity/Context Translation Modes Note that the current setting of the entity/context translation mode affects this function: If the setting is SNMPAPI_TRANSLATED, then the implementation returns the user-friendly textual name of this entity from the Local Database.  If no such name exists in the Local Database, then the function returns either of the following, depending upon whether the entity is known to be SNMPv1 or SNMPv2. If the setting is SNMPAPI_UNTRANSLATED_V1 and the subject entity is an SNMPv1 creature, then the implementations returns the transport address of the entity (in textual form).  If the subject entity is an SNMPv2 creature, then the implementation behaves as though the entity/context translation mode setting were SNMPAPI_UNTRANSLATED_V2 for the purposes of this call only. If the setting is SNMPAPI_UNTRANSLATED_V2 and the subject entity is an SNMPv2 creature, then the implementations returns the PartyID of the entity (in textual form).  If the subject entity is an SNMPv1 creature, then the implementation behaves as though the entity/context translation mode setting were SNMPAPI_UNTRANSLATED_V1 for the purposes of this call only. autonumlgl   SnmpFreeEntity() The SnmpFreeEntity function releases resources associated with a entity returned by the SnmpStrToEntity function. Syntax: SNMPAPI_STATUS SnmpFreeEntity ( IN HSNMP_ENTITY entity); Parameter Description entity An entity handle to be released. Returns: If the function is successful, the return value is SNMPAPI_SUCCESS. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information. SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_ENTITY_INVALID Indicates entity parameter is invalid. Comments: Un-freed resources created on behalf of the application will be freed by the implementation upon execution of an associated SnmpClose function or upon execution of an SnmpCleanup function.  Nonetheless, a well-behaved WinSNMP application will individually free all such resources using the atomic "free" functions.  The reason for this is to eliminate or, at least, minimize any "batch-like" loads on the implementation, so that other applications can be serviced in a timely fashion. autonumlgl   SnmpStrToContext() The SnmpStrToContext function accepts an OCTET STRING naming the collection of managed objects (or  profile ) of interest (for SNMPAPI_TRANSLATED mode), a community string (for SNMPAPI_UNTRANSLATED_V1 mode), or a contextID (for SNMPAPI_UNTRANSLATED_V2 mode) and returns a handle to an implementation-specific representation of context information for use with the SnmpSendMsg and SnmpRegister functions. Syntax:  HSNMP_CONTEXT SnmpStrToContext ( IN HSNMP_SESSION session, IN smiLPCOCTETS string); Parameter Description session Handle of the allocating session. string Pointer to an smiOCTETS descriptor identifying a collection of managed objects, community string, or contextID. Returns: If the function is successful, the return value is an HSNMP_CONTEXT handle. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.  SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_SESSION_INVALID Indicates an invalid session handle. SNMPAPI_CONTEXT_INVALID Indicates that the string descriptor is invalid (e.g., len and/or ptr member is NULL).  SNMPAPI_CONTEXT_UNKNOWN Indicates that the value referenced in the string descriptor is unknown. Comments: See Section   REF _Ref296070774 \* MERGEFORMAT  2.3. Entity/Context Translation Modes Note:  The smiOCTETS descriptor used for the string parameter in the SnmpStrToContext function is both allocated and populated by the application.  Hence, SnmpFreeDescriptor should not be called to free the memory associated with the ptr member of this descriptor. Note:   Strings  referenced in descriptors (such as an smiOCTETS structure) do not require a NULL terminating byte.  Such a string can be used in an IN smiOCTETS parameter by merely setting the len member to ignore it. When the application no longer needs to utilize this context handle, the SnmpFreeContext function should be called to release the resources associated with it. Note that the current setting of the entity/context translation mode affects this function: When the current entity/context translation mode is SNMPAPI_TRANSLATED, the "string" parameter is assumed to describe a user-friendly name (in textual form) to be de-referenced via the Local Database. When the current entity/context translation mode is SNMPAPI_UNTRANSLATED_V1, the "string" parameter is assumed to describe a literal community string (which may contain non-printable ASCII byte values).  When the current entity/context translation mode is SNMPAPI_UNTRANSLATED_V2, the "string" parameter is assumed to describe a literal ContextID (in textual form).  The implementation will attempt to identify Local Database resources associated with this SNMPv2 "context" and will supply working defaults when no such entry exists in the Local Database.  This is to enable "out-of-the-box" SNMPv2/ InitialContextID operation with WinSNMP. autonumlgl   SnmpContextToStr() The SnmpContextToStr function populates an smiOCTETS descriptor with a context value appropriate to the entity/context translation mode in effect at the time of execution.. Syntax: SNMPAPI_STATUS SnmpContextToStr ( IN HSNMP_CONTEXT context, OUT smiLPOCTETS string); Parameter Description context A handle specifying a context. string A pointer to an smiOCTETS descriptor buffer that will receive the string which identifies the context. Returns: If the function is successful, the return value is SNMPAPI_SUCCESS. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information. SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_CONTEXT_INVALID Indicates that the context handle is invalid. Comments: See Section   REF _Ref296070774 \* MERGEFORMAT  2.3. Entity/Context Translation Modes Note:  The application provides only the address of a valid smiOCTETS descriptor structure as the string parameter.  The implementation, upon successful execution of the SnmpContextToStr function, will populate the len and ptr members of the descriptor.  The application must call SnmpFreeDescriptor --when appropriate--to enable the implementation to free the memory resources so consumed. Note:   Strings  referenced in descriptors (such as an smiOCTETS structure) do not require a NULL terminating byte.  Applications should not expect a NULL-terminated string to be returned in an OUTput smiOCTETS parameter. Note that the current setting of the entity/context translation mode affects this function: If the setting is SNMPAPI_TRANSLATED, then the implementation returns the user-friendly textual name of this context from the Local Database.  If no such name exists in the Local Database, then the function returns either of the following, depending upon whether the context is known to be an SNMPv1 or SNMPv2 construct. If the setting is SNMPAPI_UNTRANSLATED_V1 and the subject context is an SNMPv1 construct, then the implementation returns the raw community string (which may contain non-printable byte values).  If the subject context is an SNMPv2 construct, then the implementation behaves as though the entity/context translation mode setting were SNMPAPI_UNTRANSLATED_V2 for the purposes of this call only. If the setting is SNMPAPI_UNTRANSLATED_V2 and the subject context is an SNMPv2 construct, then the implementations returns the raw ContextID (in textual form).  If the subject entity is an SNMPv1 construct, then the implementation behaves as though the entity/context translation mode setting were SNMPAPI_UNTRANSLATED_V1 for the purposes of this call only. autonumlgl   SnmpFreeContext() The SnmpFreeContext function releases resources associated with a context returned by the SnmpStrToContext  function. Syntax:  SNMPAPI_STATUS SnmpFreeContext ( IN HSNMP_CONTEXT context); Parameter Description context A context handle to be released. Returns: If the function is successful, the return value is SNMPAPI_SUCCESS. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information. SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_CONTEXT_INVALID Indicates context parameter is invalid. Comments: Un-freed resources created on behalf of the application will be freed by the implementation upon execution of an associated SnmpClose function or upon execution of an SnmpCleanup function.  Nonetheless, a well-behaved WinSNMP application will individually free all such resources using the atomic "free" functions.  The reason for this is to eliminate or, at least, minimize any "batch-like" loads on the implementation, so that other applications can be serviced in a timely fashion. autonumlgl   PDU Functions This section defines functions which construct PDUs for use in the SnmpSendMsg and SnmpEncodeMsg functions and which decompose PDUs received via the SnmpRecvMsg and SnmpDecodeMsg functions.  The following section--Variable Binding Functions--also pertains to PDU [de]composition, but is retained as a separate section both for consistency with the earlier versions of this document and for modularization. Actual PDU and variable binding data structures are private to the WinSNMP implementation.  The PDU and Variable Binding functions enable applications to extract the component data elements which are then available for whatever use the application deems appropriate.  The elements comprising a PDU from the perspective of a WinSNMP application are: /* This typedef is for expository purposes only.  It is not a required component of WinSNMP */ typedef struct { smiINT PDU_type; smiINT32 request_id; smiINT error_status; -- "non_repeaters" for BulkPDU smiINT error_index; -- "max_repetitions" for BulkPDU HSNMP_VBL varbindlist;} -- we'll examine this one in the next section The functions in this section are: Return Type Procedure Name Parameters HSNMP_PDU SnmpCreatePdu (IN HSNMP_SESSION session, IN smiINT PDU_type, IN smiINT32 request_id, IN smiINT error_status/non_repeaters, IN smiINT error_index/max_repetitions, IN HSNMP_VBL vbl); SNMPAPI_STATUS SnmpGetPduData (IN HSNMP_PDU PDU, OUT smiLPINT PDU_type, OUT smiLPINT32 request_id, OUT smiLPINT error_status/non_repeaters, OUT smiLPINT error_index/max_repetitions, OUT LPHSNMP_VBL vbl); SNMPAPI_STATUS SnmpSetPduData (IN HSNMP_PDU PDU, IN const smiINT FAR *PDU_type, IN const smiINT32 FAR *request_id, IN const smiINT FAR *non_repeaters, IN const smiINT FAR *max_repetitions, IN const HSNMP_VBL FAR *vbl); HSNMP_PDU SnmpDuplicatePdu (IN HSNMP_SESSION session, IN HSNMP_PDU PDU); SNMPAPI_STATUS SnmpFreePdu (IN HSNMP_PDU PDU); The following table illustrates the possible PDU_type values used in WinSNMP functions: PDU_types Table SNMP_PDU_GET Indicates a Get Request-PDU SNMP_PDU_GETNEXT Indicates a GetNextRequest-PDU SNMP_PDU_GETBULK Indicates a GetBulkRequest-PDU SNMP_PDU_V1TRAP Indicates an SNMPv1-Trap-PDU SNMP_PDU_SET Indicates a SetRequest- PDU SNMP_PDU_INFORM Indicates an InformRequest-PDU SNMP_PDU_RESPONSE Indicates a Response-PDU SNMP_PDU_TRAP Indicates an SNMPv2-Trap-PDU The following table illustrates the possible SNMP error values used in the error_status element of an SNMP PDU: SNMP Error Values Table SNMP_ERROR_NOERROR Specifies the noError error. SNMP_ERROR_TOOBIG Specifies the tooBig error. SNMP_ERROR_NOSUCHNAME Specifies the noSuchName error. SNMP_ERROR_BADVALUE Specifies the badValue error. SNMP_ERROR_READONLY Specifies the readOnly error. SNMP_ERROR_GENERR Specifies the genErr error. SNMP_ERROR_NOACCESS Specifies the noAccess error. SNMP_ERROR_WRONGTYPE Specifies the wrongType error. SNMP_ERROR_WRONGLENGTH Specifies the wrongLength error. SNMP_ERROR_WRONGENCODING Specifies the wrongEncoding error. SNMP_ERROR_WRONGVALUE Specifies the wrongValue error. SNMP_ERROR_NOCREATION Specifies the noCreation error. SNMP_ERROR_INCONSISTENTVALUE Specifies the inconsistentValue error. SNMP_ERROR_RESOURCEUNAVAILABLE Specifies the resourceUnavailable error. SNMP_ERROR_COMMITFAILED Specifies the commitFailed error. SNMP_ERROR_UNDOFAILED Specifies the undoFailed error. SNMP_ERROR_AUTHORIZATIONERROR Specifies the authorizationError error. SNMP_ERROR_NOTWRITABLE Specifies the notWritable error. SNMP_ERROR_INCONSISTENTNAME Specifies the inconsistentName error. autonumlgl   SnmpCreatePdu() The SnmpCreatePdu function allocates and initializes an SNMP protocol data unit for subsequent use in SnmpSendMsg, SnmpEncodeMsg, and other functions. Note that all input parameters to SnmpCreatePdu must be present; but, with the exception of the "session" parameter, all may be NULL, resulting in a default PDU as defined below. Syntax: HSNMP_PDU SnmpCreatePdu ( IN HSNMP_SESSION session, IN smiINT PDU_type, IN smiINT32 request_id, IN smiINT error_status, -- "non_repeaters" for BulkPDU IN smiINT error_index, -- "max_repetitions" for BulkPDU IN HSNMP_VBL Parameter Description session Handle of the allocating session. PDU_type NULL or one of the values shown in the PDU_types table shown in the introduction to the PDU Functions section.  If NULL, the WinSNMP implementation will supply SNMP_PDU_GETNEXT. request_id An application-supplied value used to identify the PDU or NULL, in which case the WinSNMP implementation will supply a value. error_status Ignored (and may be NULL) on input for all PDU types except SNMP_PDU_GETBULK, in which case it represents the value for non_repeaters.  For all other PDU types, the WinSNMP implementation will supply SNMP_ERROR_NOERROR. error_index Ignored (and may be NULL) on input for all PDU types except SNMP_PDU_GETBULK, in which case it represents the value for max_repetitions.  The WinSNMP implementation returns 0 (zero) for all other PDU types. A handle to a varbindlist data structure (or NULL). Returns: If the function is successful, the return value identifies the created SNMP protocol data unit If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_SESSION_INVALID Indicates an invalid session handle.  SNMPAPI_PDU_INVALID Indicates an invalid PDU_type value. SNMPAPI_VBL_INVALID Indicates an invalid vbl.   Comments: Assuming NULL values for all input parameters (other than "session"), the created protocol data unit defaults to the following attributes: PDU_type: SNMP_PDU_GETNEXT request_id: <WinSNMP-generated value> error_status: SNMP_ERROR_NOERROR error_index: After completing operations with the created PDU, the SnmpFreePdu function should be called to release the resources allocated to the PDU by the SnmpCreatePdu function.. autonumlgl   SnmpGetPduData() The SnmpGetPduData function extracts selected data elements from the specified PDU and copies them to the respective locations given as corresponding output parameters. Note that all output parameters must be supplied to the function call, but any (or all) of them may be NULL.  No values are returned for output parameters passed as NULL. Syntax: SNMPAPI_STATUS SnmpGetPduData ( IN HSNMP_PDU OUT smiLPINT PDU_type, OUT smiLPINT32 request_id, OUT smiLPINT error_status, -- "non_repeaters" for GetBulkRequest-PDU OUT smiLPINT error_index, -- "max_repetitions" for GetBulkRequest-PDU OUT LPHSNMP_VBL vbl); Parameter Description Identifies the SNMP protocol data unit. PDU_type If not NULL, points to an smiINT variable that will receive the PDU_type of the PDU. request_id If not NULL, points to an smiINT32 variable that will receive the request_id of the PDU. error_status If not NULL, points to an smiINT variable that will receive the error_status (or non_repeaters) of the PDU. error_index If not NULL, points to an smiINT variable that will receive the error_index (or max_repetitions) of the PDU. If not NULL, points to an HSNMP_VBL variable that will receive the handle to the varbindlist of the PDU. Returns: If the function is successful, the return value is SNMPAPI_SUCCESS. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_PDU_INVALID Indicates that the PDU parameter is invalid.  SNMPAPI_NOOP Indicates that all output parameters were NULL  Comments: On a successful return and if the parameter was not NULL, PDU_type will contain one of the values from the PDU_Types Table shown in the introduction to the PDU Functions section. On a successful return and if the parameter was not NULL, error_status will contain one of the values from the SNMP Error Values Table shown in the introduction to the PDU Functions section. As always, a well-behaved application must handle the case when an unexpected value (PDU_type and error_status are just possible examples) might be returned by a procedure call. It is very important to note that the HSNMP_VBL resource returned if the call is successful and the vbl parameter was not NULL represents a new varbindlist object.  This is consistent both with the primary purpose of the SnmpGetPduData function--namely, to dereference the elements of a newly received PDU and with the WinSNMP policy that says that anytime the implementation returns a handled resource object to the application, it will be a newly allocated object.  For PDUs that an application has either created for sending or has already dereferenced with SnmpGetPduData, the application is expected to   the values of the PDU components.  Calling SnmpGetPduData with a non-NULL vbl parameter against an existing dereferenced PDU is equivalent (wrt the returned HSNMP_VBL object) to calling SnmpDuplicateVbl on the vbl object already attached to the PDU. Calling SnmpGetPduData with a non-NULL vbl parameter against a newly received PDU has the effect of  attaching  the returned HSNMP_VBL object to the HSNMP_PDU object specified in the input pdu parameter.  Calling SnmpGetPduData with a non-NULL vbl parameter against an existing (created or dereferenced) PDU, results in a new HSNMP_VBL object as discussed above but does not disturb the original HSNMP_VBL object value already attached to the PDU. autonumlgl   SnmpSetPduData() The SnmpSetPduData function updates selected data elements in the specified PDU. Note that all parameters must be supplied to the function call, but any (or all) of them--except the PDU-- may be NULL.  No values are changed in the PDU for input parameters passed as NULL (and they are passed as pointers to values to allow for the case when NULL is the desired update value). Syntax: SNMPAPI_STATUS SnmpSetPduData ( IN HSNMP_PDU IN smiLPINT PDU_type, IN smiLPINT32 request_id, IN smiLPINT non_repeaters, -- for GetBulkRequest-PDU only IN smiLPINT max_repetitions, -- for GetBulkRequest-PDU only IN LPHSNMP_VBL vbl); Parameter Description Identifies the SNMP protocol data unit. PDU_type If not NULL, points to an smiINT variable that will update the PDU_type of the PDU. request_id If not NULL, points to an smiINT32 variable that will update the request_id of the PDU. non_repeaters If not NULL, points to an smiINT variable that will update the non_repeaters of the GetBulkRequest-PDU (ignored for other PDU_types). max_repetitions If not NULL, points to an smiINT variable that will update the max_repetitions of the GetBulkRequest-PDU (ignored for other PDU_types). If not NULL, points to an HSNMP_VBL variable that will update the handle to the varbindlist of the PDU. Returns: If the function is successful, the return value is SNMPAPI_SUCCESS. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_PDU_INVALID Indicates that the PDU parameter is invalid.  SNMPAPI_VBL_INVALID Indicates an invalid vbl parameter.   SNMPAPI_NOOP Indicates that all input parameters were NULL  Comments: Not all possible combinations of individually legal component values are valid.  Ultimately, the WinSNMP implementation must verify the validity of the PDU (and other message elements) when the application calls the SnmpSendMsg or SnmpEncodeMsg function and reject and ill-formed or otherwise illegal PDU structures autonumlgl   SnmpDuplicatePdu() The SnmpDuplicatePdu function duplicates an SNMP protocol data unit structure identified by the PDU parameter. Syntax: HSNMP_PDU SnmpDuplicatePdu ( IN HSNMP_SESSION session, IN HSNMP_PDU PDU); Parameter Description session Handle of the allocating session. Identifies the SNMP protocol data unit to duplicate. Returns: If the function is successful, the return value is a handle which identifies the new (duplicated) SNMP protocol data unit. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_SESSION_INVALID Indicates an invalid session handle.  SNMPAPI_PDU_INVALID Indicates that the PDU parameter is invalid.   Comments: After using the duplicated message, SnmpFreePdu function should be called to release the resources allocated to the PDU by the SnmpDuplicatePdu function. Note:  The handle returned by a successful call to SnmpDuplicatePdu will be unique among active PDU handles, at least within the calling application. autonumlgl   SnmpFreePdu() The SnmpFreePdu function releases resources associated with a protocol data unit previously created by the SnmpCreatePdu or SnmpDuplicatePdu function. Syntax: SNMPAPI_STATUS SnmpFreePdu ( IN HSNMP_PDU PDU); Parameter Description Identifies the SNMP protocol data unit to be freed. Returns: If the function is successful, the return value is SNMPAPI_SUCCESS. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_PDU_INVALID Indicates that the PDU parameter is invalid.   Comments: Un-freed resources created on behalf of the application will be freed by the implementation upon execution of an associated SnmpClose function or upon execution of an SnmpCleanup function.  Nonetheless, a well-behaved WinSNMP application will individually free all such resources using the atomic "free" functions.  The reason for this is to eliminate or, at least, minimize any "batch-like" loads on the implementation, so that other applications can be serviced in a timely fashion. Varbinds and VarBindLists are re-usable independently of any given PDU.  In WinSNMP, a varbind does not exist outside of a varbindlist (even if the latter consists of only a single varbind).  There is a separate atomic function--SnmpFreeVbl--to deallocate varbindlist resources.  Of course, upon execution of SnmpFreePdu, the WinSNMP implementation must free any internal resources allocated to VBLs for that PDU.  That's different from the HSNMP_VBL resources requested and held by a session in the calling application. autonumlgl   Variable Binding Functions WinSNMP relies on a varbindlist structure (VBL), and drops the concept of a separate varbind structure (VB).  No capability is lost, since an individual varbind structure can be represented by a varbindlist structure of one member.  A WinSNMP application accesses the varbindlist structure via handles--of type HSNMP_VBL.  A WinSNMP implementation hides the details of this structure from the application using whatever proprietary mechanisms and techniques it considers optimal. These functions allow applications to easily construct and manipulate VarBindLists for inclusion in PDUs.  Note that a varbind is not directly associated with a PDU, only indirectly through inclusion in a varbindlist.  A varbindlist gets associated with and de referenced from a PDU with the SnmpSetPduData and SnmpGetPduData, respectively. The functions in this section are: Return Type Procedure Name Parameters HSNMP_VBL SnmpCreateVbl (IN HSNMP_SESSION session, IN smiLPCOID name, IN smiLPCVALUE value); HSNMP_VBL SnmpDuplicateVbl (IN HSNMP_SESSION session, IN HSNMP_VBL vbl); SNMPAPI_STATUS SnmpFreeVbl (IN HSNMP_VBL vbl); SNMPAPI_STATUS SnmpCountVbl (IN HSNMP_VBL vbl); SNMPAPI_STATUS SnmpGetVb (IN HSNMP_VBL vbl, IN smiUINT32 index, OUT smiLPOID name, OUT smiLPVALUE value); SNMPAPI_STATUS SnmpSetVb (IN HSNMP_VBL vbl, IN smiUINT32 index, IN smiLPCOID name, IN smiLPCVALUE value); SNMPAPI_STATUS SnmpDeleteVb (IN HSNMP_VBL vbl, IN smiUINT32 index); Table of Syntax Values Used in Variable Binding Data Structures SNMP_SYNTAX_INT32 SNMP_SYNTAX_OCTETS SNMP_SYNTAX_OID SNMP_SYNTAX_BITS SNMP_SYNTAX_IPADDR SNMP_SYNTAX_CNTR32 SNMP_SYNTAX_GAUGE32 SNMP_SYNTAX_TIMETICKS SNMP_SYNTAX_OPAQUE SNMP_SYNTAX_NSAPADDR SNMP_SYNTAX_CNTR64 SNMP_SYNTAX_UINT32 SNMP_SYNTAX_NULL SNMP_SYNTAX_NOSUCHOBJECT SNMP_SYNTAX_NOSUCHINSTANCE SNMP_SYNTAX_ENDOFMIBVIEW autonumlgl   SnmpCreateVbl() The SnmpCreateVbl function creates a new varbindlist structure for the calling application.  If the "name" and "value" parameters are not NULL, SnmpCreateVbl uses them to construct the initial varbind member of the varbindlist. Syntax: HSNMP_VBL SnmpCreateVbl ( IN HSNMP_SESSION session, IN smiLPCOID name, IN smiLPCVALUE value); Parameter Description session Handle of the allocating session. name  If not NULL, points to an OID for initialization of the varbindlist. value  If not NULL, points to a value for initialization of the varbidlist. Returns: If the function is successful, the return value identifies a newly created varbindlist structure. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_SESSION_INVALID Indicates an invalid session handle.  SNMPAPI_OID_INVALID Indicates that the name parameter referenced an invalid OID structure. SNMPAPI_SYNTAX_INVALID Indicates that the syntax field of the value parameter is invalid.   Comments: IF the "name" parameter is not NULL and the "value" parameter is NULL, the varbindlist will still be initialized, with the value set to NULL and with syntax of SNMP_SYNTAX_NULL.  If the "name" parameters is NULL, the varbindlist will not be initialized, and the "value" parameter will be ignored. Every call to SnmpCreateVbl must be matched with a corresponding call to SnmpFreeVbl to release the resources associated with the varbindlist.  A memory leak will result if a variable used to hold an HSNMP_VBL value returned by SnmpCreateVbl (or SnmpDuplicateVbl) is re-used for a subsequent SnmpCreateVbl (or SnmpDuplicateVbl) operation before it has been passed to SnmpFreeVbl. autonumlgl   SnmpDuplicateVbl() The SnmpDuplicateVbl function creates a new varbindlist structure for the specified session in the calling application and initializes it with a copy of the input vbl (which may be empty). Syntax: HSNMP_VBL SnmpDuplicateVbl ( IN HSNMP_SESSION session, IN HSNMP_VBL vbl); Parameter Description session Handle of the allocating session. Identifies the varbindlist to be duplicated. Returns: If the function is successful, the return value identifies a newly created varbindlist structure. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_SESSION_INVALID Indicates an invalid session handle.  SNMPAPI_VBL_INVALID Indicates that the vbl parameter is invalid.   Comments: Every call to SnmpDuplicateVbl must be matched with a corresponding call to SnmpFreeVbl to release the resources associated with the varbindlist.  A memory leak will result if a variable used to hold an HSNMP_VBL value returned by SnmpDuplicateVbl (or SnmpCreateVbl) is re-used for a subsequent SnmpDuplicateVbl (or SnmpCreateVbl) operation before it has been passed to SnmpFreeVbl. Note:  The handle returned by a successful call to SnmpDuplicateVbl will be unique among active VBL handles, at least within the calling application. autonumlgl   SnmpFreeVbl() The SnmpFreeVbl function releases resources associated with a varbindlist structure previously allocated by SnmpCreateVbl or SnmpDuplicateVbl.  It is the responsibility of WinSNMP applications to free varbindlist resources allocated through calls to SnmpCreateVbl and SnmpDuplicateVbl. Syntax: SNMPAPI_STATUS SnmpFreeVbl ( IN HSNMP_VBL  vbl); Parameter Description Identifies the varbindlist to be released.  Returns: If the function is successful, the return value is SNMPAPI_SUCCESS. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_VBL_INVALID Indicates that the vbl parameter is invalid.   Comments: Every call to SnmpCreateVbl must be matched with a corresponding call to SnmpFreeVbl to release the resources associated with the varbindlist.  A memory leak will result if a variable used to hold an HSNMP_VBL value returned by SnmpCreateVbl is re-used for a subsequent SnmpCreateVbl operation before it has been passed to SnmpFreeVbl.  The foregoing comments apply equally to VarBindLists originating via the SnmpDuplicateVbl function. Un-freed resources created on behalf of the application will be freed by the implementation upon execution of an associated SnmpClose function or upon execution of an SnmpCleanup function.  Nonetheless, a well-behaved WinSNMP application will individually free all such resources using the atomic "free" functions.  The reason for this is to eliminate or, at least, minimize any "batch-like" loads on the implementation, so that other applications can be serviced in a timely fashion. autonumlgl   SnmpCountVbl() The SnmpCountVbl function counts the number of varbinds in the varbindlist identified by the vbl input parameter. Syntax: SNMPAPI_STATUS SnmpCountVbl ( IN HSNMP_VBL vbl); Parameter Description Identifies the subject varbindlist. Returns: If the function is successful, the return value is the count of varbinds in the varbindlist. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_VBL_INVALID Indicates that the vbl parameter is invalid. SNMPAPI_NOOP Indicates that the vbl resources contained no varbinds at this time.   Comments: The value returned when the result is SNMPAPI_SUCCESS represents the maximum "index" value in the SnmpGetVb and SnmpSetVb functions. autonumlgl   SnmpGetVb() The SnmpGetVb function retrieves the object instance name and its associated value from the varbind identified by the index parameter.  The SnmpGetVb function returns the object instance name in the descriptor pointed to by the name parameter and its associated value in the descriptor pointed to by the value parameter. Syntax: SNMPAPI_STATUS SnmpGetVb ( IN HSNMP_VBL IN smiUINT32 index, OUT smiLPOID  name, OUT smiLPVALUE value); Parameter Description Identifies the subject varbindlist.  index Identifies the position of the subject varbind within the varbindlist. name  Points to a variable to receive the OID portion of the varbind. value  Points to a variable to receive the value portion of the varbind. Returns: If the function is successful, the return value is SNMPAPI_SUCCESS. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_VBL_INVALID Indicates that the vbl parameter is invalid.   SNMPAPI_INDEX_INVALID Indicates that the index parameter is invalid. Comments: Valid values for the "index" parameter come from the SnmpCountVbl function and from the "error_index" component of GetResponse PDUs returned via the SnmpRecvMsg function.  These values range from 1 to n, where n is the total number of varbinds in the varbindlist. The member elements of the smiOID  and smiVALUE structures pointed to by the   and  value  parameters are ignored on input  and will be overwritten by the implementation upon a successful execution of this function. On a successful return, the syntax field of the "value" variable will contain one of the object syntax types shown in the Table of Syntax Values included in the introduction to this section. The application must eventually call the SnmpFreeDescriptor function to enable the implementation to free any resources that might have been allocated to populate the   members of the   and (depending upon its  syntax  member)  value  structures. autonumlgl   SnmpSetVb() The SnmpSetVb function adds and updates varbind entries in a varbindlist. Syntax: SNMPAPI_STATUS SnmpSetVb ( IN HSNMP_VBL IN smiUINT32 index, IN smiLPCOID name, IN smiLPCVALUE value); Parameter Description Identifies the target varbindlist.  index Identifies the position of the subject varbind within the varbindlist for an  update  operation or is zero for an  add/append  operation. name  Points to a variable containing the object instance name to be set. value If not NULL, points to a variable containing the associated value to be set. Returns: If the function is successful, the return value is the position ( index  value) of the affected varbind.  In the case of successful update operations, the return value will equal the  index  parameter.  In the case of add/append operations (in which the  index  parameter will have been zero), the return value will be  , where   was the previous total count of varbinds in the varbindlist (per SnmpCountVbl). f the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_VBL_INVALID Indicates that the vbl parameter is invalid.  SNMPAPI_INDEX_INVALID Indicates that the index parameter is invalid. SNMPAPI_OID_INVALID Indicates that the name parameter is invalid.  SNMPAPI_SYNTAX_INVALID Indicates that the syntax field of the value parameter is invalid.   Comments: Valid values for the "index" parameter range from 0 (zero) to n, where n is the total number of varbinds currently in the varbindlist as reported by the SnmpCountVbl function.  An index value of 0 (zero) indicates the addition of a varbind to the varbindlist. If the "value" parameter is NULL, the varbind will still be initialized, with the value set to NULL and with syntax of SNMP_SYNTAX_NULL. autonumlgl   SnmpDeleteVb() The SnmpDeleteVb function removes a varbind entry from a varbindlist. Syntax: SNMPAPI_STATUS SnmpDeleteVb ( IN HSNMP_VBL IN smiUINT32 index); Parameter Description Identifies the target varbindlist.  index Identifies the position of the subject varbind within the varbindlist. Returns: If the function is successful, the return value is SNMPAPI_SUCCESS. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_VBL_INVALID Indicates that the vbl parameter is invalid.   SNMPAPI_INDEX_INVALID Indicates that the index parameter is invalid. Comments: Valid values for the "index" parameter come from the SnmpCountVbl function and from the "error_index" component of GetResponse PDUs returned via the SnmpRecvMsg function.  These values range from 1 to n, where n is the total number of varbinds in the varbindlist. A typical use for this function will be when a GetResponse PDU includes an SNMP error and the user elects to resubmit the original "request" PDU sans the offending varbind. Note that following a successful SnmpDeleteVb operation, any varbinds that previously came after the deleted varbind will logically  move up  in the varbindlist--that is, their index values will decrement by one position and the total number of varbinds in the varbindlist, as returned by SnmpCountVbl will likewise decrement by one. It is legal to end up with an empty varbindlist by executing  SnmpDeleteVb (hVBL, 1)  on the last remaining varbind in a varbindlist.  In this case, the varbindlist itself (as a HANDLE d object) is still valid and must eventually be released via SnmpFreeVbl. Sample pseudo-code for SnmpDeleteVb: -- Omitting error-checking the function calls for clarity's sake... nReqID = SnmpRecvMsg (session, &rSrc, &rDst, &rCtx, &rPDU); SnmpGetPduData (rPDU, &rType, &rReqid, &rErrstat, &rErridx, &rVBL); -- Assuming type == GetResponse-PDU and -- Assuming error_status != SNMP_ERROR_NOERROR... -- Assuming the error is something we cannot or do not want to fix... -- If error_index == 1, do an SnmpCountVbl (); -- if count <= 1 follow another strategy (like SnmpFreeVbl (sVBL)) -- Assuming error_index > 1 || count > 1... SnmpDeleteVb  (sVBL, rErridx); -- And assuming we want to re-try the SNMP operation -- ...with a new Request_ID just for good measure... sReqid++; SnmpSetPduData (sPDU, NULL, &sReqid, NULL, NULL, &sVBL); SnmpSendMsg (session, sSrc, sDst, sCtx, sPDU); -- No need for the received PDU or VBL any longer... SnmpFreePdu (rPDU); SnmpFreeVbl (rVBL); -- Go back to doing what we were doing before all of this started... autonumlgl   Utility Functions The utility functions are offered to ease the tasks of bookkeeping and dealing with objects passed across the Windows SNMP interface. Return Type Procedure Name Parameters SNMPAPI_STATUS SnmpGetLastError (IN HSNMP_SESSION session); SNMPAPI_STATUS SnmpStrToOid (IN LPCSTR string, OUT smiLPOID dstOID); SNMPAPI_STATUS SnmpOidToStr (IN smiLPCOID srcOID, IN smiUINT32 size, OUT LPSTR string); SNMPAPI_STATUS SnmpOidCopy (IN smiLPCOID srcOID, OUT smiLPOID dstOID); SNMPAPI_STATUS SnmpOidCompare (IN smiLPCOID xOID, IN smiLPCOID yOID, IN smiUINT32 maxlen, OUT smiLPINT result); SNMPAPI_STATUS SnmpEncodeMsg (IN HSNMP_SESSION session, IN HSNMP_ENTITY srcEntity, IN HSNMP_ENTITY dstEntity, IN HSNMP_CONTEXT context, IN HSNMP_PDU pdu, OUT smiLPOCTETS msgBufDesc); SNMPAPI_STATUS SnmpDecodeMsg (IN HSNMP_SESSION session, OUT LPHSNMP_ENTITY srcEntity, OUT LPHSNMP_ENTITY dstEntity, OUT LPHSNMP_CONTEXT context, OUT LPHSNMP_PDU pdu, IN smiLPCOCTETS msgBufDesc); SNMPAPI_STATUS SnmpFreeDescriptor (IN smiUINT32 syntax, IN smiLPOPAQUE descriptor); autonumlgl   SnmpGetLastError() The SnmpGetLastError function returns an indication of why the last WinSNMP operation executed by the application failed.  Syntax: SNMPAPI_STATUS SnmpGetLastError ( IN HSNMP_SESSION session); Parameter Description session  Indicates the session for which error information is requested.  If NULL, the application-wide error information is returned. Returns: This function returns the last WinSNMP error that occurred for the indicated session or for the application (task) if the session is NULL (as when, for example, SnmpStartup fails.) Comments: See Section   REF _Ref295972638 \* MERGEFORMAT  2.10. Error Handling This function should be called immediately after any API call that fails, as the value is overwritten after each API call which fails. The session input parameter is provided to facilitate accommodation of multi-threaded Windows operating environments.  Single-threaded applications can always pass a NULL session value and retrieve the last error information for the overall application. Note that SnmpGetLastError must be able to return a value to a WinSNMP application even when SnmpStartup fails, and/or before any sessions are created with SnmpOpen, and/or after all sessions are closed with SnmpClose and/or the application disconnects from the implementation with the SnmpCleanup function. autonumlgl   SnmpStrToOid() The SnmpStrToOid function converts a textual representation of the dotted numeric form of an OBJECT IDENTIFIER into an internal OBJECT IDENTIFIER representation. Syntax: SNMPAPI_STATUS SnmpStrToOid ( IN  LPCSTR string, OUT smiLPOID dstOID); Parameter Description string  Points to a NULL terminated string to be converted.   dstOID  Points to an smiOID variable to receive the converted value.   Returns: If the function is successful, the return value is the number of sub-identifiers in the output OBJECT IDENTIFIER.  This number will also be the value of the "len" member of the dstOID structure upon return.. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_OID_INVALID Indicates that the string was invalid.  Comments: Note that the format of the OID array in an smiOID structure is one integral sub-identifier per array element.  That is, the string  1.3.6.1  (lstrlen=7)  becomes an array of {1,3,6,1} (len=4) and vice versa. The member elements of the smiOID structure pointed to by the dstOID structure are ignored on input and will be overwritten by the implementation upon a successful execution of this function. The application must eventually call the SnmpFreeDescriptor function to enable the implementation to free any resources that might have been allocated to populate the   member of the dstOID structure. This function has nothing to do with the MIB database APIs described elsewhere.  The purpose of this function is to translate from the dotted numeric string representation of an OID (e.g. "1.2.3.4.5.6") to the internal object identifier format. This function can fail with SNMPAPI_OID_INVALID, for example, if the "string" input parameter is not NULL terminated, is of insufficient length, is longer than MAXOBJIDSTRSIZE, or does not constitute the textual form of a valid OID. autonumlgl   SnmpOidToStr() The SnmpOidToStr function converts an internal representation of an OBJECT IDENTIFIER into a dotted numeric string representation of an OBJECT IDENTIFIER. Syntax: SNMPAPI_STATUS SnmpOidToStr ( IN  smiLPCOID srcOID, IN smiUINT32 size, OUT LPSTR  string); Parameter Description srcOID  Points to a variable holding an object identifier to be converted. The size of the buffer the application is providing to contain the string. string Points to a buffer that will receive the string that identifies the management entity. Returns: If the function is successful, the return value is the number of bytes, including the NULL terminating byte, output to "string"--this value may be less than or equal to "size", but not greater. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_OID_INVALID Indicates that the srcOID was invalid.  SNMPAPI_OUTPUT_TRUNCATED Indicates that the buffer was too small. Comments: This function has nothing to do with the MIB database APIs described elsewhere.  The purpose of this function is to translate from the internal object identifier format to the dotted numeric string representation of the OID (e.g., "1.2.3.4.5.6"). Note that the format of the OID array in an smiOID structure is one integral sub-identifier per array element.  That is, the string  1.3.6.1  (lstrlen=7)  becomes an array of {1,3,6,1} (len=4) and vice versa. Note that the application should use a string buffer of MAXOBJIDSTRSIZE length for this call, to be safe.  If, as will normally be true, a shorter OID is actually decoded, the application can copy the resulting string to one of appropriate length and either re-use or free the space allocated to the original buffer. Note that a NULL-terminated string is returned for convenience.  The return value, upon success, will include the terminating NULL byte. autonumlgl   SnmpOidCopy() The SnmpOidCopy function copies the srcOID to the dstOID. Syntax: SNMPAPI_STATUS SnmpOidCopy ( IN smiLPCOID srcOID, OUT smiLPOID dstOID); Parameter Description srcOID  Points to a variable holding an object identifier. dstOID  Points to a variable to receive a copy of the srcOID.  Returns: If the function is successful, the return value is the number of sub-identifiers in the output OBJECT IDENTIFIER.  This number will also be the value of the "len" member of the dstOID structure upon return. If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_OID_INVALID Indicates that the srcOID was invalid.  Comments: The member elements of the smiOID structure pointed to by the dstOID structure are ignored on input  and will be overwritten by the implementation upon a successful execution of this function. The application must eventually call the SnmpFreeDescriptor function to enable the implementation to free any resources that might have been allocated to populate the   member of the dstOID structure. autonumlgl   SnmpOidCompare() The SnmpOidCompare function lexicographically compares two OIDs.  If "maxlen" is non-zero, then its value is used as an upper limit on the number of sub-identifiers to compare.  This approach will most often be used to identify whether two OIDs have common prefixes or not.  If "maxlen" is zero, then the "len" members of the two smiOID structures will determine the maximum number of sub-identifiers to compare. Syntax: SNMPAPI_STATUS SnmpOidCompare ( IN smiLPCOID xOID, IN smiLPCOID yOID, IN smiUINT32 maxlen, OUT smiLPINT result); Parameter Description Points to a variable holding an object identifier to compare.  Points to a variable holding an object identifier to compare.  maxlen  If non-zero, Indicates the number of sub-identifiers to compare.  Must be less than MAXOBJIDSIZE. result Points to a variable to receive the result of the comparison: if xOID is greater than yOID if xOID equals yOID if xOID is less than yOID Returns: If the function is successful, the return value is SNMPAPI_SUCCESS.  If the function fails, the return value is SNMPAPI_FAILURE.  Use the SnmpGetLastError function to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_OID_INVALID Indicates that either or both of the input OIDs were invalid.  SNMPAPI_SIZE_INVALID Indicates that the "maxlen" parameter was invalid; that is, greater than MAXOBJIDSIZE. Comments: The SnmpOidCompare function combines the functionality of the SnmpOidCmp and SnmpOidNCmp functions which appeared in versions earlier that v1.0g of this specification. When "maxlen" is non-zero (but not greater than MAXOBJIDSIZE), the maximum number of sub-identifiers that will be compared is the minimum of the "maxlen" input parameter and the two "len" members of the input OID structures.  Either or both of the input OIDs can have a zero length without causing an error. When "maxlen" is zero, the maximum number of sub-identifiers that will be compared is the minimum of the two "len" members of the input OID structures.  Either or both of the input OIDs can have a zero length without causing an error. If the two OIDs are lexicographically equal when the maximum number of sub-identifiers have been compared, then: SYMBOL 183 \f "Symbol" \s 10 \h If the "maxlen" parameter value was used as the maximum number of sub-identifiers to compare, or if the two OID parameters have equal "len" members which are less than the "maxlen" input parameter, the "result" value will be 0 (equal). SYMBOL 183 \f "Symbol" \s 10 \h If an OID "len" member was used as the value for the maximum number of sub-identifiers to compare (because it was less than the non-zero "maxlen" input parameter or because "maxlen" was equal to zero), and the other OID "len" member value is greater, the "result" value will be <0 or >0, depending on which OID parameter had which "len" value. autonumlgl   SnmpEncodeMsg() The SnmpEncodeMsg routine takes as its first five input parameters the same parameters passed to SnmpSendMsg.  The implementation will use these parameters to form an SNMP "message" as though they had arrived via the SnmpSendMsg function.  The implementation will not, however, attempt to transmit the resulting message to the 'dstEntity'.  It will, instead, use the 'msgBufDesc' parameter as described herein to return to the application the encoded/serialized SNMP message that it would have transmitted to the 'dstEntity' if SnmpSendMsg had been called. Syntax: SNMPAPI_STATUS  SnmpEncodeMsg ( IN HSNMP_SESSION session, IN HSNMP_ENTITY srcEntity, IN HSNMP_ENTITY dstEntity, IN HSNMP_CONTEXT context, IN HSNMP_PDU OUT smiLPOCTETS msgBufDesc); Parameter Description session  Identifies the session that will perform the operation.   srcEntity Identifies the subject management entity. dstEntity Identifies the target management entity. context Identifies the target context of interest. Identifies the SNMP protocol data unit containing the requested operation. msgBufDesc Identifies the variable to receive the encoded SNMP message. Returns: Upon success, SnmpEncodeMsg returns the length, in bytes, of the encoded SNMP message.  (This value will also be in the   member of the msgBufDesc output parameter.) If the function fails, the return value is SNMPAPI_FAILURE.  Use SnmpGetLastError to obtain extended error information.   SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_SESSION_INVALID Indicates that a session parameter is invalid. SNMPAPI_ENTITY_INVALID Indicates that an entity parameter is invalid. SNMPAPI_CONTEXT_INVALID Indicates that the context parameter is invalid. SNMPAPI_PDU_INVALID Indicates that the PDU parameter is invalid. Comments: The member elements of the smiOCTETS structure pointed to by the msgBufDesc structure are ignored and will be overwritten by the implementation upon a successful execution of this function. The application must eventually call the SnmpFreeDescriptor function to enable the implementation to free any resources that might have been allocated to populate the   member of the msgBufDesc structure. If any of the first five input parameters fail the normal integrity checks performed for SnmpSendMsg then SnmpEncodeMsg will return SNMPAPI_FAILURE and SnmpGetLastError will be set to return the appropriate extended error code. autonumlgl   SnmpDecodeMsg() The SnmpDecodeMsg function is the converse of the SnmpEncodeMsg function.  It takes as input a session identifier and a far pointer to an smiOCTETS structure which describes an encoded/serialized SNMP message to be decoded into its constituent components.  The session identifier is required since new resources will be created by the implementation and allocated to the application as a result of calling this function, if it is successful.  The 'msgBufDesc' input parameter consists of two elements:  The "len" member identifies the maximum number of bytes to process; the "ptr" member points to the encoded/serialized SNMP message to decode. Syntax: SNMPAPI_STATUS  SnmpDecodeMsg ( HSNMP_SESSION session, OUT LPHSNMP_ENTITY srcEntity, OUT LPHSNMP_ENTITY dstEntity, OUT LPHSNMP_CONTEXT context, OUT LPHSNMP_PDU IN smiLPCOCTETS msgBufDesc); Parameter Description session  Identifies the session that will perform the operation.   srcEntity Identifies the subject management entity. dstEntity Identifies the target management entity. context Identifies the target context of interest. Identifies the SNMP protocol data unit. msgBufDesc Identifies the buffer holding the encoded SNMP message. Returns: Upon successful completion, SnmpDecodeMsg returns the actual number of bytes decoded.  This may be equal to or less than the "len" member of the 'msgBufDesc' input parameter.  Also, upon success, SnmpDecodeMsg returns handle values in the 'srcEntity', 'dstEntity', 'context', and 'pdu' output parameters.  Note that these resources are to be freed by the application using the appropriate SnmpFree<xxx> functions, or by the implementation in response to an SnmpClose or SnmpCleanup function call. If SnmpDecodeMsg fails, the return value will be SNMPAPI_FAILURE and SnmpGetLastError will be set to report one of the following: SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_SESSION_INVALID Indicates that a session parameter is invalid. SNMPAPI_ENTITY_INVALID Indicates that an entity parameter is invalid. SNMPAPI_CONTEXT_INVALID Indicates that the context parameter is invalid. SNMPAPI_PDU_INVALID Indicates that the PDU parameter is invalid. SNMPAPI_OUTPUT_TRUNCATED Indicates that the buffer was too small.  That is, "len" bytes of "ptr" were consumed before reaching the end of the encoded message; no output parameters are  created. SNMPAPI_MESSAGE_INVALID The SNMP message described by the 'msgBufDesc' parameter is invalid; no output resources are created. Comments: The SmnpDecodeMsg function is meant to be symmetrical with the SnmpEncodeMsg function.  Refer to SnmpEncodeMsg for additional insight into the operation and possible failure modes of the SnmpDecodeMsg function.  AUTONUMLGL   SnmpFreeDescriptor() The SnmpFreeDescriptor function is used by the application to inform the implementation that it no longer requires access to a WinSNMP  descriptor object  that had been  populated  earlier on its behalf by the implementation. Syntax: SNMPAPI_STATUS  SnmpFreeDescriptor ( smiUINT32 syntax, smiLPOPAQUE descriptor); Parameter Description syntax  Identifies the  syntax  (data type) of the target descriptor. descriptor Identifies the target descriptor object.. Returns: Upon successful completion, SnmpFreeDescriptor returns SNMPAPI_SUCCESS. If SnmpFreeDescriptor fails, the return value will be SNMPAPI_FAILURE and SnmpGetLastError will be set to report one of the following: SnmpGetLastError() Description "Common Error Codes" See Section   REF _Ref295972232 \* MERGEFORMAT  2.10.1. Common Error Codes SNMPAPI_SYNTAX_INVALID Indicates that the syntax parameter is invalid for this function. SNMPAPI_OPERATION_INVALID Indicates that the descriptor parameter is invalid for this function. Comments: See Section   REF _Ref296104548 \* MERGEFORMAT  2.11.4. Descriptors WinSNMP  descriptor objects  are either smiOID or smiOCTETS structures (or equivalents, such as smiIPADDR and smiOPAQUE) and consist of a   member and a   member. These objects are  populated  by the implementation on behalf of the application in response to any   parameter of type smiOID, smiOCTETS, and smiVALUE.  (Note that any smiVALUE structure may or may not contain an smiOID or smiOCTETS structure in its  value  member upon return from SnmpGetVb, as will be indicated by the associated  syntax  member of the smiVALUE structure.)  In addition to SnmpGetVb, the following functions also result in the implementation populating a descriptor object for the application:  SnmpContextToStr, SnmpStrToOid, SnmpOidCopy, SnmpEncodeMsg.  Others may be added later. Note that applications should not attempt to free memory returned in the   member of descriptor objects that have been populated by the implementation.  The method of memory allocation and, consequently, deallocation, for these variables is private to the implementation, and hidden from the application except for the SnmpFreeDescriptor interface described above. Note that the  syntax  parameter can be used by implementations to distinguish among different varieties of  descriptor objects, if necessary.  The SNMPAPI_OPERATION_INVALID error can be returned if, for example, the  descriptor  parameter does not satisfy implementation-specific requirements (e.g., the implementation can recognize that the   member does not identify an allocation that it has made on behalf of the calling application or if the indicated allocation had already been released by the application in a prior call to SnmpFreeDescriptor). autonumlgl   Declarations This section--exclusive of  this preamble text--constitutes the WinSNMP.h include file containing common declarations for SNMP datatypes, attributes, and values and for WinSNMP API datatypes, attributes, and values.  This section (minus this preamble text) must be delivered as WinSNMP.h with every compliant implementation. Additional declarations required or offered by an implementation must be delivered in a separate include file with an implementation-specific name. An attempt has been made to balance brevity and clarity in these declarations.  In general, however, there has been a slight bias toward brevity.  Developers can easily include longer, more descriptive equivalents to the declarations through additional #define and typedef statements in a private include files loaded after WinSNMP.h. /* v1.1 WinSNMP.h */ /* v1.0 - Sep 13, 1993 */ /* v1.1 - Jun 10, 1994 */ #ifndef _INC_WINSNMP /* Include WinSNMP declarations */ #define  _INC_WINSNMP  /* Just once! */ #ifndef _INC_WINDOWS /* Include Windows declarations, if not already done */ #include <windows.h> #define _INC_WINDOWS  /* Just once! */ #endif /* _INC_WINDOWS */ #ifdef __cplusplus extern "C" { #endif /* WinSNMP API Type Definitions  */ typedef  HANDLE HSNMP_SESSION,  FAR *LPHSNMP_SESSION; typedef  HANDLE HSNMP_ENTITY,   FAR *LPHSNMP_ENTITY; typedef  HANDLE HSNMP_CONTEXT,  FAR *LPHSNMP_CONTEXT; typedef  HANDLE HSNMP_PDU, FAR *LPHSNMP_PDU; typedef  HANDLE HSNMP_VBL, FAR *LPHSNMP_VBL; typedef unsigned char smiBYTE, FAR *smiLPBYTE; /* SNMP-related types from RFC1442 (SMI) */ typedef signed long smiINT, FAR *smiLPINT; typedef smiINT smiINT32, FAR *smiLPINT32; typedef unsigned long smiUINT32, FAR *smiLPUINT32; typedef struct {      smiUINT32 len;      smiLPBYTE ptr;} smiOCTETS, FAR *smiLPOCTETS; typedef const smiOCTETS FAR *smiLPCOCTETS; typedef smiOCTETS smiBITS, FAR *smiLPBITS; typedef struct {      smiUINT32   len;      smiLPUINT32 ptr;} smiOID, FAR *smiLPOID; typedef const smiOID FAR *smiLPCOID; typedef smiOCTETS smiIPADDR, FAR *smiLPIPADDR; typedef smiUINT32 smiCNTR32, FAR *smiLPCNTR32; typedef smiUINT32 smiGAUGE32, FAR *smiLPGAUGE32; typedef smiUINT32 smiTIMETICKS, FAR *smiLPTIMETICKS; typedef smiOCTETS smiOPAQUE, FAR *smiLPOPAQUE; typedef smiOCTETS smiNSAPADDR, FAR *smiLPNSAPADDR; typedef struct {         smiUINT32 hipart;         smiUINT32 lopart;} smiCNTR64, FAR *smiLPCNTR64; /* ASN/BER Base Types */ /* (used in forming SYNTAXes and certain SNMP types/values) */ #define ASN_UNIVERSAL (0x00) #define ASN_APPLICATION (0x40) #define ASN_CONTEXT (0x80) #define ASN_PRIVATE (0xC0) #define ASN_PRIMITIVE (0x00) #define ASN_CONSTRUCTOR (0x20) /* SNMP ObjectSyntax Values */ #define SNMP_SYNTAX_SEQUENCE (ASN_UNIVERSAL | ASN_CONSTRUCTOR | 0x10) /* These values are used in the "syntax" member of the smiVALUE structure which follows */ #define SNMP_SYNTAX_INT (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x02) #define SNMP_SYNTAX_BITS (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x03) #define SNMP_SYNTAX_OCTETS (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x04) #define SNMP_SYNTAX_NULL (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x05) #define SNMP_SYNTAX_OID (ASN_UNIVERSAL | ASN_PRIMITIVE | 0x06) #define SNMP_SYNTAX_INT32 SNMP_SYNTAX_INT #define SNMP_SYNTAX_IPADDR (ASN_APPLICATION | ASN_PRIMITIVE | 0x00) #define SNMP_SYNTAX_CNTR32 (ASN_APPLICATION | ASN_PRIMITIVE | 0x01) #define SNMP_SYNTAX_GAUGE32 (ASN_APPLICATION | ASN_PRIMITIVE | 0x02) #define SNMP_SYNTAX_TIMETICKS (ASN_APPLICATION | ASN_PRIMITIVE | 0x03) #define SNMP_SYNTAX_OPAQUE (ASN_APPLICATION | ASN_PRIMITIVE | 0x04) #define SNMP_SYNTAX_NSAPADDR (ASN_APPLICATION | ASN_PRIMITIVE | 0x05) #define SNMP_SYNTAX_CNTR64 (ASN_APPLICATION | ASN_PRIMITIVE | 0x06) #define SNMP_SYNTAX_UINT32 (ASN_APPLICATION | ASN_PRIMITIVE | 0x07) /* Exception conditions in response PDUs for SNMPv2 */ #define SNMP_SYNTAX_NOSUCHOBJECT (ASN_CONTEXT | ASN_PRIMITIVE | 0x00) #define SNMP_SYNTAX_NOSUCHINSTANCE (ASN_CONTEXT | ASN_PRIMITIVE | 0x01) #define SNMP_SYNTAX_ENDOFMIBVIEW (ASN_CONTEXT | ASN_PRIMITIVE | 0x02) typedef struct { /* smiVALUE portion of VarBind */ smiUINT32 syntax; /* Insert SNMP_SYNTAX_<type> */ union { smiINT sNumber; /* SNMP_SYNTAX_INT    SNMP_SYNTAX_INT32 */ smiUINT32 uNumber; /* SNMP_SYNTAX_UINT32                                        SNMP_SYNTAX_CNTR32                                        SNMP_SYNTAX_GAUGE32                                        SNMP_SYNTAX_TIMETICKS */ smiCNTR64 hNumber; /* SNMP_SYNTAX_CNTR64 */ smiOCTETS string; /* SNMP_SYNTAX_OCTETS    SNMP_SYNTAX_BITS    SNMP_SYNTAX_OPAQUE    SNMP_SYNTAX_IPADDR    SNMP_SYNTAX_NSAPADDR */ smiOID /* SNMP_SYNTAX_OID */ smiBYTE empty; /* SNMP_SYNTAX_NULL    SNMP_SYNTAX_NOSUCHOBJECT    SNMP_SYNTAX_NOSUCHINSTANCE    SNMP_SYNTAX_ENDOFMIBVIEW */         } value; /* union */ smiVALUE, FAR *smiLPVALUE; typedef const smiVALUE FAR *smiLPCVALUE; /* SNMP Limits   */ #define MAXOBJIDSIZE /* Max number of components in an OID */ #define MAXOBJIDSTRSIZE /* Max len of decoded MAXOBJIDSIZE OID */ /* PDU Type Values */ #define SNMP_PDU_GET (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x0) #define SNMP_PDU_GETNEXT (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x1) #define SNMP_PDU_RESPONSE (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x2) #define SNMP_PDU_SET (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x3) /* SNMP_PDU_V1TRAP is obsolete in SNMPv2 */ #define SNMP_PDU_V1TRAP (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x4) #define SNMP_PDU_GETBULK (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x5) #define SNMP_PDU_INFORM (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x6) #define SNMP_PDU_TRAP (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x7) /* SNMPv1 Trap Values */ /* (These values might be superfluous wrt WinSNMP applications) */ #define SNMP_TRAP_COLDSTART #define SNMP_TRAP_WARMSTART #define SNMP_TRAP_LINKDOWN #define SNMP_TRAP_LINKUP #define SNMP_TRAP_AUTHFAIL #define SNMP_TRAP_EGPNEIGHBORLOSS #define SNMP_TRAP_ENTERPRISESPECIFIC /* SNMP Error Codes Returned in Error_status Field of PDU */ /* (these are NOT WinSNMP API Error Codes */ /* Error Codes Common to SNMPv1 and SNMPv2 */ #define SNMP_ERROR_NOERROR #define SNMP_ERROR_TOOBIG #define SNMP_ERROR_NOSUCHNAME #define SNMP_ERROR_BADVALUE #define SNMP_ERROR_READONLY #define SNMP_ERROR_GENERR /* Error Codes Added for SNMPv2 */ #define SNMP_ERROR_NOACCESS #define SNMP_ERROR_WRONGTYPE #define SNMP_ERROR_WRONGLENGTH #define SNMP_ERROR_WRONGENCODING #define SNMP_ERROR_WRONGVALUE #define SNMP_ERROR_NOCREATION #define SNMP_ERROR_INCONSISTENTVALUE #define SNMP_ERROR_RESOURCEUNAVAILABLE #define SNMP_ERROR_COMMITFAILED #define SNMP_ERROR_UNDOFAILED #define SNMP_ERROR_AUTHORIZATIONERROR #define SNMP_ERROR_NOTWRITABLE #define SNMP_ERROR_INCONSISTENTNAME /* WinSNMP API Values */ /* Values used to indicate entity/context translation modes */ #define SNMPAPI_TRANSLATED           #define SNMPAPI_UNTRANSLATED_V1 #define SNMPAPI_UNTRANSLATED_V2 /* Values used to indicate SNMP "communications  level" supported by the implementation */ #define SNMPAPI_NO_SUPPORT #define SNMPAPI_V1_SUPPORT #define SNMPAPI_V2_SUPPORT #define SNMPAPI_M2M_SUPPORT /* Values used to indicate retransmit mode in the implementation */ #define SNMPAPI_OFF /* Refuse support */ #define SNMPAPI_ON /* Request support */ /* WinSNMP API Function Return Codes */ typedef smiUINT32 SNMPAPI_STATUS; /* Used for function ret values */ #define SNMPAPI_FAILURE /* Generic error code */ #define SNMPAPI_SUCCESS /* Generic success code */ /* WinSNMP API Error Codes (for SnmpGetLastError) */ /* (NOT SNMP Response-PDU error_status codes) */ #define SNMPAPI_ALLOC_ERROR /* Error allocating memory */ #define SNMPAPI_CONTEXT_INVALID /* Invalid context parameter */ #define SNMPAPI_CONTEXT_UNKNOWN /* Unknown context parameter */ #define SNMPAPI_ENTITY_INVALID /* Invalid entity parameter */ #define SNMPAPI_ENTITY_UNKNOWN /* Unknown entity parameter */ #define SNMPAPI_INDEX_INVALID /* Invalid VBL index parameter */ #define SNMPAPI_NOOP /* No operation performed */ #define SNMPAPI_OID_INVALID /* Invalid OID parameter */ #define SNMPAPI_OPERATION_INVALID /* Invalid/unsupported operation */ #define SNMPAPI_OUTPUT_TRUNCATED /* Insufficient output buf len */ #define SNMPAPI_PDU_INVALID /* Invalid PDU parameter */ #define SNMPAPI_SESSION_INVALID /* Invalid session parameter */ #define SNMPAPI_SYNTAX_INVALID /* Invalid syntax in smiVALUE */ #define SNMPAPI_VBL_INVALID /* Invalid VBL parameter */ #define SNMPAPI_MODE_INVALID /* Invalid mode parameter */ #define SNMPAPI_SIZE_INVALID /* Invalid size/length parameter */ #define SNMPAPI_NOT_INITIALIZED /* SnmpStartup failed/not called */ #define SNMPAPI_MESSAGE_INVALID /* Invalid SNMP message format */ #define SNMPAPI_HWND_INVALID /* Invalid Window handle */ #define SNMPAPI_OTHER_ERROR /* For internal/undefined errors */ /* Generic Transport Layer (TL) Errors */ #define SNMPAPI_TL_NOT_INITIALIZED /* TL not initialized */ #define SNMPAPI_TL_NOT_SUPPORTED /* TL does not support protocol */ #define SNMPAPI_TL_NOT_AVAILABLE /* Network subsystem has failed */ #define SNMPAPI_TL_RESOURCE_ERROR /* TL resource error */ #define SNMPAPI_TL_UNDELIVERABLE /* Destination unreachable */ #define SNMPAPI_TL_SRC_INVALID /* Source endpoint invalid */ #define SNMPAPI_TL_INVALID_PARAM /* Input parameter invalid */ #define SNMPAPI_TL_IN_USE /* Source endpoint in use */ #define SNMPAPI_TL_TIMEOUT /* No response before timeout */ #define SNMPAPI_TL_PDU_TOO_BIG /* PDU too big for send/receive */ #define SNMPAPI_TL_OTHER /* Undefined TL error */ /* WinSNMP API Function Prototypes */ #define IN /* Documentation only */ #define OUT /* Documentation only */ #define SNMPAPI_CALL WINAPI /* FAR PASCAL calling conventions */ /* Local Database Functions */ SNMPAPI_STATUS SNMPAPI_CALL SnmpGetTranslateMode (OUT smiLPUINT32 nTranslateMode); SNMPAPI_STATUS SNMPAPI_CALL SnmpSetTranslateMode (IN smiUINT32 nTranslateMode); SNMPAPI_STATUS SNMPAPI_CALL SnmpGetRetransmitMode (OUT smiLPUINT32 nRetransmitMode); SNMPAPI_STATUS SNMPAPI_CALL SnmpSetRetransmitMode (IN smiUINT32 nRetransmitMode); SNMPAPI_STATUS SNMPAPI_CALL SnmpGetTimeout (IN HSNMP_ENTITY hEntity, OUT smiLPTIMETICKS nPolicyTimeout, OUT smiLPTIMETICKS nActualTimeout); SNMPAPI_STATUS SNMPAPI_CALL SnmpSetTimeout (IN HSNMP_ENTITY hEntity, IN smiTIMETICKS nPolicyTimeout); SNMPAPI_STATUS SNMPAPI_CALL SnmpGetRetry (IN HSNMP_ENTITY hEntity, OUT smiLPUINT32 nPolicyRetry, OUT smiLPUINT32 nActualRetry); SNMPAPI_STATUS SNMPAPI_CALL SnmpSetRetry (IN HSNMP_ENTITY hEntity, IN smiUINT32 nPolicyRetry); /* Communications Functions */ SNMPAPI_STATUS SNMPAPI_CALL SnmpStartup (OUT smiLPUINT32 nMajorVersion, OUT smiLPUINT32 nMinorVersion, OUT smiLPUINT32 nLevel, OUT smiLPUINT32 nTranslateMode, OUT smiLPUINT32 nRetransmitMode); SNMPAPI_STATUS SNMPAPI_CALL SnmpCleanup (void); HSNMP_SESSION  SNMPAPI_CALL SnmpOpen (IN HWND hWnd, IN UINT wMsg); SNMPAPI_STATUS SNMPAPI_CALL SnmpClose (IN HSNMP_SESSION session); SNMPAPI_STATUS SNMPAPI_CALL SnmpSendMsg (IN HSNMP_SESSION session, IN HSNMP_ENTITY srcEntity, IN HSNMP_ENTITY dstEntity, IN HSNMP_CONTEXT context, IN HSNMP_PDU PDU); SNMPAPI_STATUS SNMPAPI_CALL SnmpRecvMsg (IN HSNMP_SESSION session, OUT LPHSNMP_ENTITY srcEntity, OUT LPHSNMP_ENTITY dstEntity, OUT LPHSNMP_CONTEXT  context, OUT LPHSNMP_PDU PDU); SNMPAPI_STATUS SNMPAPI_CALL SnmpRegister (IN HSNMP_SESSION session, IN HSNMP_ENTITY srcEntity, IN HSNMP_ENTITY dstEntity, IN HSNMP_CONTEXT context, IN smiLPCOID notification, IN smiUINT32 state); /* Entity/Context Functions */ HSNMP_ENTITY SNMPAPI_CALL SnmpStrToEntity (IN HSNMP_SESSION session, IN LPCSTR string); SNMPAPI_STATUS SNMPAPI_CALL SnmpEntityToStr (IN HSNMP_ENTITY entity, IN smiUINT32 size, OUT LPSTR string); SNMPAPI_STATUS SNMPAPI_CALL SnmpFreeEntity (IN HSNMP_ENTITY entity); HSNMP_CONTEXT SNMPAPI_CALL SnmpStrToContext (IN HSNMP_SESSION session, IN smiLPCOCTETS string); SNMPAPI_STATUS SNMPAPI_CALL SnmpContextToStr (IN HSNMP_CONTEXT context, OUT smiLPOCTETS string); SNMPAPI_STATUS SNMPAPI_CALL SnmpFreeContext (IN HSNMP_CONTEXT context); /* PDU Functions */ HSNMP_PDU SNMPAPI_CALL SnmpCreatePdu (IN HSNMP_SESSION session, IN smiINT PDU_type, IN smiINT32 request_id, IN smiINT error_status, IN smiINT error_index, IN HSNMP_VBL varbindlist); SNMPAPI_STATUS SNMPAPI_CALL SnmpGetPduData (IN HSNMP_PDU PDU, OUT smiLPINT PDU_type, OUT smiLPINT32 request_id, OUT smiLPINT error_status, OUT smiLPINT error_index, OUT LPHSNMP_VBL varbindlist); SNMPAPI_STATUS SNMPAPI_CALL SnmpSetPduData (IN HSNMP_PDU PDU, IN const smiINT FAR *PDU_type, IN const smiINT32 FAR *request_id, IN const smiINT FAR *non_repeaters, IN const smiINT FAR *max_repetitions, IN const HSNMP_VBL FAR *varbindlist); HSNMP_PDU SNMPAPI_CALL SnmpDuplicatePdu (IN HSNMP_SESSION session, IN HSNMP_PDU PDU); SNMPAPI_STATUS SNMPAPI_CALL SnmpFreePdu (IN HSNMP_PDU PDU); /* Variable-Binding Functions */ HSNMP_VBL SNMPAPI_CALL SnmpCreateVbl (IN HSNMP_SESSION session, IN smiLPCOID name, IN smiLPCVALUE value); HSNMP_VBL SNMPAPI_CALL SnmpDuplicateVbl (IN HSNMP_SESSION session, IN HSNMP_VBL vbl); SNMPAPI_STATUS SNMPAPI_CALL SnmpFreeVbl (IN HSNMP_VBL vbl); SNMPAPI_STATUS SNMPAPI_CALL SnmpCountVbl (IN HSNMP_VBL vbl); SNMPAPI_STATUS SNMPAPI_CALL SnmpGetVb (IN HSNMP_VBL vbl, IN smiUINT32 index, OUT smiLPOID name, OUT smiLPVALUE value); SNMPAPI_STATUS SNMPAPI_CALL SnmpSetVb (IN HSNMP_VBL vbl, IN smiUINT32 index, IN smiLPCOID name, IN smiLPCVALUE value); SNMPAPI_STATUS SNMPAPI_CALL SnmpDeleteVb (IN HSNMP_VBL vbl, IN smiUINT32 index); /* Utility Functions */ SNMPAPI_STATUS SNMPAPI_CALL SnmpGetLastError (IN HSNMP_SESSION session); SNMPAPI_STATUS SNMPAPI_CALL SnmpStrToOid (IN LPCSTR string, OUT smiLPOID dstOID); SNMPAPI_STATUS SNMPAPI_CALL SnmpOidToStr (IN smiLPCOID srcOID, IN smiUINT32 size, OUT LPSTR string); SNMPAPI_STATUS SNMPAPI_CALL SnmpOidCopy (IN smiLPCOID srcOID, OUT smiLPOID dstOID); SNMPAPI_STATUS SNMPAPI_CALL SnmpOidCompare (IN smiLPCOID xOID, IN smiLPCOID yOID, IN smiUINT32 maxlen, OUT smiLPINT result); SNMPAPI_STATUS SNMPAPI_CALL SnmpEncodeMsg (IN HSNMP_SESSION session, IN HSNMP_ENTITY srcEntity, IN HSNMP_ENTITY dstEntity, IN HSNMP_CONTEXT context, IN HSNMP_PDU pdu, OUT smiLPOCTETS msgBufDesc); SNMPAPI_STATUS SNMPAPI_CALL SnmpDecodeMsg (IN HSNMP_SESSION session, OUT LPHSNMP_ENTITY srcEntity, OUT LPHSNMP_ENTITY dstEntity, OUT LPHSNMP_CONTEXT context, OUT LPHSNMP_PDU pdu, IN smiLPCOCTETS msgBufDesc); SNMPAPI_STATUS SNMPAPI_CALL SnmpFreeDescriptor (IN smiUINT32 syntax, IN smiLPOPAQUE descriptor); #ifdef __cplusplus #endif #endif /* _INC_WINSNMP */ Appendix A. Mapping Traps Between SNMPv1 and SNMPv2 One of the differences between SNMPv1 and SNMPv2 is a change to the trap format: In SNMPv1, the trap format was unlike the format of the other protocol data units; in SNMPv2 the trap format is identical to the format of the other PDUs. When the WinSNMP API delivers a trap to a management application, it always uses the SNMPv2 trap format, even if an SNMPv1 agent generated the trap.  The SNMPv2 coexistence document, RFC 1452, specifies how an SNMPv1 trap is translated into the SNMPv2 trap format, and this algorithm is used in all implementations of the WinSNMP API. In SNMPv1, the trap format has five fields: - enterprise, which identified the type of device which generated the trap; - agent-addr, which identified the network address of the device; - generic-trap/specific-trap, which identified the trap which was generated; - time-stamp, which identified when the trap was generated; and, - variable-bindings, which contained the "payload", if any, associated with the trap. In SNMPv2, the trap format consists simply of a list of "N'' variable bindings, in which: - the first variable binding contains the time-stamp; - the second variable binding identifies the trap, using an OBJECT IDENTIFIER; - the third through "N'' variable bindings, if any, contain the payload. Hence, when SnmpRecvMsg returns a message whose operation type is SNMP_PDU_TRAP, the application need only examine the variable-bindings of that message in order to ascertain the information associated with the trap. When translating an SNMPv1 trap to the SNMPv2 format, one additional variable binding may be present, at the end of the list, which corresponds to the enterprise field.  According to the SNMPv2 coexistence document, this variable binding need only be present if the trap was enterprise-specific.  However, in order to simplify the programming of management applications, this variable binding is always added by the WinSNMP API when it translates an SNMPv1 trap to the SNMPv2 format. The following code fragment shows how an application can examine the variable-bindings in order to retrieve all of the information associated with a trap. SNMPAPI_STATUS TrapProcess (HSNMP_SESSION hSession)         HSNMP_ENTITY hSrc, hDest;         HSNMP_CONTEXT hContext;         HSNMP_PDU hPDU;         HSNMP_VBL hVBL;         smiINT32 Request_id;         smiINT PduType, Err_stat, Err_index;         SNMPAPI_STATUS RetStatus, Index, VBCount;         smiOID   Name;         smiVALUE Value;         smiBYTE  NameBuffer[100], ValueBuffer[256];         ...         Request_id = SnmpRecvMsg (                 hSession,  // Trap Session Handle                 &hSrc,  // Source Entity Handle                 &hDest,  // Destination Entity Handle                 &hContext, // Context Handle                 &hPDU); // PDU Handle         // Error condition checking for SnmpRecvMsg() performs here.                  RetStatus = SnmpGetPduData (                 hPDU,  // PDU Handle                 &PduType,  // PDU return type                 &Request_id,  // Request ID of the Trap                 &Err_stat,  // Error status for a variable                 &Err_index,  // Index to the variable with error                 &hVBL);  // Handle to the Varbindlist         // Sample error checking for SnmpGetPduData():         if ((RetStatus == SNMPAPI_FAILURE) ||             (PduType != SNMP_PDU_TRAP) ||             (Err_stat != SNMP_ERROR_NOERROR)) {                 SnmpFreePdu(hPDU);                 SnmpFreeEntity(hSrc);                 SnmpFreeEntity(hDest);                 SnmpFreeContext(hContext);                 return (SnmpGetLastError(hSession));         }         VBCount = SnmpCountVbl(hVBL);         for (Index = 1; i <= VBCount; Index ++) {                 // When Index = 1,                  //  Oid   = sysUpTimeOid                 //  Value = uptime value for the V1 time-stamp trap field                 // When Index = 2,                 //  Oid   = v2snmpTrapOid                 //  value = can be one of the following Oids:                 //              v2coldStartOid                 //              v2warmStartOid                 //              v2linkDownOid                 //              v2linkUpOid                 //              v2authenFailureOid                 //              v2egpNeighborLossOid                 //              v2snmpTrapEnterpriseOid+0+specific_trap                 // When Index = VBCount, (the last Oid in the v2 trap)                 //  Oid   = v2snmpTrapEnterpriseOid                 //  Value = enterprise specific Oid from V1 trap               // Get a particular variable from the Varbindlist               // using the given Index.                 RetStatus = SnmpGetVb (                      hVBL, // Input Varbindlist Handle                      Index, // Index to a variable                      &Name,  // Output name of the variable                      &Value); // Output value of the variable                 // Error condition checking for RetStatus performs here                 SnmpOidToStr (&Name, 100, (LPSTR)NameBuffer);                 SnmpFreeDescriptor (SNMP_SYNTAX_OID, &Name);                 switch (Value.syntax) {                                          case SNMP_SYNTAX_INT :                         _ltoa ((long)Value.value.sNumber, ValueBuffer, 10);                         break;                         case SNMP_SYNTAX_UINT32 :                         case SNMP_SYNTAX_CNTR32 :                         case SNMP_SYNTAX_GAUGE32 :                         case SNMP_SYNTAX_TIMETICKS :                         _ltoa ((long)Value.value.uNumber, ValueBuffer, 10);                         break;                         case SNMP_SYNTAX_CNTR64 :                         break; // Need routine to convert 64-bit number to string here!                         case SNMP_SYNTAX_OCTETS :                         case SNMP_SYNTAX_BITS :                         case SNMP_SYNTAX_OPAQUE :                         case SNMP_SYNTAX_IPADDR :                         case SNMP_SYNTAX_NSAPADDR :                         _fmemcpy (ValueBuffer, Value.value.string.ptr, (size_t)Value.value.string.len);                         SnmpFreeDescriptor (SNMP_SYNTAX_OCTETS, &Value.value.string);                         break;                         case SNMP_SYNTAX_OID :                         SnmpOidToStr (&Value.value.oid, 256, ValueBuffer);                         SnmpFreeDescriptor (SNMP_SYNTAX_OID, &Value.value.oid);                         break;                 } // switch                 OutputVariable (                         Index, // Index to a given variable for output                         NameBuffer, // Trap variable Oid Name Output Buffer                         ValueBuffer); // Trap variable Value Output Buffer         } //for loop                  SnmpFreeEntity (hSrc);         SnmpFreeEntity (hDest);         SnmpFreeContext (hContext);         SnmpFreeVbl (hVBL);         SnmpFreePdu (hPDU);         return SNMPAPI_SUCCESS; } // TrapProcess Appendix B. Usage Example Sample applications will be published separately due to size and packaging considerations. Appendix C.  WinSNMP++ Prototype The following table shows a possible mapping between the C interface of the WinSNMP API specification and a set of C++ wrappers.  This is strictly an informational Appendix and does not constitute a part of the official Windows SNMP API specification at this time. The content was contributed by Maria Greene, and was well-discussed on the list.  Unless otherwise noted, obvious differences between the WinSNMP C interface specifications and the WinSNMP++ interface prototypes shown below are simply due to changes being made to the C interface after this Appendix was inserted.  Therefore, future edits for consistency--according to the pattern demonstrated herein--can be assumed. Please note the re-positioning of the varbindlist parameter in the SnmpCreatePdu and SnmpSetPduData C++ equivalents is intentional and permits applications to take advantage of certain C++ language-specific features. Class/Returns C++ Interface C Interface Session:: Session (    Entity &srcEntity,     HWND hWnd,     UINT wMsg) SnmpOpen ~Session (void) SnmpClose SendMsg (    const Entity &dstEntity,     const Context &context,     const Pdu &PDU)             SnmpSendMsg Pdu * RecvMsg (    Entity &srcEntity,    Entity &dstEntity,    Context &context)    SnmpRecvMsg Register (    const Entity &entity,     const Context &context,               const Oid &notification = NULL,       BOOL enabled = TRUE)    SnmpRegister Entity:: Entity (const LPSTR entity)                 Entity (const Entity &entity) SnmpStrToEntity ~Entity (void) SnmpFreeEntity               Entity operator const char*() const   &operator  =  (const Entity &entity) SnmpEntityToStr Context:: Context (const LPSTR context)                Context (const Context &context) SnmpStrToContext ~Context (void)  SnmpFreeContext                 Context operator const char*() const &operator  = (const Context &context) SnmpContextToStr SnmpUtil::  SnmpUtil (???) SnmpStartup ~SnmpUtil (void) SnmpCleanup ????  EnumEntities (???) SnmpEnumEntities EnumContexts (???) SnmpEnumContexts GetLastError (void) SnmpGetLastError DWORD Version (void) SnmpUtilVersion Class/Returns C++ Interface C Interface Pdu:: Pdu (    smiINT PDU_type=       SNMP_PDU_GETNEXT,     VarBindList *varbindlist = NULL,    smiINT32 request_id = 0,    smiINT non_repeaters = 0,    smiINT max_repetitions = 0)     SnmpCreatePdu  Pdu (const Pdu &PDU)  SnmpDuplicatePdu ~Pdu (void)  SnmpFreePdu GetData (    smiLPINT PDU_type = NULL,    smiLPINT32 request_id = NULL,    smiLPINT error_status = NULL,    smiLPINT error_index = NULL,    VarBindList **varbindlist = NULL)  SnmpGetPduData BOOL  SetData (    smiINT PDU_type =        SNMP_PDU_GETNEXT,    VarBindList *pvarbindlist = NULL,    smiINT32 request_id = 0,    smiINT non_repeaters = 0,    smiINT max_repetitions = 0) SnmpSetPduData &operator = (const Pdu &PDU) VarBindList:: VarBindList (    Oid *poid = NULL,     smiLPVALUE value = NULL) SnmpCreateVbl VarBindList (&VarBindList) SnmpDuplicateVbl ~VarBindList (void)  SnmpFreeVbl smiINT  Count (void) SnmpCountVbl GetVb (    smiINT index,    Oid &oid,     smiLPVALUE value) SnmpGetVb SetVb (    Oid &oid,    smiLPVALUE value)  SnmpSetVb DeleteVb (Oid &oid) SnmpDeleteVb VarBindList &operator  = (const VarBindList &varbindlist) Oid:: Oid (LPSTR str =  NULL) SnmpUtilStrToOid Oid (const Oid &oid)  SnmpUtilOidCpy ~Oid (void) operator const char*() const   SnmpUtilOidToStr &operator += (const Oid &oid) SnmpUtilOidAppend operator == (const Oid &oid) const SnmpUtilOidCmp &operator = (const LPSTR str)  SnmpUtilStrToOid &operator = (const Oid &oid) SnmpUtilOidCpy smiINT NCmp (    const Oid &oid,     smiUINT32 len = 0) const SnmpUtilOidNCmp  Introduction                                                                                          ~{xur zupkfb] |wrmid_Z |xsnid_[ |wrnid_Z }xsnie`[ |xsnid_[ |wrnid_Z ~{xurolif {wrmhd ~zupkgb] zuqlgb^ {xurje] {vqmhc_Z |xsnje`\ |wsnie`[ }xsojea\ |yvspmjb {xurolifc` ~{xur yqif` ~vspmjgda^ }uphc[XU zumjda^[S ~{xurolifc }zwtq |wrmhc_ |yvspkfc zurol }zwqnk {vqnkh ~{xurol ~zupkf }xsnid`[ |yvspmjg }zwto ~{xurm ~ytoje ~{xurolg ~{vqlg |yvspm zuqlgb] ~{xurl }zurmh ~ytqnkh |yvsp ~{xuro }xsnid_ zvqlhc^ |wrnid` |wsmjgda^ zwtqnkh |yvsni zwtqnkh zwtqnk |wrmid_Z ~zuqlhc_ |yvspmjd }zwtqnk ~{xupm |wrmjg {vqnkh }xsnid_[ |wrmh ~{xurm }zwqnk zwtqni }zupkf |yvspkf }ytoje` }xsoje`\ ~ytpmhc^Z |wrmhc^Y ~ytojfa\ ~yupkfb]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\docs\winsnmp2.txt ===
WinSNMP v2.0 Addendum

Document version information:

	November 1, 1997 - Initial Release Version
	December 5, 1997 - Typos wrt SnmpListen() params fixed

Document contents information:

       I - Introduction

      II - Clarifications for WinSNMP v2.0:

          1.  Version 2.0
          2.  Level definitions
          3.  Operating system dependencies
          4.  Retransmission support
          5.  Timeout notification methods
          6.  SNMPv1 Trap-PDU generation
          7.  Notification port usage
          8.  Request-ID/SnmpCreatePdu()/SnmpSetPdu()
          9.  SnmpGetPduData() and hVbl
         10.  GetBulk -> GetNext mapping
         11.  IPX support in SnmpStrToEntity()
         12.  SnmpDecodeMsg() outputs
         13.  Inform processing
         14.  Thread-safeness
         15.  WinSNMP++ -> SNMP++ change
         16.  SnmpRegister()

     III - New functions for WinSNMP v2.0:

          1.  SnmpCreateSession()
          2.  SnmpCreateEntity()
          3.  SnmpCreateContext()
          4.  SnmpCancelMsg()
          5.  SnmpSetPort()
          6.  SnmpListen()
          7.  SnmpGetVendorInfo()
          8.  SnmpOpen() [Re-written for v2.0]

I - Introduction

This document is an update Addendum to the WinSNMP/Manager
API Specification, v1.1a, dated August 9, 1995).  In some
places (Section II below, especially) it modifies (via
clarifying text) that earlier document; in other places
(Section III below, especially) it adds completely new
functionality.  Users of the WinSNMP API--implementors
and application developers must be familiar with both
documents until such time as the new WinSNMP API v2.0
specification document is published.  Said document will
incorporate all of the text in the final version of this
update Addendum.

Like the WinSNMP API specification document itself, this
document is intended to be freely available for use by
all interested parties.  It is the product of an open,
collaborative effort via the ad hoc WinSNMP Industry Forum
e-mail discussion list (winsnmp@mailbag.intel.com).
Numerous individuals have contributed to the WinSNMP API
since this work was started in the 1992/93 time frame.

II - Clarifications

1.  Version 2.0

The collection of clarifications to v1.1a of the
WinSNMP/Manager API specification described herein defines
v2.0 of the WinSNMP API specification.

A compliant v2.0 implementation MUST support ALL of the
functions and operations defined in both the WinSNMP v1.1a
specification and is this WinSNMP v2.0 Addendum.

Where this WinSNMP v2.0 Addendum differs from the WinSNMP
v1.1a specification, this Addendum has precedence.

Note that for v2.0, the SnmpStartup() function must return a
value of 2 for the lMajor parameter and a value of 0 for the
lMinor parameter.

Note also that the "/Manager" qualifier is dropped for v2.0.
This version explicitly supports agent-side SNMP operations,
in addition to the manager-side SNMP operations.

2.  Level definitions

The concept of "levels of support" is deprecated for v2.0.
Implementations must report a value of 2 for the lLevel
parameter of SnmpStartup().

Level 2 equates to full support for the IETF standard SNMPv2
protocol as defined in RFCs 1902-1908 with the community-
based message wrapper as defined in RFC 1901 (SNMPv2c).

Levels 0 and 1 are fully subsumed under Level 2.  That is,
in addition to full SNMPv2 support (as defined in the
previous paragraph), all WinSNMP v2.0 implementations must
implement the SnmpEncodeMsg() and SnmpDecodeMsg() functions
(since no WinSNMP functions are optional in any case) and
must also support all SNMPv1 protocol operations (except
that, as always, all received SNMPv1 traps are converted
to SNMPv2 Trap-PDU format for delivery to registered WinSNMP
applications).

Level 3, as originally defined, is no longer germane since the
"Manager-to-Manager" MIB of "SNMPv2-Classic" was deprecated to
"Historic" status by the IESG and, on the positive side, the
combination of SNMPv2 support (especially, InformRequest-PDUs
and their associated Response-PDUs) and the new functions to
support agent applications under WinSNMP v2.0 (especially, the
SnmpListen() function) now provide the basis for building
Mid-Level Manager (MLM) solutions using WinSNMP.  Additionally,
it is envisioned that the next major revision of WinSNMP (v3)
will correspond to adding support for the eventual IETF SNMPv3.

(You will note that the proposed SnmpCreateEntity() and
SnmpCreateContext() functions which were included in the
earlier drafts of this Addendum have been dropped.  It is
anticipated that they will be added in WinSNMP v3 to support
the corresponding constructs which will (almost surely!) be
included in SNMPv3.)

"SNMPAPI_UNTRANSLATED_V2" mode now means "SNMPv2c"; all
the party stuff is gone (deprecated to "Historic" RFCs)
and this mode uses community names in a manner identical
to "SNMPAPI_UNTRANSLATED_V1" in terms of entity and context
definitions.  The only difference is that messages built
for SNMPv2 destination entities will use the SNMPv2 value
[1] in the "version" member of the SNMP message in the
PDUs on the wire.

3.  Operating system dependencies

WinSNMP v1 was targeted at the Microsoft Windows family of
operating systems.

WinSNMP v2 is not targeted at any particular operating
systems or environments; however, to ensure backward
compatibility with fielded WinSNMP v1 applications, the
fundamental design objectives and architectural constructs
of WinSNMP v1 are retained.

The degree of operating system independence targeted in
WinSNMP v2 is realized via the new SnmpCreateSession()
function (specified in Section III.1 of this document).

The original session creation function--SnmpOpen()--is
retained and comprises a proper subset of the possible forms
of using SnmpCreateSession().  Some minor clarifying text
has been added to SnmpOpen() for WinSNMP v2 (specified in
Section III.8 of this document).

4.  Retransmission support

Execution of the retransmission policy was optional for
implementations in WinSNMP v1.  It is mandatory capability
for implementations in WinSNMP v2.

Implementations may still announce their "default" mode of
operation at each call to SnmpStartup().  The default mode
is whatever the implementation says it is in response to
the given call to SnmpStartup().

Applications may elect to operate with the RetransmitMode
set to SNMPAPI_ON or SNMPAPI_OFF at any given point in time.

The RetransmitMode setting is evaluated by the implementation
at SnmpSendMsg() time.

Unless and until a response is received, a message sent when
the RetransmitMode is "on" will result in retries (if a non-
zero retry count is specified for the dstEntity at the time
SnmpSendMsg() is called) and issuance of a timeout notification
to the associated session (when no response is received within
the timeout interval and the retry count is exhausted).

A message sent when RetransmitMode is "off" does not result
in retries and no timeout notification is sent to the
associated session.

See the "Timeout notification methods" clarification for
related information.

See the new SnmpCancelMsg() function for associated
functionality.

5.  Timeout notification methods

The method for notifying a session of a timed out request
message was not specified for WinSNMP v1.

It is specified for WinSNMP v2.

The implementation must return the SNMPAPI_TL_TIMEOUT error
value in wParam and the RequestID of the timed out PDU in
lParam (this is true regardless of the notification mode of
the session...i.e., message-based or callback-based).

Note that for normal request, response, or trap delivery,
the implementation must set wParam to zero and lParam to the
RequestID of the PDU to be retrieved.

Applications should check wParam on all notifications,
regardless of notification mode (message or callback).
If it is non-zero, then its value is one of the "transport
layer" (SNMPAPI_TL_<n>) error codes and the application
does not need to (and should not) call SnmpRecvMsg() in
response to this notification.

However, if the application elects to make the SnmpRecvMsg()
call, then one of three results may occur:

          1.  If there is a pending message for this
              session, the DLL may deliver it at this
              time; or,

          2.  If there is no pending message for this
              session, then SnmpRecvMsg() must return
              SNMPAPI_FAILURE, with SnmpGetLastError()
              set to:

               a.  SNMPAPI_NOOP [8], or

               b.  SNMPAPI_TL_TIMEOUT [108].

Note that if Result 1 obtains, the session may eventually
receive a notification that will yield Result 2a, since
that notification may have happened asynchronously to the
early retrieval of the message.

Note to implementors:  If there is no message pending for the
calling application, then Result 2a is the preferred error
setting.  Result 2b is allowed for backward compatibility
with certain fielded applications.

6.  SNMPv1 Trap-PDU generation

The WinSNMP API is oriented towards SNMPv2.  No standard
function is provided to accommodate the unique fields of an
SNMPv1 Trap-PDU (SNMP_PDU_V1TRAP).  All SNMPv1 and SNMPv2
Trap-PDUs which are received by a WinSNMP implementation
and delivered to applications who requested them via
SnmpRegister(), are delivered as SNMPv2 traps (SNMP_PDU_TRAP).
Furthermore, only SNMPv2 Trap-PDUs can be assembled directly
via SnmpCreatePdu() and/or SnmpSetPduData().

However, WinSNMP entities operating in an agent role may
need to emit traps to non-WinSNMP SNMPv1 targets.  To
accommodate this requirement, the SnmpSendMsg() must
evaluate the SNMP-version level of the dstEntity parameter
of any out-going SNMP_PDU_TRAP message.  If the dstEntity is
an SNMPv1 entity, then the message must be automatically and
transparently converted to an SNMP_PDU_V1TRAP message via
the following procedure:

The WinSNMP API is intended to be a common interface that
provides bilingual protocol support as transparently as
possible.  To this end, the API takes on a "v2-style
interface" in all other areas, and "downgrades" a request
appropriate to communicate with either v1 or v2 agents using
the *SAME* interface.

For example, WinSNMP v1.1a specified that all implementations
(level 1 or 2) must support the GetBulk operator.  However,
if the request is sent to a v1 entity, then the WinSNMP
implementation transparently "downgrades" the GetBulk to a
GetNext request per RFC 1908.  This enables an application
to be coded to always use GetBulk and not care whether the
dstEntity is a v1 or a v2 entity, especially in "translated
mode".

While RFC 1908 does not specify how to "downgrade" an
SNMP_PDU_TRAP message into an SNMP_PDU_V1TRAP message, the
translation is straight forward.  As such, the WinSNMP
interface for sending traps--whether to a v1 or a v2
destination-is stipulated hereby as an SNMPv2 Trap-PDU
(SNMP_PDU_TRAP).

If the dstEntity of an SNMP_TRAP_PDU submitted to
SnmpSendMessage() or SnmpEncodeMsg() is a v1 entity, then
the WinSNMP implementation must "downgrade" (translate)
the trap into an SNMP_PDU_V1TRAP during assembly of the
corresponding SNMP message.

This action taken on out-going SNMP trap messages has no
bearing on SNMP traps received by an implementation.  As
with v1 of the WinSNMP API specification, in all cases,
received traps are presented to WinSNMP applications as
SNMPv2 traps (SNMP_PDU_TRAP).

The translation procedure (e.g., during serialization) is
simply the converse of the v1-to-v2 trap translation that
is already done by WinSNMP implementations when v1traps
are received and presented to the application.  The steps
are defined in Section 3.3 of RFC 2089, "V2ToV1 Mapping
SNMPv2 onto SNMPv1 within a bi-lingual SNMP agent" by Bert
Wijnen and David Levi.

From an implementation perspective, it is straight-forward
and rather easy to implement.  From an application developer
perspective, eliminating the need for the application to
know/care about differences in v1 vs v2 traps enormously
simplifies the application.

The bottom line is that this approach preserves the "single
interface / bilingual protocol" value proposition that
WinSNMP was founded on.  It also eliminates the need for a
new / additional function in the WinSNMP API.

7.  Notification port usage

The term "notification" as used here applies to both traps
(SNMPv1 and SNMPv2c) and informs (SNMPv2c only).  Trap
mapping between entities of different SNMP versions is
described above.  Important details wrt Inform requests are
given in Section II.13, "Inform Processing", below.

InformRequest-PDUs may only be sent to a destination entity
that supports SNMPv2c.  An attempt by an application to send
an InformRequest-PDU to an SNMPv1 destination entity using
SnmpSendMsg() results in SNMPAPI_FAILURE, with SnmpGetLastError()
set to return SNMPAPI_OPERATION_INVALID.

The well-known notification port for any protocol supported
by an implementation (e.g., 162 for UDP and 36880 for IPX)
should be held by an implementation of this WinSNMP API, if
at all, only when there are active SnmpRegister() entries
that might accept an incoming notification message.

Where possible, an implementation should use some de facto or
de jure standard "system service" for receiving notification
messages to be dispatched to registered WinSNMP applications,
such that other (non-WinSNMP) notification targets may operate
concurrently with it.  For Microsoft Windows NT, this standard
mechanism is the "SNMPTRAP" system service.

8.  Request-ID/SnmpCreatePdu()/SnmpSetPdu()

Applications should specify "meaningful" Request-ID values
via SnmpCreatePdu() and/or SnmpSetPduData().

Implementations will automatically assign an arbitrary
Request-ID value when SnmpCreatePdu() is called without a
specified Request-ID value (i.e., the value is zero).  The
SnmpSetPduData() function may be used by an application to
assign any Request-ID value it wants, including a value of
zero.

Implementations must use the resulting Request-ID value at
SnmpSendMsg() time to return the eventual Response-PDU or
timeout notification (if a corresponding Response-PDU is
not received) to the application.

Note that the Request-ID used in the "on-the-wire" messages
is assigned by the implementation independently and may or
may not be the same as the Request-ID used at the application
level for any given message.

9.  SnmpGetPduData() and hVbl

If an hVbl output parameter is specified on a call to
SnmpGetPduData() it will return a new instance of the
VarBindList associated with the corresponding hPdu.

This behavior is consistent with both the basic purpose of
SnmpGetPduData()--which is to de-reference the components of
a received PDU--and a basic characteristic of all WinSNMP
functions which return WinSNMP resource objects (sessions,
entities, contexts, PDUs, and VarBindLists) as outputs...
namely, each output represents a new "instance" (used loosely)
of the object.  Such a new "instance" may be either a new
unique value for that object type or may correspond to some
internal, implementation-specific mechanism (such as a
"reference count").

The key underlying principle is that actual value of a
WinSNMP resource object is not meaningful to the
application, but is meaningful to the implementation.
Applications need only be certain to match up each WinSNMP
resource object creation operation with a corresponding
"free" operation or, as may be appropriate, to free them via
calls to SnmpClose() or SnmpCleanup().

10.  GetBulk -> GetNext mapping

When the dstEntity used in an SnmpSendMsg() operation is an
SNMPv1 entity and the PDU type is SNMP_PDU_GETBULK, the
implementation must automatically and transparently modify
the PDU type to SNMP_PDU_GETNEXT, per RFC 1908.  Note that
this "translation" occurs during serialization of the
WinSNMP components (hContext, hPdu, and hVbl, in this case)
into the SNMP message that will be transmitted.  It does
NOT alter the submitted components themselves.

11.  IPX support in SnmpStrToEntity()

WinSNMP v1 was highly oriented toward IP/UDP, but was not
meant to exclude the compatible, symmetrical use of other
transport protocols by specific implementations.  As a
result, some implementations accepted alternative string
formats as arguments to SnmpStrToEntity()--when called by
an application operating in "untranslated" mode--to signal
the use of protocols other than UDP.

In particular, the use of "<netnum><sep><nodenum>" for the
IPX protocol found a significant degree of usage.  Hence, it
is considered helpful to the community to specify a standard
format for this purpose and to explicitly allow its use in
SnmpStrToEntity().  This standard format consists of three
collated parts:

     1.  A "network number" <netnum>, consisting of eight
         hexadecimal digits (zero-filled, if necessary).

     2.  A separator (i.e., either ":" or "-").

     3.  A "node number" <nodenum>, consisting of twelve
         hexadecimal digits (zero-filled, if necessary).

For example:  "00000001:00080A0D01C2"
         or:  "00000001-00008A0D01C2"

Note that SnmpEntityToStr() is also modified to return a
properly formatted IPX address string, per above, for any
IPX entity--when called by an application operating in
"untranslated" mode at the time, or in "translated" mode
but with no "friendlyName" value available.

The ":" separator is the recommended default for use in
the output string.

12.  SnmpDecodeMsg() outputs

This clarification has to do with return values for the hSrc
and hDst output parameters.  The key point is that an
implementation cannot be required to supply information that
is not unambiguously available to it.  When WinSNMP v1 was
designed, party-based SNMPv2 (since deprecated to "Historic"
status) was being actively considered by the IETF.  That
form of the protocol might have included more address-type
information in the encoded SNMP messages.  If it had, then
this information could have been used by the implementation
of the SnmpDecodeMsg() function to instantiate hSrc and hDst
entity values.

However, the IETF adopted a different form of SNMPv2 (SNMPv2c,
as defined in RFCs 1901-1908) and this form retains the same
message format as SNMPv1 and that message format does not
include the addressing information needed to properly create
WinSNMP entity resources.

Therefore, SnmpDecodeMsg() cannot return meaningful values
for the hSrc or hDst parameter for SNMPv1 or SNMPv2 messages
submitted to it and must return a value of zero in these
output parameters.

13.  Inform processing

SNMPv2 Inform requests are only supported to a destination
entity that supports SNMPv2.  An attempt to send an Inform
request to an SNMPv1 destination using SnmpSendMsg() must
return SNMPAPI_FAILURE, with SnmpGetLastError() set to
return SNMPAPI_OPERATION_INVALID.

The implementation is responsible for generating and
transmitting the (single) Response-PDU for any received
InformRequest-PDU.

Applications that receive an InformRequest-PDU via a WinSNMP
session must not issue a corresponding Response-PDU.

14.  Thread-safeness

A multi-threaded application must ensure the thread-safeness
of its own WinSNMP operations.

The implementation must ensure "thread-safeness" at the
application (process) level.  That is, the implementation
must ensure that the WinSNMP operations of one process do
not unilaterally modify the WinSNMP settings of any other
process.

The WinSNMP operations that might merit attention on the
part of a multi-threaded application are those which set
application-level parameters.  At this time, there are
only two such settings:

	- SnmpSetTranslateMode()
	- SnmpSetRetransmitMode()

It is often, not always, the case that an application--
multi-threaded or not--will operate with a single constant
value for each of these settings, with this value normally
being either the default supplied by the SnmpStartup() call
or an application-specified value (via SnmpSetTranslateMode()
and/or SnmpSetRetransmitMode()) before any calls to the
WinSNMP entity or context creation functions (for "translate"
mode) or calls to SnmpSendMsg() (for "retransmit" mode).

Nonetheless, implementors providing WinSNMP for operating
environments which support multi-threaded applications
are encouraged to include guidance on this issue in their
developer-oriented documentation.

15.  WinSNMP++ -> SNMP++ change

The embryonic WinSNMP++ appendix to the WinSNMP v1
specification has been deprecated and deleted from the
WinSNMP v2 specification.

Implementors are now directed to the open SNMP++
specification (and reference code) published by Hewlett-
Packard (http://rosegarden.external.hp.com/snmp++).

16.  SnmpRegister()

The primary purpose of SnmpRegister() is to enable an
application to indicate that it wants to receive traps
that arrive at the default SNMP trap port(s) (UDP 162
and/or IPX 36880) on the local machine.  This can be
accomplished by passing the following parameter values
in the call to SnmpRegister():

     session      - a valid session handle
     srcEntity    - NULL
     dstEntity    - NULL
     context      - NULL
     notification - NULL
     status       - SNMPAPI_ON

This sequence of parameter values, assuming the call is
otherwise successful, will result in all notifications
(traps and informs) received by the WinSNMP implementation
being delivered to the session.  We will refer to the
above setting as an "unfiltered" registration.

A secondary purpose of SnmpRegister() is to function as
a minimal "trap filter" on notifications received by the
WinSNMP implementation.  In this mode, non-NULL values
for any combination of one or more of the srcEntity,
dstEntity, context, or notification parameters, will be
used to form a filter to be applied to traps received by
the WinSNMP implementation for the indicated session.
We will refer to any such operation as a "filtered"
registration.

Note that while an "unfiltered" registration is in
effect for a session, it makes no sense to issue any
"filtered" registration requests for that same session.
They would be totally superfluous--since all notifications
would already be delivered to the session anyway due to
the "unfiltered" registration.  This is one of three types
of "redundant" registrations.  Another type of "redundant"
registration is a duplicate call to SnmpRegister()--that
is, one in which the parameter list is identical to the
parameter list used to instantiate an active registration
for the same session.  The third type of "redundant"
registration is one in which the notification parameter
(when dereferenced) fully contains (as a prefix) a
notification parameter used on an active registration
for the same session.  This is redundant due to the
wildcard interpretation of the notification parameter
specified in the WinSNMP v1.1a spec.

In all cases of "redundant" registrations, SnmpRegister()
should return SNMPAPI_SUCCESS, since the action requested
by the application--namely, to deliver the specified
notifications to the indicated session--will be carried
out.  [Yes, we could have gone with SNMPAPI_FAILURE in
these cases and setting SnmpGetLastError() to return
SNMPAPI_NOOP, but the incidence of problems resulting
form such "redundant" calls has proven to be close to
zero in practice and, therefore, we are taking a more
streamlined approach.]

Also, note that such redundant "register" requests are
idempotent, meaning that only a single corresponding
"unregister" call is required.  To "unregister" means
to call SnmpRegister() with a status parameter value of
SNMPAPI_OFF and with the first five parameters having
the same effective values as some previously successful
call with a status parameter of SNMPAPI_ON.

Implementations do not maintain a "count" of redundant
registrations that must be matched with an equal number
of corresponding unregistrations.

Of course, each unique (non-redundant) register must
be matched with an unregister call to remove it, if
desired by the application.

III - New Functions:

1.  SnmpCreateSession()

The SnmpCreateSession() function is used to create a WinSNMP
"session" and to specify the notification mode-either a
"window/message" pair or callback function--that will be
used for the session.

With this function, Windows programmers now have the option
of having the implementation use either the standard Windows
message notification method (as in SnmpOpen()) or a direct
callback into a session-specific function.  As a by-product
of this enhanced flexibility for Windows programmers, the
WinSNMP API can now also be used in some non-Windows
operating environments (some examples are given below).

This function is a superset of the SnmpOpen() function.
That is, when used to create a session with window/message
notification, it provides the exact same functionality as
SnmpOpen().  (Refer to the descriptive text for SnmpOpen()
elsewhere in this alphabetical "Function Reference" chapter
for more information.)

Developers writing new applications for WinSNMP v2.0 are
encouraged to use SnmpCreateSession() for all session
creation, even when selecting the window/message
notification mode (i.e., instead of using SnmpOpen()).
Developers upgrading applications written for earlier
versions of WinSNMP to take advantage of other WinSNMP v2.0
features are encouraged to change all SnmpOpen() calls to
the equivalent form of SnmpCreateSession().

HSNMP_SESSION SnmpCreateSession (IN HWND hWnd,
                                 IN UINT wMsg,
                                 IN SNMPAPI_CALLBACK fCallBack,
                                 IN LPVOID lpClientData);

WINSNMP.DEF category = Communications Functions;
ordinal value = 220.

Parameter     Description
hWnd          Identifies a notification window.
wMsg          Identifies a notification message.
fCallBack     Identifies a notification callback function;
              may be NULL.
lpClientData  Identifies a pointer to optional application
              data to pass to the fCallBack function; may be
              NULL.

Returns:

If the SnmpCreateSession() function is successful, the return
value is an HSNMP_SESSION handle which identifies the WinSNMP
session opened by the implementation on behalf of the calling
application.

If the function fails, the return value is SNMPAPI_FAILURE
and SnmpGetLastError() will be set to return extended error
information as follows:

SnmpGetLastError()        Description
"Common Error Codes"      See Section 2.10.1. Common Error
                          Codes.
SNMPAPI_HWND_INVALID      hWnd is not a valid window value.
SNMPAPI_MSG_INVALID       wMsg is not a valid message value.
SNMPAPI_MODE_INVALID      The combination of values passed
                          is mutually incompatible or
                          incomplete.
SNMPAPI_OPERATION_INVALID The combination of values passed
                          does not identify a valid
                          notification mode for this
                          implementation.

As will be explained below, the conditions leading to any of
the three specific error codes listed above are somewhat
environment-specific.

Comments:

If fCallBack is NULL, SnmpCreateSession() is equivalent to
the SnmpOpen() function.  In this window/notification mode,
the values of hWnd and wMsg must both be valid in the
implementation's operating environment.

If the value of hWnd is invalid, then the function returns
SNMPAPI_FAILURE, and SnmpGetLastError() is set to return
SNMPAPI_HWND_INVALID.

Else, if the value of wMsg is invalid, then the function
returns SNMPAPI_FAILURE, and SnmpGetLastError() is set to
return SNMPAPI_WMSG_INVALID.

Else, if both values are individually valid but are mutually
incompatible in a given windowing environment, then the
function returns SNMPAPI_FAILURE, and SnmpGetLastError() is
set to return SNMPAPI_MODE_INVALID.

If fCallBack is non-NULL, it represents the address of a
function to be called whenever the implementation has a
notification to deliver to the session.  The notification
may signal the presence of an SNMP message for the session
or it may signal the existence of an asynchronous error
condition (for example, a transport layer timeout error).
(Refer to the discussion of "Retransmission and Timeout
Notification" in the "Programming with WinSNMP" chapter
and the descriptive text for SnmpRecvMsg() elsewhere in
this alphabetical "Function Reference" chapter for more
information.)  When fCallBack is non-NULL, a given operating
environment may require valid values for any or all of hWnd,
wMsg, and/or lpClientData and should return one of the three
function-specific error codes in a manner consistent with
that outlined above.

The callback function prototype must be:

typedef SNMPAPI_STATUS (CALLBACK *SNMPAPI_CALLBACK)(
                        IN HSNMP_SESSION session,
                        IN HWND hWnd,
                        IN UINT wMsg,
                        IN WPARAM wParam,
                        IN LPARAM lParam,
                        IN LPVOID lpClientData);

Parameter     Description
session       Identifies the session being notified.
hWnd          Identifies the session's notification window.
wMsg          Identifies the session's notification message.
wParam        Identifies the purpose of the notification.
lParam        Identifies the RequestID of the subject PDU.
lpClientData  Identifies a pointer to optional application
              data, if such a pointer was specified in the
              session's SnmpCreateSession() call.

Note:  If fCallBack is non-NULL on a successful call to the
SnmpCreateSession() function, then the session operates in
callback notification mode and the values of hWnd and wMsg
passed to the SnmpCreateSession() function may or may not be
significant depending upon the operating environment, but
are always passed to the callback function for its possible
use.

Note:  If a callback function has been assigned to a session
in this manner, then upon receipt of an SNMP message for the
session the implementation will call the callback function--
instead of sending the wMsg notification message to the hWnd
as it would in the window/message notification mode--and
pass it the session identifier and two values representing
the wParam and lParam values that would have been used if
operating in the window/message notification mode.  (See the
descriptive text for the SnmpOpen() function elsewhere in
the alphabetical "Function Reference" chapter for additional
background information.)

Note:  The fCallBack function must return SNMPAPI_SUCCESS to
indicate continued viability.  Any other returned value will
be interpreted as SNMPAPI_FAILURE and will result in the
implementation doing an implicit SnmpClose() operation on
the session.

Note:  If the fCallBack parameter to SnmpCreateSession() is
NULL, any non-NULL value of lpClientData is meaningless and,
therefore, will be ignored by the implementation.

Note:  When the callback function is called for the purpose
of notifying the session of the presence of an SNMP message
for it, the value passed for wParam must be 0.  Otherwise,
any non-zero value of wParam will signal an asynchronous
error notification for the session.  The most common example
of such an error notification is a "no response from agent"
timeout when the implementation is executing retransmission
policy for the application; in which case, the value of
wParam will be SNMPAPI_TL_TIMEOUT [108].  The value passed
in the lParam parameter will always indicate the RequestID
of the affected PDU.  (See the descriptive text for the
SnmpRecvMsg() function elsewhere in the alphabetical
"Function Reference" chapter for more information about the
general use of these two parameters.)

Following are some sample calling modes for different
operating environments:

MS-Windows, Window/Message notification mode:
hSession = SnmpCreateSession (myWnd, myMsg, NULL, NULL);

MS-Windows, Callback notification mode:
hSession = SnmpCreateSession (0, 0, myFunc, <NULL|myData>);

UNIX X-Windows, Callback notification mode:
hSession = SnmpCreateSession (myWnd, 0, myFunc, <NULL|myData>);

Any non-window Command Line Environment, Callback mode:
hSession = SnmpCreateSession (0, 0, myFunc, <NULL|myData>);

Note:  The first example above is equivalent to a standard
WinSNMP SnmpOpen() call.

Note:  For non-MS-Windows operating environments,
implementors may (and will likely have to) supply
definitions for the Windows-specific data types used in the
standard WinSNMP.h file, which originate from <windows.h>
(which is #include'd in WinSNMP.h).

A possible example of a "windows.h" file for a generic
X-Windows operating environment follows:

// windows.h
// #include'd in WinSNMP.h
// typedef's for the SnmpCreateSession function
typedef XtAppContext  HWND;     // X-Window id
typedef unsigned int  UINT;     // Not used
typedef void         *CALLBACK; // Callback function
typedef void         *LPVOID;   // Callback user data
// additional typedef's for the fCallBack prototype
typedef unsigned int  WPARAM;   // Notification code
typedef unsigned int  LPARAM;   // RequestID

See also:  SnmpOpen() and SnmpRecvMsg() in the alphabetical
function reference section, and "Retransmission and Timeout
Notification" in the "Programming with WinSNMP" section.

2.  SnmpCreateEntity()

Due to the on-going work in the IETF SNMPv3 WG, this function
will be deferred to the WinSNMP v3 time frame.

This "placeholder" is being retained here as a signal to
interested parties to monitor the SNMPv3 output for future
incorporation in WinSNMP v3.

3.  SnmpCreateContext()

Due to the on-going work in the IETF SNMPv3 WG, this function
will be deferred to the WinSNMP v3 time frame.

This "placeholder" is being retained here as a signal to
interested parties to monitor the SNMPv3 output for future
incorporation in WinSNMP v3.

4.  SnmpCancelMsg()

The SnmpCancelMsg() function requests cancellation of any
further retransmissions or timeout notification for the PDU
identified by the requestId parameter for the specified
session.

SNMPAPI_STATUS SnmpCancelMsg (IN HSNMP_SESSION session,
                              IN smiINT32 requestId);

WINSNMP.DEF category = Communications Functions;
ordinal value = @222.

Parameter     Description
session       Identifies the session which submitted the
              message to be canceled.
requestId     Identifies the Request-ID value of the
              hPdu used in the corresponding call to
              SnmpSendMsg().

Returns:

If the function executes successfully, the return value is
SNMPAPI_SUCCESS.

If the function fails, the return value is SNMPAPI_FAILURE.
Use SnmpGetLastError() to obtain extended error information.

SnmpGetLastError()       Description
SNMPAPI_SESSION_INVALID  The session parameter is invalid.
SNMPAPI_PDU_INVALID      The requestId parameter does not
                         identify a message with outstanding
                         retransmissions for the specified
                         session.

Comments:

Successful execution of this function is analogous to
setting RetransmitMode to SNMPAPI_OFF for the affected
message.

Note:  Applications must be aware that--due to transaction
queuing at various levels--it is possible that the subject
destination entity may still receive and/or respond to a
corresponding SNMP message even following successful
execution of SnmpCancelMsg().  But the implementation must
not transmit any retries or submit a Response-PDU or timeout
notification to the application for the subject message
following successful execution of this function.

Note:  Successful execution of this function applies to a
single message instance.  This point illustrates another
reason why applications should use "meaningful" Request-ID
values for their respective PDUs.

Note:  Implementations must effectively execute
SnmpCancelMsg() on any outstanding messages for a session
when SnmpClose() is called, whether directly or indirectly
via SnmpCleanup().

5.  SnmpSetPort()

The SnmpSetPort() function permits an application to change
the port assignment of a given destination entity.

SNMPAPI_STATUS SNMPAPI_CALL SnmpSetPort
				(IN HSNMP_ENTITY hEntity,
                            	IN UINT nPort);

WINSNMP.DEF category = Entity/Context Functions;
ordinal value = @320.

Note:  "Destination entity" includes entities used as
agent applications via the local WinSNMP implementation
(see Section III.6, "SnmpListen()", below).

Note:  If the hEntity parameter identifies an entity which
is already operating in an agent mode for this application
(via the new SnmpListen() function outlined below), then
this function will return SNMPAPI_FAILURE, with SnmpGetLastError()
set to return SNMPAPI_ENTITY_INVALID, since such an entity is
already bound to a port.  The proper sequence of events for
such an entity is:

	hAgent = SnmpStrToEntity (hSession, <addrString>);
	lStatus = SnmpSetPort (hAgent, <nPort>);
	lStatus = SnmpListen (hAgent, SNMPAPI_ON);

The implementation will have "assigned" a port value to the
entity as part of the SnmpStrToEntity() operation.  This will
normally be the standard SNMP request port for the respective
protocol family (e.g., UDP 161 or IPX 36879) for an entity
created in "untranslated" mode or whatever may be specified in
the local database for an entity created in "translated" mode.
So, if the agent is to listen on a different port, or just to
be safe, the app can use SnmpSetPort() to arrange that.

6.  SnmpListen()

This new function permits the "attachment" of an agent
application using the [local] address and port settings
in effect for the hEntity parameter.

SNMPAPI_STATUS SNMPAPI_CALL SnmpListen
				(IN HSNMP_ENTITY hEntity,
                           	IN SNMPAPI_STATUS lStatus);

WINSNMP.DEF category = Communications Functions;
ordinal value = @221.

"hEntity" will indicate the session to be notified (via
callback or window/message) when an in-coming request
is received for this agent application, and the address
family, interface address, and port to use for this
"agent".  Note that all of these attributes already exist
as aspects of a WinSNMP "entity".

"lStatus" will take either of two values: SNMPAPI_ON
or SNMPAPI_OFF.  If it is SNMPAPI_ON, all else passing,
the "agent" will then bind to its af:addr:port and
listen for incoming requests, which will be transferred
to it via the normal WinSNMP mechanisms.  It will then
"do its thing" with the request, form the response,
reverse the srcEntity and dstEntity parameters it
received on the SnmpRecvMsg() call, and transmit the
response back to the requester via SnmpSendMsg().

If the entity's port is already in use, the call to
SnmpListen() will fail with an appropriate error
via SnmpGetLastError().  When an entity no longer
wants to function as an agent, it should call
SnmpListen() with an "lStatus" value of SNMPAPI_OFF
to release the port (and other resources).  Both
SnmpClose() for the session and SnmpCleanup() for
the app must release all affected agent ports.

7.  SnmpGetVendorInfo()

This new function returns vendor identification information
to the application using a new structure defined in winsnmp.h:

#define MAXVENDORINFO 32
typedef struct
	{
	char vendorName[MAXVENDORINFO*2];
	char vendorContact[MAXVENDORINFO*2];
	char vendorVersionId[MAXVENDORINFO];
	char vendorVersionDate[MAXVENDORINFO];
	smiUINT32 vendorEnterprise;
	} smiVENDORINFO, FAR *smiLPVENDORINFO;

SNMPAPI_STATUS SNMPAPI_CALL SnmpGetVendorInfo
				(OUT smiLPVENDORINFO vendorInfo);

WINSNMP.DEF category = Local Database Functions;
ordinal value = @120.

If vendorInfo is NULL, the return value is SNMPAPI_FAILURE with
SnmpGetLastError() set to return SNMPAPI_NOOP.

Upon successful return from this function, the four "char"
fields should contain NULL-terminated text strings suitable
for output on a display device.  The content of these fields
is vendor-determined, but should provide information helpful
to end-users in the event of a problem, if displayed by an
application.  For example, "vendorContact" could include a
physical or postal address, telephone and/or fax numbers,
an e-mail address or a URL.  If a vendor has an IANA-issue
enterprise number, then it should be returned as the value
of vendorEnterprise; otherwise, its value must be zero.

8.  SnmpOpen()

[Note:  Modified for clarity wrt SnmpCreateSession(), which
is new for WinSNMP v2.]

[Do_Box]
Important:  WinSNMP v2.0 added the SnmpCreateSession()
function which provides a superset of the SnmpOpen()
functionality.  Developers are encouraged to use
SnmpCreateSession() instead of SnmpOpen().

SnmpOpen() is maintained for backwards compatibility with
pre-v2.0 WinSNMP applications, but some (non-Windows)
implementations may return SNMPAPI_OPERATION_INVALID in
response to any SnmpOpen() call, as described below.
[End_Box]

The SnmpOpen() function enables the implementation to
allocate and initialize memory, resources, and/or
communications mechanisms and data structures for the
application.  The application will continue to use the
"session identifier" returned by the implementation in
subsequent WinSNMP function calls to facilitate resource
accounting on a per session basis.  This mechanism enables
the implementation to perform an orderly release of
resources in response to a subsequent SnmpClose() function
call for a given session (or in response to a subsequent
SnmpCleanup() call for the application).

Syntax:
HSNMP_SESSION     SnmpOpen (
IN HWND           hWnd,
IN UINT           wMsg);

Parameter     Description
hWnd     Identifies the application's notification window.
wMsg     Identifies the application's notification message.

Returns:

If the function is successful, the return value is a non-
zero HSNMP_SESSION value which identifies the WinSNMP
session opened by the implementation on behalf of the
calling application.

If the function fails, the return value is SNMPAPI_FAILURE.
Use the SnmpGetLastError() function to obtain extended error
information.

SnmpGetLastError()        Description
"Common Error Codes"      See Section 2.10.1. Common Error
                          Codes.
SNMPAPI_HWND_INVALID      The hWnd parameter is not a valid
                          window handle.
SNMPAPI_OPERATION_INVALID This implementation does not
                          support the Windows/Message
                          notification scheme (see
                          SnmpCreateSession()).

Comments:

See Section 2.5. Sessions and Section <new> SnmpCreateSession().

An application can open multiple sessions.  Each such
session for the same hWnd should provide a different wMsg,
but this is not required.

A successful SnmpOpen() call always returns a unique
HSNMP_SESSION value (with respect to all other currently
open sessions for the calling application).

The hWnd parameter specifies the window to be notified when
an asynchronous request completes or trap/notification
occurs and the wMsg parameter specifies the message number
that the implementation will send to the window.  Upon
receipt of this message,

     - If the wParam component of the notification message
       is zero (0),  the application should call
       SnmpRecvMsg() to retrieve the subject PDU for
       immediate or subsequent processing.

     - If the wParam component of the notification message
       is non-zero, it will represent a WinSNMP API error
       code (e.g., SNMPAPI_TL_TIMEOUT) referring to the
       PDU identified by the Request_Id value in the lParam
       component.  In this case, the application should
       react to the error condition and should not call
       SnmpRecvMsg().

In other programming models (e.g., synchronous, CLI-driven,
or "curtained" applications), the WinSNMP implementation may
interpret hWnd and hMsg differently.  Likewise, the session
model may be used to facilitate multi-threaded programming
in supporting environments.  The SnmpCreateSession()
function has been added to WinSNMP v2.0 to formalize such
usage.

Note:  A well-behaved WinSNMP application will call
SnmpClose() for each session opened with SnmpOpen().  When
an emergency exit is required by the application, it must at
least call SnmpCleanup().

A well-behaved WinSNMP implementation must react to an
SnmpCleanup() call as though it were a series of SnmpClose()
calls for each open session allocated to the calling
application.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\mibs\progref.rtf ===
{\rtf1\ansi \deff12\deflang1033{\fonttbl{\f0\froman\fcharset0\fprq2 Tms Rmn{\*\falt Times New Roman};}{\f1\froman\fcharset2\fprq2 Symbol;}{\f2\fswiss\fcharset0\fprq2 Helv;}{\f3\fmodern\fcharset0\fprq1 Courier;} {\f4\froman\fcharset0\fprq2 Times New Roman;}{\f5\fswiss\fcharset0\fprq2 Arial;}{\f6\froman\fcharset0\fprq2 MS Serif;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f8\froman\fcharset0\fprq2 Times;}{\f9\fswiss\fcharset0\fprq2 Helvetica;} {\f10\fswiss\fcharset0\fprq2 System;}{\f11\fmodern\fcharset0\fprq1 Courier New;}{\f12\froman\fcharset0\fprq2 New York{\*\falt Times New Roman};}{\f13\fswiss\fcharset0\fprq2 Geneva;}{\f14\fswiss\fcharset0\fprq2 AvantGarde;} {\f15\froman\fcharset0\fprq2 ITC Bookman;}{\f16\fswiss\fcharset0\fprq2 Helvetica-Narrow;}{\f17\froman\fcharset0\fprq2 NewCenturySchlbk;}{\f18\froman\fcharset0\fprq2 Palatino;}{\f19\froman\fcharset0\fprq2 ZapfChancery;} {\f20\fdecor\fcharset2\fprq2 ZapfDingbats;}{\f21\fnil\fcharset2\fprq2 Marlett;}{\f22\fmodern\fcharset0\fprq1 Lucida Console;}{\f23\fswiss\fcharset0\fprq2 Lucida Sans Unicode;}{\f24\fnil\fcharset2\fprq2 Wingdings;} {\f25\fswiss\fcharset0\fprq2 Arial Narrow;}{\f26\fswiss\fcharset0\fprq2 Arial Black;}{\f27\froman\fcharset0\fprq2 Book Antiqua;}{\f28\froman\fcharset0\fprq2 Bookman Old Style;}{\f29\froman\fcharset0\fprq2 Century Schoolbook;} {\f30\fnil\fcharset2\fprq2 Monotype Sorts;}{\f31\froman\fcharset0\fprq2 Garamond;}{\f32\fmodern\fcharset2\fprq1 MS LineDraw;}{\f33\froman\fcharset255\fprq2 Roman;}{\f34\fscript\fcharset255\fprq2 Script;}{\f35\fmodern\fcharset255\fprq2 Modern;} {\f36\fswiss\fcharset0\fprq1 MS Dialog;}{\f37\fswiss\fcharset0\fprq0 Chicago;}{\f38\fmodern\fcharset0\fprq0 Monaco;}{\f39\fscript\fcharset0\fprq0 Venice;}{\f40\fdecor\fcharset0\fprq0 London;}{\f41\fdecor\fcharset0\fprq0 Athens;} {\f42\fdecor\fcharset0\fprq0 San Francisco;}{\f43\fnil\fcharset0\fprq0 Cairo;}{\f44\fnil\fcharset0\fprq0 Los Angeles;}{\f45\fnil\fcharset0\fprq0 Zapf Dingbats;}{\f46\fnil\fcharset0\fprq0 Bookman;}{\f47\fnil\fcharset0\fprq0 N Helvetica Narrow;} {\f48\fnil\fcharset0\fprq0 Zapf Chancery;}{\f49\fnil\fcharset0\fprq0 Avant Garde;}{\f50\fnil\fcharset0\fprq0 New Century Schlbk;}{\f51\fnil\fcharset0\fprq0 MT Extra;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255; \red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0; \red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\nowidctlpar \f12 \snext0 Normal;}{\s1\sb120\keepn\nowidctlpar \b\f9 \sbasedon0\snext0 heading 1;}{\s2\sb120\keepn\nowidctlpar \b\f9 \sbasedon0\snext0 heading 2;}{ \s3\sb120\keepn\nowidctlpar\tx1080 \b\f9 \sbasedon0\snext0 heading 3;}{\s4\sb120\keepn\nowidctlpar\tx1080 \b\f9 \sbasedon0\snext0 heading 4;}{\s5\sb120\keepn\nowidctlpar\tx1440 \b\f9 \sbasedon0\snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;} {\s15\li720\nowidctlpar\tx1980\tqr\tldot\tx9000 \f9\fs20 \sbasedon0\snext0 toc 5;}{\s16\li540\nowidctlpar\tx1620\tqr\tldot\tx9000 \f9\fs20 \sbasedon0\snext0 toc 4;}{\s17\li360\nowidctlpar\tx1260\tqr\tldot\tx9000 \f9\fs20 \sbasedon0\snext0 toc 3;}{ \s18\li180\sb60\nowidctlpar\tx900\tqr\tldot\tx9000 \f9\fs20 \sbasedon0\snext0 toc 2;}{\s19\sb100\nowidctlpar\tx540\tqr\tldot\tx9000 \f9\fs20 \sbasedon0\snext0 toc 1;}{\s20\nowidctlpar\tqc\tx4320\tqr\tx8640 \f12 \sbasedon0\snext0 footer;}{ \s21\nowidctlpar\tqc\tx4320\tqr\tx8640 \f12 \sbasedon0\snext0 header;}{\s22\qj\li360\ri360\sb100\nowidctlpar \f12\fs20 \sbasedon0\snext0 Normal Indent;}{\s23\qj\sb100\nowidctlpar \f12\fs20 \sbasedon0\snext23 Norm Justified;}{ \s24\fi-720\li720\sb60\nowidctlpar\tx720\tx1440\tx2160 \f3\fs20 \sbasedon23\snext24 Code Text;}{\s25\qc\sb100\nowidctlpar \b\f9\fs20 \sbasedon0\snext25 Diagram;}{\s26\qj\fi-288\li1008\sa240\keep\nowidctlpar\tx1008 \f8\fs20 \sbasedon0\snext26 Ref List;}{ \s27\qj\fi-720\li720\sb100\nowidctlpar \f12\fs20 \sbasedon23\snext27 Reference;}{\s28\qj\li1080\ri1080\nowidctlpar \f12\fs20 \sbasedon0\snext28 Confidentiality;}{\s29\qj\sb100\nowidctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 \sbasedon23\snext29  ParmListHdr;}{\s30\qj\fi-2880\li2880\sb100\nowidctlpar\tx2880 \f12\fs20 \sbasedon23\snext30 ParmListEntry;}{\s31\fi-720\li720\sb60\nowidctlpar\tx720\tx1440\tx2160 \f3\fs18 \sbasedon24\snext31 Appx Code Text;}{\s32\qj\li720\sb100\nowidctlpar\brdrb \brdrs\brdrw15 \tx5040 \b\f9\fs20 \sbasedon29\snext32 Inset ParmListHdr;}{\s33\qj\fi-4320\li5040\sb100\nowidctlpar\tx5040 \f12\fs20 \sbasedon30\snext33 Inset ParmListEntry;}}{\info{\author Don Ryan}{\operator Don Ryan}{\creatim\yr1996\mo4\dy10\hr12\min52} {\revtim\yr1996\mo9\dy27\hr10\min37}{\version2}{\edmins3}{\nofpages33}{\nofwords5710}{\nofchars32549}{\*\company Microsoft Corporation}{\vern57443}}\margl1440\margr1440 \widowctrl\ftnbj\aenddoc\ftnrestart\revisions\hyphcaps0 \fet0\sectd  \pgnrestart\linex0\endnhere {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4 \pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (} {\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \qc\widctlpar \f12 {\b\fs28  \par  \par  \par  \par  \par  \par }{\b\f9\fs36 Microsoft Windows NT \par SNMP Programmer's Reference \par }{\b\fs28  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par  \par }{\fs20 May 16, 1996 \par }\pard \widctlpar \sect \sectd \linex0\endnhere {\header \pard\plain \s21\qc\widctlpar \f12 {\b\f9\fs20 Microsoft Windows NT SNMP Programmer's Reference \par }}{\footer \pard\plain \s20\widctlpar\tqc\tx4680\tqr\tx9360 \f12 {\b\f9\fs20 \tab \chpgn \tab  \par }}\pard\plain \s1\sb120\keepn\widctlpar \b\f9 1.\tab Introduction\tab  \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 This document describes the Simple Network Management Protocol (SNMP) application programming interfaces (APIs) for Windows NT.   \par These APIs support the development of SNMP manager applications and extensions to the Windows NT SNMP agent application .  A SNMP agent application is a SNMP application entity that responds to queries from SNMP manager applications and generates traps to SNMP manager applications.  A SNMP manager application is a SNMP application entity that generates queries to SNMP agen t applications and receives traps generated by SNMP agent applications.   \par The Windows NT SNMP agent application employs a simple subagent multiplexing design which makes it easy for independent software vendors (ISVs) to supply additional variables from various Management Information Bases (MIBs).  During initialization,  each subagent is asked to register the MIB view it supports and a list of subagents and their supported MIB views is constructed and lexographically sorted.  When an incoming request is being serviced, each object identifier (OID) from the request is comp ared to the entries of the subagent supported MIB view list and the request is divided into separate queries for each corresponding subagent.  Microsoft currently ships subagents for RFC1213-MIB and LanMgr-Mib-II.  The extensible a gent is implemented as a Win32 Service, and the subgents are implemented as Win32 Dynamic Link Libraries (DLLs).   \par The Windows NT SNMP Management APIs allow multiple management consoles to operate on a single host computer by sharing access to resources like the SNMPTRAP port.  A SNMP manager application would use  the Management APIs to send GET, SET, or GETNEXT requests to a SNMP agent application or to simply listen for traps from a SNMP agent application.  The Management APIs are implemented as a Win32 DLL (note  the trap-related functions are only available when the SNMP Trap Service is running).  \par Miscellaneous utility APIs are also provided to assist with comparing, copying, and freeing allocated data structures, among other operations.   \par \pard\plain \s1\sb120\keepn\widctlpar \b\f9 2.\tab Application Program Interfaces \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 There are three categories of APIs provided:  Agent, Manager, and Utility.   \par Wherever possible, the low-level details of SNMP have been hidden by these APIs.  Abstract Syntax Notation One (ASN.1) and its Basic Encoding Rules (BER)  are not exposed by these APIs.  The formatting and parsing of SNMP packets, and the communications code that sends/receives SNMP packets on the network are not exposed by these APIs.   \par The APIs utilize type definitions for SNMP variables, SNMP variable bindings, and SNMP variable bindings lists.  These definitions along with the API parameters comprise the interface exposed to the ISV developing a SNMP agent extension  or manager application.   \par Agent APIs define the interface between the Windows NT extensible agent and the ISV-developed subagent DLLs. \par Manager APIs define the interface between ISV-developed manager applications and the Management API DLL.   \par Utility APIs are provided to simplify manipulation of the type definitions discussed above, and perform other miscellaneous operations.   \par This results in the SNMP developer being able to concentrate on the task of providing or requesting management informati on without having to be concerned with socket programming, message generation and parsing, ASN.1 BER encoding and decoding, and other low-level details of SNMP.  This greatly simplifies the task of developing SNMP agent extensions  and manager applications.   \par \pard\plain \s2\sb120\keepn\widctlpar \b\f9 \page 2.1.\tab Agent APIs \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 Agent APIs define the interface between the Windows NT extensible agent and ISV-developed subagent DLLs.   \par These APIs are implemented by the ISV developing the subagent DLL and are called by the extensible agent provided by Microsoft.  Some may view these as similar to callbacks.  No active thread of execution is required in a subagent  DLL, but may be implemented if necessary to provided the desired functionality (neither of the Microsoft subagent DLLs discussed earlier contain an active thread of execution).   \par These ISV-developed subagent DLLs are dynamically linked by the extensible agent at run-time.  The extensible agent determines what subagent DLLs need to be loaded by referring to its parameters in the Registry.   \par There are four Agent APIs:  SnmpExtensionInit(), SnmpExtensionInitEx(), SnmpExtensionQuery(), and SnmpExtensionTrap().  SnmpExtensionInitEx() is optional and is designed for subagents who support multiple MIB views within the same DLL.  SnmpExtensionTrap () is optional and is designed for subagents who require trap generation capabilities.  \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 2.1.1.\tab SnmpExtensionInit() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpExtensionInit( \par     IN  DWORD               dwTimeZeroReference, \par     OUT HANDLE              *hPollForTrapEvent, \par     OUT AsnObjectIdentifier *supportedView) \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpExtensionInit} function exported by the ISV-developed subagent DLL is called by the extensible agent during the extensible agent\rquote s service startup to exchange configuration information.   \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 dwTimeZeroReference \tab Specifies a time-zero reference for the subagent.   \par hPollForTrapEvent \tab Points to a handle for an event that will be signaled when the {\b\f9 SnmpExtensionTrap} entry point should be polled by the extensible agent.  If traps are not generated by the subagent, NULL should be returned.   \par supportedView \tab Points to an AsnObjectIdentifier specifying the MIB sub-tree supported by the subagent.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function is successful, the return value is TRUE.   \par If the function fails, the return value is FALSE.   \par {\b\f9 Comments}{\b  \par }The dwTimeZeroReference allows all subagents to report time information from the same reference point.  The subagent can compute elapsed time by subtracting dwTimeZeroReference from the value returned by {\b\f9 GetCurrentTime} .  This time reference is necessary to implement traps, and possibly some MIB variables.   \par The subagent may need to generate traps for a variety of reasons.  The hPollForTrapEvent is provided to support this functionality.  The event handle is created by the subagent during initialization by calling {\b\f9 CreateEvent}.  When this event is  signaled, the extensible agent will call the {\b\f9 SnmpExtensionTrap} entry point and use the returned information to send a trap to each destination listed in the Registry.   \par {\b\f9 See Also}{\f9   \par }SnmpExtensionTrap(), GetCurrentTime(), CreateEvent(), SetEvent(). \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.1.2.\tab SnmpExtensionInitEx() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpExtensionInit( \par \tab OUT AsnObjectIdentifier *supportedView) \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpExtensionInitEx} function exported by the ISV-developed subagent DLL is called by the extensible agent during the extensible agent\rquote s service  startup to exchange additional configuration information.   \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 supportedView \tab Points to an AsnObjectIdentifier specifying the MIB sub-tree supported by the subagent.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If supportedView has been initialized with an additional MIB sub-tree, the return value is TRUE.   \par If there are no more MIB sub-trees to register, the return value is FALSE.   \par {\b\f9 Comments}{\b  \par }The extensible agent repeatedly calls the {\b SnmpExtensionInitEx} entry point in order to give subagents a chance to register support for additional MIB views.  The subagent must keep track of which MIB views have already been registered. \par {\b\f9 See Also}{\f9   \par }SnmpExtensionInit(). \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.1.3.\tab SnmpExtensionQuery() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpExtensionQuery( \par     IN BYTE                   requestType, \par     IN OUT RFC1157VarBindList *variableBindings, \par     OUT AsnInteger            *errorStatus, \par     OUT AsnInteger            *errorIndex) \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpExtensionQuery} function exported by the subagent DLL is called by the extensible agent to resolve SNMP requests containing variables within one or more of the subagent\rquote  s registered MIB views.   \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 requestType \tab Specifies the SNMP request type from the following list: \par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 requestType\tab Description \par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 ASN_RFC1157_GETREQUEST\tab Indicates SNMP Get Request.   \par ASN_RFC1157_GETNEXTREQUEST\tab Indicates SNMP Get Next Request.   \par ASN_RFC1157_SETREQUEST\tab Indicates SNMP Set Request.   \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 variableBindings \tab Points to the variable bindings list.   \par errorStatus \tab Points to variable to receive the resulting error status from the following list  \par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 errorStatus\tab Description \par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 ASN_ERRORSTATUS_NOERROR\tab Indicates the noError error status.   \par ASN_ERRORSTATUS_TOOBIG\tab Indicates the tooBig error status.   \par ASN_ERRORSTATUS_NOSUCHNAME\tab Indicates the noSuchName error status.   \par ASN_ERRORSTATUS_BADVALUE\tab Indicates the badValue error status.   \par ASN_ERRORSTATUS_READONLY\tab Indicates the readOnly error status.   \par ASN_ERRORSTATUS_GENERR\tab Indicates the genError error status.   \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 errorIndex \tab Points to variable to receive the resulting error index.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function is successful, the return value is TRUE.   \par If the function fails, the return value is FALSE.   \par {\b\f9 Comments}{\b  \par }This entry point is called when the extensible agent must resolve a GET, GETNEXT, or SET operation within the subtree registered by the subagent during initialization.  For GET or SET operations, the ISV must follow the rules in RFC 1157  to resolve the variable bindings or generate an error.   \par The GETNEXT operation is more complicated to process.  The requested variable may not be resolvable by this subagent.  If it can be resolved by this subagent, the ISV must follow the rules in RFC 1157 to resolve the var iable bindings or generate an error.  If it cannot be resolved by this subagent, the ISV must alter the name field of the variable binding to point just past the supportedView provided by {\b\f9 SnmpExtensionInit} .  If the agent's supported view was ".1.3.6.1.4.1.77.1", a GETNEXT request using variable ".1.3.6.1.4.1.77.1.5.1" would result in the name field being modified to be ".1.3.6.1.4.1.77.2".  This signals the extensible a gent to continue to attempt to resolve such variable bindings with other subagents.   \par It is important to note that during the {\b SnmpExtensionQuery} call, the extensible agent will be allocating dynamic memory that may be released by the subagent (if the object identifier needs to be modified)  and the subagent will be allocating dynamic memory that may be released by the extensible agent (if the object identifier was modified or if the value of the requested variable was an object identifer or a dynamically allocated string).  It is therefore  critical that both the extensible agent and the subagent use allocation routines that resolve to the same heap.  Originally, the ISVs developing Windows NT subagents were encouraged to use malloc() and free().  Unfortunately,  different versions of the C runtime implemented these functions differently.  In the Windows NT 3.51 release, a pair of macros were introduced, SNMP_malloc() and SNMP_free(), which simply resolved to GlobalAlloc() and GlobalFree().   Although this solved the problem of the extensible agent and the subagent using different allocation routines, it did not provide a means for easily debugging memory leaks.  In the Windows NT 4.0 release, the macros have been replaced by two entry points , {\b SnmpUtilMemAlloc}() and {\b SnmpUtilMemFree}(), in a new utility DLL (SNMPAPI.DLL).  Subagents should use these two functions (SNMP_malloc() and SNMP_free() now resolve to these functions) and should not assume they resolve to  GlobalAlloc() and GlobalFree() or any other specific heap routine. \par  \par {\b\f9 See Also}{\f9   \par }SnmpExtensionInit(), SnmpExtensionInitEx(), RFC 1157. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.1.4.\tab SnmpExtensionTrap() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpExtensionTrap( \par     OUT AsnObjectIdentifier *enterprise, \par     OUT AsnInteger          *genericTrap, \par     OUT AsnInteger          *specificTrap, \par     OUT AsnTimeticks        *timeStamp, \par     OUT RFC1157VarBindList  *variableBindings) \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpExtensionTrap} function exported by the subagent DLL is called by the extensible agent to retrieve subagent generated traps.   \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 enterprise \tab Points to an object identifier indicating the originating enterprise generating the trap.   \par genericTrap \tab Points to an indication of the generic trap generated from the following list: \par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 genericTrap\tab Description \par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 SNMP_GENERICTRAP_COLDSTART\tab Indicates Cold Start trap.   \par SNMP_GENERICTRAP_WARMSTART\tab Indicates Warm Start trap.   \par SNMP_GENERICTRAP_LINKDOWN\tab Indicates Link Down trap.   \par SNMP_GENERICTRAP_LINKUP\tab Indicates Link Up trap.   \par SNMP_GENERICTRAP_AUTHFAILURE\tab Indicates Authentication Failure trap.   \par SNMP_GENERICTRAP_EGPNEIGHLOSS\tab Indicates EGP Neighbor Loss trap.   \par SNMP_GENERICTRAP_ENTERSPECIFIC\tab Indicates Enterprise Specific trap.   \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 specificTrap \tab Points to an indication of the specific trap generated.   \par timeStamp \tab Points to variable to receive the time-stamp.   \par variableBindings \tab Points to the variable bindings list.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function returned a trap in its parameters, the return value is TRUE.  The function is called repeatedly by the extensible agent until a return value of FALSE is returned.   \par {\b\f9 Comments}{\b  \par }This function is repeatedly called by the extensible agent once hPollForTrapEvent has been signaled.  Each successful call returns a single trap's data in its parameters.  It returns FALSE to indicate that it\rquote  s parameters do not represent valid trap data and to stop the extensible agent's repeated calls.   \par It is important to note that earlier documentation stated that the enterprise OID returned by the subagent must be dynamically allocated because the extensible agent would attempt to release the memory after sending the trap.  This may have been how the  function was originally designed but it was not implemented like this in the extensible agent of any release of Windows NT.  The subagent should not expect the extensible agent to attempt to release the memory associated with the enterprise OID.   It is recommended instead that you simply return a pointer to a static OID structure. \par {\b\f9 See Also}{\f9   \par }SnmpExtensionInit(). \par \pard\plain \s2\sb120\keepn\widctlpar \b\f9 \page 2.2.\tab Manager APIs \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 Manager APIs define the interface between ISV-developed Manager Applications and the Management API DLL.   \par These APIs are provided by the Management API DLL.  In the Windows NT 3.51 release and earlier, a detached process is used to receive SNMP traps and dispatch them to the Manager Applications that have registered to receive SNMP traps via  SnmpMgrTrapListen().  In the Windows NT 4.0 release, a separate SNMP Trap Service has been introduced so that SNMP Manager applications not using the Manager API can control the acquistion of the SNMPTRAP port  Note that t he SNMP Trap Service must be started before Manager applications can successfully call SnmpMgrTrapListen().  The Manager APIs are synchronous except the APIs dealing with SNMP traps, which are either polled or notification based.   \par The ISV-developed Manager Application links with this DLL to gain access to its services.   \par There are several Manager APIs:  SnmpMgrOpen(), SnmpMgrClose(), SnmpMgrRequest(), SnmpMgrStrToOid(), SnmpMgrOidToStr(), SnmpMgrTrapListen(), and SnmpMgrGetTrap().  SnmpMgrOpen(), SnmpMgrClose(), and SnmpMgrRequest() are the primary APIs.  SnmpMgrStrToOid( ) and SnmpMgrOidToStr() are only accessed if their respective conversions of Object Identifiers to/from Object Descriptors are desired.  SnmpMgrTrapListen() and SnmpMgrGetTrap() are only accessed if trap reception is desired.   \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 2.2.1.\tab SnmpMgrOpen() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 LPSNMP_MGR_SESSION SnmpMgrOpen( \par     IN LPSTR lpAgentAddress,    // Name/address of target SNMP agent \par     IN LPSTR lpAgentCommunity,  // Community for target SNMP agent \par     IN INT   nTimeOut,          // Communication time-out in milliseconds \par     IN INT   nRetries)          // Communication time-out/retry count \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpMgrOpen} function initializes communications sockets and data structures allowing communications with the specified agent.   \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 lpAgentAddress \tab Points to a null-terminated string specifying either a dotted-decimal IP address, or a host name that can be resolved to an IP address.   \par lpAgentCommunity \tab Points to a null-terminated string specifying the SNMP Community Name used when communicating with the agent specified in lpAgentAddress.   \par nTimeOut \tab Specifies the communications time-out in milliseconds.   \par nRetries \tab Specifies the communications retry count.  The time-out specified in nTimeOut is doubled each time a retry attempt is transmitted.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function is successful, the return value is a pointer to a LPSNMP_MGR_SESSION structure.  This structure is used internally and should not be altered by the programmer.   \par If the function fails, the return value is NULL.  Use the {\b\f9 GetLastError} function to obtain extended error information.   \par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 GetLastError()\tab Description \par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 SNMP_MEM_ALLOC_ERROR\tab Indicates error allocating memory.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Comments}{\b  \par }None. \par {\b\f9 See Also}{\f9   \par }SnmpMgrClose(), SnmpMgrRequest(). \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.2.2.\tab SnmpMgrClose() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpMgrClose( \par     IN LPSNMP_MGR_SESSION session) // SNMP session pointer \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpMgrClose} function closes communications socket and data structures associated with the specified session. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 session \tab Points to a LPSNMP_MGR_SESSION structure specifying the session to close.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function is successful, the return value is TRUE.   \par If the function fails, the return value is FALSE.  Use the {\b\f9 GetLastError} function to obtain extended error information.   \par {\b\f9 Comments}{\b  \par }None. \par {\b\f9 See Also}{\f9   \par }SnmpMgrOpen(), SnmpMgrRequest(). \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.2.3.\tab SnmpMgrRequest() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 SNMPAPI SnmpMgrRequest( \par     IN     LPSNMP_MGR_SESSION session,           // SNMP session pointer \par     IN     BYTE               requestType,       // Get, GetNext, or Set \par     IN OUT RFC1157VarBindList *variableBindings, // Varible bindings \par     OUT    AsnInteger         *errorStatus,      // Result error status \par     OUT    AsnInteger         *errorIndex)       // Result error index \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpMgrRequest} function requests the specified operation be performed with the specified agent.   \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 session \tab Points to a LPSNMP_MGR_SESSION structure specifying the session that will perform the request.   \par requestType \tab Specifies the SNMP request type from the following list: \par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 requestType\tab Description \par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 ASN_RFC1157_GETREQUEST\tab Indicates SNMP Get Request.   \par ASN_RFC1157_GETNEXTREQUEST\tab Indicates SNMP Get Next Request.   \par ASN_RFC1157_SETREQUEST\tab Indicates SNMP Set Request.   \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 variableBindings \tab Points to the variable bindings list.   \par errorStatus \tab Points to variable to receive the resulting error status from the following list (see sections 4.1.2, 4.1.3, and 4.1.5 of RFC 1157 to understand the meaning of these errors for the supplied requestType): \par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 errorStatus\tab Description \par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 ASN_ERRORSTATUS_NOERROR\tab Indicates the noError error status.   \par ASN_ERRORSTATUS_TOOBIG\tab Indicates the tooBig error status.   \par ASN_ERRORSTATUS_NOSUCHNAME\tab Indicates the noSuchName error status.   \par ASN_ERRORSTATUS_BADVALUE\tab Indicates the badValue error status.   \par ASN_ERRORSTATUS_READONLY\tab Indicates the readOnly error status.   \par ASN_ERRORSTATUS_GENERR\tab Indicates the genError error status.   \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 errorIndex \tab Points to variable to receive the resulting error index.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function is successful, the return value is TRUE.   \par If the function fails, the return value is NULL.  Use the {\b\f9 GetLastError} function to obtain extended error information.   \par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 GetLastError()\tab Description \par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 SNMP_MGMTAPI_TIMEOUT\tab Request timed-out.   \par SNMP_MGMTAPI_SELECT_FDERRORS\tab Unexpected error file descriptors indicated by select().   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Comments}{\b  \par }For GET and GETNEXT requests, each variable in the variableBindings must be initialized to type ASN_NULL.  . \par {\b\f9 See Also}{\f9   \par }SnmpMgrOpen(), SnmpMgrClose(), RFC 1157. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.2.4.\tab SnmpMgrStrToOid() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpMgrStrToOid( \par     IN  LPSTR               string,   // OID string to be converted \par     OUT AsnObjectIdentifier *oid)     // OID internal representation \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpMgrStrToOid} function converts a string OBJECT IDENTIFIER or OBJECT DESCRIPTOR representation to an internal AsnObjectIdentifier. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 string \tab Points to a NULL terminated string to be converted.   \par oid \tab Points to an AsnObjectIdentifier variable to receive the converted value.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function is successful, the return value is TRUE.   \par If the function fails, the return value is FALSE.   \par {\b\f9 Comments}{\b  \par }None. \par {\b\f9 See Also}{\f9   \par }SnmpMgrOidToStr(), MibCC. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.2.5.\tab SnmpMgrOidToStr() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpMgrOidToStr( \par     OUT AsnObjectIdentifier oid,     // OID internal rep to be converted \par     IN  LPSTR               string)  // OID string representation \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpMgrStrToOid} function converts an internal AsnObjectIdentifier to a string OBJECT IDENTIFIER or OBJECT DESCRIPTOR representation. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 oid \tab Points to an AsnObjectIdentifier to be converted.   \par string \tab Points to a NULL terminated string to receive the converted value.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function is successful, the return value is TRUE.   \par If the function fails, the return value is FALSE.   \par {\b\f9 Comments}{\b  \par }None. \par {\b\f9 See Also}{\f9   \par }SnmpMgrStrToOid(), MibCC. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.2.6.\tab SnmpMgrTrapListen() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpMgrTrapListen( \par     OUT HANDLE *phTrapAvailable) // Event handle indicating trap(s) available \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpMgrTrapListen} function registers the desire to receive SNMP traps.   \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 phTrapAvailable \tab Points to an event that is asserted when new traps have been received.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function is successful, the return value is TRUE.   \par If the function fails, the return value is FALSE.  Use the {\b\f9 GetLastError} function to obtain extended error information.   \par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 GetLastError()\tab Description \par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 SNMP_MGMTAPI_TRAP_DUPINIT\tab This function has already been called.   \par SNMP_MGMTAPI_AGAIN\tab Error encountered, can attempt call again.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Comments}{\b  \par }The phTrapAvailable event is provided to allow event-driven acquisition of SNMP traps.  It can be ignored and the {\b\f9 SnmpMgrGetTrap} function can be polled at regular intervals.   \par Or, a thread could be created waiting on the event using {\b\f9 WaitForSingleObject}.  When the event is asserted, this thread should clear the event using {\b\f9 ResetEvent}, and then repeatedly call the {\b\f9 SnmpMgrGetTrap}  function until it returns FALSE.   \par {\b\f9 See Also}{\f9   \par }SnmpMgrGetTrap(), WaitForSingleObject(), ResetEvent(). \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.2.7.\tab SnmpMgrGetTrap() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 BOOL SnmpMgrGetTrap( \par     OUT AsnObjectIdentifier *enterprise,       // Generating enterprise \par     OUT AsnInteger          *genericTrap,      // Generic trap type \par     OUT AsnInteger          *specificTrap,     // Enterprise specific type \par     OUT AsnTimeticks        *timeStamp,        // Time stamp \par     OUT RFC1157VarBindList  *variableBindings) // Variable bindings \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpMgrGetTrap} function returns outstanding trap data that the caller has not yet received.   \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 enterprise \tab Points to an object identifier indicating the originating enterprise generating the trap.   \par genericTrap \tab Points to an indication of the generic trap generated from the following list: \par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 genericTrap\tab Description \par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 SNMP_GENERICTRAP_COLDSTART\tab Indicates Cold Start trap.   \par SNMP_GENERICTRAP_WARMSTART\tab Indicates Warm Start trap.   \par SNMP_GENERICTRAP_LINKDOWN\tab Indicates Link Down trap.   \par SNMP_GENERICTRAP_LINKUP\tab Indicates Link Up trap.   \par SNMP_GENERICTRAP_AUTHFAILURE\tab Indicates Authentication Failure trap.   \par SNMP_GENERICTRAP_EGPNEIGHLOSS\tab Indicates EGP Neighbor Loss trap.   \par SNMP_GENERICTRAP_ENTERSPECIFIC\tab Indicates Enterprise Specific trap.   \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 specificTrap \tab Points to an indication of the specific trap generated.   \par timeStamp \tab Points to variable to receive the time-stamp.   \par variableBindings \tab Points to the variable bindings list.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function returned a trap in its parameters, the return value is TRUE.  The function should be called repeatedly until a return value of FALSE is returned with {\b\f9 GetLastError()} indicating either an error or SNMP_MGMTAPI_NOTRAPS.   \par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 GetLastError()\tab Description \par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 SNMP_MGMTAPI_TRAP_ERRORS\tab Errors encountered, traps not accessible.   \par SNMP_MGMTAPI_NOTRAPS\tab No traps are available.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Comments}{\b  \par }The phTrapAvailable event from {\b\f9 SnmpMgrTrapListen} is provided to allow event-driven acquisition of SNMP traps.  It can be ignored and this function can be polled at regular intervals.   \par Or, a thread could be created waiting on the event using {\b\f9 WaitForSingleObject}.  When the event is asserted, this thread should clear the event using {\b\f9 ResetEvent}, and then repeatedly call the this function until it returns FALSE.   \par {\b\f9 See Also}{\f9   \par }SnmpMgrTrapListen(), WaitForSingleObject(), ResetEvent(). \par \pard\plain \s2\sb120\keepn\widctlpar \b\f9 \page 2.3.\tab Utility APIs \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 Utility APIs are provided to simplify manipulation of the type definitions discussed above, and perform other miscellaneous operations.   \par In the Windows NT 3.51 release and earilier, these APIs were provided by the SNMP static library, {\b\f9 SNMP.LIB}.  In the Windows NT 4.0 release, these APIs are provided by the SNMP utility DLL,{\b  }{\b\f9 SNMPAPI.DLL}, and it\rquote s import library,  {\b\f9 SNMPAPI.LIB}. \par The ISV developed Application links with this library to gain access to its services.   \par There are several Utility APIs:  SnmpUtilMemAlloc(), SnmpUtilMemFree(), SnmpUtilMemReAlloc(), SnmpUtilOi dCpy(), SnmpUtilOidAppend(), SnmpUtilOidNCmp(), SnmpUtilOidCmp(), SnmpUtilOidFree(), SnmpUtilVarBindListCpy(), SnmpUtilVarBindCpy(), SnmpUtilVarBindListFree(), SnmpUtilVarBindFree(), and SnmpUtilPrintAsnAny().   \par Care should be taken to insure that dynamic memory is allocated with SnmpUtilMemAlloc() and is released with SnmpUtilMemFree().  The extensible agent and all of the Utility APIs use these routines exclusively.  \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 2.3.1.\tab SnmpUtilMemAlloc() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 LPVOID SnmpUtilMemAlloc( \par \tab IN UINT Size // number of bytes to allocate \par     ); \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilMemAlloc} function allocates the specified number of bytes from the heap. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 Size \tab Specifies the number of bytes to allocate. \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function is successful, the return value is a pointer to the newly allocated memory object.   \par If the function fails, the return value is NULL.   \par {\b\f9 Comments}{\b  \par }Memory should be released using {\b\f9 SnmpUtilMemFree}. \par {\b\f9 See Also}{\f9   \par }SnmpUtilMemFree(), SnmpUtilMemReAlloc(). \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.2.\tab SnmpUtilMemFree() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 VOID SnmpUtilMemFree( \par \tab IN LPVOID Addr // pointer to the memory object \par     ); \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilMemFree} function frees the specified memory object. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 Addr \tab Specifies the memory object to release. \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }None.   \par {\b\f9 Comments}{\b  \par }Memory should be allocated using {\b\f9 SnmpUtilMemAlloc}. \par {\b\f9 See Also}{\f9   \par }SnmpUtilMemAlloc(), SnmpUtilMemReAlloc(). \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.3.\tab SnmpUtilMemReAlloc() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 LPVOID SnmpUtilMemReAlloc( \par \tab IN LPVOID Addr, // pointer to the memory object \par \tab IN UINT Size    // number of bytes to allocate \par     ); \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilMemReAlloc} function changes the size of the specified memory object. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 Addr \tab Specifies the memory object to resize. \par Size \tab Specifies the new size of the memory object. \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function is successful, the return value is a pointer to the newly allocated memory object.   \par If the function fails, the return value is NULL.   \par {\b\f9 Comments}{\b  \par }Memory should be released using {\b\f9 SnmpUtilMemFree}. \par {\b\f9 See Also}{\f9   \par }SnmpUtilMemAlloc(), SnmpUtilMemFree(). \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.4.\tab SnmpUtilOidCpy() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 SNMPAPI SnmpUtilOidCpy( \par     OUT AsnObjectIdentifier *DestObjId, // Destination OID \par     IN AsnObjectIdentifier *SrcObjId    // Source OID \par     ); \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilOidCpy} function copies the SrcObjId to the DestObjId allocating any necessary memory for the destination's copy. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 DestObjId \tab Points to an AsnObjectIdentifier variable to receive the copy.   \par SrcObjId \tab Points to an AsnObjectIdentifier variable to copy.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function is successful, the return value is TRUE.   \par If the function fails, the return value is FALSE.   \par {\b\f9 Comments}{\b  \par }Any memory allocated for the destination can be freed using {\b\f9 SnmpUtilOidFree}. \par {\b\f9 See Also}{\f9   \par }SnmpUtilOidFree(). \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.5.\tab SnmpUtilOidAppend() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 SNMPAPI SnmpUtilOidAppend( \par     IN OUT AsnObjectIdentifier *DestObjId, // Destination OID \par     IN AsnObjectIdentifier *SrcObjId       // Source OID \par     ); \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilOidAppend} function appends the SrcObjId to the DestObjId reallocating any necessary memory for the destination's copy. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 DestObjId \tab Points to an AsnObjectIdentifier variable to receive the copy.   \par SrcObjId \tab Points to an AsnObjectIdentifier variable to copy.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function is successful, the return value is TRUE.   \par If the function fails, the return value is FALSE.   \par {\b\f9 Comments}{\b  \par }Any memory allocated for the destination can be freed using {\b\f9 SnmpUtilOidFree}. \par {\b\f9 See Also}{\f9   \par }SnmpUtilOidFree(). \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.6.\tab SnmpUtilOidNCmp() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 int SnmpUtilOidNCmp( \par     IN AsnObjectIdentifier *A, // First OID \par     IN AsnObjectIdentifier *B, // Second OID \par     IN UINT Len                // Max len to compare \par     ); \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilOidNCmp} function compares Len sub-identifiers of A and B. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 A \tab Points to an AsnObjectIdentifier variable to compare.   \par B \tab Points to an AsnObjectIdentifier variable to compare.   \par Len \tab Indicates the number of sub-identifiers to compare.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }The function returns a value greater than zero if A is greater than B, zero if A equals B, and less than zero if A is less than B.   \par {\b\f9 Comments}{\b  \par }None.   \par {\b\f9 See Also}{\f9   \par }SnmpUtilOidCmp().   \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.7.\tab SnmpUtilOidCmp() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 int SnmpUtilOidCmp( \par     IN AsnObjectIdentifier *A, // First OID \par     IN AsnObjectIdentifier *B, // Second OID \par     ); \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilOidCmp} function compares object identifiers A and B. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 A \tab Points to an AsnObjectIdentifier variable to compare.   \par B \tab Points to an AsnObjectIdentifier variable to compare.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }The function returns a value greater than zero if A is greater than B, zero if A equals B, and less than zero if A is less than B.   \par {\b\f9 Comments}{\b  \par }None.   \par {\b\f9 See Also}{\f9   \par }SnmpUtilOidNCmp().   \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.8.\tab SnmpUtilOidFree() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 void SnmpUtilOidFree( \par     IN OUT AsnObjectIdentifier *Obj // OID to free \par     ); \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilOidFree} function frees any allocated data associated with Obj. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 Obj \tab Points to an AsnObjectIdentifier variable whose allocated data should be freed.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }None.   \par {\b\f9 Comments}{\b  \par }None.   \par {\b\f9 See Also}{\f9   \par }None.   \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.9.\tab SnmpUtilVarBindListCpy() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 SNMPAPI SnmpUtilVarBindListCpy( \par     RFC1157VarBindList *dst, // Destination var bind list \par     RFC1157VarBindList *src  // Source var bind list \par     ); \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilOidCpy} function copies the RFC1157VarBindList allocating any necessary memory for the destination's copy. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 dst \tab Points to an RFC1157VarBindList to receive the copy.   \par src \tab Points to an RFC1157VarBindList to copy.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function is successful, the return value is TRUE.   \par If the function fails, the return value is FALSE.   \par {\b\f9 Comments}{\b  \par }Any memory allocated for the destination can be freed using {\b\f9 SnmpUtilVarBindListFree}. \par {\b\f9 See Also}{\f9   \par }SnmpUtilVarBindListFree(). \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.10.\tab SnmpUtilVarBindCpy() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 SNMPAPI SnmpUtilVarBindCpy( \par     RFC1157VarBind *dst, // Destination var bind \par     RFC1157VarBind *src  // Source var bind \par     ); \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilOidCpy} function copies the RFC1157VarBind allocating any necessary memory for the destination's copy. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 dst \tab Points to an RFC1157VarBind to receive the copy.   \par src \tab Points to an RFC1157VarBind to copy.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }If the function is successful, the return value is TRUE.   \par If the function fails, the return value is FALSE.   \par {\b\f9 Comments}{\b  \par }Any memory allocated for the destination can be freed using {\b\f9 SnmpUtilVarBindFree}. \par {\b\f9 See Also}{\f9   \par }SnmpUtilVarBindFree(). \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.11.\tab SnmpUtilVarBindListFree() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 void SnmpUtilVarBindListFree( \par     RFC1157VarBindList *VarBindList // Variable bindings list to free \par     ); \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilVarBindListFree} function frees any allocated data associated with VarBindList. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 VarBindList \tab Points to an RFC1157VarBindList whose allocated data should be freed.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }None.   \par {\b\f9 Comments}{\b  \par }None.   \par {\b\f9 See Also}{\f9   \par }None.   \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.12.\tab SnmpUtilVarBindFree() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 void SnmpUtilVarBindFree( \par     RFC1157VarBind *VarBind // Variable binding to free \par     ); \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilVarBindFree} function frees any allocated data associated with VarBind. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 VarBindList \tab Points to an RFC1157VarBind whose allocated data should be freed.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }None.   \par {\b\f9 Comments}{\b  \par }None.   \par {\b\f9 See Also}{\f9   \par }None.   \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 2.3.13.\tab SnmpUtilPrintAsnAny() \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 void SnmpUtilPrintAsnAny( \par     IN AsnAny *Any \par     ); \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 SnmpUtilPrintAsnAny} function prints the value of Any to stdout. \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Parameter\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 Any\tab Points to an AsnAny structure whose value is to be printed.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Returns}{\b  \par }None.   \par {\b\f9 Comments}{\b  \par }This function is provided for debugging and development purposes.  It does not generally print the data in forms a Manager Applications would normally need.   \par This function determines the type of data from the AsnAny structure which was probably set internally by referring to a BER tag value in an encoded stream.   \par {\b\f9 See Also}{\f9   \par }AsnAny.   \par \pard\plain \s1\sb120\keepn\widctlpar \b\f9 \page 3.\tab Structures and Types \par \pard\plain \s2\sb120\keepn\widctlpar \b\f9 3.1.\tab Structures \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.1.1.\tab AsnAny \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef struct \{ \par     BYTE asnType; \par     union \{ \par         // RFC 1155 SimpleSyntax (subset of ISO ASN.1) \par         AsnInteger           number; \par         AsnOctetString       string; \par         AsnObjectIdentifier  object; \par  \par         // ISO ASN.1 \par         AsnSequence          sequence; \par  \par         // RFC 1155 ApplicationSyntax \par         AsnIPAddress         address; \par         AsnCounter           counter; \par         AsnGauge             gauge; \par         AsnTimeticks         ticks; \par         AsnOpaque            arbitrary; \par     \} asnValue; \par \} AsnAny; \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 AsnAny} structure contains a SNMP variable type and value.  This structure is a member of the RFC1157VarBind structure used as a parameter in many of the SNMP APIs.   \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Member\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 asnType \tab Indicates the variable's type and what portion of the union should be used.   \par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 asnType\tab Description \par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 ASN_INTEGER\tab Indicates integer variable.   \par ASN_OCTETSTRING\tab Indicates octet string variable.   \par ASN_OBJECTIDENTIFIER\tab Indicates object identifier variable.   \par ASN_SEQUENCE\tab Indicates ASN sequence variable.   \par ASN_RFC1155_IPADDRESS\tab Indicates IP address variable.   \par ASN_RFC1155_COUNTER\tab Indicates counter variable.   \par ASN_RFC1155_GAUGE\tab Indicates gauge variable.   \par ASN_RFC1155_TIMETICKS\tab Indicates timeticks variable.   \par ASN_RFC1155_OPAQUE\tab Indicates opaque variable.   \par ASN_RFC1213_DISPSTRING\tab Indicates display string variable.   \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 asnValue \tab Contains the variable's value.  This union supports the possible SNMP values.   \par \pard\plain \s32\qj\li720\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx5040 \b\f9\fs20 Member\tab Description \par \pard\plain \s33\qj\fi-4320\li5040\sb100\widctlpar\tx5040 \f12\fs20 number\tab Accesses integer variable.   \par string\tab Accesses octet string variable.   \par object\tab Accesses object identifier variable.   \par sequence\tab Accesses ASN sequence variable.   \par address\tab Accesses IP address variable.   \par counter\tab Accesses counter variable.   \par gauge\tab Accesses gauge variable.   \par ticks\tab Accesses timeticks variable.   \par arbitrary\tab Accesses opaque variable.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Comments}{\b  \par }None. \par {\b\f9 See Also}{\f9   \par }RFC1157VarBind, RFC 1155. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.1.2.\tab RFC1157VarBind \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef struct vb \{ \par     AsnObjectName   name; \par     AsnObjectSyntax value; \par \} RFC1157VarBind; \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 RFC1157VarBind} structure represents a SNMP variable binding as defined in RFC 1157.   \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Member\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 name \tab Indicates the variable's name as an object identifier.   \par value \tab Contains the variable's value.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Comments}{\b  \par }None. \par {\b\f9 See Also}{\f9   \par }RFC 1155, RFC 1157. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.1.3.\tab RFC1157VarBindList \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef struct \{ \par     RFC1157VarBind *list; \par     UINT           len; \par \} RFC1157VarBindList; \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The {\b\f9 RFC1157VarBindList} structure represents a SNMP variable bindings list as defined in RFC 1157.   \par \pard\plain \s29\qj\sb100\widctlpar\brdrb\brdrs\brdrw15 \tx2880 \b\f9\fs20 Member\tab Description \par \pard\plain \s30\qj\fi-2880\li2880\sb100\widctlpar\tx2880 \f12\fs20 list \tab A pointer that may be dereferenced as an array to access individual variable bindings.   \par len \tab Contains the number of variable bindings in the list.   \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 Comments}{\b  \par }None. \par {\b\f9 See Also}{\f9   \par }RFC1157VarBind, RFC 1157. \par \pard\plain \s2\sb120\keepn\widctlpar \b\f9 \page 3.2.\tab Types \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.1.\tab AsnInteger \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef long           AsnInteger; \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnInteger} is used to represent signed integer quantities as defined in RFC 1155.   \par {\b\f9 See Also}{\f9   \par }RFC 1155. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.2.\tab AsnOctetString \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef struct \{ \par     BYTE *stream; \par     UINT  length; \par     BOOL dynamic; \par \}                      AsnOctetString; \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnOctetString} is used to represent octet (usually byte) quantities as defined in RFC 1155.   \par The dynamic flag indicates to data structure freeing code whether the stream is allocated from dynamic memory.   \par {\b\f9 See Also}{\f9   \par }RFC 1155. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.3.\tab AsnObjectIdentifier \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef struct \{ \par     UINT idLength; \par     UINT *ids; \par \}                      AsnObjectIdentifier; \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnObjectIdentifier} is used to represent objects as defined in RFC 1155.   \par {\b\f9 See Also}{\f9   \par }RFC 1155. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.4.\tab AsnSequence \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnOctetString AsnSequence; \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnSequence} is used to represent sequences as defined in RFC 1155.   \par {\b\f9 See Also}{\f9   \par }RFC 1155. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.5.\tab AsnImplicitSequence \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnSequence    AsnImplicitSequence; \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnImplicitSequence} is used to represent implicit sequences as defined in RFC 1155.   \par {\b\f9 See Also}{\f9   \par }RFC 1155. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.6.\tab AsnIPAddress \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnOctetString AsnIPAddress; \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnIPAddress} is used to represent Internet Protocol (IP) addresses as defined in RFC 1155.   \par {\b\f9 See Also}{\f9   \par }RFC 1155. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 \page 3.2.7.\tab AsnDisplayString \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnOctetString AsnDisplayString; \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnDisplayString} is used to represent human readable octets as defined in RFC 1213.   \par {\b\f9 See Also}{\f9   \par }RFC 1213. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.8.\tab AsnCounter \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnInteger     AsnCounter; \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnCounter} is used to represent counted quantities as defined in RFC 1155.   \par {\b\f9 See Also}{\f9   \par }RFC 1155. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.9.\tab AsnGauge \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnInteger     AsnGauge; \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnGauge} is used to represent metered quantities as defined in RFC 1155.   \par {\b\f9 See Also}{\f9   \par }RFC 1155. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.10.\tab AsnTimeticks \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnInteger     AsnTimeticks; \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnTimeTicks} is used to represent relative time quantities as defined in RFC 1155.   \par {\b\f9 See Also}{\f9   \par }RFC 1155. \par \pard\plain \s3\sb120\keepn\widctlpar\tx1080 \b\f9 3.2.11.\tab AsnOpaque \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 typedef AsnOctetString AsnOpaque; \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 {\b\f9 AsnOpaque} is used to represent an encapsolation of other ASN constructs as defined in RFC 1155.   \par {\b\f9 See Also}{\f9   \par }RFC 1155. \par \pard\plain \s1\sb120\keepn\widctlpar \b\f9 \page 4.\tab MIB Compiler \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 A basic SNMP MIB Compiler is provided with the Management APIs.  This MIB c ompiler is currently used only to resolve the conversions requested by SnmpMgrStrToOid() and SnmpMgrOidToStr().  These conversions are Object Identifier to/from Object Descriptor translations.   \par Help on how this MIB compiler is invoked is provided by typing 'MIBCC -?':   \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 c:\\>mibcc -? \par usage: mibcc [-?] [-e] [-l] [-n] [-o] -[w] [files...]               \par    MibCC compiles the specified SNMP MIB files.                          \par       -?      usage.                                                     \par       -eX     stop after X Errors. (default = 10)                        \par       -l      do not print Logo.                                         \par       -n      print each Node as it is added.                            \par       -ofile  output file name.  (default = mib.bin)                     \par       -wX     set Warning level.  (1=errors, 2=warnings)                 \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20  This MIB compiler accepts the subset of ASN.1 defined by the SNMP RFCs.  A file containing ASN.1 source code can contain one or more MODULE definitions, although it is easier to keep one module per file and specify multiple files on the command line.  Ord er of specification is significant.  For example, SMI.MIB should be specified before any other MIBs. \par An example compile may look like: \par \pard\plain \s24\fi-720\li720\sb60\widctlpar\tx720\tx1440\tx2160 \f3\fs20 c:\\>mibcc smi.mib mib-ii.mib                    \par Microsoft (R) SNMP MIB Compiler Version 1.00                             \par Copyright (c) Microsoft Corporation 1992.  All rights reserved.          \par warning : EXPORTS on line 3 not supported (ignored)                      \par warning : IMPORTS on line 135 not supported (ignored)                    \par Parse of 'test.mib' was successful.  2756 lines were parsed.             \par mibcc: total files processed:  1.                                        \par mibcc: writing compiled SNMP MIB.                                        \par                                                                          \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 The following MIB files have been included in this distribution: SMI.MIB, MIB_II.MIB, LMMIB2.MIB, WINS.MIB, DHCP.MIB, INETSRV.MIB, HTTP.MIB, GOPHERD.MIB, FTP.MIB, and TOASTER.MIB.  \par \pard\plain \s1\sb120\keepn\widctlpar \b\f9 \page 5.\tab Example Code \par \pard\plain \s23\qj\sb100\widctlpar \f12\fs20 Example SNMP application entities are contained in the Win32 SDK to aid in understanding the workings of the various APIs.  Look undermstools\\samples\\win32\\winnt\\snmp\\testdll for an example subagent and  look under mstools\\samples\\win32\\winnt\\snmp\\snmputil for an example management application. \par It should be noted that agent developers should thoroughly understand the non-protocol issues presented in RFC 1155 and RFC 1157.   \par \pard\plain \s2\sb120\keepn\widctlpar \b\f9  \par }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\ws2inst\sample.ini ===
;;;
;;; The following section contains the number of transport service providers
;;; represented by this .INI file, and "pointers" to the .INI file sections
;;; corresponding to each of those transport service providers.
;;;

[WinSock 2.0 Transport Service Providers]

;;;
;;; ProviderCount is the number of transport service providers represented
;;; by this .INI file.
;;;

ProviderCount=2

;;;
;;; For each transport service provider there will be a value called
;;; "ProviderN" where "N" ranges from 0 to (ProviderCount-1). The value
;;; associated with each of these is the name of the .INI file section for
;;; that transport service provider.
;;;

Provider0=A Sample Transport

;;;
;;; Each provider will have its own uniquely named section.
;;;

[A Sample Transport]

;;;
;;; ProviderName contains the displayable name of the provider.
;;;

ProviderName=Sample Transport Service Provider

;;;
;;; ProviderPath contains the path to the provider's DLL.
;;;

ProviderPath=%SystemRoot%\System32\samxport.dll

;;;
;;; ProviderId contains the GUID identifying the provider.
;;;

ProviderId=0fdfcf40-d9d5-11cf-95cd-00805f48a192

;;;
;;; ProtocolCount contains the number of protocols supported by this
;;; provider.
;;;

ProtocolCount=3

;;;
;;; For each protocol there will be a section called "{name} Protocol M"
;;; where {name} is the name of the service provider.
;;;

[A Sample Transport Protocol 0]
dwServiceFlags1=0x66
dwServiceFlags2=0
dwServiceFlags3=0
dwServiceFlags4=0
dwProviderFlags=0x8
iVersion=0x2
iAddressFamily=0x2
iMaxSockAddr=0x10
iMinSockAddr=0x10
iSocketType=0x1
iProtocol=0x6
iProtocolMaxOffset=0
iNetworkByteOrder=0
iSecurityScheme=0
dwMessageSize=0
dwProviderReserved=0
szProtocol=Sample TCP/IP

[A Sample Transport Protocol 1]
dwServiceFlags1=0x609
dwServiceFlags2=0
dwServiceFlags3=0
dwServiceFlags4=0
dwProviderFlags=0x8
iVersion=0x2
iAddressFamily=0x2
iMaxSockAddr=0x10
iMinSockAddr=0x10
iSocketType=0x2
iProtocol=0x11
iProtocolMaxOffset=0
iNetworkByteOrder=0
iSecurityScheme=0
dwMessageSize=0xffbb
dwProviderReserved=0
szProtocol=Sample UDP/IP

[A Sample Transport Protocol 2]
dwServiceFlags1=0x609
dwServiceFlags2=0
dwServiceFlags3=0
dwServiceFlags4=0
dwProviderFlags=0xc
iVersion=0x2
iAddressFamily=0x2
iMaxSockAddr=0x10
iMinSockAddr=0x10
iSocketType=0x3
iProtocol=0
iProtocolMaxOffset=255
iNetworkByteOrder=0
iSecurityScheme=0
dwMessageSize=0xffbb
dwProviderReserved=0
szProtocol=Sample RAW/IP

;;;
;;; The following section contains the number of namespace service providers
;;; represented by this .INI file, and "pointers" to the .INI file sections
;;; corresponding to each of those namespace service providers.
;;;

[WinSock 2 Name Space Providers]

;;;
;;; ProviderCount is the number of namespace service providers represented
;;; by this .INI file.
;;;

ProviderCount=2

;;;
;;; For each namespace service provider there will be a value called
;;; "ProviderN" where "N" ranges from 0 to (ProviderCount-1). The value
;;; associated with each of these is the name of the .INI file section for
;;; that namespace service provider.
;;;

Provider0=A Sample Namespace

;;;
;;; Each provider will have its own uniquely named section.
;;;

[A Sample Namespace]

;;;
;;; ProviderName contains the displayable name of the provider.
;;;

ProviderName=Sample Namespace Service Provider

;;;
;;; ProviderPath contains the path to the provider's DLL.
;;;

ProviderPath=%SystemRoot%\System32\samnspc.dll

;;;
;;; ProviderId contains the GUID identifying the provider.
;;;

ProviderId=0fdfcf41-d9d5-11cf-95cd-00805f48a192

;;;
;;; NameSpaceId contains the namespace identifier for the namespace
;;; implemented by the provider.
;;;

NameSpaceId=0xc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\util\ws2inst\ws2map.ini ===
[WinSock 2 Transport Service Providers]
ProviderCount=1
Provider0=WinSock 2:1 Mapper Transport Provider

[WinSock 2:1 Mapper Transport Provider]
ProviderName=WinSock 2:1 Mapper
ProviderPath=%SystemRoot%\System32\ws2map.dll
ProviderId=008e39b0-c4af-11cf-95c8-00805f48a192
ProtocolCount=3

[WinSock 2:1 Mapper Transport Provider Protocol 0]
dwServiceFlags1=0x66
dwServiceFlags2=0
dwServiceFlags3=0
dwServiceFlags4=0
dwProviderFlags=0x8
iVersion=0x2
iAddressFamily=0x2
iMaxSockAddr=0x10
iMinSockAddr=0x10
iSocketType=0x1
iProtocol=0x6
iProtocolMaxOffset=0
iNetworkByteOrder=0
iSecurityScheme=0
dwMessageSize=0
dwProviderReserved=0
szProtocol=RWS TCP/IP Through 2:1 Mapper

[WinSock 2:1 Mapper Transport Provider Protocol 1]
dwServiceFlags1=0x609
dwServiceFlags2=0
dwServiceFlags3=0
dwServiceFlags4=0
dwProviderFlags=0x8
iVersion=0x2
iAddressFamily=0x2
iMaxSockAddr=0x10
iMinSockAddr=0x10
iSocketType=0x2
iProtocol=0x11
iProtocolMaxOffset=0
iNetworkByteOrder=0
iSecurityScheme=0
dwMessageSize=0xffbb
dwProviderReserved=0
szProtocol=RWS UDP/IP Through 2:1 Mapper

[WinSock 2:1 Mapper Transport Provider Protocol 2]
dwServiceFlags1=0x609
dwServiceFlags2=0
dwServiceFlags3=0
dwServiceFlags4=0
dwProviderFlags=0xc
iVersion=0x2
iAddressFamily=0x2
iMaxSockAddr=0x10
iMinSockAddr=0x10
iSocketType=0x3
iProtocol=0
iProtocolMaxOffset=255
iNetworkByteOrder=0
iSecurityScheme=0
dwMessageSize=0xffbb
dwProviderReserved=0
szProtocol=RWS RAW/IP Through 2:1 Mapper

[WinSock 2 Name Space Providers]
ProviderCount=1
Provider0=WinSock 2:1 Mapper Name Space Provider

[WinSock 2:1 Mapper Name Space Provider]
ProviderName=WinSock 2:1 Mapper
ProviderPath=%SystemRoot%\System32\ws2map.dll
ProviderId=008e39b0-c4af-11cf-95c8-00805f48a192
NameSpaceId=0xc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\registry.txt ===
note: for items where i give three default values, the first is for
small machines (<12.5 MB), the second is medium machines (12.5 to 20
MB) and the third is for large machines (> 20 MB).

**** AFD is the driver which handles winsock.  the following values
may be set under Services\Afd\Parameters:

LargeBufferSize, REG_DWORD, default = 3876
the size in bytes of large buffers used by AFD.  smaller values use
less memory, larger values can improve performance.

LargBufferListDepth, REG_DWORD, default = 0/2/10
the maximum count of large buffers that AFD keeps in reserve.  larger
numbers give better performance at the cost of physical memory.

MediumBufferSize, REG_DWORD, default = 1504
size of medium buffers.

MediumBufferListDepth, REG_DWORD, default = 4/8/16
max count of medium buffers in reserve.

SmallBufferSize, REG_DWORD, default = 128

SmallBufferListDepth, REG_DWORD, default = 8/16/16

FastSendDatagramThreshold, REG_DWORD, default = 1024
datagrams smaller than this get bufferred on send, larger ones are
pended.  the default value was found by testing to be the best
overall value for performance.  it is unlikely that anyone would want
to change this.

StandardAddressLength, REG_DWORD, default = 24
the length of TDI addresses typically used for the machine.  if the
customer has a transport protocol like TP4 which uses very long
addresses, then increasing this value will result in a slight
performance improvement.

DefaultReceiveWindow, REG_DWORD, default = 8192
the number of receive bytes AFD will buffer on a connection before
imposing flow control.  for some applications, a larger value here
will give slightly better performance at the expense of increases
resource utilization.  note that applications can modify this value
on a per-socket basis with the SO_RCVBUF socket option.

DefaultSendWindow, REG_DWORD, default = 8192
as with DefaultReceiveWindow, but for the send side of connections.

BufferMultiplier, REG_DWORD, default = 512
DefaultReceiveWindow and DefaultSendWindow get divided by this value
to determine how many massages can be sent/received before flow
control is imposed.

PriorityBoost, REG_DWORD, default = 2
the priority boost AFD gives to a thread when it completes I/O for
that thread.  if a multithreaded application experiences starvation
of some threads, reducing this value may remedy the problem.

IrpStackSize, REG_DWORD, default = 4
the count of IRP stack locations used by default for AFD.  users
shouldn't need to change this.

TransmitIoLength, REG_DWORD, default = PAGE_SIZE,PAGE_SIZE*2,65536
the default size for I/O (reads and sends) performed by TransmitFile().
Note that for the NT workstation product, the default I/O size is
exactly one page.

IgnorePushBitOnReceives, REG_DWORD, default = 0
If this value is zero (the default) and the TCP push bit is set on a
receive indication, then a larger then necessary buffer is passed down
to the TCP stack. This often gives a performance boost on receives.
If this value is non-zero, then the TCP push bit is ignored (this was
the behaviour of NT 3.1).

MaxActiveTransmitFileCount, REG_DWORD, default = 0
This value controls the maximum number of simultaneous TransmitFile
operations allowed. This registry value is only honored in the NT
Server product; NT Workstations always use a hardcoded (not configurable)
value.

MaxFastTransmit, REG_DWORD, default = 65536
This is the threshold count, in bytes, for the TransmitFile fast path to
fail.  If the caller requests a send larger than this, it will never
go through the TransmitFile fast path.

MaxFastCopyTransmit, REG_DWORD, default = 3876
If a TransmitFile caller requests a send smaller than this size, the
operation is performed by doing a data copy from the file data to a system
buffer.  This is slightly faster than direct I/O for small files, but for
larger files the copy overhead overwhelms the inherent efficiency of the
copy operation.

TransmitWorker, REG_DWORD, default=0x10
Specifies how afd should schedule work items to process long
(more than one send) transmit file request. By default (0x10)
afd uses system worker threads, with 0x20 it will use kernel
APC's in the context of the thread that initiated the request.
0x20 reduces number of context switches and potentially improves
performance, however, if thread that originated TransmitFile
request is used for heavy computation, it may not be interrupted
by the OS scheduler for significant period of time (up to a full
quantum) and APC will not get processed thus starwing request
processing

DisableRawSecurity, REG_DWORD default = 0;
Non-zero value tells afd to not require admin privilege 
to open a raw socket.

DisableAddressSharing, REG_DWORD, default = 0
Disallows sharing of ports between processes even if application
specifies SO_REUSEADDR in an attempt to hajack some other
application's port. Setting this flag will tighten security
although at the expense of additional checking for each created
socket as well as possibility of breaking some application which
require socket sharing accross processes

EnableDynamicBacklog, REG_DWORD, default = 0
Enables dynamic backlog algorithm on listening endpoints in
an attempt to thwart off syn attacks:         //
	If the free connection count has dropped below the configured
	minimum, the number of "quasi-free" connections is less than
	the configured maximum, and we haven't already queued enough
	requests to take us past the maximum, then add new free
	connections to the endpoint. "Quasi-free" is defined as the
	sum of the free connection count and the count of pending TDI
	accepts.

MinimumDynamicBacklog, REG_DWORD, default = 0
MaximumDynamicBacklog, REG_DWORD, default = 0
DynamicBacklogGrowthDelta, REG_DWORD, default = 0
Parameters in the algorithm described above.

*********** THE KEYS BELOW SHOULD NO LONGER BE RELEVANT *********
			(however, some code may be still using them)
*********** SEE WINSOCK2 SPECIFICATION **************************

**** the following keys are used by the RNR (service resolution and
registration) apis in winsock.  these are all just "pointers" to
other stuff in the registry.  users should never need to change
these.

under CurrentControlSet\Control\ServiceProvider\Order, values:

ExcludedProviders: a REG_MULTI_SZ that contains decimal values
corresponding to name space providers that should be excluded.
default is an empty set.  some name space provider decimal values
include:

#define NS_SAP                      (1)
#define NS_NDS                      (2)

#define NS_TCPIP_LOCAL              (10)
#define NS_TCPIP_HOSTS              (11)
#define NS_DNS                      (12)
#define NS_NETBT                    (13)
#define NS_WINS                     (14)

#define NS_NBP                      (20)

#define NS_MS                       (30)
#define NS_STDA                     (31)
#define NS_NTDS                     (32)

#define NS_X500                     (40)
#define NS_NIS                      (41)

for example, setting ExcludedProviders to "1" "12" means that
GetAddressByName() will not attempt to use SAP or DNS when doing
typical name resolution operations.

ProviderOrder: a REG_MULTI_SZ that contains strings corresponding to
keys under CurrentControlSet\Services.  these keys must have a
ServiceProvider subkey which provides information about the name
space provider, especially Class and ProviderPath values.

**** the following values are relevent to TCP/IP name resolution
(gethostbyname()) and the GetAddressByName() API.  under
Services\Tcpip\ServiceProvider:

Class, REG_DWORD, default = 8.  should never change--this indicates
that TCPIP is a name service provider.

DnsPriority, REG_DWORD, default = 0x7D0
HostsPriority, REG_DWORD, default = 0x1F4
LocalPriority, REG_DWORD, default = 0x1F3
NetbtPriority, REG_DWORD, default = 0x7D1
these priority values are used to determine the order of name
resolutions.  low priority mechanisms are used first, so the default
order is local, hosts, dns, netbt.  if someone wants a different name
resolution order, readjust the priority values as needed.  note that
values under 1000 decimal are considered "fast" name resolution
providers, so putting network-based resolution mechanisms like dns
and netbt at values under 1000 may have weird effects.

Name, REG_SZ, default = "TCP/IP"
no need to change.

ProviderPath, REG_SZ, default = "%SystemRoot%\System32\wsock32.dll"
points to the dll that does tcpip name resolution.  there is no need
to change this.

**** there are other keys associated with netware name resolution.
chuck chan will comment on their names and meaning.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\spinlock.txt ===
AfdSpinLock Usage
~~~~~~~~~~~~~~~~~

    ACCEPT.C

        Function:   AfdDeferAccept
        Protects:   Endpoint->Common.VcListening.UnacceptedConnectionListHead
        Synopsis:   Used when deferring an accept (putting a connection back
                    on the endpoint's unaccepted connection queue).
        Strategy:   None. Deferring accepted connections is a very low
                    frequency operation (and is impossible in WinSock 1.1).


    BIND.C

        Function:   AfdRestartGetAddress
        Protects:   Endpoint->LocalAddress[Length]
        Synopsis:   Used when allocating an endpoint's local address buffer
                    to prevent multiple processors from allocating the buffer.
        Strategy:   None. AfdGetAddress is only called during bind() and
                    getsockname() APIs. The bind() call is certainly more
                    interesting than getsockname(), but even bind() is only
                    called once per socket, so it is unlikely there would be
                    any benefit in tuning this.


    BLKCONN.C

        Function:   AfdAddFreeConnection
        Protects:   Endpoint->Common.VcListening.FreeConnectionListHead
        Synopsis:   Used when adding free connections to the endpoint's
                    free connection queue.
        Strategy:   Use SLIST for free connection queue.

        Function:   AfdFreeConnection
        Protects:   Endpoint->Common.VcListening.FreeConnectionListHead
        Synopsis:   Used when appending a reused connection to the endpoint's
                    free connection queue.
        Strategy:   Use SLIST for free connection queue.

        Function:   AfdDereferenceConnection
        Protects:   Connection->ReferenceCount
        Synopsis:   Synchronizes access to reference count member.
        Strategy:   Use InterlockedDecrement. If updated value is now zero,
                    then acquire AfdSpinLock, and recheck the value for zero.
                    If it's still zero, do the usual dereference stuff. This
                    will eliminate all spinlock acquisitions on reference/
                    dereference except the *last* dereference.

        Function:   AfdGetFreeConnection
        Protects:   Endpoint->Common.VcListening.FreeConnectionListHead
        Synopsis:   Used when removing a free connection from the endpoint's
                    free connection queue.
        Strategy:   Use SLIST for free connection queue.

        Function:   AfdGetReturnedConnection
        Protects:   Endpoint->Common.VcListening.ReturnedConnectionListHead
        Synopsis:   Used when scanning the returned connection queue for a
                    specific sequence number.
        Strategy:   None (for now).

        Function:   AfdReferenceConnection
        Protects:   Connection->ReferenceCount
        Synopsis:   Synchronizes access to reference count member.
        Strategy:   Use InterlockedIncrement instead.


    BLKENDP.C

        Function:   AfdFreeQueuedConnections
        Protects:   Endpoint->Common.VcListening.UnacceptedConnectionListHead
        Synopsis:   Used when puring the endpoint's unaccepted connection
                    queue.
        Strategy:   None (for now).

        Function:   AfdDereferenceEndpoint
        Protects:   Endpoint->ReferenceCount
        Synopsis:   Synchronizes access to reference count member.
        Strategy:   Use InterlockedDecrement. If updated value is now zero,
                    then acquire AfdSpinLock, and recheck the value for zero.
                    If it's still zero, do the usual dereference stuff. This
                    will eliminate all spinlock acquisitions on reference/
                    dereference except the *last* dereference.

        Function:   AfdReferenceEndpoint
        Protects:   Endpoint->ReferenceCount
        Synopsis:   Synchronizes access to reference count member.
        Strategy:   Use InterlockedIncrement instead.


    CLOSE.C

        Function:   AfdCleanup
        Protects:
        Synopsis:
        Strategy:


    CONNECT.C

        Function:   AfdSetupConnectDataBuffers
        Protects:   Endpoint->ConnectDataBuffers
        Synopsis:   Used to guard connect data buffers when they're moved
                    from an endpoint to a connection.
        Strategy:   Do the "double compare" trick to avoid acquiring the
                    spinlock if there are no connect data buffers on the
                    endpoint.

        Function:   AfdRestartConnect
        Protects:   Connection->ConnectDataBuffers
        Synopsis:   Used to guard connect data buffers after a connect
                    completes.
        Strategy:   Do the "double compare" trick to avoid acquiring the
                    spinlock if there are no connect data buffers on the
                    connection.

        
    DISCONN.C

        Function:   AfdPartialDisconnect(1)
        Protects:   Endpoint->DisconnectMode
        Synopsis:   Used to guard the disconnect mode bits when shutting
                    down a datagram endpoint.
        Strategy:   Test a Bunch-O-Bits in the endpoint, and only if
                    at least one of these is nonzero acquire the spinlock,
                    then proceed with the current tests.

        Function:   AfdPartialDisconnect(2)
        Protects:   Connection->Common.Bufferring.Receive[Expedited]BytesTaken
        Synopsis:   Used to guard access to the byte counters in the connection
                    when receives are shutdown so that the connection can be
                    aborted if necessary.
        Strategy:   None (for now).

        Function:   AfdDisconnectEventHandler
        Protects:   Connection->ConnectDataBuffers
        Synopsis:   Used to guard disconnect data buffers when a disconnect
                    indication is received.
        Strategy:   Do the "double compare" trick to avoid acquiring the
                    spinlock if there are no connect data buffers on the
                    connection.

        Function:   AfdBeginAbort
        Protects:   Bunch-O-Stuff
        Synopsis:
        Strategy:

        Function:   AfdBeginDisconnect
        Protects:   Bunch-O-Stuff, including disconnect buffers
        Synopsis:
        Strategy:

        Function:   AfdRestartDisconnect
        Protects:   DisconnectContext->DisconnectListEntry
        Synopsis:   Guards access to AfdDisconnectListHead
        Strategy:   AfdDisconnectListHead no longer used. Nuke it!


    LISTEN.C

        Function:   AfdWaitForListen
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdCancelWaitForListen
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdConnectEventHandler
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdRestartAccept
        Protects:
        Synopsis:
        Strategy:


    MISC.C

        Function:   AfdInsertNewEndpointInList
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdRemoveEndpointFromList
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdInterlockedRemoveEntryList
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdGetConnectData
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdSetConnectData
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdQueueWorkItem
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdDoWork
        Protects:
        Synopsis:
        Strategy:


    POLL.C

        Function:   AfdPoll
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdCancelPoll
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdIndicatePollEvent
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdTimeoutPoll
        Protects:
        Synopsis:
        Strategy:


    RECEIVE.C

        Function:   AfdReceive
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdRestartReceive
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdReceiveEventHandler
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdReceiveExpeditedEventHandler
        Protects:
        Synopsis:
        Strategy:

        Function:   AfdQueryReceiveInformation
        Protects:
        Synopsis:
        Strategy:


    SEND.C

        Function:   AfdRestartBufferSend
        Protects:   Connection->VcDisconnectIrp
        Synopsis:   Used to grab the disconnect IRP off a connection.
        Strategy:   Use InterlockedExchange. Will require changes to
                    blkconn!AfdFreeConnection.



AfdBufferSpinLock Usage
~~~~~~~~~~~~~~~~~~~~~~~

    BUFFER.C

        Function:   AfdGetBuffer
        Protects:   Afd{Small|Medium|Large}BufferListHead
        Synopsis:   Serializes access to the various buffer lists.
        Strategy:   Use DaveC's SLIST instead. We'll still need the spinlock
                    for PPC.

        Function:   AfdReturnBuffer
        Protects:   Afd{Small|Medium|Large}BufferListHead
        Synopsis:   Serializes access to the various buffer lists.
        Strategy:   Use DaveC's SLIST instead. We'll still need the spinlock
                    for PPC.



Endpoint->SpinLock Usage
~~~~~~~~~~~~~~~~~~~~~~~~

    ACCEPT.C

        Function:   AfdAcceptCore
        Protects:
        Synopsis:
        Strategy:


    BLKCONN.C

        Function:   AfdAddConnectedReference
        Protects:   Connection->ConnectedReferenceAdded
        Synopsis:
        Strategy:

        Function:   AfdDeleteConnectedReference
        Protects:
        Synopsis:
        Strategy:


    CLOSE.C

        Function:   AfdCleanup
        Protects:   Endpoint->{Receive|Peek}DatagramIrpListHead,
                    Endpoint->Vc{Receive|Send}IrpListHead,
                    Connection->CleanupBegun,
                    Endpoint->TransmitIrp
        Synopsis:
        Strategy:


    CONNECT.C

        Function:   AfdDoDatagramConnect
        Protects:   Endpoint->Common.Datagram.RemoteAddress[Length]
        Synopsis:
        Strategy:

        Function:   AfdRestartConnect
        Protects:   Connection->ConnectedReferenceAdded
        Synopsis:
        Strategy:

        Function:   AfdEnabledFailedConnectEvent
        Protects:   Endpoint->EventsEnabled
        Synopsis:
        Strategy:


    DISCONN.C

        Function:   AfdDisconnectEventHandler
        Protects:   Connection->Vc{Receive|Send}IrpListHead,
                    Connection->VcByteCounts
        Synopsis:
        Strategy:

        Function:   AfdBeginAbort
        Protects:   Connection->Vc{Receive|Send}IrpListHead,
        Synopsis:
        Strategy:

        Function:   AfdRestartAbort
        Protects:   Connection->Vc{Receive|Send}IrpListHead,
        Synopsis:
        Strategy:


    EVENTSEL.C

        Function:   AfdEventSelect
        Protects:   Endpoint->EventSelectStuff
        Synopsis:
        Strategy:

        Function:   AfdEnumNetworkEvents
        Protects:   Endpoint->EventSelectStuff
        Synopsis:
        Strategy:


    FASTIO.C

        Function:
        Protects:
        Synopsis:
        Strategy:


    POLL.C

        Function:
        Protects:
        Synopsis:
        Strategy:


    RECEIVE.C

        Function:
        Protects:
        Synopsis:
        Strategy:


    RECVDG.C

        Function:
        Protects:
        Synopsis:
        Strategy:


    RECVVC.C

        Function:
        Protects:
        Synopsis:
        Strategy:


    SEND.C

        Function:
        Protects:
        Synopsis:
        Strategy:


    TRANFILE.C

        Function:
        Protects:
        Synopsis:
        Strategy:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\apps\tsecimp\schema.xml ===
<?xml version="1.0"?>
<Schema 
    name="TsecSchema" 
    xmlns="urn:schemas-microsoft-com:xml-data"
    xmlns:dt="urn:schemas-microsoft-com:datatypes">

    <ElementType name="Address" content="textOnly" model="closed">
        <description>A dialable address on a line device</description>
    </ElementType>
    <ElementType name="PermanentID" content="textOnly" model="closed" dt:type="ui4">
        <description>Line device Permanent ID</description>
    </ElementType>

    <AttributeType name="Remove" default="0" required="no" dt:type="boolean">
        <description>Line device to be removed from user access</description>
    </AttributeType>

    <ElementType name="Line" content="eltOnly" model="closed">
        <description>A line device to be added to or removed from user's access</description>
        <attribute type="Remove" required="no" />
        <group minOccurs="1" maxOccurs="1" order="one">
            <element type="Address" minOccurs="1" maxOccurs="1" />
            <element type="PermanentID" minOccurs="1" maxOccurs="1" />
        </group>
    </ElementType>

    <ElementType name="LineList" content="eltOnly" model="closed">
        <description>List of line devices</description>
        <element type="Line" minOccurs="1" maxOccurs="*" />
    </ElementType>

    <ElementType name="DomainUser" content="textOnly" model="closed" dt:type="string">
        <description>Domain user account like corpdomain\jonsmith </description>
    </ElementType>
    <ElementType name="FriendlyName" content="textOnly" model="closed" dt:type="string">
        <description>User friendly name like Jon Smith</description>
    </ElementType>
    <AttributeType name="NoMerge" default="0" required="no" dt:type="boolean">
        <description>Old line devices for this user are to be removed first</description>
    </AttributeType>

    <ElementType name="User" content="eltOnly" model="closed">
        <description>A user whose line devices are to be changed</description>
        <attribute type="NoMerge" required="no" />
        <element type="DomainUser" minOccurs="1" maxOccurs="1" />
        <element type="FriendlyName" minOccurs="0" maxOccurs="1" />
        <element type="LineList" minOccurs="0" maxOccurs="1" />
    </ElementType>

    <ElementType name="UserList" content="eltOnly" model="closed">
        <description>List of users</description>
        <element type="User" minOccurs="0" maxOccurs="*" />
    </ElementType>

    <ElementType name="TsecRoot" content="eltOnly" model="closed">
        <element type="UserList" minOccurs="1" maxOccurs="1" />
    </ElementType>
</Schema>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\readme.txt ===
9/30/1998
Removed Generic Video Payload Handlers by adding the define:
NO_GENERIC_VIDEO
to files:

dxmrtp\sources
idl\sources
rph\rphgenv\sources
sph\sphgenv\sources

In order to enable them just comment out or remove that line then compile

=====================================================================

NOTE: these filters are based on ActiveMovie 2.0.  In order to build
them you must enlist in %_NTDRIVE%%_NTROOT%\private\amovie.  Then
ssync and build ~amovie\sdk\classes\base.

The script 'amovie.cmd' will do this for you.

11/4/97: The filters listed below are now included in a new dll, 
         dxmrtp.dll.

	Filters included in dxmrtp.dll:
	amrtpdmx.ax
	amrtpnet.ax
	amrtpss.ax
	mxfilter.ax
	ppm.dll
	rphaud.ax
	rphgena.ax
	rphgenv.ax
	rphh26x.ax
	sphaud.ax
	sphgena.ax
	sphgenv.ax
	sphh26x.ax
	winrtp.dll

Each filter can still be generated independently, in order to do that, 
you must modify filters\filters.mk file and set to 0 or 1 the respective
variables to control what filters get included into dxmrtp.dll and what
will become separate DLLs. 

Note that dependencies are not checked across directories, so you must 
rebuild the whole directorie(s) that change from a separate DLL to be 
included in dxmrtp.dll (or viceversa), as well as dxmrtp.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\perfdll\tapiperf.ini ===
[info]

drivername=TAPISRV
symbolfile=perfctr.h

[languages]
009=English

[text]
TAPIOBJ_009_NAME=Telephony
TAPIOBJ_009_HELP=The Telphony System

LINES_009_NAME=Number of Lines
LINES_009_HELP=The number of telephone lines serviced by this computer.

PHONES_009_NAME=Number of Telephone devices
PHONES_009_HELP=The number of telephone devices serviced by this computer.

LINESINUSE_009_NAME=Number of Active Lines
LINESINUSE_009_HELP=the number of telephone lines serviced by this computer that are currently active.

PHONESINUSE_009_NAME=Number of Active Telephones
PHONESINUSE_009_HELP=The number of telephone devices that are currently being monitored.

TOTALOUTGOINGCALLS_009_NAME=Outgoing calls/sec
TOTALOUTGOINGCALLS_009_HELP=The rate of outgoing calls made by this computer.

TOTALINCOMINGCALLS_009_NAME=Incoming calls/sec
TOTALINCOMINGCALLS_009_HELP=The rate of incoming calls answered by this computer.

CLIENTAPPS_009_NAME=Number of Client Apps
CLIENTAPPS_009_HELP=The number of applications that are currently using telephony services.

ACTIVEOUTGOINGCALLS_009_NAME=Current Outgoing Calls 
ACTIVEOUTGOINGCALLS_009_HELP=Current outgoing calls being serviced by this computer.

ACTIVEINCOMINGCALLS_009_NAME=Current Incoming Calls
ACTIVEINCOMINGCALLS_009_HELP=Current incoming calls being serviced by this computer.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\readme.txt ===
This is the Real-Time Communications source branch.

PLEASE DO NOT MAKE ANY CHANGES TO THE SOURCE LAYOUT
UNTIL I (ARLIED) APPROVE THEM.

Until we have agreed on some sensible way to arrange
this source tree, I don't want random check-ins in
this tree.

Thanks.

-- Arlie Davis (arlied)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\test3\testprof.xml ===
<provision key="amun1" name="Amun">
 <provider name="Amun" homepage="http://winrtc/phoenix">
  <data>test</data>
 </provider>
 <client name="Phoenix" banner="false"/><user uri="sip:rtctest@microsoft.com"/>
 <accesscontrol domain="ntdev.microsoft.com" sig="43r8mXTFvSMBZHajABKbd5ee1vHXUDqJIUxhsmtF67UZZryIolEdp/1qs2oiTKbKrAlAsIzOoCL75lTzZSbacA==" />
 <sipsrv addr="amun1.ntdev.microsoft.com" protocol="udp" role="registrar"/>
 <sipsrv addr="amun1.ntdev.microsoft.com" protocol="udp" role="proxy">
  <session party="first" type="pc2pc"/>
  <session party="first" type="pc2ph"/>
  <session party="first" type="im"/>
 </sipsrv>
</provision>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\core\test4\testprof.xml ===
<provision key="amun1" name="Amun">
 <user uri="sip:rtctest@microsoft.com"/>
 <accesscontrol domain="ntdev.microsoft.com" sig="43r8mXTFvSMBZHajABKbd5ee1vHXUDqJIUxhsmtF67UZZryIolEdp/1qs2oiTKbKrAlAsIzOoCL75lTzZSbacA==" />
 <sipsrv addr="amun1.ntdev.microsoft.com" protocol="udp" role="registrar"/>
 <sipsrv addr="amun1.ntdev.microsoft.com" protocol="udp" role="proxy">
  <session party="first" type="pc2pc"/>
  <session party="first" type="pc2ph"/>
  <session party="first" type="im"/>
 </sipsrv>
</provision>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\ssltest\metatel-testin.txt ===
REGISTER sip:metatel.com SIP/2.0
From: sip:arlied%40microsoft.com@metatel.com
To: sip:arlied%40microsoft.com@metatel.com
Call-ID: 1@arlied0.ntdev.microsoft.com
CSeq: 1 REGISTER
Content-Length: 0
Via: SIP/2.0/TCP 198.6.9.2:5060
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\ssltest\testin.txt ===
GET / HTTP/1.1
Accept: */*
Hostname: www.microsoft.com
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\server\tapisrv.ini ===
\registry\machine\software\microsoft\windows
\registry\machine\software\microsoft\windows\currentversion
\registry\machine\software\microsoft\windows\currentversion\Telephony
    TapisrvDebugLevel = REG_DWORD 0
    Tapi32DebugLevel = REG_DWORD 0
    KmddspDebugLevel = REG_DWORD 0
    Atsp32DebugLevel = REG_DWORD 0

\registry\machine\software\microsoft\windows\currentversion\Telephony\Providers
    NumProviders = REG_DWORD 3
    NextProviderID = REG_DWORD 4
    ProviderID0 = REG_DWORD 1
    ProviderID1 = REG_DWORD 2
    ProviderID2 = REG_DWORD 3
    ProviderFilename0 = REG_SZ kmddsp.tsp
    ProviderFilename1 = REG_SZ esp32.tsp
    ProviderFilename2 = REG_SZ atsp32.tsp

\registry\machine\software\microsoft\windows\currentversion\Telephony\Provider1
    NumLines = REG_DWORD 0
    NumPhones = REG_DWORD 0

\registry\machine\software\microsoft\windows\currentversion\Telephony\Provider2
    NumLines = REG_DWORD 0
    NumPhones = REG_DWORD 0

\registry\machine\software\microsoft\windows\currentversion\Telephony\Provider3
    NumLines = REG_DWORD 0
    NumPhones = REG_DWORD 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\ansmach\readme.txt ===
--------------------------------------------------------------------------

  Copyright (C) 1998-1999 Microsoft Corporation. All rights reserved.

--------------------------------------------------------------------------

TAPI 3.0 ANSMACH Sample Application


Overview:
~~~~~~~~~

Ansmach is a sample TAPI 3.0 application that waits for and answers
incoming phone calls. It uses the Media Streaming Terminal (MST) to
play out a recorded message and then records the caller's message to
a file.

In order to receive incoming call notifications, as well as any call
state event notifications, the outgoing ITCallNotification interface
must be implemented by the TAPI 3.0 application, and registered with
TAPI 3.0 through the IConnectionPoint mechanism.  For more information
on IConnectionPoint, and IConnectiontPointContainer, please refer
to the COM documentation.

CALLNOT.CPP and CALLNOT.H show the implementation of the ITCallNotification
interface.  ITCallNotification is defined by TAPI 3.0, and the interface
definition is in tapi3.h.

INCOMING.CPP shows how to register the interface, and how to answer
an incoming call.

TERM.CPP shows how to use the MST for reading and writing media samples.

How to build the sample:
~~~~~~~~~~~~~~~~~~~~~~~~

To run the ANSMACH sample application, set the SDK build environment, then
type "nmake" in the ansmach directory.  This will build ansmach.exe

How to use the sample:
~~~~~~~~~~~~~~~~~~~~~~

After the sample is built, run ANSMACH.EXE <mode>. Replace <mode> with
"play", "record", or "both". "play" means to play a prerecorded file
when a call is received. "record" means to record a file when a call
is received. "both" means to do both, but note that due to a limitation
of the sample code this will only work if the address supports
full-duplex streaming (this is not the case with most voice modems).

A small dialog box will appear, and the status will be "Waiting for a call."
If your computer does not have any TAPI devices, the application will display
an error as is starts up.  The application will wait for calls on all TAPI
addresses that support audio calls.

When a call arrives on one of the TAPI addresses, the application will answer
the call. It will play out a recorded message from a file (op1_16.avi),
It then records the caller's message to another file (rec.avi),
depending on the option used to start the app: play, record, or both.

What functionality does this sample show:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The incoming sample application demonstrates how to use the 
Media Streaming Terminal (MST) in the context of a TAPI call. 

What this sample does not show:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This sample does not let the user choose the TAPI address for the
application to use.  It does not allow the user to decide what media
types to listen for, and it does not allow the user to decide what
terminals to use. It doesn't use video in the call.

Hints:
~~~~~~

This sample should be able to run as long as you have TAPI devices
installed.  Many computers have a modem.  If the modem is installed 
correctly, it will show up as a TAPI device. Also, there are TAPI
devices corresponding to various IP telephony services that are
present on most systems.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\incoming\readme.txt ===
--------------------------------------------------------------------------

  Copyright (C) 1998-1999 Microsoft Corporation. All rights reserved.

--------------------------------------------------------------------------

TAPI 3.0 T3IN Sample Application


Overview:
~~~~~~~~~

T3IN is a sample TAPI 3.0 application that waits for and answers
incoming phone calls.

In order to receive incoming call notifications, as well as any call
state event notifications, the outgoing ITCallNotification interface
must be implemented by the TAPI 3.0 application, and registered with
TAPI 3.0 through the IConnectionPoint mechanism.  For more information
on IConnectionPoint, and IConnectiontPointContainer, please refer
to the COM documentation.

CALLNOT.CPP and CALLNOT.H show the implementation of the ITCallNotification
interface.  ITCallNotification is defined by TAPI 3.0, and the interface
definition is in tapi3.h.

INCOMING.CPP shows how to register the interface, and how to answer
an incoming call.

How to build the sample:
~~~~~~~~~~~~~~~~~~~~~~~~

To run the T3IN sample application, set the SDK build environment, then
type "nmake" in the incoming directory.  This will build T3IN.EXE.

How to use the sample:
~~~~~~~~~~~~~~~~~~~~~~

After the sample is built, run T3IN.EXE.

A small dialog box will appear, and the status will be "Waiting for a call."
If your computer does not have any TAPI devices, the application will display
an error as is starts up.  The application will wait for calls on all TAPI
addresses that support audio calls.  If a call comes in that has both
audio and video, the sample will also set up the video streams.

When a call arrives on one of the TAPI addresses, the "Answer" button will
be enabled, and the status message will change to "Click the Answer button".
When the "Answer" button is clicked, the application will answer
the call.

Alternatively, there is an auto-answer box that, when checked, will make the
application proceed as soon as a call is received.

What functionality does this sample show:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The incoming sample application demonstrates how to receive new call
notification and call state event notifications.  It also demonstrates
the basic TAPI 3.0 functions involved in answering a call.

What this sample does not show:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This sample does not let the user choose the TAPI address for the
application to use.  It does not allow the user to decide what media
types to listen for, and it does not allow the user to decide what
terminals to use.

Hints:
~~~~~~

This sample should be able to run as long as you have TAPI devices
installed.  Many computers have a modem.  If the modem is installed 
correctly, it will show up as a TAPI device. Also, there are TAPI
devices corresponding to various IP telephony services that are
present on most systems.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\mstsample\tapirecv\readme.txt ===
___________________________________________________

  Copyright (C) 1999 Microsoft Corporation. All rights reserved.

___________________________________________________



TAPI 3.0 TAPIRecv Media Streaming Terminal Sample Application



Overview:


The purpose of TAPIRecv sample is to illustrate the use of Media Streaming 
Terminal (MST) for retrieving audio data from a TAPI media stream.

TAPIRecv is the receiving side of the call. It accepts a call and uses the MST
to get incoming audio data, which it saves to a local audio file, 
recording.wav. When the remote side disconnects the call, the application exits.

TAPIRecv is a command line application. 

To run the sample, run TAPIRecv.exe. There are no command line arguments. When 
started, the application begins waiting for an incoming call.

The applicarion produces extensive logging to the console window. 

Note that while detailed logging is useful for observing sequence of events and 
monitoring state of the application, on a slow machine it can impair
performance to the point where it affects quality of the recorded sound.
Minimizing the console window while the application is running, or removing 
logging calls from the code will solve this problem.

The application can be terminated by pressing ctrl+break, closing the 
application's window, logging off, or shutting down the system.

Refer to the TAPISend sample for information on using the Media Streaming 
Terminal for introducing data into a TAPI media stream.



Building the Sample


To build the sample, set the Platform SDK build environment, then run nmake 
from the sample's directory. This will build TAPIRecv.exe.



Asynchronous Event Processing


The TAPIRecv performs asynchronous event processing. It subscribes to receive 
TAPI notifications by 

- registering CTAPIEventNotification (which implements 
ITTAPIEventNotification interface)
- calling ITTAPI::put_EventFilter()
- calling ITTAPI::RegisterCallNotifications for listening addresses


When TAPI has an event to be processed by the application, it calls 
ITTAPIEventNotification::Event() on the registered callback object and passes 
in event data. It is recommended that this call returns as quickly as 
possible, so our implementation of the interface does nothing more than posting
the event to worker thread (implemented by CWorkerThread) for asynchronous 
processing. 

When the worker thread receives the message, it passes it along to 
OnTapiEvent(), the event handler where all event processing is happening.



Application Flow


On startup, TAPIRecv starts listening on all addresses available that support 
audio and Media Streaming Terminal.

When the application is notified of an incoming call (by a TE_CALLNOTIFICATION 
message), the event handler verifies that there is not already an active call,
and that the application is the owner of the call. If so, we keep a pointer
to the call's ITBasicCallControl interface. From now on this is assumed to be 
the currently active call.

Once we have an active call, we are ready to receive notifications of the 
call's state (TE_CALLSTATE). If the call is in the offering state
(CS_OFFERING), before answering the call, we create a rendering Media 
Streaming Terminal and select it on one of the call's incoming audio streams.

When the audio stream becomes active (and the application receives 
CME_STREAM_ACTIVE TE_CALLMEDIA event), the event handler starts 
recording incoming audio data into a file. See "Writing Media Streaming 
Terminal Data to a file" section of this document for more details. 

Writing stream to a file is a "blocking" operation, and it does not return
until the call disconnects. Since this sample performs recording on the the
event handler's thread, messages will queued but not processed until recording
stops.

Some time after recording is completed, event handler will receive 
CS_DISCONNECTED call state event. At this time we disconnect the call and 
signal the main thread.

The main thread wakes up, performs clean up, and the application exits.



Writing Media Streaming Terminal Data to a File


Function WriteStreamToFile contains the logic for extracting audio data from 
the media streaming terminal and writing it out to a file. 

The Media Streaming Terminal has a number of samples of certain sizes 
(configured through the terminal's ITAllocatorProperties interface). 

The application repeatedly calls AllocateSample() on the terminal's 
IMediaStream interface to get the terminal's samples (AllocateStreamSamples), 
and associates each sample with an event by passing the event to the sample's 
IStreamSample::Update() (see AssociateEventsWithSamples).

An event is signaled when the corresponding sample is filled with data by the 
Media Streaming Terminal and is ready for the application to be processed 
(written to a file). A call to IStreamSample::CompletionStatus assures that the 
sample has valid data and is ready to be used. 

The sample's data (accessed via sample's IMemoryData interface, see 
WriteSampleToFile) is written to a file. 

When the application is finished with the sample, it returns the sample to the 
MST and asks it to be notified when the sample gets new portion of data for the 
application to process. This is done by calling Update() on the sample's 
IStreamSample interface and passing it the event to be signaled on completion.

At this point the applications goes back to waiting for the next sample to be 
completed.

Note that samples are aborted and IStreamSample::CompletionStatus() returns 
E_ABORT when call disconnects. TAPIRecv uses this error code as an indirect 
sign that the connection was broken and it is time to stop streaming.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\mstsample\tapisend\readme.txt ===
___________________________________________________

  Copyright (C) 1999 Microsoft Corporation. All rights reserved.

___________________________________________________



TAPI 3.0 TAPISend Media Streaming Terminal Sample Application



Overview:


The purpose of TAPISend sample is to illustrate the use of Media Streaming 
Terminal for injecting live audio data into a TAPI media stream.

TAPISend initiates a TAPI call, opens a wave file and uses Media Streaming 
Terminal (MST) to send audio data from the file to the remote machine. When
the file is processed, TAPISend disconnects the call and exits

TAPISend is a command line application. It produces extensive logging to the
console window and can be terminated by pressing ctrl+break or closing the 
application's windows. 

To run the sample, start TAPIRecv.exe and specify the name of the file to be
sent, destination address, and address type as command line arguments:

TAPISend <file_name> <destination_address> <address_type>

The following address types are allowed (the application is not
case-insensitive): PHONENUMBER, CONFERENCE, EMAIL, MACHINE, and IP.

Usage examples:

TAPISend sound.wav 212-121-1212 phonenumber
TAPISend music.wav MYMACHINE machine
TAPISend recording.wav 127.0.0.1 IP

If the application is started with the number of arguments other than three, it
displays usage information.

For information on using Media Streaming Terminal to extract data from a TAPI
stream, refer to the TAPIRecv sample.



Building the Sample


To build the sample, set the Platform SDK build environment, then run nmake 
from the sample's directory. This will build TAPISend.exe.



Application Flow


The application attempts to make a TAPI call to the destination specified in
the command line. 

Note that for simplicity TAPISend does not do TAPI message processing (it 
does not create and register with TAPI an object implementing 
ITTAPIEventNotification). All processing is done on a single thread. Please 
check documentation, TAPIRecv and other samples for more information on TAPI 
event notification processing.

When the call is connected, TAPISend creates an MST for capture. (The word 
"capture" is used in DirectShow sense, and indicates the fact that MST 
"captures" application's data to be introduced into TAPI data stream. See 
function CreateCaptureMediaStreamingTerminal.)

Once a terminal is constructed, the application opens the input file (see 
CAVIFileReader class for details on media file handling) to get the format 
of the audio stream that we are about to start sending.

The data format is then communicated to the terminal by calling 
ITAMMediaFormat::put_MediaFormat(). A failure to set format on the terminal 
may mean that the underlying MSP used for the call requires a specific wave 
format (as is the case with H323 MSP which requires 16-bit mono 8000 samples 
per second PCM data).

TAPISend uses terminal's ITAllocatorProperties interface to suggest allocator 
properties for the terminal (number and size of data buffers). If the 
application chooses to configure allocator properties, it needs to do this 
before the call is connected and terminal is selected.

The default behavior (and the behavior shown in the sample) is to have MST 
allocate buffers for the data.

The application, however, can do its own memory allocation. In this case the 
application needs to call ITAllocatorProperties::SetAllocateBuffers(FALSE). 
Later, during sample processing, the application would instruct MST's samples 
to use application-allocated buffers by calling IMemoryData::SetBuffer on MST 
samples.

Once audio format is configured and allocator properties are suggested, the 
application selects the terminal on the call's first outgoing audio stream. 

Reading the samples from the file and submitting them to the MST is done in 
ReadFileIntoTerminal.

In a loop, until connection breaks, or exit is requested, we use terminal's
IMediaStream interface to "allocate" samples on the terminal 
(a call to IMediaStream::AllocateSample, which, in effect returns us a pointer
 o IStreamSample interface of a sample. The terminal has a limited number of 
samples. This number can be set and verified via the terminal's 
ITAllocatorProperties interface.

If the application gets ahead of the terminal and all samples have been filled 
with data and submitted to MST but not yet processed, the call to 
AllocateSample will block until the MST completes processing of at least one 
sample and the processed sample becomes available to the application to be 
refilled.

We use the sample's IMemoryData interface to get to its buffer, which is filled
with audio data from the file by AVI file reader. After the data is copied to 
the sample's buffer, the application "returns" the sample to the MST by calling
Update() on its the sample's IStreamSample interface. This tells the Media 
Streaming Terminal that the sample is ready for processing (injecting into 
TAPI media stream and sending to the destination).

Note that if Update() is called while the stream is not yet active, it returns
the VFW_E_NOT_COMMITTED error code. Since TAPISend does not process events, 
and therefore not notified of when the stream is started, the application 
uses this error code as a sign that the stream is not yet active, and keeps
retrying until Update() succeeds. Again, the recommended procedure is to wait
for CME_STREAM_ACTIVE call media event before starting sending samples to 
the MST.

To keep track of samples that we have submitted, we also put the sample into 
a list. This will allow us to insure that, when the whole file is submitted, 
we don't terminate the call until all samples are completely processed by the
MST. This is achieved by calling method IStreamSample::CompletionStatus() on 
all the samples submitted during file read.

Note that the list of samples will have duplicate samples. The correctness of 
the application does not suffer, but the performance does, and this should be 
addressed in a real-life application (by making sure the list only has unique 
entries, for instance).

When all samples are submitted, or the user requested exit, we disconnect the 
call, uninitialize TAPI, and exit. Note that since we don't process events we 
don't know when the receiving side received all the samples we submitted. So 
we wait several seconds before disconnecting the call.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\outgoing\readme.txt ===
--------------------------------------------------------------------------

  Copyright (C) 1998-1999 Microsoft Corporation. All rights reserved.

--------------------------------------------------------------------------

TAPI 3.0 T3OUT Sample Application


Overview:
~~~~~~~~~

T3OUT is a sample TAPI 3.0 application that makes outgoing phone
calls.

This sample shows the most basic TAPI 3.0 functionality - finding an
appropriate address object and creating a call on it.

How to use:
~~~~~~~~~~~

To run the T3OUT sample application, set the SDK build environment, then
type "nmake" in the outgoing directory.  This will build T3OUT.EXE.

How to use the sample:
~~~~~~~~~~~~~~~~~~~~~~

After the sample is built, run T3OUT.EXE.

A small dialog box will appear.  The user can type in a destination address
and choose the address type of the destination address.  TAPI 3.0 currently
supports the following address types:

    Conference Name
    Email Name
    Machine Name
    Phone Number
    IP Address

Microsoft's H.323 Service Provider currently supports the Machine Name
and IP Address address types. Many other TAPI Service Providers support
the Phone Number address type

When the user types in a destination address, chooses an address type,
and presses the "Dial" button, the application will find a TAPI address
that support the address type selected, as well as the audio media type.
Then it will make a call on that address.

If the address also supports video, and the machine has video
capabilities, the application will also set up a video stream.

What functionality does this sample show:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The T3OUT sample application shows how to make a phone call with TAPI 3.0.

What this sample does not show:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This sample is extremely simple.  It does not allow the user to select
the address or terminals that the user is interested in.  It does not
see call state messages, and does not listen for incoming calls. It does
not use the rendezvous control functions necessary to fully support the
Email Name and Conference Name address types on H.323 and IPConf addresses.
 
Hints:
~~~~~~

This sample should be able to run as long as you have TAPI devices
installed.  Many computers have a modem.  If the modem is installed 
correctly, it will show up as a TAPI device. Also, there are TAPI
devices corresponding to various IP telephony services that are present
on most systems (these are referred to as H.323 and IPConf).
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\cctest.log ===
Intel RMC Call Control Test Harness
              Version X0.4 (Experimental)
              Intel Corporation Copyright 1996
              
17:50:13  OS Version = Microsoft Windows NT 3.51
17:50:13  Run Date: 04/16/1996
17:50:16  q931 Init

17:50:21  q931 Listen status = 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\doc\microsoft tapi video decoder filter.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Don Ryan Microsoft Corporation Microsoft  TAPI  Video Decoder Filter Title _PID_GUID _PID_HLINKSMicrosoft  TAPI  Video Decoder Filter Streams and Interfaces Philippe Ferriere, Michael VanBuskirk NetMeeting Specification.dot Philippe Ferriere Microsoft Word 8.0IDATx @&Ep  Tup:E* X06og TfEwc n?,4.[@b kj4"pv  m$kNu w~=8\3 9)?y9 zti=h sP`(bc1@'Dp 8{$}9 V?o8R lpYQ& >8ocu <p8k` p4]%9 7)iV5 h*f!> 8de'O fUnpf yzJL/ ~IDAT B_Aow* `}+f6\\PHILF\SPECS\MICROS~1.DOC Entire Network At-act Microsoft Network \\Philf \\Philf\specs Microsoft TAPI Video Encoder Filter.doc MICROS~1.DOC r.doc \\PHILF\SPECS Microsoft TAPI Video Encoder Filter.doc\\PHILF\SPECS\MICROSOFT TAPI VIDEO ENCODER FILTER.DOC TITLE  \* MERGEFORMAT  Microsoft  TAPI  Video Decoder Filter  SUBJECT  \* MERGEFORMAT  Streams and Interfaces Design Specification   Draft Author:   AUTHOR  \* MERGEFORMAT  Philippe Ferriere, Michael VanBuskirk Revision 0.4.134,   SAVEDATE \@ "d MMMM, yyyy" \* MERGEFORMAT  26 June, 1999 This documentation is an early release of the final product documentation. It is meant to accompany software that is still in development. Some of the information in this documentation may be inaccurate or may not be an accurate representation of the functionality of the final retail product. Microsoft assumes no responsibility for any damages that might occur either directly or indirectly from these inaccuracies.  TOC \o "1-4"  Introduction  PAGEREF _Toc455061646 \h  Intended audience  PAGEREF _Toc455061647 \h  Conventions  PAGEREF _Toc455061648 \h  Document organization  PAGEREF _Toc455061649 \h  Definition of terms  PAGEREF _Toc455061650 \h  TAPI incoming video architecture  PAGEREF _Toc455061651 \h  TAPI 3.0 overview  PAGEREF _Toc455061652 \h  Call and media controls  PAGEREF _Toc455061653 \h  3.2.1 TAPI 3.0 COM object  PAGEREF _Toc455061654 \h  3.2.2 TAPI server  PAGEREF _Toc455061655 \h  3.2.3 Call control functions  PAGEREF _Toc455061656 \h  3.2.4 Media control functions  PAGEREF _Toc455061657 \h  Incoming video filter graph  PAGEREF _Toc455061658 \h  Video decoder filter streams  PAGEREF _Toc455061659 \h  Video decoder filter RTP packetized input stream  PAGEREF _Toc455061660 \h  Video decoder filter video output stream  PAGEREF _Toc455061661 \h  Video decoder filter stream formats  PAGEREF _Toc455061662 \h  Media type for RTP-packetized H.26x compressed video and still-image input streams  PAGEREF _Toc455061663 \h  Video info header structure for RTP-packetized H.263 video streams  PAGEREF _Toc455061664 \h  Video info header structure for RTP-packetized H.261 video streams  PAGEREF _Toc455061665 \h  Bitmap info header structure for RTP-packetized H.263 video streams  PAGEREF _Toc455061666 \h  Bitmap info header structure for RTP-packetized H.261 video streams  PAGEREF _Toc455061667 \h  RTP-packetized data format  PAGEREF _Toc455061668 \h  H.245 command outgoing interface  PAGEREF _Toc455061669 \h  IVideoChannelControl interface  PAGEREF _Toc455061670 \h  VideoFastUpdatePicture method  PAGEREF _Toc455061671 \h  VideoFastUpdateGOB method  PAGEREF _Toc455061672 \h  VideoFastUpdateMB method  PAGEREF _Toc455061673 \h  videoSendSyncEveryGOB and videoSendSyncEveryGOBCancel commands  PAGEREF _Toc455061674 \h  VideoNotDecodedMBs method  PAGEREF _Toc455061675 \h  Uncompressed video output pin TAPI interfaces  PAGEREF _Toc455061676 \h  IH245DecoderCommand interface  PAGEREF _Toc455061677 \h  7.1.1 videoFreezePicture method  PAGEREF _Toc455061678 \h  7.1.2 Other picture freeze and release requests  PAGEREF _Toc455061679 \h  ICPUControl interface  PAGEREF _Toc455061680 \h  7.2.1 SetMaxProcessingTime method  PAGEREF _Toc455061681 \h  7.2.2 GetMaxProcessingTime method  PAGEREF _Toc455061682 \h  7.2.3 SetMaxCPULoad method  PAGEREF _Toc455061683 \h  7.2.4 GetMaxCPULoad method  PAGEREF _Toc455061684 \h  IFrameRateControl interface  PAGEREF _Toc455061685 \h  7.3.1 SetMaxFrameRate method  PAGEREF _Toc455061686 \h  7.3.2 GetMaxFrameRate method  PAGEREF _Toc455061687 \h  Uncompressed still-image output pin TAPI interfaces  PAGEREF _Toc455061688 \h  IH245DecoderCommand interface  PAGEREF _Toc455061689 \h  ICPUControl interface  PAGEREF _Toc455061690 \h  RTP-packetized compressed video input pin TAPI interfaces  PAGEREF _Toc455061691 \h  IBitrateControl interface  PAGEREF _Toc455061692 \h  9.1.1 SetMaxBitrate method  PAGEREF _Toc455061693 \h  9.1.2 GetMaxBitrate method  PAGEREF _Toc455061694 \h  IFrameRateControl interface  PAGEREF _Toc455061695 \h  Video decoder filter application interfaces  PAGEREF _Toc455061696 \h  IAMVideoProcAmp interface  PAGEREF _Toc455061697 \h  10.1.1 VideoProcAmpProperty enumerated data type  PAGEREF _Toc455061698 \h  10.1.2 VideoProcAmpFlags enumerated data type  PAGEREF _Toc455061699 \h  10.1.3 GetRange method  PAGEREF _Toc455061700 \h  10.1.4 Set method  PAGEREF _Toc455061701 \h  10.1.5 Get method  PAGEREF _Toc455061702 \h  IAMCameraControl interface  PAGEREF _Toc455061703 \h  10.2.1 CameraControlProperty enumerated data type  PAGEREF _Toc455061704 \h  10.2.2 CameraControlFlags enumerated data type  PAGEREF _Toc455061705 \h  10.2.3 GetRange method  PAGEREF _Toc455061706 \h  10.2.4 Set method  PAGEREF _Toc455061707 \h  10.2.5 Get method  PAGEREF _Toc455061708 \h  IAMVideoControl interface  PAGEREF _Toc455061709 \h  10.3.1 VideoControlFlags enumerated data type  PAGEREF _Toc455061710 \h  10.3.2 GetCaps method  PAGEREF _Toc455061711 \h  10.3.3 SetMode method  PAGEREF _Toc455061712 \h  10.3.4 GetMode method  PAGEREF _Toc455061713 \h  Video decoder filter H.245 video capabilities  PAGEREF _Toc455061714 \h  Standard Codec addition or replacement  PAGEREF _Toc455061715 \h  Non-standard codec support  PAGEREF _Toc455061716 \h  11.2.1 Interpretation facilities provided by the installed codec filter  PAGEREF _Toc455061717 \h  11.2.2 Capability resolution/channel open mechanism  PAGEREF _Toc455061718 \h  IH245VideoCapability interface  PAGEREF _Toc455061719 \h  11.3.1 NegotiatedVideoLimit enumerated data type  PAGEREF _Toc455061720 \h  11.3.2 VideoResourceBounds structure  PAGEREF _Toc455061721 \h  11.3.3 H245VideoCapabilityMap structure  PAGEREF _Toc455061722 \h  11.3.4 H245VideoCapabilityTable structure  PAGEREF _Toc455061723 \h  11.3.5 GetH245VersionID method  PAGEREF _Toc455061724 \h  11.3.6 GetFormatTable method  PAGEREF _Toc455061725 \h  11.3.7 ReleaseFormatTable method  PAGEREF _Toc455061726 \h  11.3.8 IntersectFormats method  PAGEREF _Toc455061727 \h  11.3.9 GetLocalFormat method  PAGEREF _Toc455061728 \h  11.3.10 GetNegotiatedLimitProperty method  PAGEREF _Toc455061729 \h  11.3.11 ReleaseNegotiatedCapability method  PAGEREF _Toc455061730 \h  11.3.12 SetIDBase method  PAGEREF _Toc455061731 \h  11.3.13 FindIDByRange method  PAGEREF _Toc455061732 \h  References  PAGEREF _Toc455061733 \h  TAPI 3.1 Specifications  PAGEREF _Toc455061734 \h  DirectShow SDK articles and documentation  PAGEREF _Toc455061735 \h  ITU communications standards  PAGEREF _Toc455061736 \h  IETF Request for comments  PAGEREF _Toc455061737 \h  Introduction H.26x video decoders differ from traditional Microsoft  Windows  desktop video codecs: They operate over unreliable communication channels using RTP/UDP/IP (H.323) They usually have many modes of operation (H.263 options) They may need to handle or generate call control specific (H.245) commands They may implement different decoding algorithms in order to adapt their CPU usage Like over desktop video decoders, they need to operate in real-time. In order to support all of the above features in the Microsoft  TAPI  environment, this document describes video decoder implementation requirements. The TAPI incoming video stack relies on video decoders to expose RTP-packetized compressed video and still-image input pins, and uncompressed video output pins using the DirectShow model. The video decoder shall present its input pins to the network source filter and be able to reassemble and decompress raw RTP packets, to deliver uncompressed video frames to the downstream render filter(s). We define a new H.245 command interface to communicate picture freeze requests to the compressed video output pin of a video decoder filter. We also define an H.245 command outgoing interface to allow the video input pin of a video decoder to issue H.245 commands such as requests for I-frame, group of blocks, or macro-block updates due to packet loss. We describe extended bitmap info headers for H.261 and H.263 video streams to retrieve from the compressed video input pin a list of optional mode of compressions supported by the decoder. Video decoders may also expose interfaces to allow users to control video quality settings such as brightness, contrast, hue, saturation, gamma and sharpness, provided that the video decoder is capable of applying the necessary post-processing operators. They may also expose an interface to simulate camera control functionality such as pan, tilt and zoom. Video decoders shall be able to control their decompressed output pin to reach target frame rate values provided dynamically by other streaming TAPI components. Those frame rates may be lower or higher than the frame rate at which video frames are coming from the network. The video decoder shall be able to handle those upsampling or downsampling operations while streaming, without stopping the streams. Video decoders should also try and control their CPU usage to decode a video frame within bounds (decoding time, and CPU load) provided by other monitoring TAPI components. Finally, video decoders shall implement a new H.245 capability interface. This interface provides the TAPI TSP/MSP call control components with information needed to resolve capabilities, and in the case of non-standard codecs, with facilities to interpret non-standard capability data. Intended audience The reader should have a good understanding of the DirectShow model and its operation, as well as ITU-T standards H.245, H.261 and H.263. Conventions In this document the following conventions are used: "Shall" indicates a mandatory requirement, "Should" indicates a suggested but optional course of action, "May" indicates an optional course of action rather than a recommendation that something take place. References to Sections, Paragraphs, Annexes, and Appendices refer to those items within this specification unless another document is explicitly listed. Document organization Section   REF _Ref420292803 \r \h   of this document defines the terms used in this video decoder filter specification. Section   REF _Ref420293040 \r \h   provides background information on the TAPI MSP and its graph building operation. Section   REF _Ref433872348 \r \h   discusses the streams used and produced by the video decoder filter. Section   REF _Ref420293435 \r \h   describes the format structures used to describe the streams handled by the video decoder filter. Section   REF _Ref422391459 \r \h   introduces an H.245 command outgoing interface and the mechanism used to allow the RTP-packetized input pin of the decoder filter to use this interface. Sections   REF _Ref433872438 \r \h   and   REF _Ref433872538 \r \h   detail the H.245 command incoming interface (section   REF _Ref433872453 \r \h  ), as wells as CPU control (section   REF _Ref433872474 \r \h  ), and frame rate control (section   REF _Ref431542280 \r \h  ) interfaces exposed by the uncompressed output pins of the video decoder filter. Section   REF _Ref434060270 \r \h   presents the interfaces exposed by the RTP-packetized compressed video input pin of the video decoder filter to retrieve information on the bitrate (section   REF _Ref434060386 \r \h  ) and frame rate (section   REF _Ref434060396 \r \h  ) of the incoming video data. Section   REF _Ref434060256 \r \h   presents the interfaces exposed by the video decoder filter to set video quality settings (section   REF _Ref427959429 \r \h  ) and simulated camera control capabilities (sections   REF _Ref429653644 \r \h   and   REF _Ref429653646 \r \h  Section   REF _Ref432249242 \r \h   describes the H.245 video capability interface exposed by the video decoder filter to enumerate, translate and compare video formats. Definition of terms Codec: Coder/Decoder. A filter for data that manipulates it in some form, usually by compressing or decompressing the data stream. Component Object Model (COM): The OLE object-oriented programming model that defines how objects interact within a single process or between processes. In COM, clients have access to an object through interfaces implemented on the object. See also Interface. COM Object: An object that conforms to the OLE Component Object Model (COM). A COM object is an instance of an object definition, which specifies the object's data and one or more implementations of interfaces on the object. Clients interact with a COM object only through its interfaces. See also Component Object Model and Interface. Decoder Filter: A specialized type of transform filter. Decoder filters (decompressors) accept compressed data, use a decompression algorithm to transform the data, and pass the uncompressed data dow  next filter in line to receive data from an upstream filter. An upstream filter sends data from its output pin to the connected input pin of the downstream filter. Encoder Filter: A specialized type of transform filter. Encoder filters (compressors) accept data, use a compression scheme to transform the data, and pass the compressed data downstream. Filter: A key component in the DirectShow architecture, a filter is a COM object that supports DirectShow interfaces or base classes. It might operate on streams of data in a variety of ways, such as reading, copying, modifying, or writing the data to a file. Sources, transform filters, and renderers are all particular types of filters. A filter contains pins that it uses to connect to other filters. Filter Graph: A collection of filters. Typically, a filter graph contains filters that are connected to perform a particular operation, such as playing back a media file, or capturing video from a VCR to the hard disk. Format Type: A GUID value that indicates what a format block contains. DirectShow defines a number of major types, for example, the video type. These major types have a format block, such as VIDEOINFOHEADER, that describes the media data. The format block for a particular media type is specified by a GUID in the AM_MEDIA_TYPE structure. This GUID is called the format type. If the format block contains VIDEOINFOHEADER, the format type GUID will be FORMAT_VideoInfo. GOB: Group-Of-Blocks. In H.263, a GOB consists of a row of k*16 lines with k=1 for sub-QCIF, QCIF and CIF, k=2 for 4CIF and k=4 for 16CIF; thus there are 6GOBs for sub-QCIF, 9 for QCIF, and 18 for CIF, 4CIF, and 16CIF. Data for each GOB consists of a GOB header (which may be empty) followed by data for each of the macroblocks (MBs) contained in a GOB. GUID: A globally unique identifier used to uniquely identify objects, such as interfaces and plug-in distributors. Class identifiers (CLSIDs) and interface identifiers (IIDs) are GUIDs. H.245: ITU Recommendation H.245. This Recommendation specifies syntax and semantics of terminal information messages as well as procedures to use them for in-band negotiation at the start of or during communication. The messages cover receiving and transmitting capabilities as well as mode preference from the receiving end, logical channel signaling, and Control & Indication. Acknowledged signaling procedures are specified to ensure reliable audiovisual and data communication. H.261: ITU Recommendation H.261. This Recommendation describes the video coding and decoding methods for the moving picture component of audiovisual services at the rates of px64 kbit/s, where p is in the range 1 to 30. H.263: ITU Recommendation H.263. This Recommendation specifies a coded representation that can be used for compressing the moving picture component of audio-visual services at low bit rates. The basic configuration of the video source coding algorithm is based on Recommendation H.261 and is a hybrid of inter-picture prediction to utilize temporal redundancy and transform coding of the remaining signal to reduce spatial redundancy. The source coder can operate on five standardized video source formats. The decoder has motion compensation capability, allowing optional incorporation of this technique in the coder. Half pixel precision is used for the motion compensation, as opposed to Recommendation H.261 where full pixel precision and a loopfilter are used. Variable length coding is used for the symbols to be transmitted. In addition to the basic video source coding algorithm, negotiable coding options are included for improved compression performance and the support of additional capabilities. Additional supplemental information may also be included in the bitstream for enhanced display capability and for external usage. In-Process Server: A server implemented as a DLL that runs in the process space of the client. See also Out-of-process server, Local server, and Remote server. Input Pin: A pin that accepts data into the filter. Interface: A group of semantically related functions that provide access to a COM object. Each OLE interface defines a contract that allows objects to interact according to the Component Object Model (COM). See also Component Object Model and COM object. ITU: International Telecommunication Union. Keyframe: A frame of video data that contains all the data necessary to construct that frame. In contrast, delta frames contain data relating to changes from the last keyframe and do not contain enough information by themselves to construct a complete frame. Major Type: A GUID value that describes the overall class of media data for a data stream. Typical values are MEDIATYPE_Video, MEDIATYPE_Audio, MEDIATYPE_Text, and MEDIATYPE_Midi. MB: Macroblock. In H.263, like in MPEG1-2, it consists of a 16x16 block of Y, and corresponding 8x8 blocks of each of the two chrominance components. Method: A predefined interface function. Minor Type: See subtype (media type). MSP: Media Service Provider. A component in TAPI that handles media streams. Out-Of-Process Server: A server, implemented as an .EXE application, which runs outside the process of its client, either on the same machine or a remote machine. See also Local server and Remote server. Output Pin: A pin that provides data to other filters. Payload Data: The data transported by RTP in a packet for example compressed video data. Payload Header: For H.263 and H.261 RTP packets, the RTP fixed header is followed by the payload header, itself followed by the payload data. Pin: A COM object created by the filter that represents a point of connection for a data stream on the filter. Pins provide interfaces to connect with other pins and transport data. Input pins accept data into the filter, and output pins provide data to other filters. An input pin typically exposes the IPin and IMemInputPin interfaces. An output pin typically exposes the IPin, IMediaSeeking, and IQualityControl interfaces. A source filter provides one output pin for each stream of data in the file. A typical transform filter, such as a compression/decompression (codec) filter, provides one input pin and one output pin. Presentation Time: The stream time at which the packets of data that a filter receives should be presented downstream or rendered. When a filter graph runs, each filter is passed a start time according to the reference clock, and the packets of data that a filter receives will usually be time-stamped with the presentation time. Renderer: A filter that renders media data to any location that accepts media input. Most often, data is rendered to a computer monitor, sound card, or printer. Renderer filters have only input pins. Remote Server: A server application, implemented as an EXE, running on a different machine from the client application using it. See also In-process server, Local server, and Out-of-process server. RTP: Real-Time Transport Protocol. RTP provides end-to-end network transport functions suitable for applications transmitting real-time data, such as audio, video or simulation data, over multicast or unicast network services. Source Filter: A filter that takes data from some source such as the hard drive, network, or the Internet, and introduces it into the filter graph. Stream: A stream is identical to a DirectShow pin. A stream can accept data from or supply data to the processor, such as a stream representing an H.263 input, or can simply route data through hardware, such as a stream representing an NTSC output jack on the back of an adapter. Subtype (media type): A GUID value that describes the specific format of media data for a data stream. Typical values include MEDIASUBTYPE_MJPG, MEDIASUBTYPE_RGB8, MEDIASUBTYPE_RGB565, MEDIASUBTYPE_MPEGPacket, MEDIASUBTYPE_Avi, and MEDIASUBTYPE_WAVE. TAPI: Telephony API. TAPI is a set of APIs that enable applications to make PSTN and IP phone calls. Time Stamp: Time on a media sample indicating when it was recorded and when it should be scheduled for playback. Time stamps are measured in 100-nanosecond units (REFERENCE_TIME) and are normalized so that zero indicates when the graph is run. Transform Filter: A filter that takes data, processes it, and then passes it along to the next filter in the filter graph. Transform-Inplace Filter: A transform filter that can perform its operation in place (without copying data or altering the data's media type). Transport: The mechanism that channels audio data, video data, or both from an external device to the computer and from the computer to the external device. Upstream Filter: The filter that passes data from its output pin to the connected input pin of the next filter in the filter graph. TAPI incoming video architecture This section provides an overview of TAPI s video receive, decoding and rendering data path under the Windows 98 and Windows NT 5.0 operating systems. TAPI 3.0 overview TAPI version 3.0 is a set of COM-based APIs providing convergence of both traditional telephony and IP (Internet Protocol) Telephony.  IP Telephony enables voice, data and video collaboration over existing LANs, WANs and the Internet. TAPI 3.0 implements IP Telephony on the Windows platforms by providing simple and generic methods for making connections between two or more machines. TAPI 3.0 supports standards-based H.323 conferencing and IP Multicast conferencing, utilizing the Windows NT 5.0 Active Directory service to simplify deployment within an organization. Quality-of-service (QoS) support is included to improve conference quality and network manageability. Media stream access is provided through DirectShow filters. TAPI 3.0 PSTN and IP functionality is provided by three main sections: call and media controls, media stream controls, and directory controls. The following diagram illustrates how these controls interact with the telephone and IP networks. Call and media controls Call and media controls are a simple and generic set of methods for making calls between two or more machines. In the context of TAPI 3.0, the word call refers not just to voice transmission over the public switched telephone network (PSTN) but to any medium capable of transferring content.  TAPI 3.0 provides access to the media being transmitted through the use of DirectShow.  TAPI 3.0 abstracts both call and media functionality to allow different, and seemingly incompatible, communication protocols to expose a common interface to applications. Because TAPI 3.0 is based on the Component Object Model (COM), applications may be written in any language. Some interface methods may not be available to scripting languages such as VBScript. TAPI 3.0 call and media controls involve four primary sets of code: the TAPI 3.0 COM objects, the TAPI Server, Telephony Service Providers (TSPs), and Media Service Providers (MSPs). TAPI 3.0 COM object For background information on TAPI 3.0 COM objects, see the article titled Telephony Application Programming Interface, in the Platform SDK Documentation. TAPI server TAPI 3.0 is implemented as an in-process server and uses TAPISRV.EXE to perform telephony operations, thus making TAPI 3.0 applications compatible with all TAPI 2.1 service providers. The TAPI Server process (TAPISRV.EXE) abstracts TSPI (Telephony Service Provider Interface) from TAPI 3.0 and TAPI 2.1 and maintains the internal state of TAPI. Additional information concerning the TAPI Server and TSPI can be found in the article titled Telephony Application Programming Interface, in the Platform SDK Documentation. Call control functions Call-control functions are provided by a TSP. The TAPI 2.1 client/server relationship with remote service providers is supported. Telephony Service Providers are responsible for translating the protocol-independent call model of TAPI into protocol-specific call setup and teardown, on a service-by-service basis. TAPI 3.0 has backward compatibility with TAPI 2.1 TSPs. Two new IP Telephony Service Providers (and their associated Media Service Providers) ship by default with TAPI 3.0: the H.323 TSP and the IP Multicast Conferencing TSP.  Additional information concerning Telephony Service Providers can be found in the article titled Telephony Application Programming Interface, in the Platform SDK Documentation. Media control functions Media control functions are provided by an MSP that implements the DirectShow interfaces for a particular provider. Media Service Providers are required for any telephony service that makes use of DirectShow media streaming.  Incoming video filter graph The following illustration shows what DirectShow filters the MSP typically connects in a filter graph to provide the incoming video functionality, and the interfaces the MSP Video Decoder Filter and its output pin expose to the MSP in order to provide the control functionality described in the next sections: The H.245 command outgoing interface exposed by the TAPI MSP Channel Controller module, and the mechanisms used to allow the RTP-packetized compressed input pins to use it are detailed in section   REF _Ref422391459 \r \h  . The uncompressed video and still-image output pin interfaces are described in sections   REF _Ref433872769 \r \h   and   REF _Ref433872778 \r \h  . The RTP-packetized compressed video input pin interfaces are discussed in section   REF _Ref434059941 \r \h  . The video decoder filter interfaces are explained in section   REF _Ref434059956 \r \h  . The H.245 video capability interface is presented in section   REF _Ref432249242 \r \h  Video decoder filter streams Fundamentally, a video decoder filter designed to be used by the TAPI MSP, provides one type of output streams, and takes in one kind of input stream. An input stream contains RTP-packetized compressed video or still-image data. An output stream generates uncompressed video data or uncompressed still-image data. Video decoder filter RTP packetized input stream The data gathered from the output pin of the network sink filter is typically composed of multiple RTP packets (H.323). The video decoder filter shall reassemble those RTP packets and extract the relevant video data. If packets are missing (non-continuous RTP sequence number), the video codec is free to use any error recovering technique, or issue the appropriate update request, via an H.245 command, to compensate for the loss. The RTP-packetized compressed video input pin of the video decoder filter can be used to receive either video data or high-resolution still images using H.245 s progressive refinement mode. Optionally, the video decoder may expose a dedicated input pin used to collect RTP-packetized still-image data, in order to render high-resolution snapshots in a separate video window. The RTP-packetized compressed video and still-image input streams are almost identical in terms of data formats and stream characteristics. Both provide RTP packetized compressed digital image data. Video decoder filter video output stream The video decoder exposes a video output pin to be connected to a render sink filter. This output pin shall provide video data in uncompressed form, such as RGB8 or RGB16. It may also generate data in a DirectDraw friendly YUV packed format such as YUY2 or UYVY. The video output pin can be used to render video or progressive still-image data. Optionally, the video decoder may expose a dedicated still-image output pin. This pin will be connected to an other instance of the video render filter, allowing snapshots to be displayed in a separate window. The uncompressed video and still-image output streams are identical in terms of data formats and stream characteristics. Both provide uncompressed digital image data that can be efficiently rendered. Video decoder filter stream formats Stream types are described in DirectShow using the AM_MEDIA_TYPE structure. This structure includes GUID fields for majortype, subtype and formattype as well as fields specifying other sample features. It is defined as follows: typedef struct  _MediaType     GUID      majortype;     GUID      subtype;     BOOL      bFixedSizeSamples;     BOOL      bTemporalCompression;     ULONG     lSampleSize;     GUID      formattype;     IUnknown  *pUnk;     ULONG     cbFormat;     /* [size_is] */ BYTE __RPC_FAR *pbFormat; } AM_MEDIA_TYPE; The following describes the AM_MEDIA_TYPE members. majortype  Specifies the major type of the stream.  subtype  Specifies the subtype of the stream.  bFixedSizeSamples  Specifies that all the samples are the same size if set to TRUE. bTemporalCompression  Specifies that each sample is a synchronization point (keyframe) if set to FALSE. lSampleSize  Specifies the maximum size of the samples in bytes.  formattype  Specifies the format type of the stream.  pUnk  Specifies a pointer to the IUnknown interface. cbFormat  Specifies the size of the format section of the media type.  pbFormat  Specifies a pointer to the format section of the media type. Media type for RTP-packetized H.26x compressed video and still-image input streams For RTP-packetized H.26x compressed video and still-image streams, the majortype type is MEDIATYPE_Video, and the formattype is set to FORMAT_VideoInfo. The subtype, along with the Format block, is used to convey details of the particular video data type.  The low-order four bytes of the subtype shall match the FourCC values used in the BITMAPINFOHEADER.biCompression field of the VIDEOINFOHEADER structure pointed to by the pbFormat field. For example, the following GUID identifies the FourCC (R263) for the RTP-packetized H.263 video format: 33363252-0000-0010-8000-00AA00389B71       52 = 'R'     32 = '2'   36 = '6' 33 = '3' s a complete list of ITU formats currently supported by TAPI and their associated subtype: Video Format FourCC ITU H.263 version 1 33363252-0000-0010-8000-00AA00389B71 ITU H.263 version 2 33363253-0000-0010-8000-00AA00389B71 ITU H.261 31363252-0000-0010-8000-00AA00389B71 For all RTP-packetized H.26x compressed video streams, the bFixedSizeSamples and bTemporalCompression fields shall respectively be set to FALSE and TRUE. Video info header structure for RTP-packetized H.263 video streams TAPI defines the VIDEOINFOHEADER_H263 structure to specify details of the video stream. The pbFormat field of the AM_MEDIA_TYPE structure shall point to a structure of the VIDEOINFOHEADER_H263 type, instead of a regular VIDEOINFOHEADER structure, when describing RTP-packetized H.263 video streams. Note that it is similar to the VIDEOINFOHEADER structure: typedef struct tagVIDEOINFOHEADER_H263 {    RECT                   rcSource;    RECT                   rcTarget;    DWORD                  dwBitRate;    DWORD                  dwBitErrorRate;    REFERENCE_TIME         AvgTimePerFrame;    BITMAPINFOHEADER_H263  bmiHeader; } VIDEOINFOHEADER_H263, *PVIDEOINFOHEADER_H263; where rcSource  Specifies a RECT structure that defines the source video window.  rcTarget  Specifies a RECT structure that defines the destination video window.  dwBitRate  Specifies a DWORD value that indicates the video stream's approximate data rate, in bits per second.  dwBitErrorRate  Specifies a DWORD value that indicates the video stream's data error rate, in bit errors per second.  AvgTimePerFrame  Specifies a REFERENCE TIME value that indicates the video frame's average display time, in 100-nanosecond units.  bmiHeader  Specifies a BITMAPINFOHEADER_H263 structure that contains detailed format information for the RTP-packetized H.263 video data.  Video info header structure for RTP-packetized H.261 video streams TAPI also defines the VIDEOINFOHEADER_H261 structure to specify details of an RTP-packetized H.261 video stream. The pbFormat field of the AM_MEDIA_TYPE structure shall point to a structure of the VIDEOINFOHEADER_H261 type, instead of a regular VIDEOINFOHEADER structure, when describing RTP-packetized H.261 video streams. Note that it is similar to the VIDEOINFOHEADER structure: typedef struct tagVIDEOINFOHEADER_H261 {    RECT                   rcSource;    RECT                   rcTarget;    DWORD                  dwBitRate;    DWORD                  dwBitErrorRate;    REFERENCE_TIME         AvgTimePerFrame;    BITMAPINFOHEADER_H261  bmiHeader; } VIDEOINFOHEADER_H261, *PVIDEOINFOHEADER_H261; where rcSource  Specifies a RECT structure that defines the source video window.  rcTarget  Specifies a RECT structure that defines the destination video window.  dwBitRate  Specifies a DWORD value that indicates the video stream's approximate data rate, in bits per second.  dwBitErrorRate  Specifies a DWORD value that indicates the video stream's data error rate, in bit errors per second.  AvgTimePerFrame  Specifies a REFERENCE TIME value that indicates the video frame's average display time, in 100-nanosecond units.  bmiHeader  Specifies a BITMAPINFOHEADER_H261 structure that contains detailed format information for the RTP-packetized H.261 video data.  Bitmap info header structure for RTP-packetized H.263 video streams The H.263 specification allows for many compression options. The video decoder filter is responsible to chose what H.263 options to advertise by setting the H.263 specific fields of the extended bitmap info header defined below: typedef struct tagBITMAPINFOHEADER_H263 {     // Generic bitmap info header fields     BITMAPINFOHEADER   bmi;     // H.263 specific fields     DWORD dwMaxBitrate;     DWORD dwBppMaxKb;     DWORD dwHRD_B;     // Options     DWORD fUnrestrictedVector:1;     DWORD fArithmeticCoding:1;     DWORD fAdvancedPrediction:1;     DWORD fPBFrames:1;     DWORD fErrorCompensation:1;     DWORD fAdvancedIntraCoding:1;     DWORD fDeblockingFilter:1;     DWORD fImprovedPBFrames:1;     DWORD fUnlimitedMotionVectors:1;     DWORD fFullPictureFreeze:1;     DWORD fPartialPictureFreezeAndRelease:1;     DWORD fResizingPartPicFreezeAndRelease:1;     DWORD fFullPictureSnapshot:1;     DWORD fPartialPictureSnapshot:1;     DWORD fVideoSegmentTagging:1;     DWORD fProgressiveRefinement:1;     DWORD fDynamicPictureResizingByFour:1;     DWORD fDynamicPictureResizingSixteenthPel:1;     DWORD fDynamicWarpingHalfPel:1;     DWORD fDynamicWarpingSixteenthPel:1;     DWORD fIndependentSegmentDecoding:1;     DWORD fSlicesInOrder_NonRect:1;     DWORD fSlicesInOrder_Rect:1;     DWORD fSlicesNoOrder_NonRect:1;     DWORD fSlicesNoOrder_Rect:1;     DWORD fAlternateInterVLC:1;     DWORD fModifiedQuantization:1;     DWORD fReducedResolutionUpdate:1;     DWORD fReserved:4;     // Reserved     DWORD dwReserved[4]; } BITMAPINFOHEADER_H263, *PBITMAPINFOHEADER_H263; The BITMAPINFOHEADER is the well known GDI bitmap info header structure. It contains information on the video format such as actual image dimensions and the pixel depth. The following list describes the H.263 specific members of BITMAPINFOHEADER_H263: dwMaxBitrate  Specifies the maximum bit rate in units of 100 bits/s at which the decoder can receive video. This value is valid between 1 and 192400.  dwBppMaxKb  Specifies the maximum number of bits for one coded picture that the decoder can receive and decode correctly, and is measured in units of 1024 bits. This value is valid between 0 and 65535.  dwHRD_B  Specifies the Hypothetical Reference Decoder parameter B as described in Annex B of H.263. This value is valid between 0 and 524287.  fUnrestrictedVector  Specifies that the decoder can receive video data using the unrestricted motion vectors mode as defined in Annex D of H.263.  fArithmeticCoding  Specifies that the decoder can receive video data using the syntax based arithmetic coding mode as defined in Annex E of H.263.  fAdvancedPrediction  Specifies that the decoder can receive video data using the advanced prediction mode as defined in Annex F of H.263.  fPBFrames  Specifies that the decoder can receive video data using the PB-frames mode as defined in Annex G of H.263.  fErrorCompensation  Specifies that the decoder can identify MBs received with transmission errors, treat them as not coded, and send appropriate videoNotDecodedMBs indications.  fAdvancedIntraCoding  Specifies that the decoder can receive video data using the advanced INTRA coding mode as defined in Annex I of H.263.  fDeblockingFilter  Specifies that the decoder can receive video data using the deblocking filter mode as defined in Annex J of H.263.  fImprovedPBFrames  Specifies that the decoder can receive video data using the improved PB-frames mode as defined in Annex M of H.263.  fUnlimitedMotionVectors  Specifies that the decoder can receive video data using the unrestricted motion vector range when unrestricted motion vector mode as defined in Annex D of H.263 is also indicated.  fFullPictureFreeze Specifies that the decoder can receive Full Picture Freeze commands as described in Annex L of H.263.  fPartialPictureFreezeAndRelease Specifies that the decoder can receive Full Picture Freeze and Release commands as described in Annex L of H.263.  fResizingPartPicFreezeAndRelease Specifies that the decoder can receive the Resizing Partial Picture Freeze and Release commands as described in Annex L of H.263.  fFullPictureSnapshot Specifies that the decoder can receive Full Picture snapshots of the video content as described in Annex L of H.263.  fPartialPictureSnapshot Specifies that the decoder can receive Partial Picture Snapshots of the video content as described in Annex L of H.263.  fVideoSegmentTagging Specifies that the decoder can receive Video Segment tagging for the video content as described in Annex L of H.263.  fProgressiveRefinement Specifies that the decoder can receive Progressive Refinement tagging as described in Annex L of H.263. In addition, when true, the encoder shall respond to the progressive refinement miscellaneous commands doOneProgression, doContinuousProgressions, doOneIndependentProgression, doContinuousIndependentProgressions, progressiveRefinementAbortOne, and progressiveRefinementAbortContinuous. In addition, the encoder shall insert the Progressive Refinement Segment Start Tags and the Progressive Refinement Segment End Tags as defined in the Supplemental Enhancement Information Specification (Annex L) of Recommendation H.263. Note, Progressive Refinement tagging can be sent by an encoder and received by a decoder even when not commanded in a miscellaneous command.  fDynamicPictureResizingByFour Specifies that the decoder supports the picture resizing-by-four (with clipping) submode of the implicit Reference Picture Resampling Mode (Annex P) of H.263.  fDynamicPictureResizingSixteenthPel Specifies that the decoder supports resizing a reference picture to any width and height using the implicit Reference Picture Resampling mode (Annex P) of H.263 (with clipping). If DynamicPictureResizingSixteenthPel is true then DynamicPictureResizingByFour shall be true fDynamicWarpingHalfPel Specifies that the decoder supports the arbitrary picture warping operation within the Reference Picture Resampling mode (Annex P) of H.263 (with any fill mode) using half-pixel accuracy warping.  fDynamicWarpingSixteenthPel Specifies that the decoder supports the arbitrary picture warping operation within the Reference Picture Resampling mode (Annex P) of H.263 (with any fill mode) using either half-pixel or sixteenth pixel accuracy warping. fIndependentSegmentDecoding Specifies that the decoder supports the Independent Segment Decoding Mode (H.263 Annex R) of H.263.  fSlicesInOrder_NonRect Specifies that the decoder supports the submode of Slice Structured Mode (H.263 Annex K) where slices are transmitted in order and contain macroblocks in scanning order of the picture.  fSlicesInOrder_Rect Specifies that the decoder supports the submode of Slice Structured Mode (H.263 Annex K) where slices are transmitted in order and the slice occupies a rectangular region of the picture.  fSlicesNoOrder_NonRect Specifies that the decoder supports the submode of Slice Structured Mode (H.263 Annex K) where slices contain macroblocks in scanning order of the picture and need not be transmitted in order.  fSlicesNoOrder_Rect Specifies that the decoder supports the submode of Slice Structured Mode (H.263 Annex K) where slices occupy a rectangular region of the picture and need not be transmitted in order.  fAlternateInterVLC  Specifies that the decoder can receive video data using the alternate inter VLC mode as defined in Annex S of H.263.  fModifiedQuantization  Specifies that the decoder can receive video data using the modified quantization mode as defined in Annex T of H.263.  fReducedResolutionUpdate  Specifies that the decoder can receive video data using the reduced resolution update mode as defined in Annex Q of H.263.  fReserved  Reserved. Shall be set to NULL.  dwReserved[4]  Reserved. Shall all be set to NULL.  When the TAPI MSP, or the network upstream filter requests from the RTP-packetized compressed video input pin a list of supported formats, the input pin shall set the H.263 specific fields that it is capable of decoding to TRUE (1). This does not mean that the video decoder filter will necessarily receive data using that H.263 optional mode. Bitmap info header structure for RTP-packetized H.261 video streams The input pin of the video decoder filter shall use the following H.261 video format structure when asked to enumerate its supported input types, to indicate what maximum video bitrate the decoder can receive, and if it is capable of decoding still images as defined in Annex D of H.261: typedef struct tagBITMAPINFOHEADER_H261 {     // Generic bitmap info header fields     BITMAPINFOHEADER   bmi;     // H.261 specific fields     DWORD dwMaxBitrate;     BOOL fStillImageTransmission;     // Reserved     DWORD dwReserved[4]; } BITMAPINFOHEADER_H261, *PBITMAPINFOHEADER_H261; The BITMAPINFOHEADER is the well-known GDI bitmap info header structure. It contains information on the video stream such as actual image dimensions and the pixel depth. The following list describes the H.261 specific members of BITMAPINFOHEADER_H261: dwMaxBitrate  Specifies the maximum bit rate in units of 100 bits/s at which the decoder can receive video. This value is only valid between 1 and 19200.   fStillImageTransmission  Specifies that the decoder can receive still images as defined in Annex D of H.261.  dwReserved[4]  Reserved. Shall all be set to NULL.  When the TAPI MSP, or the network upstream filter requests from the RTP-packetized compressed video input pin a list of supported formats, the fStillImageTransmission field shall be set to TRUE if the pin is capable of decoding still images as described in Annex D of H.261. This does not mean that the video decoder filter will necessarily receive data using that optional mode. The dwMaxBitrate field shall be set to the maximum bitrate in units of 100 bits/s at which the RTP-packetized compressed video input pin can receive video data. RTP-packetized data format The TAPI MSP network source filter delivers raw RTP packets to the decoder filter. The input pin of the decoder filter is responsible for re-assembling RTP packets and extract the meaningful video or still-image data they contain. The input pin may chose to copy the content of the incoming packets into some of its own internal buffers and immediately return the packet to the upstream filter, until it gets an RTP packet with the end marker bit set, which signals the end of a frame. At that point, the decoder filter can decompress the entire video frame and deliver it on its output pin. It may also decide to lock the intermediary packets instead of copying them. In this case, the input pin shall release all the locked RTP packets after it has received the RTP packet with the end marker bit set. The decoder filter should not wait for the last RTP fragment of a video frame before starting decoding the video data that has already been received in the previous RTP packets. If the decoder supports layered encoding, it shall re-assemble packets from the different streams on one unique input pin. There is no need to expose an RTP-packetized compressed video input pin for each of the compressed layers. The input pin shall look at the SSRC field of the header of the RTP packet and the content of the video data to identify packets that belong to different encoding layers. H.245 command outgoing interface The TAPI MSP Channel Controller exposes the IVideoChannelControl outgoing interface to the RTP-packetized input pin of the video decoder filter. This pin may call upon this interface to send H.245 commands such as requests for I-frame, group of blocks, or macro-block updates to the remote sending endpoint. The flow control and temporal/spatial trade-off commands, as well as request mode messages are sent to the remote endpoint by the TAPI MSP, following a request from the application. The video decoder filter is not involved in the generation of those commands. The TAPI MSP calls IPin::QueryInterface on the RTP-packetized input pin to get an interface pointer to the IConnectionPointContainer interface. It then uses this interface to find a connection point object for the IVideoChannelControl interface. If the RTP-packetized input pin supports this outgoing interface, it needs to return a pointer to the IConnectionPoint interface. Finally, the TAPI MSP calls IConnectionPoint::Advise to pass a pointer to the IVideoChannelControl interface to the input pin. The RTP-packetized input pin may then start using this outgoing interface to send H.245 commands to the remote sending endpoint. IVideoChannelControl interface H.245 commands exist for various purposes. Fast update requests are generally issued when source switching occurs in multipoint applications, or packet loss was detected. In order to issue H.245 commands and indications, the TAPI MSP Channel Controller component provides the RTP-packetized compressed video input pin of the decoder filter with a pointer to an IVideoChannelControl interface containing, among others, the following relevant methods: VideoFastUpdadePicture  Used to command the remote encoder to enter the fast-update mode at its earliest opportunity.  VideoFastUpdateGOB  Used to command the remote encoder to perform a fast update of one or more GOBs. VideoFastUpdateMB  Used to command the remote encoder to perform a fast update of one or more MBs. VideoSendSyncEveryGOB Used to command the remote encoder to use sync for every GOB as defined in H.263. VideoSendSyncEveryGOBCancel Used to command the remote encoder to decide the frequency of GOB syncs. VideoNotDecodedMBs Used to indicate to the remote encoder that a set of MBs has been received with errors and that any MB in the specified set has been treated as not coded. VideoFastUpdatePicture method The videoFastUpdatePicture H.245 command is used to specify to the remote encoder to enter the fast-update mode at its earliest opportunity. The VideoFastUpdatePicture method is declared as follows: HRESULT VideoFastUpdatePicture() This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_NOTIMPL Method is not supported NOERROR No error This command shall be used with all video compression algorithms as a generic way to generate a keyframe (I-frame). VideoFastUpdateGOB method The videoFastUpdateGOB H.245 command is used to specify to the remote encoder to perform a fast update of one or more GOBs. The VideoFastUpdateGOB method is declared as follows: HRESULT VideoFastUpdateGOB([IN]DWORD dwFirstGOB, [IN]DWORD dwNumberOfGOBs) where dwFirstGOB  Specifies the number of the first GOB to be updated. This value is only valid between 0 and 17.  dwNumberOfGOBs  Specifies the number of GOBs to be updated. This value is only valid between 1 and 18.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error This command shall only be used with video compression algorithms that define GOBs such as H.261 and H.263. VideoFastUpdateMB method The videoFastUpdateMB H.245 command is used to specify to the remote encoder to perform a fast update of one or more MBs. The VideoFastUpdateMB method is declared as follows: HRESULT VideoFastUpdateMB([IN]DWORD dwFirstGOB, [IN]DWORD dwFirstMB, [IN]DWORD dwNumberOfMBs) where dwFirstGOB  Specifies the number of the first GOB to be updated and is only relative to H.263. This value is only valid between 0 and 255. dwFirstMB  Specifies the number of the first MB to be updated and is only relative to H.261. This value is only valid between 1 and 8192.  dwNumberOfMBs  Specifies the number of MBs to be updated. This value is only valid between 1 and 8192.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error This command shall only be used with video compression algorithms that define MBs such as H.261 and H.263. The remote encoder may respond to this command with a GOB update which includes the MBs requested. videoSendSyncEveryGOB and videoSendSyncEveryGOBCancel commands The videoSendSyncEveryGOB H.245 command is used to specify to the remote encoder to use sync for every GOB as defined in H.263. Reciprocally, the videoSendSyncEveryGOBCancel command is used to allow the remote encoder to decide the frequency of GOB syncs. To issue these commands, we define the VideoSendSyncEveryGOB method on the IVideoChannelControl interface as follows: HRESULT VideoSendSyncEveryGOB([IN]BOOL fEnable) where fEnable  If set to TRUE, specifies that the remote encoder should use sync for every GOB; if set to FALSE, specifies that the remote encoder should decide the frequency of GOB syncs on its own. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_NOTIMPL Method is not supported NOERROR No error This command shall only be used with video encoded according to H.263. VideoNotDecodedMBs method The videoNotDecodedMBs H.245 indication is used to indicate to the remote encoder that a set of MBs has been received with errors and that any MB in the specified set has been treated as not coded. To generate this indication, we define the VideoNotDecodedMBs method on the IVideoChannelControl interface as follows: HRESULT VideoNotDecodedMBs([IN]DWORD dwFirstMB, [IN]DWORD dwNumberOfMBs, [IN]DWORD dwTemporalReference) where dwFirstMB  Specifies the number of the first MB treated as not coded. This value is only valid between 1 and 8192. dwNumberOfMBs  Specifies the number of MBs treated as not coded. This value is only valid between 1 and 8192. dwTemporalReference  Specifies the temporal reference of the picture containing not decoded MBs. This value is only valid between 0 and 255. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error This remote encoder may use this information to compensate transmission errors, as illustrated in Appendix II of H.263. Uncompressed video output pin TAPI interfaces The TAPI MSP exposes a few interfaces supported by the uncompressed video output pin directly to the TAPI TSP call control component or the TAPI MSP Quality Controller. The call control component uses the IH245DecoderCommand interface to communicate H.245 commands to the uncompressed video output pin. The Quality Controller uses the ICPUControl interface to initialize and adjust the maximum decoding time per frame and CPU load not be exceeded by the decoder s decompression algorithm. It uses the IFrameRateControl interface to initialize and regulate the rate at which uncompressed video frames should be generated by the video output pin. This frame rate may be lower or higher than the frame rate at which video frames are coming from the network. The video decoder shall be able to handle those upsampling or downsampling operations while streaming, without stopping the streams. The TAPI MSP calls QueryInterface on the IPin interface exposed by the video output pin to get pointers to the IH245DecoderCommand, ICPUControl and IFrameRateControl interfaces. IH245DecoderCommand interface In order to handle H.245 commands, the uncompressed video or still-image output pin provides the TAPI call control component with a pointer to an IH245DecoderCommand interface containing the following method: videoFreezePicture  Used to command the output pin to complete updating the current video frame and subsequently display the frozen picture until receipt of the appropriate freeze-picture release control signal.  videoFreezePicture method This H.245 command is used to specify to the output pin to complete updating the current video frame and subsequently display the frozen picture until receipt of the appropriate freeze-picture release control signal. The videoFreezePicture method is declared as follows: HRESULT videoFreezePicture() This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_NOTIMPL Method is not supported NOERROR No error Other picture freeze and release requests The H.263 version 2 specification defined Supplemental Enhancement Information that may be included in the bitstream to signal enhanced display capability or to provide information for external usage (Annex L). This supplemental information can be used to signal a full-picture or partial-picture freeze or freeze-release request with or without resizing. The Supplemental Enhancement Information is sent in-band using the PSUPP field of the picture layer of H.263. Therefore, there is no other method defined on the IH245DecoderCommand interface for partial-picture freeze or freeze-release request with or without resizing. The decoder is always free to simply discard any PSUPP information bits that appear in the bitstream, if it does not support any of the requests. ICPUControl interface We also define the ICPUControl interface that video output pins are required to provide in order to receive bounds on the decoding time (latency) and CPU load that should not be exceeded during the decompression process. The methods on this interface are called at the beginning of a call to initialize the maximum CPU load and frame decoding time, and then occasionally by the TAPI MSP Quality Controller during the entire call, whenever an adjustment is deemed necessary. The initial and limit values for the maximum CPU load and frame decoding time are based on user-defined settings provided by the application. The ICPUControl interface contains the following methods: SetMaxProcessingTime  Used to specify to the uncompressed video output pin the maximum decoding time per frame, in 100-nanosecond units. GetMaxProcessingTime Used to retrieve the maximum decoding time per frame the uncompressed video output pin is currently setup for, in 100-nanosecond units. SetMaxCPULoad  Used to specify to the uncompressed video output pin the maximum decoding algorithm CPU load. GetMaxCPULoad Used to retrieve the maximum decoding algorithm CPU load the uncompressed video output pin is currently setup for. SetMaxProcessingTime method This CPU control method is used to specify to the uncompressed video output pin the maximum decoding time per frame. The SetMaxProcessingTime method is declared as follows: HRESULT SetMaxProcessingTime([IN]REFERENCE_TIME MaxProcessingTime) where MaxProcessingTime Specifies the maximum decoding time per frame, in 100-nanosecond units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetMaxProcessingTime method This CPU control method is used to retrieve the maximum decoding time per frame the uncompressed video output pin is currently setup for. The GetMaxProcessingTime method is declared as follows: HRESULT GetMaxProcessingTime([OUT]REFERENCE_TIME *pMaxProcessingTime) where pMaxProcessingTime Used to retrieve the maximum decoding time per frame the uncompressed video output pin is currently setup for, in 100-nanosecond units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error SetMaxCPULoad method This CPU control method is used to specify to the uncompressed video output pin the maximum decompression algorithm CPU load. The SetMaxCPULoad method is declared as follows: HRESULT SetMaxCPULoad([IN]DWORD dwMaxCPULoad) where dwMaxCPULoad Specifies the maximum decoding algorithm CPU load, in percentage units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetMaxCPULoad method This CPU control method is used to retrieve the maximum decompression algorithm CPU load the uncompressed video output pin is currently setup for. The GetMaxCPULoad method is declared as follows: HRESULT GetMaxCPULoad([OUT]DWORD *pdwMaxCPULoad) where pdwMaxCPULoad Used to retrieve the maximum decoding algorithm CPU load the uncompressed video output pin is currently setup for, in percentage units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error IFrameRateControl interface The IFrameRateControl interface specifies a target frame rate to the uncompressed video output pin of the decoder filter. This interface is provided for applications that would like to render the uncompressed video frames at a different playback rate than the incoming rate at which they are received from the network. The TAPI MSP Quality Controller may also call upon the methods of this interface based on its monitoring of the current CPU usage. The IFrameRateControl interface contains the following methods: SetMaxFrameRate  Used to specify to the uncompressed video output pin the video frame's average display time. GetMaxFrameRate Used to retrieve the video frame's average display time uncompressed video output pin are currently setup for. SetMaxFrameRate method This frame rate control method is used to specify to the un compressed video output pin the video frame s average display time. The SetMaxFrameRate method is declared as follows: HRESULT SetMaxFrameRate([IN] REFERENCE_TIME AvgTimePerFrame) where AvgTimePerFrame  Specifies a REFERENCE_TIME value that indicates the video frame's average display time, in 100-nanosecond units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Whenever this method is called, the video decoder output pin shall keep decompressing the incoming video data at its native rate, but generate uncompressed images at a lower or higher frame rate.  GetMaxFrameRate method This method is used to retrieve the video frame's average display time the uncompressed video output pin is currently setup for. The GetMaxFrameRate method is declared as follows: HRESULT GetMaxFrameRate([OUT] REFERENCE_TIME *pAvgTimePerFrame) where pAvgTimePerFrame Used to receive a REFERENCE_TIME value that indicates the video frame's average display time, in 100-nanosecond units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error Uncompressed still-image output pin TAPI interfaces The TAPI MSP exposes two interfaces supported by the uncompressed still-image output pin directly to the TAPI TSP call control component or the TAPI MSP Quality Controller. The call control component uses the IH245DecoderCommand interface to communicate H.245 commands to the uncompressed still-image output pin. The Quality Controller uses the ICPUControl interface to initialize and adjust the maximum decoding time per frame and CPU load not be exceeded by the decoder s decompression algorithm. The TAPI MSP calls QueryInterface on the IPin interface exposed by the still-image output pin to get pointers to the IH245DecoderCommand, and ICPUControl interfaces. IH245DecoderCommand interface The call control component uses the IH245DecoderCommand interface to communicate H.245 commands to the uncompressed still-image output pin. See section   REF _Ref433873056 \r \h   for more information on the IH245DecoderCommand interface. ICPUControl interface The uncompressed still-image output pin is required to implement the ICPUControl interface. The methods on this interface are called at the beginning of a call to initialize the maximum CPU load and frame decoding time, and then periodically by the TAPI MSP Quality Controller during the entire call. The initial and limit values for the maximum CPU load and frame decoding time are based on user-defined settings provided by the application. See section   REF _Ref433873069 \r \h   for more information on the ICPUControl interface. RTP-packetized compressed video input pin TAPI interfaces The TAPI MSP exposes two interfaces supported by the compressed video input pin directly to the TAPI MSP Quality Controller. The Quality Controller uses the IBitrateControl and IFrameRateControl interfaces to retrieve information on the bitrate and frame rate of the incoming video data. The TAPI MSP calls QueryInterface on the IPin interface exposed by the video input pin to get pointers to the IBitrateControl, and IFrameRateControl interfaces. IBitrateControl interface The TAPI MSP Quality Controller uses the IBitrateControl interface to get information on the effective bitrate of the incoming video data. The IBitrateControl interface contains the following methods: SetMaxBitrate  Not used with the RTP-packetized compressed video input pin. GetMaxBitrate Used to retrieve the effective bitrate of the incoming video data, free of any network header overhead. The Quality Controller will never make a call to the IBitrateControl::SetMaxBitrate method on the RTP-packetized compressed video input pin. SetMaxBitrate method The SetMaxBitrate method is declared as follows: HRESULT SetMaxBitrate([IN] DWORD dwMaxBitrate, [IN] DWORD dwLayerId) where dwMaxBitrate Specifies the new upper limit in bandwidth transmission in bits/s.  dwLayerId Specifies the ID of the encoding layer the new upper limit in bandwidth transmission applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  The input pin of the video decoder filter shall return E_NOTIMPL on this method. GetMaxBitrate method This method is used to retrieve the upper limit in bandwidth reception the RTP-packetized compressed video input pin is currently observing. The GetMaxBitrate method is declared as follows: HRESULT GetMaxBitrate([OUT] DWORD *pdwMaxBitrate, [IN] DWORD dwLayerId) where pdwMaxBitrate Used to receive the RTP-packetized compressed video input pin upper limit in bandwidth reception, free of any network header overhead, in bits/s.  dwLayerId Specifies the ID of the encoding layer the upper limit in bandwidth reception applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc..  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error IFrameRateControl interface The RTP-packetized compressed input pin is required to implement the IFrameRateControl interface. The TAPI MSP will never call the IFrameRateControl::SetMaxFrameRate method on the RTP-packetized compressed video input pin. The input pin of the video decoder filter shall return E_NOTIMPL on this method. On the other hand, the RTP-packetized compressed input pin shall implement the IFrameRateControl::GetMaxFrameRate method, and return the rate at which compressed video frames are received from the network. See section   REF _Ref431542280 \r \h   for more information on the IFrameRateControl interface. Video decoder filter application interfaces The TAPI MSP exposes a few DirectShow interfaces supported by the video decoder filter to the client application. Typically, these applications will indirectly use those interfaces to modify video quality settings, or provide simulated camera control capabilities if the video decoder filter supports such features. Those interfaces are the IAMVideoProcAmp, IAMCameraControl  and IAMVideoControl interfaces. Note that the application will not get a direct pointer to those interfaces. Instead, the methods on those interfaces will be used through containment. All the interfaces listed below shall be implemented by the video decoder itself, not its output pins. The TAPI MSP will call QueryInterface on the IBaseFilter interface exposed by the video encoder filter to get pointers to the DirectShow interfaces mentioned in this section. IAMVideoProcAmp interface The IAMVideoProcAmp interface contains methods for controlling video quality such as brightness, contrast, hue, saturation, gamma, and sharpness. It defines a uniform range for these settings regardless of whether the adjustment is made in the analog or digital domain. The IAMVideoProcAmp interface contains the following methods: GetRange  Used to retrieve minimum, maximum, and default values of a video quality setting. Used to set the value of a video quality setting.  Used to retrieve the value of a video quality setting.  The IAMVideoProcAmp interface uses the VideoProcAmpProperty enumerated data type to identify specific quality settings, and the VideoProcAmpFlags enumerated data type to qualify if the quality setting can be set manually and/or automatically. VideoProcAmpProperty enumerated data type This enumerated data type is defined as follows: typedef enum tagVideoProcAmpProperty    VideoProcAmp_Brightness,    VideoProcAmp_Contrast,    VideoProcAmp_Hue,    VideoProcAmp_Saturation,    VideoProcAmp_Sharpness,    VideoProcAmp_Gamma,    VideoProcAmp_ColorEnable,    VideoProcAmp_WhiteBalance,    VideoProcAmp_BacklightCompensation } VideoProcAmpProperty; where: VideoProcAmp_Brightness  Specifies the brightness setting in IRE units * 100. The range for Value is -10000 to 10000; the default value is 750 (7.5 IRE)  VideoProcAmp_Contrast Specifies the contrast or luma gain setting in gain factor * 100. The Value range is from zero to 10000, and the default is 100 (1x). Note that a particular video decoder filter may only implement a subset of this range.  VideoProcAmp_Hue Specifies the hue setting in degrees * 100. Value range is from -18000 to 18000 ( -180 to +180 degrees), and the default is zero. Note that a particular video decoder filter may only implement a subset of this range.  VideoProcAmp_Saturation Specifies the saturation or chroma gain setting in gain * 100. Value ranges from zero to 10000, and the default is 100 (1x). Note that a particular video decoder filter may only implement a subset of this range.  VideoProcAmp_Sharpness Specifies the sharpness setting in arbitrary units. Value ranges from zero to 100, and the default is 50. Note that a particular video decoder filter may only implement a subset of this range.  VideoProcAmp_Gamma Specifies the gamma setting in gamma * 100. Value ranges from 1 to 500, and the default is 100 (gamma = 1). Note that a particular video decoder filter may only implement a subset of this range.  VideoProcAmp_ColorEnable Specifies the color enable setting as a Boolean value. Value ranges from zero to 1, and the default is 1.  VideoProcAmp_WhiteBalance Specifies the white balance setting expressed as a color temperature in degrees Kelvin. The range and default values for this setting are video decoder filter dependent.  VideoProcAmp_BacklightCompensation Specifies the backlight compensation setting which is a Boolean. Zero indicates backlight compensation is disabled, and 1 indicates backlight compensation is enabled.  VideoProcAmpFlags enumerated data type This enumerated data type is defined as follows: typedef enum tagVideoProcAmpFlags    VideoProcAmp_Flags_Manual = 0x0000,    VideoProcAmp_Flags_Auto   = 0x0001 } VideoProcAmpFlags; where: VideoProcAmp_Flags_Manual  Specifies that the quality setting can be modified manually.  VideoProcAmp_Flags_Auto Specifies that the quality setting can be modified automatically.  GetRange method This method is used to retrieve the minimum, maximum, and default values for specific video quality settings. The GetRange method is declared as follows: HRESULT GetRange([IN]long Property, [OUT]long *pMin, [OUT]long *pMax, [OUT]long *pSteppingDelta, [OUT]long *pDefault, [OUT]long *pCapsFlags) where Property  Used to specify the video quality setting to determine the range of. Use a member of the VideoProcAmpProperty enumerated type. Used to retrieve the minimum value of the video quality setting range.  Used to retrieve the maximum value of the video quality setting range.  pSteppingDelta Used to retrieve the stepping delta of the video quality setting range.  pDefault Used to retrieve the default value of the video quality setting range.  pCapsFlags Used to retrieve the capabilities of the video quality setting. Pointer to a member of the VideoProcAmpFlags enumerated type. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Set method This method is used to set the value of a specific video quality setting. The Set method is declared as follows: HRESULT Set([IN]long Property, [IN]long lValue, [IN]long Flags) where Property  Used to specify the video quality setting to set the value of. Use a member of the VideoProcAmpProperty enumerated type. lValue Used to specify the new value of the video quality setting.  Flags A member of the VideoProcAmpFlags enumerated type.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Get method This method is used to get the current value of a specific video quality setting. The Get method is declared as follows: HRESULT Get([IN]long Property, [OUT]long *lValue, [OUT]long *Flags) where Property  Used to specify the video quality setting to get the value of. Use a member of the VideoProcAmpProperty enumerated type. lValue Used to retrieve the current value of the video quality setting.  Flags Pointer to a member of the VideoProcAmpFlags enumerated type.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error IAMCameraControl interface The IAMCameraControl interface contains methods to adjust or inquire about simulated camera control settings. The controls are a subset of the proposed ITU T.RDC standard at  HYPERLINK "http://www.itu.ch" http://www.itu.ch The IAMCameraControl interface contains the following methods: GetRange  Used to retrieve minimum, maximum, and default values of a simulated camera control setting. Used to set the value of a simulated camera control setting.  Used to retrieve the value of a simulated camera control setting.  The IAMCameraControl interface uses the CameraControlProperty enumerated data type to describe specific simulated camera control settings, and the CameraControlFlags enumerated data type to qualify if the simulated camera control setting can be set manually and/or automatically. CameraControlProperty enumerated data type This enumerated data type is defined as follows: typedef enum tagCameraControlProperty    CameraControl_Pan,    CameraControl_Tilt,    CameraControl_Roll,    CameraControl_Zoom,    CameraControl_Exposure,    CameraControl_Iris,    CameraControl_Focus } CameraControlProperty; where: CameraControl_Pan  Specifies the simulated camera pan setting in degrees. Values range from -180 to +180, and the default is zero. Positive values are clockwise from the origin (the simulated camera rotates clockwise when viewed from above), and negative values are counterclockwise from the origin. Note that a particular video decoder filter may only implement a subset of this range.  CameraControl_Tilt Specifies the simulated camera tilt setting in degrees. Values range from -180 to +180, and the default is zero. Positive values point the imaging plane up, and negative values point the imaging plane down. Note that a particular video decoder filter may only implement a subset of this range.  CameraControl_Roll Specifies the simulated roll setting in degrees. Values range from -180 to +180, and the default is zero. Positive values cause a clockwise rotation of the simulated camera along the image viewing axis, and negative values cause a counterclockwise rotation of the simulated camera. Note that a particular video decoder filter may only implement a subset of this range.  CameraControl_Zoom Specifies the simulated zoom setting in millimeter units. Values range from 10 to 600, and the default is video decoder filter specific.  CameraControl_Exposure Specifies the simulated exposure setting in seconds using the following formula. For values less than zero, the exposure time is 1/2n seconds. For positive values and zero, the exposure time is 2n seconds. Note that a particular video decoder filter may only implement a subset of this range.  CameraControl_Iris Specifies the simulated iris setting expressed as the fstop  * 10.  CameraControl_Focus Specifies the simulated camera focus setting as the distance to the optimally focused target in millimeters. The range and default values are video decoder filter specific. Note that a particular filter may only implement a subset of this range.  CameraControlFlags enumerated data type This enumerated data type is defined as follows: typedef enum tagCameraControlFlags    CameraControl_Flags_Manual = 0x0000,    CameraControl_Flags_Auto   = 0x0001 } CameraControlFlags; where: CameraControl_Flags_Manual  Specifies that the simulated camera control  setting can be modified manually.  CameraControl_Flags_Auto Specifies that the simulated camera control setting can be modified automatically.  GetRange method This method is used to retrieve the minimum, maximum, and default values for specific simulated camera control settings. The GetRange method is declared as follows: HRESULT GetRange([IN]long Property, [OUT]long *pMin, [OUT]long *pMax, [OUT]long *pSteppingDelta, [OUT]long *pDefault, [OUT]long *pCapsFlags) where Property  Used to specify the simulated camera control setting to determine the range of. Use a member of the CameraControlProperty enumerated type. Used to retrieve the minimum value of the simulated camera control setting range.  Used to retrieve the maximum value of the simulated camera control setting range.  pSteppingDelta Used to retrieve the stepping delta of the simulated camera control setting range.  pDefault Used to retrieve the default value of the simulated camera control setting range.  pCapsFlags Used to retrieve the capabilities of the simulated camera control setting. Pointer to a member of the CameraControlFlags enumerated type. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Set method This method is used to set the value of a specific simulated camera control setting. The Set method is declared as follows: HRESULT Set([IN]long Property, [IN]long lValue, [IN]long Flags) where Property  Used to specify the simulated camera control setting to set the value of. Use a member of the CameraControlProperty enumerated type. lValue Used to specify the new value of the simulated camera control setting.  Flags A member of the CameraControlFlags enumerated type.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Get method This method is used to get the current value of a specific simulated camera control setting. The Get method is declared as follows: HRESULT Get([IN]long Property, [OUT]long *lValue, [OUT]long *Flags) where Property  Used to specify the simulated camera control setting to get the value of. Use a member of the CameraControlProperty enumerated type. lValue Used to retrieve the current value of the simulated camera control setting.  Flags Pointer to a member of the CameraControlFlags enumerated type.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error IAMVideoControl interface The IAMVideoControl interface contains methods to flip a picture horizontally and/or vertically. Methods on this interface that are not related to the flip operations will not be exposed, nor used by TAPI. The following list identifies the only methods of IAMVideoControl interface exposed by TAPI: GetCaps  Used to retrieve the capabilities of the video decoder filter regarding flipping pictures. SetMode Used to flip a picture horizontally or vertically.  GetMode Used to retrieve the current flip state.  The IAMVideoControl interface uses the VideoControlFlags enumerated data type to describe flip modes. VideoControlFlags enumerated data type This enumerated data type is defined as follows: typedef enum tagVideoControlFlags     VideoControlFlag_FlipHorizontal        = 0x0001,     VideoControlFlag_FlipVertical          = 0x0002,     VideoControlFlag_ExternalTriggerEnable = 0x0004,     VideoControlFlag_Trigger               = 0x0008 } VideoControlFlags; where only the two first values are used: VideoControlFlag_FlipHorizontal Specifies that the picture is flipped horizontally.  VideoControlFlag_FlipVertical Specifies that the picture is flipped vertically.  GetCaps method This method is used to retrieve the capabilities of the video decoder filter regarding flipping pictures. The GetCaps method is declared as follows: HRESULT GetCaps([IN]IPin *pPin, [OUT]long *pCapsFlags) where pPin  Used to specify the compressed video output pin to query capabilities from. pCapsFlags Used to retrieve a value representing a combination of the flags from the VideoControlFlags enumeration.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error SetMode method This method is used to flip a picture horizontally of vertically. The SetMode method is declared as follows: HRESULT SetMode([IN]IPin *pPin, [IN]long Mode) where pPin  Used to specify the pin to set the flip mode on. Used to specify a combination of the flags from the VideoControlFlags enumeration.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetMode method This method is used to retrieve the capabilities of the video decoder filter regarding flipping pictures. The GetCaps method is declared as follows: HRESULT GetCaps([IN]IPin *pPin, [OUT]long *Mode) where pPin  Used to specify the pin to get the flip mode of. Pointer to a value representing a combination of the flags from the VideoControlFlags enumeration.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Video decoder filter H.245 video capabilities The TAPI 3.1 MSP Capability module is responsible for coordinating capability advertisement and resolution with respect to the limits configured in the TAPI 3.1 MSP Quality Controller. Installable encoder and decoder filters are required to implement a new IH245VideoCapability interface provide the TAPI 3.1 MSP Capability module with a table of estimated steady-state resource requirements as related to each format that the codec supports. While run-time resource requirements fluctuate within a continuum, the steady-state resource requirements are meant to indicate relative resource requirements under near-ideal conditions and no network loss. At minimum, the resource requirements should include the typical maximum bitrate and CPU utilization (in % of the host CPU) for each supported format. The steady-state resource requirement information is used only by the TAPI 3.1 MSP Capability module to ensure that negotiated formats always fall within the maximum configured resource budget. Given the steady-state resource requirements of all filters and the resource limits configured in the TAPI 3.1 MSP Quality Controller, the TAPI 3.1 MSP Capability module is able to build the local simultaneous capability descriptors and to disable advertisement and selection of formats which exceed or approach the configured resource limits. Once streaming is active, fluctuations in actual bitrate and CPU load are then managed by the TAPI 3.1 MSP Quality Controller.  Standard Codec addition or replacement  When a standard codec is installed, the TAPI 3.1  MSP Capability module will use the IH245VideoCapability interface to obtain the capability information of the installed filter and add the supported transmit and receive capabilities in H.245/AM_MEDIA_TYPE form to internal transmit and receive capability lists in priority order. The TAPI 3.1 MSP Capability module also keeps track of the origin of the added capability so that it can find the appropriate filter instance at capability resolution and channel-open time. The MSP Capability module ignores duplicate H.245 capabilities in either list, so that if a replacement codec is installed and is at a higher priority than the original codec, the replacement codec will always be chosen over the original one.  The capability resolution code in the MSP Capability module is capable of advertising, understanding, comparing, and finding matches in local and remote capability lists provided that the capability is defined in the supported version of H.245. The only difference introduced by the installation of a replacement codec is as follows. When the Capability module finds a remote capability match via its existing priority search algorithm, it must check the chosen capability in its internal list for an association with a specific filter. This module differentiates between filters implementing the same standard algorithm by referencing their unique registered DirectShow GUID. Once a format is chosen and a channel is opened, the MSP channel control code passes the AM_MEDIA_TYPE structure to the MSP streaming components. Mode changes and openLogicalChannel requests are handled similarly by capability resolution code in the MSP Capability module. Given the channel parameters in H.245 form, it is capable of understanding, comparing, and finding a local capability that is compatible with the channel parameters in the mode change or openLogicalChannel request. Filter configuration is identical to the transmit case. Non-standard codec support Installation, negotiation, and selection of non-standard codecs places additional requirements on TAPI and the implementation of the codec filter. As when a standard codec is installed, the TAPI 3.1  MSP Capability module will obtain the capability information of the installed filter using the IH245VideoCapability interface. Recall that the format of the capability data for non-standard formats includes a sized byte array instead of an initialized H.245 structure. The capability module stores the sized byte array of each capability in its internal lists. When capabilities are advertised, the sized byte array is encapsulated in an extensible structure, which is in turn encapsulated in an H.245 non-standard capability structure. The extensible structure mentioned in the previous sentence is a tagged and sized structure. The structure is defined by Microsoft and is not exposed. The purpose of the structure is to allow support of multiple non-standard capability negotiation mechanisms within Microsoft products without breaking interoperability. (There is only one H.221 non-standard identifier assigned to Microsoft Corp). There are already defined tags for NetMeeting's non-standard audio and video capability "capsules". A new tag will be defined that identifies the contents as "the TAPI 3.1 non-standard codec scheme". This will allow shipped versions of NetMeeting to ignore new non-standard capabilities that it may receive. When non-standard capabilities are involved, The TAPI 3.1 MSP Capability module recognizes the presence of non-standard capabilities and delegates the interpretation of their contents according to the H.221 non-standard identifier and the contents of the encapsulation structure. As always, the prioritized search for a matching capability favors the order of the local transmit capability list. The target of the search is based on the current "top" of the local transmit capability list. If the current search target is a non-standard capability, the TAPI 3.1 MSP capability module searches the received capability list for a non-standard capability that has a matching H.221 non-standard identifier. Whenever a matching H.221 non-standard identifier (Microsoft) is found, the TAPI 3.1 MSP capability module reads the encapsulated tag to see if the non-standard capability scheme identified by that tag is supported on the platform. If the tag indicates that the nonstandard data is formatted according to "the TAPI 3.1 non-standard codec scheme", the MSP Capability module uses the facilities of the installed codec filter modules to interpret non-standard capability data. Recall that the transmit capability list contains references to the installed filter module that is supplying the capability, so this is the only filter module that needs to attempt interpretation of the candidate remote capability. This scheme avoids unnecessary attempts to interpret or recognize non-standard capability data.  Interpretation facilities provided by the installed codec filter  The interpretation methods of the IH245VideoCapability interface provide the following general facilities: Input Output Facility #1 (Sized byte array), (Sized byte array)  A local/remote pair of non-standard capabilities (Boolean) compare succeeded (HANDLE) negotiated format identifier (Sized byte array) non-standard logical channel parameters for the remote system (AM_MEDIA_TYPE) filter configuration structure Facility #2 (Sized byte array) non-standard logical channel parameters from remote system (Boolean) local format found (HANDLE) negotiated format identifier (AM_MEDIA_TYPE) filter configuration structure Facility #3 (HANDLE) negotiated format identifier Negotiated generic parameters useful for input to Quality Controller (max bitrate, frame rate, min/max frames/packet, etc) The installed codec filter is required to include basic negotiable parameters e.g. max frames per packet in its private representation of logical channel parameters, and to compute the intersection of local and remote parameters when facility #1 or #2 succeeds. The results of this intersection are stored internally and a unique handle is created ("negotiated format identifier" in the table above) to reference the intersection data.  Capability resolution/channel open mechanism If and when Facility #1 of IH245VideoCapability returns TRUE indicating that the compare succeeded, the TAPI 3.1 MSP Capability module of the sender forwards the negotiated format identifier, the filter configuration structure, and the non-standard logical channel parameters to the TAPI 3.1 MSP Channel control module. The Channel control module encapsulates and transfers the non-standard logical channel parameters to the remote system via openLogicalChannel. When the remote system receives the openLogicalChannel request, the TAPI 3.1 MSP Channel control module of the receiver forwards the channel parameters to the TAPI 3.1 MSP Capability module. The TAPI 3.1 MSP Capability module uses facility #2 of the installed codec filter to obtain the filter configuration structure and format identifier and returns the capability data to the TAPI 3.1 MSP Channel control module. The TAPI 3.1 MSP Channel control module may then configure the receive (decoding) filter and acknowledge the openLogicalChannel. The TAPI 3.1 MSP Channel control module may also obtain negotiated parameters e.g. maximum bitrate at this time and forward the result to the Quality Controller. When the TAPI 3.1 MSP Channel control module of the sender receives the openLogicalChannel ack, it may then configure the send (encoding) filter and Quality Controller similarly. The mechanisms for handling of mode changes at the sender are conceptually the same as those handling openLogicalChannel requests at the receiver. IH245VideoCapability interface The IH245VideoCapability interface contains methods to enumerate, translate, and compare video formats. The IH245VideoCapability interface contains the following methods: GetH245VersionID Used to retrieve a version identifier that indicates the version of H.245 that was in effect when the filter module was compiled. GetFormatTable Used to retrieve a table of supported formats as related to estimated system resources. This table may be dynamically allocated by the filter.  ReleaseFormatTable Used to release the format table allocated by GetFormatTable. IntersectFormats Used to compare a local capability and remote capability and produce filter configuration structures and parameters that are compatible with both.  GetLocalFormat Used to retrieve local format parameters that are compatible with a specific remote capability and parameters. GetNegotiatedLimitProperty Used to retrieve the value of a negotiated limiting parameter.  ReleaseNegotiatedCapability Used to release resources that were allocated by IntersectFormats or GetLocalFormat.  SetIDBase Used to control the range of sequential numbers that uniquely identify individual capabilities FindIDByRange Used to find a specific capability that corresponds to a formatted AM_MEDIA_TYPE structure.  The IH245VideoCapability interface uses the NegotiatedVideoLimit enumerated data type to describe negotiated video limiting parameters. Only generic properties which are useful to the TAPI MSP Quality Controller module are defined. NegotiatedVideoLimit enumerated data type This enumerated data type is defined as follows: typedef enum tagNegotiatedVideoLimit     NegotiatedVideo_MaxFrameRate,     NegotiatedVideo_MaxBitRate,     NegotiatedVideo_MaxBitsPerPicture, } NegotiatedVideoLimit; where: NegotiatedVideo_MaxFrameRate Specifies the smaller of the maximum continuous video frame rate that the receiver is capable of receiving or the transmitter is capable of transmitting.  NegotiatedVideo_MaxBitRate Specifies smaller of the maximum average video bit rate that the receiver is capable of receiving or the transmitter is capable of transmitting.  NegotiatedVideo_MaxBitsPerPicture Specifies the maximum number of bits that may be contained in a single video frame. If there is no negotiated maximum, this shall be zero.  VideoResourceBounds structure TAPI defines the VideoResourceBounds structure to specify the estimated maximum continuous resource requirements of a video encoding or decoding filter at a specific frame rate: typedef enum tag_VideoResourceBounds     int iPicturesPerSecond;     DWORD dwBitsPerPicture;     WORD wCPUUtilization; } VideoResourceBounds; where: iPicturesPerSecond Specifies an INTEGER value that indicates the video frame rate, in frames per second, for which the resource bounds are being specified. Frame rates of less than 1 frame per second are indicated by a negative value in units of seconds per frame.  dwBitsPerPicture Specifies a DWORD value that indicates the approximate average number of bits per video frame at an average frame rate of iPicturesPerSecond.  wCPUUtilization Specifies a WORD value that indicates the approximate average CPU utilization, in percent, of the encoder or decoder at the average frame rate of iPicturesPerSecond.  H245VideoCapabilityMap structure TAPI defines the H245VideoCapabilityMap structure to specify the relationship between supported formats and estimated maximum system resources for the supported format: typedef enum tag_H245VideoCapabilityMap     AM_MEDIA_TYPE *pAMMediaType;     H245VideoCapability h245VideoCapability;     GUID filterGuid;     DWORD dwUniqueID;     UINT uNumRatesSupported;     VideoResourceBounds *pResourceBoundArray; } H245VideoCapabilityMap; where: pAMMediaType Specifies a pointer to an AM_MEDIA_TYPE structure that describes the format of the video stream.  h245VideoCapability Specifies the H.245 video format, including all parameters and options. This structure is H.245 version specific: its definition depends on the version of H.245 that was in effect at the time the filter was developed. This structure may indicate format parameters for more than one standard video size at a time if the resource requirements are similar for all sizes.  filterGuid Specifies a GUID value that uniquely identifies the video decoder filter.  dwUniqueID Specifies a DWORD value that uniquely identifies the capability of the video decoder filter.  uNumRatesSupported This indicates the number of elements referenced by pResourceBoundArray and specifies the number of integral frame rates that are supported for the format options specified in pAMMediaType and h245VideoCapability.  pResourceBoundArray Specifies an array of VideoResourceBounds structures that indicate the approximate resource bounds of each supported integral frame rate.  H245VideoCapabilityTable structure TAPI defines the H245VideoCapabilityTable structure to specify the set of formats that are supported by the filter: typedef enum tag_H245VideoCapabilityTable     UINT uMappedCapabilities;     H245VideoCapabilityMap *pCapabilityArray; } H245VideoCapabilityTable; where: uMappedCapabilities Specifies  the  number of H245VideoCapabilityMap structures in pCapabilityArray.  pCapabilityArray Specifies a pointer to an array of H245VideoCapabilityMap structures.  GetH245VersionID method This method returns a DWORD value that identifies the platform version that the filter was designed for. The platform version is defined as TAPI_H245_VERSION_ID. The GetH245VersionID method is declared as: DWORD GetH245VersionID() GetFormatTable method This method is used to obtain H245VideoCapabilityMap structures for all formats and format options that the filter supports. In general, the content of the capability information that the TAPI 3.1 MSP Capability module obtains via the GetFormatTable method is a two dimensional table that relates every supported transmit and/or receive format to steady-state resource requirements of that format. In the case of standard codecs, the "format" information consists of an initialized H.245 data structure and an initialized AM_MEDIA_TYPE structure. The definition of this structure would be provided by Microsoft as part of a development kit. In the case of non-standard codecs, the H.245 structure would be replaced with a sized array of bytes. The contents of the nonstandard byte array are defined by the implementation of a complimentary pair of encoder and decoder filters. The GetFormatTable method is declared as follows: HRESULT GetFormatTable([IN]IPin *pPin, [OUT]H245VideoCapabilityTable *pTable) where pPin  Used to specify the output pin of the capture filter that will be providing input for encoder filters or the input pin of the filter receiving output from decoder filters. The filter shall enumerate the list of formats supported by this pin to build its own video capability table. pTable Pointer to an H245VideoCapabilityTable structure.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error ReleaseFormatTable method This method is used to release memory allocated by the GetFormatTable method. The ReleaseFormatTable method is declared as follows: HRESULT ReleaseFormatTable([IN]H245VideoCapabilityTable *pTable) where pTable Pointer to an H245VideoCapabilityTable structure.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error IntersectFormats method This method is used to compare and intersect one local capability and one remote capability and to obtain filter configuration parameters. The IntersectFormats method is declared as follows: HRESULT IntersectFormats([IN]H245VideoCapability *pLocalCapability, [IN]H245VideoCapability *pRemoteCapability, [OUT]HANDLE *phIntersectionCookie, [OUT]H245VideoCapability *pIntersectedCapability) where pLocalCapability  Specifies the H.245 video format, including all parameters and options defined by H.245, of a local video capability. pRemoteCapability  Specifies the H.245 video format, including all parameters and options defined by H.245, of a remote video capability. phIntersectionCookie  Identifies the dynamic instance of intersected capabilities. When a filter creates the intersection, it may allocate memory for the intersected capability parameters. The intersection cookie identifies this allocation. This is used to release internal allocations and also as an argument to the GetNegotiatedLimitProperty method. pIntersectedCapability  Specifies the H.245 video format, of the resolved common local and remote capability options and limits. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_INCOMPATIBLECAPS Failure E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetLocalFormat method This method is used to obtain local filter configuration parameters that are compatible with a remote capability. The GetLocalFormat method is declared as follows: HRESULT GetLocalFormat([IN]H245VideoCapability *pRemoteCapability, [IN]HANDLE *phIntersectionCookie, [OUT]AM_MEDIA_TYPE **ppAMMediaType) where pRemoteCapability  Specifies the H.245 video format, including all parameters and options defined by H.245, of a remote video capability. phIntersectionCookie  Identifies the dynamic instance of intersected capabilities. When a filter creates the intersection, it may allocate memory for the intersected capability parameters. The intersection cookie identifies this allocation. This is used to release internal allocations and also as an argument to the GetNegotiatedLimitProperty method. ppAMMediaType Pointer to the address of an AM_MEDIA_TYPE structure to receive the local format.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_INCOMPATIBLECAPS No local compatible capability exists E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetNegotiatedLimitProperty method This method is used to obtain negotiated limits that were determined by either the IntersectFormats or GetLocalFormat method. The GetNegotiatedLimitProperty method is declared as follows: HRESULT GetNegotiatedLimitProperty([IN]HANDLE hIntersectionCookie, [IN]NegotiatedVideoLimit LimitProperty, [OUT]DWORD *pdwValue) where hIntersectionCookie  Identifies the dynamic instance of intersected capabilities. LimitProperty  Identifies the limit property being retrieved. pdwValue Pointer to a DWORD value to receive the value of the specified limit property.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error ReleaseNegotiatedCapability method This method is used to release a filter's internal memory allocated by either the IntersectFormats or GetLocalFormat method. The ReleaseNegotiatedCapability method is declared as follows: HRESULT ReleaseNegotiatedCapability([IN]HANDLE hIntersectionCookie) where hIntersectionCookie  Identifies the dynamic instance of intersected capabilities. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error SetIDBase method This method is used to control the sequential numbering range used to uniquely identify a Filter s capabilities. The SetIDBase method is declared as follows: HRESULT SetIDBase([IN]DWORD dwIDBase) where dwIDBase  A DWORD value that indicates the beginning number in the sequence . This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error FindIDByRange method This method is used to obtain the unique format ID of a capability that corresponds to an AM_MEDIA_TYPE. The FindIDByRange method is declared as follows: HRESULT FindIDByRange([IN]AM_MEDIA_TYPE *pAMMediaType,[OUT]DWORD *pdwID) where pAMMediaType Pointer to an AM_MEDIA_TYPE structure that has been initialized indicate a specific format. pdwID  Pointer to a DWORD output parameter that will contain the unique format ID. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error  References TAPI 3.1 Specifications Microsoft  TAPI  Video Encoder Filter   Streams and Interfaces  LINK Word.Document.8 "\\\\PHILF\\SPECS\\MICROSOFT TAPI VIDEO ENCODER FILTER.DOC" "" \a \p  DirectShow SDK articles and documentation Available from  HYPERLINK "http://www.microsoft.com/directx/pavilion/dshow" http://www.microsoft.com/directx/pavilion/dshow ITU communications standards Available from  HYPERLINK "http://www.itu.int/itudoc/itu-t/rec/h" http://www.itu.int/itudoc/itu-t/rec/h Recommendation H.245 v3 (09/97)   Control protocol for multimedia communication Recommendation H.261 (03/93)   Video codec for audiovisual services at px64 kbit/s Recommendation H.263 (03/96)   Video coding for low bit rate communication Recommendation H.263 v2 (01/98)   Video coding for low bit rate communication ITU home page:  HYPERLINK "http://www.itu.int/home" http://www.itu.int/home IETF Request for comments Available from  HYPERLINK "ftp://ftp.isi.edu/in-notes" ftp://ftp.isi.edu/in-notes RFC 1889   RTP: A Transport Protocol for real-time Applications RFC 2032   RTP Payload Format for H.261 video streams RFC 2190   RTP Payload Format for H.263 video streams RFC 2429   RTP Payload Format for the 1998 Version of ITU-T Rec. H.263 Video (H.263+)  Unless stated otherwise all references to TAPI apply to version 3.1. Microsoft Corporation Company Confidential  DATE  06/26/99        Draft - Microsoft Corporation Company Confidential      TIME  8:00 PM Revision 0.207            WDM Connection and Streaming Architecture Revision 0.4.  REVNUM  \* MERGEFORMAT              TITLE  \* MERGEFORMAT  Microsoft  TAPI  Video Decoder Filter  DATE  06/26/99            Microsoft Corporation Company Confidential            TIME  8:00 PM  DATE  06/26/99       Draft - Microsoft Corporation Company Confidential       TIME  8:00 PM Microsoft Corporation Company Confidential  DATE  06/26/99        Draft - Microsoft Corporation Confidential      TIME  8:00 PM Optional Compressed Still-Image Pin Optional Uncompressed Still-Image Pin Compressed Video Pin TAPI MSP Video Decoder Filter IH245DecoderCommand ICPUControl IAMVideoProcAmp IAMCameraControl IAMVideoControl IH245VideoCapability IH245DecoderCommand IFrameRateControl ICPUControl Uncompressed Video Pin TAPI MSP Network Source Filter TAPI MSP Video Renderer Sink Filter TAPI MSP Video Renderer Sink Filter IVideoChannelControl TAPI MSP Call Control Module IConnectionPointContainer IConnectionPoint IConnectionPointContainer IConnectionPoint IFrameRateControl IBitrateControl ~ytoje`[ ~ytoje`[ ~{xurol`] {xurolif |yvsp ~{xug zwrogda\WR }xspma^[ zugb]X rmhc^Y |wrmhc^Y ~ytoje`[ zupkfa\ ~ytoje`[ |wrmhc^[X |yvqnid_Z }yvspm_\ }olida ~pmjeb_ |wrmhc` {vqli]Z }zwroje` }xtojfc` |nkhc`] |ytolifa |pmjeb_\ }zwrmjgd_ rolgda }zwtqc wtqnkfc` }xsnid_ zwtoje`[ ~{xupkgb |wtqnid` |yvqlhc\ |ymjgb] uroje`[ zwtqlgc^ |wtqnid` |yvqlhc\ |ymjgb] {wrkgb] ~yrnid` {wrmid_ }xsnidXS xtqlgbTO zwtqnb_\ }zupkfa\ }xsnkhZW |ytojeb_ ~ytqnkfa] {vqlgda^ zwtqlgb] spmheb_ }olida^ |ytolifa }zwrmid] }zwtqnkheb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\doc\review of netmeeting requirements.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Don Ryan Microsoft Corporation Review of NetMeeting Requirements Title _PID_GUIDReview of NetMeeting Requirements Audio and Video Streaming Philippe Ferriere, Mu Han, Andres Vega-Garcia NetMeeting Specification.dot Philippe Ferriere Microsoft Word 8.0D;*fal*F/l*Fp qaA8 XptttMicrosoft Word Document MSWordDoc Word.Document.8Microsoft Corporation NetMeeting and TAPI Integration Title _PID_GUID _PID_HLINKSNetMeeting and TAPI Integration Functional Overview Philippe Ferriere, John Selbie NetMeeting Specification.dot Philippe Ferriere Microsoft Word 8.0/hwdev/desinit/ TITLE  \* MERGEFORMAT  NetMeeting and TAPI Integration  SUBJECT  \* MERGEFORMAT  Functional Overview Draft Authors:    AUTHOR  \* MERGEFORMAT  Philippe Ferriere, John Selbie Revision 0.0.  REVNUM  \* MERGEFORMAT   DATE \@ "d MMMM, yyyy" \* MERGEFORMAT  26 June, 1998  TOC \o "1-4"  Introduction  PAGEREF _Toc423489917 \h  Intended audience  PAGEREF _Toc423489918 \h  Document organization  PAGEREF _Toc423489919 \h  NetMeeting media streaming strengths  PAGEREF _Toc423489920 \h  Video capture  PAGEREF _Toc423489921 \h  Audio recording  PAGEREF _Toc423489922 \h  Video playback  PAGEREF _Toc423489923 \h  Audio playback  PAGEREF _Toc423489924 \h  CPU and bandwidth usage monitoring  PAGEREF _Toc423489925 \h  H.245 commands and miscellaneous indications  PAGEREF _Toc423489926 \h  Functional requirements for TAPI 3.x  PAGEREF _Toc423489927 \h  Video capture  PAGEREF _Toc423489928 \h  3.1.1 Minimum feature set  PAGEREF _Toc423489929 \h  3.1.2 TAPI only features  PAGEREF _Toc423489930 \h  Audio recording  PAGEREF _Toc423489931 \h  3.2.1 Minimum feature set  PAGEREF _Toc423489932 \h  3.2.2 TAPI only features  PAGEREF _Toc423489933 \h  Video playback  PAGEREF _Toc423489934 \h  3.3.1 Minimum feature set  PAGEREF _Toc423489935 \h  3.3.2 TAPI only features  PAGEREF _Toc423489936 \h  Audio playback  PAGEREF _Toc423489937 \h  3.4.1 Minimum feature set  PAGEREF _Toc423489938 \h  3.4.2 TAPI only features  PAGEREF _Toc423489939 \h  CPU and bandwidth usage monitoring  PAGEREF _Toc423489940 \h  3.5.1 Minimum feature set  PAGEREF _Toc423489941 \h  3.5.2 TAPI only features  PAGEREF _Toc423489942 \h  H.245 commands and indications  PAGEREF _Toc423489943 \h  3.6.1 Minimum feature set  PAGEREF _Toc423489944 \h  3.6.2 TAPI only features  PAGEREF _Toc423489945 \h  References  PAGEREF _Toc423489946 \h  Introduction This short document presents an introductory list of functional requirements for the TAPI team in order to allow NetMeeting  to run on top of TAPI 3.x on Win98 and NT5, with performances as good or better than what NetMeeting 2.11 already achieves on Win9x and NT4.0. There is no reason for the NetMeeting A\V team to use - or design from scratch - another media streaming platform if a slightly modified version of TAPI can run on Win98 and NT5, and provide the necessary level of performances. In order to help and scope the modifications that may have to be applied to TAPI 3.0, it is important to understand how strong an application NetMeeting 2.11 is on Win9x and NT4.0 platforms, and what makes it work well. This document lists NetMeeting s strengths, verbalizes them as functional specifications for TAPI to achieve parity in performance, and elaborates on additional requirements to guarantee higher performance on TAPI. Intended audience This document is intended for TAPI team members in charge of providing the NetMeeting team with a media streaming platform with performances and functionality as good, and preferably better, than what NetMeeting 2.11 achieves on all Windows operating systems. Document organization Section   REF _Ref423422538 \r \h   describes the current streaming capabilities and functionality of NetMeeting 2.11 on all platforms. Section   REF _Ref423422554 \r \h   summarizes the list of functionalities that TAPI is required to provide in order to achieve the same level of functionality than NetMeeting 2.11, and elaborates on the list of features required to make NetMeeting stronger on TAPI. NetMeeting media streaming strengths This section provides an overview of NetMeeting s audio and video streaming strengths and features that will need to be matched by TAPI s own streaming architecture. Video capture Most of the video streaming performances exhibited by NetMeeting come from its knowledgeable capture layer. NetMeeting will only make use of advanced features with VfW capture devices   and now WDM devices   after the NetMeeting test and development teams have effectively validated those features through exhaustive testing. This guarantees the best and consistent experience to NetMeeting users. For devices that support streaming, capture at a high frame rate can be achieved. For devices that do not support streaming, a safer and simpler approach is found in using frame-grabbing, yielding certainly lower performances. However, the device do not AV, nor hang, as is frequently the case in competitive products. This consistency in reliability, performance, and overall user experience has been key to NetMeeting's success in technical Press reviews. NetMeeting currently supports three video sizes ( Small Medium , and  Large  UI sizes) that match the ITU-T sizes known as SQCIF, QCIF and CIF. Those sizes can be changed quickly, and at anytime during a call. It several capture devices are installed, the user can select which device to use from a drop down list.  NetMeeting renders a preview version of the captured video stream in its Local Video window. This window can be docked/undocked in NetMeeting s main UI, as well as stretched. Audio recording Audio recording can occur through any Windows audio device that supports a recording format used by the codecs.  At the present time, all NetMeeting codecs operate on 8000hz-16 bit PCM samples, so all recording devices must support this format. User Interface stream controls. From the NetMeeting UI components, the user can has the ability to do the following: Select which recording device to use.  Only devices that support the 8000-16 format are available for the user to choose from. Control the recording and microphone gain on the Wave device s mixer.  A feature known as  AutoMix  is provided that adjusts the mixer settings based on occurrences of clipping and low volume inputs. Manually adjust the silence threshold if he desires, although an  automatic  mode is provided that adapts to the background noise of the room. If the recording device s mixer supports automatic gain control (AGC) or a  Microphone Boost  control, a UI component is available for the user to enable this feature. Enable full or half duplex recording.  Full duplex is enabled by default.  Some sound cards do no support full duplex operations, or only function well in half duplex mode. The ability to pause the recording stream so as to achieve a   effect.  This a stream control, not a mixer control. The duplex, mixer settings, and silence level can be changed while in a call.   It is not necessary to support the changing of the audio device while streaming. While in a call, a signal level meter is displayed on the UI to indicate speech input, speech signal strength, and transmission. Codecs NetMeeting s default codec is G723.1, and it can operate at a sampling rate of 6400 or 5333 bits per second.  Other codecs that ship with NetMeeting include G.711 (uLaw or ALaw) and the L&H codecs. Advanced features of audio capture An advanced feature of audio capture is the ability for the user to select a particular codec to use in subsequent calls.  Manual codec selection doesn t always imply that the codec will be used.  Capabilities, bandwidth, and interoperability may require use of a different codec. The NetMeeting UI could benefit from notifications or polling mechanisms that indicate the audio stream status.  Information to indicate that a device failed to open and stream activation (on/off) would be beneficial. The NetMeeting team has experimented with different techniques of Acoustic Echo Cancellation (AEC) and speakerphone algorithms.  While it is desirable for AEC to be built into the hardware itself, a software approach built into TAPI would be beneficial to all NetMeeting users. Video playback NetMeeting renders the incoming video stream into a Remote Video window that can be docked/undocked in NetMeeting s main UI, as well as stretched. Audio playback Most of the functionality of audio recording that is described above also applies to audio playback.  NetMeeting currently supports audio playback through the older set of  WaveOut  APIs as well as through DirectSound (version 5 or later only). User interface stream controls Device Selection   NetMeeting only allows the use of playback devices that support the 8000-16 format.  This may change if a codec is available with a different sampling rate. Volume control   The playback volume can be set by the user. Pause control   the ability to pause the stream in order to achieve a mute effect. Full Duplex   Can be turned on or off.  As a requirement to support half-duplex, silence detection by the playback stream may be necessary. DirectSound NetMeeting users can gain the benefits of low latency audio if DirectSound (version 5 or later) is available.  NetMeeting 2.1 would default to using DirectSound if it was available.  However, many popular sound cards (Ensoniq, Gravis, Aztech) don t function well when used in full duplex mode with DirectSound available.  As a result of PSS complaints and other bug reports, a UI control to NetMeeting 3.0 has been added to turn DirectSound use off. s not unreasonable to require a compatible DirectSound sound card for multi-point playback. CPU and bandwidth usage monitoring NetMeeting also has its own internal QoS module that monitors CPU as well as local bandwidth usage. It is important to regulate CPU usage so that application sharing gets a higher share of the CPU than video streaming when run concurrently. It is also important that audio packets get higher priority than video packets when going over the wire. When journalists review, or people simply use NetMeeting, their machine is always responsive, even when application sharing, audio, and video streaming are occurring at the same time. Similarly, audio playback isn't cut when video bandwidth usage increases. H.245 commands and miscellaneous indications H.245 commands and indications provide a way for H.323 endpoints (including NetMeeting) to influence the behavior of other remote H.323 endpoints. Being able to send and receive temporal/spatial trade-off, flow control and frame update requests (among others) is crucial to NetMeeting. A temporal/spatial trade-off command allows users to modify the frame rate and video quality of incoming video streams. Fast update requests are generally issued when source switching occurs in multipoint applications, or packet loss has been detected by a remote endpoint, or a video incoming stream needs to be restarted. The flow control command is used to allow the bit rate of the video stream to be controlled by the remote endpoint. This has a number of purposes: interworking with terminals that only support a finite number of bit rates; multi-point applications where the rates from different sources should be matched; and flow control in congested networks. Functional requirements for TAPI 3.x This section summarizes the list of functionalities that TAPI is required to provide in order to achieve the same level of functionality than NetMeeting 2.11, and elaborates on the list of features required to make NetMeeting stronger on TAPI. Video capture Minimum feature set Legacy VfW and new WDM capture devices support Source dialog settings for VfW devices, VideoProcAmp and CameraControl dialogs for WDM devices On-the-fly video frame size changes Multiple capture device selection dialog Simple image size stretch (x2, x3, and x4) TAPI only features Hardware acceleration of capture in compressed format DirectDraw Blit and Stretch hardware acceleration for Local Video preview window Arbitrary size stretch Picture-In-Picture Multi-monitor support High-resolution still snapshots Audio recording Minimum feature set APIs and interfaces for: Device selection Controlling Duplex (full or half) Recording volume controls and AGC Silence threshold controls, including  automatic and adaptive  silence detection AutoMix microphone feature. Polling or notifications for signal level (for visual VU meter), device status, and stream status. Mute/Pause control of microphone and outgoing audio stream Codec Selection TAPI only features Acoustic echo cancellation Video playback Minimum feature set Simple image size stretch (x2, x3, and x4) TAPI only features Hardware decompression acceleration of incoming video stream DirectDraw Blit and Stretch hardware acceleration for Remote Video window Arbitrary size stretch Picture-In-Picture Multi-monitor support Audio playback Minimum feature set APIs and interfaces for: Device selection Playback volume controls Polling or notifications for signal level (for visual VU meter), device status, and stream status. Enabling/Disabling of DirectSound Mute/Pause control of incoming audio stream TAPI only features Multi-point audio and audio mixing CPU and bandwidth usage monitoring Minimum feature set Monitor CPU usage and adjust capture frame rate if necessary Monitor bandwidth usage and adjust compression ratio if necessary Use RSVP when available to reserve bandwidth Privilege audio packets over video packets when sent over the wire TAPI only features Use RTCP reports to monitor packet loss and modify the frame rate or compression ratio if necessary H.245 commands and indications Minimum feature set Issue and collect Temporal/Spatial trade-off command Issue and collect Flow Control command Issue and collect Fast Update Picture command TAPI only features Issue and collect Fast Update Group Of Blocks command Issue and collect Fast Update Macro-Blocks command References NetMeeting specification documents can be found on the NetMeeting team web site at  HYPERLINK "/hwdev/desinit/" http://mnmweb/  Unless stated otherwise all references to NetMeeting apply to version 3.0 Microsoft Corporation Company Confidential  DATE  06/26/98        Draft - Microsoft Corporation Company Confidential      TIME  10:06 AM Revision 0.207            WDM Connection and Streaming Architecture Revision 0.0.  REVNUM  \* MERGEFORMAT              TITLE  \* MERGEFORMAT  NetMeeting and TAPI Integration  DATE  06/26/98            Microsoft Corporation Company Confidential            TIME  10:06 AM  DATE  06/26/98       Draft - Microsoft Corporation Company Confidential       TIME  10:06 AM Microsoft Corporation Company Confidential  DATE  06/26/98        Draft - Microsoft Corporation Confidential      TIME  10:06 AM ~{mkkikd ~{spmjgda^ }zwtqnkh ytoa[SKC vspm_SID zupb_\YVH ~ytf^VSPHMicrosoft Word Document MSWordDoc Word.Document.8Microsoft Corporation NetMeeting and TAPI Integration Requirements Title _PID_GUIDNetMeeting and TAPI Integration Requirements John Selbie Normal.dot John Selbie Microsoft Word 8.0bjbjt+t+ NetMeeting and TAPI Integration Requirements September 23, 1998 John Selbie and Philippe Ferriere This document is provided as an addendum to an earlier document entitled  NetMeeting and TAPI Integration Functional Overview .  The original document provided a list of audio/video features that NetMeeting currently supported as well as additional features being considered for a future release. In order for NetMeeting to be at parity through TAPI as it is today requires that TAPI implement the majority of the features discussed below. The list of requirements only addresses areas relating to audio and video streaming.  It does not address other TAPI issues such as T.120, MCU, gateway, or gatekeeper support. Audio Minimum Feature Set For NetMeeting to continue to provide the same audio features through TAPI that it has today, TAPI must provide the following types of APIs and interfaces. Device selection This has already been implemented.  The application can simply enumerate all the available terminals for a given address object and provide the user with a list to choose from. Need support for system policies on devices An OEM or ISS manager may want to configure a machine with a registry key or system policy editor to disallow certain terminals from being used.  An example scenario would be to prevent the user from accidentally choosing a voice modem that also supports a WAVE device as the terminal to use in an audio call. Controlling Duplex (full or half) While most all devices support full duplex operations, some users prefer a half-duplex experience to eliminate problems with echo. Recording volume controls and AGC Currently, NetMeeting performs volume control through the mixer APIs provided by MMSYSTEM.DLL (e.g.  mixerOpen ).  Not only does NetMeeting provide volume and gain controls, but also un-mutes the Wave and Speaker volume controls as well as insures the microphone input is enabled. Silence threshold controls, including  automatic and adaptive  silence detection TAPI should provide auto-silence detection by default and provide an interface method such that the application can specify it s own silence threshold. AutoMix microphone feature This is NetMeeting s version of AGC.  The microphone gain is lowered when clipping is detected and raised during low input levels. Polling or notifications for signal level (for visual VU meter), device status, and stream status. A method on the audio terminals is needed to find out what the current signal level is such that a visual  VU meter  can be implemented. TAPI issues TE_TERMINAL/TME_FAILED if an audio device fails to open.  NetMeeting could inform the user when this condition occurs.  Being able to receive notifications when a stream is paused or stopped (due to call control commands from the other side) would also be helpful. TAPI does not deliver TE_CALLMEDIA notifications consistently.  For example, if the receive video stream does not get negotiated when the call starts up, but does get established later, the notification through the ITTAPIEventNotification interface gets sent.  If the channel got started at call connect time, the notification never gets sent.  It would be preferable if the UI always got these kinds of notifications delivered to it. Ability to pause audio streams Some sound card drivers may not support a mute function on their mixers, so the ability to specify a  pause  operation to the capture and render terminals is needed.  In the case of pausing a incoming stream, this operation could be tied to a remote signaling operation in call control. Ability to mute independent streams in a multi-point conference Codec Selection An application should have a way to enumerate over all the available codecs (e.g. G711 and G723).  It should also be allowed to specify which is the preferred codec.  Failure to use or negotiate the preferred codec should not cause an error.  In this case, TAPI should pick a more appropriate codec. Other advanced features that may be exposed through TAPI These are features that NetMeeting would like to have in the future. Acoustic echo cancellation Jay Stokes has been consulting with both the NetMeeting and TAPI teams on how to provide this functionality once the PictureTel code is licensed. Video Minimum Feature Set For NetMeeting to continue to provide the same audio features through TAPI that is does today, TAPI must provide the following types of APIs and interfaces. Legacy VFW and new WDM capture devices support TAPI should provide video capture terminals corresponding to all VFW and WDM capture drivers.  The ability to enumerate the available terminals appears to already exist. Source dialog settings for VFW devices, and expose interfaces for WDM drivers. Older VFW drivers provide their own  source  and  format  dialog boxes for the user to configure the hardware.  An application will need a way to display such dialogs. For newer WDM drivers, exposing IAMVideoControl, IAMVideoProcAmp, IAMCameraControl, and IAMXBar interfaces will be sufficient.  TAPI may elect to implement their own dialogs for these controls to be consistent with the activation of VFW dialogs. On-the-fly video frame size changes (QCIF, CIF, SQCIF) An application should be able to enumerate all the available formats and apply size changes to the active send stream Multiple capture device selection dialog Already implemented via enumeration methods (ITTerminalSupport). Simple image size stretch (x2, x3, and x4) The application should be able to enlarge video capture or receive windows to an integral multiple of the frame size that is actually being sent or received.  Video preview while not in a call Currently, TAPI does not provide a way for an application to preview local video while not in a call. Signaling for remote pausing If A pauses remote video, message (H.245) should be sent to B so that B can stop streaming.  Likewise, when the stream becomes started again, the remote sender should start streaming again. Codec Selection An application should have a way to enumerate over all the available codecs (e.g. G263 and G261).  It should also be allowed to specify which is the preferred codec.  Failure to use or negotiate the preferred codec should not cause an error.  In this case, TAPI should pick a more appropriate codec. Interface methods to control frame rate, bitrates Currently, TAPI is optimized for 16 kbits/sec video transmission.  This results in poor quality on LAN settings.  TAPI should expose methods such that the application can specify the following in regards to the type of video connections it wants to have: Set preview frame rate and send frame rate independently Set render frame rate independent of the receive frame rate Set maximum receive and send bitrates Provides support for  System policies  (codec, device, and QOS restrictions) Other advanced video features that may be exposed through TAPI These are features that NetMeeting would like to have available in the future.  The ability to query for support, enable, and disable these features should be considered as well. Hardware acceleration of capture in compressed format DirectDraw Blit and Stretch hardware acceleration for Local Video preview window Arbitrary size stretch Picture-In-Picture Multiple-monitor support High-resolution still snapshots The ability to query for support and trigger a request from the send or receive side H.245 commands and indications Minimum Feature Set Issue and collect Temporal/Spatial trade-off command TAPI should provide a simple interface to set either quality parameter or latency parameter to control overall call quality. Issue and collect Flow Control command Cf. Set maximum bitrate on send and receive Remote signaling for pausing channels (as mentioned above in audio and video sections) TITLE  \* MERGEFORMAT  Review of NetMeeting Requirements  SUBJECT  \* MERGEFORMAT  Audio and Video Streaming Functional Specification   Draft Author:   AUTHOR  \* MERGEFORMAT  Philippe Ferriere, Mu Han, Andres Vega-Garcia Revision 0.1.24,   DATE \@ "d MMMM, yyyy" \* MERGEFORMAT  13 October, 1998 This documentation is an early release of the final product documentation. It is meant to accompany software that is still in development. Some of the information in this documentation may be inaccurate or may not be an accurate representation of the functionality of the final retail product. Microsoft assumes no responsibility for any damages that might occur either directly or indirectly from these inaccuracies.  TOC \o "1-4"  Introduction  PAGEREF _Toc432931457 \h  Document organization  PAGEREF _Toc432931458 \h  Video requirements  PAGEREF _Toc432931459 \h  Legacy VFW and new WDM capture device support  PAGEREF _Toc432931460 \h  3.1.1 Analysis  PAGEREF _Toc432931461 \h  3.1.2 Time estimates  PAGEREF _Toc432931462 \h  Source dialogs for VfW devices, expose WDM driver interfaces  PAGEREF _Toc432931463 \h  3.2.1 Analysis  PAGEREF _Toc432931464 \h  3.2.2 Time estimates  PAGEREF _Toc432931465 \h  On-the-fly video frame size changes (QCIF, CIF, SQCIF)  PAGEREF _Toc432931466 \h  3.3.1 Analysis  PAGEREF _Toc432931467 \h  3.3.2 External dependencies  PAGEREF _Toc432931468 \h  3.3.3 Time estimates  PAGEREF _Toc432931469 \h  Multiple capture device selection dialog  PAGEREF _Toc432931470 \h  3.4.1 Analysis  PAGEREF _Toc432931471 \h  3.4.2 Time estimates  PAGEREF _Toc432931472 \h  Simple image size stretch (x2, x3, and x4)  PAGEREF _Toc432931473 \h  3.5.1 Analysis  PAGEREF _Toc432931474 \h  3.5.2 Time estimates  PAGEREF _Toc432931475 \h  Video preview while not in a call  PAGEREF _Toc432931476 \h  3.6.1 Analysis  PAGEREF _Toc432931477 \h  3.6.2 Time estimates  PAGEREF _Toc432931478 \h  Signaling for remote pausing  PAGEREF _Toc432931479 \h  3.7.1 Analysis  PAGEREF _Toc432931480 \h  3.7.2 Time estimates  PAGEREF _Toc432931481 \h  Video codec selection  PAGEREF _Toc432931482 \h  3.8.1 Analysis  PAGEREF _Toc432931483 \h  3.8.2 Time estimates  PAGEREF _Toc432931484 \h  Interface methods to control frame rate, bitrates, and video quality  PAGEREF _Toc432931485 \h  3.9.1 Analysis  PAGEREF _Toc432931486 \h  3.9.2 Time estimates  PAGEREF _Toc432931487 \h  Other advanced video features that may be exposed through TAPI  PAGEREF _Toc432931488 \h  3.10.1 Analysis  PAGEREF _Toc432931489 \h  3.10.2 Time estimates  PAGEREF _Toc432931490 \h  Audio requirements  PAGEREF _Toc432931491 \h  Audio device selection  PAGEREF _Toc432931492 \h  4.1.1 Analysis  PAGEREF _Toc432931493 \h  4.1.2 External dependencies  PAGEREF _Toc432931494 \h  4.1.3 Time estimates  PAGEREF _Toc432931495 \h  Support for system policies on audio devices  PAGEREF _Toc432931496 \h  4.2.1 Analysis  PAGEREF _Toc432931497 \h  4.2.2 Time estimates  PAGEREF _Toc432931498 \h  Duplex control (full or half)  PAGEREF _Toc432931499 \h  4.3.1 Analysis  PAGEREF _Toc432931500 \h  4.3.2 External dependencies  PAGEREF _Toc432931501 \h  4.3.3 Time estimates  PAGEREF _Toc432931502 \h  Recording volume controls and AGC  PAGEREF _Toc432931503 \h  4.4.1 Analysis  PAGEREF _Toc432931504 \h  4.4.2 Time estimates  PAGEREF _Toc432931505 \h  Silence threshold controls, including "automatic and adaptive" silence detection  PAGEREF _Toc432931506 \h  4.5.1 Analysis  PAGEREF _Toc432931507 \h  4.5.2 Time estimates  PAGEREF _Toc432931508 \h  AutoMix microphone feature  PAGEREF _Toc432931509 \h  4.6.1 Analysis  PAGEREF _Toc432931510 \h  4.6.2 Time estimates  PAGEREF _Toc432931511 \h  Polling or notifications for signal level (for visual VU meter), device status, and stream status  PAGEREF _Toc432931512 \h  4.7.1 Analysis  PAGEREF _Toc432931513 \h  4.7.2 Time estimates  PAGEREF _Toc432931514 \h  Ability to pause audio streams  PAGEREF _Toc432931515 \h  4.8.1 Analysis  PAGEREF _Toc432931516 \h  4.8.2 Time estimates  PAGEREF _Toc432931517 \h  Audio codec selection  PAGEREF _Toc432931518 \h  4.9.1 Analysis  PAGEREF _Toc432931519 \h  4.9.2 Time estimates  PAGEREF _Toc432931520 \h  Acoustic echo cancellation  PAGEREF _Toc432931521 \h  4.10.1 Analysis  PAGEREF _Toc432931522 \h  4.10.2 External dependencies  PAGEREF _Toc432931523 \h  4.10.3 Time estimates  PAGEREF _Toc432931524 \h  References  PAGEREF _Toc432931525 \h  Introduction NetMeeting s requirements relate to video and audio streaming, as well as H.245 call control. They do not address related issues such as T.120, MCU, gateway or gatekeeper support. We address each of the audio and video areas independently. The call control requirements have been merged with the appropriate audio and video requirements. We describe the list of interfaces that need to be supported by the TAPI 3.1 COM objects to meet each of the requirements, without going into the details of each of those interfaces. This list of interfaces is used to understand how the TAPI 3.1 stream objects need to be modified. Based on this analysis, generate estimates on the amount of work needed to fully characterize those interfaces, and add support for these interfaces in the TAPI 3.1 framework architecture. Current estimates for architectural and implementation work are summarized in the following table (details appear in each of the sections of this document). Two milestones are defined. M1 describes work that will be done by the TAPI 3.1 team in our first deliverable, M2 relates to features that will only appear in a later deliverable: NetMeeting Requirement Legacy VfW and new WDM capture device support Source dialogs for VfW devices, expose WDM driver interfaces On-the-fly video frame size changes (QCIF, CIF, SQCIF) Multiple capture device selection dialog Simple image size stretch (x2, x3, and x4) Video preview while not in a call Signaling for remote pausing Video codec selection Interface methods to control frame rate, bitrates and video quality Hardware Acceleration of capture High-Resolution snapshots Audio device selection Support for system policies on audio devices Duplex control (full or half) Recording volume controls and AGC Silence threshold controls, including  automatic\adpative  silence detection AutoMix microphone feature Polling or notifications for signal level, device status, and stream status AutoMix microphone feature Ability to pause audio streams Audio codec selection Acoustic echo cancellation Total Note that most of the streaming work items have a dependency on DShow 7.0 s dynamic graph  capabilities currently scheduled to ship in May 1999. This list does not include any of the re-writing of the call control stacks as planned by Don and Mike. It is possible for us to meet all of the above NetMeeting requirements without any of those changes. Document organization Section   REF _Ref432476713 \r \h   of this document describes the list of interfaces that need to be implemented by video terminal and stream objects in order to answer NetMeeting s video requirements. Section   REF _Ref432476714 \r \h   enumerates the list of interfaces that need to be implemented by audio terminal and stream objects in order to enable NetMeeting s audio requirements. Video requirements This section deals with VfW and WDM video capture device selection and configuration, stream format configuration and codec selection, video render control, supporting video preview outside of a call, frame rate and bitrate control, H.245 signaling, and advanced consumer features. We provide detailed analysis of the modules, interfaces and techniques TAPI 3.1 uses to answer this requirement. Legacy VFW and new WDM capture device support This NetMeeting requirement is described  as follows: TAPI should provide video capture terminals corresponding to all VFW and WDM capture drivers. The ability to enumerate the available terminals appears to already exist. Analysis s Address object exposes the ITTerminalSupport interface. Applications such as NetMeeting can use the EnumerateStaticTerminals  method on this interface to get an IEnumTerminal device enumerating interface. This interface will enumerate the terminal objects, returning a pointer to their ITTerminal interface. The application is then responsible for calling get_MediaType on the ITTerminal interface to discriminate between audio and capture devices. The quality and performance expectations behind this requirement imply that the TAPI team implements its own video capture source filter in order to provide: Optimized support for any VfW or WDM device, based on a knowledge base of their capabilities Size conversion operations from VfW to ITU-T size Format conversions (MJPEG to I420 for instance) when codecs do not support the capture device native type The H.263 and H.261 NetMeeting and TAPI codec code bases need to be merged. The NetMeeting code base supports many more input formats, and processing operations such as cropping of image data. Both code bases contain bug fixes that need to be consolidated in the Video Encoder and Video Decoder filters. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate Video Capture Source Filter Architecture 2 days Implementation 10 days Video Encoder Filter Architecture 1 day Implementation 5 days Video Decoder Filter Architecture 1 day Implementation 5 days Total 24 days Source dialogs for VfW devices, expose WDM driver interfaces This NetMeeting requirement is described as follows: Older VFW drivers provide their own "source" and "format" dialog boxes for the user to configure the hardware. An application will need a way to display such dialogs. For newer WDM drivers, exposing IAMVideoControl, IAMVideoProcAmp, IAMCameraControl, and IAMXBar interfaces will be sufficient. TAPI may elect to implement their own dialogs for these controls to be consistent with the activation of VFW dialogs. Analysis In order to support this requirement, we define new control interfaces on the Local Video Stream object. The Local Video Stream object, on top of the ITStream interface, will expose the ITCrossbar, ITVideoProcAmp, ITCameraControl, ITVideoControl and ITVfWCaptureDialogs interfaces. In the case of the H.323 and H.324 MSP, those interfaces directly map to the corresponding DirectShow interfaces implemented by either the Video Capture Source filter or the Video Encoder filter. Those interfaces cannot be implemented on the Terminal object since they may be implemented by the Video Encoder Filter, when not implemented by the Video Capture Source Filter. There is little work required in the specification of these interfaces: they will have the same methods, method parameters and return values than their DirectShow counterpart. Most of the work lies in adding support for these interfaces in the Local Video Stream object, and implement those interfaces on the Video Capture Source filter and Video Encoder filter. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate Local Video Stream object Architecture 1 day Implementation 2 days Video Capture Source Filter Architecture 1 days Implementation 2 days Video Encoder Filter Architecture 1 days Implementation 2 days Total 9 days On-the-fly video frame size changes (QCIF, CIF, SQCIF) This NetMeeting requirement is described as follows: An application should be able to enumerate all the available formats and apply size changes to the active send stream. Analysis In order to support this requirement, we define a new stream configuration interface on the Local Video Send Substream and Local Video Preview Substream objects. The stream objects, on top of the ITSubStream interface, implement the ITFormatControl interface. In the case of the H.323 and H.324 MSP, those interfaces will be implemented using the DirectShow IAMStreamConfig interface on one or more output pins. In the case of the Local Video Send Substream object, this interface is implemented by calling IAMStreamConfig::SetFormat on the Video Capture pin of the Video Capture Source filter, and the Compressed Video Output pin of the Video Encoder filter. The Local Video Preview Substream object calls the IAMStreamConfig interface exposed by the Video Preview Pin of the Video Capture Source Filter. Those interfaces cannot be implemented on the Terminal object since they may be implemented by the output pin of the Video Encoder filter, the preview and capture pins of the Video Capture Source filter. The Terminal object does not make any distinctions between preview and capture pins, nor has access to the Video Encoder filter compressed output pin. There is little work required in the specification of this interface: it will have the same methods, method parameters and return values than its DirectShow counterpart (IAMStreamConfig). Most of the work lies in adding support for the ITFormatControl on the Substreams, call the appropriate IAMStreamConfig interfaces on the output pins of the Video Encoder filter and the Video Capture Source Filter. We still need to make sure that there isn t any discrepancy between the formats applied on the capture device and the encoder filter. If the capture device does not expose a Preview pin, the Video Capture Source Filter will implement a teeing mechanism and resolve discrepancies between the formats set on the Preview pin and the Capture pin (different image sizes We need to implement our own allocators to make the best usage of memory for the video buffers and still allow very fast switching between different image sizes. External dependencies In order for this scheme to work smoothly, we will require new version of DShow that supports dynamic format changes. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate Interface and allocator Architecture 1 day Implementation 4 days Video Capture Filter internal tee Architecture 1 day Implementation 4 days Total 10 days Multiple capture device selection dialog This NetMeeting requirement is described as follows: Already implemented via enumeration methods (ITTerminalSupport). Analysis As explained earlier, TAPI s Address object exposes the ITTerminalSupport interface. Applications such as NetMeeting can use the EnumerateStaticTerminals  method on this interface to get an IEnumTerminal device enumerating interface. This interface will enumerate the terminal objects, returning a pointer to their ITTerminal interface. The application needs to  call get_MediaType on the ITTerminal interface to discriminate between audio and capture devices. The application is also responsible for implementing the right UI dialog to expose the list of devices to the user. Time estimates There is no work planned in this area. Simple image size stretch (x2, x3, and x4) This NetMeeting requirement is described as follows: The application should be able to enlarge video capture or receive windows to an integral multiple of the frame size that is actually being sent or received. Analysis The terminal object already implements the IBasicVideo interface. Applications can already use this DirectShow interface to control how the video data should be rendered. The methods on this interface allow for stretching video to an arbitrary size. Time estimates There is no work planned in this area. Video preview while not in a call This NetMeeting requirement is described as follows: Currently, TAPI does not provide a way for an application to preview local video while not in a call. Analysis TAPI 3.1 exposes two new steam objects called a Stream and a Substream. The local video preview will be exposed as a Substream of the Local Video Stream object. The Local Video Preview Substream will implement ITFrameRateControl, ITCPUControl and ITFormatControl. We already have the means to add the right chain of filters in the filter graph to provide the Preview functionality (connect Preview output pin of the video encode filter to input pin of video render terminal). Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate Interface work Architecture 2 days Implementation 4 days Total 6 days Signaling for remote pausing This NetMeeting requirement is described as follows: If A pauses remote video, message (H.245) should be sent to B so that B can stop streaming. Likewise, when the stream becomes started again, the remote sender should start streaming again. Analysis The application can pause a stream locally by calling the ITStream::PauseStream or ITStream::StopStream method. The filters will stop passing samples but the channel stays open. The packets sent from the other party will get dropped. By default, the stream object will issue an H.245 command to pause the remote endpoint. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate Add H245 specific interface Architecture 1 day Implementation 3 days Total 4 days Video codec selection This NetMeeting requirement is described as follows: An application should have a way to enumerate over all the available codecs (e.g. H263 and H261). It should also be allowed to specify which is the preferred codec. Failure to use or negotiate the preferred codec should not cause an error. In this case, TAPI should pick a more appropriate codec. Analysis This is handled by enumerating supported formats on the stream object via the ITFormatControl interface. This interface also allows the application to query for and set a new format on the stream. Most of the work lies in adding support for the ITFormatControl on the Local Video Send substream, call the appropriate IAMStreamConfig interfaces on the output pins of the Video Encoder filter and the Video Capture Source Filter. We still need to make sure that there isn t any discrepancy between the formats applied on the capture device and the encoder filter. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate ITFomatControl interface Architecture 2 days Implementation 6 days Total 8 days Interface methods to control frame rate, bitrates, and video quality This NetMeeting requirement is described as follows: Currently, TAPI is optimized for 16 kbits/sec video transmission. This results in poor quality on LAN settings. TAPI should expose methods such that the application can specify the following in regards to the type of video connections it wants to have: Set preview frame rate and send frame rate independently Set render frame rate independent of the receive frame rate Set maximum receive and send bitrates Provides support for "System policies" (codec, device, and QoS restrictions) Issue and collect Flow Control commands TAPI should provide a simple interface to set either quality parameter or latency parameter to control overall call quality Analysis In order to support this requirement the Local Video Send Substream and Local Video Preview Substream need to expose the ITFrameRateControl, ITBitrateControl and ITCPUControl interfaces. The Video Preview and Video Capture output pins of the Capture Source filter, as well as the Compressed Video output pin of the Video Encoder filter need to implement the IFrameRateControl, IBitrateControl and ICPUControl interfaces. Those interfaces will not be directly called by the application but will have to go through the QoS module first, in order to be checked. The QoS module will then call the control interfaces on the pins based on its current knowledge of CPU, network bandwidth availability and user preferences. The QoS module may call these interfaces if it determines that an adjustment in the filter parameters needs to be made, e.g. when a user preference is violated or to improve quality. An example is when the loss rate goes too high and the output bit rate needs to be decreased, or when the CPU usage is going above the upper limit and the frame rate has to be decreased or the time to encode a single frame has to be reduced. The Remote Video Stream will also need to expose the ITFrameRateControl, ITBitrateControl and ITCPUControl interfaces. The ITBitrateControl will be implemented by the stream object by issuing an Flow Control H.245 command. The ITFrameRateControl and ITCPUControl interfaces will be implemented by the QoS module, that will in turn call IFrameRateControl and ICPUControl interface methods on the output pin of the Video Decoder filter, if needed. The Local Video Send Substream and Remote Video substream will expose an ITQualityControl interface. This interface will allow the application to control the quality of the outgoing or incoming video stream. The Local Video Send Substream will implement this interface by calling IFrameRateControl on the Video Capture pin and\or IBitrateControl on the Compressed Video output pin. The call control module needs to allow the streams to issue H.245 command, and be able to dispatch incoming call control commands to the streams. We will not provide a mechanism for system policies. The application is responsible for doing this work. On the other hand, we will implement all the bitrate, frame rate, and CPU control interfaces to support those policies. In order to provide a high-level of performances, and support our new filter and RTP packetization model we need to rewrite the RTP and Demux filters, remove the SPH and RPH filters and move those functionality into the RTP filters. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate Control interfaces work Architecture 3 days Implementation 10 days QoS module work Architecture 4 days Implementation 8 days Support for H.245 commands and indications Architecture 1 day Implementation 2 days All RTP work Architecture 15 days RTP\RTCP base Implementation 20 days GQoS support Implementation 10 days Security Implementation 10 days Demux Implementation 5 days SPH/RPH Implementation 5 days Dejitter Implementation 5 days Total 98 days Other advanced video features that may be exposed through TAPI This NetMeeting requirement is described as follows: These are features that NetMeeting would like to have available in the future. The ability to query for support, enable, and disable these features should be considered as well: Hardware acceleration of capture in compressed format DirectDraw Blit and Stretch hardware acceleration for Local Video preview window Arbitrary size stretch Picture-In-Picture Multiple-monitor support High-resolution still snapshots The ability to query for support and trigger a request from the send or receive side Analysis Our Video Render terminal expose the IBasicVideo and IVideoWindow interfaces. Those interfaces can already be used by applications to provide arbitrary size stretch, picture-in-picture and automatic blit and stretch acceleration through DirectDraw. Hardware acceleration or capture in compressed format requires modifications of the Capture source filter to understand H.261 and H.263 types. The MSP also needs to understand that it shouldn t connect the Capture Source filter to a Video Encoder filter. High-resolution still snapshots adding support for Progressive Refinement commands and add the proper code in the H.26x encoders. We need to also create a special pin on the Capture Source filter to generate hgh-resolution images Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate Hardware Acceleration of capture Architecture 5 days Implementation 15 days High-resolution snaphots Architecture 5 days Implementation 15 days Total 40 days Audio requirements This section deals with audio recording and playback device selection and configuration, stream configuration, H.245 signaling, codec selection, and advanced consumer features. We provide an overview of the modules, interfaces and techniques TAPI 3.1 uses to answer this requirement. Audio device selection This NetMeeting requirement is described as follows: This has already been implemented. The application can simply enumerate all the available terminals for a given address object and provide the user with a list to choose from. Analysis In NT5, one piece of audio hardware might show up as three devices, wave, Direct Sound, and WDM. If the WDM device is available, it can be used with the kmixer proxy filter and provide the best performance. If WDM is not available, Direct Sound would be a good choice because it provides mixing with system sound. The only problem with Direct Sound is that it might be emulated on top of wave. In this case, using the wave directly might be better.  The terminal enumeration will be based on the hardware devices. The actual driver in use will be selected by the MSP automatically. There will also be extra interface where the app can make its own choice of driver if it really wants to do so. External dependencies How to determine the devices enumerated are using the same hardware. DShow devenum issue. How to find out if the Direct Sound is emulated. DShow devenum issue. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate A smart enumeration Architecture 3 days Implementation 5 days Direct Sound support in MSP Architecture 2 days Implementation 3 days WDM and Kmixer support in MSP Architecture 2 Days Implementation 3 Days Total 18 days Support for system policies on audio devices This NetMeeting requirement is described as follows: An OEM or ISS manager may want to configure a machine with a registry key or system policy editor to disallow certain terminals from being used. An example scenario would be to prevent the user from accidentally choosing a voice modem that also supports a WAVE device as the terminal to use in an audio call. Analysis This is an application issue, not a platform issue. TAPI will always return an exhaustive list of enabled audio devices installed on the machine. The application is responsible to decide it the device should be made available to the user. Time estimates There is no work planned in this area. Duplex control (full or half) This NetMeeting requirement is described as follows: While most all devices support full duplex operations, some users prefer a half-duplex experience to eliminate problems with echo. Analysis The feature requires that whenever we are rendering sound, the capture needs to be paused. A straightforward solution is to send two events from the audio render filter. One event is RENDERING_START. The filter sends the event the render queue change from empty to not empty. The other is RENDERING_STOP when the render queue gets empty. We also need to provide an interface to allow the application to query for support for Half or Full Duplex, query for the current mode, and set the duplex mode to Half or Full-Duplex. In addition, the half-duplex may have 2 modes of operation, 1) the capture device is muted whenever there are incoming packets, and 2) the incoming packets are discarded whenever the user wants to be in send mode. Discarding packets can be done in the network filters on each direction and 2 events are required from the source network filter, RTP_SSRC_ACTIVE and RTP_SSRC_IDLE, to signal when a participant is sending data (incoming packets) and when it stops doing so. External dependencies DShow needs to modify the audio render filter to fire the events. If they don t do it, we could get the code and do this ourselves. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate Using the new event in MSP Architecture 1 day Implementation 1 day Add duplex control interface to the stream object Architecture 1 day Implementation 2 days If we need to modify the renderer ourselves Analysis 5 days Implementation 1 day Mute receiver and add events Analysis 3 days Implementation 4 days Total 18 days Recording volume controls and AGC This NetMeeting requirement is described as follows: Currently, NetMeeting performs volume control through the mixer APIs provided by MMSYSTEM.DLL (e.g. "mixerOpen"). Not only does NetMeeting provide volume and gain controls, but also un-mutes the Wave and Speaker volume controls as well as insures the microphone input is enabled. Analysis The Audio capture terminal will support the IAMAudioInputMix interface to control the recording volume. It will also support an interface so that the app can enumerate the input channels and configure them. The input channels will also support the IAMAudioInputMix interface. AGC is one of the method in IAMAudioInputMix interface. If the hardware supports it, it will return success. We just need to verify that it is working. If the hardware doesn t support it, the application will be able to query for it on the stream object to get a software-only emulated AGC. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate Enable the audio input interfaces Architecture 2 days Implementation 5 days Total 7 days Silence threshold controls, including "automatic and adaptive" silence detection This NetMeeting requirement is described as follows: TAPI should provide auto-silence detection by default and provide an interface method such that the application can specify it's own silence threshold. Analysis The stream object needs to provide a new interface to enable this.  We also need to define an interface for these features that can be supported by an output pin. If the encoder supports all the functionality, it will support this interface and the stream object uses this interface. If the encoder doesn t support it, a silence suppression filter will be inserted and it will deal with this functionality. If it is a hardware-accelerated capture+encoder, it is required to support this interface. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate Add interface to the stream object Architecture 1 days Implementation 2 days Add support to silence suppressor Architecture 1 days Implementation 2 days Total 6 days AutoMix microphone feature This NetMeeting requirement is described as follows: This is NetMeeting's version of AGC. The microphone gain is lowered when clipping is detected and raised during low input levels. Analysis The software AGC will be supported on the stream object. The stream object will configure the encoder or the silence suppressor to do it. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate Add AGC support to silence suppressor Architecture 2 days Implementation 5 days Total 7 days Polling or notifications for signal level (for visual VU meter), device status, and stream status This NetMeeting requirement is described as follows: A method on the audio terminals is needed to find out what the current signal level is such that a visual "VU meter" can be implemented. TAPI issues TE_TERMINAL/TME_FAILED if an audio device fails to open. NetMeeting could inform the user when this condition occurs. Being able to receive notifications when a stream is paused or stopped (due to call control commands from the other side) would also be helpful. TAPI does not deliver TE_CALLMEDIA notifications consistently. For example, if the receive video stream does not get negotiated when the call starts up, but does get established later, the notification through the ITTAPIEventNotification interface gets sent. If the channel got started at call connect time, the notification never gets sent. It would be preferable if the UI always got these kinds of notifications delivered to it. Analysis Similar to section 4.5, this method will be in the same interfaces where the app and stream can configure silence levels. The CME_STREAM_ACTIVE event is now fired on all streams, the app can listen to this event to find out when a stream is active. On the render side, the interface will only support the VU meter. The implementer will be the output pin of the decoder filter. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate Add the method to get the signal level Architecture 1 days Implementation 2 days Total 5 days Ability to pause audio streams This NetMeeting requirement is described as follows: Some sound card drivers may not support a mute function on their mixers, so the ability to specify a "pause" operation to the capture and render terminals is needed.  In the case of pausing a incoming stream, this operation could be tied to a remote signaling operation in call control. Ability to mute independent streams in a multi-point conference. Analysis The application can pause a stream locally by calling the ITStream::PauseStream or ITStream::StopStream method. The filters will stop passing samples but the channel stays open. The packets sent from the other party will get dropped. By default, the stream object will issue an H.245 command to pause the remote endpoint. When in a multicast conference, it is important to be able to mute individual participants because of different reasons. For example, that participant could be sending a disturbing noise or blank packets, that participant could be sending data we don t care to receive, we could be low in resources and want to discard that participant s data as soon as possible. In order to provide this functionality, the source network filters need the ability to mute specific sources.  In the case of an MCU supported multipoint call, we need special support from H.245 stack to control the MCU on a stream basis. We need to do some more research on how to implement this feature. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate Add H245 specific interface Architecture 2 days Implementation 3 days Mute specific SSRC RTP sources Architecture 2 days Implementation 2 days MCU based stream control Architecture 5 days Implementation 5 days Total 19 days Audio codec selection This NetMeeting requirement is described as follows: An application should have a way to enumerate over all the available codecs (e.g. G711 and G723). It should also be allowed to specify which is the preferred codec. Failure to use or negotiate the preferred codec should not cause an error. In this case, TAPI should pick a more appropriate codec. Analysis This is handled by enumerating supported formats on the stream object via the ITFormatControl interface. This interface also allows the application to query for and set a new format on the stream. We also need to develop a registration mechanism for audio encoders and decoders so that only the codecs registered with TAPI are exposed. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate ITFomatControl interface Architecture 3 days Implementation 5 days Total 8 days Acoustic echo cancellation This NetMeeting requirement is described as follows: This is a feature that NetMeeting would like to have in the future. Jay Stokes has been consulting with both the NetMeeting and TAPI teams on how to provide this functionality once the PictureTel code is licensed. Analysis Important parts of the architecture to support AEC are still being worked out. There are many issues due to the fact that there are two driver stacks (PortClass and Stream). We will have to wait for Jay Stoke to finalize his design work before we can expose this feature to applications. Still, there are many good reasons to anticipate the availability of this feature in the future. We need to create an interface to the stream to allow the application to query for AEC support, current mode, and set a new mode. If the AEC support algorithms enumeration, we will add an enumeration function to the interface. The application would be responsible for selecting the right algorithm. External dependencies Depends on the multimedia team to deliver the AEC. Time estimates The following table lists the work items required to answer NetMeeting s requirement: Component Work Item Time Estimate Add interface to use AEC Architecture 2 days Implementation 4 days Total 6 days References NetMeeting and TAPI Integration   Functional Overview  EMBED Word.Document.8 \s  NetMeeting and TAPI Integration Requirements  EMBED Word.Document.8 \s   All functional requirements are extracted from the NetMeeting documents included in the reference section. Microsoft Corporation Company Confidential  DATE  10/13/98        Draft - Microsoft Corporation Company Confidential      TIME  4:47 PM Microsoft Corporation Company Confidential  DATE  10/13/98        Draft - Microsoft Corporation Company Confidential      TIME  4:47 PM Revision 0.207            WDM Connection and Streaming Architecture Revision 0.1.  REVNUM  \* MERGEFORMAT              TITLE  \* MERGEFORMAT  Review of NetMeeting Requirements  DATE  10/13/98            Microsoft Corporation Company Confidential            TIME  4:47 PM  DATE  10/13/98       Draft - Microsoft Corporation Company Confidential       TIME  4:47 PM Microsoft Corporation Company Confidential  DATE  10/13/98        Draft - Microsoft Corporation Confidential      TIME  4:47 PM ~ytoje`[ ~ztqnkheb] }ytmf_[VO zvqjc\XS {voha]XQ zvqjc\XS ~{xurogda |wrmid] ~ytpkhZW {wrmhd_Z spmjgda^ |xsnie`[V }zwrnkh\ }vrmhc_ZU zvqjc_Z zuqle^Z |yvjgda^[XUR }xtojea\W zuqlgb^ }qnkheb_\N ~ytpkhe]Z zslhc^Y {wtqeb_\ vqlgc^W {wrmhd_ZU ~yupib^Y {wrkd` }olid_Z ~rolifc`] }ukgdaUR ~ytpkfa] rolgb]Y qnkhZW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\doc\microsoft tapi video encoder filter.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Don Ryan Microsoft Corporation Microsoft  TAPI  Video Encoder Filter Title _PID_GUID _PID_HLINKSMicrosoft  TAPI  Video Encoder Filter Streams and Interfaces Philippe Ferriere, Michael VanBuskirk NetMeeting Specification.dot Philippe Ferriere Microsoft Word 8.0IDATx @&Ep  Tup:E* X06og TfEwc n?,4.[@b kj4"pv  m$kNu w~=8\3 9)?y9 zti=h sP`(bc1@'Dp 8{$}9 V?o8R lpYQ& >8ocu <p8k` p4]%9 7)iV5 h*f!> 8de'O fUnpf yzJL/ ~IDAT TITLE  \* MERGEFORMAT  Microsoft  TAPI  Video Encoder Filter  SUBJECT  \* MERGEFORMAT  Streams and Interfaces Design Specification   Draft Author:   AUTHOR  \* MERGEFORMAT  Philippe Ferriere, Michael VanBuskirk Revision 0.4.148,   SAVEDATE \@ "d MMMM, yyyy" \* MERGEFORMAT  26 June, 1999 This documentation is an early release of the final product documentation. It is meant to accompany software that is still in development. Some of the information in this documentation may be inaccurate or may not be an accurate representation of the functionality of the final retail product. Microsoft assumes no responsibility for any damages that might occur either directly or indirectly from these inaccuracies.  TOC \o "1-4"  Introduction  PAGEREF _Toc455061536 \h  Intended audience  PAGEREF _Toc455061537 \h  Conventions  PAGEREF _Toc455061538 \h  Document organization  PAGEREF _Toc455061539 \h  Definition of terms  PAGEREF _Toc455061540 \h  TAPI local video architecture  PAGEREF _Toc455061541 \h  TAPI 3.0 overview  PAGEREF _Toc455061542 \h  Call and media controls  PAGEREF _Toc455061543 \h  3.2.1 TAPI 3.0 COM object  PAGEREF _Toc455061544 \h  3.2.2 TAPI server  PAGEREF _Toc455061545 \h  3.2.3 Call control functions  PAGEREF _Toc455061546 \h  3.2.4 Media control functions  PAGEREF _Toc455061547 \h  Local video filter graph  PAGEREF _Toc455061548 \h  Video encoder filter streams  PAGEREF _Toc455061549 \h  Video encoder filter video and still-image output streams  PAGEREF _Toc455061550 \h  Video encoder filter video preview output stream  PAGEREF _Toc455061551 \h  Video encoder filter RTP packetization descriptor output stream  PAGEREF _Toc455061552 \h  Video encoder filter input stream  PAGEREF _Toc455061553 \h  Video encoder filter stream formats  PAGEREF _Toc455061554 \h  Media type for H.26x compressed video and still-image streams  PAGEREF _Toc455061555 \h  5.1.1 Video info header structure for H.263 video streams  PAGEREF _Toc455061556 \h  5.1.2 Video info header structure for H.261 video streams  PAGEREF _Toc455061557 \h  5.1.3 Bitmap info header structure for H.263 video streams  PAGEREF _Toc455061558 \h  5.1.4 Bitmap info header structure for H.261 video streams  PAGEREF _Toc455061559 \h  Media type for RTP packetization descriptor streams  PAGEREF _Toc455061560 \h  5.2.1 Configuration capabilities structure for RTP packetization descriptor streams  PAGEREF _Toc455061561 \h  5.2.2 Information header structure for RTP packetization descriptor streams  PAGEREF _Toc455061562 \h  RTP packetization descriptor format  PAGEREF _Toc455061563 \h  RTP packetization descriptor and video streams synchronization  PAGEREF _Toc455061564 \h  Compressed video output pin TAPI interfaces  PAGEREF _Toc455061565 \h  IH245EncoderCommand interface  PAGEREF _Toc455061566 \h  6.1.1 videoFastUpdatePicture method  PAGEREF _Toc455061567 \h  6.1.2 videoFastUpdateGOB method  PAGEREF _Toc455061568 \h  6.1.3 videoFastUpdateMB method  PAGEREF _Toc455061569 \h  6.1.4 videoSendSyncEveryGOB and videoSendSyncEveryGOBCancel commands  PAGEREF _Toc455061570 \h  6.1.5 videoNotDecodedMBs indication  PAGEREF _Toc455061571 \h  6.1.6 FlowControl  PAGEREF _Toc455061572 \h  6.1.7 Temporal/Spatial trade-off  PAGEREF _Toc455061573 \h  6.1.8 H.245 mode requests  PAGEREF _Toc455061574 \h  INetworkStats interface  PAGEREF _Toc455061575 \h  6.2.1 SetChannelErrors method  PAGEREF _Toc455061576 \h  6.2.2 GetChannelErrors method  PAGEREF _Toc455061577 \h  6.2.3 SetPacketLossRate method  PAGEREF _Toc455061578 \h  6.2.4 GetPacketLossRate method  PAGEREF _Toc455061579 \h  ICPUControl interface  PAGEREF _Toc455061580 \h  6.3.1 SetMaxProcessingTime method  PAGEREF _Toc455061581 \h  6.3.2 GetMaxProcessingTime method  PAGEREF _Toc455061582 \h  6.3.3 SetMaxCPULoad method  PAGEREF _Toc455061583 \h  6.3.4 GetMaxCPULoad method  PAGEREF _Toc455061584 \h  IBitrateControl interface  PAGEREF _Toc455061585 \h  6.4.1 SetMaxBitrate method  PAGEREF _Toc455061586 \h  6.4.2 GetMaxBitrate method  PAGEREF _Toc455061587 \h  IProgressiveRefinement interface  PAGEREF _Toc455061588 \h  Compressed still-image output pin TAPI interfaces  PAGEREF _Toc455061589 \h  IProgressiveRefinement interface  PAGEREF _Toc455061590 \h  7.1.1 doOneProgression method  PAGEREF _Toc455061591 \h  7.1.2 doContinuousProgressions method  PAGEREF _Toc455061592 \h  7.1.3 doOneIndependentProgression method  PAGEREF _Toc455061593 \h  7.1.4 doContinuousIndependentProgressions method  PAGEREF _Toc455061594 \h  7.1.5 progressiveRefinementAbortOne method  PAGEREF _Toc455061595 \h  7.1.6 progressiveRefinementAbortContinuous method  PAGEREF _Toc455061596 \h  INetworkStats interface  PAGEREF _Toc455061597 \h  ICPUControl interface  PAGEREF _Toc455061598 \h  IBitrateControl interface  PAGEREF _Toc455061599 \h  RTP packetization descriptor output pin TAPI interface  PAGEREF _Toc455061600 \h  IRTPPDControl interface  PAGEREF _Toc455061601 \h  8.1.1 SetMaxRTPPacketSize method  PAGEREF _Toc455061602 \h  8.1.2 GetMaxRTPPacketSize method  PAGEREF _Toc455061603 \h  Video encoder filter application interfaces  PAGEREF _Toc455061604 \h  IAMVideoProcAmp interface  PAGEREF _Toc455061605 \h  9.1.1 VideoProcAmpProperty enumerated data type  PAGEREF _Toc455061606 \h  9.1.2 VideoProcAmpFlags enumerated data type  PAGEREF _Toc455061607 \h  9.1.3 GetRange method  PAGEREF _Toc455061608 \h  9.1.4 Set method  PAGEREF _Toc455061609 \h  9.1.5 Get method  PAGEREF _Toc455061610 \h  IAMCameraControl interface  PAGEREF _Toc455061611 \h  9.2.1 CameraControlProperty enumerated data type  PAGEREF _Toc455061612 \h  9.2.2 CameraControlFlags enumerated data type  PAGEREF _Toc455061613 \h  9.2.3 GetRange method  PAGEREF _Toc455061614 \h  9.2.4 Set method  PAGEREF _Toc455061615 \h  9.2.5 Get method  PAGEREF _Toc455061616 \h  IAMVideoControl interface  PAGEREF _Toc455061617 \h  9.3.1 VideoControlFlags enumerated data type  PAGEREF _Toc455061618 \h  9.3.2 GetCaps method  PAGEREF _Toc455061619 \h  9.3.3 SetMode method  PAGEREF _Toc455061620 \h  9.3.4 GetMode method  PAGEREF _Toc455061621 \h  Video encoder filter H.245 video capabilities  PAGEREF _Toc455061622 \h  Standard Codec addition or replacement  PAGEREF _Toc455061623 \h  Non-standard codec support  PAGEREF _Toc455061624 \h  10.2.1 Interpretation facilities provided by the installed codec filter  PAGEREF _Toc455061625 \h  10.2.2 Capability resolution/channel open mechanism  PAGEREF _Toc455061626 \h  IH245VideoCapability interface  PAGEREF _Toc455061627 \h  10.3.1 NegotiatedVideoLimit enumerated data type  PAGEREF _Toc455061628 \h  10.3.2 VideoResourceBounds structure  PAGEREF _Toc455061629 \h  10.3.3 H245VideoCapabilityMap structure  PAGEREF _Toc455061630 \h  10.3.4 H245VideoCapabilityTable structure  PAGEREF _Toc455061631 \h  10.3.5 GetH245VersionID method  PAGEREF _Toc455061632 \h  10.3.6 GetFormatTable method  PAGEREF _Toc455061633 \h  10.3.7 ReleaseFormatTable method  PAGEREF _Toc455061634 \h  10.3.8 IntersectFormats method  PAGEREF _Toc455061635 \h  10.3.9 GetLocalFormat method  PAGEREF _Toc455061636 \h  10.3.10 GetNegotiatedLimitProperty method  PAGEREF _Toc455061637 \h  10.3.11 ReleaseNegotiatedCapability method  PAGEREF _Toc455061638 \h  10.3.12 SetIDBase method  PAGEREF _Toc455061639 \h  10.3.13 FindIDByRange method  PAGEREF _Toc455061640 \h  References  PAGEREF _Toc455061641 \h  TAPI 3.1 Specifications  PAGEREF _Toc455061642 \h  DirectShow SDK articles and documentation  PAGEREF _Toc455061643 \h  ITU communications standards  PAGEREF _Toc455061644 \h  IETF Request for comments  PAGEREF _Toc455061645 \h  Introduction H.26x video encoders differ from traditional Microsoft  Windows  desktop video codecs: They need to encode in real-time The data they produce is typically fragmented in several network RTP packets They may need to handle or generate call control specific (H.245) commands They operate over unreliable communication channels using RTP/UDP/IP (H.323) They usually have many modes of operation (H.263 options) They are required to adjust their output bitrate dynamically They may implement different encoding algorithms in order to adapt their CPU usage In order to support all of the above features in the Microsoft  TAPI  environment, this document describes video encoder implementation requirements. The TAPI local video send stack relies on video encoders to expose two synchronized output pins using the DirectShow model. One of the two pins is responsible for producing data in H.26x format; the second one generates packetization descriptors to greatly facilitate network RTP fragmentation. The RTP packetization descriptors are streamed on a separate pin for the five following reasons: For each video (or audio) subformat existing today, definition of a corresponding new subformat would be necessary if the TAPI Network Send Filter were to collect compressed data and RTP packetization descriptors from a unique pin. Keeping them separate allows creating a single new format, for the RTP packetization descriptor stream. Video coding algorithms such as H.26x and MPEGx are stable ITU recommendations. Payload handlers are usually documented in RFCs and are not always concerned with backward compatibility. It wouldn t be wise to create yet another compressed subformat every single time a payload handler specification is revised. In the future, manufacturers of video display boards may implement hardware accelerators to speed up decompression and rendering of H.263 video data. Keeping the RTP packetization descriptors and the video data on separate pins allows the TAPI MSP and any DirectShow application to easily tee off the compressed video data directly to a hardware accelerated video renderer. RTP packetization descriptors are only useful when compressed data is to be sent over a network. Separating the compressed data from the packetization information allows for applications to use the same video encoder to store compressed data locally, on the user s hard disks if desired. Other networking or conferencing applications may chose to use different network protocols than RTP/UPD/IP to transmit their compressed data. We define a new H.245 command interface to communicate to the compressed video output pin of a video encoder requests for I-frame, group of blocks, or macro-block updates due to packet loss or multi-point switching. We describe extended bitmap info headers for H.261 and H.263 video streams to communicate to the compressed video output pin a list of optional mode of compressions supported by the remote endpoint. Still, the decision to use those modes is left to the video encoder. Video encoders may also expose interfaces to allow users to control video quality settings such as brightness, contrast, hue, saturation, gamma and sharpness, provided that the video encoder is capable of applying the necessary pre-processing operators. They may also expose an interface to simulate camera control functionality such as pan, tilt and zoom. Whenever they implement such features, they shall also expose a video output pin to allow users to preview the changes. Video encoders that support progressive refinement modes shall expose an interface on their compressed video output pin to allow for transmission of high-resolution stills that are continuously improved on the remote endpoint as more data is received and decompressed. They may also elect to implement this same interface on an optional separate and dedicated still-image output pin. We introduce a network statistics interface, to allow the network to provide feedback on the channel conditions to the compressed video output pin of a video encoder. The video encoder is responsible for taking appropriate actions, if needed. Video encoders shall be able to control their compressed output to reach target bitrate values provided dynamically by other streaming TAPI components. The video encoder shall be able to handle those operations while streaming, without stopping the streams. Video encoders should also try and control their CPU usage to encode a video frame within bounds (encoding time, and CPU load) provided by other monitoring TAPI components. Finally, video encoders shall implement a new H.245 capability interface. This interface provides the TAPI TSP/MSP call control components with information needed to resolve capabilities, and in the case of non-standard codecs, with facilities to interpret non-standard capability data. Intended audience The reader should have a good understanding of the DirectShow model and its operation, as well as ITU-T standards H.245, H.261 and H.263. Conventions In this document the following conventions are used: "Shall" indicates a mandatory requirement, "Should" indicates a suggested but optional course of action, "May" indicates an optional course of action rather than a recommendation that something take place. References to Sections, Paragraphs, Annexes, and Appendices refer to those items within this specification unless another document is explicitely listed. Document organization Section   REF _Ref420292803 \r \h   of this document defines the terms used in this video encoder filter specification. Section   REF _Ref420293040 \r \h   provides background information on the TAPI MSP and its graph building operation. Section   REF _Ref431462734 \r \h   describes the streams used and produced by the video encoder filter. Section   REF _Ref420293435 \r \h   describes the format structures used to describe the streams produced by the video encoder filter. Section   REF _Ref422391459 \r \h   describes the H.245 command (section   REF _Ref427959102 \r \h  ), network monitor (section   REF _Ref427926473 \r \h  ), CPU control (section   REF _Ref431461184 \r \h  ), and bandwidth control (section   REF _Ref431461225 \r \h  ) interfaces exposed by the compressed output pins of the video encoder filter. Section   REF _Ref431462814 \r \h   describes the progressive refinement interface exposed by the compressed video or still-image output pins of the video encoder filter. Section   REF _Ref431467990 \r \h   describes the control interface exposed by the RTP packetization descriptor output pin of the video encoder filter. Section   REF _Ref431468948 \r \h   describes the interfaces exposed by the video encoder filter to set video quality settings (section   REF _Ref427959429 \r \h  ) and simulated camera control capabilities (sections   REF _Ref429653644 \r \h   and   REF _Ref429653646 \r \h  Section   REF _Ref432249242 \r \h   describes the H.245 video capability interface exposed by the video encoder filter to enumerate, translate and compare video formats. Definition of terms Codec: Coder/Decoder. A filter for data that manipulates it in some form, usually by compressing or decompressing the data stream. Component Object Model (COM): The OLE object-oriented programming model that defines how objects interact within a single process or between processes. In COM, clients have access to an object through interfaces implemented on the object. See also Interface. COM Object: An object that conforms to the OLE Component Object Model (COM). A COM object is an instance of an object definition, which specifies the object's data and one or more implementations of interfaces on the object. Clients interact with a COM object only through its interfaces. See also Component Object Model and Interface. DirectShow: o receive data from an upstream filter. An upstream filter sends data from its output pin to the connected input pin of the downstream filter. Encoder Filter: A specialized type of transform filter. Encoder filters (compressors) accept data, use a compression scheme to transform the data, and pass the compressed data downstream. Filter: A key component in the DirectShow architecture, a filter is a COM object that supports DirectShow interfaces or base classes. It might operate on streams of data in a variety of ways, such as reading, copying, modifying, or writing the data to a file. Sources, transform filters, and renderers are all particular types of filters. A filter contains pins that it uses to connect to other filters. Filter Graph: A collection of filters. Typically, a filter graph contains filters that are connected to perform a particular operation, such as playing back a media file, or capturing video from a VCR to the hard disk. Format Type: A GUID value that indicates what a format block contains. DirectShow defines a number of major types, for example, the video type. These major types have a format block, such as VIDEOINFOHEADER, that describes the media data. The format block for a particular media type is specified by a GUID in the AM_MEDIA_TYPE structure. This GUID is called the format type. If the format block contains VIDEOINFOHEADER, the format type GUID will be FORMAT_VideoInfo. GOB: Group-Of-Blocks. In H.263, a GOB consists of a row of k*16 lines with k=1 for sub-QCIF, QCIF and CIF, k=2 for 4CIF and k=4 for 16CIF; thus there are 6GOBs for sub-QCIF, 9 for QCIF, and 18 for CIF, 4CIF, and 16CIF. Data for each GOB consists of a GOB header (which may be empty) followed by data for each of the macroblocks (MBs) contained in a GOB. GUID: A globally unique identifier used to uniquely identify objects, such as interfaces and plug-in distributors. Class identifiers (CLSIDs) and interface identifiers (IIDs) are GUIDs. H.245: ITU Recommendation H.245. This Recommendation specifies syntax and semantics of terminal information messages as well as procedures to use them for in-band negotiation at the start of or during communication. The messages cover receiving and transmitting capabilities as well as mode preference from the receiving end, logical channel signaling, and Control & Indication. Acknowledged signaling procedures are specified to ensure reliable audiovisual and data communication. H.261: ITU Recommendation H.261. This Recommendation describes the video coding and decoding methods for the moving picture component of audiovisual services at the rates of px64 kbit/s, where p is in the range 1 to 30. H.263: ITU Recommendation H.263. This Recommendation specifies a coded representation that can be used for compressing the moving picture component of audio-visual services at low bit rates. The basic configuration of the video source coding algorithm is based on Recommendation H.261 and is a hybrid of inter-picture prediction to utilize temporal redundancy and transform coding of the remaining signal to reduce spatial redundancy. The source coder can operate on five standardized video source formats. The decoder has motion compensation capability, allowing optional incorporation of this technique in the coder. Half pixel precision is used for the motion compensation, as opposed to Recommendation H.261 where full pixel precision and a loopfilter are used. Variable length coding is used for the symbols to be transmitted. In addition to the basic video source coding algorithm, negotiable coding options are included for improved compression performance and the support of additional capabilities. Additional supplemental information may also be included in the bitstream for enhanced display capability and for external usage. In-Process Server: A server implemented as a DLL that runs in the process space of the client. See also Out-of-process server, Local server, and Remote server. Input Pin: A pin that accepts data into the filter. Interface: A group of semantically related functions that provide access to a COM object. Each OLE interface defines a contract that allows objects to interact according to the Component Object Model (COM). See also Component Object Model and COM object. ITU: International Telecommunication Union. Keyframe: A frame of video data that contains all the data necessary to construct that frame. In contrast, delta frames contain data relating to changes from the last keyframe and do not contain enough information by themselves to construct a complete frame. Major Type: A GUID value that describes the overall class of media data for a data stream. Typical values are MEDIATYPE_Video, MEDIATYPE_Audio, MEDIATYPE_Text, and MEDIATYPE_Midi. MB: Macroblock. In H.263, like in MPEG1-2, it consists of a 16x16 block of Y, and corresponding 8x8 blocks of each of the two chrominance components. Method: A predefined interface function. Minor Type: See subtype (media type). MSP: Media Service Provider. A component in TAPI that handles media streams. Out-Of-Process Server: A server, implemented as an .EXE application, which runs outside the process of its client, either on the same machine or a remote machine. See also Local server and Remote server. Output Pin: A pin that provides data to other filters. Payload Data: The data transported by RTP in a packet for example compressed video data. Payload Header: For H.263 and H.261 RTP packets, the RTP fixed header is followed by the payload header, itself followed by the payload data. Pin: A COM object created by the filter that represents a point of connection for a data stream on the filter. Pins provide interfaces to connect with other pins and transport data. Input pins accept data into the filter, and output pins provide data to other filters. An input pin typically exposes the IPin and IMemInputPin interfaces. An output pin typically exposes the IPin, IMediaSeeking, and IQualityControl interfaces. A source filter provides one output pin for each stream of data in the file. A typical transform filter, such as a compression/decompression (codec) filter, provides one input pin and one output pin. Presentation Time: The stream time at which the packets of data that a filter receives should be presented downstream or rendered. When a filter graph runs, each filter is passed a start time according to the reference clock, and the packets of data that a filter receives will usually be time-stamped with the presentation time. Renderer: A filter that renders media data to any location that accepts media input. Most often, data is rendered to a computer monitor, sound card, or printer. Renderer filters have only input pins. Remote Server: A server application, implemented as an EXE, running on a different machine from the client application using it. See also In-process server, Local server, and Out-of-process server. RTP: Real-Time Transport Protocol. RTP provides end-to-end network transport functions suitable for applications transmitting real-time data, such as audio, video or simulation data, over multicast or unicast network services. Source Filter: A filter that takes data from some source such as the hard drive, network, or the Internet, and introduces it into the filter graph. Stream: A stream is identical to a DirectShow pin. A stream can accept data from or supply data to the processor, such as a stream representing an H.263 input, or can simply route data through hardware, such as a stream representing an NTSC output jack on the back of an adapter. Subtype (media type): A GUID value that describes the specific format of media data for a data stream. Typical values include MEDIASUBTYPE_MJPG, MEDIASUBTYPE_RGB8, MEDIASUBTYPE_RGB565, MEDIASUBTYPE_MPEGPacket, MEDIASUBTYPE_Avi, and MEDIASUBTYPE_WAVE. TAPI: Telephony API. TAPI is a set of APIs that enable applications to make PSTN and IP phone calls. Time Stamp: Time on a media sample indicating when it was recorded and when it should be scheduled for playback. Time stamps are measured in 100-nanosecond units (REFERENCE_TIME) and are normalized so that zero indicates when the graph is run. Transform Filter: A filter that takes data, processes it, and then passes it along to the next filter in the filter graph. Transform-Inplace Filter: A transform filter that can perform its operation in place (without copying data or altering the data's media type). Transport: The mechanism that channels audio data, video data, or both from an external device to the computer and from the computer to the external device. Upstream Filter: The filter that passes data from its output pin to the connected input pin of the next filter in the filter graph. TAPI local video architecture This section provides an overview of TAPI s video capture, encoding and send data path under the Windows 98 and Windows NT 5.0 operating systems. TAPI 3.0 overview TAPI version 3.0 is a set of COM-based APIs providing convergence of both traditional telephony and IP (Internet Protocol) Telephony.  IP Telephony enables voice, data and video collaboration over existing LANs, WANs and the Internet. TAPI 3.0 implements IP Telephony on the Windows platforms by providing simple and generic methods for making connections between two or more machines. TAPI 3.0 supports standards-based H.323 conferencing and IP Multicast conferencing, utilizing the Windows NT 5.0 Active Directory service to simplify deployment within an organization. Quality-of-service (QoS) support is included to improve conference quality and network manageability. Media stream access is provided through DirectShow filters. TAPI 3.0 PSTN and IP functionality is provided by three main sections: call and media controls, media stream controls, and directory controls. The following diagram illustrates how these controls interact with the telephone and IP networks. Call and media controls Call and media controls are a simple and generic set of methods for making calls between two or more machines. In the context of TAPI 3.0, the word call refers not just to voice transmission over the public switched telephone network (PSTN) but to any medium capable of transferring content.  TAPI 3.0 provides access to the media being transmitted through the use of DirectShow.  TAPI 3.0 abstracts both call and media functionality to allow different, and seemingly incompatible, communication protocols to expose a common interface to applications. Because TAPI 3.0 is based on the Component Object Model (COM), applications may be written in any language. Some interface methods may not be available to scripting languages such as VBScript. TAPI 3.0 call and media controls involve four primary sets of code: the TAPI 3.0 COM objects, the TAPI Server, Telephony Service Providers (TSPs), and Media Service Providers (MSPs). TAPI 3.0 COM object For background information on TAPI 3.0 COM objects, see the article titled Telephony Application Programming Interface, in the Platform SDK Documentation. TAPI server TAPI 3.0 is implemented as an in-process server and uses TAPISRV.EXE to perform telephony operations, thus making TAPI 3.0 applications compatible with all TAPI 2.1 service providers. The TAPI Server process (TAPISRV.EXE) abstracts TSPI (Telephony Service Provider Interface) from TAPI 3.0 and TAPI 2.1 and maintains the internal state of TAPI. Additional information concerning the TAPI Server and TSPI can be found in the article titled Telephony Application Programming Interface, in the Platform SDK Documentation. Call control functions Call-control functions are provided by a TSP. The TAPI 2.1 client/server relationship with remote service providers is supported. Telephony Service Providers are responsible for translating the protocol-independent call model of TAPI into protocol-specific call setup and teardown, on a service-by-service basis. TAPI 3.0 has backward compatibility with TAPI 2.1 TSPs. Two new IP Telephony Service Providers (and their associated Media Service Providers) ship by default with TAPI 3.0: the H.323 TSP and the IP Multicast Conferencing TSP.  Additional information concerning Telephony Service Providers can be found in the article titled Telephony Application Programming Interface, in the Platform SDK Documentation. Media control functions Media control functions are provided by an MSP that implements the DirectShow interfaces for a particular provider. Media Service Providers are required for any telephony service that makes use of DirectShow media streaming.  Local video filter graph The following illustration shows what DirectShow filters the MSP typically connects in a filter graph to provide the local video send functionality, and the interfaces the MSP Video Encoder Filter and its output pins expose to the MSP in order to provide the control functionality described in the next sections. The compressed video output pin interfaces are described in section   REF _Ref422391459 \r \h  . The still-image output pin interfaces are presented in section   REF _Ref431468873 \r \h  . The RTP packetization descriptor output pin interface is introduced in section   REF _Ref431468938 \r \h  . The video encoder filter interfaces are explained in section   REF _Ref431468948 \r \h  Whenever the video encoder filter implements the IAMVideoProcAmp, IAMCameraControl or IAMVideoControl interfaces, the encoder filter shall also expose a preview video output pin in order to allow the user to view the changes applied to the image data, as illustrated below: Video encoder filter streams Fundamentally, a video encoder filter designed to be used by the TAPI MSP, provides three different types of output streams, and takes in one input stream. The input stream contains uncompressed video data. The three kinds of output streams contain respectively, compressed video data, compressed still-image data, and RTP packetization descriptors. Video encoder filter video and still-image output streams The TAPI MSP uses a primary video stream to get data in H.26x compressed form from the video encoder filter to the network send filter. The data gathered from the compressed video output pin will be typically fragmented into RTP packets to be sent over the wire (H.323). This same output pin can be put to use to transmit high-resolution still images using H.245 s progressive refinement mode. Optionally, a still-image stream of compressed data may be created on a separate and dedicated still-image output pin. The compressed video and still-image streams are almost identical in terms of data formats and stream characteristics. Both provide compressed digital image data. Video encoder filter video preview output stream Whenever the video encoder filter implements the IAMVideoProcAmp, IAMCameraControl or IAMVideoControl interfaces, the encoder filter shall also expose a video preview output pin in order to allow the user to view the changes applied to the image data. The video preview data may be built from the pre-processed version of the video data gathered from the output pin of the video capture filter, or from a decompressed version of the compressed video data generated on the video output pin of the encoder filter. In either case, the preview frames shall be in a video format that can be easily rendered, such as RGB8 or RGB16. The video preview output pin may also generate data in a DirectDraw friendly YUV packed format such as YUY2 or UYVY. Video encoder filter RTP packetization descriptor output stream This section defines a stream of a new type used to generate RTP packetization descriptors to be used synchronously with a compressed video output stream and facilitate RTP fragmentation. If the video encoder exposes an optional still image output stream, it shall create a second RTP pakcetization desdcriptor stream dedicated to the fragmentation of the still-image data The packetization descriptors contain payload header data to be inserted in front of the fragmented payload data by the RTP send network layer. They also describe at what points in the compressed data the packets start and end. Each of the samples of the RTP packetization descriptors output stream is synchronized to a unique sample of the compressed output stream. Nonetheless, the RTP packetization descriptors may be used to describe multi-layer encoded data. For filters that wouldn t provide RTP packetization descriptors, the TAPI network send filter would be forced to partially decompress the compressed data collected on the compressed output pin and figure out how the compressed data should be fragmented before it can be sent over the wire, yielding degraded performances. Video encoder filter input stream The video encoder filter takes its input video data from the uncompressed video output pin of the TAPI video capture source filter. The two filters are connected together by the TAPI MSP. Video encoder filter stream formats Stream types are described in DirectShow using the AM_MEDIA_TYPE structure. This structure includes GUID fields for majortype, subtype and formattype as well as fields specifying other sample features. It is defined as follows: typedef struct  _MediaType     GUID      majortype;     GUID      subtype;     BOOL      bFixedSizeSamples;     BOOL      bTemporalCompression;     ULONG     lSampleSize;     GUID      formattype;     IUnknown  *pUnk;     ULONG     cbFormat;     /* [size_is] */ BYTE __RPC_FAR *pbFormat; } AM_MEDIA_TYPE; The following describes the AM_MEDIA_TYPE members. majortype  Specifies the major type of the stream.  subtype  Specifies the subtype of the stream.  bFixedSizeSamples  Specifies that all the samples are the same size if set to TRUE. bTemporalCompression  Specifies that each sample is a synchronization point (keyframe) if set to FALSE. lSampleSize  Specifies the maximum size of the samples in bytes.  formattype  Specifies the format type of the stream.  pUnk  Specifies a pointer to the IUnknown interface. cbFormat  Specifies the size of the format section of the media type.  pbFormat  Specifies a pointer to the format section of the media type. Media type for H.26x compressed video and still-image streams For H.26x compressed video streams, the majortype type is MEDIATYPE_Video, and the formattype is set to FORMAT_VideoInfo. The subtype, along with the Format block, is used to convey details of the particular video data type.  The low-order four bytes of the subtype shall match the FourCC values used in the BITMAPINFOHEADER.biCompression field of the VIDEOINFOHEADER structure pointed to by the pbFormat field. For example, the following GUID identifies the FourCC (M263) for the H.263 video format: 3336324D-0000-0010-8000-00AA00389B71       4D = 'M'     32 = '2'   36 = '6' 33 = '3' s a complete list of ITU formats currently supported by TAPI and their associated subtype: Video Format FourCC ITU H.263 version 1 3336324D-0000-0010-8000-00AA00389B71 ITU H.263 version 2 3336324E-0000-0010-8000-00AA00389B71 ITU H.261 3136324D-0000-0010-8000-00AA00389B71 For all H.26x compressed video streams, the bFixedSizeSamples and bTemporalCompression fields shall respectively be set to FALSE and TRUE. Video info header structure for H.263 video streams TAPI defines the VIDEOINFOHEADER_H263 structure to specify details of the video stream. The pbFormat field of the AM_MEDIA_TYPE structure shall point to a structure of the VIDEOINFOHEADER_H263 type, instead of a regular VIDEOINFOHEADER structure, when describing H.263 video streams. Note that it is similar to the VIDEOINFOHEADER structure: typedef struct tagVIDEOINFOHEADER_H263 {    RECT                   rcSource;    RECT                   rcTarget;    DWORD                  dwBitRate;    DWORD                  dwBitErrorRate;    REFERENCE_TIME         AvgTimePerFrame;    BITMAPINFOHEADER_H263  bmiHeader; } VIDEOINFOHEADER_H263, *PVIDEOINFOHEADER_H263; where rcSource  Specifies a RECT structure that defines the source video window.  rcTarget  Specifies a RECT structure that defines the destination video window.  dwBitRate  Specifies a DWORD value that indicates the video stream's approximate data rate, in bits per second.  dwBitErrorRate  Specifies a DWORD value that indicates the video stream's data error rate, in bit errors per second.  AvgTimePerFrame  Specifies a REFERENCE TIME value that indicates the video frame's average display time, in 100-nanosecond units.  bmiHeader  Specifies a BITMAPINFOHEADER_H263 structure that contains detailed format information for the H.263 video data.  Video info header structure for H.261 video streams TAPI also defines the VIDEOINFOHEADER_H261 structure to specify details of an H.261 video stream. The pbFormat field of the AM_MEDIA_TYPE structure shall point to a structure of the VIDEOINFOHEADER_H261 type, instead of a regular VIDEOINFOHEADER structure, when describing H.261 video streams. Note that it is similar to the VIDEOINFOHEADER structure: typedef struct tagVIDEOINFOHEADER_H261 {    RECT                   rcSource;    RECT                   rcTarget;    DWORD                  dwBitRate;    DWORD                  dwBitErrorRate;    REFERENCE_TIME         AvgTimePerFrame;    BITMAPINFOHEADER_H261  bmiHeader; } VIDEOINFOHEADER_H261, *PVIDEOINFOHEADER_H261; where rcSource  Specifies a RECT structure that defines the source video window.  rcTarget  Specifies a RECT structure that defines the destination video window.  dwBitRate  Specifies a DWORD value that indicates the video stream's approximate data rate, in bits per second.  dwBitErrorRate  Specifies a DWORD value that indicates the video stream's data error rate, in bit errors per second.  AvgTimePerFrame  Specifies a REFERENCE TIME value that indicates the video frame's average display time, in 100-nanosecond units.  bmiHeader  Specifies a BITMAPINFOHEADER_H261 structure that contains detailed format information for the H.261 video data.  Bitmap info header structure for H.263 video streams The H.263 specification allows for many compression options. The video encoder filter is left responsible to chose what options to implement. On the other hand, when TAPI sets a specific video format on the compressed video output pin, it effectively indicates what options the receiver specified it supported by setting the H.263 specific fields of the extended bitmap info header defined below: typedef struct tagBITMAPINFOHEADER_H263 {     // Generic bitmap info header fields     BITMAPINFOHEADER   bmi;     // H.263 specific fields     DWORD dwMaxBitrate;     DWORD dwBppMaxKb;     DWORD dwHRD_B;     // Options     DWORD fUnrestrictedVector:1;     DWORD fArithmeticCoding:1;     DWORD fAdvancedPrediction:1;     DWORD fPBFrames:1;     DWORD fErrorCompensation:1;     DWORD fAdvancedIntraCoding:1;     DWORD fDeblockingFilter:1;     DWORD fImprovedPBFrames:1;     DWORD fUnlimitedMotionVectors:1;     DWORD fFullPictureFreeze:1;     DWORD fPartialPictureFreezeAndRelease:1;     DWORD fResizingPartPicFreezeAndRelease:1;     DWORD fFullPictureSnapshot:1;     DWORD fPartialPictureSnapshot:1;     DWORD fVideoSegmentTagging:1;     DWORD fProgressiveRefinement:1;     DWORD fDynamicPictureResizingByFour:1;     DWORD fDynamicPictureResizingSixteenthPel:1;     DWORD fDynamicWarpingHalfPel:1;     DWORD fDynamicWarpingSixteenthPel:1;     DWORD fIndependentSegmentDecoding:1;     DWORD fSlicesInOrder_NonRect:1;     DWORD fSlicesInOrder_Rect:1;     DWORD fSlicesNoOrder_NonRect:1;     DWORD fSlicesNoOrder_Rect:1;     DWORD fAlternateInterVLC:1;     DWORD fModifiedQuantization:1;     DWORD fReducedResolutionUpdate:1;     DWORD fReserved:4;     // Reserved     DWORD dwReserved[4]; } BITMAPINFOHEADER_H263, *PBITMAPINFOHEADER_H263; The BITMAPINFOHEADER is the well known GDI bitmap info header structure. It contains information on the video format such as actual image dimensions and the pixel depth. The following list describes the H.263 specific members of BITMAPINFOHEADER_H263: dwMaxBitrate  Specifies the maximum bit rate in units of 100 bits/s at which the receiver can receive video. This value is valid between 1 and 192400.  dwBppMaxKb  Specifies the maximum number of bits for one coded picture that the receiver can receive and decode correctly, and is measured in units of 1024 bits. This value is valid between 0 and 65535.  dwHRD_B  Specifies the Hypothetical Reference Decoder parameter B as described in Annex B of H.263. This value is valid between 0 and 524287.  fUnrestrictedVector  Specifies that the receiver can receive video data using the unrestricted motion vectors mode as defined in Annex D of H.263.  fArithmeticCoding  Specifies that the receiver can receive video data using the syntax based arithmetic coding mode as defined in Annex E of H.263.  fAdvancedPrediction  Specifies that the receiver can receive video data using the advanced prediction mode as defined in Annex F of H.263.  fPBFrames  Specifies that the receiver can receive video data using the PB-frames mode as defined in Annex G of H.263.  fErrorCompensation  Specifies that the receiver can identify MBs received with transmission errors, treat them as not coded, and send appropriate videoNotDecodedMBs indications.  fAdvancedIntraCoding  Specifies that the receiver can receive video data using the advanced INTRA coding mode as defined in Annex I of H.263.  fDeblockingFilter  Specifies that the receiver can receive video data using the deblocking filter mode as defined in Annex J of H.263.  fImprovedPBFrames  Specifies that the receiver can receive video data using the improved PB-frames mode as defined in Annex M of H.263.  fUnlimitedMotionVectors  Specifies that the receiver can receive video data using the unrestricted motion vector range when unrestricted motion vector mode as defined in Annex D of H.263 is also indicated.  fFullPictureFreeze Specifies that the receiver can receive Full Picture Freeze commands as described in Annex L of H.263.  fPartialPictureFreezeAndRelease Specifies that the receiver can receive Full Picture Freeze and Release commands as described in Annex L of H.263.  fResizingPartPicFreezeAndRelease Specifies that the receiver can receive the Resizing Partial Picture Freeze and Release commands as described in Annex L of H.263.  fFullPictureSnapshot Specifies that the receiver can receive Full Picture snapshots of the video content as described in Annex L of H.263.  fPartialPictureSnapshot Specifies that the receiver can receive Partial Picture Snapshots of the video content as described in Annex L of H.263.  fVideoSegmentTagging Specifies that the receiver can receive Video Segment tagging for the video content as described in Annex L of H.263.  fProgressiveRefinement Specifies that the receiver can receive Progressive Refinement tagging as described in Annex L of H.263. In addition, when true, the encoder shall respond to the progressive refinement miscellaneous commands doOneProgression, doContinuousProgressions, doOneIndependentProgression, doContinuousIndependentProgressions, progressiveRefinementAbortOne, and progressiveRefinementAbortContinuous. In addition, the encoder shall insert the Progressive Refinement Segment Start Tags and the Progressive Refinement Segment End Tags as defined in the Supplemental Enhancement Information Specification (Annex L) of Recommendation H.263. Note, Progressive Refinement tagging can be sent by an encoder and received by a decoder even when not commanded in a miscellaneous command.  fDynamicPictureResizingByFour Specifies that the receiver supports the picture resizing-by-four (with clipping) submode of the implicit Reference Picture Resampling Mode (Annex P) of H.263.  fDynamicPictureResizingSixteenthPel Specifies that the receiver supports resizing a reference picture to any width and height using the implicit Reference Picture Resampling mode (Annex P) of H.263 (with clipping). If DynamicPictureResizingSixteenthPel is true then DynamicPictureResizingByFour shall be true fDynamicWarpingHalfPel Specifies that the receiver supports the arbitrary picture warping operation within the Reference Picture Resampling mode (Annex P) of H.263 (with any fill mode) using half-pixel accuracy warping.  fDynamicWarpingSixteenthPel Specifies that the receiver supports the arbitrary picture warping operation within the Reference Picture Resampling mode (Annex P) of H.263 (with any fill mode) using either half-pixel or sixteenth pixel accuracy warping. fIndependentSegmentDecoding Specifies that the receiver supports the Independent Segment Decoding Mode (H.263 Annex R) of H.263.  fSlicesInOrder_NonRect Specifies that the receiver supports the submode of Slice Structured Mode (H.263 Annex K) where slices are transmitted in order and contain macroblocks in scanning order of the picture.  fSlicesInOrder_Rect Specifies that the receiver supports the submode of Slice Structured Mode (H.263 Annex K) where slices are transmitted in order and the slice occupies a rectangular region of the picture.  fSlicesNoOrder_NonRect Specifies that the receiver supports the submode of Slice Structured Mode (H.263 Annex K) where slices contain macroblocks in scanning order of the picture and need not be transmitted in order.  fSlicesNoOrder_Rect Specifies that the receiver supports the submode of Slice Structured Mode (H.263 Annex K) where slices occupy a rectangular region of the picture and need not be transmitted in order.  fAlternateInterVLC  Specifies that the receiver can receive video data using the alternate inter VLC mode as defined in Annex S of H.263.  fModifiedQuantization  Specifies that the receiver can receive video data using the modified quantization mode as defined in Annex T of H.263.  fReducedResolutionUpdate  Specifies that the receiver can receive video data using the reduced resolution update mode as defined in Annex Q of H.263.  fReserved  Reserved. Shall be set to NULL.  dwReserved[4]  Reserved. Shall all be set to NULL.  Again, when one of the H.263 specific fields is set to TRUE (1), this does not mean that the video encoder filter should generate data using that optional mode. Instead, TAPI is merely indicating that the option is supported by the receiver. Alternatively, when the TAPI MSP requests from the video encoder filter a list of supported formats, the Boolean flags shall be set to TRUE for all the optional modes the video encoder filter supports. The dwMaxBitrate field shall be set to the maximum bitrate in units of 100 bits/s at which the video encoder filter can generate video data. Finally, the dwBppMaxKb field shall be set to the maximum number of bits for one coded picture that the video encoder filter can generate in units of 1024 bits. This number shall be equivalent to the biSizeImage field of the bmi (bitmap info header) structure. Bitmap info header structure for H.261 video streams The TAPI MSP applies the following H.261 video format structure on the compressed video output pin to indicate what maximum video bitrate the receiver can receive, and if it is capable of receiving still images as defined in Annex D of H.261: typedef struct tagBITMAPINFOHEADER_H261 {     // Generic bitmap info header fields     BITMAPINFOHEADER   bmi;     // H.261 specific fields     DWORD dwMaxBitrate;     BOOL fStillImageTransmission;     // Reserved     DWORD dwReserved[4]; } BITMAPINFOHEADER_H261, *PBITMAPINFOHEADER_H261; The BITMAPINFOHEADER is the well-known GDI bitmap info header structure. It contains information on the video stream such as actual image dimensions and the pixel depth. The following list describes the H.261 specific members of BITMAPINFOHEADER_H261: dwMaxBitrate  Specifies the maximum bit rate in units of 100 bits/s at which the receiver can receive video. This value is only valid between 1 and 19200.   fStillImageTransmission  Specifies that the receiver can receive still images as defined in Annex D of H.261.  dwReserved[4]  Reserved. Shall all be set to NULL.  If the fStillImageTransmission H.261 specific field is set to TRUE (1) when setting a format on the compressed video output pin, this does not mean that it should generate data using that optional mode. Instead, the TAPI MSP is merely indicating that the option is supported by the receiver. Alternatively, when the TAPI MSP requests from the compressed video output pin a list of supported formats, the fStillImageTransmission field shall be set to TRUE if the pin is capable of generating still images as described in Annex D of H.261. The dwMaxBitrate field shall be set to the maximum bitrate in units of 100 bits/s at which the compressed output pin can generate video data. Media type for RTP packetization descriptor streams For RTP packetization descriptor streams, the majortype type is MEDIATYPE_RTP_PD, the formattype is set to FORMAT_None, and the subtype is initialized to MEDIASUBTYPE_None. Only the Format block is used to convey details of the particular RTP packetization descriptor type.  The following table shows the actual GUID values for type fields of the AM_MEDIA_TYPE structure used to describe RTP packetization descriptor streams: MEDIATYPE_RTP_PD 64707472-5245-4945-5252-45464C494850 FORMAT_None 0F6417D6-C318-11D0-A43F-00A0C9223196 MEDIASUBTYPE_None E436EB8E-524F-11CE-9F53-0020AF0BA770 The bFixedSizeSamples and bTemporalCompression fields are both set to FALSE. Configuration capabilities structure for RTP packetization descriptor streams In order to allow the TAPI MSP to use the IAMStreamConfig::GetStreamCaps method to get information on the minimum and maximum RTP packet size the video encoder filter can generate, the RTP_PD_CONFIG_CAPS structure is defined as follows: typedef struct tagRTP_PD_CONFIG_CAPS  {     DWORD dwSmallestRTPPacketSize;     DWORD dwLargestRTPPacketSize;     DWORD dwRTPPacketSizeGranularity;     DWORD dwSmallestNumLayers;     DWORD dwLargestNumLayers;     DWORD dwNumLayersGranularity;     DWORD dwNumStaticPayloadTypes;     DWORD dwStaticPayloadTypes[4];     DWORD dwNumDescriptorVersions;     DWORD dwDescriptorVersions[4];     DWORD dwReserved[4]; } RTP_PD_CONFIG_CAPS; where dwSmallestRTPPacketSize  Specifies the size in bytes of the smallest RTP packet the stream can describe.  dwLargestRTPPacketSize Specifies the size in bytes of the largest packet the stream can describe.  dwRTPPacketSizeGranularity  Specifies the granularity of the increments between the smallest and largest packet size the stream supports.  dwSmallestNumLayers  Specifies the smallest number of encoding layers the stream can describe.  dwLargestNumLayers  Specifies the largest number of encoding layers the stream can describe.  dwNumLayersGranularity  Specifies the granularity of the increments between the smallest and largest number of encoding layers the stream supports.  dwNumStaticPayloadTypes Specifies the number of static payload types the stream supports. This value is valid between 0 and 4.  dwStaticPayloadTypes[4]  Specifies an array of static payload types the stream supports. A stream can support at most 4 static payload types. The number of valid entries in this array is indicated by the dwNumStaticPayloadTypes field.  dwNumDescriptorVersions  Specifies the number of packetization descriptor versions the stream supports. This value is valid between 1 and 4.  dwDescriptorVersions[4]  Specifies an array of version identifiers qualifying the format of packetization descriptors. A stream can support at most 4 packetization descriptor versions. The number of valid entries in this array is indicated by the dwNumDescriptorVersions field.  dwReserved[4]  Reserved. Shall all be set to NULL.  Information header structure for RTP packetization descriptor streams Finally, the details of the format are specified using the RTP_PD_INFO structure defined as: typedef struct tagRTP_PD_INFO {     REFERENCE_TIME AvgTimePerSample;     DWORD dwMaxRTPPacketizationDescriptorBufferSize;     DWORD dwMaxRTPPayloadHeaderSize;     DWORD dwMaxRTPPacketSize;     DWORD dwNumLayers;     DWORD dwPayloadType;     DWORD dwDescriptorVersion;     DWORD dwReserved[4]; } RTP_PD_INFO, *PRTP_PD_INFO; where AvgTimePerSample  Specifies the average time per list of RTP packet descriptor, in 100ns units. This value shall be identical to the value of the AvgTimePerFrame field of the video info header of the related compressed video stream format dwMaxRTPPacketizationDescriptorBufferSize  Specifies the maximum size in bytes of the entire RTP packetization descriptor buffer. The format of this buffer is described in the following section. The maximum size of the entire RTP packetization descriptor buffer rarely needs to exceed a few hundred bytes. dwMaxRTPPayloadHeaderSize  Specifies the maximum size in bytes of the payload header data for one RTP packet. For example, the maximum size of a payload header for H.263 version 1 is 12 bytes (Mode C header). dwMaxRTPPacketSize  Specifies the maximum RTP packet size in bytes to be described by the list of packetization descriptor. Typically, this number is just below the MTU size of the network.  dwNumLayers  Specifies the number of encoding layers to be described by the list of packetization descriptor. Typically, this number is equal to 1. Only in the case of multi-layered encoders would this number be higher than 1.  dwPayloadType Specifies the static payload type the stream describes. If the RTP packetization descriptors do not apply to an existing static payload type but a dynamic payload type, this field shall be set to DYNAMIC_PAYLOAD_TYPE (defined as MAXDWORD).  dwDescriptorVersion  Specifies a version identifier qualifying the format of packetization descriptors. This field shall be set to VERSION_1 (defined as 1UL) to identify the packetization descriptor structures described in the next section.  dwReserved[4]  Reserved. Shall all be set to NULL.  Again, this structure is pointed to by the pbFormat field of the AM_MEDIA_TYPE structure used to describe the RTP packetization descriptor stream. RTP packetization descriptor format The format of the RTP packetization descriptors begins with a single header structure, RTP_PD_HEADER, defined as follows: typedef struct tagRTP_PD_HEADER {     DWORD dwThisHeaderLength;     DWORD dwTotalByteLength;     DWORD dwNumHeaders;     DWORD dwReserved; } RTP_PD_HEADER, *PRTP_PD_HEADER; where dwThisHeaderLength  Specifies the length, in bytes, of this structure. This field is the offset to the first RTP_PD structure.  dwTotalByteLength  Specifies the length, in bytes, of the entire data. This includes this structure, the RTP_PD structures, and the payload information.  dwNumHeaders  Specifies the number of RTP_PD structures.  dwReserved  Reserved. Shall be set to NULL.  This structure is followed by RTP_PD_HEADER.dwNumHeaders structures of type RTP_PD. Those structures are defined as follows: typedef struct tagRTP_PD {     DWORD dwThisHeaderLength;     DWORD dwPayloadHeaderOffset;     DWORD dwPayloadHeaderLength;     DWORD dwPayloadStartBitOffset;     DWORD dwPayloadEndBitOffset;     BOOL  fEndMarkerBit;     DWORD dwLayerId;     DWORD dwTimestamp;     union {     DWORD dwAudioAttributes;     DWORD dwVideoAttributes;     };     DWORD dwReserved; } RTP_PD, *PRTP_PD; where dwThisHeaderLength  Specifies the length, in bytes, of this structure. This field is the offset to the next RTP_PD structure, if there is one, or the start of the payload headers.  dwPayloadHeaderOffset  Specifies the offset from the start of the RTP packetization descriptor data to the first byte of the payload header.  dwPayloadHeaderLength  Specifies the length, in bytes, of the payload header.  dwPayloadStartBitOffset  Specifies the offset from the start of the corresponding compressed video buffer to the first bit of the payload data associated with this RTP_PD structure.  dwPayloadEndBitOffset  Specifies the offset from the start of the corresponding compressed video buffer to the last bit of the payload data associated with this RTP_PD structure.  fEndMarkerBit  If set to TRUE, this flag signals that this structure applies to the last chunk of a video frame. Typically, only the last packet descriptor in a series of descriptors would have this flag turned on. However, this may not be the case for video encoder filters that do not respect frame boundaries and fill buffers with truncated or multiple video frames. dwLayerId  Specifies the ID of the encoding layer this descriptor applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc. dwTimestamp Specifies the value of the RTP timestamp field to be set by the downstream filter when creating the RTP header for this packet. The units and ranges for this field shall adhere to the definition of timestamp given in section 5.1 of RFC 1889.  dwAudioAttributes Specifies some bitfield attributes used to characterize the sample in the audio stream associated to this RTP packetization descriptor. This field shall always be set to 0UL, unless the audio sample described by this RTP packetization descriptor structure is a silent frame, in which case, this field shall be set to AUDIO_SILENT (defined as 1UL). dwVideoAttributes Specifies some bitfield attributes used to characterize the sample in the video stream associated to this RTP packetization descriptor. There are no video attributes defined at this time. Therefore, this field shall always be set to 0UL. dwReserved  Reserved. Shall be set to NULL. The payload header data does not need to start right after the end of the last of the RTP_PD structures. The downstream filter will use the dwPayloadHeaderOffset field of each of the RTP_PD structures to jump to the appropriate memory location in the RTP packetization descriptor buffer, as the example below shows. This illustrates packetization of the first I-frame of an H.263 video stream in three fragments using a mode A header (4 bytes long) for each fragment: RTP packetization descriptor and video streams synchronization The TAPI MSP will always try to connect the compressed video output pin first. If this operation fails, there will be no attempt to connect an RTP packetization descriptor output pin to an input pin of the downstream filter. Once the compressed video output pin has been connected, TAPI will try to connect the RTP packetization descriptor pin. Synchronization of the RTP packetization descriptors and video streams is achieved by generating identical presentation timestamps for a compressed video sample and the corresponding RTP packetization descriptor sample. The downstream filter will look at those timestamps to establish how samples should be matched between the two streaming output pins. These timestamps should not be confused with the timestamp field of the RTP header that the network send downstream filter generates using other means. Whenever the TAPI MSP decides to pause or stop the stream compressed video output pin, the video encoder filter should not bother returning data on the associated RTP packetization descriptor output pin. Compressed video output pin TAPI interfaces The TAPI MSP exposes a few interfaces supported by the compressed video output pin to the TAPI MSP Channel Controller, the TAPI MSP network sink filter, or the TAPI MSP Quality Controller. The Channel Controller uses the IVideoChannelControl Stream interface to call the  IH245EncoderCommand interface to communicate H.245 commands to the compressed video output pin. This same Stream interface calls upon the IProgressiveRefinement interface to communicate progressive refinement H.245 commands to the compressed video or still-image output pins. The network sink filter uses the INetworkStats interface to inform the compressed video output pin of the transmission channel conditions (packet loss ). The Quality Controller uses the ICPUControl interface to initialize and adjust the maximum encoding time per frame and CPU load not be exceeded by the encoder s compression algorithm. Similarly, it uses the IBitrateControl interface to initialize and regulate the outgoing bitrate of the compressed video output pin. The TAPI MSP calls QueryInterface on the IPin interface exposed by the video output pin to get pointers to the IH245EncoderCommand, IProgressiveRefinement, INetworkStats, ICPUControl and IBitrateControl interfaces. IH245EncoderCommand interface H.245 commands exist for various purposes. Fast update requests are generally issued when source switching occurs in multipoint applications, or packet loss was detected. The flow control command is used to allow the bit rate of the video stream to be controlled by the remote endpoint. This has a number of purposes: interworking with terminals that only support a finite number of bit rates; multi-point applications where the rates from different sources should be matched; and flow control is congested. The temporal/spatial trade-off command is used by a remote endpoint to indicate preferences in terms of video quality vs. frame rate. In order to handle H.245 commands and indications, the compressed video output pin provides the TAPI call control component with a pointer to an IH245EncoderCommand interface containing the following methods: videoFastUpdadePicture  Used to command the compressed video output pin to enter the fast-update mode at its earliest opportunity.  videoFastUpdateGOB  Used to command the compressed video output to perform a fast update of one or more GOBs. videoFastUpdateMB  Used to command the compressed video output pin to perform a fast update of one or more MBs. videoSendSyncEveryGOB Used to command the compressed video output pin to use sync for every GOB as defined in H.263. videoSendSyncEveryGOBCancel Used to command the compressed video output pin to decide the frequency of GOB syncs. videoNotDecodedMBs Used to indicate to the compressed video output pin that a set of MBs has been received with errors and that any MB in the specified set has been treated as not coded. Note that the flow control, temporal/spatial trade-off command and mode changes are not propagated to the video output pin directly. Those commands are implemented using other means as described in sections   REF _Ref431529837 \r \h  6.1.6  REF _Ref428201104 \r \h  6.1.8 videoFastUpdatePicture method This H.245 command is used to specify to the compressed video output pin to enter the fast-update mode at its earliest opportunity. The videoFastUpdatePicture method is declared as follows: HRESULT videoFastUpdatePicture() This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_NOTIMPL Method is not supported NOERROR No error This command shall be used with all video compression algorithms as a generic way to generate a keyframe (I-frame). videoFastUpdateGOB method This H.245 command is used to specify to the compressed video output pin to perform a fast update of one or more GOBs. The videoFastUpdateGOB method is declared as follows: HRESULT videoFastUpdateGOB([IN] DWORD dwFirstGOB, [IN] DWORD dwNumberOfGOBs) where dwFirstGOB  Specifies the number of the first GOB to be updated. This value is only valid between 0 and 17.  dwNumberOfGOBs  Specifies the number of GOBs to be updated. This value is only valid between 1 and 18.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error This command shall only be used with video compression algorithms that define GOBs such as H.261 and H.263. videoFastUpdateMB method This H.245 command is used to specify to the compressed video output pin to perform a fast update of one or more MBs. The videoFastUpdateMB method is declared as follows: HRESULT videoFastUpdateMB([IN] DWORD dwFirstGOB, [IN] DWORD dwFirstMB, [IN] DWORD dwNumberOfMBs) where dwFirstGOB  Specifies the number of the first GOB to be updated and is only relative to H.263. This value is only valid between 0 and 255. dwFirstMB  Specifies the number of the first MB to be updated and is only relative to H.261. This value is only valid between 1 and 8192.  dwNumberOfMBs  Specifies the number of MBs to be updated. This value is only valid between 1 and 8192.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error This command shall only be used with video compression algorithms that define MBs such as H.261 and H.263. The encoder may respond to this command with a GOB update which includes the MBs requested. videoSendSyncEveryGOB and videoSendSyncEveryGOBCancel commands The videoSendSyncEveryGOB H.245 command is used to specify to the compressed video output pin to use sync for every GOB as defined in H.263. Reciprocally, the videoSendSyncEveryGOBCancel command is used to allow the video output pin to decide the frequency of GOB syncs. To handle these commands, we define the videoSendSyncEveryGOB method on the IH245EncoderCommand interface as follows: HRESULT videoSendSyncEveryGOB([IN] BOOL fEnable) where fEnable  If set to TRUE, specifies that the video output pin should use sync for every GOB; if set to FALSE, specifies that the video output pin should decide the frequency of GOB syncs on its own. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_NOTIMPL Method is not supported NOERROR No error This command shall only be used with video encoded according to H.263. videoNotDecodedMBs indication This H.245 indication is used to indicate to the compressed video output pin that a set of MBs has been received with errors and that any MB in the specified set has been treated as not coded. To handle this indication, we define the videoNotDecodedMBs method on the IH245EncoderCommand interface as follows: HRESULT videoNotDecodedMBs([IN] DWORD dwFirstMB, [IN] DWORD dwNumberOfMBs, [IN] DWORD dwTemporalReference) where dwFirstMB  Specifies the number of the first MB treated as not coded. This value is only valid between 1 and 8192. dwNumberOfMBs  Specifies the number of MBs treated as not coded. This value is only valid between 1 and 8192. dwTemporalReference  Specifies the temporal reference of the picture containing not decoded MBs. This value is only valid between 0 and 255. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error This compressed video output pin may use this information to compensate transmission errors, as illustrated in Appendix II of H.263. FlowControl The flow control command is used to allow the bit rate of the video stream to be controlled by the remote endpoint. This has a number of purposes: interworking with terminals that only support a finite number of bit rates; multi-point applications where the rates from different sources should be matched; and flow control is congested. This command is propagated to the compressed video output pin using the IBitrateControl::SetMaxBitrate method as described in section   REF _Ref431458819 \r \h  6.4.1 Temporal/Spatial trade-off The temporal/spatial trade-off command is used by a remote endpoint to indicate preferences in terms of video quality vs. frame rate. This command is not propagated directly to the compressed video output pin. Instead, and only if necessary, the TAPI MSP dynamically adjusts the frame rate on the video capture source filter. Whenever this occurs, the compressed video output pin shall update its internal compression parameters to maintain a constant bitrate as specified in VIDEOINFOHEADER_H263.dwBitRate or the last call to IBitrateControl::SetMaxBitrate. H.245 mode requests The mode request procedures allow a terminal to request a remote terminal to use a particular mode of operation in its transmit direction. The TAPI MSP does not propagate those requests down to the compressed video output pin using the IH245EncoderCommand interface. Instead, the video stream is stopped and new formats are set on the video pins, based on the content of the video mode request. INetworkStats interface Video encoder filters may have smart ways to improve their resiliency to packet loss. They may decide to code their data in different ways or use some specific redundancy payload definitions to provide better error resilience. We define an INetworkStats interface that can be used to communicate the network channel characteristics (losses) to the compressed video or still-image output pin. These methods are called by the TAPI MSP network sink filter whenever an adjustement is  deemed necessary, based on monitored network performances. The compressed output pin is responsible for taking appropriate actions, if needed. The INetworkStats interface contains the following methods: SetChannelErrors  Used to inform the compressed output pin of the error channel conditions.  GetChannelErrors Used to supply to the network sink filter the error channel conditions the compressed output pin is currently setup for. SetPacketLossRate Used to inform the compressed output pin of the channel packet loss rate. GetPacketLossRate Used to supply to the network sink filter the channel packet loss rate the compressed output pin is currently setup for. SetChannelErrors method This network statistics method is used to inform the compressed output pin of the error channel conditions. The SetChannelErrors method is declared as follows: HRESULT SetChannelErrors([IN] DWORD dwRandomBitErrorRate, [IN] DWORD dwBurstErrorDuration, [IN] DWORD dwBurstErrorMaxFrequency, [IN] DWORD dwLayerId) where dwRandomBitErrorRate Specifies the random bit error rate of the channel in multiples of 10-6.  dwBurstErrorDuration Specifies the duration for short burst errors in ms.  dwBurstErrorMaxFrequency Specifies the maximum frequency for short burst errors in Hz.  dwLayerId Specifies the ID of the encoding layer the error channel conditions apply to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetChannelErrors method This network statistics method is used to supply to the network sink filter the error channel conditions the compressed output pin is currently setup for. The GetChannelErrors method is declared as follows: HRESULT GetChannelErrors([OUT] DWORD *pdwRandomBitErrorRate, [OUT] DWORD *pdwBurstErrorDuration, [OUT] DWORD *pdwBurstErrorMaxFrequency, [IN] DWORD dwLayerId) where pdwRandomBitErrorRate Specifies a pointer to a DWORD to receive the random bit error rate of the channel the compressed video output pin is currently setup for in multiples of 10-6.  pdwBurstErrorDuration Specifies a pointer to a DWORD to receive the duration for short burst errors the compressed video output pin is currently setup for in ms.  pdwBurstErrorMaxFrequency Specifies a pointer to a DWORD to receive the maximum frequency for short burst errors the compressed video output pin is currently setup for in Hz.  dwLayerId Specifies the ID of the encoding layer the error channel conditions apply to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error SetPacketLossRate method This network statistics method is used to inform the compressed output pin of the channel packet loss rate. The SetPacketLossRate method is declared as follows: HRESULT SetPacketLossRate([IN] DWORD dwPacketLossRate, [IN] DWORD dwLayerId) where dwPacketLossRate Specifies the packet loss rate of the channel in multiples of 10-6.  dwLayerId Specifies the ID of the encoding layer the error channel packet loss rate applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetPacketLossRate method This network statistics method is used to supply to the network sink filter the packet loss rate channel conditions the compressed output pin is currently setup for. The GetPacketLossRate method is declared as follows: HRESULT GetPacketLossRate([OUT] DWORD *pdwPacketLossRate, [IN] DWORD dwLayerId) where pdwPacketLossRate Specifies a pointer to a DWORD to receive the packet loss rate of the channel the compressed output pin is currently setup for in multiples of 10-6.  dwLayerId Specifies the ID of the encoding layer the packet loss rate applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error ICPUControl interface We also define the ICPUControl interface that video output pins are required to provide in order to receive bounds on the encoding time (latency) and CPU load that should not be exceeded during the compression process. This interface builds on work that was done in NetMeeting s CPU-Aware Quality Controller that monitors system-wide CPU usage and adjusts the frame rate of video capture devices. The methods on this interface are called at the beginning of a call to initialize the maximum CPU load and frame encoding time, and then occasionally by the TAPI MSP Quality Controller during the entire call. The initial and limit values for the maximum CPU load and frame encoding time are based on user-defined settings provided by the application. The ICPUControl interface contains the following methods: SetMaxProcessingTime  Used to specify to the compressed video output pin the maximum encoding time per frame, in 100-nanosecond units. GetMaxProcessingTime Used to retrieve the maximum encoding time per frame the compressed video output pin is currently setup for, in 100-nanosecond units. SetMaxCPULoad  Used to specify to the compressed video output pin the maximum encoding algorithm CPU load. GetMaxCPULoad Used to retrieve the maximum encoding algorithm CPU load the compressed video output pin is currently setup for. SetMaxProcessingTime method This CPU control method is used to specify to the compressed video output pin the maximum encoding time per frame. The SetMaxProcessingTime method is declared as follows: HRESULT SetMaxProcessingTime([IN] REFERENCE_TIME MaxProcessingTime) where MaxProcessingTime Specifies the maximum encoding time per frame, in 100-nanosecond units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetMaxProcessingTime method This CPU control method is used to retrieve the maximum encoding time per frame the compressed video output pin is currently setup for. The GetMaxProcessingTime method is declared as follows: HRESULT GetMaxProcessingTime([OUT] REFERENCE_TIME *pMaxProcessingTime) where pMaxProcessingTime Used to retrieve the maximum encoding time per frame the compressed video output pin is currently setup for, in 100-nanosecond units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error SetMaxCPULoad method This CPU control method is used to specify to the compressed video output pin the maximum processing algorithm CPU load. The SetMaxCPULoad method is declared as follows: HRESULT SetMaxCPULoad([IN] DWORD dwMaxCPULoad) where dwMaxCPULoad Specifies the maximum encoding algorithm CPU load, in percentage units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetMaxCPULoad method This CPU control method is used to retrieve the maximum processing algorithm CPU load the compressed video output pin is currently setup for. The GetMaxCPULoad method is declared as follows: HRESULT GetMaxCPULoad([OUT] DWORD *pdwMaxCPULoad) where pdwMaxCPULoad Used to retrieve the maximum encoding algorithm CPU load the compressed video output pin is currently setup for, in percentage units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error IBitrateControl interface The IBitrateControl interface specifies a maximum bitrate to the video output pin of the TAPI MSP video encoder filter. The methods on this interface are called at the beginning of a call by the TAPI MSP Quality Controller to initialize the target bitrate, and then occasionally during the entire call. The dynamic values for the target bitrates are based on network statistics provided by the TAPI MSP network sink filter to the TAPI MSP Quality Controller. The initial and limit values for the target bitrate are based on user-defined settings provided by the application to the TAPI MSP Quality Controller and the result of capability negotiations between the two connected endpoints provided by the TAPI TSP call control module. Note that the IBitrateControl::SetMaxBitrate is also called by the TAPI TSP call control component whenever it receives a FlowControl command. The IBitrateControl interface contains the following methods: SetMaxBitrate  Used to specify to the compressed video output pin the upper limit in bandwidth transmission. GetMaxBitrate Used to retrieve the upper limit in bandwidth transmission the compressed video output pin is currently setup for. SetMaxBitrate method This bitrate control method is used to specify to the compressed video output pin the upper limit in bandwidth transmission. The SetMaxBitrate method is declared as follows: HRESULT SetMaxBitrate([IN] DWORD dwMaxBitrate, [IN] DWORD dwLayerId) where dwMaxBitrate Specifies the new upper limit in bandwidth transmission in bits/s.  dwLayerId Specifies the ID of the encoding layer the new upper limit in bandwidth transmission applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Whenever this method is called, the compressed video output pin shall update its internal compression parameters accordingly (e.g., quantization parameters) to generate compressed data at the new target bitrate.  Compression parameters shall be adjusted to compensate for network protocol overhead as well. The dwMaxBitrate value then effectively characterizes the estimated bitrate of the RTP/UDP/IP network stream. The compressed video output pin shall include the estimated overhead for the RTP payload header and RTP, UDP, and IP packet headers when updating internal compression parameters. Note that both the TAPI TSP call control component (FlowControl H.245 command) and TAPI MSP Quality Controller may call upon this method to adjust the output bitrate of the compressed video output pin. GetMaxBitrate method This method is used to retrieve the upper limit in bandwidth transmission the compressed video output pin is currently setup for. The GetMaxBitrate method is declared as follows: HRESULT GetMaxBitrate([OUT] DWORD *pdwMaxBitrate, [IN] DWORD dwLayerId) where pdwMaxBitrate Used to receive the compressed video output pin upper limit in bandwidth transmission in bits/s.  dwLayerId Specifies the ID of the encoding layer the new upper limit in bandwidth transmission applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc..  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error IProgressiveRefinement interface H.245 progressive refinement commands exist to allow for transmission of high-res stills that are continuously improved on the remote endpoint as more data is received and decompressed. In order to handle those commands, the compressed video output pin provides the TAPI call control component with a pointer to an IProgressiveRefinement interface. See section   REF _Ref431462814 \r \h   for more information on the IProgressiveRefinement interface. Compressed still-image output pin TAPI interfaces The TAPI MSP exposes a few interfaces supported by the compressed still-image output pin directly to the TAPI TSP call control component, the TAPI MSP Quality Controller,  or the TAPI MSP network sink filter. The call control component uses the IProgressiveRefinement interface to communicate progressive refinement H.245 commands to the compressed video or still-image output pins. The network sink filter uses the INetworkStats interface to inform the compressed still-image output pin of the transmission channel conditions (packet loss ), as described in section   REF _Ref427926473 \r \h  . The Quality Controller uses the ICPUControl interface to initialize and adjust the maximum encoding time per frame and CPU load not be exceeded by the encoder s compression algorithm, as defined in section   REF _Ref431461184 \r \h  . Similarly, it uses the IBitrateControl interface (introduced in section   REF _Ref431461225 \r \h  ) to initialize and regulate the outgoing bitrate of the compressed still-image output pin. The TAPI MSP calls QueryInterface on the IPin interface exposed by the still-image output pin to get pointers to the IProgressiveRefinement, INetworkStats, ICPUControl and IBitrateControl interfaces. IProgressiveRefinement interface H.245 progressive refinement commands exist to allow for transmission of high-res stills that are continuously improved on the remote endpoint as more data is received and decompressed. In order to handle those commands, the compressed still-image output pin provides the TAPI call control component with a pointer to an IProgressiveRefinement interface containing the following methods: doOneProgression Used to command the compressed still-image output pin to begin producing a progressive refinement sequence for one picture. doContinuousProgressions Used to command the compressed still-image output pin to begin producing progressive refinement sequences for several pictures. doOneIndependentProgression Used to command the compressed still-image output pin to begin an independent progressive refinement sequence for one Intra picture. doContinuousIndependentProgressions Used to command the compressed still-image output pin to begin an independent progressive refinement sequence several Intra pictures. progressiveRefinementAbortOne Used to command the compressed still-image output pin to terminate a progressive refinement sequence for the current picture. progressiveRefinementAbortContinuous Used to command the compressed still-image output pin to terminate a progressive refinement sequence for all pictures. These methods return an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_NOTIMPL Method is not supported NOERROR No error doOneProgression method This H.245 progressive refinement command is used to specify to the compressed still-image output pin to begin producing a progressive refinement sequence. The doOneProgression method is declared as follows: HRESULT doOneProgression() In this mode, the compressed still-image output pin produces video data consisting of one picture followed by a sequence of zero or more frames of refinement of the quality of the same picture. The compressed still-image output pin stays in this mode until it decides an acceptable fidelity level has been reached or the progressiveRefinementAbortOne command is received. In addition, the compressed still-image output pin shall insert the Progressive Refinement Segment Start Tag and the Progressive Refinement Segment End Tag to mark the beginning and end of the progressive refinement as defined in the Supplemental Enhancement Information Specification (Annex L) of Recommendation H.263. doContinuousProgressions method This H.245 progressive refinement command is used to specify to the compressed still-image output pin to begin producing a progressive refinement sequence. The doContinuousProgressions method is declared as follows: HRESULT doContinuousProgressions() In this mode, the compressed still-image output pin produces video data consisting of one picture followed by a sequence of zero or more frames of refinement of the quality of the same picture. When the compressed still-image output pin decides an acceptable fidelity level has been reached or the progressiveRefinementAbortOne command is received, it stops refining the current progression and begins another progressive refinement for a different picture. The sequence of progressive refinements continues until the progressiveRefinementAbortContinuous command is received. In addition, the compressed still-image output pin shall insert Progressive Refinement Segment Start Tags and Progressive Refinement Segment End Tags to mark the start and end of each progressive refinement as defined in the Supplemental Enhancement Information Specification (Annex L) of Recommendation H.263. doOneIndependentProgression method This H.245 progressive refinement command is used to specify to the compressed still-image output pin to begin an independent progressive refinement sequence. The doOneIndependentProgression method is declared as follows: HRESULT doOneIndependentProgression() In this mode, the compressed still-image output pin produces video data consisting of one Intra picture followed by a sequence of zero or more frames of refinement of the quality of the same picture. The compressed still-image output pin stays in this mode until either it decides an acceptable fidelity level has been reached or the progressiveRefinementAbortOne command is received. In addition, the compressed still-image output pin shall insert the Progressive Refinement Segment Start Tag and the Progressive Refinement Segment End Tag to mark the beginning and end of the progressive refinement as defined in the Supplemental Enhancement Information Specification (Annex L) of Recommendation H.263. doContinuousIndependentProgressions method This H.245 progressive refinement command is used to specify to the compressed still-image output pin to begin producing independent progressive refinement sequences. The doContinuousIndependentProgressions method is declared as follows: HRESULT doContinuousIndependentProgressions() In this mode, the compressed still-image output pin produces video data consisting of one Intra picture followed by a sequence of zero or more frames of refinement of the quality of the same picture. When the compressed still-image output pin decides an acceptable fidelity level has been reached or the progressiveRefinementAbortOne command is received, it stops refining the current progression and begins another independent progressive refinement for a different picture. The sequence of independent progressive refinements continues until the progressiveRefinementAbortContinuous command is received. In addition, the terminal shall insert Progressive Refinement Segment Start Tags and Progressive Refinement Segment End Tags to mark the start and end of each independent progressive refinement as defined in the Supplemental Enhancement Information Specification (Annex L) of Recommendation H.263. progressiveRefinementAbortOne method This H.245 progressive refinement command is used to specify to the compressed still-image output pin to terminate doOneProgression, doOneIndependentProgression, or the current progressive refinement in the sequence of progressive refinements in either doContinuousProgressions or doContinuousIndependentProgressions. The progressiveRefinementAbortOne method is declared as follows: HRESULT progressiveRefinementAbortOne() progressiveRefinementAbortContinuous method This H.245 progressive refinement command is used to specify to the compressed still-image output pin to terminate either doContinuousProgressions or doContinuousIndependentProgressions. The progressiveRefinementAbortContinuous method is declared as follows: HRESULT progressiveRefinementAbortContinuous() INetworkStats interface Compressed still-image output pins may chose to also expose an INetworkStats interface. The TAPI MSP network sink filter calls methods on this interface occasionally based on monitored network performances. The compressed still-image output pin is responsible for taking appropriate actions, if needed. See section   REF _Ref427926743 \r \h   for more information on the INetworkStats interface. ICPUControl interface Compressed still-image output pins are required to implement the ICPUControl interface. The methods on this interface are called at the beginning of a call to initialize the maximum CPU load and frame encoding time, and then occasionally by the TAPI MSP Quality Controller during the entire call, whenever deemed necessary. The initial and limit values for the maximum CPU load and frame encoding time are based on user-defined settings provided by the application. See section   REF _Ref431461184 \r \h   for more information on the ICPUControl interface. IBitrateControl interface The IBitrateControl interface specifies a maximum bitrate to the still-image output pin of the TAPI MSP video encoder filter. The methods on this interface are called at the beginning of a call by the TAPI MSP Quality Controller to initialize the target bitrate, and then occasionally during the entire call. The dynamic values for the target bitrates are based on network statistics provided by the TAPI MSP network sink filter to the TAPI MSP Quality Controller. The initial and limit values for the target bitrate are based on user-defined settings provided by the application to the TAPI MSP Quality Controller and the result of capability negotiations between the two connected endpoints provided by the TAPI TSP call control module. See section   REF _Ref431461225 \r \h   for more information on the IBitrateControl interface. RTP packetization descriptor output pin TAPI interface The TAPI MSP video encoder filter exposes a new interface supported by the RTP packetization descriptor output pin to the network sink filter. The network sink filter uses the IRTPPDControl interface to dynamically modify or query for the maximum RTP packet size on the RTP packetization descriptor output pin. Note that in typical scenarios, the maximum RTP packet size will be set once at stream creation time through the RTP_PD_INFO structure and never change. The TAPI MSP calls QueryInterface on the IPin interface exposed by the RTP packetization descriptor output pin of the TAPI MSP video encoder filter to get a pointer to the IRTPPDControl interface. IRTPPDControl interface In order to dynamically adjust the maximum RTP packet size, the RTP packetization descriptor output pin provides the network filter with a pointer to an IRTPPDControl interface containing the following methods: SetMaxRTPPacketSize Used to dynamically adjust the maximum RTP packet size (in bytes) to be described by the list of packetization descriptors. Typically, this number is just below the MTU size of the network. GetMaxRTPPacketSize Used to supply to the network sink filter the current maximum RTP packet size (in bytes) described by the list of packetization descriptors. SetMaxRTPPacketSize method This RTP packetization descriptor control method is used to dynamically adjust the maximum RTP packet size (in bytes) to be described by the list of packetization descriptor. Typically, this number is just below the MTU size of the network. The SetMaxRTPPacketSize method is declared as follows: HRESULT SetMaxRTPPacketSize([IN] DWORD dwMaxRTPPacketSize, [IN] DWORD dwLayerId) where dwMaxRTPPacketSize Specifies the maximum RTP packet size (in bytes) to be described by the list of packetization descriptors.  dwLayerId Specifies the ID of the encoding layer the maximum RTP packet size applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetMaxRTPPacketSize method This RTP packetization descriptor control method is used to supply to the network sink filter the maximum RTP packet size (in bytes) described by the list of packetization descriptors. The GetMaxRTPPacketSize method is declared as follows: HRESULT GetMaxRTPPacketSize([OUT] DWORD *pdwMaxRTPPacketSize, [IN] DWORD dwLayerId) where pdwMaxRTPPacketSize Specifies a pointer to a DWORD to receive the maximum RTP packet size (in bytes) described by the list of packetization descriptors.  dwLayerId Specifies the ID of the encoding layer the maximum RTP packet size applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc..  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error Video encoder filter application interfaces The TAPI MSP exposes a few DirectShow interfaces supported by the video encoder filter to the client application. Typically, these applications will indirectly use those interfaces to modify video quality settings, or provide simulated camera control capabilities if the video encoder filter supports such features. Those interfaces are the IAMVideoProcAmp, IAMCameraControl  and IAMVideoControl interfaces. The TAPI MSP will query the video encoder filter itself, not its output pins, to get pointer to those interfaces. Note that the application will not get a direct pointer to those interfaces. Instead, the methods on those interfaces will be called through delegation. All the interfaces listed below shall be implemented by the video encoder itself, not its output pins. The TAPI MSP will call QueryInterface on the IBaseFilter interface exposed by the video encoder filter to get pointers to the DirectShow interfaces mentioned in this section. IAMVideoProcAmp interface The IAMVideoProcAmp interface contains methods for controlling video quality such as brightness, contrast, hue, saturation, gamma, and sharpness. It defines a uniform range for these settings regardless of whether the adjustment is made in the analog or digital domain. The IAMVideoProcAmp interface contains the following methods: GetRange  Used to retrieve minimum, maximum, and default values of a video quality setting. Used to set the value of a video quality setting.  Used to retrieve the value of a video quality setting.  The IAMVideoProcAmp interface uses the VideoProcAmpProperty enumerated data type to identify specific quality settings, and the VideoProcAmpFlags enumerated data type to qualify if the quality setting can be set manually and/or automatically. VideoProcAmpProperty enumerated data type This enumerated data type is defined as follows: typedef enum tagVideoProcAmpProperty    VideoProcAmp_Brightness,    VideoProcAmp_Contrast,    VideoProcAmp_Hue,    VideoProcAmp_Saturation,    VideoProcAmp_Sharpness,    VideoProcAmp_Gamma,    VideoProcAmp_ColorEnable,    VideoProcAmp_WhiteBalance,    VideoProcAmp_BacklightCompensation } VideoProcAmpProperty; where: VideoProcAmp_Brightness  Specifies the brightness setting in IRE units * 100. The range for Value is -10000 to 10000; the default value is 750 (7.5 IRE)  VideoProcAmp_Contrast Specifies the contrast or luma gain setting in gain factor * 100. The Value range is from zero to 10000, and the default is 100 (1x). Note that a particular video encoder filter may only implement a subset of this range.  VideoProcAmp_Hue Specifies the hue setting in degrees * 100. Value range is from -18000 to 18000 ( -180 to +180 degrees), and the default is zero. Note that a particular video encoder filter may only implement a subset of this range.  VideoProcAmp_Saturation Specifies the saturation or chroma gain setting in gain * 100. Value ranges from zero to 10000, and the default is 100 (1x). Note that a particular video encoder filter may only implement a subset of this range.  VideoProcAmp_Sharpness Specifies the sharpness setting in arbitrary units. Value ranges from zero to 100, and the default is 50. Note that a particular video encoder filter may only implement a subset of this range.  VideoProcAmp_Gamma Specifies the gamma setting in gamma * 100. Value ranges from 1 to 500, and the default is 100 (gamma = 1). Note that a particular video encoder filter may only implement a subset of this range.  VideoProcAmp_ColorEnable Specifies the color enable setting as a Boolean value. Value ranges from zero to 1, and the default is 1.  VideoProcAmp_WhiteBalance Specifies the white balance setting expressed as a color temperature in degrees Kelvin. The range and default values for this setting are video encoder filter dependent.  VideoProcAmp_BacklightCompensation Specifies the backlight compensation setting which is a Boolean. Zero indicates backlight compensation is disabled, and 1 indicates backlight compensation is enabled.  VideoProcAmpFlags enumerated data type This enumerated data type is defined as follows: typedef enum tagVideoProcAmpFlags    VideoProcAmp_Flags_Manual = 0x0000,    VideoProcAmp_Flags_Auto   = 0x0001 } VideoProcAmpFlags; where: VideoProcAmp_Flags_Manual  Specifies that the quality setting can be modified manually.  VideoProcAmp_Flags_Auto Specifies that the quality setting can be modified automatically.  GetRange method This method is used to retrieve the minimum, maximum, and default values for specific video quality settings. The GetRange method is declared as follows: HRESULT GetRange([IN]long Property, [OUT]long *pMin, [OUT]long *pMax, [OUT]long *pSteppingDelta, [OUT]long *pDefault, [OUT]long *pCapsFlags) where Property  Used to specify the video quality setting to determine the range of. Use a member of the VideoProcAmpProperty enumerated type. Used to retrieve the minimum value of the video quality setting range.  Used to retrieve the maximum value of the video quality setting range.  pSteppingDelta Used to retrieve the stepping delta of the video quality setting range.  pDefault Used to retrieve the default value of the video quality setting range.  pCapsFlags Used to retrieve the capabilities of the video quality setting. Pointer to a member of the VideoProcAmpFlags enumerated type. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Set method This method is used to set the value of a specific video quality setting. The Set method is declared as follows: HRESULT Set([IN]long Property, [IN]long lValue, [IN]long Flags) where Property  Used to specify the video quality setting to set the value of. Use a member of the VideoProcAmpProperty enumerated type. lValue Used to specify the new value of the video quality setting.  Flags A member of the VideoProcAmpFlags enumerated type.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Get method This method is used to get the current value of a specific video quality setting. The Get method is declared as follows: HRESULT Get([IN]long Property, [OUT]long *lValue, [OUT]long *Flags) where Property  Used to specify the video quality setting to get the value of. Use a member of the VideoProcAmpProperty enumerated type. lValue Used to retrieve the current value of the video quality setting.  Flags Pointer to a member of the VideoProcAmpFlags enumerated type.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error IAMCameraControl interface The IAMCameraControl interface contains methods to adjust or inquire about simulated camera control settings. The controls are a subset of the proposed ITU T.RDC standard at  HYPERLINK "http://www.itu.ch" http://www.itu.ch The IAMCameraControl interface contains the following methods: GetRange  Used to retrieve minimum, maximum, and default values of a simulated camera control setting. Used to set the value of a simulated camera control setting.  Used to retrieve the value of a simulated camera control setting.  The IAMCameraControl interface uses the CameraControlProperty enumerated data type to describe specific simulated camera control settings, and the CameraControlFlags enumerated data type to qualify if the simulated camera control setting can be set manually and/or automatically. CameraControlProperty enumerated data type This enumerated data type is defined as follows: typedef enum tagCameraControlProperty    CameraControl_Pan,    CameraControl_Tilt,    CameraControl_Roll,    CameraControl_Zoom,    CameraControl_Exposure,    CameraControl_Iris,    CameraControl_Focus } CameraControlProperty; where: CameraControl_Pan  Specifies the simulated camera pan setting in degrees. Values range from -180 to +180, and the default is zero. Positive values are clockwise from the origin (the simulated camera rotates clockwise when viewed from above), and negative values are counterclockwise from the origin. Note that a particular video encoder filter may only implement a subset of this range.  CameraControl_Tilt Specifies the simulated camera tilt setting in degrees. Values range from -180 to +180, and the default is zero. Positive values point the imaging plane up, and negative values point the imaging plane down. Note that a particular video encoder filter may only implement a subset of this range.  CameraControl_Roll Specifies the simulated roll setting in degrees. Values range from -180 to +180, and the default is zero. Positive values cause a clockwise rotation of the simulated camera along the image viewing axis, and negative values cause a counterclockwise rotation of the simulated camera. Note that a particular video encoder filter may only implement a subset of this range.  CameraControl_Zoom Specifies the simulated zoom setting in millimeter units. Values range from 10 to 600, and the default is video encoder filter specific.  CameraControl_Exposure Specifies the simulated exposure setting in seconds using the following formula. For values less than zero, the exposure time is 1/2n seconds. For positive values and zero, the exposure time is 2n seconds. Note that a particular video encoder filter may only implement a subset of this range.  CameraControl_Iris Specifies the simulated iris setting expressed as the fstop  * 10.  CameraControl_Focus Specifies the simulated camera focus setting as the distance to the optimally focused target in millimeters. The range and default values are video encoder filter specific. Note that a particular filter may only implement a subset of this range.  CameraControlFlags enumerated data type This enumerated data type is defined as follows: typedef enum tagCameraControlFlags    CameraControl_Flags_Manual = 0x0000,    CameraControl_Flags_Auto   = 0x0001 } CameraControlFlags; where: CameraControl_Flags_Manual  Specifies that the simulated camera control  setting can be modified manually.  CameraControl_Flags_Auto Specifies that the simulated camera control setting can be modified automatically.  GetRange method This method is used to retrieve the minimum, maximum, and default values for specific simulated camera control settings. The GetRange method is declared as follows: HRESULT GetRange([IN]long Property, [OUT]long *pMin, [OUT]long *pMax, [OUT]long *pSteppingDelta, [OUT]long *pDefault, [OUT]long *pCapsFlags) where Property  Used to specify the simulated camera control setting to determine the range of. Use a member of the CameraControlProperty enumerated type. Used to retrieve the minimum value of the simulated camera control setting range.  Used to retrieve the maximum value of the simulated camera control setting range.  pSteppingDelta Used to retrieve the stepping delta of the simulated camera control setting range.  pDefault Used to retrieve the default value of the simulated camera control setting range.  pCapsFlags Used to retrieve the capabilities of the simulated camera control setting. Pointer to a member of the CameraControlFlags enumerated type. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Set method This method is used to set the value of a specific simulated camera control setting. The Set method is declared as follows: HRESULT Set([IN]long Property, [IN]long lValue, [IN]long Flags) where Property  Used to specify the simulated camera control setting to set the value of. Use a member of the CameraControlProperty enumerated type. lValue Used to specify the new value of the simulated camera control setting.  Flags A member of the CameraControlFlags enumerated type.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Get method This method is used to get the current value of a specific simulated camera control setting. The Get method is declared as follows: HRESULT Get([IN]long Property, [OUT]long *lValue, [OUT]long *Flags) where Property  Used to specify the simulated camera control setting to get the value of. Use a member of the CameraControlProperty enumerated type. lValue Used to retrieve the current value of the simulated camera control setting.  Flags Pointer to a member of the CameraControlFlags enumerated type.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error IAMVideoControl interface The IAMVideoControl interface contains methods to flip a picture horizontally and/or vertically. Methods on this interface that are not related to the flip operations will not be exposed, nor used by TAPI. The following list identifies the only methods of IAMVideoControl interface exposed by TAPI: GetCaps  Used to retrieve the capabilities of the video encoder filter regarding flipping pictures. SetMode Used to flip a picture horizontally or vertically.  GetMode Used to retrieve the current flip state.  The IAMVideoControl interface uses the VideoControlFlags enumerated data type to describe flip modes. VideoControlFlags enumerated data type This enumerated data type is defined as follows: typedef enum tagVideoControlFlags     VideoControlFlag_FlipHorizontal        = 0x0001,     VideoControlFlag_FlipVertical          = 0x0002,     VideoControlFlag_ExternalTriggerEnable = 0x0004,     VideoControlFlag_Trigger               = 0x0008 } VideoControlFlags; where only the two first values are used: VideoControlFlag_FlipHorizontal Specifies that the picture is flipped horizontally.  VideoControlFlag_FlipVertical Specifies that the picture is flipped vertically.  GetCaps method This method is used to retrieve the capabilities of the video encoder filter regarding flipping pictures. The GetCaps method is declared as follows: HRESULT GetCaps([IN]IPin *pPin, [OUT]long *pCapsFlags) where pPin  Used to specify the compressed video output pin to query capabilities from. pCapsFlags Used to retrieve a value representing a combination of the flags from the VideoControlFlags enumeration.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error SetMode method This method is used to flip a picture horizontally of vertically. The SetMode method is declared as follows: HRESULT SetMode([IN]IPin *pPin, [IN]long Mode) where pPin  Used to specify the pin to set the flip mode on. Used to specify a combination of the flags from the VideoControlFlags enumeration.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetMode method This method is used to retrieve the capabilities of the video encoder filter regarding flipping pictures. The GetCaps method is declared as follows: HRESULT GetCaps([IN]IPin *pPin, [OUT]long *Mode) where pPin  Used to specify the pin to get the flip mode of. Pointer to a value representing a combination of the flags from the VideoControlFlags enumeration.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Video encoder filter H.245 video capabilities The TAPI 3.1 MSP Capability module is responsible for coordinating capability advertisement and resolution with respect to the limits configured in the TAPI 3.1 MSP Quality Controller. Installable encoder and decoder filters are required to implement a new IH245VideoCapability interface provide the TAPI 3.1 MSP Capability module with a table of estimated steady-state resource requirements as related to each format that the codec supports. While run-time resource requirements fluctuate within a continuum, the steady-state resource requirements are meant to indicate relative resource requirements under near-ideal conditions and no network loss. At minimum, the resource requirements should include the typical maximum bitrate and CPU utilization (in % of the host CPU) for each supported format. The steady-state resource requirement information is used only by the TAPI 3.1 MSP Capability module to ensure that negotiated formats always fall within the maximum configured resource budget. Given the steady-state resource requirements of all filters and the resource limits configured in the TAPI 3.1 MSP Quality Controller, the TAPI 3.1 MSP Capability module is able to build the local simultaneous capability descriptors and to disable advertisement and selection of formats which exceed or approach the configured resource limits. Once streaming is active, fluctuations in actual bitrate and CPU load are then managed by the TAPI 3.1 MSP Quality Controller.  Standard Codec addition or replacement  When a standard codec is installed, the TAPI 3.1  MSP Capability module will use the IH245VideoCapability interface to obtain the capability information of the installed filter and add the supported transmit and receive capabilities in H.245/AM_MEDIA_TYPE form to internal transmit and receive capability lists in priority order. The TAPI 3.1 MSP Capability module also keeps track of the origin of the added capability so that it can find the appropriate filter instance at capability resolution and channel-open time. The MSP Capability module ignores duplicate H.245 capabilities in either list, so that if a replacement codec is installed and is at a higher priority than the original codec, the replacement codec will always be chosen over the original one.  The capability resolution code in the MSP Capability module is capable of advertising, understanding, comparing, and finding matches in local and remote capability lists provided that the capability is defined in the supported version of H.245. The only difference introduced by the installation of a replacement codec is as follows. When the Capability module finds a remote capability match via its existing priority search algorithm, it must check the chosen capability in its internal list for an association with a specific filter. This module differentiates between filters implementing the same standard algorithm by referencing their unique registered DirectShow GUID. Once a format is chosen and a channel is opened, the MSP channel control code passes the AM_MEDIA_TYPE structure to the MSP streaming components. Mode changes and openLogicalChannel requests are handled similarly by capability resolution code in the MSP Capability module. Given the channel parameters in H.245 form, it is capable of understanding, comparing, and finding a local capability that is compatible with the channel parameters in the mode change or openLogicalChannel request. Filter configuration is identical to the transmit case. Non-standard codec support Installation, negotiation, and selection of non-standard codecs places additional requirements on TAPI and the implementation of the codec filter. As when a standard codec is installed, the TAPI 3.1  MSP Capability module will obtain the capability information of the installed filter using the IH245VideoCapability interface. Recall that the format of the capability data for non-standard formats includes a sized byte array instead of an initialized H.245 structure. The capability module stores the sized byte array of each capability in its internal lists. When capabilities are advertised, the sized byte array is encapsulated in an extensible structure, which is in turn encapsulated in an H.245 non-standard capability structure. The extensible structure mentioned in the previous sentence is a tagged and sized structure. The structure is defined by Microsoft and is not exposed. The purpose of the structure is to allow support of multiple non-standard capability negotiation mechanisms within Microsoft products without breaking interoperability. (There is only one H.221 non-standard identifier assigned to Microsoft Corp). There are already defined tags for NetMeeting's non-standard audio and video capability "capsules". A new tag will be defined that identifies the contents as "the TAPI 3.1 non-standard codec scheme". This will allow shipped versions of NetMeeting to ignore new non-standard capabilities that it may receive. When non-standard capabilities are involved, The TAPI 3.1 MSP Capability module recognizes the presence of non-standard capabilities and delegates the interpretation of their contents according to the H.221 non-standard identifier and the contents of the encapsulation structure. As always, the prioritized search for a matching capability favors the order of the local transmit capability list. The target of the search is based on the current "top" of the local transmit capability list. If the current search target is a non-standard capability, the TAPI 3.1 MSP capability module searches the received capability list for a non-standard capability that has a matching H.221 non-standard identifier. Whenever a matching H.221 non-standard identifier (Microsoft) is found, the TAPI 3.1 MSP capability module reads the encapsulated tag to see if the non-standard capability scheme identified by that tag is supported on the platform. If the tag indicates that the nonstandard data is formatted according to "the TAPI 3.1 non-standard codec scheme", the MSP Capability module uses the facilities of the installed codec filter modules to interpret non-standard capability data. Recall that the transmit capability list contains references to the installed filter module that is supplying the capability, so this is the only filter module that needs to attempt interpretation of the candidate remote capability. This scheme avoids unnecessary attempts to interpret or recognize non-standard capability data.  Interpretation facilities provided by the installed codec filter  The interpretation methods of the IH245VideoCapability interface provide the following general facilities: Input Output Facility #1 (Sized byte array), (Sized byte array)  A local/remote pair of non-standard capabilities (Boolean) compare succeeded (HANDLE) negotiated format identifier (Sized byte array) non-standard logical channel parameters for the remote system (AM_MEDIA_TYPE) filter configuration structure Facility #2 (Sized byte array) non-standard logical channel parameters from remote system (Boolean) local format found (HANDLE) negotiated format identifier (AM_MEDIA_TYPE) filter configuration structure Facility #3 (HANDLE) negotiated format identifier Negotiated generic parameters useful for input to Quality Controller (max bitrate, frame rate, min/max frames/packet, etc) The installed codec filter is required to include basic negotiable parameters e.g. max frames per packet in its private representation of logical channel parameters, and to compute the intersection of local and remote parameters when facility #1 or #2 succeeds. The results of this intersection are stored internally and a unique handle is created ("negotiated format identifier" in the table above) to reference the intersection data.  Capability resolution/channel open mechanism If and when Facility #1 of IH245VideoCapability returns TRUE indicating that the compare succeeded, the TAPI 3.1 MSP Capability module of the sender forwards the negotiated format identifier, the filter configuration structure, and the non-standard logical channel parameters to the TAPI 3.1 MSP Channel control module. The Channel control module encapsulates and transfers the non-standard logical channel parameters to the remote system via openLogicalChannel. When the remote system receives the openLogicalChannel request, the TAPI 3.1 MSP Channel control module of the receiver forwards the channel parameters to the TAPI 3.1 MSP Capability module. The TAPI 3.1 MSP Capability module uses facility #2 of the installed codec filter to obtain the filter configuration structure and format identifier and returns the capability data to the TAPI 3.1 MSP Channel control module. The TAPI 3.1 MSP Channel control module may then configure the receive (decoding) filter and acknowledge the openLogicalChannel. The TAPI 3.1 MSP Channel control module may also obtain negotiated parameters e.g. maximum bitrate at this time and forward the result to the Quality Controller. When the TAPI 3.1 MSP Channel control module of the sender receives the openLogicalChannel ack, it may then configure the send (encoding) filter and Quality Controller similarly. The mechanisms for handling of mode changes at the sender are conceptually the same as those handling openLogicalChannel requests at the receiver. IH245VideoCapability interface The IH245VideoCapability interface contains methods to enumerate, translate, and compare video formats. The IH245VideoCapability interface contains the following methods: GetH245VersionID Used to retrieve a version identifier that indicates the version of H.245 that was in effect when the filter module was compiled. GetFormatTable Used to retrieve a table of supported formats as related to estimated system resources. This table may be dynamically allocated by the filter.  ReleaseFormatTable Used to release the format table allocated by GetFormatTable. IntersectFormats Used to compare a local capability and remote capability and produce filter configuration structures and parameters that are compatible with both.  GetLocalFormat Used to retrieve local format parameters that are compatible with a specific remote capability and parameters. GetNegotiatedLimitProperty Used to retrieve the value of a negotiated limiting parameter.  ReleaseNegotiatedCapability Used to release resources that were allocated by IntersectFormats or GetLocalFormat.  SetIDBase Used to control the range of sequential numbers that uniquely identify individual capabilities FindIDByRange Used to find a specific capability that corresponds to a formatted AM_MEDIA_TYPE structure.  The IH245VideoCapability interface uses the NegotiatedVideoLimit enumerated data type to describe negotiated video limiting parameters. Only generic properties which are useful to the TAPI MSP Quality Controller module are defined. NegotiatedVideoLimit enumerated data type This enumerated data type is defined as follows: typedef enum tagNegotiatedVideoLimit     NegotiatedVideo_MaxFrameRate,     NegotiatedVideo_MaxBitRate,     NegotiatedVideo_MaxBitsPerPicture, } NegotiatedVideoLimit; where: NegotiatedVideo_MaxFrameRate Specifies the smaller of the maximum continuous video frame rate that the receiver is capable of receiving or the transmitter is capable of transmitting.  NegotiatedVideo_MaxBitRate Specifies smaller of the maximum average video bit rate that the receiver is capable of receiving or the transmitter is capable of transmitting.  NegotiatedVideo_MaxBitsPerPicture Specifies the maximum number of bits that may be contained in a single video frame. If there is no negotiated maximum, this shall be zero.  VideoResourceBounds structure TAPI defines the VideoResourceBounds structure to specify the estimated maximum continuous resource requirements of a video encoding or decoding filter at a specific frame rate: typedef enum tag_VideoResourceBounds     int iPicturesPerSecond;     DWORD dwBitsPerPicture;     WORD wCPUUtilization; } VideoResourceBounds; where: iPicturesPerSecond Specifies an INTEGER value that indicates the video frame rate, in frames per second, for which the resource bounds are being specified. Frame rates of less than 1 frame per second are indicated by a negative value in units of seconds per frame.  dwBitsPerPicture Specifies a DWORD value that indicates the approximate average number of bits per video frame at an average frame rate of iPicturesPerSecond.  wCPUUtilization Specifies a WORD value that indicates the approximate average CPU utilization, in percent, of the encoder or decoder at the average frame rate of iPicturesPerSecond.  H245VideoCapabilityMap structure TAPI defines the H245VideoCapabilityMap structure to specify the relationship between supported formats and estimated maximum system resources for the supported format: typedef enum tag_H245VideoCapabilityMap     AM_MEDIA_TYPE *pAMMediaType;     H245VideoCapability h245VideoCapability;     GUID filterGuid;     DWORD dwUniqueID;     UINT uNumRatesSupported;     VideoResourceBounds *pResourceBoundArray; } H245VideoCapabilityMap; where: pAMMediaType Specifies a pointer to an AM_MEDIA_TYPE structure that describes the format of the video stream.  h245VideoCapability Specifies the H.245 video format, including all parameters and options. This structure is H.245 version specific: its definition depends on the version of H.245 that was in effect at the time the filter was developed. This structure may indicate format parameters for more than one standard video size at a time if the resource requirements are similar for all sizes.  filterGuid Specifies a GUID value that uniquely identifies the video encoder filter.  dwUniqueID Specifies a DWORD value that uniquely identifies the capability of the video encoder filter.  uNumRatesSupported This indicates the number of elements referenced by pResourceBoundArray and specifies the number of integral frame rates that are supported for the format options specified in pAMMediaType and h245VideoCapability.  pResourceBoundArray Specifies an array of VideoResourceBounds structures that indicate the approximate resource bounds of each supported integral frame rate.  H245VideoCapabilityTable structure TAPI defines the H245VideoCapabilityTable structure to specify the set of formats that are supported by the filter: typedef enum tag_H245VideoCapabilityTable     UINT uMappedCapabilities;     H245VideoCapabilityMap *pCapabilityArray; } H245VideoCapabilityTable; where: uMappedCapabilities Specifies  the  number of H245VideoCapabilityMap structures in pCapabilityArray.  pCapabilityArray Specifies a pointer to an array of H245VideoCapabilityMap structures.  GetH245VersionID method This method returns a DWORD value that identifies the platform version that the filter was designed for. The platform version is defined as TAPI_H245_VERSION_ID. The GetH245VersionID method is declared as: DWORD GetH245VersionID() GetFormatTable method This method is used to obtain H245VideoCapabilityMap structures for all formats and format options that the filter supports. In general, the content of the capability information that the TAPI 3.1 MSP Capability module obtains via the GetFormatTable method is a two dimensional table that relates every supported transmit and/or receive format to steady-state resource requirements of that format. In the case of standard codecs, the "format" information consists of an initialized H.245 data structure and an initialized AM_MEDIA_TYPE structure. The definition of this structure would be provided by Microsoft as part of a development kit. In the case of non-standard codecs, the H.245 structure would be replaced with a sized array of bytes. The contents of the nonstandard byte array are defined by the implementation of a complimentary pair of encoder and decoder filters. The GetFormatTable method is declared as follows: HRESULT GetFormatTable([IN]IPin *pPin, [OUT]H245VideoCapabilityTable *pTable) where pPin  Used to specify the output pin of the capture filter that will be providing input for encoder filters or the input pin of the filter receiving output from decoder filters. The filter shall enumerate the list of formats supported by this pin to build its own video capability table. pTable Pointer to an H245VideoCapabilityTable structure.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error ReleaseFormatTable method This method is used to release memory allocated by the GetFormatTable method. The ReleaseFormatTable method is declared as follows: HRESULT ReleaseFormatTable([IN]H245VideoCapabilityTable *pTable) where pTable Pointer to an H245VideoCapabilityTable structure.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error IntersectFormats method This method is used to compare and intersect one local capability and one remote capability and to obtain filter configuration parameters. The IntersectFormats method is declared as follows: HRESULT IntersectFormats([IN]H245VideoCapability *pLocalCapability, [IN]H245VideoCapability *pRemoteCapability, [OUT]HANDLE *phIntersectionCookie, [OUT]H245VideoCapability *pIntersectedCapability) where pLocalCapability  Specifies the H.245 video format, including all parameters and options defined by H.245, of a local video capability. pRemoteCapability  Specifies the H.245 video format, including all parameters and options defined by H.245, of a remote video capability. phIntersectionCookie  Identifies the dynamic instance of intersected capabilities. When a filter creates the intersection, it may allocate memory for the intersected capability parameters. The intersection cookie identifies this allocation. This is used to release internal allocations and also as an argument to the GetNegotiatedLimitProperty method. pIntersectedCapability  Specifies the H.245 video format, of the resolved common local and remote capability options and limits. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_INCOMPATIBLECAPS Failure E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetLocalFormat method This method is used to obtain local filter configuration parameters that are compatible with a remote capability. The GetLocalFormat method is declared as follows: HRESULT GetLocalFormat([IN]H245VideoCapability *pRemoteCapability, [IN]HANDLE *phIntersectionCookie, [OUT]AM_MEDIA_TYPE **ppAMMediaType) where pRemoteCapability  Specifies the H.245 video format, including all parameters and options defined by H.245, of a remote video capability. phIntersectionCookie  Identifies the dynamic instance of intersected capabilities. When a filter creates the intersection, it may allocate memory for the intersected capability parameters. The intersection cookie identifies this allocation. This is used to release internal allocations and also as an argument to the GetNegotiatedLimitProperty method. ppAMMediaType Pointer to the address of an AM_MEDIA_TYPE structure to receive the local format.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_INCOMPATIBLECAPS No local compatible capability exists E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetNegotiatedLimitProperty method This method is used to obtain negotiated limits that were determined by either the IntersectFormats or GetLocalFormat method. The GetNegotiatedLimitProperty method is declared as follows: HRESULT GetNegotiatedLimitProperty([IN]HANDLE hIntersectionCookie, [IN] NegotiatedVideoLimit LimitProperty, [OUT]DWORD *pdwValue) where hIntersectionCookie  Identifies the dynamic instance of intersected capabilities. LimitProperty  Identifies the limit property being retrieved. pdwValue Pointer to a DWORD value to receive the value of the specified limit property.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error ReleaseNegotiatedCapability method This method is used to release a filter's internal memory allocated by either the IntersectFormats or GetLocalFormat method. The ReleaseNegotiatedCapability method is declared as follows: HRESULT ReleaseNegotiatedCapability([IN]HANDLE hIntersectionCookie) where hIntersectionCookie  Identifies the dynamic instance of intersected capabilities. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error SetIDBase method This method is used to control the sequential numbering range used to uniquely identify a Filter s capabilities. The SetIDBase method is declared as follows: HRESULT SetIDBase([IN]DWORD dwIDBase) where dwIDBase  A DWORD value that indicates the beginning number in the sequence . This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error FindIDByRange method This method is used to obtain the unique format ID of a capability that corresponds to an AM_MEDIA_TYPE. The FindIDByRange method is declared as follows: HRESULT FindIDByRange([IN]AM_MEDIA_TYPE *pAMMediaType,[OUT]DWORD *pdwID) where pAMMediaType Pointer to an AM_MEDIA_TYPE structure that has been initialized indicate a specific format. pdwID  Pointer to a DWORD output parameter that will contain the unique format ID. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error References TAPI 3.1 Specifications Microsoft  TAPI  Video Decoder Filter   Streams and Interfaces DirectShow SDK articles and documentation Available from  HYPERLINK "http://www.microsoft.com/directx/pavilion/dshow" http://www.microsoft.com/directx/pavilion/dshow ITU communications standards Available from  HYPERLINK "http://www.itu.int/itudoc/itu-t/rec/h" http://www.itu.int/itudoc/itu-t/rec/h Recommendation H.245 v3 (09/97)   Control protocol for multimedia communication Recommendation H.261 (03/93)   Video codec for audiovisual services at px64 kbit/s Recommendation H.263 (03/96)   Video coding for low bit rate communication Recommendation H.263 v2 (01/98)   Video coding for low bit rate communication ITU home page:  HYPERLINK "http://www.itu.int/home" http://www.itu.int/home IETF Request for comments Available from  HYPERLINK "ftp://ftp.isi.edu/in-notes" ftp://ftp.isi.edu/in-notes RFC 1889   RTP: A Transport Protocol for real-time Applications RFC 2032   RTP Payload Format for H.261 video streams RFC 2190   RTP Payload Format for H.263 video streams RFC 2429   RTP Payload Format for the 1998 Version of ITU-T Rec. H.263 Video (H.263+)  Unless stated otherwise all references to TAPI apply to version 3.1. Microsoft Corporation Company Confidential  DATE  06/26/99        Draft - Microsoft Corporation Company Confidential      TIME  7:51 PM Revision 0.207            WDM Connection and Streaming Architecture Revision 0.4.  REVNUM  \* MERGEFORMAT              TITLE  \* MERGEFORMAT  Microsoft  TAPI  Video Encoder Filter  DATE  06/26/99            Microsoft Corporation Company Confidential            TIME  7:51 PM  DATE  06/26/99       Draft - Microsoft Corporation Company Confidential       TIME  7:51 PM Microsoft Corporation Company Confidential  DATE  06/26/99        Draft - Microsoft Corporation Confidential      TIME  7:51 PM IAMCrossbar IAMVideoProcAmp IAMCameraControl IAMVideoControl TAPI MSP Video Renderer Sink Filter Capture Pin TAPI MSP Video Encoder Filter H.263 Video I-Frame IRTPPDControl Preview Pin Payload header - F=0, P=0, SBIT=007, EBIT=000, SRC=011, R=00000, I=1, A=0, S=0, DBQ=00, TRB=000, TR=00000000 Optional Compressed Still-Image Pin IAMVideoProcAmp IAMCameraControl IAMVideoControl IH245VideoCapability IH245EncoderCommand IProgressiveRefinement INetworkStats IBitrateControl ICPUControl RTP Packetization Descriptor Compressed Video Pin TAPI MSP Video Capture Source Filter IRTPPDControl Optional RTP Packetization Descriptor IFrameRateControl ICPUControl IFrameRateControl ICPUControl IFrameRateControl ICPUControl IFrameRateControl ICPUControl IAMCrossbar IAMVideoProcAmp IAMCameraControl IAMVideoControl Capture Pin IProgressiveRefinement INetworkStats IBitrateControl ICPUControl TAPI MSP Network Send Sink Filter IRTPPDControl Optional RTP Packetization Descriptor IRTPPDControl TAPI MSP Video Encoder Filter Preview Pin TAPI MSP Video Renderer Sink Filter Optional Compressed Still-Image Pin IAMVideoProcAmp IAMCameraControl IAMVideoControl IH245VideoCapability IH245EncoderCommand IProgressiveRefinement INetworkStats IBitrateControl ICPUControl RTP Packetization Descriptor Compressed Video Pin TAPI MSP Video Capture Source Filter IProgressiveRefinement INetworkStats IBitrateControl ICPUControl TAPI MSP Network Send Sink Filter Payload header - F=0, P=0, SBIT=000, EBIT=001, SRC=011, R=00000, I=1, A=0, S=0, DBQ=00, TRB=000, TR=00000000 0x00806038 0x00806001 0x00806000 dwThisHeaderLength dwPayloadHeaderOffset dwPayloadHeaderLength dwPayloadStartBitOffset21247 dwPayloadEndBitOffset .26031 fEndMarkerBit dwLayerId dwTimestamp dwVideoAttributes dwReserved dwThisHeaderLength dwPayloadHeaderOffset dwPayloadHeaderLength dwPayloadStartBitOffset10784 dwPayloadEndBitOffset .21246 fEndMarkerBit dwLayerId dwTimestamp dwVideoAttributes dwReserved RTP_PD RTP_PD RTP_PD_HEADER dwThisHeaderLength dwPayloadHeaderOffset dwPayloadHeaderLength dwPayloadStartBitOffset dwPayloadEndBitOffset .10783 fEndMarkerBit dwLayerId dwTimestamp dwVideoAttributes dwReserved Payload header - F=0, P=0, SBIT=000, EBIT=000, SRC=011, R=00000, I=1, A=0, S=0, DBQ=00, TRB=000, TR=00000000 RTP_PD dwThisHeaderLength dwTotalByteLength ..128 dwNumHeaders dwReserved ~ytoje`[ ~ytoje`[ ~ytojf`]Z }zwrolifc`]Z zumjgd ~{xuroa |wrd_ZU {vqlgb]X {tokf_Z |wrmhc^Y |wrmhc^Y zupkfa\W zupkfa\ ~ytoje`[ {vqc^Y |wifc`] }xsnida^[ |yvqlgb]X spmhc^Y {vqnkhc^ |yvspmjb_\ ~{xupkgb }xqmhc_ {tpkfb] {vqmjgda |wrnkheb ~ytoje`]Z ~yupkgda {vrmhda^ |xurd {xupmhc^ }xtojfc` |nkhc`] |ytolifa ~rolgda^ urojgda zwtlifc` |xsnjgdX |ykhe`] {xurol`[X {vrmhda^ |xupheb_\ }xsnida^ ~ytolifa\ {vokfa] |xslhc^ }vrmhd_ ~ytoje`[ ~ytqnkfa\ {tpkfb] }xqmhc_ zvqlhc }xsnida^ {wrmid_ |wrnid` {vrmhd_ {oje^WP {mhc^YV spmhc^Y zupmj\ spmhc^ }xurojea |wrnib^ |wtqnid` zupkfa^[ |wtqnid_Z }xurojeb_ |ytokf_ ~yrnid` MSO Palette  )$+*($''-2@7-0=0''8L9=CEHIH+6OUNFT@GHE !E.'.EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE 1AQ"aq PwedS W^1*1j 5iZ<z ri/%:5~ mE^_~2J {sr~Q? Z]z<`_ MSO Palette  )$+*($''-2@7-0=0''8L9=CEHIH+6OUNFT@GHE !E.'.EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\doc\microsoft_tapi_rtp_new.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Corporation Microsoft RTP (Real-time Transport Protocol) Title _PID_HLINKSMicrosoft RTP (Real-time Transport Protocol) Andres Vega-Garcia This is a complete rewritting of the original document that was designed for an API based on a ioctl like interface. This one includes a subset of the functionality as individual methods ina few interfaces. NetMeeting Specification Andres Vega-Garcia Microsoft Word 10.0urn:schemas-microsoft-com:office:smarttags urn:schemas-microsoft-com:office:smarttags place TITLE  \* MERGEFORMAT  Microsoft RTP (Real-time Transport Protocol) Functional Specification   Draft Author:   AUTHOR  \* MERGEFORMAT  Andres Vega-Garcia Revision 0.7.  REVNUM  \* Arabic  \* MERGEFORMAT   SAVEDATE \@ "MMMM d, yyyy" \* MERGEFORMAT  May 16, 2001 This documentation is an early release of the final product documentation. It is meant to accompany software that is still in development. Some of the information in this documentation may be inaccurate or may not be an accurate representation of the functionality of the final retail product. Microsoft assumes no responsibility for any damages that might occur either directly or indirectly from these inaccuracies.  TOC \o \h \z   HYPERLINK \l "_Toc514501956"  Introduction  PAGEREF _Toc514501956 \h   HYPERLINK \l "_Toc514501957"  Scenarios  PAGEREF _Toc514501957 \h   HYPERLINK \l "_Toc514501958"  Proposed requirements list  PAGEREF _Toc514501958 \h   HYPERLINK \l "_Toc514501959"  RTP specific requirements  PAGEREF _Toc514501959 \h   HYPERLINK \l "_Toc514501960"  Demultiplexing requirements  PAGEREF _Toc514501960 \h   HYPERLINK \l "_Toc514501961"  Payload handling requirements  PAGEREF _Toc514501961 \h   HYPERLINK \l "_Toc514501962"  Participant handling requirements  PAGEREF _Toc514501962 \h   HYPERLINK \l "_Toc514501963"  Quality of service requirements  PAGEREF _Toc514501963 \h   HYPERLINK \l "_Toc514501964"  Cryptographic requirements  PAGEREF _Toc514501964 \h   HYPERLINK \l "_Toc514501965"  Statistics gathering requirements  PAGEREF _Toc514501965 \h   HYPERLINK \l "_Toc514501966"  Interface IRtpSession  PAGEREF _Toc514501966 \h   HYPERLINK \l "_Toc514501967"  Initialization  PAGEREF _Toc514501967 \h   HYPERLINK \l "_Toc514501968"  3.1.1  PAGEREF _Toc514501968 \h   HYPERLINK \l "_Toc514501969"  3.1.2 Deinit  PAGEREF _Toc514501969 \h   HYPERLINK \l "_Toc514501970"  Address and ports  PAGEREF _Toc514501970 \h   HYPERLINK \l "_Toc514501971"  3.2.1 GetPorts  PAGEREF _Toc514501971 \h   HYPERLINK \l "_Toc514501972"  3.2.2 SetPorts  PAGEREF _Toc514501972 \h   HYPERLINK \l "_Toc514501973"  3.2.3 GetAddress  PAGEREF _Toc514501973 \h   HYPERLINK \l "_Toc514501974"  3.2.4 SetAddress  PAGEREF _Toc514501974 \h   HYPERLINK \l "_Toc514501975"  3.2.5 SetScope  PAGEREF _Toc514501975 \h   HYPERLINK \l "_Toc514501976"  3.2.6 SetMcastLoopback  PAGEREF _Toc514501976 \h   HYPERLINK \l "_Toc514501977"  Miscellaneous  PAGEREF _Toc514501977 \h   HYPERLINK \l "_Toc514501978"  3.3.1 ModifySessionMask  PAGEREF _Toc514501978 \h   HYPERLINK \l "_Toc514501979"  Participants  PAGEREF _Toc514501979 \h   HYPERLINK \l "_Toc514501980"  3.4.1 EnumParticipants  PAGEREF _Toc514501980 \h   HYPERLINK \l "_Toc514501981"  3.4.2 GetParticipantState  PAGEREF _Toc514501981 \h   HYPERLINK \l "_Toc514501982"  3.4.3 GetMuteState  PAGEREF _Toc514501982 \h   HYPERLINK \l "_Toc514501983"  3.4.4 SetMuteState  PAGEREF _Toc514501983 \h   HYPERLINK \l "_Toc514501984"  3.4.5 GetNetEventState  PAGEREF _Toc514501984 \h   HYPERLINK \l "_Toc514501985"  3.4.6 SetNetMetricsState  PAGEREF _Toc514501985 \h   HYPERLINK \l "_Toc514501986"  3.4.7 GetNetworkInfo  PAGEREF _Toc514501986 \h   HYPERLINK \l "_Toc514501987"  SDES information  PAGEREF _Toc514501987 \h   HYPERLINK \l "_Toc514501988"  3.5.1 GetSdesInfo  PAGEREF _Toc514501988 \h   HYPERLINK \l "_Toc514501989"  3.5.2 SetSdesInfo  PAGEREF _Toc514501989 \h   HYPERLINK \l "_Toc514501990"   PAGEREF _Toc514501990 \h   HYPERLINK \l "_Toc514501991"  3.6.1 SetQosByName  PAGEREF _Toc514501991 \h   HYPERLINK \l "_Toc514501992"  3.6.2 SetQosAppId  PAGEREF _Toc514501992 \h   HYPERLINK \l "_Toc514501993"  3.6.3 SetQosState  PAGEREF _Toc514501993 \h   HYPERLINK \l "_Toc514501994"  3.6.4 ModifyQosList  PAGEREF _Toc514501994 \h   HYPERLINK \l "_Toc514501995"  Cryptography  PAGEREF _Toc514501995 \h   HYPERLINK \l "_Toc514501996"  3.7.1 SetEncryptionMode  PAGEREF _Toc514501996 \h   HYPERLINK \l "_Toc514501997"  3.7.2 SetEncryptionKey  PAGEREF _Toc514501997 \h   HYPERLINK \l "_Toc514501998"  Interface IRtpDemux  PAGEREF _Toc514501998 \h   HYPERLINK \l "_Toc514501999"  4.1.1 AddPin  PAGEREF _Toc514501999 \h   HYPERLINK \l "_Toc514502000"  4.1.2 SetPinCount  PAGEREF _Toc514502000 \h   HYPERLINK \l "_Toc514502001"  4.1.3 SetPinMode  PAGEREF _Toc514502001 \h   HYPERLINK \l "_Toc514502002"  4.1.4 SetMappingState  PAGEREF _Toc514502002 \h   HYPERLINK \l "_Toc514502003"  4.1.5 FindPin  PAGEREF _Toc514502003 \h   HYPERLINK \l "_Toc514502004"  4.1.6 FindSSRC  PAGEREF _Toc514502004 \h   HYPERLINK \l "_Toc514502005"  Interface IRtpMediaControl  PAGEREF _Toc514502005 \h   HYPERLINK \l "_Toc514502006"  5.1.1 SetFormatMapping  PAGEREF _Toc514502006 \h   HYPERLINK \l "_Toc514502007"  5.1.2 FlushFormatMappings  PAGEREF _Toc514502007 \h   HYPERLINK \l "_Toc514502008"  Interface IRtpDtmf  PAGEREF _Toc514502008 \h   HYPERLINK \l "_Toc514502009"  6.1.1 SetDtmfParameters  PAGEREF _Toc514502009 \h   HYPERLINK \l "_Toc514502010"  6.1.2 SendDtmfEvent  PAGEREF _Toc514502010 \h   HYPERLINK \l "_Toc514502011"  Interface IRtpRedundancy  PAGEREF _Toc514502011 \h   HYPERLINK \l "_Toc514502012"  7.1.1 SetRedParameters  PAGEREF _Toc514502012 \h   HYPERLINK \l "_Toc514502013"  Events  PAGEREF _Toc514502013 \h   HYPERLINK \l "_Toc514502014"  Error codes  PAGEREF _Toc514502014 \h   HYPERLINK \l "_Toc514502015"  References  PAGEREF _Toc514502015 \h   HYPERLINK \l "_Toc514502016"  Open issues  PAGEREF _Toc514502016 \h  Introduction The TAPI 3 streaming architecture consist of modular blocks named filters under the Direct Show terminology [ref]. In such architecture, multimedia data (e.g. audio, video) can be produced in a source filter, then be transformed in a transform filter, to be consumed in a render filter. That process is depicted in the next diagram.  In order to send this information over a network such as the Internet or a corporate network, we need Network Source and Render filters that implement the required protocols to enable sending and receiving data from such networks. Most of such protocols are already a service from the operating system, e.g. TCP/IP, but others still need to be implemented in the application space. That is the case for the Real-time Transport Protocol (RTP) [ref] which has been adopted to carry real time data on top of UDP/IP. The basic requirements for an RTP source and render filters are to implement the RTP protocol and to support the Direct Show model. But in addition to the basic requirements, there exist many others that will give the RTP filters a powerful richness and flexibility that will easy the task of building much more complex scenarios. TOREDO The rest of the document is organized in the following way:  Section   REF _Ref436641541 \r \h   describes some scenarios for which special features are required in the RTP filters. Section   REF _Ref436641565 \r \h   puts together a comprehensive list of requirements. Section   REF _Ref438020020 \r \h   presents the interface and generic method. Sections   REF _Ref442599149 \r \h  Error! Reference source not found.  thou   REF _Ref444073524 \r \h  Error! Reference source not found.  give detailed information for each function s category. Section   REF _Ref444073500 \r \h   contains the references. Scenarios The scenarios described below reflect the functionalities that in some way must be made available to an application. An application has the choice to use those functionalities to achieve a specific behavior. The implication of it is that some support needs to be provided all along the path between the application and the RTP filters. The application is capable of selecting to discard (mute) incoming data from specific participants or from specific sessions without rendering it. The application is capable of selecting not to send data to one or more of its destination addresses. An application is capable to show the user graphically, the state of each (remote) participant, e.g. currently sending data, silent, left the session, etc. Video follows audio. An application can decide to render a single video window which displays at any time the video for the current speaker, or can render it at full size/bit rate. The application provides a way for the user to feed the SDES information to be sent (some of the SDES items are set programmatically and can not be overridden, e.g. CNAME). The user can select who receives QoS. The user/application can decide the action to take when doing QoS reservation fails, e.g. if the connection fails altogether, the application pass to use best effort. The application can specify the encryption key to use for the session, which may be different for receiver and sender. The application can specify what portions of the RTP/RTCP packets are encrypted. For sessions where a  pass phrase  may be distributed by non TAPI means, the user should be able to feed in the pass phrase and specify the encryption algorithm to use for the secure session. For sessions where the address/port to use is distributed by non TAPI means, the user should be able to feed in the multicast address, port and TTL to be used in that session. Proposed requirements list This section presents the RTP network filters requirements. Those requirements are classified in 7 categories or families RTP specific Demultiplexing Payload handling Participant information Quality of service Cryptographic functions Statistics RTP specific requirements Standard based RFC1889 compliant. Some specifications could be overridden, e.g. relax the even, odd, or the I, I+1 relationship between RTP and RTCP ports, not sending RTCP reports at all. Packet scheduling Packets sent from several sources can be put in different queues  and serviced by priority, at the same time, events may be generated when crossing low and high water marks. Mute sessions Individual sessions can be muted at any time. All data coming and/or going to that session is discarded. Advanced muting The initial state for all participants could be to start as muted. At any time, all new participants who join a conference could be also started as muted. Participants have state Each participant can be in one of the following states: TALKING, WAS_TALKING, SILENT, STALE, LEFT. The state would allow implementing video follows audio where we could watch only video from the one speaking. This also would allow identifying who is sending at any time and would allow disabling annoying or unwanted senders. Event handling All events can be enabled/disabled individually, e.g. RTP/RTCP events, QOS events, Demux events. Demultiplexing requirements Manual mapping Participants can be mapped manually to specific output pins. Automatic mapping New participants are mapped to the first available output pin that matches some criteria. After mapped, the participant keeps that pin until explicitly changed. Automatic then manual A new participant is mapped to the first free output pin that matches some criteria. Once a participant has a pin, it holds it until explicitly unmapped, or until the participant becomes silent (this includes an expired participant or one who left the session), at that time, the pin goes back to its initial state to accept a new participant. Payload handling requirements Playout delay handling Computes the de-jitter buffer required. Handles packetization descriptors Understands packetization descriptors that tell RTP how to split data into smaller packets. Inter session synchronization Data streams from different sessions can be synchronized against a master session. Used for lips-sync. Participant handling requirements Unified/scalable participants handling Ability to handle efficiently a large number of participants and do associations  across sessions, e.g. find out that user X in an audio session is the same as user Y in a video session. SDES handling SDES fields can be enabled individually for sender and receiver. Mute participants Individual participants can be muted at any time.  All data coming from that participant can be discarded. Quality of service requirements All 3 reservation styles in RSVP Support for Fixed Filter (FF), Wildcard filter (WF) and Shared Explicit (SE). Asynchronous notifications Some QOS related events are generated asynchronously and passed up as events. On the fly flow spec update The reservation for receivers, or the sending flow spec can be modified at any time. On the fly modification of filters for shared explicit The set of filters (participants) that share a reservation can be modified dynamically. Ask for permission to send Asking for permission to send can be configured, and when asking, the behavior can be to wait or not for receivers before starting to send. Asynchronous reservation Setting QOS (SIO_SET_QOS) can be done asynchronously. Flow spec specification Provide interfaces to fine-tune the flow spec  to use. Cryptographic requirements Independent keys Each sender and receiver can have different keys. Built upon CryptoAPI Using CAPI allows taking advantage of the richness of algorithms supported by CAPI. Accepts pass phrase Capable of producing a key from text (pass phrase) Statistics gathering requirements Statistics Gathering statistics  on bytes/packets sent/received, probably  also frames per second based on timestamp. Bandwidth usage detection Computes the average bandwidth used (sender or receiver) Interface's bandwidth detection Estimation of interface s bandwidth based on sending latency. Interface IRtpSession This is the main interface to control an RTP session, it consist of 7 categories: Initialization Address and ports Miscellaneous Participants SDES information Cryptography Initialization There is only one initialization method, no other method can be used before this one is called (the exception is GetSdesInfo() and some IRtpDemux methods). Initializes an RTP session, either for a source or render RTP filter. HRESULT Init(             [IN OUT] HANDLE *phCookie,             [IN] DWORD       dwFlags         ); Parameters use: phCookie Allows the same RTP session to be shared by a source and a render filter. The first call (e.g. a source filter) will have the cookie initialized to NULL; the next call (e.g. the corresponding render filter) will use the previously returned cookie to lookup the same RTP session dwFlags Specify 1 or more flags to configure the RTP session Valid flags: RTPINIT_ENABLE_QOS The session may be QOS enabled (create sockets that support QOS and ask for reservations) RTPINIT_PERSIST_SSRC Make the SSRC be persistent, i.e. it will not change after the session goes through a stop/start RTPINIT_PERSIST_SOCKETS Make the sockets be persistent, i.e. they will not be closed/created after the session goes through a stop/start. This guarantee the port to which the sockets were bound will remain in use by the same socket RTPINIT_CLASS_AUDIO Gives the session an identity as AUDIO class, some features such as thread priority and playout delay computation are dependent on the session s class to be audio RTPINIT_CLASS_VIDEO Gives the session an identity as VIDEO class RTPINIT_MATCHRADDR Enable a filter to reject all packets not coming from the remote address RTPINIT_RADDRRESETDEMUX Enable resetting the demux (i.e. unmap all outputs) whenever a new remote address is set Returned value: NOERROR Call succeeded RTPERR_POINTER Null pointer was passed when no NULL was expected RTPERR_INVALIDSTATE Null cookie passed for new session, but some pointers were already initialized RTPERR_INVALIDRTPADDR Internal structure (RTP address) found is invalid, because of a bad cookie passed RTPERR_REFCOUNT Unexpected ref count value Remarks: This method shouldn t be called more than once, but if done, the cookie must be preserved, e.g. if the first time it was passed with a NULL value, which was updated to a non NULL value during the first Init, then the next time that same value returned on the first call must be used. In addition, any successive call to Init must use the same flags that were used the first time. The only way to call Init with different flags and new empty cookie, is after having had called Deinit(). Deinit De-initializes an RTP session, so a new call to Init with a NULL cookie and possible different flags can and must be done before other functions can be used. HRESULT Deinit(         ); Returned value: NOERROR Call succeeded RTPERR_INVALIDSTATE The RTP filter is still active, i.e. the DShow RTP filter is. Remarks: This method takes the filter to an state such that it behaves as if Init hadn t been called at all. Address and ports This group of methods is used to set/get IP addresses and to configure other networking related parameters. NOTE: All IP addresses and port numbers are exchanged in NETWORK order. GetPorts Retrieves one or more of the RTP or RTCP, local or remote ports. HRESULT GetPorts(             [OUT] WORD      *pwRtpLocalPort,             [OUT] WORD      *pwRtpRemotePort,             [OUT] WORD      *pwRtcpLocalPort,             [OUT] WORD      *pwRtcpRemotePort         ); Parameters use: pwRtpLocalPort If this pointer is non NULL, copy the local RTP port pwRtpRemotePort If this pointer is non NULL, copy the remote RTP port pwRtcpLocalPort If this pointer is non NULL, copy the local RTCP port pwRtcpRemotePort If this pointer is non NULL, copy the remote RTCP port Returned value: NOERROR Call succeeded RTPERR_POINTER Null pointers were passed when at least one non NULL pointer was expected RTPERR_INVALIDSTATE Init not done, or local ports had not been specified yet or can not be assigned because the local address hasn t been selected yet, or internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPADDR Internal structure found is invalid SetPorts Sets one or more of the RTP or RTCP, local or remote ports. HRESULT SetPorts(             [IN] WORD        wRtpLocalPort,             [IN] WORD        wRtpremotePort,             [IN] WORD        wRtcpLocalPort,             [IN] WORD        wRtcpRemotePort         ); Parameters use: wRtpLocalPort Local RTP port wRtpRemotePort Remote RTP port wRtcpLocalPort Local RTCP port wRtcpRemotePort Remote RTCP port Returned value: NOERROR Call succeeded RTPERR_INVALIDSTATE Init not done or internal pointer was found to be NULL when a non NULL was expected or attempt to assign a local port when one is already assigned and is different RTPERR_INVALIDRTPADDR Internal structure found is invalid Remarks: Do nothing if passing -1, otherwise assign value (including 0). GetAddress Retrieves local or remote IP address. HRESULT GetAddress(             [OUT] WORD      *pdwLocalAddr,             [OUT] WORD      *pdwRemoteAddr         ); Parameters use: pwRtpLocalAddr If this pointer is non NULL, copy the local RTP address pwRtpRemoteAddr If this pointer is non NULL, copy the remote RTP address Returned value: NOERROR Call succeeded RTPERR_POINTER Null pointers were passed when at least one non NULL pointer was expected  RTPERR_INVALIDSTATE Init not done or the address is not available yet or internal pointer was found to be NULL when non NULL was expected RTPERR_INVALIDRTPADDR Internal structure found is invalid SetAddress Sets local or remote IP address. HRESULT SetAddress(             [IN] DORD        dwLocalAddr,             [IN] DORD        dwRemoteAddr         ); Parameters use: dwLocalAddr Local RTP address dwRemoteAddr Remote RTP address Returned value: NOERROR Call succeeded RTPERR_INVALIDARG Both addresses are 0 RTPERR_INVALIDSTATE Init not done or internal pointer was found to be NULL when non NULL was expected RTPERR_INVALIDRTPADDR Internal structure found is invalid Remarks: If local address passed is 0, assign an address based on the remote address. SetScope Sets the IP scope, i.e. TTL (Time To Live). HRESULT SetScope(             [IN] DWORD       dwTTL             [IN] DwORD       dwFlags         ); Parameters use: dwTTL Time to live value dwFlags Some flags Valid flags: RTPTTL_RTP Set scope to RTP RTPTTL_RTCP Set scope to RTCP RTPTTL_RTPRTCP Set scope to RTP and RTCP Returned value: NOERROR Call succeeded RTPERR_INVALIDSTATE Init not done yet Remarks: The default scope is DEFAULT_UCAST_TTL (127) for unicast and DEFAULT_MCAST_TTL (4) for multicast. SetMcastLoopback Sets the IP multicast loop-back mode. HRESULT SetMcastLoopback(             [IN] int         iMcastLoopbackMode,             [IN] DWORD       dwFlags          ); Parameters use: iMcastLoopbackMode Multicast mode dwFlags Some flags (not used, pass 0) Valid flags: Pass 0 Returned value: NOERROR Call succeeded RTPERR_INVALIDARG Invalid multicast mode RTPERR_INVALIDSTATE Init not done yet Remarks: The modes can be any of the following: RTPMCAST_LOOPBACKMODE_NONE Multicast loop-back disabled RTPMCAST_LOOPBACKMODE_PARTIAL Receive local packets except those sent by the same socket RTPMCAST_LOOPBACKMODE_FULL Receive all multicast packets including those sent by the same socket Miscellaneous ModifySessionMask Modify or query one of the session s masks. HRESULT ModifySessionMask(             [IN] DWORD       dwKind,             [IN] DWORD       dwMask,             [IN] DWORD       dwValue,             [IN OUT] DWORD  *pdwModifiedMask          ); Parameters use: dwKind Specifies one of the different kinds of masks that can be queried/modified. dwMask Specifies the mask of bits to be set, or reset dwValue Non zero to set, 0 to reset the bits selected by dwMask pdwModifiedMask If non NULL, returns the resulting mask. Note that passing a dwMask=0, will not modify any bits and that way the current mask is just queried Returned value: NOERROR Call succeeded RTPERR_CRITSECT Failed to acquire a critical section RTPERR_INVALIDARG Invalid mask kind RTPERR_INVALIDSTATE Init not done yet, or an internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPSESS An internal structure was found to be invalid Remarks: The kinds of masks that can be used (parameter dwKind) are: RTPMASK_FEATURES_MASK RTPMASK_RECV_EVENTS RTPMASK_SEND_EVENTS RTPMASK_PINFOR_EVENTS RTPMASK_PINFOS_EVENTS RTPMASK_QOSRECV_EVENTS RTPMASK_QOSSEND_EVENTS RTPMASK_SDESRECV_EVENTS RTPMASK_SDESSEND_EVENTS RTPMASK_SDES_LOCMASK RTPMASK_SDES_REMMASK And the specific masks and the events (if applicable) that they enable, are listed below for each kind of mask: RTPMASK_FEATURES_MASK: Bit masks used to select what RTP features that will be in use: RTPFEAT_GENTIMESTAMP RTPFEAT_PASSHEADER RTPFEAT_BADESTIMATION RTPMASK_RECV_EVENTS, RTPMASK_SEND_EVENTS: Bit masks used to select what RTP events will be fired to a receiver (e.g. RTP source filter), the default is to fire no events. And/or a sender (e.g. an RTP render filter), the default is to fire no events: RTPRTP_MASK_RR_RECEIVED            RTPRTP_EVENT_RR_RECEIVED RTPRTP_MASK_SR_RECEIVED            RTPRTP_EVENT_SR_RECEIVED RTPRTP_MASK_LOCAL_COLLISION        RTPRTP_EVENT_LOCAL_COLLISION RTPRTP_MASK_WS_RECV_ERROR          RTPRTP_EVENT_WS_RECV_ERROR RTPRTP_MASK_WS_SEND_ERROR          RTPRTP_EVENT_WS_SEND_ERROR RTPRTP_MASK_WS_NET_FAILURE         RTPRTP_EVENT_WS_NET_FAILURE RTPRTP_MASK_RECV_LOSSRATE          RTPRTP_EVENT_RECV_LOSSRATE RTPRTP_MASK_SEND_LOSSRATE          RTPRTP_EVENT_SEND_LOSSRATE RTPRTP_MASK_SEND_BANDESTIMATION    RTPRTP_EVENT_SEND_BANDESTIMATION RTPRTP_MASK_CRYPT_RECV_ERROR       RTPRTP_EVENT_CRYPT_RECV_ERROR RTPRTP_MASK_CRYPT_SEND_ERROR       RTPRTP_EVENT_CRYPT_SEND_ERROR RTPMASK_PINFOR_EVENTS, RTPMASK_PINFOS_EVENTS: Bit masks used to enable firing the specific events to a receiver (e.g. RTP source filter), the default is to fire no events. And/or to a sender (e.g. an RTP render filter), the default is to fire no events: RTPPARINFO_MASK_CREATED            RTPPARINFO_EVENT_CREATED RTPPARINFO_MASK_SILENT             RTPPARINFO_EVENT_SILENT RTPPARINFO_MASK_TALKING            RTPPARINFO_EVENT_TALKING RTPPARINFO_MASK_WAS_TALKING        RTPPARINFO_EVENT_WAS_TALKING RTPPARINFO_MASK_STALL              RTPPARINFO_EVENT_STALL RTPPARINFO_MASK_BYE                RTPPARINFO_EVENT_BYE RTPPARINFO_MASK_DEL                RTPPARINFO_EVENT_DEL RTPPARINFO_MASK_MAPPED             RTPPARINFO_EVENT_MAPPED RTPPARINFO_MASK_UNMAPPED           RTPPARINFO_EVENT_UNMAPPED RTPPARINFO_MASK_NETWORKCONDITION   RTPPARINFO_EVENT_NETWORKCONDITION RTPMASK_QOSRECV_EVENTS, RTPMASK_QOSSEND_EVENTS: Bit masks used to enable firing QOS notification events for a receiver (e.g. RTP source filter), the default is to fire no events. And/or a sender (e.g. an RTP render filter), the default is to fire no events: RTPQOS_MASK_NOQOS                  RTPQOS_EVENT_NOQOS RTPQOS_MASK_RECEIVERS              RTPQOS_EVENT_RECEIVERS RTPQOS_MASK_SENDERS                RTPQOS_EVENT_SENDERS RTPQOS_MASK_NO_SENDERS             RTPQOS_EVENT_NO_SENDERS RTPQOS_MASK_NO_RECEIVERS           RTPQOS_EVENT_NO_RECEIVERS RTPQOS_MASK_REQUEST_CONFIRMED      RTPQOS_EVENT_REQUEST_CONFIRMED RTPQOS_MASK_ADMISSION_FAILURE      RTPQOS_EVENT_ADMISSION_FAILURE RTPQOS_MASK_POLICY_FAILURE         RTPQOS_EVENT_POLICY_FAILURE RTPQOS_MASK_BAD_STYLE              RTPQOS_EVENT_BAD_STYLE RTPQOS_MASK_BAD_OBJECT             RTPQOS_EVENT_BAD_OBJECT RTPQOS_MASK_TRAFFIC_CTRL_ERROR     RTPQOS_EVENT_TRAFFIC_CTRL_ERROR RTPQOS_MASK_GENERIC_ERROR          RTPQOS_EVENT_GENERIC_ERROR RTPQOS_MASK_ESERVICETYPE           RTPQOS_EVENT_ESERVICETYPE RTPQOS_MASK_EFLOWSPEC              RTPQOS_EVENT_EFLOWSPEC RTPQOS_MASK_EPROVSPECBUF           RTPQOS_EVENT_EPROVSPECBUF RTPQOS_MASK_EFILTERSTYLE           RTPQOS_EVENT_EFILTERSTYLE RTPQOS_MASK_EFILTERTYPE            RTPQOS_EVENT_EFILTERTYPE RTPQOS_MASK_EFILTERCOUNT           RTPQOS_EVENT_EFILTERCOUNT RTPQOS_MASK_EOBJLENGTH             RTPQOS_EVENT_EOBJLENGTH RTPQOS_MASK_EFLOWCOUNT             RTPQOS_EVENT_EFLOWCOUNT RTPQOS_MASK_EUNKOWNPSOBJ           RTPQOS_EVENT_EUNKOWNPSOBJ RTPQOS_MASK_EPOLICYOBJ             RTPQOS_EVENT_EPOLICYOBJ RTPQOS_MASK_EFLOWDESC              RTPQOS_EVENT_EFLOWDESC RTPQOS_MASK_EPSFLOWSPEC            RTPQOS_EVENT_EPSFLOWSPEC RTPQOS_MASK_EPSFILTERSPEC          RTPQOS_EVENT_EPSFILTERSPEC RTPQOS_MASK_ESDMODEOBJ             RTPQOS_EVENT_ESDMODEOBJ RTPQOS_MASK_ESHAPERATEOBJ          RTPQOS_EVENT_ESHAPERATEOBJ RTPQOS_MASK_RESERVED_PETYPE        RTPQOS_EVENT_RESERVED_PETYPE RTPQOS_MASK_NOT_ALLOWEDTOSEND      RTPQOS_EVENT_NOT_ALLOWEDTOSEND RTPQOS_MASK_ALLOWEDTOSEND          RTPQOS_EVENT_ALLOWEDTOSEND RTPMASK_SDESRECV_EVENTS, RTPMASK_SDESSEND_EVENTS: Bit masks used to enable firing events upon the arrival of SDES items. The events can be fired to a receiver (e.g. an RTP source filter), the default is to fire no events. And/or to a sender (e.g. RTP render filter), the default is to fire no events. In order to fire these events, the SDES item must also be enabled to be accepted and stored using the RTPMASK_SDES_REMMASK mask: RTPSDES_MASK_CNAME                 RTPSDES_EVENT_CNAME RTPSDES_MASK_NAME                  RTPSDES_EVENT_NAME RTPSDES_MASK_EMAIL                 RTPSDES_EVENT_EMAIL RTPSDES_MASK_PHONE                 RTPSDES_EVENT_PHONE RTPSDES_MASK_LOC                   RTPSDES_EVENT_LOC RTPSDES_MASK_TOOL                  RTPSDES_EVENT_TOOL RTPSDES_MASK_NOTE                  RTPSDES_EVENT_NOTE RTPSDES_MASK_PRIV                  RTPSDES_EVENT_PRIV RTPSDES_MASK_BYE                   RTPSDES_EVENT_BYE RTPSDES_MASK_ANY                   RTPSDES_EVENT_ANY RTPMASK_SDES_LOCMASK: Bit masks used to select the SDES items to send (provided they have a default value or one has been set) in RTCP reports; the default is to send all the SDES items available. RTPSDES_LOCMASK_CNAME RTPSDES_LOCMASK_NAME RTPSDES_LOCMASK_EMAIL RTPSDES_LOCMASK_PHONE RTPSDES_LOCMASK_LOC RTPSDES_LOCMASK_TOOL RTPSDES_LOCMASK_NOTE RTPSDES_LOCMASK_PRIV RTPMASK_SDES_REMMASK  Bit masks used to select the SDES items to accept and store when they are received from the remote participants in their RTCP reports, the default is to accept and store all the SDES items received: RTPSDES_REMMASK_CNAME RTPSDES_REMMASK_NAME RTPSDES_REMMASK_EMAIL RTPSDES_REMMASK_PHONE RTPSDES_REMMASK_LOC RTPSDES_REMMASK_TOOL RTPSDES_REMMASK_NOTE RTPSDES_REMMASK_PRIV Participants NOTE: All the SSRCs are exchanged in NETWORK order and where appropriate, SSRC can be set to  1 to indicate that the first SSRC found is to be used. EnumParticipants Enumerates the participants (SSRCs). HRESULT EnumParticipants(             [OUT] DWORD     *pdwSSRC,             [IN OUT] DWORD  *pdwNumber          ); Parameters use: pdwSSRC Array of DWORDs where to copy the SSRCs pdwNumber Contains the maximum entries to copy, and returns the actual number of SSRCs copied Returned value: NOERROR Call succeeded RTPERR_POINTER Both pointers are NULL when at least pdwNumber was expected to be non NULL RTPERR_CRITSECT Failed to acquire a critical section RTPERR_NOTINIT Init not done yet RTPERR_INVALIDSTATE An internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPADDR Internal structure found is invalid Remarks: If pdwSSRC is NULL, but pdwNumber is not, return in pdwNumber the current number of SSRCs. GetParticipantState Obtain participant s state. HRESULT GetParticipantState(             [IN] DWORD       dwSSRC,             [OUT] int       *piState          ); Parameters use: dwSSRC Participant s SSRC whose state is to be retrieved piState Current participant s state Returned value: NOERROR Call succeeded RTPERR_INVALIDARG SSRC not specified RTPERR_POINTER NULL pointer RTPERR_CRITSECT Failed to obtain a critical section RTPERR_NOTINIT Init not done yet RTPERR_INVALIDSTATE An internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPADDR Internal structure found is invalid Remarks: The state can be any of the following: RTPPARINFO_SILENT RTPPARINFO_TALKING RTPPARINFO_WAS_TALKING RTPPARINFO_STALL (Haven t receive RTP nor RTCP packets for some time) GetMuteState Obtain participant s mute state. HRESULT GetMuteState(             [IN] DWORD       dwSSRC,             [OUT] BOOL      *pbMuted          ); Parameters use: dwSSRC Participant s SSRC whose state is to be retrieved pbMuted Mute state (1=muted, 0=not muted) Returned value: NOERROR Call succeeded RTPERR_INVALIDARG SSRC not specified RTPERR_POINTER NULL pointer RTPERR_CRITSECT Failed to obtain a critical section RTPERR_NOTINIT Init not done yet RTPERR_INVALIDSTATE An internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPADDR Internal structure found is invalid SetMuteState Set the participant s mute state. HRESULT SetMuteState(             [IN] DWORD       dwSSRC,             [IN] BOOL        bMuted          ); Parameters use: dwSSRC Participant s SSRC whose state is to be retrieved bMuted Mute state (non zero=muted, 0=not muted) Returned value: NOERROR Call succeeded RTPERR_INVALIDARG SSRC not specified RTPERR_CRITSECT Failed to obtain a critical section RTPERR_NOTINIT Init not done yet RTPERR_INVALIDSTATE An internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPADDR Internal structure found is invalid GetNetEventState Obtain participant s generation of network quality metrics state. HRESULT GetNetMetricsState(             [IN] DWORD       dwSSRC,             [OUT] BOOL      *pbState          ); Parameters use: dwSSRC Participant s SSRC whose state is to be retrieved pbState Network metrics generation state (non zero=being generated, 0=not being generated) Returned value: NOERROR Call succeeded RTPERR_INVALIDARG SSRC not specified RTPERR_CRITSECT Failed to obtain a critical section RTPERR_NOTINIT Init not done yet RTPERR_INVALIDSTATE An internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPADDR Internal structure found is invalid SetNetMetricsState Sets the participant s generation of network quality metrics state. HRESULT SetNetMetricsState(             [IN] DWORD       dwSSRC,             [IN] BOOL        bState          ); Parameters use: dwSSRC Participant s SSRC whose state is to be set, 0 = enable metrics computation for any and all the SSRCs, -1= select the first SSRC bState Network metrics generation state (non zero=generate metrics, 0=do not generate metrics) Returned value: NOERROR Call succeeded RTPERR_INVALIDARG SSRC not specified RTPERR_CRITSECT Failed to obtain a critical section RTPERR_NOTINIT Init not done yet RTPERR_INVALIDSTATE An internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPADDR Internal structure found is invalid Remarks: When the network metrics are being generated, the event RTPPARINFO_EVENT_NETWORKCONDITION will be generated if enabled. When the vent is generated, P1 will contain the participant s SSRC that is reporting the given network conditions (each participant may perceive different network conditions) and P2 will contain encoded the network quality metrics. You can use the following macros to decode each parameter as follows: DWORD dwGlobalMetric = RTPNET_GET_dwGLOBALMETRIC(P2);/* 0 100 */ double dAvgRTT = RTPNET_GET_dRTT(P2);        /* seconds */ double dAvgJitter = RTPNET_GET_dJITTER(P2);  /* seconds */ double dLossRate = RTPNET_GET_dLOSSRATE(P2); /* Percentage */ GetNetworkInfo Sets the participant s generation of network quality metrics state. HRESULT GetNetworkInfo(             [IN] DWORD          dwSSRC,             [OUT] RtpNetInfo_t *pRtpNetInfo          ); Parameters use: dwSSRC Participant s SSRC whose state is to be set pRtpNetInfo Pointer to the structure to fill up with the network quality metrics as seen by this participant Returned value: NOERROR Call succeeded RTPERR_INVALIDARG SSRC not specified RTPERR_CRITSECT Failed to obtain a critical section RTPERR_NOTINIT Init not done yet RTPERR_INVALIDSTATE An internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPADDR Internal structure found is invalid Remarks: The structure contains information for average RTT, jitter and loss rate as well as a 0-100 metric of how good that parameter is and an overall network quality also in a 0-100 scale. See file msrtp.h for details about the structure and the indexes to use to obtain each parameter, e.g. NETQ_RTT_IDX for average RTT and how good is the RTT. Note that the average of the network parameters are available no matter the event for them is enabled or not, but the 0-100 metric and the global metric are only computed and hence available when the network metrics computation is enabled (using function SetNetMetricsState), and is made available in the event s parameter 2, if the event RTPPARINFO_EVENT_NETWORKCONDITION is enabled. SDES information GetSdesInfo Get SDES (Source Description) information. HRESULT GetSdesInfo(             [IN] DWORD       dwSdesItem,             [OUT] WCHAR     *psSdesData,             [IN OUT] DWORD  *pdwSdesDataLen,             [IN] DWORD       dwSSRC          ); Parameters use: dwSdesItem SDES item to be retrieved psSdesData Where to place the data retrieved pdwSdesDataLen Buffer length in UNICODE chars dwSSRC Participant s SSRC Returned value: NOERROR Call succeeded RTPERR_POINTER NULL pointer passed when a non NULL was expected RTPERR_INVALIDARG Invalid SDES item RTPERR_INVALIDSTATE Init not done yet or an internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPADDR Internal structure found is invalid RTPERR_NOTFOUND The SSRC was not found Remarks: Get a local SDES item if dwSSRC=0, otherwise gets the SDES item from the participant whose SSRC was specified. pdwSdesDataLen contains the initial size in UNICODE chars and returns the actual UNICODE chars copied (including the NULL terminating char). If the SDES item is not available, dwSdesDataLen is set to 0 and the call succeeds. SetSdesInfo Set the local SDES (Source Description) information. HRESULT SetSdesInfo(             [IN] DWORD       dwSdesItem,             [IN] WCHAR      *psSdesData          ); Parameters use: dwSdesItem SDES item to be set psSdesData NULL terminated UNICODE string to be set as the SDES item, it must not be bigger than 255 bytes once converted to UTF-8 Returned value: NOERROR Call succeeded RTPERR_POINTER NULL pointer passed when a non NULL was expected RTPERR_INVALIDARG Invalid SDES item or conversion to UTF-8 failed (possibly because the converted string was bigger than 255 bytes) RTPERR_INVALIDSTATE Init not done yet or an internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPADDR Internal structure found is invalid SetQosByName Set the QOS name (i.e. the name to derive the QOS flow specification) to be used. HRESULT SetQosByName(             [IN] WCHAR      *psQosName,             [IN] DWORD       dwResvStyle,             [IN] DWORD       dwMaxParticipants,             [IN] DWORD       dwQosSendMode,             [IN] DWORD       dwFrameSize          ); Parameters use: psQosName NULL terminates string with the QOS template s name to use dwResvStyle Reservation style dwMaxParticipants Maximum number of participants, usually 1 for unicast, but usually bigger than 1 for multicast  dwQosSendMode Send mode (senders only), modifies the sender s behavior when not allowed to send dwFrameSize Frame size in milliseconds, passing 0 makes this parameter be ignored Returned value: NOERROR Call succeeded RTPERR_POINTER NULL pointer passed when a non NULL was expected RTPERR_INVALIDARG QOS name passed, or reservation style, or send mode is invalid RTPERR_INVALIDSTATE Init not done yet or an internal pointer was found to be NULL when a non NULL was expected or the session is not QOS enabled RTPERR_INVALIDRTPADDR Internal structure found is invalid Remarks: The QOS name can be any of: RTPQOSNAME_G711 RTPQOSNAME_G723_1 RTPQOSNAME_GSM6_10 RTPQOSNAME_DVI4_8 RTPQOSNAME_DVI4_16 RTPQOSNAME_SIREN RTPQOSNAME_G722_1 RTPQOSNAME_MSAUDIO RTPQOSNAME_H263QCIF RTPQOSNAME_H263CIF RTPQOSNAME_H261QCIF RTPQOSNAME_H261CIF The reservation style can be any of: RTPQOS_STYLE_DEFAULT - Use default style, i.e. FF for unicast, WF for multicast. RTPQOS_STYLE_WF - Wildcard-Filter (default in multicast). RTPQOS_STYLE_F - FFixed-Filter (default in unicast). RTPQOS_STYLE_SE - Shared-Explicit (for multicast, typically for video). The send mode can be any of: RTPQOSSENDMODE_UNRESTRICTED - Don't ask for permission to send. RTPQOSSENDMODE_REDUCED_RATE - Ask permission to send, if denied, keep sending at a reduced rate. RTPQOSSENDMODE_DONT_SEND - Ask permission to send, if denied, DON'T SEND at all. RTPQOSSENDMODE_ASK_BUT_SEND - Ask permission to send, send at normal rate no matter what, the application is supposed to stop passing data to RTP or to pass the very minimum (this is the mode that should be used) . SetQosAppId Sets the QOS application ID. HRESULT SetQosAppId(             [IN] WCHAR      *psAppName,             [IN] WCHAR      *psAppGUID,             [IN] WCHAR      *psPolicyLocator          ); Parameters use: psAppName If the application name is specified, replaces the default name with the new UNICODE string. The default is the binary image name psAppGUID If the application GUID is specified, replaces the default with the new UNICODE string. The default is   HYPERLINK "http://www.microsoft.com"  www.microsoft.com psPolicyLocator If policy locator is specified, append a comma and this whole string to the default policy locator, if not, use only the default which would contain the codec type and name if available. Returned value: NOERROR Call succeeded RTPERR_POINTER NULL pointer passed when a non NULL was expected RTPERR_INVALIDARG Invalid SDES item RTPERR_INVALIDSTATE Init not done yet or an internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPADDR Internal structure found is invalid RTPERR_MEMORY Failed to allocate storage to the string(s) RTPERR_SIZE The string passed is bigger than allowed Remarks: Any parameter can be NULL but at least one of them MUST be not NULL.  The QOS policy locator built (either using defaults or new settings) will look similar to this: GUID=www.microsoft.com,APP=rtcclnt.exe,SAPP=MICROSOFT REAL-TIME COMMUNICATIONS,VER=1.0, SAPP=AUDIO,SAPP=DVI4_16 And the application name will look similar to this: rtcclnt.exe SetQosState Enable or disable the participant from sharing the QOS reservation. HRESULT SetQosState(             [IN] DWORD       dwSSRC,             [IN] BOOL        bEnable          ); Parameters use: dwSSRC Participant s SSRC whose reservation state (i.e. if he receives or not Shared Explicit (SE) reservation) is to be modified bEnable If non-zero, add (if not in it yet) this participant to the SE list of participants who shared the reservation. If zero, remove this participant (if already in it) from the SE list Returned value: NOERROR Call succeeded RTPERR_NOQOS The receiver was not initialized as QOS enabled or QOS initialization failed RTPERR_INVALIDSTATE Init not done yet or an internal pointer was found to be NULL when a non NULL was expected or the reservation style is not RTPQOS_STYLE_SE RTPERR_INVALIDRTPADDR Internal structure found is invalid Remarks: This is used only for receivers, for senders always return NOERROR. ModifyQosList Enable or disable participants from sharing the QOS reservation. HRESULT ModifyQosList(             [IN] DWORD      *pdwSSRC,             [IN OUT]DWORD   *pdwNumber,             DWORD            dwOperation          ); Parameters use: pdwSSRC Array or participant s SSRCs for which the QOS state is going to be modified pdwNumber Number of SSRCs passed in the array, on output, will return the number of SSRCs whose state changed, or was possible to change dwOperation RTPQOS_ADD_SSRC to add the participants to the SE list, RTPQOS_DEL_SSRC to remove from the participants from the SE list. RTPQOS_FLUSH can be used to empty the list before performing the ADD operation Returned value: NOERROR Call succeeded RTPERR_POINTER NULL pointer passed when a non NULL was expected RTPERR_NOQOS The receiver was not initialized as QOS enabled or QOS initialization failed RTPERR_QOS None of the participants could be added/deleted from the SE list RTPERR_INVALIDSTATE Init not done yet or an internal pointer was found to be NULL when a non NULL was expected or the reservation style is not RTPQOS_STYLE_SE RTPERR_INVALIDRTPADDR Internal structure found is invalid Remarks: This is used only for receivers, for senders always return NOERROR. Cryptography SetEncryptionMode Selects the encryption (and/or decryption) mode. HRESULT SetEncryptionMode(             [IN] int         iMode,             [IN] DWORD       dwFlags          ); Parameters use: iMode The encryption mode to be used dwFlags Some flags Valid flags: RTPCRYPT_SAMEKEY If more than one channel is going to be encrypted (i.e. RTP receive, RTP send, RTCP), use the same key for all of them. If this flag is not specified when setting the mode, each channel will use a separate key Returned value: NOERROR Call succeeded RTPERR_INVALIDARG Either the mode or flags are invalid RTPERR_NOTINIT Init not done yet RTPERR_INVALIDSTATE An internal pointer was found to be NULL when a non NULL was expected or the mode/flags are already set and are different from what is specified in the parameters passed or the underlying RTP session is already running RTPERR_INVALIDRTPADDR Internal structure found is invalid Remarks: The encryption mode , once set, cannot be changed. Multiple calls to this function must specify the same mode. If mode and flags are 0, the default mode will be RTPCRYPTMODE_ALL with the flag RTPCRYPT_SAMEKEY set. The encryption mode can be any of: RTPCRYPTMODE_PAYLOAD  - Encrypt/Decrypt RTP payload only. RTPCRYPTMODE_RTP - Encrypt/Decrypt RTP packets only. RTPCRYPTMODE_ALL- Encrypt/Decrypt RTP and RTCP packets. SetEncryptionKey Set 1 or more encryption (and/or decryption) parameters HRESULT SetEncryptionKey(             [IN] WCHAR      *psPassPhrase,             [IN] WCHAR      *psHashAlg,             [IN] WCHAR      *psDataAlg,             [IN] BOOL        bRtcp          ); Parameters use: psPassPhrase If not NULL, specifies the pass phrase to use to derive a key used for encryption and/or decryption psHashAlg If not NULL, specifies the hashing algorithm to use psDataAlg If not NULL, specifies the data encryption/decryption algorithm to use bRtcp If non-zero, specifies that the parameters are to be applied to RTCP, if zero, they are for RTP. This parameter is meaningless if the flag RTPCRYPT_SAMEKEY was used when selecting the encryption mode Returned value: NOERROR Call succeeded RTPERR_POINTER NULL pointers passed when a at least one non NULL was expected RTPERR_INVALIDARG At least one of the arguments is incorrect. It could be an empty pass phrase, a pass phrase bigger than RTPCRYPT_PASSPHRASEBUFFSIZE (256), or a non recognized algorithm (see remarks) RTPERR_NOTINIT Init not done yet RTPERR_INVALIDSTATE An internal pointer was found to be NULL when a non NULL was expected or the underlying RTP session is already running RTPERR_INVALIDRTPADDR Internal structure found is invalid RTPERR_RTPERR_CRYPTO Any of the Crypto API functions failed with the current parameters Remarks: The cryptographic objects are not created when this function is called but when the session starts, so for example, if the hashing algorithm specified is recognized and the call succeeds, that is not a guarantee that hashing will be possible using that algorithm. When the session starts, creation o the cryptographic objects will fail if that algorithm is not supported or is invalid for the purpose at hand. RTPCRYPT_PASSPHRASEBUFFSIZE is the buffer size in bytes to hold the pass phrase after it was converted from UNICODE to UTF-8. Interface IRtpDemux AddPin Add 1 more pin. HRESULT AddPin(             [IN] int         iOutMode,             [OUT] int       *piPos          ); Parameters use: iOutMode The pin mode piPos Returns the position of the newly created pin Returned value: NOERROR Call succeeded RTPERR_MEMORY Could not allocate memory for the pin RTPERR_INVALIDARG Invalid mode RTPERR_INVALIDSTATE An internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPSESS Internal structure found is invalid Remarks: The mode can be any of: RTPDMXMODE_MANUAL - Manual mapping. RTPDMXMODE_AUTO - Automatically map and unmap. RTPDMXMODE_AUTO_MANUAL - Automatically map, manual unmap. Adding pins should be done, as is the case for any other method in this document, after Init() is called, yet, there exist the possibility to add pins before calling Init(), see the remarks for SetMappingState for additional information about the possible danger. SetPinCount Add pins to reach the specified number of pins. HRESULT SetPinCount(             [IN] int         iCount,             [IN] int         iOutMode          ); Parameters use: iCount Number of pins to have iOutMode The pin mode Returned value: NOERROR Call succeeded RTPERR_MEMORY Could not allocate memory for the pin RTPERR_INVALIDARG Invalid mode RTPERR_INVALIDSTATE An internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPSESS Internal structure found is invalid Remarks: This function adds the pins needed to reach the specified number of pins, if the specified number is smaller than the current number of pins, no pins will be added nor deleted. The mode can be any of: RTPDMXMODE_MANUAL - Manual mapping. RTPDMXMODE_AUTO - Automatically map and unmap. RTPDMXMODE_AUTO_MANUAL - Automatically map, manual unmap. Adding pins should be done, as is the case for any other method in this document, after Init() is called, yet, there exist the possibility to add pins before calling Init(), see the remarks for SetMappingState for additional information about the possible danger. SetPinMode Modify the output pin s mode. HRESULT SetPinMode(             [IN] int         iPos,             [IN] IPin       *pIPin,             [IN] int         iOutMode          ); Parameters use: Position of pin whose output mode is to be changed, iPos has precedence over IPIn pIPin Pin whose output mode is to be changed, iPos has precedence over IPIn iOutMode The output mode Returned value: NOERROR Call succeeded RTPERR_POINTER NULL pointers passed when a non NULL was expected RTPERR_INVALIDARG Invalid mode or a pin in iPos position doesn t exist RTPERR_INVALIDSTATE Init not done yet or an internal pointer was found to be NULL when a non NULL was expected or the pin doesn t have its RTP counterpart (an output) RTPERR_INVALIDRTPSESS Internal structure found is invalid RTPERR_NOTFOUND IPin not found  Remarks: The mode can be any of: RTPDMXMODE_MANUAL - Manual mapping. RTPDMXMODE_AUTO - Automatically map and unmap. RTPDMXMODE_AUTO_MANUAL - Automatically map, manual unmap. The non-specified position is  1, the non-specified IPin is NULL. SetMappingState Sets the mapping state to mapped or unmapped. HRESULT SetMappingState(             [IN] int         iPos,             [IN] IPin       *pIPin,             [IN] DWORD       dwSSRC,             [IN] BOOL        bMapped          ); Parameters use: Position of pin to map/unmap, iPos has precedence over IPIn pIPin Pin to map/unmap, iPos has precedence over IPIn dwSSRC Participant s SSRC to map/unmap bMapped If zero, unmap, otherwise map Returned value: NOERROR Call succeeded RTPERR_POINTER NULL pointers passed when a non NULL was expected RTPERR_CRITSECT Failed to acquire a critical section RTPERR_INVALIDARG The iPos position doesn t exist RTPERR_INVALIDSTATE Init not done yet or an internal pointer was found to be NULL when a non NULL was expected or the pin doesn t have an RTP output (the RTP counterpart to a DShow pin) or the SSRC is not mapped when trying to unmap RTPERR_INVALIDRTPADDR Internal structure found is invalid RTPERR_NOTFOUND IPin not found or SSRC not found Remarks: When mapping, both, the pin and the SSRC must be free, i.e. unmapped.  When unmapping, you can specify only SSRC or one of position or pin, but is you specify both (i.e. SSRC and any of position or pin), they must match (i.e. the SSRC must already been mapped to that pin). The non-specified position is  1, the non-specified IPin is NULL. There is a scenario that may lead to inconsistency between the real mapping and the mapping view in DShow.  This may happen if pins are added before Init() is called, and one or more of the RTP outputs (the DShow pin s counterpart in RTP stack) fail to be created, so the number of DShow pins is bigger that the number of RTP outputs. When the above happens, mapping by pin may fail with error RTPERR_INVALIDSTATE if the pin hasn t an RTP output. Mapping by position will select that position in the RTP outputs, and this position may not be the same its DShow pin has. FindPin Finds the pin this participant is mapped to. HRESULT FindPin(             [IN] DWORD       dwSSRC,             [OUT] int       *piPos,             [OUT] IPin     **ppIPin          ); Parameters use: dwSSRC Participant s SSRC to find piPos Position of pin the SSRC is mapped to ppIPin Pin the SSRC is mapped to Returned value: NOERROR Call succeeded RTPERR_POINTER NULL pointers passed when at least one non NULL was expected RTPERR_INVALIDARG The iPos position doesn t exist RTPERR_INVALIDSTATE Init not done yet or an internal pointer was found to be NULL when a non NULL was expected RTPERR_INVALIDRTPADDR Internal structure found is invalid RTPERR_NOTFOUND SSRC not found Remarks: You can specify only one of piPin or ppIPin. If the SSRC is not mapped, the iPos value is set to  1 and the IPin pointer is set to NULL. FindSSRC Finds the SSRC mapped to a pin. HRESULT FindSSRC(             [IN] int         iPos,             [IN] IPin       *pIPin,             [OUT] DWORD     *pdwSSRC          ); Parameters use: Pin position, has precedence over Pin pIPin pdwSSRC SSRC from participant mapped to the specified pin Returned value: NOERROR Call succeeded RTPERR_POINTER NULL pointers passed when a non NULL was expected RTPERR_INVALIDARG The iPos position doesn t exist RTPERR_INVALIDSTATE Init not done yet or an internal pointer was found to be NULL when a non NULL was expected or the DShow pin doesn t have an RTP output RTPERR_INVALIDRTPADDR Internal structure found is invalid RTPERR_NOTFOUND SSRC not found Remarks: If the pin is not mapped, the SSRC is set to 0. The non-specified position is  1, the non-specified IPin is NULL. Interface IRtpMediaControl SetFormatMapping Set the mapping between a payload type, a media type and a sampling frequency. HRESULT SetFormatMapping(          [IN] DWORD         dwRTPPayLoadType,              [IN] DWORD         dwFrequency,             [IN] AM_MEDIA_TYPE *pMediaType          ); Parameters use: dwRTPPayLoadType RTP payload type dwFrequency Sampling frequency pMediaType Media type Returned value: NOERROR Call succeeded RTPERR_POINTER NULL pointers passed when a non NULL was expected RTPERR_MEMORY Failed to allocate memory to store the media type RTPERR_RESOURCES There are no more available entries to add a new mapping Remarks: The maximum number of entries is specified by MAX_MEDIATYPE_MAPPINGS  (10). FlushFormatMappings Empty the format mappings table. HRESULT FlushFormatMappings (          ); Returned value: NOERROR Call succeeded Remarks: This function always succeeds and leaves the format mappings table empty. Interface IRtpDtmf SetDtmfParameters Configures the DTMF parameters. HRESULT SetDtmfParameters(          [IN] DWORD         dwPT_Dtmf          ); Parameters use: dwPT_Dtmf DTMF payload type Returned value: NOERROR Call succeeded RTPERR_INVALIDARG The payload type is invalid RTPERR_INVALIDSTATE Init not done yet Remarks: It is suggested that a payload type from the range of dynamic payload types be used, as of RFC1890, that is the range 96 to 127. SendDtmfEvent Sends DTMF event. HRESULT SendDtmfEvent(          [IN] DWORD         dwEvent,              [IN] DWORD         dwVolume,             [IN] DWORD         dwDuration,             [IN] BOOL          bEnd          ); Parameters use: dwEvent DTMF event to send dwVolume Event s volume (0 to  63 dBm0 without the sign) dwDuration Event s duration in milliseconds Indicates if this is the end of the evnt Returned value: NOERROR Call succeeded RTPERR_INVALIDARG Any of the input parameters is invalid RTPERR_INVALIDSTATE Init not done yet or the DTMF payload type hasn t been specified yet RTPERR_ENCRYPT The packet encryption failed RTPERR_WS2SEND The packet was not successfully sent Remarks: Directs an RTP render filter to send a packet formatted according to rfc2833 containing the specified event, specified volume level, duration in milliseconds, and the END flag. The RTP render filter will convert the duration in milliseconds to the timestamp units based on its current sampling frequency, or 8000 Hz if none has been specified. The events are defined in RFC2823, and include: Event encoding  (decimal) 12--15 Flash Interface IRtpRedundancy SetRedParameters Configures the redundancy parameters for receiver or sender. HRESULT SetRedParameters(             [IN] DWORD         dwPT_Red,             [IN] DWORD         dwInitialRedDistance,             [IN] DWORD         dwMaxRedDistance          ); Parameters use: dwPT_Red Payload type for redundant packets dwInitialRedDistance Initial redundancy distance dwMaxRedDistance Maximum redundancy distance Returned value: NOERROR Call succeeded RTPERR_NOTINIT Init hasn t been called yet RTPERR_INVALIDARG The payload type is invalid RTPERR_INVALIDSTATE Redundancy only valid for AUDIO class of stream Remarks: Parameters dwInitialRedDistance and dwMaxRedDistance are meaningful only for a sender. All the parameters can receive a  1 and defaults will be assigned to them, yet, in order to enable redundancy, this method must be called, even with  1 in all the parameters. The RFC2198 describes the RTP header format for redundant audio. Events Events are fired only if they are enabled, and each event can be enabled individually, no events is the default behavior. Participants expiration Whenever a participant stops sending RTP and RTCP packets or the receiver is just not receiving them, the event RTPPARINFO_EVENT_STALL will be issued after 5 times the RTCP interval report. Then, if no packets are yet received from the same participant after 10 times the current RTCP interval report, then the event RTPPARINFO_EVENT_DEL will be posted. Note that the timers are based on the current RTCP interval report. That interval scales with the amount of participants and is always random around a reference value. In unicast, that interval goes around 4.1 instead of the expected 5 due to an RTP compensation (see latest RTP draft), that makes roughly a 20.5 and 41 seconds interval since last RTP or RTCP packet was received for the events STALL and DEL to be fired respectively.  Error codes <To be done> References RFC 1889 - RTP: A Transport Protocol for Real-Time Applications H. Schulzrinne, S. Casner, R. Frederick, V. Jacobson RFC 1890 - RTP Profile for Audio and Video Conferences with Minimal Control H. Schulzrinne RFC 2833 - RTP Payload for DTMF Digits, Telephony Tones and Telephony Signals H. Schulzrinne, S. Petrack RFC2198 - RTP Payload for Redundant Audio Data C. Perkins, I. Kouvelas, O. Hodson, V. Hardman, M. Handley, J.C. Bolot, A. Vega-Garcia, S. Fosse-Parisis Open issues None.  The current implementation may or may not provide all of the requirements listed here. See the actual methods implemented for detailed information.  Note that one or more  modes  are associated with the cryptographic algorithms, e.g. DES in CBC or ECB mode, the mode here is an RTP specific and independent mode, and they should not be confused.  The pass phrase is currently taken without any parsing, but note that RFC1890 states that the pass phrase MAY be preceded by a specification of the encryption algorithm (e.g.: DES-CBC/pass-phrase) which currently is not supported.  PAGE   Revision 0.207            WDM Connection and Streaming Architecture  DATE  5/16/2001            Microsoft Corporation Company Confidential            TIME  12:08 PM Revision 0.7.  REVNUM  \* Arabic  \* MERGEFORMAT   TITLE  \* MERGEFORMAT  Microsoft RTP (Real-time Transport Protocol)  SAVEDATE \@ "M/d/yyyy" \* MERGEFORMAT  5/16/2001 Draft - Microsoft Corporation Company Confidential  SAVEDATE \@ "h:mm am/pm" \* MERGEFORMAT  12:03 PM Revision 0.7.  REVNUM  \* Arabic  \* MERGEFORMAT   TITLE  \* MERGEFORMAT  Microsoft RTP (Real-time Transport Protocol) Microsoft Corporation Company Confidential  SAVEDATE \@ "M/d/yyyy" \* MERGEFORMAT  5/16/2001 Draft - Microsoft Corporation Company Confidential  SAVEDATE \@ "h:mm am/pm" \* MERGEFORMAT  12:03 PM PAGE \# "'Page: '#' Page: 3 The support from the QOS packet scheduler could be used if available and otherwise use a sneding thread to work as a packet scheduler on a per link basis. PAGE \# "'Page: '#' Page: 4 At the very least, this is required to synchronize streams. PAGE \# "'Page: '#' Page: 4 The encoder/decoder will have to provide the mechanism to create a receiving  and/or sending flow spec based on its current settings, that can be as simple as copying some fixed values, e.g. G.711 will not have different flow spec depending on current settings because is a fix rate codec, though, some parameters like max bucket size could be fine tuned. PAGE \# "'Page: '#' Page: 4 Probably wise to put all statistics in shared memory and build  a monitoring tool. PAGE \# "'Page: '#' Page: 4 Being able to keep track of memory usage may be also a useful feature. Transform filter  Render filter Source  filter hdVQJQJQ gd?<]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\doc\tapi_audio_filters.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Corporation Microsoft TAPI Audio Filters Title _PID_GUIDMicrosoft TAPI Audio Filters Mu Han Normal Mu Han Microsoft Word 8.0S5&s|5bjbjt+t+  TITLE  \* MERGEFORMAT  Microsoft TAPI  Audio Filters  SUBJECT  \* MERGEFORMAT  Design Specification   Draft Authors: Mu Han, Philippe Ferriere, Andres Vega-Garcia, Michael VanBuskirk Revision 1.0.1,   SAVEDATE \@ "d MMMM, yyyy" \* MERGEFORMAT  7 May, 1999 This documentation is an early release of the final product documentation. It is meant to accompany software that is still in development. Some of the information in this documentation may be inaccurate or may not be an accurate representation of the functionality of the final retail product. Microsoft assumes no responsibility for any damages that might occur either directly or indirectly from these inaccuracies.  TOC \o "1-4"  Introduction  PAGEREF _Toc451251406 \h  Document organization  PAGEREF _Toc451251407 \h  Overview of all the audio components  PAGEREF _Toc451251408 \h  Outgoing Audio Stream  PAGEREF _Toc451251409 \h  3.1.1 The default case  PAGEREF _Toc451251410 \h  3.1.2 The Hardware accelerated encoding case  PAGEREF _Toc451251411 \h  3.1.3 The installable codec case  PAGEREF _Toc451251412 \h  3.1.4 The File Terminal and Media Streaming Terminal case  PAGEREF _Toc451251413 \h  Incoming Audio stream  PAGEREF _Toc451251414 \h  3.2.1 The default case  PAGEREF _Toc451251415 \h  3.2.2 The File Terminal and Media Streaming Terminal case  PAGEREF _Toc451251416 \h  TAPI Audio Encoding Handler  PAGEREF _Toc451251417 \h  The IAMStreamConfig interface  PAGEREF _Toc451251418 \h  4.1.1 SetFormat method  PAGEREF _Toc451251419 \h  4.1.2 GetFormat method  PAGEREF _Toc451251420 \h  4.1.3 GetNumberOfCapabilities method  PAGEREF _Toc451251421 \h  4.1.4 GetStreamCaps method  PAGEREF _Toc451251422 \h  The IAMBufferNegotiation interface  PAGEREF _Toc451251423 \h  The IEncodingControl interface  PAGEREF _Toc451251424 \h  4.3.1 QueryCaptureFormat method  PAGEREF _Toc451251425 \h  4.3.2 FreeCaptureFormat method  PAGEREF _Toc451251426 \h  4.3.3 QueryBufferSizes method  PAGEREF _Toc451251427 \h  4.3.4 EnableAGC method  PAGEREF _Toc451251428 \h  4.3.5 Reset method  PAGEREF _Toc451251429 \h  4.3.6 Transform method  PAGEREF _Toc451251430 \h  The IH245AudioCapability interface  PAGEREF _Toc451251431 \h  4.4.1 GetH245VersionID method  PAGEREF _Toc451251432 \h  4.4.2 GetNumberOfCapabilities method  PAGEREF _Toc451251433 \h  4.4.3 GetStreamCaps method  PAGEREF _Toc451251434 \h  4.4.4 IntersectFormats method  PAGEREF _Toc451251435 \h  4.4.5 ReleaseNegotiatedCapability method  PAGEREF _Toc451251436 \h  4.4.6 SetIDBase method  PAGEREF _Toc451251437 \h  4.4.7 FindIDByRange method  PAGEREF _Toc451251438 \h  4.4.8 FindIDByMode method  PAGEREF _Toc451251439 \h  4.4.9 SetAcknowledgedCapabilityLimits method  PAGEREF _Toc451251440 \h  The IBitRateControl interface  PAGEREF _Toc451251441 \h  4.5.1 SetMaxBitrate method  PAGEREF _Toc451251442 \h  4.5.2 GetMaxBitrate method  PAGEREF _Toc451251443 \h  4.5.3 GetMaxBitrateRange method  PAGEREF _Toc451251444 \h  The ICPUControl interface  PAGEREF _Toc451251445 \h  4.6.1 SetMaxProcessingTime method  PAGEREF _Toc451251446 \h  4.6.2 GetMaxProcessingTime method  PAGEREF _Toc451251447 \h  4.6.3 SetMaxCPULoad method  PAGEREF _Toc451251448 \h  4.6.4 GetMaxCPULoad method  PAGEREF _Toc451251449 \h  The ISilenceControl interface  PAGEREF _Toc451251450 \h  4.7.1 SetSilenceDetection method  PAGEREF _Toc451251451 \h  4.7.2 GetSilenceDetection method  PAGEREF _Toc451251452 \h  4.7.3 SetSilenceCompression method  PAGEREF _Toc451251453 \h  4.7.4 GetSilenceCompression method  PAGEREF _Toc451251454 \h  4.7.5 GetAudioLevel method  PAGEREF _Toc451251455 \h  4.7.6 GetAudioLevelRange method  PAGEREF _Toc451251456 \h  4.7.7 SetSilenceLevel method  PAGEREF _Toc451251457 \h  4.7.8 GetSilenceLevel method  PAGEREF _Toc451251458 \h  4.7.9 GetSilenceLevelRange method  PAGEREF _Toc451251459 \h  Noise reduction  PAGEREF _Toc451251460 \h  TAPI Audio Capture Filter (WAV, DSound)  PAGEREF _Toc451251461 \h  Threading model  PAGEREF _Toc451251462 \h  Buffer management  PAGEREF _Toc451251463 \h  Sample Manipulation  PAGEREF _Toc451251464 \h  5.3.1 Timestamps  PAGEREF _Toc451251465 \h  5.3.2 In-band Format changes  PAGEREF _Toc451251466 \h  5.3.3 Multiple Media Samples in one packet  PAGEREF _Toc451251467 \h  IAMStreamConfig interface  PAGEREF _Toc451251468 \h  IAudioInputMix interface  PAGEREF _Toc451251469 \h  ITAudioDeviceControl interface  PAGEREF _Toc451251470 \h  IAudioCaptureModeControl interface  PAGEREF _Toc451251471 \h  5.7.1 StartCapture method  PAGEREF _Toc451251472 \h  5.7.2 StopCapture method  PAGEREF _Toc451251473 \h  5.7.3 ReleaseCapture method  PAGEREF _Toc451251474 \h  TAPI Audio Capture using hardware acceleration  PAGEREF _Toc451251475 \h  TAPI Audio Encoding Filter  PAGEREF _Toc451251476 \h  Buffer management  PAGEREF _Toc451251477 \h  TAPI Audio Render Filter (DSound)  PAGEREF _Toc451251478 \h  Mixing  PAGEREF _Toc451251479 \h  Buffer management  PAGEREF _Toc451251480 \h  Timing control  PAGEREF _Toc451251481 \h  IAudioSettings  PAGEREF _Toc451251482 \h  IAudioRenderModeControl interface  PAGEREF _Toc451251483 \h  7.5.1 SetCaptureModeControl method  PAGEREF _Toc451251484 \h  7.5.2 StopRender method  PAGEREF _Toc451251485 \h  Stereo playout  PAGEREF _Toc451251486 \h  TAPI Audio Render Filter (WAV)  PAGEREF _Toc451251487 \h  Mixing  PAGEREF _Toc451251488 \h  Buffer management  PAGEREF _Toc451251489 \h  IAudioSettings  PAGEREF _Toc451251490 \h  TAPI Audio Mixing Filter  PAGEREF _Toc451251491 \h  Mixing  PAGEREF _Toc451251492 \h  Buffer management  PAGEREF _Toc451251493 \h  IAudioSettings  PAGEREF _Toc451251494 \h  TAPI Audio Decoding Filter  PAGEREF _Toc451251495 \h  Buffer management  PAGEREF _Toc451251496 \h  Sample Manipulation  PAGEREF _Toc451251497 \h  10.2.1 Timestamps  PAGEREF _Toc451251498 \h  10.2.2 Format changes  PAGEREF _Toc451251499 \h  IAMStreamConfig interface  PAGEREF _Toc451251500 \h  The IH245AudioCapability interface  PAGEREF _Toc451251501 \h  The IBitRateControl interface  PAGEREF _Toc451251502 \h  The ICPUControl interface  PAGEREF _Toc451251503 \h  Device Enumeration  PAGEREF _Toc451251504 \h  The IDeviceEnumerator interface  PAGEREF _Toc451251505 \h  11.1.1 GetTerminals method  PAGEREF _Toc451251506 \h  The IAudioDeviceConfig interface  PAGEREF _Toc451251507 \h  11.2.1 SetDeviceID method  PAGEREF _Toc451251508 \h  References  PAGEREF _Toc451251509 \h  Introduction This document describes the design of the audio related filters for TAPI3.1. It will fulfill the following feature requirements: Low latency Latency could be the single biggest reason why people refuse to use our product. The best latency we have achieved so far is 100ms between two machines on LAN. This design will try to keep low latency as the first priority while adding new features. This document carefully specified the timing control in each filter. And, all the advanced features that incur latency can be disabled by the user to cut latency. Automatic Gain Control The differences in volume caused by the differences in microphone sensitivity and gain setting is a very annoying problem when using PCs to make voice calls, especially in multi-party calls. Therefore, smart and accurate automatic gain control is a must-have feature to improve the user experience. The new capture filter added build-in AGC support. (Basic encoders are also built into the capture filter). Supporting non-hardware source and sink For IVR applications, the ability to play a message and record a message is very important. The design of the audio filters supports this feature by having a separate encoding filter to handle date from non-hardware sources and a separate mixing filter to render date to no-hardware sinks. Bandwidth control This feature will be supported to control the maximum bandwidth generated by the audio stream. The bandwidth control can be achieved by either controlling the bitrate of a variable bitrate CODEC or changing the packet size to reduce the total bandwidth consumption. Since most audio packets are very small, the latter method can be more effective. CPU control This feature will be supported to control the maximum CPU used by the audio stream. All advanced features will be restricted within the CPU limits set by the user. Acoustic Echo cancellation Most people hate to use headphones when making phone calls. The audio stream will support the system AEC if it is available. If AEC is not available, the audio stream supports half-duplex emulation to work around the problem.  Noise Reduction This is an advanced feature. It requires more CPU and might introduce more latency. It should be combined with the AEC or the encoder to save CPU cycle. The final design of this feature is still TBD. Hardware accelerated encoding This is an advanced feature that only applies to certain hardware. The audio stream needs to be aware of the fact that the hardware does encoding and take actions accordingly. Proxy to kernel streaming filter will be used to achieve this. Document organization Section   REF _Ref444596872 \r \h   of this document is the overview of the audio streams. Section   REF _Ref450887628 \r \h   of this document describes the design of an Encoding Handler that will be used in the capture filter and the standalone encoding filter. Section   REF _Ref450923509 \r \h   of this document describes the design of the TAPI Audio Capture filter. Section   REF _Ref450887976 \r \h   of this document describes the design of the TAPI Audio Encoding filter. Section   REF _Ref450887993 \r \h   of this document describes the design of the TAPI Render filter using DSound. Section   REF _Ref450888009 \r \h   of this document describes the design of the TAPI Render filter using WAV. Section   REF _Ref450888030 \r \h   of this document describes the design of the TAPI Mixing filter. Section   REF _Ref450888045 \r \h   of this document describes the design of the TAPI Decoding filter. Overview of all the audio components In tapi3 model, there are two kinds of audio streams, incoming audio streams and outgoing audio streams. They are the controlling objects for streaming audio data to or from other machines. The stream object interacts with the call control objects and the quality control object to control the streaming.  Internally, each stream object uses several Dshow filters to process the data. The relationship among these objects are illustrated in the following diagram: All the stream objects support the ITStream, ITSubStream, ITQualityControl, and ITFormatControl interfaces. Audio streams also support two additional interfaces: the ITAudioDeviceControl interface and the ITAudioSettings interface. All these interfaces are used by the application. Please refer to the SDK document for information about ITStream and ITSubStream. ITQualityControl is used to set limits on the CPU usage and bandwidth usage on the stream object. ITFormatControl is used to control the format used in transmitting the audio data. ITAudioDeviceControl is used to choose what kinds of drivers should be used; the choices are WAV, Dsound, and WDM. The ITAudioSettings interface allows the app to query and configure the property of the audio data.  The stream object also exposes the ITStreamControl and the IH245AudioCapability interface to the channel object. The channel object uses the ITStreamControl interface to control the stream and uses the IH245AudioCapability interface to query the capability of the stream. At the same time, the stream object uses the IChannelControl interface to delegate channel related calls to the channel object. The details of these interfaces are in H323MSP.doc. Internally the stream object uses a couple of filters to handle the audio data. A filter graph object maintains the filters. The steam object uses the quality controller to calculate the settings on the filters based on the limits set by the app and the current bandwidth and CPU usage. Outgoing Audio Stream The outgoing audio stream handles sending audio data from the local machine to the network. There are several cases of graph building. In the default case, there are two filters used inside the filter graph: the TAPI MSP audio capture filter and the TAPI MSP RTP render filter. The TAPI MSP audio capture filter handles silence suppression, AGC and generates G.711, G.723.1, and other formats that ACM handles. This case is used most of the time with two exceptions: hardware acceleration and installable CODEC. In the hardware acceleration case, the hardware implements all the functionality and the TAPI MSP audio capture filter serves only as a proxy. In the installable CODEC case, the TAPI MSP audio capture filter handles only AGC and leaves the encoding to the installed encoder. In addition, if the application selects non-hardware related terminals like the file terminal or the Media Streaming Terminal, the stream has to use a standalone encoder to deal with encoding and possibly voice detection and AGC. The details of the four cases are explained in the following sections. The default case The following filter graph is used inside the outgoing audio stream if the following conditions are met: There is no installable CODEC to handle the selected format. The hardware cannot generate the format directly.  The TAPI MSP audio capture filter can support the format. This filter graph contains two filters, the TAPI MSP Audio Capture filter and the TAPI MSP RTP Render filter. The capture filter talks to the driver to get the audio data, encode them, and give them to the RTP render filter to send them to the network. The capture filter implements all the interfaces that the Stream needs to manipulate the audio device and data. IAMAudioInputMixer is used to configure different sound sources such as mic, linein, CD, etc. ITAudioDeviceControl is used to select which driver mode to use, WAV, DSound, or WDM. IAudioCaptureModeControl is used to change the capture mode during half-duplex audio calls. IH245AudioCapability is used to expose the capability of the capture device. IBitRateControl, ICPUControl, and INetworkStats are used to dynamically adjust the encoding based on the status of system resources. ISilenceControl is used to control the silence suppression algorithm. The Hardware accelerated encoding case If the audio capture device supports the encoding acceleration as defined in  Audio Conferencing Acceleration with WDM G.Series Audio Encoding, by Philippe Ferriere,  the TAPI MSP capture filter will simply delegate all the functionality to the hardware. This graph also contains two filters, the TAPI MSP Audio Capture filter and the TAPI MSP RTP render filter. The TAPI MSP Audio Capture filter implements all the interfaces by delegating all the calls to the kernel mode driver. The ITAudioDeviceControl interface is not supported in this case because the only way to access this kind of device is through the WDM ksproxy. We can either use the ksproxy filter and implement interface handlers to achieve this functionality or integrate part of the ksproxy code into the TAPI MSP audio capture filter to talk to the device directly. The final decision is still TBD. The installable codec case In the case that a third-part encoder is installed to handle the selected format, the installed codec has higher priority than the default codec. The details of how to register an Encoder and its capability is still TBD. Assuming that the stream object can find the encoder and create it, the TAPI MSP audio capture filter will generate linear PCM samples to be consumed by the encoder. The filter graph is shown in the following diagram: This graph contains three filters, the TAPI MSP Audio Capture filter, the encoder filter and the TAPI MSP RTP Render filter. The capture filter talks to the driver to get the audio data and give them to the encoder filter in linear PCM format. The encoder filter encodes the data and gives them to the RTP render filter to send them to the network. The encoder filter should implement the IH245AudioCapability, IBitRateControl, ICPUControl, INetworkStats, and ISilenceControl interfaces. The IAMAudioInputMixer, ITAudioDeviceControl, and IAudioCaptureModeControl interfaces on the capture filter are still used by the stream.  The File Terminal and Media Streaming Terminal case In the case that non-hardware related terminals are selected, the filter graph will look like the following: The filter graph has a source filter that generates linear PCM data. The encoder filter that follows the source filter needs to implement all the interfaces needed by the stream. It does silence suppression and encoding. AGC is not supported in this case since the data are most likely from a pre-recorded file or a text to speech engine where the gains are already controlled. Many server apps might also disable the silence suppression as well since they only send data when there is a message. The TAPI Audio Encoder filter might be replaced by plug-in encoder in this case, all the interfaces stay the same. Incoming Audio stream The outgoing audio stream handles rendering audio data received from the network. The filter graphs used in the incoming audio stream is more complicated than the outgoing audio stream because there are multiple decoding paths allocated for decoding audio data from multiple sources at the same time. The audio data also need to be mixed before being played out. The number of decoding paths is determined by the max number of sources that the user wants to hear simultaneously. The RTP source filter handles dynamic reusing of the audio decoders based on which sources are active.  The default case In this case, DSound is selected as the render device. The render filter supports multiple input pins, each of which uses a secondary buffer and DSound mixes the audio data from different sources.  The application could also specify that WAV API should be used to render the sound. This might happen if the DSound driver for the device is broken, or the device doesn t have a DSound driver and the app doesn t want to use emulated DSound on top of WAV. The render filter will have to support mixing internally. The encoded audio samples are passed from the RTP source filter to the decoding filter. The decoded data are then passed to the audio render filter to render them out. The input pin of the audio decoding filter implements IH245AudioCapability interface for configuring the receive capability of the audio stream; ICPUControl for controlling CPU usage; and IBitRateControl for configuring bitrate. The audio render filter implements IAudioSettings to configure the play out settings for each sound source.   The File Terminal and Media Streaming Terminal case If the application selected a File Terminal or Media Streaming Terminal in place of the audio render terminal, the graph might have to put a mixer before the terminal s filter. If there is only one participant for the lifetime of the call, the mixer will not be used. Otherwise, the mixer will always be inserted. TAPI Audio Encoding Handler After analyzing the four cases of the outgoing audio stream, we find out that, except for the hardware accelerated encoding case, all cases need some degrees of post-processing on the PCM samples. The TAPI Audio Encoding Handler is abstracted out to handle the common code path.  The Encoding Handler implements the following functionality: Voice detection Automatic gain control  Encoding  The capture filter and the encoder filter create the Encoding handler and use the IEncodingControl to control it and process data. The encoding handler supports several TAPI-specific interfaces and can be aggregated by the output pin object in both the capture filter and the encoder filter.  The voice detection module first classified the input data as sound or silence. Then the AGC module makes gain control suggestion base on the statistics of the samples. Finally, the encoding module is called to encode the data if needed. The IAMStreamConfig interface  This is one of the DShow interfaces used to configure the formats. The TAPI Encoding Handler supports it to make the life of the filter easier. The pin object can delegate the calls on its IAMStreamConfig interface to the IAMStreamConfig interface on the encoding handler. However, the pin object might need to do more on SetFormat() if the allocator properties are affected by the format change.  SetFormat Used to set the format for the encoded data.  GetFormat Get the encoding format currently in use. GetNumberOfCapabilities Get the number of capabilites of the Encoding Handler. GetStreamCaps Get one specific capability.  This function returns a pair of an AM_MEDIA_TYPE structure and an AUDIO_STREAM_CONFIG_CAPS structure.  SetFormat method The SetFormat() method can be called both before the encoding handler starts and while it is streaming. The encoding handler will start generating the new format with the next TransForm() call. The user of this encoding handler is responsible for ensuring that the new source buffer size fulfills the requirement of the format. The proper buffer size can be obtained by calling QueryBufferSizes() after the new format is set. HRESULT SetFormat ( [in] AM_MEDIA_TYPE *pmt where The new encoding format.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Wrong format No error GetFormat method The GetFormat method is used to retrieve the current encoding format. The format is allocated by using CoTaskMemAlloc().  HRESULT GetFormat ( [in] AM_MEDIA_TYPE **ppmt where A pointer to the pointer to the format returned.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_OUTOFMEM No memory for the format No error  GetNumberOfCapabilities method The GetNumberOfCapabilities method is used to retrieve the number of capabilities and the size of the structure.  HRESULT GetNumberOfCapabilities( [out] int *piCount, [out] int *piSize where piCount A pointer to the number of capabilities. piSize A pointer to the size of the structure. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument No error  GetStreamCaps method The GetStreamCaps method is used to retrieve a specific capability entry. It returns a (media type, capabilities) pair. The AUDIO_STREAM_CONFIG_CAPS data structure is used in describing the capability. TODO: The default AUDIO_STREAM_CONFIG_CAPS structure doesn t have a range for bit rate. It can t describe variable bitrate CODECs when the BitPerSample is less than 1. We need to extend the structure and use a different GUID. typedef struct _TAPI_AUDIO_STREAM_CONFIG_CAPS { GUID       guid;    // will be MEDIATYPE_TAPI_Audio ULONG      MinimumChannels; ULONG      MaximumChannels; ULONG      ChannelsGranularity; ULONG      MinimumBitsPerSample; ULONG      MaximumBitsPerSample; ULONG      BitsPerSampleGranularity; ULONG      MinimumSampleFrequency; ULONG      MaximumSampleFrequency; ULONG      SampleFrequencyGranularity; ULONG      MinimumAvgBytesPerSec; ULONG      MaximumAvgBytesPerSec; ULONG      AvgBytesPerSecGranularity; } TAPI_AUDIO_STREAM_CONFIG_CAPS;  HRESULT GetStreamCaps( [in]  int iIndex, [out] AM_MEDIA_TYPE **ppmt, [out] BYTE *pSCC); where iIndex The index of the capability. It should be from 0 to the number of capabilities  A pointer to pointer to the media type structure. The memory used by this structure is allocated by calling CoTaskMemAlloc(). A pointer to a buffer that stores the returned capability structure. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument S_FALSE Index too big. (according to axextend.idl) No error The IAMBufferNegotiation interface  This interface is defined by DShow to configure the allocator property. This interface is only useful when the downstream filter has specific allocator requirement. For example, if the down stream filter handles encoding, it will ask the capture filter to generate PCM samples with specific size.  SuggestAllocatorProperties Used to set the properties of the allocator. This function fails if the current format is not PCM L16. Only the cbBuffer field will be processed in the ALLOCATOR_PROPERTIES structure. GetAllocatorProperties Used to get the properties of the allocator. The IEncodingControl interface  This is the main control interface used to configure the encoding handler and transform data. It controls the enabling of functionality and setting parameters. QueryCaptureFormat Used to get the WAVEFORMATEX data structure to be set on the capture device. FreeCaptureFormat Free the format in case the format was dynamically allocated. QueryBufferSizes Used to get the buffer size required for capture and encoding based on the current format. EnableAGC Used to enable or disable the AGC algorithm. Reset Used to notify the encoder handler the start of the data stream. TransForm Used to encode a buffer filled with PCM sample into the desired format. QueryCaptureFormat method The QueryCaptureFormat is used to find out the format to be set on the capture device. This method is needed because different encoding formats have different requirements on the capture device. The encoder currently uses only L16 PCM as the input format. However, the sample rate can be 8KHz or 16KHz. In the future, the Encoding Handler might be extended to handle more complicated encoding formats. HRESULT QueryCaptureFormat ( [out] DWORD *         pdwSize, [out] BYTE **        ppbFormat where pdwSize The size of the WAVEFORMATEX data structure returned.   ppbFormat The pointer to a pointer that points to a WAVEFORMATEX structure.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument No error FreeCaptureFormat method The FreeCaptureFormat is used to free the capture format returned by QueryCaptureFormat. If it is not dynamically allocated, the encoding handler will just return S_OK. HRESULT FreeCaptureFormat ( [in] BYTE * pbFormat where pbFormat The pointer that points to a WAVEFORMATEX data structure returned by QueryCaptureFormat(). This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Bad pointer No error QueryBufferSizes method This method is used to find out the size of the buffers required for the source and destination data. HRESULT QueryBufferSizes( [out] DWORD * pdwSourceBufferSize,  [out] DWORD * pdwNumSourceBuffers,  [out] DWORD * pdwDestinationBufferSize where pdwSourceBufferSize Pointer to the size of the source buffer.  The capture device will be configured to fill buffers of this size pdwNumSourceBuffers Pointer to the number of source buffers needed.  pdwDestinationBufferSize Pointer to the size of the destination buffer.  This will be the size of the buffers allocated for the samples passed to down stream filters. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument No error EnableAGC method This method is used to enable or disable the AGC algorithm in the encoding handler.  HRESULT EnableAGC( [in] BOOL fEnable where fEnable Setting it to TRUE enable AGC, to FALSE disables AGC. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure No error Reset method This method is used to notify the encoding handler that it should reset its state machine for its algorithms. This method will be called when the filter that contains the handler starts. HRESULT Reset(); This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure No error Transform method This method is used to transform data from the captured format to the format required. This function will also return the suggestion for gain-control if AGC is enabled. If the output format is the same as the input format, the data is copied from the source buffer to the destination buffer. This is needed because we don t want to lock the driver s buffer when we pass the samples to the downstream filters. The detail of this is explained later in the audio capture filter. HRESULT Transfrom( [in] BYTE * pSourceBuffer, [in] DWORD dwSourceDataSize, [in] BYTE * pDestBuffer, [in, out] DWORD * pdwDestBufferSize, [out] LONG * plGainAdjustment,         [out] BOOL * pfDataDiscontinuity where pSourceBuffer Pointer to the source buffer that contains data to be encoded. dwSourceDataSize The size of the source buffer, in bytes. pDestBuffer Pointer to the source buffer that contains data to be encoded. pdwDestBufferSize The size of the source buffer, in bytes. After the function returns, it contains the number bytes for the encoded data. plGainAdjustMent The suggested adjustment for the microphone gain, in percentage. 0 means no adjustment. A positive number means the percent of increase. A negative number, [-100, -1], means the percent of decrease. This number will always be 0 if the AGC is not enabled. pfDataDiscontinuity This flag will be set on the first and the last buffer of a talk spurt. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Bad pointer argument E_INVALIDARG Invalid argument S_SILENCE Silence data that should be discarded.  S_PENDING Send the sample together with the next sample. No error. The IH245AudioCapability interface  The IH245AudioCapability interface contains methods to enumerate, translate, and compare audio formats. The IH245AudioCapability interface contains the following methods: GetH245VersionID Used to retrieve a version identifier that indicates the version of H.245 that was in effect when the filter module was compiled. GetNumberOfCapabilities Used to retrieve the number of capabilities the filter supports.  GetStreamCaps Used to get a specific capability item. IntersectFormats Used to compare a local capability and remote capability and produce filter configuration structures and parameters that are compatible with both.  ReleaseNegotiatedCapability Used to release resources that were allocated by IntersectFormats. SetIDBase Used to control the range of sequential numbers that uniquely identify individual capabilities FindIDByRange Used to find a specific capability that corresponds to a formatted AM_MEDIA_TYPE structure.  FindIDByMode Used to find a specific capability that corresponds to a H245 mode element.  SetAcknowledgedCapabilityLimits Used to find a specific capability that corresponds to a H245 mode element.  GetH245VersionID method This method returns a DWORD value that identifies the platform version that the filter was designed for. The platform version is defined as TAPI_H245_VERSION_ID. The GetH245VersionID method is declared as: DWORD GetH245VersionID() GetNumberOfCapabilities method This method is used to retrieve the number of stream capability structure and format structure pairs. Capability structures are used to express the kinds of audio formats supported by the filter, beyond what is contained in the AM_MEDIA_TYPE structure. The GetNumberOfCapabilities method is declared as follows: HRESULT GetNumberOfCapabilities( [out]int *piCount,  [out]int *piSize where piCount  Pointer to the number of TAPI_AUDIO_STREAM_CONFIG_CAPS structures supported by the stream. piSize Pointer to the size of TAPI_AUDIO_STREAM_CONFIG_CAPS structure.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported No error GetStreamCaps method This method is used to obtain audio capabilities of a filter. The GetStreamCaps method is declared as follows: HRESULT GetStreamCaps( [in]int iIndex,  [out] H245Capability* ph245Capability,  [out]AM_MEDIA_TYPE **ppMediaType,  [out]BYTE *pStreamConfigCaps,  [out]BOOL *pfEnabled,  [out]DWORD*pdwUniqueID where iIndex  Index to the desired format structure and stream capability structure pair. Use the GetNumberOfCapabilities method to retrieve the total number of these pairs. Possible index values range from zero to one less than the total number of pairs. The preferred format has the smallest index value. ph245Capability  Address of a pointer to an H245Capability structure. ppMediaType  Address of a pointer to an AM_MEDIA_TYPE structure. pStreamConfigCaps Pointer to a TAPI_ AUDIO_STREAM_CONFIG_CAPS structure.  pfEnabled Pointer to a boolean indicating if the format is enabled or disabled for this call.  pdwUniqueID Pointer to a DWORD that uniquely identifies the format  The filter capability with the smallest iIndex value is the preferred format.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_POINTER Null pointer argument E_NOTIMPL Method is not supported No error IntersectFormats method This method is used to compare and intersect one local capability and one remote capability and to obtain filter configuration parameters. The IntersectFormats method is declared as follows: HRESULT IntersectFormats( [in]H245Capability *pLocalCapability, [in]H245Capability *pRemoteCapability,  [out]HANDLE *phIntersectionCookie, [out]H245Capability *pIntersectedCapability, [in]AM_MEDIA_TYPE *pAMMediaType where pLocalCapability  Specifies the H.245 local audio capability. If it is NULL, the filter is free to find the best match for the remote capability from all of its capabilities. pRemoteCapability  Specifies the H.245 remote audio capability. phIntersectionCookie  Identifies the dynamic instance of intersected capabilities. When a filter creates the intersection, it may allocate memory for the intersected capability parameters. The intersection cookie identifies this allocation.  pIntersectedCapability  Specifies the H.245 audio format, of the resolved common local and remote capability options and limits. pAMMediaType Pointer to an AM_MEDIA_TYPE structure that has been initialized to regard negotiated options.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_INCOMPATIBLECAPS Failure E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported No error ReleaseNegotiatedCapability method This method is used to release a filter's internal memory allocated by the IntersectFormats method. The ReleaseNegotiatedCapability method is declared as follows: HRESULT ReleaseNegotiatedCapability( [IN]HANDLE hIntersectionCookie where hIntersectionCookie  Identifies the dynamic instance of intersected capabilities. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error SetIDBase method This method is used to control the sequential numbering range used to uniquely identify a Filter s capabilities. The SetIDBase method is declared as follows: HRESULT SetIDBase( [in]DWORD dwIDBase where dwIDBase  A DWORD value that indicates the beginning number in the sequence . This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported No error FindIDByRange method This method is used to obtain the unique format ID of a capability that corresponds to an AM_MEDIA_TYPE. The FindIDByRange method is declared as follows: HRESULT FindIDByRange( [in]AM_MEDIA_TYPE *pAMMediaType, [out]DWORD *pdwID where pAMMediaType Pointer to an AM_MEDIA_TYPE structure that has been initialized to indicate a specific format. pdwID  Pointer to a DWORD output parameter that will contain the unique format ID. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported No error FindIDByMode method This method is used to obtain the unique format ID of a capability that corresponds to an H245 mode element. The FindIDByMode method is declared as follows: HRESULT FindIDByMode( [in] H245_MODE_ELEMENT *pModeElement, [out] DWORD *pdwUniqueID where pModeElement Pointer to an H245 mode element structure. pdwUniqueID  Pointer to a DWORD output parameter that will contain the unique format ID. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported No error SetAcknowledgedCapabilityLimits method This method is used to notify the encoder about the limits set by the OLC acknowledgement. The SetAcknowledgedCapabilityLimits method is declared as follows: HRESULT SetAcknowledgedCapabilityLimits (   [in] H245Capability* ph245Capability where ph245Capability Pointer to an H245 capability structure. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported No error The IBitRateControl interface  IBitRateControl interface sets the maximum bitrate on the encoder.  SetMaxBitrate  Sets the upper limit of the bitrate of encoded data.  GetMaxBitrate Get the current setting of bitrate upper limit. GetMaxBitrateRange Used to retrieve support, minimum, maximum, and default values for the upper limit in bandwidth transmission the compressed audio output pin may be setup for. SetMaxBitrate method This method is used to set the upper limit of the bitrate generated by the audio encoder. If the maximum bitrate is smaller than the capability of the encoder, this function will fail. HRESULT SetMaxBitrate( [in]DWORD dwMaxBitrate,  [in]DWORD dwLayerId where dwMaxBitrate The upper limit of bit rate. dwLayerId The LayerId for layered encoding. It is 0 for now. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported No error Currently only G723 has limited capability of changing bitrate. All the other formats we support are fixed bitrate formats. However, bandwidth consumption can be reduced if more data are put into one packet. Within the limit of maximum frames per packet, the encoder handler changes the data length per packet to fulfill the requirement of this method. GetMaxBitrate method This method is used to get the current setting of the bitrate limit. HRESULT GetMaxBitrate( [out]DWORD * pdwMaxBitrate,  [in]DWORD dwLayerId where pdwMaxBitrate A pointer to a dword to receive the current MaxBitrate setting. dwLayerId The LayerId for layered encoding. It is 0 for now. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported No error GetMaxBitrateRange method This method is used to retrieve support, minimum, maximum, and default values for the upper limit in bandwidth transmission the compressed audio output pin may be setup for. The GetMaxBitrateRange method is declared as follows: HRESULT GetMaxBitrateRange( [out]LPDWORD pdwMin,  [out]LPDWORD pdwMax,  [out]LPDWORD pdwSteppingDelta,  [out]LPDWORD pdwDefault,  [in]DWORD dwLayerId where pdwMin Used to retrieve the minimum limit in bandwidth transmission the compressed audio output pin maybe setup for, in bits/s.  pdwMax Used to retrieve the maximum limit in bandwidth transmission the compressed audio output pin maybe setup for, in bits/s.  pdwSteppingDelta Used to retrieve the stepping delta in bandwidth transmission the compressed audio output pin maybe setup for, in bits/s.  pdwDefault Used to retrieve the default limit in bandwidth transmission the compressed audio output pin is setup for, in bits/s.  dwLayerId Specifies the ID of the encoding layer the command applies to. For audio encoding filter, this field is always set to 0.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported No error The ICPUControl interface  The ICPUControl interface is used to control the bounds of encoding time and CPU consumption.  SetMaxProcessingTime  Used to specify the max processing delay.  GetMaxProcessingTime Used to get the current setting of maximum processing time. SetMaxCPULoad  Used to specify the max CPU load used by the encoder.  GetMaxCPULoad Used to get the current setting of the CPU load. SetMaxProcessingTime method This method is currently not supported by the Encoding Handler. HRESULT SetMaxProcessingTime(     [in] REFERENCE_TIME MaxProcessingTime     ) where MaxProcessingTime Specifies the maximum encoding time for samples in a second, in 100-nanosecond units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_NOTIMPL Method is not supported GetMaxProcessingTime method This method is currently not supported by the Encoding Handler. HRESULT GetMaxProcessingTime(     [out] REFERENCE_TIME *pMaxProcessingTime     ) where pMaxProcessingTime The returned maximum encoding time for samples in a second, in 100-nanosecond units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_NOTIMPL Method is not supported SetMaxCPULoad method This method is used to set the maximum CPU load used by the Encoding Handler. It is the MIPs of the encoding algorithm / MIPs of the machine. If this method is called by the app before the stream is negotiated, it will affect the capability enumeration. Only the formats that meet the requirements will be considered. If this method is called while the streams is running and the number is too small, it will fail.  HRESULT SetMaxCPULoad(     [in] DWORD dwMaxCPULoad     ) where dwMaxCPULoad Specifies the maximum encoding algorithm CPU load, in percentage units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported No error GetMaxCPULoad method This method is used to get the current setting of the maximum CPU load used by the Encoding Handler.  HRESULT GetMaxCPULoad(     [out] DWORD* pdwMaxCPULoad     ) where pdwMaxCPULoad Used to receive the current setting of maximum CPU load.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported No error The ISilenceControl interface  The ISilenceControl interface is used to control the silence suppression settings. Currently there are four silence detection algorithms available, our current algorithm which is based on running average of the PCM value of silent packets, Billyb s algorithm which is based on short time average of mulaw value, Whisper projects  algorithm that uses a histogram to determine threshold, and G723 encoder s VAD. The first two have been evaluated and compared. The last two will also be evaluated and the best will be used in the TAPI Encoding Handler. The audio level and the silence level are relative to the range given by the encoder. They could be the PCM value, or Root Mean Square, or whatever measurement the encoder is using. They are not guaranteed to use the same measurement either. However, this encoding handler will use the same range and unit for both. SetSilenceDetection Used to enable/disable silence detection. The default setting of silence detection is enabled. GetSilenceDetection Used to query if silence detection is disabled or enabled. SetSilenceCompression Used to enable/disable silence compression. If this enabled, the samples are always giving to the encoding module for process. Formats that do not have this feature return E_NOTIMPL. Silence detection ON Silence detection OFF SilenceComression ON Compress silence Send all SilenceComression OFF Discard silence Send all GetSilenceCompression Used to query if silence compression is supported, disabled or enabled. GetAudioLevel Used to retrieve the current audio level expressed as an average magnitude of the audio signal. GetAudioLevelRange Used to retrieve support, minimum, maximum, and default values for the audio level. SetSilenceLevel  Used to set the current silence level. If this function is never called by the application, the encoder works in auto mode. The silence threshold adapts to the environment. Once the app calls this method, auto mode is disabled and the silence level the app set will be used.  GetSilenceLevel Used to retrieve the silence level the audio capture pin is currently setup for. GetSilenceLevelRange Used to retrieve support, minimum, maximum, and default values for the silence level the audio capture pin is currently setup for. SetSilenceDetection method This method is used to enable or disable silence detection. The silence detection routine is activated and marks each packet as silence or sound. The encoding module can then choose to ignore the packet or do silence compression if silence compression is enabled. HRESULT SetSilenceDetection (     [in]BOOL fEnable     ) where fEnable Boolean used to enable or disable silence detection. If set to TRUE, silence detection is enabled. If set to FALSE, silence detection is disabled.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure No error GetSilenceDetection method This method is used to query whether silence detection is currently enabled or disabled.  HRESULT GetSilenceDetection (     [out]LPBOOL pfEnable     ) where pfEnable Pointer to a boolean used to query whether silence detection is enabled of disabled. If set to TRUE, silence detection is enabled. If set to FALSE, silence detection is disabled.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument No error SetSilenceCompression method This method is used to enable or disable silence compression. Among the formats we support, only G723.1 has this mode. This method only succeeds when G723.1 is the current format. HRESULT SetSilenceCompression (     [in]BOOL fEnable     ) where fEnable Boolean used to enable or disable silence compression. If it is set to TRUE, silence detection is enabled. If it is set to FALSE, silence detection is disabled.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_NOTIMPL Method is not supported No error GetSilenceCompression method This method is used to query whether silence compression is currently enabled or disabled.  HRESULT GetSilenceCompression (     [out]LPBOOL pfEnable     ) where pfEnable Pointer to a boolean used to query whether silence compression is enabled of disabled. If set to TRUE, silence detection is enabled. If set to FALSE, silence comression is disabled.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_NOTIMPL Method is not supported E_POINTER Null pointer argument No error GetAudioLevel method This method is used to get the current value of the audio signal level. The TAPI encoding object returns average PCM value of the latest 10ms of samples. TODO: Ideally, we should return the dB value of Root Mean Square of the latest 10ms of sample, since it is the closest to what human ears will perceive. HRESULT GetAudioLevel(     [out]LPLONG plAudioLevel     ) where plAudioLevel Pointer used to retrieve the current value of the audio signal level.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument No error GetAudioLevelRange method This method is used to retrieve support, minimum, maximum, and stepping values for the audio level the encoding handler may generate. HRESULT GetAudioLevelRange( [out]LPLONG plMin,  [out]LPLONG plMax,  [out]LPLONG plSteppingDelta where plMin Used to retrieve the minimum audio level the Encoding Handler may generate.  plMax Used to retrieve the maximum audio level the Encoding Handler may generate.  plSteppingDelta Used to retrieve the stepping delta values of the audio level the Encoding Handler may generate.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported No error SetSilenceLevel method This method is used to set the value of the silence audio level. If silence detection is enabled and this method is not called, the encoding handler will try to adapt the threshold to the background noise. If this function is called by the app, the adaptive algorithm is disabled. HRESULT SetSilenceLevel(     [in]LONG lSilenceLevel     ) where lSilenceLevel Used to specify the new value of the audio silence level setting.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported No error GetSilenceLevel method This method is used to get the current value of the audio silence level setting. HRESULT GetSilenceLevel(     [out]LPLONG plSilenceLevel     ) where plSilenceLevel Pointer used to retrieve the current value of the silence level setting.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported No error GetSilenceLevelRange method This method is used to retrieve support, minimum, maximum, and default values for the audio silence level setting the Encoding Handler is using.  HRESULT GetSilenceLevelRange( [out]LPLONG plMin,  [out]LPLONG plMax,  [out]LPLONG plSteppingDelta,  [out]LPLONG plDefault where plMin Used to retrieve the minimum silence level the Encoding Handler allows.  plMax Used to retrieve the maximum silence level the Encoding Handler allows.  plSteppingDelta Used to retrieve the stepping delta values of silence level.  plDefault Used to retrieve the default silence level.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported No error Noise reduction The noise reduction feature should be part of the encoding handler. The principle of noise reduction is quite sample. The filter calculates the profile of the background noise in silence period and subtracts the silence from the samples while the user is talking. However, this operation has to be done in the frequency domain, which means extra CPU usage and more latency. We are still working with people in the research group to get algorithms. Noise may not be a big problem for voice coders like G723.1.   TAPI Audio Capture Filter (WAV, DSound) This filter uses either WAV or Dsound interface to capture audio data. It uses the TAPI Audio Encoding Handler to process the data before it gives the data to the next filter. It also performs adjusting of the gain of the microphone based on the feedback of the Encoding Handler.  The Encoding Handler is aggregated by the filter s output pin so that the pin exposes the interfaces supported by the handler. Threading model  The capture filter has a worker thread listening for the completion of the capture sample and pushing the data down stream. In the WAV case, although there is a wavin callback function, it shouldn t be used to perform complicated calculations. Therefore, the samples completed will be put in a queue and the worker thread is signaled to encode them and push them to the downstream filters. In the Dsound case, a worker thread is required to listen on a handle that will be signaled when the capture buffer reaches a certain point. The worker thread is a real-time thread in order to reduce latency. Open issue: Whether this worker thread will be a shared thread or a private worker thread of the filter is TBD. Buffer management  The capture buffer has one block of memory used for capturing. The block consists of equally sized blocks base on the requirement of the format that is obtained by calling the GetBufferSizes() function on the TAPI Audio Encoding Handler.  In the case of WAV, waveinPrepareHeader() is called using each block before the capture filter starts to run. When a block is filled with data, the callback function will be called, which puts the block in a queue and signals the worker thread to process it. The worker thread gets a Media Sample from the output pin and calls TransForm() method of the encoding handler. After this function returns, the worker thread returns the block to the driver and sends the Media Sample that contains the encoded data downstream. In the case of DSound, a capture buffer is created using IDirectSoundCapture s CreateCaptureBuffer() method.  SetNotificationPositions() is called using the size of the blocks required by the encoding handler. When the capture reaches the position, an event is signaled and the worker thread wakes up to process the data. The worker thread locks the memory block, get a Media Sample from the output pin, and calls TransForm(). Then the worker thread unlocks the memory block and sends the Media Sample downstream. The encoding handler might suggest discarding the frame if it contains only silence. It might also suggest queuing up the frame and later send several frame in one call to ReceiveMultiple() on the input pin. If the Encoding Handler suggests any gain adjustment, the worker thread will also carry it out after the Media Sample is delivered.  The allocator on the output pin might be provided by the down stream filter. If the downstream filter doesn t provide one, the output pin creates its own. In either case, the size of the buffers fulfills the requirements given by the GetBufferSizes() call. Open issue: if we want to support the changing of audio encoding format on the fly, we might run into a situation that one format prefers 30ms samples while the other prefers 20ms. This particular example can be solved by capturing at 10ms and using total block size multiple of 60ms. The filter gets notifications every 10ms, but only every 20ms or 30ms will a Media Sample be delivered.  The benefit of this feature is the smooth transition of format. The drawbacks are the extra context switches and the complexity of the buffer management. If 99% of the time users don t change format that results in a change of capture buffer size, I suggest restarting the capture device with new buffer size when a conflict happens. Sample Manipulation Timestamps If there is no external clock, the audio clock is used. The first sample starts from the current system time and timestamps are calculated based on the number of samples captured. If there is a period of silence, there will be a gap in the timestamps reflecting the number of samples skipped and AM_SAMPLE_DATADISCONTINUITY will be set on the first sample of the new talk spurt. This flag will also be set on the last media sample before a silence period. If there is an external clock, the filter syncs up the audio clock with the external clock whenever there is a silence period. The first sample starts from the first reading of the external clock and the subsequent timestamps are calculated based on the number of samples captured as long as there is no silence. When there is a silence period, the first non-silence sample sent after it uses a new reading of the external clock as the new starting timestamp.  A better approach than using the silence period to sync up is to adjust the sample rate to match the external clock. However, this requires adjusting of the sample rate with very fine granularity. The capture card may not support it. If the drift is not significant, the above algorithm should be good enough. If lip sync is required, the audio capture and video capture filters need to use the same clock. Besides that, we need to compensate for the latency between the time when a buffer is filled by the sound card and the time when the filter get a reading from the clock. The clock reading needs to be adjusted based on the latency number to get the accurate timestamp. This number may vary from system to system and is also affected by other activities in the system. We can calculate the variation but it is hard to find the offset. This number might have to be based on experiments.  In-band Format changes If the encoding format is changed on the fly, the RTP network filter needs to be notified about the payload type change and the sample rate change. AM_SAMPLE_TYPECHANGED will be set on the first sample that changed. The RTP filter needs to call GetMediaType() on the sample to get the new format.  Multiple Media Samples in one packet If the capture filter decides to send bigger packets in order to save bandwidth, it will call ReceiveMultiple() method on the input pin of the RTP filter to send multiple samples in one RTP packet. IAMStreamConfig interface  This is a DShow interface used to configure the formats. The output pin of the capture filter supports this interface to intercepts format changes. SetFormat Used to set the format used for the streaming. The filter delegates this function call to the TAPI Encoder Handler. If the format change causes a change in the buffer size for capturing, the filter will stop the capture and restarted it with the new capture size setting. GetFormat This function is delegated to the TAPI Encoding Handler. GetNumberOfCapabilities This function is delegated to the TAPI Encoding Handler. GetStreamCaps This function is delegated to the TAPI Encoding Handler.  IAudioInputMix interface  This is a DShow interface that uses the mixer API to control the capture settings. The same code will be used in the TAPI audio capture filter. ITAudioDeviceControl interface  The TAPI Audio Capture Filter supports this interface to configure device-related settings. The definition of this interface is in  Microsoft TAPI Media Control Interface . The capture filters supports the setting of AudioDevice_DuplexMode, AudioDevice_DriverType, AudioDevice_AutomaticGainControl, and AudioDevice_AccousticEchoCancellation. The method of this interface can only be called when the stream is in a stopped state. AudioDevice_DuplexMode Used to set the mode on the device. If half-duplex is specified, the capture device stops when the render side is active. AudioDevice_DriverType Used to select driver types. The capture filter will use either DSound or WAV based on the request. AudioDevice_AutomaticGainControl Used to specify if automatic gain control should be used. AudioDevice_AccousticEchoCancellation Used to enable and disable AEC. IAudioCaptureModeControl interface  This interface allows the render filter to control the capture device in half-duplex mode. StartCapture Used to start the capture device again. StopCapture Used to switch the capturing state but allows the device to stay opened. ReleaseCapture Used to release the capture device if the device doesn t support full duplex. StartCapture method This method is used to start the capture device. If the device was in paused state, the filter resumes the device and continues capturing. If the device was closed, the filter will reopen the device to capture. HRESULT StartCapture() This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_DEVICE_INUSE Device is in use No error StopCapture method This method is used to stop the capture device when the render is rendering data. The capture filter can still keep the device open. HRESULT StopCapture() This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure No error ReleaseCapture method This method is used to tell the capture filter to release the device. This happens when the device supports only half-duplex.  HRESULT ReleaseCapture() This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_DEVICE_INUSE Device is in use No error TAPI Audio Capture using hardware acceleration The detail of this scenario is described in the  AudioConferencing acceleration with WDM, Philippe Ferriere. There are two approaches to implement this feature. We can either use the ksproxy filter and add interface handlers on it or use the ksproxy code in the TAPI Audio capture filter. For the first approach, Philippe has already got running code. If we don t have blocking issues, the first approach will be used. If we do have blocking issues, we will cut the code out and construct a new filter. TAPI Audio Encoding Filter This filter is used when the data source can generate only PCM data and doesn t do any other processing. The encoder filter loads the TAPI Audio Encoding Handler to process the data before giving them to the network filter. The Encoding Handler is also aggregated by the output pin of the encoder filter to handle the TAPI specific interfaces. The audio encoding filter is just a simplified TAPI MSP Audio Capture Filter without the sound driver manipulation code. It is an in-place transform filter that does synchronous transform on the samples passed in.  Buffer management  Since this filter does in-place transform, the same media samples are normally passed to the downstream filter with the original timestamps and flags. The only thing special about this filter is that it has to tell the upstream filter the length of the sample buffer it expects. For this purpose, GetAllocatorRequirements() method is implemented to tell the upstream filter the required buffer size. However, if the upstream filter doesn t fulfill the requirement, the encoder filter creates its own allocator and copies the data. If the encoding format changed while the graph is running, the buffer size requirement might change. If there is a conflict, the encoder filter copies the samples too. TAPI Audio Render Filter (DSound) This filter supports multiple input pins and uses DSound secondary buffers to render audio data so that voice from multiple participants can be mixed together. It does jitter buffering based on the timestamps set by the network filter.  Mixing Each input pin of this render filter has a DSound secondary buffer. It is a circular buffer that stores 2 seconds worth of data. If there is no sound to play in 2 seconds, the buffer needs to be filled with silence or comfortable noise before the driver plays the same sound again. A timer of 500ms is set up using the timeSetEvent() function. When the timer goes off, the callback function goes through all the pins and cleanup stale data. The timeSetEvent() function uses one worker thread per process. The filter doesn t create its own thread to do mixing. Buffer management  DSound render filter itself doesn t provide an allocator. It copies the data provided by the upstream filter into the circular buffer and releases the media sample. If the buffer is full, the sample will be dropped. Timing control  The RTP source filter is responsible of calculating the jitter of the incoming packets. On the first sample of a new talk spurt, the RTP filter sets the AM_SAMPLE_DATADISCONTINUITY flag to true and it also sets the start time to current time + jitter buffer time. The render filters shares the same clock with the RTP filter so that it can put the sample into the right place in the play out buffer. This algorithm also works for lip-sync.  Clock slaving is not considered for this release since the silence suppression syncs the clocks so frequently that the drift between clocks is not a significant problem. IAudioSettings  The filter supports IAudioSettings interface to control audio related properties. It is basically the same as the ITAudioSettings interface, but it supports one more parameter, the SSRC of a participant. If the SSRC is 0, the method applies to the mixed data. If the SSRC is not 0, the method applies to a certain participant. Internally, the filter maintains a table of all the SSRCs to their settings. Based on who is talking, the setting will be applied to the pin that receives the data. In order to tell the render filter which participant is talking, the RTP filter needs to send the SSRC in the first media sample. The following data structure is added at the end of the AM_SAMPLE2_PROPERTIES data structure: #define TAPI_MEDIASAMPLE_KEY       ((DWORD)'TA31') typedef struct _TAPI_SAMPLE_PROPERTIES {     AM_SAMPLE2_PROPERTIES  Sample2Props;           DWORD    dwKey;               // Should be TAPI_MEDIASAMPLE_KEY     DWORD    dwSSRC; } TAPI_SAMPLE_PROPERTIES; The cbData field of the AM_SAMPLE2_PROPERTIES data structure should be not less than (sizeof AM_SAMPLE2_PROPERTIES + sizeof TAPI_SAMPLE_PROPERTIES). Note: The default implementation of CMediaSampe::GetProperties doesn t handle anything bigger than the size of AM_SAMPLE2_PROPERTIES, even though they put a cbData field as the first field! We need to push Dshow to fix the base class.  The IAudioSettings interface has the following methods, each of which takes an extra dwSSRC as the first parameter than the same methods in ITAudioSettings interface. GetRange  Used to retrieve minimum, maximum, and default values of an audio setting. Used to set the value of an audio setting.  Used to retrieve the value of an audio setting.  IAudioRenderModeControl interface  This interface is used to control the render filter in half-duplex mode. It is only called when the half-duplex mode is enabled.  SetCaptureModeControl Give the render filter an IAudioCaptureModeContorl interface so that the render filter can mute the capture device when it is rendering sound. StopRender Force the render filter to give up so that the capture filter can work. SetCaptureModeControl method This method is used to give an IAudioCaptureModeContorl to the render filter. Setting a valid interface pointer configures the render filter to work in half-duplex mode. The render filter first has to decide if the audio device supports full duplex. It first open its device and then calls StartCapture() on the IAudioCaptureModeContorl interface to let the capture filter open the device. If either of them fails with device-in-use, it means that the capture device can t support full duplex. In this case, the audio render will call ReleaseCapture() before rendering data and close the render device before calling StartCapture(). If the device does support full duplex, StartCapture() and StopCapture() will be called to switch the capture on and off. HRESULT SetCaptureModeControl(     IAudioCaptureModeControl * pCaptureModeControl     ) where pCaptureModeControl An interface pointer to an IAudioCaptureModeControl interface provided by a capture filter. If it is NULL, render mode is set to full duplex again. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Bad Pointer No error StopRender method This method is used to stop the render filter. It is used to implement push-to-talk feature in the half-duplex mode. The render filter is forced into mute state and it will also start the capture device if it has been stopped. HRESULT StopRender() This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure No error Stereo playout  This is an advanced feature. The render filter can create two channels for playing back the audio data. Based on the balance setting of each SSRC, the mono data is copied into the two channels with different attenuation, which can produce the illusion of position. This feature will be added after the basic mono playback. TAPI Audio Render Filter (WAV) WAV API doesn t support mixing so that the render filter has to handle the mixing before giving the samples to the driver. It differs from the DSound render in the following areas: Mixing This filter maintains one circular mixing buffer that can store 2 seconds worth of data. It is split into 100 20ms buffers. waveoutPrepareHeader() is called on these buffers. When samples are received, they are copied into certain positions in the mixing buffer based on the start time set by the RTP filter. If the samples  timestamps overlap, they will be mixed while being copied into the mixing buffer. The filter needs to keep track of the depth of mixing in order to scale the samples properly. Mixing samples directly into the mixing buffer avoids having a 2-second secondary buffer in each input pin.  At the beginning of a talk spurt, two 20ms buffers at the beginning of the mixing buffer are sent to the waveout device. After that, every time the waveout callback happens, another 20ms buffer will be fed to the device as long as there are still data in the buffer. In this way, the render filter relies on the sound card clock to pull the data out of the buffer. If there is a silence period, no data will be sent. When the next talk spurt starts, the same cycle starts again. Experience shown that using the waveout device this way produces the smallest latency. Buffer management  Like the DSound render filter, WAV render filter itself doesn t provide an allocator either. It copies the data provided by the upstream filter into the mixing buffer and releases the media sample immediately.  IAudioSettings  WAV render filter supports the same IAudioSettings interface as the DSound Render filter. However, it doesn t have a secondary buffer to apply the settings. The function in the input pin that copies data into the mixing buffer simulates the setting in software. TAPI Audio Mixing Filter This filter is used to mix the audio data in a conference and to send the result of the mixing to a PCM sink, which can be a file filter or a media-streaming filter. An important observation is that these sinks are not real-time sinks. There is no deadline of delivering data to the sink. Under this assumption, the mixing filter uses the system clock to decide when to deliver samples. Mixing This filter uses the same mixing algorithm as the WAV render filter. It maintains one circular mixing buffer that can store 2 seconds worth of data. When samples are received from the decoder, they are copied into certain positions in the mixing buffer based on the start time set by the RTP filter. If the samples  timestamps overlap, they will be mixed while being copied into the mixing buffer. The filter needs to keep track of the depth of mixing in order to scale the samples properly.  The difference between the WAV render filter and this filter is that there is no driver clock or driver callback. As a result, the system clock is chosen and a multimedia timer is used to simulate a driver callback.  Buffer management  The mixing filter doesn t provide an allocator for the upstream filter. It copies the data provided by the upstream filter into the mixing buffer and releases the media sample immediately. However, it uses its own allocator for the mixed samples. The 2-seconds circular mixing buffer is divided into 100 20ms media samples. A multimedia timer of 20ms is created to checking the mixing buffer periodically. If the difference between the timestamp of the first sample and the current clock is bigger than 20ms, the first 20ms sample in the mixing buffer is delivered to the next filter.   IAudioSettings  The mixer filter supports the same IAudioSettings interface as the DSound Render filter. However, it doesn t have a secondary buffer to apply the settings. The function in the input pin that copies data into the mixing buffer simulates the setting in software. TAPI Audio Decoding Filter This filter handles the decoding of the well-known formats and supports the interfaces required by TAPI. It is a simple transform filter with one input pin and one output pin. The filters itself doesn t have any special interface. Only the input pin supports several TAPI specific interfaces. Buffer management  RFC 1890 specifies that every audio endpoint should be capable of receiving audio packets between 0ms and 200ms. If fact, anything bigger than 200ms is not practical because of the huge latency. Therefore, the decoder sets the maximum packet size to not more that 200ms in the H245 capability and prepares to receive up to 200ms of data in one packet.  GetAllocatorRequirements() method on the input pin is used to tell the upstream filter the largest possible packet it could get. The RTP filter can use this information to allocate receiving buffers. If the downstream filter provides an allocator, SetProperties() is called on the allocator to specify the buffer size requirement. If the downstream filter can t fulfill the requirement, the Decoding Filter creates its own allocator. If the downstream filter doesn t provide an allocator at all, the Decoding Filter also creates its own allocator. Only one decoding buffer is needed if the downstream filter doesn t hold the buffer for very long. Sample Manipulation Timestamps The timestamps and other properties of the media sample will be copied form the input sample to the output sample without modification.   Format changes When the stream object wants to set the audio format, not matter the filter graph is running or not, it needs to call the SetFormat() method on the RTP output pin together with the new payload type value that the RTP filter should be expecting. When the RTP filter receives the first packet with the new payload type, it needs to set AM_SAMPLE_TYPECHANGED on the media sample delivered to the decoding filter. The decoding filter reads the new format from the sample and changes the decoding algorithm on the fly. This rule also applies to the very first sample after the graph starts running. The stream object guarantees that the new format is within the capability of the Decoding Filter. Otherwise, the stream object should have used a different filter for the new format. This feature requires the remote endpoint to use a different payload type for the format being changed to. If not, the RTP filter will not be able to figure out when the format changed. IAMStreamConfig interface  This is a DShow interface used to configure the formats. The input pin of the Decoding Filter supports this interface to expose the capabilities of the filter. SetFormat The Decoding Filter relies on in-band format changes signaled by the samples. Therefore, this function is not called directly by the stream object. While the pin is being connected, the output pin of the RTP filter calls this function to set the negotiated format. After the graph starts running, the filter will ignore the calls to this function and will change format only with the first sample that has AM_SAMPLE_TYPECHANGED flag set. GetFormat Get the format currently in use. GetNumberOfCapabilities Get the number of capabilites of the Encoding Handler. GetStreamCaps Get one specific capability.  This function returns a pair of AM_MEDIA_TYPE structure and an AUDIO_STREAM_CONFIG_CAPS structure.  The IBitRateControl interface  IBitRateControl interface sets the maximum bitrate on the encoder. TODO: We need to add a method to get the Bitrate Range and steps. SetMaxBitrate  Sets the upper limit of the bitrate of data before decoding. Not implemented. GetMaxBitrate Get the current bitrate upper limits of data before decoding that the current format uses. The ICPUControl interface  The ICPUControl interface is used to control the bounds of encoding time and CPU consumption.  SetMaxProcessingTime  Used to specify the max processing delay. Not implemented. GetMaxProcessingTime Used to get the current setting of maximum processing time. Not implemented. SetMaxCPULoad  This method is used to set the maximum CPU load by the Decoding Filter. It is the MIPs of the decoding algorithm / MIPs of the machine. If this method is called by the app before the stream is negotiated, it will affect the capability enumeration. Only the formats that meet the requirements will be considered. If this method is called while the streams is running and the number is too small, it will fail. GetMaxCPULoad Used to get the current setting of the CPU load. Device Enumeration DSound devices can be enumerated by using DirectSoundEnumerate and DirectSoundCaptureEnumerate. Each device is identified by a GUID and a device name. The name can be displayed to the user and the GUID can be used in DirectSoundCreate to open the device. WAV devices can be enumerated by using waveInGetNumDevs, waveInGetDevCaps, waveOutGetNumDevs, and waveOutGetDevCaps. Each device is identified by an ID and a name.  DevEnum.dll provided by DShow has a CLSID_SystemDeviceEnum object that uses the above APIs to enumerate devices. It also implements caching, PnP, and enumeration of other devices. The CLSID_CWaveinClassManager and CLSID_CWaveOutClassManager are the two categories that we need. It would be ideal to leverage the code in DevEnum. However, it doesn t enumerate DSound capture devices. The reason for this is that DShow doesn t have a DSound capture filter. We can either postpone the support for DSound capture or we will have to have special code for DSound capture enumeration. When enumerating the devices with the two sets of APIs, we will get two devices for each piece of hardware. The only way to match the results of the two enumerations is to match the device name. (Currently DeeEnum adds  DirectSound:  at the beginning of the name property of the device.) A TAPIAudioDeviceEnumerator is designed to achieve this goal. It enumerates all the WAV devices and DirectSound devices and merge them based on their name. The MSP Address object uses it as a helper object to create audio terminals. The IDeviceEnumerator interface  The IDeviceEnumerator interface is used to enumerate terminals, which identify devices. GetTerminals  Used to get the list of terminals. GetTerminals method This method is used get the list of terminals available. HRESULT GetTerminals(     [in]     TERMINAL_DIRECTION Direction,     [in,out] int *              piNumTerminals,     [out]    ITTerminal **      ppTerminals     [out]    int  *             piPreferred,     ) where Direction It can be either TD_CAPTURE for capture devices or TD_RENDER for render devices.  piNumTerminals Used to specify the number of terminals needed. The return value is the number of terminals returned in the array. If the ppTerminal filter is NULL, the returned number is the total number of terminals.  ppTerminals Memory space to store an array of terminal pointers.  plPreferred The index of the preferred device in the array.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Bad pointer TAPI_E_NOTENOUGHMEMORY The array is too small. No error The IAudioDeviceConfig interface  The terminal object creates the filter. It uses IAudioDeviceConfig to configure the filter. This interface is supported on both the audio capture filter and audio render filter. The IAudioDeviceConfig interface is used to enumerate audio devices and to create audio terminals out of these devices. SetDeviceID Used to set the ID of the audio device SetDeviceID method The method is used to set tell the filter the device ID. HRESULT SetDeviceID(     [in]     GUID * pDSoundGUID,     [in]     UNIT uiWaveID     ) where pDSoundGUID The GUID to create the dsound device.  uiWaveID The ID to open the wave device.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can be one of the following standard constants, or other values not listed here: HRESULT Meaning E_FAIL Failure E_POINTER Bad pointer No error References SDK documents on DShow, DSound, WAV. ITU standard G.711, G.723.1. RFC 1889, 1890. Microsoft Corporation Company Confidential  SAVEDATE \@ "M/d/yy" \* MERGEFORMAT  5/13/99        Draft - Microsoft Corporation Company Confidential      SAVEDATE \@ "h:mm am/pm" \* MERGEFORMAT  5:55 PM Microsoft Corporation Company Confidential  SAVEDATE \@ "M/d/yy" \* MERGEFORMAT  5/13/99        Draft - Microsoft Corporation Company Confidential      SAVEDATE \@ "h:mm am/pm" \* MERGEFORMAT  5:55 PM Revision 0.207            WDM Connection and Streaming Architecture Revision 0.6.  REVNUM  \* MERGEFORMAT              TITLE  \* MERGEFORMAT  Microsoft TAPI Audio Filters  DATE  05/15/99            Microsoft Corporation Company Confidential            TIME  3:54 PM  SAVEDATE \@ "M/d/yy" \* MERGEFORMAT  5/13/99       Draft - Microsoft Corporation Company Confidential       SAVEDATE \@ "h:mm am/pm" \* MERGEFORMAT  5:55 PM ITStream/ ITSubStream ITQualityControl ITFormatControl ITAudioDeviceControl ITAudioSettings Tapi3 app Channel Object IGraphBuilder IStreamControl IQualityControl Filter graph Quality Controller IH245Audio Capability Audio Stream object IChannelControl TAPI MSP Audio Capture Filter  ITAudioDeviceControl IAudioCaptureModeControl IAMStreamConfig IH245AudioCapability IBitrateControl ICPUControl INetworkStats ISilenceControl TAPI MSP RTP Render filter Voice Detection Audio Driver (WAV, DS) Encoder (G.711, G.723.1, ACM codecs) Automatic Gain Control TAPI MSP Audio Capture Filter  IAudioSettings TAPI MSP RTP Source filter IAMStreamConfig IH245AudioCapability IBitrateControl ICPUControl TAPI Audio Encoding Handler TAPI Audio Encoding Handler TAPI MSP Audio Encoding Filter  Audio Driver (WAV, DS) TAPI MSP Audio Capture Filter  IAudioSettings IAMStreamConfig IAMBufferNegotiation IEncodingControl IH245AudioCapability IBitrateControl ICPUControl ISilenceControl Audio Decoding Filter TAPI MSP RTP Source filter Mixer  Audio Decoding Filter Any other render filter that supports PCM IAMStreamConfig IH245AudioCapability IBitrateControl ICPUControl TAPI MSP Audio Decoding Filter  Automatic Gain Control Encoding (G.711, G.723.1, ACM codecs) Voice Detection TAPI MSP Audio Encoding Handler IAMStreamConfig IH245AudioCapability IBitrateControl ICPUControl INetworkStats ISilenceControl IAMAudioInputMixer  ITAudioDeviceControl IAudioCaptureModeControl IAMStreamConfig IAMBufferNegotiation IH245AudioCapability IBitrateControl ICPUControl INetworkStats ISilenceControl IAMAudioInputMixer  Ksproxy TAPI MSP RTP Render filter Automatic Gain Control Encoder TAPI MSP RTP Render filter IAMStreamConfig IH245AudioCapability IBitrateControl ICPUControl INetworkStats ISilenceControl IAudioCaptureModeControl IAMAudioInputMixer  Voice Detection Audio Driver (WAV, DS) TAPI MSP Audio Capture Filter  IAMStreamConfig IH245AudioCapability IBitrateControl ICPUControl INetworkStats ISilenceControl ITAudioDeviceControl IAudioCaptureModeControl IAMAudioInputMixer  IAMStreamConfig IAMBufferNegotiation  IAMStreamConfig IH245AudioCapability IBitrateControl ICPUControl A PCM Source Filter IAMAudioInputMixer IAMStreamConfig IH245AudioCapability IBitrateControl ICPUControl INetworkStats ISilenceControl TAPI MSP RTP Render filter Encoder (G.711, G.723.1, ACM codecs) Voice Detection IAMStreamConfig IAMBufferNegotiation  TAPI Audio Encoder Filter  Audio Render Filter (DSound, WAV) Audio Decoding Filter Audio Decoding Filter ~ytoje`[ ~ytoje`[ yspmgdaY {vqlg |wrmjgb] {vqlgb] |wrnid`[ |wkhe`[V ~ytqlgb_Z ~yvsnie`Y zvseb]X ~ytoje`[ }zlifc`[ {xupkfa^[X |wrmhc^ {vqmhc_ zwtqlgc^ ~ytqnkfa] ~yupie`[ }xqmhc_ xtojfa\ zvqlhe` {vokfa] |wplgb^ {vqlifc^ {olid_ZW ~zupli }zupkfa }xlifa\W |wtqnid` xtojfa\ {vqmhZW ~ytojgd_ |wrmjgd_ ~{vqnkhc^ zupkfa^[ |yvspmjgd }zwtqc`] {vqlgb_QN spmheb_Z }zwtlifc yvspm_v {vjgd zuqlea\ |ykheb_\ ~ytoje`[V zupkfa^[ vspkfa\Y
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\doc\microsoft tapi video capture filter.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Don Ryan Microsoft Corporation Microsoft  TAPI  Video Capture Filter Title _PID_GUID _PID_HLINKSMicrosoft  TAPI  Video Capture Filter VfW, WDM, and Videoconferencing Accelerator support Philippe Ferriere NetMeeting Specification.dot Philippe Ferriere Microsoft Word 8.0IDATx @&Ep  Tup:E* X06og TfEwc n?,4.[@b kj4"pv  m$kNu w~=8\3 9)?y9 zti=h sP`(bc1@'Dp 8{$}9 V?o8R lpYQ& >8ocu <p8k` p4]%9 7)iV5 h*f!> 8de'O fUnpf yzJL/ ~IDAT /hwdev/desinit/ TITLE  \* MERGEFORMAT  Microsoft  TAPI  Video Capture Filter  SUBJECT  \* MERGEFORMAT  VfW, WDM, and Videoconferencing Accelerator support Design Specification   Draft Author:   AUTHOR  \* MERGEFORMAT  Philippe Ferriere Revision 0.1.154,   SAVEDATE \@ "d MMMM, yyyy" \* MERGEFORMAT  28 February, 1999 This documentation is an early release of the final product documentation. It is meant to accompany software that is still in development. Some of the information in this documentation may be inaccurate or may not be an accurate representation of the functionality of the final retail product. Microsoft assumes no responsibility for any damages that might occur either directly or indirectly from these inaccuracies.  TOC \o "1-4"  Introduction  PAGEREF _Toc444857957 \h  Intended audience  PAGEREF _Toc444857958 \h  Conventions  PAGEREF _Toc444857959 \h  Document organization  PAGEREF _Toc444857960 \h  Definition of terms  PAGEREF _Toc444857961 \h  Video capture overview  PAGEREF _Toc444857962 \h  VfW video capture  PAGEREF _Toc444857963 \h  WDM video capture  PAGEREF _Toc444857964 \h  3.2.1 Components of WDM Streaming  PAGEREF _Toc444857965 \h  3.2.2 KSProxy  PAGEREF _Toc444857966 \h  3.2.3 Streams, pins and formats  PAGEREF _Toc444857967 \h  TAPI local video architecture  PAGEREF _Toc444857968 \h  TAPI 3.0 overview  PAGEREF _Toc444857969 \h  Call and media controls  PAGEREF _Toc444857970 \h  4.2.1 TAPI 3.0 COM object  PAGEREF _Toc444857971 \h  4.2.2 TAPI server  PAGEREF _Toc444857972 \h  4.2.3 Call control functions  PAGEREF _Toc444857973 \h  4.2.4 Media control functions  PAGEREF _Toc444857974 \h  Local video filter graph  PAGEREF _Toc444857975 \h  4.3.1 VfW capture devices  PAGEREF _Toc444857976 \h  4.3.1.1 Default implementation  PAGEREF _Toc444857977 \h  4.3.1.2 Support for installable codec  PAGEREF _Toc444857978 \h  4.3.2 WDM capture devices  PAGEREF _Toc444857979 \h  4.3.2.1 Default implementation  PAGEREF _Toc444857980 \h  4.3.2.2 Support for installable codec  PAGEREF _Toc444857981 \h  4.3.3 Videoconferencing Accelerators  PAGEREF _Toc444857982 \h  TAPI MSP video capture filter and WDM video capture  PAGEREF _Toc444857983 \h  TAPI MSP video capture filter and VfW video capture  PAGEREF _Toc444857984 \h  Video capture filter streams  PAGEREF _Toc444857985 \h  Output streams  PAGEREF _Toc444857986 \h  Input streams  PAGEREF _Toc444857987 \h  Video capture filter stream formats  PAGEREF _Toc444857988 \h  Media types for video preview streams  PAGEREF _Toc444857989 \h  Media types for capture and still-image streams  PAGEREF _Toc444857990 \h  Media type for H.26x compressed video and still-image streams  PAGEREF _Toc444857991 \h  6.3.1 Video info header structure for H.263 video streams  PAGEREF _Toc444857992 \h  6.3.2 Video info header structure for H.261 video streams  PAGEREF _Toc444857993 \h  6.3.3 Bitmap info header structure for H.263 video streams  PAGEREF _Toc444857994 \h  6.3.4 Bitmap info header structure for H.261 video streams  PAGEREF _Toc444857995 \h  Media type for RTP packetization descriptor streams  PAGEREF _Toc444857996 \h  6.4.1 Configuration capabilities structure for RTP packetization descriptor streams  PAGEREF _Toc444857997 \h  6.4.2 Information header structure for RTP packetization descriptor streams  PAGEREF _Toc444857998 \h  6.4.3 RTP packetization descriptor format  PAGEREF _Toc444857999 \h  6.4.4 RTP packetization descriptor and video streams synchronization  PAGEREF _Toc444858000 \h  Media type enumeration  PAGEREF _Toc444858001 \h  6.5.1 First time use  PAGEREF _Toc444858002 \h  6.5.2 Known capture device  PAGEREF _Toc444858003 \h  6.5.3 Quality Assurance  PAGEREF _Toc444858004 \h  Video capture filter application interfaces  PAGEREF _Toc444858005 \h  VfW specific capture device application interface  PAGEREF _Toc444858006 \h  7.1.1 VfwCaptureDialogs enumerated data type  PAGEREF _Toc444858007 \h  7.1.2 HasDialog method  PAGEREF _Toc444858008 \h  7.1.3 ShowDialog method  PAGEREF _Toc444858009 \h  7.1.4 SendDriverMessage method  PAGEREF _Toc444858010 \h  WDM capture device and Videoconferencing Accelerator specific application interfaces  PAGEREF _Toc444858011 \h  7.2.1 IAMCrossbar interface  PAGEREF _Toc444858012 \h  7.2.2 PhysicalConnectorType enumerated data type  PAGEREF _Toc444858013 \h  7.2.3 get_PinCounts method  PAGEREF _Toc444858014 \h  7.2.4 CanRoute method  PAGEREF _Toc444858015 \h  7.2.5 Route method  PAGEREF _Toc444858016 \h  7.2.6 get_IsRoutedTo method  PAGEREF _Toc444858017 \h  7.2.7 get_CrossbarPinInfo method  PAGEREF _Toc444858018 \h  VfW, WDM capture device and Videoconferencing Accelerator application interfaces  PAGEREF _Toc444858019 \h  7.3.1 IAMVideoProcAmp interface  PAGEREF _Toc444858020 \h  7.3.1.1 VideoProcAmpProperty enumerated data type  PAGEREF _Toc444858021 \h  7.3.1.2 VideoProcAmpFlags enumerated data type  PAGEREF _Toc444858022 \h  7.3.1.3 GetRange method  PAGEREF _Toc444858023 \h  7.3.1.4 Set method  PAGEREF _Toc444858024 \h  7.3.1.5 Get method  PAGEREF _Toc444858025 \h  7.3.2 IAMCameraControl interface  PAGEREF _Toc444858026 \h  7.3.2.1 CameraControlProperty enumerated data type  PAGEREF _Toc444858027 \h  7.3.2.2 CameraControlFlags enumerated data type  PAGEREF _Toc444858028 \h  7.3.2.3 GetRange method  PAGEREF _Toc444858029 \h  7.3.2.4 Set method  PAGEREF _Toc444858030 \h  7.3.2.5 Get method  PAGEREF _Toc444858031 \h  7.3.3 IAMVideoControl interface  PAGEREF _Toc444858032 \h  7.3.3.1 VideoControlFlags enumerated data type  PAGEREF _Toc444858033 \h  7.3.3.2 GetCaps method  PAGEREF _Toc444858034 \h  7.3.3.3 SetMode method  PAGEREF _Toc444858035 \h  7.3.3.4 GetMode method  PAGEREF _Toc444858036 \h  7.3.3.5 GetCurrentActualFrameRate method  PAGEREF _Toc444858037 \h  7.3.3.6 GetFrameRateList method  PAGEREF _Toc444858038 \h  7.3.3.7 GetMaxAvailableFrameRate method  PAGEREF _Toc444858039 \h  Video capture filter H.245 video capability MSP interface  PAGEREF _Toc444858040 \h  8.1.1 IH245VideoCapability interface  PAGEREF _Toc444858041 \h  8.1.2 NegotiatedVideoLimit enumerated data type  PAGEREF _Toc444858042 \h  8.1.3 VideoResourceBounds structure  PAGEREF _Toc444858043 \h  8.1.4 H245VideoCapabilityMap structure  PAGEREF _Toc444858044 \h  8.1.5 H245VideoCapabilityTable structure  PAGEREF _Toc444858045 \h  8.1.6 GetH245VersionID method  PAGEREF _Toc444858046 \h  8.1.7 GetFormatTable method  PAGEREF _Toc444858047 \h  8.1.8 ReleaseFormatTable method  PAGEREF _Toc444858048 \h  8.1.9 IntersectFormats method  PAGEREF _Toc444858049 \h  8.1.10 GetLocalFormat method  PAGEREF _Toc444858050 \h  8.1.11 GetNegotiatedLimitProperty method  PAGEREF _Toc444858051 \h  8.1.12 ReleaseNegotiatedCapability method  PAGEREF _Toc444858052 \h  8.1.13 SetIDBase method  PAGEREF _Toc444858053 \h  8.1.14 FindIDByRange method  PAGEREF _Toc444858054 \h  Video capture output pin TAPI interfaces  PAGEREF _Toc444858055 \h  VfW and WDM capture device capture output pin TAPI interfaces  PAGEREF _Toc444858056 \h  9.1.1 ICPUControl interface  PAGEREF _Toc444858057 \h  9.1.2 IFrameRateControl interface  PAGEREF _Toc444858058 \h  Compressed video output pin TAPI interfaces  PAGEREF _Toc444858059 \h  9.2.1 IH245EncoderCommand interface  PAGEREF _Toc444858060 \h  9.2.1.1 videoFastUpdatePicture command  PAGEREF _Toc444858061 \h  9.2.1.2 videoFastUpdateGOB command  PAGEREF _Toc444858062 \h  9.2.1.3 videoFastUpdateMB command  PAGEREF _Toc444858063 \h  9.2.1.4 videoSendSyncEveryGOB and videoSendSyncEveryGOBCancel commands  PAGEREF _Toc444858064 \h  9.2.1.5 videoNotDecodedMBs indication  PAGEREF _Toc444858065 \h  9.2.1.6 FlowControl command  PAGEREF _Toc444858066 \h  9.2.1.7 videoTemporalSpatialTradeOff  command  PAGEREF _Toc444858067 \h  9.2.1.8 H.245 mode requests  PAGEREF _Toc444858068 \h  9.2.2 INetworkStats interface  PAGEREF _Toc444858069 \h  9.2.2.1 SetChannelErrors method  PAGEREF _Toc444858070 \h  9.2.2.2 GetChannelErrors method  PAGEREF _Toc444858071 \h  9.2.2.3 GetChannelErrorsRange method  PAGEREF _Toc444858072 \h  9.2.2.4 SetPacketLossRate method  PAGEREF _Toc444858073 \h  9.2.2.5 GetPacketLossRate method  PAGEREF _Toc444858074 \h  9.2.2.6 GetPacketLossRateRange method  PAGEREF _Toc444858075 \h  9.2.3 ICPUControl interface  PAGEREF _Toc444858076 \h  9.2.3.1 SetMaxProcessingTime method  PAGEREF _Toc444858077 \h  9.2.3.2 GetMaxProcessingTime method  PAGEREF _Toc444858078 \h  9.2.3.3 GetMaxProcessingTimeRange method  PAGEREF _Toc444858079 \h  9.2.3.4 SetMaxCPULoad method  PAGEREF _Toc444858080 \h  9.2.3.5 GetMaxCPULoad method  PAGEREF _Toc444858081 \h  9.2.3.6 GetMaxCPULoadRange method  PAGEREF _Toc444858082 \h  9.2.4 IBitrateControl interface  PAGEREF _Toc444858083 \h  9.2.4.1 SetMaxBitrate method  PAGEREF _Toc444858084 \h  9.2.4.2 GetMaxBitrate method  PAGEREF _Toc444858085 \h  9.2.4.3 GetMaxBitrateRange method  PAGEREF _Toc444858086 \h  9.2.5 IFrameRateControl interface  PAGEREF _Toc444858087 \h  9.2.5.1 SetMaxFrameRate method  PAGEREF _Toc444858088 \h  9.2.5.2 GetMaxFrameRate method  PAGEREF _Toc444858089 \h  9.2.5.3 GetMaxFrameRateRange method  PAGEREF _Toc444858090 \h  9.2.6 IProgressiveRefinement interface  PAGEREF _Toc444858091 \h  Video preview output pin TAPI interfaces  PAGEREF _Toc444858092 \h  VfW and WDM capture device preview output pin TAPI interfaces  PAGEREF _Toc444858093 \h  10.1.1 ICPUControl interface  PAGEREF _Toc444858094 \h  10.1.2 IFrameRateControl interface  PAGEREF _Toc444858095 \h  Videoconferencing Accelerator preview output pin TAPI interfaces  PAGEREF _Toc444858096 \h  10.2.1 ICPUControl interface  PAGEREF _Toc444858097 \h  10.2.2 IFrameRateControl interface  PAGEREF _Toc444858098 \h  Compressed still-image output pin TAPI interfaces  PAGEREF _Toc444858099 \h  IProgressiveRefinement interface  PAGEREF _Toc444858100 \h  11.1.1 doOneProgression method  PAGEREF _Toc444858101 \h  11.1.2 doContinuousProgressions method  PAGEREF _Toc444858102 \h  11.1.3 doOneIndependentProgression method  PAGEREF _Toc444858103 \h  11.1.4 doContinuousIndependentProgressions method  PAGEREF _Toc444858104 \h  11.1.5 progressiveRefinementAbortOne method  PAGEREF _Toc444858105 \h  11.1.6 progressiveRefinementAbortContinuous method  PAGEREF _Toc444858106 \h  INetworkStats interface  PAGEREF _Toc444858107 \h  ICPUControl interface  PAGEREF _Toc444858108 \h  IBitrateControl interface  PAGEREF _Toc444858109 \h  RTP packetization descriptor output pin TAPI interface  PAGEREF _Toc444858110 \h  IRTPPDControl interface  PAGEREF _Toc444858111 \h  12.1.1 SetMaxRTPPacketSize method  PAGEREF _Toc444858112 \h  12.1.2 GetMaxRTPPacketSize method  PAGEREF _Toc444858113 \h  12.1.3 GetMaxRTPPacketSizeRange method  PAGEREF _Toc444858114 \h  References  PAGEREF _Toc444858115 \h  TAPI specifications  PAGEREF _Toc444858116 \h  DirectShow SDK articles and documentation  PAGEREF _Toc444858117 \h  WDM Stream class, WDM articles and documentation  PAGEREF _Toc444858118 \h  ITU communications standards  PAGEREF _Toc444858119 \h  IETF Request for comments  PAGEREF _Toc444858120 \h  Introduction Off-the-shelf video capture source filters have been designed with a heavy bias towards file-based video recording. As such, they typically capture video data to be stored in a multimedia file to be compressed with an arbitrary codec at a later time, at a fixed bitrate. They also try and capture at a constant frame rate to guarantee smooth video playback. Similarly, the video frame size remains constant during the entire capture process. A video capture source filter designed for videoconferencing needs to satisfy a different set of requirements. First, it needs to adapt its behavior to network conditions. This usually means being able to frequently adjust its output frame rate based on the amount of congestion observed over the wire. Similarly, the data it produces needs to be compressed in real-time. If there is not enough CPU available to guarantee real-time encoding, here again, it needs to slow down its output frame rate. Second, the encoders used to compress the video data are based on well know H.26x standards. Those encoders have many optional modes of operations that are enabled or disabled based on the capabilities of the remote endpoint. There is a lot of value in making this information available to the video capture source filter in order to optimize the capture/encoding process. Making the encoder part of the capture filter also allows us to build simpler, more efficient, and identical graphs for VfW, WDM capture devices and Videoconferencing Accelerators. In order to allow mode request changes, an endpoint needs to build a list of Transmit capabilities that is based on the capture device and video encoder capabilities. This is, here too, better handled if the encoder is part of the video capture filter. Also, as explained in the previous paragraph, the encoder needs to adjust its output bitrate, either based on network conditions or to answer an H.245 call control command. The encoder does some form of bitrate control, but may be unable to reach the target output bitrate on its own, if the video capture frame rate is simply too high for instance. A combined capture/encoder filter makes this process simpler to manage. Third, the video frame size of the captured video data does not have to remain constant during an entire H.323 call. As a matter of fact, users tend to often modify their local video frame size, or the remote endpoint frame size, to compensate for low video frame rate or poor video quality by reducing the image size for instance. A good videoconferencing capture source filter memory allocator needs to be able and anticipate those dynamic format changes to be as responsive as possible. In order to provide the best user experience, this document describes a new TAPI MSP Video Capture filter. This filter reuses some of the code that has been developed for the off-the-shelf VfW (QCAP) and WDM (KSProxy) video capture filters, but adds a significant amount of powerful processing functions to the capture process to meet all the requirements discussed above (section   REF _Ref444848866 \r \h  We describe extended bitmap info headers for H.261 and H.263 video streams to communicate to the TAPI MSP Video Capture filter a list of media types supported by the remote endpoint. Still, the decision to use optional compression modes is left to the TAPI MSP Video Capture filter (section   REF _Ref444844691 \r \h  ). The current VfW off-the-shelf capture filter does not have a way to expose all the capabilities of the capture device. We create our own media type enumeration process to compensate for this limitation (section   REF _Ref444845440 \r \h  The TAPI MSP Video Capture filter also supports a number of DirectShow interfaces (IAMVfwCaptureDialogs, IAMCrossbar, IAMVideoProcAmp, IAMCameraControl, IAMVideoControl) to provide better control over the capture process to TAPI applications (section   REF _Ref429467554 \r \h  We introduce a new H.245 Video Capability interface (IH245VideoCapability) supported by the TAPI MSP Video Capture filter to be used by the MSP in order to provide the TAPI MSP Capability module with a table of estimated steady-state resource requirements as related to each format that the capture device supports (section   REF _Ref444845442 \r \h  We define a new H.245 command interface (IH245EncoderCommand) to communicate to the TAPI MSP Video Capture filter requests for I-frame, group of blocks, or macro-block updates due to packet loss or multi-point switching (section   REF _Ref443191698 \r \h  9.2.1 ). We introduce a network statistics interface (INetworkStats), to allow the network to provide feedback on the channel conditions to the compressed video output pin of the TAPI MSP Video Capture filter. The TAPI MSP Video Capture filter is responsible for taking appropriate actions, if needed (section   REF _Ref427926473 \r \h  9.2.2 ). The TAPI MSP Video Capture filter also implements three control interfaces (ICPUControl, IFrameRateControl, IBitrateControl) to be used by the TAPI MSP Quality Controller to provide the best user experience (sections   REF _Ref443191699 \r \h  9.2.3  REF _Ref442843458 \r \h  9.2.5 The TAPI MSP Video Capture filter also exposes a preview output pin that can be controlled independently of the capture output pin (section   REF _Ref444850599 \r \h  ). The data produced by this pin will be rendered using overlay or a video port if supported by the capture device. The TAPI MSP Video Capture filter exposes an interface (IProgressiveRefinement) on its compressed video output pin to allow for transmission of high-resolution stills that are continuously improved on the remote endpoint as more data is received and decompressed. The TAPI MSP Video Capture filter may also elect to implement this same interface on an optional separate and dedicated still-image output pin (section   REF _Ref431548304 \r \h  Finally, the TAPI MSP Video Capture filter exposes an RTP packetization descriptor output pin synchronized to the compressed capture output pin. The downstream RTP Network Sink filter uses this second pin to understand how to better fragment the compressed video data into network RTP packets. Intended audience The reader should have a good understanding of the DirectShow model and its operation, the VfW and WDM video capture architectures, as well as ITU-T standards H.245, H.261 and H.263. Conventions In this document the following conventions are used: "Shall" indicates a mandatory requirement, "Should" indicates a suggested but optional course of action, "May" indicates an optional course of action rather than a recommendation that something take place. References to Sections, Paragraphs, Annexes, and Appendices refer to those items within this specification unless another document is explicitly listed. Document organization Section   REF _Ref420292803 \r \h   of this document defines the terms used in this specification. Section   REF _Ref429843169 \r \h   and   REF _Ref429843190 \r \h   provide background information on the VfW and WDM video capture architectures and how the TAPI MSP gets access to capture services using the TAPI MSP Video Capture filter. Section   REF _Ref444857715 \r \h   describes the streams opened on the TAPI MSP Video Capture filter, including the video preview stream, video port video preview stream, video capture stream, still-image stream, and RTP packetization descriptor stream. Section   REF _Ref444844691 \r \h   lists the formats of preview and capture output streams, as well as H.26x compressed video and still-image output streams (section   REF _Ref444844743 \r \h  ) and RTP packetization descriptor output streams (section   REF _Ref444845439 \r \h  ). It also details the media type enumeration process used by the TAPI MSP Video Capture filter for VfW and WDM capture devices (section   REF _Ref444845440 \r \h  Section   REF _Ref429467554 \r \h   enumerates the DirectShow interfaces and associated property sets on the TAPI MSP Video Capture filter exposed by the TAPI MSP to applications. Section   REF _Ref444845442 \r \h   details the H.245 video capability interface used to provide the TAPI MSP Capability module with a table of estimated steady-state resource requirements as related to each format that the TAPI MSP Video Capture filter supports. Section   REF _Ref431524638 \r \h   provides the list of interfaces and associated property sets exposed on the video output streams exposed by the TAPI MSP to the Channel Controller, Quality Controller and the downstream network send filter. Section   REF _Ref443191698 \r \h  9.2.1  documents a new interface designed to handle H.245 commands. Section   REF _Ref427926473 \r \h  9.2.2  introduces a network statistics interface created to provide feedback on network conditions. Sections   REF _Ref443191699 \r \h  9.2.3  REF _Ref442843456 \r \h  9.2.4 , and   REF _Ref442843458 \r \h  9.2.5  describe CPU, bandwidth, and bitrate control interfaces. Section   REF _Ref431548349 \r \h   describes the list of interfaces and associated property sets on the preview output stream used by the TAPI MSP Quality Controller. Section   REF _Ref432738952 \r \h   describes the list of interfaces and associated property sets on the compressed still-image output stream exposed by the TAPI MSP to the TAPI MSP Channel Controller and the downstream network send filter. Section   REF _Ref429812311 \r \h   documents a new interface designed to handle H.245 progressive refinement commands. Section   REF _Ref431548374 \r \h   describes the interface and associated property set on the RTP packetization descriptor output stream exposed by the TAPI MSP to the TAPI MSP Quality Controller. Definition of terms Adapter: See Device. Channel Controller: The TAPI MSP Channel Controller is the reliable channel used to carry the control information messages (following H.245) between two H.323 endpoints. Class Driver: A Microsoft-provided class driver is an intermediate driver designed to provide a simple interface between a vendor-written minidriver and the operating system. It provides system-required, hardware-independent support for a given class of physical devices. Such a driver communicates with a corresponding hardware-dependent port driver, using a set of system-defined device control requests, possibly with additional driver-defined device control requests. Under WDM, the class driver creates a device object to represent each adapter registered by minidrivers. The class driver is responsible for multiprocessor and interrupt synchronization Codec: Coder/Decoder. A filter for data that manipulates it in some form, usually by compressing or decompressing the data stream. Component Object Model (COM): The OLE object-oriented programming model that defines how objects interact within a single process or between processes. In COM, clients have access to an object through interfaces implemented on the object. See also Interface. COM Object: An object that conforms to the OLE Component Object Model (COM). A COM object is an instance of an object definition, which specifies the object's data and one or more implementations of interfaces on the object. Clients interact with a COM object only through its interfaces. See also Component Object Model and Interface. Connection: A negotiated method of communication between devices, whether implemented in hardware or software. Device: For WDM, usually refers to a device object, but also refers to a unit of hardware - for example, a video capture adapter - that is detected by Plug and Play. Device Node: The basic data structure for a given device, built by the Configuration Manager. Device nodes are built into memory at system startup for each device and enumerator. Each device node contains information about the device, such as currently assigned resources. The complete hierarchical representation of all device nodes, representing all currently installed devices, is referred to as the hardware tree. Device Object: A kernel-mode-only object type used to represent a physical, logical, or virtual device whose driver has been loaded into the system. DirectShow: o receive data from an upstream filter. An upstream filter sends data from its output pin to the connected input pin of the downstream filter. Driver: Kernel-mode code used either to control or emulate a hardware device. Driver Stack: Device objects that forward IRPs to other device objects. Stacking always occurs from the bottom up and is torn down from the top. Encoder Filter: A specialized type of transform filter. Encoder filters (compressors) accept data, use a compression scheme to transform the data, and pass the compressed data downstream.  Enumerator: A Plug and Play device driver that detects devices below its own device node, creates unique device IDs, and reports to Configuration Manager during startup. Filter: Atomic component that provides the basic building blocks for processing data. Under the WDM Streaming architecture, this normally corresponds to a single Plug and Play Functional Device Object. Each filter s capability is described in part by a number of connection points called pins. Each pin can consume or produce a data stream such as digital video. Specialized tasks can be solved by connecting filters by way of their pins into a topology - for example, to play filtered and mixed audio. Under WDM, a filter is implemented as a kernel-mode entity that is a device object usually implemented by a kernel driver. Under DirectShow, a filter is a user-mode entity that is an instance of a COM object, usually implemented by a DLL. Filter Graph: A collection of filters. Typically, a filter graph contains filters that are connected to perform a particular operation, such as playing back a media file, or capturing video from a VCR to the hard disk. Format Type: A GUID value that indicates what a format block contains. DirectShow defines a number of major types, for example, the video type. These major types have a format block, such as VIDEOINFOHEADER, that describes the media data. The format block for a particular media type is specified by a GUID in the AM_MEDIA_TYPE structure. This GUID is called the format type. If the format block contains VIDEOINFOHEADER, the format type GUID is FORMAT_VideoInfo. Functional Device Object: Under Plug and Play, this is the device object created by a driver during notification that a new instance is necessary because of exposure by an Enumerator. GOB: Group-Of-Blocks. In H.263, a GOB consists of a row of k*16 lines with k=1 for sub-QCIF, QCIF and CIF, k=2 for 4CIF and k=4 for 16CIF; thus there are 6GOBs for sub-QCIF, 9 for QCIF, and 18 for CIF, 4CIF, and 16CIF. Data for each GOB consists of a GOB header (which may be empty) followed by data for each of the macroblocks (MBs) contained in a GOB. GUID: A globally unique identifier used to uniquely identify objects, such as interfaces and plug-in distributors. Class identifiers (CLSIDs) and interface identifiers (IIDs) are GUIDs. H.245: ITU Recommendation H.245. This Recommendation specifies syntax and semantics of terminal information messages as well as procedures to use them for in-band negotiation at the start of or during communication. The messages cover receiving and transmitting capabilities as well as mode preference from the receiving end, logical channel signaling, and Control & Indication. Acknowledged signaling procedures are specified to ensure reliable audiovisual and data communication. H.261: ITU Recommendation H.261. This Recommendation describes the video coding and decoding methods for the moving picture component of audiovisual services at the rates of px64 kbit/s, where p is in the range 1 to 30. H.263: ITU Recommendation H.263. This Recommendation specifies a coded representation that can be used for compressing the moving picture component of audio-visual services at low bit rates. The basic configuration of the video source coding algorithm is based on Recommendation H.261 and is a hybrid of inter-picture prediction to utilize temporal redundancy and transform coding of the remaining signal to reduce spatial redundancy. The source coder can operate on five standardized video source formats. The decoder has motion compensation capability, allowing optional incorporation of this technique in the coder. Half pixel precision is used for the motion compensation, as opposed to Recommendation H.261 where full pixel precision and a loopfilter are used. Variable length coding is used for the symbols to be transmitted. In addition to the basic video source-coding algorithm, negotiable coding options are included for improved compression performance and the support of additional capabilities. Additional supplemental information may also be included in the bitstream for enhanced display capability and for external usage. Hardware Branch: The hardware archive root key in the registry that is a superset of the memory-resident hardware tree. Although the hardware tree contains information only about those devices currently detected and running in the system, the registry contains a complete list of all hardware ever installed on the particular computer. The hardware root key is HKEY_LOCAL_MACHINE\Hardware. Hardware Tree: A record in RAM of the current system configuration based on the configuration information for all devices in the hardware branch of the registry. The hardware tree is created each time the system is started or whenever a dynamic change occurs to the system configuration. In-Process Server: A server implemented as a DLL that runs in the process space of the client. See also Out-of-process server, Local server, and Remote server. Input Pin: A pin that accepts data into the filter. Interface: For parameters on a connection request, a specific set of methods and properties implemented on a medium that a filter connection uses to communicate, such as a specific set of IOCTLs. In COM, A group of semantically related functions that provide access to a COM object. Each OLE interface defines a contract that allows objects to interact according to the Component Object Model. IOCTL: Input/output control. A custom class of IRPs available to user mode. Each WDM driver has a set of IOCTLs that it accepts to communicate with applications. The IOCTLs can be used to retrieve or give the driver information about intended usage by applications. The driver is responsible for all IOCTL parameter validation. IRP: I/O request packet. Data structures that drivers use to communicate with each other. The basic method of communication between kernel-mode devices. An IRP is a key data structure for WDM, which features multiple layered drivers. In WDM, every I/O request is represented by an IRP that is passed from one driver layer to another until the request is complete. When a driver receives an IRP, it performs the operation the IRP specifies, and then either passes the IRP back to the I/O Manager for disposal or onto an adjacent driver layer. An IRP packet consists of two parts: a header and the I/O stack locations. IRQ: Interrupt request. A method by which a device can request to be serviced by the device s software driver. The system board uses a PIC to monitor the priority of the requests from all devices. When a request occurs, the microprocessor suspends the current operation and gives control to the device driver associated with the interrupt number issued. ISR: Interrupt service routine. A routine whose function is to service a device when it generates an interrupt. ITU: International Telecommunication Union. Keyframe: A frame of video data that contains all the data necessary to construct that frame. In contrast, delta frames contain data relating to changes from the last keyframe and do not contain enough information by themselves to construct a complete frame. KSProxy: KSProxy is a Microsoft-provided DirectShow filter whose role is to move a data stream down onto kernel-mode drivers and hardware components. KSProxy, running in non-kernel mode, accepts existing control interfaces (for example, the audio Wave APIs or the DirectSound APIs) and translates them into IOCTL calls to the Microsoft-provided WDM Streaming run-time library. Layered Driver: One of a collection of drivers that responds to the same IRPs. Layered driver describes the highest-level and lowest-level drivers in a chain of layered drivers that process the same IRPs, along with all intermediate drivers in the chain. Major Type: A GUID value that describes the overall class of media data for a data stream. Typical values are MEDIATYPE_Video, MEDIATYPE_Audio, MEDIATYPE_Text, and MEDIATYPE_Midi. Master Clock: Controls the rate of reference time within a graph and is used by filters within the graph to synchronize presentation times. Provides a standard mechanism to query the reference time, to query the physical clock time and rate (compared to the system clock) of the owner of the master clock, and to establish event notifications based on position changes in the master clock s reference time. MB: Macroblock. In H.263, like in MPEG1-2, it consists of a 16x16 block of Y, and corresponding 8x8 blocks of each of the two chrominance components. Method: A predefined interface function. Minidriver: A minidriver is a hardware-specific DLL that uses a Microsoft-provided class driver to accomplish most actions through function calls, and provides only device-specific controls. Minor Type: See subtype (media type). MSP: Media Service Provider. A component in TAPI that handles media streams. Out-Of-Process Server: A server, implemented as an .EXE application, which runs outside the process of its client, either on the same machine or a remote machine. See also Local server and Remote server. Output Pin: A pin that provides data to other filters. Payload Data: The data transported by RTP in a packet for example compressed video data. Payload Header: For H.263 and H.261 RTP packets, the RTP fixed header is followed by the payload header, itself followed by the payload data. Pin: A set of filter-defined properties in kernel streaming that specify a connection endpoint. In DirectShow, a COM object created by the filter that represents a point of connection for a data stream on the filter. Pins provide interfaces to connect with other pins and transport data. Input pins accept data into the filter, and output pins provide data to other filters. An input pin typically exposes the IPin and IMemInputPin interfaces. An output pin typically exposes the IPin, IMediaSeeking, and IQualityControl interfaces. A source filter provides one output pin for each stream of data in the file. A typical transform filter, such as a compression/decompression (codec) filter, provides one input pin and one output pin Port Driver: A low-level driver that responds to a set of system-defined device control requests and possibly to an additional set of driver-defined (private) device control requests sent down by a corresponding class driver. A port driver insulates class drivers from the specifics of host bus adapters and synchronizes operations for all its class drivers. Presentation Time: The stream time at which the packets of data that a filter receives should be presented downstream or rendered. When a filter graph runs, each filter is passed a start time according to the reference clock, and the packets of data that a filter receives will usually be time-stamped with the presentation time. Property: In WDM and Windows NT device driver models, an aspect of the device or stream that can be set or retrieved, such as image brightness level. Property Set: In WDM and Windows NT device driver models, a method defined to set and get properties on a driver. Each property set has a unique identifier, which represents types of related information and is used to access the property set. Quality Controller: The TAPI MSP Quality Controller takes as an input application requests, behavior of streaming application components such as encoding and decoding filters, the current network characteristics, the current CPU usage, the remote endpoint requests. Based on those inputs, it applies commands onto the streaming components to guarantee the best user experience. Renderer: A filter that renders media data to any location that accepts media input. Most often, data is rendered to a computer monitor, sound card, or printer. Renderer filters have only input pins. Remote Server: A server application, implemented as an EXE, running on a different machine from the client application using it. See also In-process server, Local server, and Out-of-process server. RTP: Real-Time Transport Protocol. RTP provides end-to-end network transport functions suitable for applications transmitting real-time data, such as audio, video or simulation data, over multicast or unicast network services. Source Filter: A filter that takes data from some source such as the hard drive, network, or the Internet, and introduces it into the filter graph. Stream: An object representing an entity on an adapter capable of receiving, processing, or supplying data. A stream is identical to a WDM Stream architecture pin. A stream can accept data from or supply data to the processor, such as a stream representing an H.263 input, or can simply route data through hardware, such as a stream representing an NTSC output jack on the back of an adapter. The purpose of representing non-data hardware with a stream is that the properties of the hardware can be controlled by software. Subtype (media type): A GUID value that describes the specific format of media data for a data stream. Typical values include MEDIASUBTYPE_MJPG, MEDIASUBTYPE_RGB8, MEDIASUBTYPE_RGB565, MEDIASUBTYPE_MPEGPacket, MEDIASUBTYPE_Avi, and MEDIASUBTYPE_WAVE. TAPI: Telephony API. TAPI is a set of APIs that enable applications to make PSTN and IP phone calls. Time Stamp: Time on a media sample indicating when it was recorded and when it should be scheduled for playback. Time stamps are measured in 100-nanosecond units (REFERENCE_TIME) and are normalized so that zero indicates when the graph is run. Transform Filter: A filter that takes data, processes it, and then passes it along to the next filter in the filter graph. Transform-Inplace Filter: A transform filter that can perform its operation in place (without copying data or altering the data's media type). Transport: The mechanism that channels audio data, video data, or both from an external device to the computer and from the computer to the external device. Upstream Filter: The filter that passes data from its output pin to the connected input pin of the next filter in the filter graph. USB: Universal Serial Bus. A bi-directional, isochronous, dynamically attachable serial interface for adding peripheral devices such as game controllers, serial and parallel ports, and input devices on a single bus. USB Class: The class of filters under WDM that provides a bus interface and bus enumerator for USB. WDM: Windows Driver Model. A kernel-mode driver model based on the Windows NT 4.0 driver model that is designed to provide a common architecture of I/O services and binary-compatible device drivers for both Windows 2000 and Windows 98 operating systems for specific classes of drivers. These driver classes include USB and IEEE 1394 buses, audio, still-image capture, video capture, and HID-compliant devices such as USB mice, keyboards, and joysticks. Provides a model for writing kernel-mode drivers and minidrivers, and provides extensions for Plug and Play and power management. WDM Streaming: A WDM-based kernel-mode extension of Microsoft DirectShow, providing kernel connection and streaming services as used by the WDM Stream class driver and system software components provided in future versions of the Windows operating system, such as the cross-process audio mixer and sample rate converter. WDM streaming provides low-level services for the lowest latency streaming; DirectShow provides higher-level features. Operating system support includes a WDM Stream class driver that supports minidrivers for audio, video, and other types of stream input, output, and acceleration. Video capture overview This section provides an overview of video capture under the Windows 98 and Windows 2000 operating systems using the Video for Windows (VfW) and Windows Driver Model (WDM). VfW video capture Video for Windows (VfW) version 1.0 was released in November 1992 for the Windows 3.1 operating system and was optimized for capturing movies to disk. Despite a large number of clients for VfW, deficiencies in the VfW architecture exposed by the emergence of video conferencing and PC/TV convergence required the development of a new video-capture technology. The VfW architecture lacked features important not only to video conferencing, but also television viewing, video field capture and ancillary data streams such as the Vertical Blanking Interval (VBI). Vendors have augmented VfW by implementing proprietary extensions to circumvent these limitations; but without standardized interfaces, applications that use these proprietary features must include hardware-dependent code. VfW drivers will continue to be supported by TAPI for devices that are primarily used for capturing video because of their large installed base. However, TAPI s dependence on VfW is expected to decline since the WDM Stream class provides optimal support for capture devices used primarily for conferencing, and no future enhancements to VfW will be developed by Microsoft. WDM video capture WDM video capture was designed to resolve problems inherent in the VfW architecture. The main advantages of WDM video capture are: Provides 32-bit drivers for devices with a 32-bit architecture, such as USB and IEEE 1394 conferencing cameras.  Allows synergy with DirectShow and WDM Streaming.  Shares a single class driver architecture (Stream.sys) for hardware (such as video ports and chip sets) between video capture devices and DVD/MPEG devices.  Supports multiple streams.  Allows television tuner and input selection.  Supports field capture, field display, and VBI.  Allows video input to be managed through the video port using DirectDraw  Video Port Extensions (VPE). The WDM Stream class was created to resolve issues that arose from the integration of multiple components on a single adapter. These components include DVD decoders, MPEG decoders, video decoders, and tuners, as well as audio codecs. A unified driver model was needed that would support all these devices and handle resource contention. The WDM Stream class supports a uniform streaming model for standard and custom data types. Similarly, property sets for most standard devices are defined and can be easily extended as needed. Because the Stream class follows WDM Streaming conventions, it also supports data transfer between kernel drivers without requiring a transition to user mode, resulting in greater efficiency and reduced latency. The WDM Stream class also simplifies driver development by handling multiprocessor and reentrancy issues. Components of WDM Streaming WDM Streaming consists of several components used to implement kernel-mode streaming, including: The WDM Streaming Library, which consists of the operating system components that enable WDM to stream data. KSProxy, a DirectShow filter with COM interfaces, provides a generic method of presenting kernel streaming (KS) filters as DirectShow filters. TAPI uses a customized version of KSProxy to interact with WDM capture devices and Videoconferencing Accelerators. The next section provides an introduction to KSProxy s functionality. The WDM Stream Class driver, as described in the previous section. KSProxy KSProxy is a kernel streaming proxy module that exports COM interfaces to the standard property sets of kernel-mode components. This DirectShow filter allows a user-mode application to  drive  a kernel-mode video or audio filter to perform operations such as starting, stopping, pausing, speeding up, slowing down, amplifying, or attenuating a data stream.  KSProxy's role is to represent kernel-mode drivers. This includes any necessary marshaling of data streams between user-mode and kernel-mode. KSProxy, running in user mode, accepts existing control interfaces and translates them into IOCTL calls to the WDM Streaming drivers. The WDM Streaming library component also notifies KSProxy of events.  The TAPI MSP Video Capture filter uses a customized version of KSProxy to get access to WDM Streaming services and communicate with traditional WDM capture devices and Videoconferencing Accelerators. Streams, pins and formats The WDM Stream class video capture minidrivers can support multiple, simultaneous streams of compressed and uncompressed video, time code, closed caption, raw and decoded VBI data, and custom data formats. For each data type that can be produced simultaneously with other data types, the minidriver creates a new stream. Each stream is exposed as a separate WDM Streaming pin by the WDM Stream class. Pins should not be seen as separate objects from the driver, but rather as a convenient grouping of capabilities on the driver. A pin represents a possible connection point, and before a client can stream data to or from a driver it must first create a pin, create a pin connection, and then obtain a handle to that connection. Pin connections describe a type of connection point used for control and data flow. Pins can support a connection property set as well as other property sets. Each pin connection has a unique identifier that allows support of pin-specific properties or data formats. Each pin (or stream) can support a variety of different formats. For example, a single pin can provide RGB16, RGB24, YVU9, H.261, and H.263 digital video. TAPI local video architecture This section provides an overview of TAPI s video capture, encoding and send data path under the Windows 98 and Windows 2000 operating systems. TAPI 3.0 overview TAPI version 3.0 is a set of COM-based APIs providing convergence of both traditional telephony and IP (Internet Protocol) Telephony.  IP Telephony enables voice, data and video collaboration over existing LANs, WANs and the Internet. TAPI 3.0 implements IP Telephony on the Windows platforms by providing simple and generic methods for making connections between two or more machines. TAPI 3.0 supports standards-based H.323 conferencing and IP Multicast conferencing, utilizing the Windows 2000 Active Directory service to simplify deployment within an organization. Quality-of-service (QoS) support is included to improve conference quality and network manageability. Media stream access is provided through DirectShow filters. TAPI 3.0 PSTN and IP functionality is provided by three main sections: call and media controls, media stream controls, and directory controls. The following diagram illustrates how these controls interact with the telephone and IP networks. Call and media controls Call and media controls are a simple and generic set of methods for making calls between two or more machines. In the context of TAPI 3.0, the word call refers not just to voice transmission over the public switched telephone network (PSTN) but to any medium capable of transferring content.  TAPI 3.0 provides access to the media being transmitted through the use of DirectShow.  TAPI 3.0 abstracts both call and media functionality to allow different, and seemingly incompatible, communication protocols to expose a common interface to applications. Because TAPI 3.0 is based on the Component Object Model (COM), applications may be written in any language. Some interface methods may not be available to scripting languages such as VBScript. TAPI 3.0 call and media controls involve four primary sets of code: the TAPI 3.0 COM objects, the TAPI Server, Telephony Service Providers (TSPs), and Media Service Providers (MSPs). TAPI 3.0 COM object For background information on TAPI 3.0 COM objects, see the article titled Telephony Application Programming Interface, in the Platform SDK Documentation. TAPI server TAPI 3.0 is implemented as an in-process server and uses TAPISRV.EXE to perform telephony operations, thus making TAPI 3.0 applications compatible with all TAPI 2.1 service providers. The TAPI Server process (TAPISRV.EXE) abstracts TSPI (Telephony Service Provider Interface) from TAPI 3.0 and TAPI 2.1 and maintains the internal state of TAPI. Additional information concerning the TAPI Server and TSPI can be found in the article titled Telephony Application Programming Interface, in the Platform SDK Documentation. Call control functions Call-control functions are provided by a TSP. The TAPI 2.1 client/server relationship with remote services providers is supported. Telephony Service Providers are responsible for translating the protocol-independent call model of TAPI into protocol-specific call setup and teardown, on a service-by-service basis. TAPI 3.0 has backward compatibility with TAPI 2.1 TSPs. Two new IP Telephony Service Providers (and their associated Media Service Providers) ship by default with TAPI 3.0: the H.323 TSP and the IP Multicast Conferencing TSP.  Additional information concerning Telephony Service Providers can be found in the article titled Telephony Application Programming Interface, in the Platform SDK Documentation. Media control functions Media control functions are provided by an MSP that implements the DirectShow interfaces for a particular provider. Media Service Providers are required for any telephony service that makes use of DirectShow media streaming.  Local video filter graph The following illustrations show what DirectShow filters the TAPI MSP typically connects in a filter graph to provide the local video send functionality, and the interfaces the TAPI MSP Video Capture filter and its output pins expose to the MSP in order to provide most of the functionality described in this document. The TAPI MSP Video Capture filter interfaces are explained in section   REF _Ref429467554 \r \h  . The compressed video output pin interfaces are described in section   REF _Ref431436410 \r \h  . The preview video output pin interfaces are discussed in section   REF _Ref431548349 \r \h  . The still-image output pin interfaces are presented in section   REF _Ref432738952 \r \h  . The RTP packetization descriptor output pin interface is introduced in section   REF _Ref431548374 \r \h  We differentiate between the graphs built for VfW, WDM capture devices, and Videoconferencing Accelerators. VfW capture devices The TAPI MSP Video Capture filter talks directly to the VfW capture driver using SendDriverMessage. This filter uses the existing DShow code implemented in QCAP but adds the necessary functions to perform smart teeing of the capture data to the preview pin. It replaces the streaming-only code used by QCAP with frame grabbing code whenever necessary (cf. Section   REF _Ref444761444 \r \h  6.5.3 ). It controls the rate at which frames are being captured by adjusting the rate at which DVM_FRAME message are being sent to the driver in frame grabbing mode, or only returning a fraction of the frames being captured in streaming mode. It performs format and Vfw to ITU-T size conversions to bring the format of the captured video data to a format that can easily be used for rendering, and directly encoded by the downstream TAPI MSP Video Encoder filter if an installable codecs is registered with the TAPI MSP. If there is no installable codec registered, the TAPI MSP Video Capture filter also performs H.26x encoding, generating a compressed video capture output stream in H.26x format, as well as an RTP packetization descriptor output data stream. Finally, the TAPI MSP Video Capture filter does all the necessary sequencing to pause the existing video streams whenever it is being asked to generate still-image data, grab a high-resolution snapshot, deliver it in progressively rendered form, and restart the video streams. Default implementation In the default case, the TAPI MSP Video Capture filter wraps the following functions: The TAPI MSP Video Capture filter then exposes the following interfaces, and is connected in the following graph: Note that this graph is, by design, identical to the graph built for WDM devices or Videoconferencing Accelerators as illustrated in sections   REF _Ref444760645 \r \h  4.3.2.1  and   REF _Ref444760649 \r \h  4.3.3 Support for installable codec If the MSP is loading an installable codec, the TAPI MSP Video Capture filter only wraps the following functions: The TAPI MSP Video Capture filter then exposes the following interfaces, and is connected in the following graph: Note that this graph is, by design, identical to the graph built for WDM devices as illustrated in section   REF _Ref444760744 \r \h  4.3.2.2 WDM capture devices The TAPI MSP Video Capture filter talks directly to the WDM capture driver using IOCTLs. This filter uses the existing code implemented in KSProxy but adds the necessary functions to perform smart teeing of the capture data to the preview pin, if necessary. It controls the rate at which frames are being captured by adjusting the rate at which buffers are being submitted to the driver in frame grabbing mode, or only returning a fraction of the frames being captured in streaming mode using overlapped IOs. It performs format and Vfw to ITU-T size conversions to bring the format of the captured video data to a format that can easily be used for rendering, and directly encoded by the downstream TAPI MSP Video Encoder filter if an installable codecs is registered with the TAPI MSP. If there is no installable codec registered, the TAPI MSP Video Capture filter also performs H.26x encoding, generating a compressed video capture output stream in H.26x format, as well as an RTP packetization descriptor output data stream. Finally, the TAPI MSP Video Capture filter does all the necessary sequencing to pause the existing video streams whenever it is being asked to generate still-image data, grab a high-resolution snapshot, deliver it in progressively rendered form, and restart the video streams. Default implementation In the default case, the TAPI MSP Video Capture filter wraps the following functions: Note that some WDM Video Capture device may not expose a preview pin. In this case, the TAPI MSP Video Capture filter tees the capture data onto the preview pin, as in the VfW capture driver model. The TAPI MSP Video Capture filter exposes the following interfaces, and is connected in the following graph: Note that this graph is, by design, identical to the graph built for VfW devices or Videoconferencing Accelerators as illustrated in sections   REF _Ref444760945 \r \h  4.3.1.1  and   REF _Ref444760649 \r \h  4.3.3 Support for installable codec If the MSP is loading an installable codec, the TAPI MSP Video Capture filter only wraps the following functions: Note that some WDM Video Capture device may not expose a preview pin. In this case, the TAPI MSP Video Capture filter tees the capture data onto the preview pin, as in the VfW capture driver model. The TAPI MSP Video Capture filter then exposes the following interfaces, and is connected in the following graph: Note that this graph is, by design, identical to the graph built for VfW devices as illustrated in section   REF _Ref444761018 \r \h  4.3.1.2 Videoconferencing Accelerators Videoconferencing Accelerators perform all the necessary functions. The TAPI MSP Video Capture filter simply wraps around their WDM driver and is only used to propagate calls to the TAPI interfaces to the Videoconferencing Accelerator minidriver, through the Stream Class driver, using IOCTLs. The TAPI MSP Video Capture filter then exposes the following interfaces, and is connected in the following graph: Note that this graph is, by design, identical to the graph built for VfW devices or WDM devices as illustrated in sections   REF _Ref444760945 \r \h  4.3.1.1  and   REF _Ref444761232 \r \h  4.3.2.1 TAPI MSP video capture filter and WDM video capture The following illustration shows how the TAPI MSP Video Capture filter and the system components interface with WDM capture devices and Videoconferencing Accelerators: The TAPI MSP Video Capture filter combines the relevant KSXBar and KSProxy code and adds all the necessary functions defined in the previous sections. The DirectShow IAMCrossbar, IAMVideoProcAmp, IAMCameraControl and IAMVideoControl are already implemented by system interface handlers. Other interfaces that are specific to TAPI such as IH245EncoderCommand, INetworkStats, IFrameRateControl, IBitrateControl, ICPUControl, IProgressiveRefinement and IRTPPDControl are implemented by the TAPI MSP Video Capture filter using a new interface handler. This interface handler implements the new TAPI interfaces using the generic IKsControl interface already developed for KSProxy. TAPI MSP video capture filter and VfW video capture The following illustration shows how the TAPI MSP Video Capture filter and the system components interface with VfW capture devices on Win9x: On Windows NT, the video capture components interface differently: The TAPI MSP Video Capture filter uses the relevant QCAP code and adds all the necessary functions defined in the previous sections. The DirectShow IAMVfwCaptureDialogs, interface is implemented by the TAPI MSP Video Capture filter using SendDriverMessage. The DirectShow IAMVideoProcAmp, IAMCameraControl and IAMVideoControl are implemented by the H.26x encoding function. Other interfaces that are specific to TAPI such as IH245EncoderCommand, INetworkStats, IFrameRateControl, IBitrateControl, ICPUControl, IProgressiveRefinement and IRTPPDControl are also implemented by the H.26x encoding function. The DCAP??.DLL were developed for NetMeeting and expose a simple API that wraps around a few SendDriverMessage calls. Video capture filter streams Fundamentally, video streams are composed of time-stamped, digitized video and related information such as VBI and time code. Streams can be paused, started, and stopped independently. Stream samples are time stamped with a 100ns-resolution clock. The TAPI MSP Video Capture filter can generate five different types of streams: a video preview stream, a video port video preview stream, a video capture stream, a still-image stream, and an RTP packetization descriptor stream. Output streams Traditionally, DirectShow streams have been identified solely by their MediaTypes. While this is sufficient for rendering simple filter graphs, more complex graphs and graphs that reflect a hardware topology require additional information for correct graph building. Each TAPI MSP Video Capture filter output pin is assigned to a pin Category, which is a GUID that identifies the primary purpose of the pin, as detailed in the following list: PINNAME_VIDEO_CAPTURE  Primary video stream, used to get data in YUV or H.26x compressed form.  PINNAME_VIDEO_PREVIEW  Secondary video stream, usually in a non-compressed format that is easily displayed without requiring a separate decompression step.  PINNAME_VIDEO_VIDEOPORT  Secondary video stream, used to preview video by streaming video data in kernel mode to the video board through the video port and be rendered using overlay.  PINNAME_VIDEO_STILL  Still image stream used to get data in YUV or H.26x compressed form to be progressively rendered by the remote endpoint.  PINNAME_RTP_PD  Stream synchronized to the primary capture stream, generating RTP packetization descriptors.  The Capture, Preview, and Still stream Categories are almost identical in terms of data formats and stream characteristics. A Capture output pin provides a stream of compressed or uncompressed digital video. A Preview output pin provides a stream of usually uncompressed digital video. If only a Capture stream is available from the capture device, the TAPI MSP Video Capture filter tees it off to create a Preview stream. Still Category output pins are optional and used with dual-mode cameras that are capable of producing both a capture stream and a still image stream that is often of higher quality than the capture stream. The still image stream includes the ability to externally or internally trigger acquisition of an image from a WDM capture device. If a VP video Preview stream is provided by a Videoconferencing Accelerator, the TAPI MSP Video Capture filter will not try and instantiate a Preview pin of the PINNAME_VIDEO_PREVIEW Category, but instead use the pin of the PINNAME_VIDEO_VIDEOPORT Category.  The video data gathered on the Capture stream is fragmented into RTP packets to be sent over the network. An RTP Packetization Descriptor stream of the PINNAME_RTP_PD Category is used to generate RTP packetization descriptors to be used synchronously with an H.26x compressed video or still-image capture stream and facilitate RTP fragmentation. The packetization descriptors contain payload header data to be inserted in front of the fragmented payload data by the RTP send network layer. They also describe at what points in the compressed data the packets start and end. Each of the samples of the RTP packetization descriptors stream is synchronized to a unique sample of the capture stream. Nonetheless, the RTP packetization descriptors may be used to describe multi-layer encoded data. Input streams Analog video capture devices expose a single input stream representing the analog video input to the digitizer. If a device supports multiple inputs, it must create a separate crossbar driver to choose between the analog inputs. Digital capture devices such as USB and IEEE 1394 cameras do not expose an analog stream. If a crossbar interface is available, the TAPI MSP queries it for a list of supported inputs and expose this list to the users for selection. Video capture filter stream formats Stream types are described in DirectShow using the AM_MEDIA_TYPE structure. This structure includes GUID fields for majortype, subtype and formattype as well as fields specifying other sample features. It is defined as follows: typedef struct  _MediaType     GUID      majortype;     GUID      subtype;     BOOL      bFixedSizeSamples;     BOOL      bTemporalCompression;     ULONG     lSampleSize;     GUID      formattype;     IUnknown  *pUnk;     ULONG     cbFormat;     /* [size_is] */ BYTE __RPC_FAR *pbFormat; } AM_MEDIA_TYPE; The following describes the AM_MEDIA_TYPE members. majortype  Specifies the major type of the stream.  subtype  Specifies the subtype of the stream.  bFixedSizeSamples  Specifies that all the samples are the same size if set to TRUE. bTemporalCompression  Specifies that each sample is a synchronization point (keyframe) if set to FALSE. lSampleSize  Specifies the maximum size of the samples in bytes.  formattype  Specifies the format type of the stream.  pUnk  Specifies a pointer to the IUnknown interface. cbFormat  Specifies the size of the format section of the media type.  pbFormat  Specifies a pointer to the format section of the media type. For all the digital video and still-image streams generated by the TAPI MSP Video Capture filter, the majortype type is MEDIATYPE_Video, and the formattype is set to FORMAT_VideoInfo. The subtype, along with the Format block, is used to convey details of the particular video data type.  The low-order four bytes of the subtype shall match the FourCC values used in the BITMAPINFOHEADER.biCompression field of the VIDEOINFOHEADER structure pointed to by the pbFormat field. For example, the following GUID identifies the FourCC (M263) for the H.263 video format: 3336324D-0000-0010-8000-00AA00389B71       4D = 'M'     32 = '2'   36 = '6' 33 = '3' Media types for video preview streams s a list of common video RGB formats (and their associated subtype) that do not require insertion of a decoder filter between the TAPI MSP Video Capture filter preview output pin and the downstream DirectShow Video Renderer Sink filter input pin: Video Format RGB 4 E436EB79-524F-11CE-9F53-0020AF0BA770 RGB 8 E436EB7A-524F-11CE-9F53-0020AF0BA770 RGB 565 E436EB7B-524F-11CE-9F53-0020AF0BA770 RGB 555 E436EB7C-524F-11CE-9F53-0020AF0BA770 RGB24 E436EB7D-524F-11CE-9F53-0020AF0BA770 By design, VfW capture devices do not have a digital preview stream (ignoring support for analog overlay). The TAPI MSP Video Capture filter for VfW capture devices simply tees the video frames generated on the video capture output pin to the video preview output pin using a smart-tee mechanism. It also converts the data to one of the RGB formats above using its own color conversion if the format of the data is a YUV format it knows about, or loads an ICM codec in order to perform the necessary conversion. WDM capture devices and Videoconferencing Accelerators typically have a video preview pin. If they don t, the TAPI MSP Video Capture filter applies the same tee operation than in the VfW case. If also converts the data before delivering it to the downstream DirectShow Video Renderer Sink filter, if it is not in RGB format, using the same mechanism described in the previous paragraph. Media types for capture and still-image streams s a list of common video YUV formats (and their associated subtype) currently supported by the TAPI MSP Video Encoder filter that do not require insertion of a decoder filter between the TAPI MSP Video Capture filter and TAPI MSP Video Encoder filter: Video Format FourCC 39555659-0000-0010-8000-00AA00389B71 32595559-0000-0010-8000-00AA00389B71 59565955-0000-0010-8000-00AA00389B71 30323449-0000-0010-8000-00AA00389B71 56555949-0000-0010-8000-00AA00389B71 If the format of the video capture output pin does not belong to this list, the TAPI MSP Video Capture filter loads an ICM codec in order to convert the video capture data to RGB. Media type for H.26x compressed video and still-image streams s a complete list of ITU formats currently supported by TAPI and their associated subtype: Video Format FourCC ITU H.263 version 1 3336324D-0000-0010-8000-00AA00389B71 ITU H.263 version 2 3336324E-0000-0010-8000-00AA00389B71 ITU H.261 3136324D-0000-0010-8000-00AA00389B71 For all H.26x compressed video and still-image streams generated by the TAPI MSP Video Capture filter, the majortype type is MEDIATYPE_Video, the formattype is set to FORMAT_VideoInfo, and the bFixedSizeSamples and bTemporalCompression fields are respectively set to FALSE and TRUE. The subtype, along with the Format block, is used to convey details of the particular video data type, as detailed next. Video info header structure for H.263 video streams TAPI defines the VIDEOINFOHEADER_H263 structure to specify details of the video stream. The pbFormat field of the AM_MEDIA_TYPE structure shall point to a structure of the VIDEOINFOHEADER_H263 type, instead of a regular VIDEOINFOHEADER structure, when describing H.263 video streams. Note that it is similar to the VIDEOINFOHEADER structure: typedef struct tagVIDEOINFOHEADER_H263 {    RECT                   rcSource;    RECT                   rcTarget;    DWORD                  dwBitRate;    DWORD                  dwBitErrorRate;    REFERENCE_TIME         AvgTimePerFrame;    BITMAPINFOHEADER_H263  bmiHeader; } VIDEOINFOHEADER_H263, *PVIDEOINFOHEADER_H263; where rcSource  Specifies a RECT structure that defines the source video window.  rcTarget  Specifies a RECT structure that defines the destination video window.  dwBitRate  Specifies a DWORD value that indicates the video stream's approximate data rate, in bits per second.  dwBitErrorRate  Specifies a DWORD value that indicates the video stream's data error rate, in bit errors per second.  AvgTimePerFrame  Specifies a REFERENCE TIME value that indicates the video frame's average display time, in 100-nanosecond units.  bmiHeader  Specifies a BITMAPINFOHEADER_H263 structure that contains detailed format information for the H.263 video data.  Video info header structure for H.261 video streams TAPI also defines the VIDEOINFOHEADER_H261 structure to specify details of an H.261 video stream. The pbFormat field of the AM_MEDIA_TYPE structure shall point to a structure of the VIDEOINFOHEADER_H261 type, instead of a regular VIDEOINFOHEADER structure, when describing H.261 video streams. Note that it is similar to the VIDEOINFOHEADER structure: typedef struct tagVIDEOINFOHEADER_H261 {    RECT                   rcSource;    RECT                   rcTarget;    DWORD                  dwBitRate;    DWORD                  dwBitErrorRate;    REFERENCE_TIME         AvgTimePerFrame;    BITMAPINFOHEADER_H261  bmiHeader; } VIDEOINFOHEADER_H261, *PVIDEOINFOHEADER_H261; where rcSource  Specifies a RECT structure that defines the source video window.  rcTarget  Specifies a RECT structure that defines the destination video window.  dwBitRate  Specifies a DWORD value that indicates the video stream's approximate data rate, in bits per second.  dwBitErrorRate  Specifies a DWORD value that indicates the video stream's data error rate, in bit errors per second.  AvgTimePerFrame  Specifies a REFERENCE TIME value that indicates the video frame's average display time, in 100-nanosecond units.  bmiHeader  Specifies a BITMAPINFOHEADER_H261 structure that contains detailed format information for the H.261 video data.  Bitmap info header structure for H.263 video streams The H.263 specification allows for many compression options. The TAPI MSP Video Capture filter is left responsible to chose what options to implement. On the other hand, when TAPI sets a specific video format on the compressed video output pin, it effectively indicates what options the receiver specified it supported by setting the H.263 specific fields of the extended bitmap info header defined below: typedef struct tagBITMAPINFOHEADER_H263 {     // Generic bitmap info header fields     BITMAPINFOHEADER   bmi;     // H.263 specific fields     DWORD dwMaxBitrate;     DWORD dwBppMaxKb;     DWORD dwHRD_B;     // Options     DWORD fUnrestrictedVector:1;     DWORD fArithmeticCoding:1;     DWORD fAdvancedPrediction:1;     DWORD fPBFrames:1;     DWORD fErrorCompensation:1;     DWORD fAdvancedIntraCoding:1;     DWORD fDeblockingFilter:1;     DWORD fImprovedPBFrames:1;     DWORD fUnlimitedMotionVectors:1;     DWORD fFullPictureFreeze:1;     DWORD fPartialPictureFreezeAndRelease:1;     DWORD fResizingPartPicFreezeAndRelease:1;     DWORD fFullPictureSnapshot:1;     DWORD fPartialPictureSnapshot:1;     DWORD fVideoSegmentTagging:1;     DWORD fProgressiveRefinement:1;     DWORD fDynamicPictureResizingByFour:1;     DWORD fDynamicPictureResizingSixteenthPel:1;     DWORD fDynamicWarpingHalfPel:1;     DWORD fDynamicWarpingSixteenthPel:1;     DWORD fIndependentSegmentDecoding:1;     DWORD fSlicesInOrder_NonRect:1;     DWORD fSlicesInOrder_Rect:1;     DWORD fSlicesNoOrder_NonRect:1;     DWORD fSlicesNoOrder_Rect:1;     DWORD fAlternateInterVLC:1;     DWORD fModifiedQuantization:1;     DWORD fReducedResolutionUpdate:1;     DWORD fReserved:4;     // Reserved     DWORD dwReserved[4]; } BITMAPINFOHEADER_H263, *PBITMAPINFOHEADER_H263; The BITMAPINFOHEADER is the well known GDI bitmap info header structure. It contains information on the video format such as actual image dimensions and the pixel depth. The following list describes the H.263 specific members of BITMAPINFOHEADER_H263: dwMaxBitrate  Specifies the maximum bit rate in units of 100 bits/s at which the receiver can receive video. This value is valid between 1 and 192400.  dwBppMaxKb  Specifies the maximum number of bits for one coded picture that the receiver can receive and decode correctly, and is measured in units of 1024 bits. This value is valid between 0 and 65535.  dwHRD_B  Specifies the Hypothetical Reference Decoder parameter B as described in Annex B of H.263. This value is valid between 0 and 524287.  fUnrestrictedVector  Specifies that the receiver can receive video data using the unrestricted motion vectors mode as defined in Annex D of H.263.  fArithmeticCoding  Specifies that the receiver can receive video data using the syntax based arithmetic coding mode as defined in Annex E of H.263.  fAdvancedPrediction  Specifies that the receiver can receive video data using the advanced prediction mode as defined in Annex F of H.263.  fPBFrames  Specifies that the receiver can receive video data using the PB-frames mode as defined in Annex G of H.263.  fErrorCompensation  Specifies that the receiver can identify MBs received with transmission errors, treat them as not coded, and send appropriate videoNotDecodedMBs indications.  fAdvancedIntraCoding  Specifies that the receiver can receive video data using the advanced INTRA coding mode as defined in Annex I of H.263.  fDeblockingFilter  Specifies that the receiver can receive video data using the deblocking filter mode as defined in Annex J of H.263.  fImprovedPBFrames  Specifies that the receiver can receive video data using the improved PB-frames mode as defined in Annex M of H.263.  fUnlimitedMotionVectors  Specifies that the receiver can receive video data using the unrestricted motion vector range when unrestricted motion vector mode as defined in Annex D of H.263 is also indicated.  fFullPictureFreeze Specifies that the receiver can receive Full Picture Freeze commands as described in Annex L of H.263.  fPartialPictureFreezeAndRelease Specifies that the receiver can receive Full Picture Freeze and Release commands as described in Annex L of H.263.  fResizingPartPicFreezeAndRelease Specifies that the receiver can receive the Resizing Partial Picture Freeze and Release commands as described in Annex L of H.263.  fFullPictureSnapshot Specifies that the receiver can receive Full Picture snapshots of the video content as described in Annex L of H.263.  fPartialPictureSnapshot Specifies that the receiver can receive Partial Picture Snapshots of the video content as described in Annex L of H.263.  fVideoSegmentTagging Specifies that the receiver can receive Video Segment tagging for the video content as described in Annex L of H.263.  fProgressiveRefinement Specifies that the receiver can receive Progressive Refinement tagging as described in Annex L of H.263. In addition, when true, the encoder shall respond to the progressive refinement miscellaneous commands doOneProgression, doContinuousProgressions, doOneIndependentProgression, doContinuousIndependentProgressions, progressiveRefinementAbortOne, and progressiveRefinementAbortContinuous. In addition, the encoder shall insert the Progressive Refinement Segment Start Tags and the Progressive Refinement Segment End Tags as defined in the Supplemental Enhancement Information Specification (Annex L) of Recommendation H.263. Note, Progressive Refinement tagging can be sent by an encoder and received by a decoder even when not commanded in a miscellaneous command.  fDynamicPictureResizingByFour Specifies that the receiver supports the picture resizing-by-four (with clipping) submode of the implicit Reference Picture Resampling Mode (Annex P) of H.263.  fDynamicPictureResizingSixteenthPel Specifies that the receiver supports resizing a reference picture to any width and height using the implicit Reference Picture Resampling mode (Annex P) of H.263 (with clipping). If DynamicPictureResizingSixteenthPel is true then DynamicPictureResizingByFour shall be true fDynamicWarpingHalfPel Specifies that the receiver supports the arbitrary picture warping operation within the Reference Picture Resampling mode (Annex P) of H.263 (with any fill mode) using half-pixel accuracy warping.  fDynamicWarpingSixteenthPel Specifies that the receiver supports the arbitrary picture warping operation within the Reference Picture Resampling mode (Annex P) of H.263 (with any fill mode) using either half-pixel or sixteenth pixel accuracy warping. fIndependentSegmentDecoding Specifies that the receiver supports the Independent Segment Decoding Mode (H.263 Annex R) of H.263.  fSlicesInOrder_NonRect Specifies that the receiver supports the submode of Slice Structured Mode (H.263 Annex K) where slices are transmitted in order and contain macroblocks in scanning order of the picture.  fSlicesInOrder_Rect Specifies that the receiver supports the submode of Slice Structured Mode (H.263 Annex K) where slices are transmitted in order and the slice occupies a rectangular region of the picture.  fSlicesNoOrder_NonRect Specifies that the receiver supports the submode of Slice Structured Mode (H.263 Annex K) where slices contain macroblocks in scanning order of the picture and need not be transmitted in order.  fSlicesNoOrder_Rect Specifies that the receiver supports the submode of Slice Structured Mode (H.263 Annex K) where slices occupy a rectangular region of the picture and need not be transmitted in order.  fAlternateInterVLC  Specifies that the receiver can receive video data using the alternate inter VLC mode as defined in Annex S of H.263.  fModifiedQuantization  Specifies that the receiver can receive video data using the modified quantization mode as defined in Annex T of H.263.  fReducedResolutionUpdate  Specifies that the receiver can receive video data using the reduced resolution update mode as defined in Annex Q of H.263.  fReserved  Reserved. Shall be set to NULL.  dwReserved[4]  Reserved. Shall all be set to NULL.  Again, when one of the H.263 specific fields is set to TRUE (1), this does not mean that the compressed video output pin should generate data using that optional mode. Instead, TAPI is merely indicating that the option is supported by the receiver. Alternatively, when the TAPI MSP requests from the TAPI MSP Video Capture filter a list of supported formats, the Boolean flags shall be set to TRUE for all the optional modes the compressed video output pin supports. The dwMaxBitrate field shall be set to the maximum bitrate in units of 100 bits/s at which the compressed video output pin can generate video data. Finally, the dwBppMaxKb field shall be set to the maximum number of bits for one coded picture that the compressed video output pin can generate in units of 1024 bits. This number shall be equivalent to the biSizeImage field of the bmi (bitmap info header) structure. Bitmap info header structure for H.261 video streams The TAPI MSP applies the following H.261 video format structure on the compressed video output pin to indicate what maximum video bitrate the receiver can receive, and if it is capable of receiving still images as defined in Annex D of H.261: typedef struct tagBITMAPINFOHEADER_H261 {     // Generic bitmap info header fields     BITMAPINFOHEADER   bmi;     // H.261 specific fields     DWORD dwMaxBitrate;     BOOL fStillImageTransmission;     // Reserved     DWORD dwReserved[4]; } BITMAPINFOHEADER_H261, *PBITMAPINFOHEADER_H261; The BITMAPINFOHEADER is the well-known GDI bitmap info header structure. It contains information on the video stream such as actual image dimensions and the pixel depth. The following list describes the H.261 specific members of BITMAPINFOHEADER_H261: dwMaxBitrate  Specifies the maximum bit rate in units of 100 bits/s at which the receiver can receive video. This value is only valid between 1 and 19200.   fStillImageTransmission  Specifies that the receiver can receive still images as defined in Annex D of H.261.  dwReserved[4]  Reserved. Shall all be set to NULL.  If the fStillImageTransmission H.261 specific field is set to TRUE (1) when setting a format on the compressed video output pin, this does not mean that it should generate data using that optional mode. Instead, the TAPI MSP is merely indicating that the option is supported by the receiver. Alternatively, when the TAPI MSP requests from the compressed video output pin a list of supported formats, the fStillImageTransmission field shall be set to TRUE if the pin is capable of generating still images as described in Annex D of H.261. The dwMaxBitrate field shall be set to the maximum bitrate in units of 100 bits/s at which the compressed output pin can generate video data. Media type for RTP packetization descriptor streams For RTP packetization descriptor streams, the majortype type is MEDIATYPE_RTP_PD, the formattype is set to FORMAT_None, and the subtype is initialized to MEDIASUBTYPE_None. Only the Format block is used to convey details of the particular RTP packetization descriptor type.  The following table shows the actual GUID values for type fields of the AM_MEDIA_TYPE structure used to describe RTP packetization descriptor streams: MEDIATYPE_RTP_PD 64707472-5245-4945-5252-45464C494850 FORMAT_None 0F6417D6-C318-11D0-A43F-00A0C9223196 MEDIASUBTYPE_None E436EB8E-524F-11CE-9F53-0020AF0BA770 The bFixedSizeSamples and bTemporalCompression fields are both set to FALSE. Configuration capabilities structure for RTP packetization descriptor streams In order to allow the TAPI MSP to use the IAMStreamConfig::GetStreamCaps method to get information on the minimum and maximum RTP packet size the RTP packetization descriptor output pin can generate, the RTP_PD_CONFIG_CAPS structure is defined as follows: typedef struct tagRTP_PD_CONFIG_CAPS  {     DWORD dwSmallestRTPPacketSize;     DWORD dwLargestRTPPacketSize;     DWORD dwRTPPacketSizeGranularity;     DWORD dwSmallestNumLayers;     DWORD dwLargestNumLayers;     DWORD dwNumLayersGranularity;     DWORD dwNumStaticPayloadTypes;     DWORD dwStaticPayloadTypes[4];     DWORD dwNumDescriptorVersions;     DWORD dwDescriptorVersions[4];     DWORD dwReserved[4]; } RTP_PD_CONFIG_CAPS; where dwSmallestRTPPacketSize  Specifies the size in bytes of the smallest RTP packet the stream can describe.  dwLargestRTPPacketSize Specifies the size in bytes of the largest packet the stream can describe.  dwRTPPacketSizeGranularity  Specifies the granularity of the increments between the smallest and largest packet size the stream supports.  dwSmallestNumLayers  Specifies the smallest number of encoding layers the stream can describe.  dwLargestNumLayers  Specifies the largest number of encoding layers the stream can describe.  dwNumLayersGranularity  Specifies the granularity of the increments between the smallest and largest number of encoding layers the stream supports.  dwNumStaticPayloadTypes Specifies the number of static payload types the stream supports. This value is valid between 0 and 4.  dwStaticPayloadTypes[4]  Specifies an array of static payload types the stream supports. A stream can support at most 4 static payload types. The number of valid entries in this array is indicated by the dwNumStaticPayloadTypes field.  dwNumDescriptorVersions  Specifies the number of packetization descriptor versions the stream supports. This value is valid between 1 and 4.  dwDescriptorVersions[4]  Specifies an array of version identifiers qualifying the format of packetization descriptors. A stream can support at most 4 packetization descriptor versions. The number of valid entries in this array is indicated by the dwNumDescriptorVersions field.  dwReserved[4]  Reserved. Shall all be set to NULL.  Information header structure for RTP packetization descriptor streams Finally, the details of the format are specified using the RTP_PD_INFO structure defined as: typedef struct tagRTP_PD_INFO {     REFERENCE_TIME AvgTimePerSample;     DWORD dwMaxRTPPacketizationDescriptorBufferSize;     DWORD dwMaxRTPPayloadHeaderSize;     DWORD dwMaxRTPPacketSize;     DWORD dwNumLayers;     DWORD dwPayloadType;     DWORD dwDescriptorVersion;     DWORD dwReserved[4]; } RTP_PD_INFO, *PRTP_PD_INFO; where AvgTimePerSample  Specifies the average time per list of RTP packet descriptor, in 100ns units. This value shall be identical to the value of the AvgTimePerFrame field of the video info header of the related compressed video stream format dwMaxRTPPacketizationDescriptorBufferSize  Specifies the maximum size in bytes of the entire RTP packetization descriptor buffer. The format of this buffer is described in the following section. The maximum size of the entire RTP packetization descriptor buffer rarely needs to exceed a few hundred bytes. dwMaxRTPPayloadHeaderSize  Specifies the maximum size in bytes of the payload header data for one RTP packet. For example, the maximum size of a payload header for H.263 version 1 is 12 bytes (Mode C header). dwMaxRTPPacketSize  Specifies the maximum RTP packet size in bytes to be described by the list of packetization descriptor. Typically, this number is just below the MTU size of the network.  dwNumLayers  Specifies the number of encoding layers to be described by the list of packetization descriptor. Typically, this number is equal to 1. Only in the case of multi-layered encoders would this number be higher than 1.  dwPayloadType Specifies the static payload type the stream describes. If the RTP packetization descriptors do not apply to an existing static payload type but a dynamic payload type, this field shall be set to DYNAMIC_PAYLOAD_TYPE (defined as MAXDWORD).  dwDescriptorVersion  Specifies a version identifier qualifying the format of packetization descriptors. This field shall be set to VERSION_1 (defined as 1UL) to identify the packetization descriptor structures described in the next section.  dwReserved[4]  Reserved. Shall all be set to NULL.  Again, this structure is pointed to by the pbFormat field of the AM_MEDIA_TYPE structure used to describe the RTP packetization descriptor stream. RTP packetization descriptor format The format of the RTP packetization descriptors begins with a single header structure, RTP_PD_HEADER, defined as follows: typedef struct tagRTP_PD_HEADER {     DWORD dwThisHeaderLength;     DWORD dwTotalByteLength;     DWORD dwNumHeaders;     DWORD dwReserved; } RTP_PD_HEADER, *PRTP_PD_HEADER; where dwThisHeaderLength  Specifies the length, in bytes, of this structure. This field is the offset to the first RTP_PD structure.  dwTotalByteLength  Specifies the length, in bytes, of the entire data. This includes this structure, the RTP_PD structures, and the payload information.  dwNumHeaders  Specifies the number of RTP_PD structures.  dwReserved  Reserved. Shall be set to NULL.  This structure is followed by RTP_PD_HEADER.dwNumHeaders structures of type RTP_PD. Those structures are defined as follows: typedef struct tagRTP_PD {     DWORD dwThisHeaderLength;     DWORD dwPayloadHeaderOffset;     DWORD dwPayloadHeaderLength;     DWORD dwPayloadStartBitOffset;     DWORD dwPayloadEndBitOffset;     BOOL  fEndMarkerBit;     DWORD dwLayerId;     DWORD dwTimestamp;     union {     DWORD dwAudioAttributes;     DWORD dwVideoAttributes;     };     DWORD dwReserved; } RTP_PD, *PRTP_PD; where dwThisHeaderLength  Specifies the length, in bytes, of this structure. This field is the offset to the next RTP_PD structure, if there is one, or the start of the payload headers.  dwPayloadHeaderOffset  Specifies the offset from the start of the RTP packetization descriptor data to the first byte of the payload header.  dwPayloadHeaderLength  Specifies the length, in bytes, of the payload header.  dwPayloadStartBitOffset  Specifies the offset from the start of the corresponding compressed video buffer to the first bit of the payload data associated with this RTP_PD structure.  dwPayloadEndBitOffset  Specifies the offset from the start of the corresponding compressed video buffer to the last bit of the payload data associated with this RTP_PD structure.  fEndMarkerBit  If set to TRUE, this flag signals that this structure applies to the last chunk of a video frame. Typically, only the last packet descriptor in a series of descriptors would have this flag turned on. However, this may not be the case for video encoder filters that do not respect frame boundaries and fill buffers with truncated or multiple video frames. dwLayerId  Specifies the ID of the encoding layer this descriptor applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc. dwTimestamp Specifies the value of the RTP timestamp field to be set by the downstream filter when creating the RTP header for this packet. The units and ranges for this field shall adhere to the definition of timestamp given in section 5.1 of RFC 1889.  dwAudioAttributes Specifies some bitfield attributes used to characterize the sample in the audio stream associated to this RTP packetization descriptor. This field shall always be set to 0UL, unless the audio sample described by this RTP packetization descriptor structure is a silent frame, in which case, this field shall be set to AUDIO_SILENT (defined as 1UL). dwVideoAttributes Specifies some bitfield attributes used to characterize the sample in the video stream associated to this RTP packetization descriptor. There are no video attributes defined at this time. Therefore, this field shall always be set to 0UL. dwReserved  Reserved. Shall be set to NULL. The payload header data does not need to start right after the end of the last of the RTP_PD structures. The downstream filter will use the dwPayloadHeaderOffset field of each of the RTP_PD structures to jump to the appropriate memory location in the RTP packetization descriptor buffer, as the example below shows. This illustrates packetization of the first I-frame of an H.263 video stream in three fragments using a mode A header (4 bytes long) for each fragment: RTP packetization descriptor and video streams synchronization The TAPI MSP will always try to connect the compressed video output pin first. If this operation fails, there will be no attempt to connect an RTP packetization descriptor output pin to an input pin of the downstream filter. Once the compressed video output pin has been connected, the TAPI MSP will try to connect the RTP packetization descriptor pin. Synchronization of the RTP packetization descriptors and video streams is achieved by generating identical presentation timestamps for a compressed video sample and the corresponding RTP packetization descriptor sample. The downstream filter will look at those timestamps to establish how samples should be matched between the two streaming output pins. These timestamps should not be confused with the timestamp field of the RTP header that the network send downstream filter generates using other means. Whenever the TAPI MSP decides to pause or stop the stream compressed video output pin, the TAPI MSP Video Capture filter does not bother returning data on the associated RTP packetization descriptor output pin. Media type enumeration Complete media type enumeration is necessary to allow the downstream TAPI MSP Video Encoder filter to build H.245 video capabilities based on the list of formats supported by the capture device for installable codecs, and to allow to let the TAPI MSP Video Capture filter build those same capabilities when using its own H.26x encoders. Unfortunately, there is no programmatic way to enumerate the formats supported by VfW capture devices. The TAPI MSP Video Capture filter maintains a database of VfW capture devices and their supported media types, based on the friendly name of the capture device driver, the version number of this driver, and the date of the driver file. We differentiate between the media type enumeration process for a capture device that the TAPI MSP Video Capture filter has already used in the past or not. Even though WDM capture devices and Videoconferencing Accelerators do support enumeration of their capabilities using datarange structures, we still add them to the database maintained by the TAPI MSP Video Capture filter in order to tune some of those capabilities based on the results of our in-house testing. First time use If there is no entry for the VfW capture device in the list maintained by the TAPI MSP Video Capture filter, the TAPI MSP Video Capture filter will first query the capture device for its current video capture format, and save this information in case the following steps result in a crash. Then, the TAPI MSP Video Capture filter applies a set of preferred formats on the capture device using SendDriverMessage with the DVM_FORMAT message. For each applied format, the TAPI MSP Video Capture filter will not only verify the return code of the SendDriverMessage, but also query back the current format to make sure the set format operation really succeeded. If the capture device fails one of the two previous steps, the TAPI MSP Video Capture filter will assume that the format is not supported. Once the TAPI MSP Video Capture filter is done with the entire list of preferred formats and no crash occurred, the list of video formats supported by the capture device is added to the list maintained by the TAPI MSP Video Capture filter. As soon as the enumeration process succeeds for one  small  (128x96 or 160x120), one  medium  (176x144 or 160x120), one  large  (352x288 or 320x240) and one  very large  size (704x576 or 640x480), the TAPI MSP Video Capture filter stops the enumeration process and adds the resulting list of formats to its database. The TAPI MSP Video Capture filter will test the previous sizes for I420, IYUV, YUY2, UYVY, YVU9, RGB16, RGB24, RGB8, and RGB4 formats, in this described order. Similarly, if there is no entry for the WDM capture device or Videoconferencing Accelerator in the list maintained by the TAPI MSP Video Capture filter, the TAPI MSP Video Capture filter queries the capture device for a list of datarange structures, and save this information in its database. The device will also be marked as a frame-grabbing device in the TAPI MSP Video Capture filter device database. Known capture device If there is an entry for the VfW capture device in the list maintained by the TAPI MSP Video Capture filter, the TAPI MSP Video Capture filter first verifies if the information contained is a complete list of supported formats, or only a default format. The entry will only contain a default format if the capture device did not support any of the preferred formats, or a crash occurred during the enumeration process. If there is only a default format stored for the VfW capture device, the TAPI MSP Video Capture filter will build a list of media types that can be built from the default format using black-banding and/or cropping. If the default format is in a compressed format, the TAPI MSP Video Capture filter will try and locate and ICM driver that can do the decompression from the compressed format to RGB. If the device supports a list of formats from the preferred list of formats, the TAPI MSP Video Capture filter will use this list to advertise the capabilities of the capture device. In all cases (VfW and WDM capture devices, Videoconferencing Accelerators), the TAPI MSP Video Capture filter won t query the device for capabilities but always use the list of formats stored in its database for this capture device. Quality Assurance Experience acquired in the NetMeeting group shows that in-house testing is still required to validate the formats capture devices pretend they support. Some devices will not work well in streaming mode and perform more consistently in frame grabbing mode, some will generate data in compressed mode without providing a decoder for their compressed data, some will simply use 100% of the CPU in streaming mode, some will in fact not function correctly at some frame size or in some formats  Some on the other hand may provide very impressive performances in streaming mode, and we should allow them to capture in this mode. In order to guarantee the best user experience, it is necessary that we test the drivers for the most common devices here at Microsoft, and update the content of the database used by the TAPI MSP Video Capture filter with the necessary modifications. Details on how to test those devices will be discussed in a separate document. Video capture filter application interfaces This section documents the list of video capture filter DirectShow interfaces indirectly exposed to applications. Those applications use TAPI IT* interfaces whose method calls are delegated to the interfaces presented here. For VfW, WDM capture devices and Videoconferencing Accelerators, the TAPI MSP Video Capture filter implements the IAMVideoProcAmp interface to control video quality such as brightness, contrast, hue, saturation, gamma, and sharpness, the IAMCameraControl interface to adjust or inquire about camera control settings, and the IAMVideoControl interface to flip a picture horizontally and/or vertically, as well as enumerate available frame rates. The TAPI MSP Video Capture filter exposes the IAMVfwCaptureDialogs interface only for VfW capture devices in order to allow the application to display one of the VfW dialog boxes. VfW specific capture device application interface The TAPI MSP exposes the IAMVfwCaptureDialogs DirectShow interfaces supported by the TAPI MSP Video Capture filter for VfW capture devices to the client application. Typically, these applications indirectly use the IAMVfwCaptureDialogs interface that contains methods to display one of the three dialog boxes (Source, Format, or Display) provided by Microsoft Video for Windows capture drivers. Note that the application do not get a direct pointer to those interfaces. Instead, the methods on those interfaces are called through delegation. The IAMVfwCaptureDialogs interface is implemented by the TAPI MSP Video Capture filter itself, not its output pins. The TAPI MSP calls QueryInterface on the IBaseFilter interface exposed by the TAPI MSP Video Capture filter to get pointers to this DirectShow interface. The IAMVfwCaptureDialogs interface contains the following methods: HasDialog  Used to determine if the specified dialog box exists in the driver. ShowDialog Used to display the specified dialog box.  SendDriverMessage Used to send a driver-specific message.  The IAMVfwCaptureDialogs interface uses the VfwCaptureDialogs enumerated data type to describe a dialog box that might exist in a Video for Windows capture driver. The methods on the IAMVfwCaptureDialogs interface are implemented using the Installable Driver Function SendDriverMessage. VfwCaptureDialogs enumerated data type This enumerated data type is defined as follows: typedef enum {     VfwCaptureDialog_Source = 1,     VfwCaptureDialog_Format = 2,     VfwCaptureDialog_Display = 4 } VfwCaptureDialogs; where: VfwCaptureDialog_Source  Specifies the video source dialog box.  VfwCaptureDialog_Format Specifies the video format dialog box.  VfwCaptureDialog_Display Specifies the video display dialog box.  HasDialog method This method is used to determine if the specified dialog box exists in the Vfw capture driver. The HasDialog method is declared as follows: HRESULT HasDialog([IN]int iDialog) where iDialog  Used to specify the desired dialog box. This is a member of the VfwCaptureDialogs enumerated data type This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported Driver contains the dialog box S_FALSE Driver does not contain the dialog box The IAMVfwCaptureDialogs::HasDialog interface method is implemented using the Installable Driver Function SendDriverMessage. The hdrvr parameter is set to the handle of the VfW capture device video in, external video in, or external video out channel based on the value of iDialog, the msg parameter is set to DVM_DIALOG, the lParam1 parameter is set to the handle of the desktop window, and the lParam2 parameter is set to VIDEO_DLG_QUERY.  ShowDialog method This method is used to display the specified Vfw capture driver dialog box. The ShowDialog method is declared as follows: HRESULT ShowDialog([IN]int iDialog, [IN]HWND hWnd) where iDialog  Used to specify the dialog box to display. This is a member of the VfwCaptureDialogs enumerated data type. Used to provide a handle to the dialog box's parent window.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The IAMVfwCaptureDialogs::ShowDialog interface method is implemented using the Installable Driver Function SendDriverMessage. The hdrvr parameter is set to the handle of the VfW capture device video in, external video in, or external video out channel based on the value of iDialog, the msg parameter is set to DVM_DIALOG, the lParam1 parameter is set to the handle of the parent window hWnd, and the lParam2 parameter is set to 0.  SendDriverMessage method This method is used to send a driver-specific message to the Vfw capture driver. The SendDriverMessage method is declared as follows: HRESULT SendDriverMessage([IN]int iDialog, [IN]int uMsg, [IN]long dw1, [IN]long dw2) where iDialog  Used to specify the handle of the driver dialog box. This is a member of the VfwCaptureDialogs enumerated data type. Used to specify the message to send to the driver.  Used to specify some message data.  Used to specify some message data.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The IAMVfwCaptureDialogs:: SendDriverMessage interface method is implemented using the Installable Driver Function SendDriverMessage. The hdrvr parameter is set to the handle of the VfW capture device video in, external video in, or external video out channel based on the value of iDialog, the msg parameter is set to uMsg, the lParam1 parameter is set to dw1, and the lParam2 parameter is set to dw2. WDM capture device and Videoconferencing Accelerator specific application interfaces The crossbar can be used to route either digital or analog signals in WDM capture devices and Videoconferencing Accelerators. A single crossbar can route both video and audio signals. Video pins can optionally indicate an audio pin, which is related to the video pin. The crossbar is modeled after a general switching matrix, with N inputs and M outputs. Any of the input signals can be routed to one or more of the outputs. Actual hardware implementations probably allow only a subset of this general routing capability. IAMCrossbar interface The crossbar can be used to route either digital or analog signals in WDM capture devices and Videoconferencing Accelerators. A single crossbar can route both video and audio signals. Video pins can optionally indicate an audio pin, which is related to the video pin. The crossbar is modeled after a general switching matrix, with N inputs and M outputs. Any of the input signals can be routed to one or more of the outputs. Actual hardware implementations probably allow only a subset of this general routing capability. The IAMCrossbar interface contains the following methods: get_PinCounts Used to retrieve the number of input and output pins. CanRoute Used to determine if the crossbar filter can route the analog or digital signal.  Route Used to route an input pin to an output pin.  get_IsRoutedTo Used to retrieve the input pin connected to a given output pin.  get_CrossbarPinInfo Used to retrieve a pin that has audio or video data relating to a given pin.  All the methods in this interface are implemented by the IAMCrossbar interface handler provided in KsXBar.ax. The IAMCrossbar interface uses the PhysicalConnectorType enumerated data type to identify specific connector types. This enumerated data type is defined as follows: PhysicalConnectorType enumerated data type This enumerated data type is defined as follows: typedef enum tagPhysicalConnectorType    PhysConn_Video_Tuner = 1,    PhysConn_Video_Composite,    PhysConn_Video_SVideo,    PhysConn_Video_RGB,    PhysConn_Video_YRYBY,    PhysConn_Video_SerialDigital,    PhysConn_Video_ParallelDigital,    PhysConn_Video_SCSI,    PhysConn_Video_AUX,    PhysConn_Video_1394,    PhysConn_Video_USB,    PhysConn_Video_VideoDecoder,    PhysConn_Video_VideoEncoder,    PhysConn_Video_SCART,    PhysConn_Video_Black,    PhysConn_Audio_Tuner = 4096,    PhysConn_Audio_Line,    PhysConn_Audio_Mic,    PhysConn_Audio_AESDigital,    PhysConn_Audio_SPDIFDigital,    PhysConn_Audio_SCSI,    PhysConn_Audio_AUX,    PhysConn_Audio_1394,    PhysConn_Audio_USB,    PhysConn_Audio_AudioDecoder  } PhysicalConnectorType; get_PinCounts method This method is used to retrieve the number of input and output pins. The get_PinCounts method is declared as follows: HRESULT get_PinCounts([OUT]long *OutputPinCount, [OUT]long *InputPinCount) where OutputPinCount Used to retrieve the number of audio and video output pins.  InputPinCount Used to retrieve the number of audio and video input pins.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error CanRoute method This method is used to determine if routing is possible. The CanRoute method is declared as follows: HRESULT CanRoute([IN]long OutputPinIndex, [IN]long InputPinIndex) where OutputPinIndex Used to specify the output pin.  InputPinIndex Used to specify the input pin.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Route method This method is used to route an input pin to an output pin. The Route method is declared as follows: HRESULT Route([IN]long OutputPinIndex, [IN]long InputPinIndex) where OutputPinIndex  Used to specify the output pin. InputPinIndex Used to specify the input pin.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error get_IsRoutedTo method This method is used to retrieve the input pin connected to a given output pin. The get_IsRoutedTo method is declared as follows: HRESULT get_IsRoutedToo([IN]long OutputPinIndex, [OUT]long *InputPinIndex) where OutputPinIndex  Used to specify the output pin. InputPinIndex Used to retrieve the connected input pin.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error get_CrossbarPinInfo method This method is used to retrieve a pin that has audio or video data relating to a given pin. The get_CrossbarPinInfo method is declared as follows: HRESULT get_CrossbarPinInfo([IN]BOOL IsInputPin, [IN]long PinIndex, [OUT]long *PinIndexRelated, [OUT]long *PhysicalType) where IsInputPin  Set to TRUE to specify the pin to be retrieved should be an input pin, FALSE for an output pin. PinIndex Used to specify the pin to find a related pin for.  PinIndexRelated Used to retrieve the index value of the related pin.  PhysicalType Used to retrieve the physical type of the related pin. Pointer to a member of the PhysicalConnectorType enumerated type  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error VfW, WDM capture device and Videoconferencing Accelerator application interfaces The TAPI MSP exposes a few DirectShow interfaces supported by the VfW, WDM capture devices and Videoconferencing Accelerators to the client application. Typically, these applications indirectly use those interfaces to modify video quality settings, or provide simulated camera control capabilities if the video capture filter supports such features. Those interfaces are the IAMVideoProcAmp, IAMCameraControl  and IAMVideoControl interfaces.  Note that the application do not get a direct pointer to those interfaces. Instead, the methods on those interfaces are called through delegation. All interfaces listed below are implemented by the TAPI MSP Video Capture filter itself, not its output pins. The TAPI MSP calls QueryInterface on the IBaseFilter interface exposed by the TAPI MSP Video Capture filter to get pointers to the DirectShow interfaces mentioned in this section. Note that for VfW capture devices, it is the encoder function that implements the IAMVideoProcAmp, IAMCameraControl  and IAMVideoControl interfaces. IAMVideoProcAmp interface The IAMVideoProcAmp interface contains methods for controlling video quality such as brightness, contrast, hue, saturation, gamma, and sharpness. It defines a uniform range for these settings regardless of whether the adjustment is made in the analog or digital domain. The IAMVideoProcAmp interface contains the following methods: GetRange  Used to retrieve minimum, maximum, and default values of a video quality setting. Used to set the value of a video quality setting.  Used to retrieve the value of a video quality setting.  For WDM capture devices and Videoconferencing Accelerators, all the methods in this interface are implemented by the IAMVideoProcAmp interface handler provided in KsWDMCap.ax. The TAPI MSP Video Capture filter uses the IAMVideoProcAmp interface handler provided in KsWDMCap.ax that relies on the PROPSETID_VIDCAP_VIDEOPROCAMP property set to implement the methods of this interface. This set contains the following properties: KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS  Used to set and retrieve the brightness setting.  KSPROPERTY_VIDEOPROCAMP_CONTRAST  Used to set and retrieve the contrast or luma gain setting.  KSPROPERTY_VIDEOPROCAMP_HUE  Used to set and retrieve the hue setting.  KSPROPERTY_VIDEOPROCAMP_SATURATION  Used to set and retrieve the saturation or chroma gain setting.  KSPROPERTY_VIDEOPROCAMP_SHARPNESS  Used to set and retrieve the sharpness setting.  KSPROPERTY_VIDEOPROCAMP_GAMMA  Used to set and retrieve the gamma setting.  KSPROPERTY_VIDEOPROCAMP_COLORENABLE  Used to set and retrieve the color enable setting.  KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE  Used to set and retrieve the white balance setting.  KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION  Used to set and retrieve the backlight compensation setting.  All properties within this property set use the same structure to set and retrieve individual properties. typedef struct {     KSPROPERTY    Property;     LONG          Value;     ULONG         Flags;     ULONG         Capabilities; } KSPROPERTY_VIDEOPROCAMP_S; where Property  Used to specify the property used.  Value  Used to specify a value for the property.  Flags  Contains one of the flags in VideoProcAmpFlags.  Capabilities Contains one of the flags in VideoProcAmpFlags.  The IAMVideoProcAmp interface uses the VideoProcAmpProperty enumerated data type to identify specific quality settings, and the VideoProcAmpFlags enumerated data type to qualify if the quality setting can be set manually and/or automatically. VideoProcAmpProperty enumerated data type This enumerated data type is defined as follows: typedef enum tagVideoProcAmpProperty    VideoProcAmp_Brightness,    VideoProcAmp_Contrast,    VideoProcAmp_Hue,    VideoProcAmp_Saturation,    VideoProcAmp_Sharpness,    VideoProcAmp_Gamma,    VideoProcAmp_ColorEnable,    VideoProcAmp_WhiteBalance,    VideoProcAmp_BacklightCompensation } VideoProcAmpProperty; where: VideoProcAmp_Brightness  Specifies the brightness setting in IRE units * 100. The range for Value is -10000 to 10000; the default value is 750 (7.5 IRE)  VideoProcAmp_Contrast Specifies the contrast or luma gain setting in gain factor * 100. The Value range is from zero to 10000, and the default is 100 (1x). Note that a particular video encoder filter may only implement a subset of this range.  VideoProcAmp_Hue Specifies the hue setting in degrees * 100. Value range is from -18000 to 18000 ( -180 to +180 degrees), and the default is zero. Note that a particular video encoder filter may only implement a subset of this range.  VideoProcAmp_Saturation Specifies the saturation or chroma gain setting in gain * 100. Value ranges from zero to 10000, and the default is 100 (1x). Note that a particular video encoder filter may only implement a subset of this range.  VideoProcAmp_Sharpness Specifies the sharpness setting in arbitrary units. Value ranges from zero to 100, and the default is 50. Note that a particular video encoder filter may only implement a subset of this range.  VideoProcAmp_Gamma Specifies the gamma setting in gamma * 100. Value ranges from 1 to 500, and the default is 100 (gamma = 1). Note that a particular video encoder filter may only implement a subset of this range.  VideoProcAmp_ColorEnable Specifies the color enable setting as a Boolean value. Value ranges from zero to 1, and the default is 1.  VideoProcAmp_WhiteBalance Specifies the white balance setting expressed as a color temperature in degrees Kelvin. The range and default values for this setting are video encoder filter dependent.  VideoProcAmp_BacklightCompensation Specifies the backlight compensation setting which is a Boolean. Zero indicates backlight compensation is disabled, and 1 indicates backlight compensation is enabled.  VideoProcAmpFlags enumerated data type This enumerated data type is defined as follows: typedef enum tagVideoProcAmpFlags    VideoProcAmp_Flags_Manual = 0x0000,    VideoProcAmp_Flags_Auto   = 0x0001 } VideoProcAmpFlags; where: VideoProcAmp_Flags_Manual  Specifies that the quality setting can be modified manually.  VideoProcAmp_Flags_Auto Specifies that the quality setting can be modified automatically.  GetRange method This method is used to retrieve the minimum, maximum, and default values for specific video quality settings. The GetRange method is declared as follows: HRESULT GetRange([IN]long Property, [OUT]long *pMin, [OUT]long *pMax, [OUT]long *pSteppingDelta, [OUT]long *pDefault, [OUT]long *pCapsFlags) where Property  Used to specify the video quality setting to determine the range of. Use a member of the VideoProcAmpProperty enumerated type. Used to retrieve the minimum value of the video quality setting range.  Used to retrieve the maximum value of the video quality setting range.  pSteppingDelta Used to retrieve the stepping delta of the video quality setting range.  pDefault Used to retrieve the default value of the video quality setting range.  pCapsFlags Used to retrieve the capabilities of the video quality setting. Pointer to a member of the VideoProcAmpFlags enumerated type. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter relies on the KSPROPERTY_VIDEOPROCAMP_S structure to implement the IAMVideoProcAmp::GetRange method.  Set method This method is used to set the value of a specific video quality setting. The Set method is declared as follows: HRESULT Set([IN]long Property, [IN]long lValue, [IN]long Flags) where Property  Used to specify the video quality setting to set the value of. Use a member of the VideoProcAmpProperty enumerated type. lValue Used to specify the new value of the video quality setting.  Flags A member of the VideoProcAmpFlags enumerated type.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter relies on the KSPROPERTY_VIDEOPROCAMP_S structure to implement the IAMVideoProcAmp::Set method.   Get method This method is used to get the current value of a specific video quality setting. The Get method is declared as follows: HRESULT Get([IN]long Property, [OUT]long *lValue, [OUT]long *Flags) where Property  Used to specify the video quality setting to get the value of. Use a member of the VideoProcAmpProperty enumerated type. lValue Used to retrieve the current value of the video quality setting.  Flags Pointer to a member of the VideoProcAmpFlags enumerated type.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter relies on the KSPROPERTY_VIDEOPROCAMP_S structure to implement the IAMVideoProcAmp::Get method.   IAMCameraControl interface The IAMCameraControl interface contains methods to adjust or inquire about camera control settings. The controls are a subset of the proposed ITU T.RDC standard at  HYPERLINK "http://www.itu.ch" http://www.itu.ch The IAMCameraControl interface contains the following methods: GetRange  Used to retrieve minimum, maximum, and default values of a camera control setting. Used to set the value of a camera control setting.  Used to retrieve the value of a camera control setting.  For WDM capture devices and Videoconferencing Accelerators, the TAPI MSP Video Capture filter uses the IAMCameraControl interface handler provided in KsWDMCap.ax that relies on the PROPSETID_VIDCAP_CAMERACONTROL property set to implement the methods of this interface. This set contains the following properties: KSPROPERTY_CAMERACONTROL_PAN  Used to set and retrieve the camera pan setting.  KSPROPERTY_CAMERACONTROL_TILT  Used to set and retrieve the camera tilt setting.  KSPROPERTY_CAMERACONTROL_ROLL  Used to set and retrieve the roll setting.  KSPROPERTY_CAMERACONTROL_ZOOM  Used to set and retrieve the zoom setting.  KSPROPERTY_CAMERACONTROL_EXPOSURE  Used to set and retrieve the exposure setting.  KSPROPERTY_CAMERACONTROL_IRIS  Used to set and retrieve the iris setting.  KSPROPERTY_CAMERACONTROL_FOCUS  Used to set and retrieve the focus setting.  All properties within this property set use the same structure to set and retrieve individual properties. typedef struct {     KSPROPERTY    Property;     LONG          Value;     ULONG         Flags;     ULONG         Capabilities; } KSPROPERTY_CAMERACONTROL_S; where Property  Used to specify the property used.  Value  Used to specify a value for the property.  Flags  Contains the flags described in the following table.  Capabilities Contains the flags described in the following table.  Flags Description KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL The property is to be adjusted manually KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO The property is to be adjusted automatically KSPROPERTY_CAMERACONTROL_FLAGS_ABSOLUTE The setting is in absolute values KSPROPERTY_CAMERACONTROL_FLAGS_RELATIVE The setting is in relative values The IAMCameraControl interface uses the CameraControlProperty enumerated data type to describe specific camera control settings, and the CameraControlFlags enumerated data type to qualify if the camera control setting can be set manually and/or automatically. CameraControlProperty enumerated data type This enumerated data type is defined as follows: typedef enum tagCameraControlProperty    CameraControl_Pan,    CameraControl_Tilt,    CameraControl_Roll,    CameraControl_Zoom,    CameraControl_Exposure,    CameraControl_Iris,    CameraControl_Focus } CameraControlProperty; where: CameraControl_Pan  Specifies the simulated camera pan setting in degrees. Values range from -180 to +180, and the default is zero. Positive values are clockwise from the origin (the simulated camera rotates clockwise when viewed from above), and negative values are counterclockwise from the origin. Note that a particular video capture filter may only implement a subset of this range.  CameraControl_Tilt Specifies the simulated camera tilt setting in degrees. Values range from -180 to +180, and the default is zero. Positive values point the imaging plane up, and negative values point the imaging plane down. Note that a particular video capture filter may only implement a subset of this range.  CameraControl_Roll Specifies the simulated roll setting in degrees. Values range from -180 to +180, and the default is zero. Positive values cause a clockwise rotation of the simulated camera along the image viewing axis, and negative values cause a counterclockwise rotation of the simulated camera. Note that a particular video capture filter may only implement a subset of this range.  CameraControl_Zoom Specifies the simulated zoom setting in millimeter units. Values range from 10 to 600, and the default is video capture filter specific.  CameraControl_Exposure Specifies the simulated exposure setting in seconds using the following formula. For values less than zero, the exposure time is 1/2n seconds. For positive values and zero, the exposure time is 2n seconds. Note that a particular video capture filter may only implement a subset of this range.  CameraControl_Iris Specifies the simulated iris setting expressed as the fstop  * 10.  CameraControl_Focus Specifies the simulated camera focus setting as the distance to the optimally focused target in millimeters. The range and default values are video encoder filter specific. Note that a particular video capture filter may only implement a subset of this range.  CameraControlFlags enumerated data type This enumerated data type is defined as follows: typedef enum tagCameraControlFlags    CameraControl_Flags_Manual = 0x0000,    CameraControl_Flags_Auto   = 0x0001 } CameraControlFlags; where: CameraControl_Flags_Manual  Specifies that the camera control  setting can be modified manually.  CameraControl_Flags_Auto Specifies that the camera control setting can be modified automatically.  GetRange method This method is used to retrieve the minimum, maximum, and default values for specific camera control settings. The GetRange method is declared as follows: HRESULT GetRange([IN]long Property, [OUT]long *pMin, [OUT]long *pMax, [OUT]long *pSteppingDelta, [OUT]long *pDefault, [OUT]long *pCapsFlags) where Property  Used to specify the camera control setting to determine the range of. Use a member of the CameraControlProperty enumerated type. Used to retrieve the minimum value of the camera control setting range.  Used to retrieve the maximum value of the camera control setting range.  pSteppingDelta Used to retrieve the stepping delta of the camera control setting range.  pDefault Used to retrieve the default value of the camera control setting range.  pCapsFlags Used to retrieve the capabilities of the camera control setting. Pointer to a member of the CameraControlFlags enumerated type. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter relies on the KSPROPERTY_CAMERACONTROL_S structure to implement the IAMCameraControl::GetRange method.   Set method This method is used to set the value of a specific camera control setting. The Set method is declared as follows: HRESULT Set([IN]long Property, [IN]long lValue, [IN]long Flags) where Property  Used to specify the camera control setting to set the value of. Use a member of the CameraControlProperty enumerated type. lValue Used to specify the new value of the camera control setting.  Flags A member of the CameraControlFlags enumerated type.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter relies on the KSPROPERTY_CAMERACONTROL_S structure to implement the IAMCameraControl::Set method.  Get method This method is used to get the current value of a specific camera control setting. The Get method is declared as follows: HRESULT Get([IN]long Property, [OUT]long *lValue, [OUT]long *Flags) where Property  Used to specify the camera control setting to get the value of. Use a member of the CameraControlProperty enumerated type. lValue Used to retrieve the current value of the camera control setting.  Flags Pointer to a member of the CameraControlFlags enumerated type.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter relies on the KSPROPERTY_CAMERACONTROL_S structure to implement the IAMCameraControl::Get method.  IAMVideoControl interface The IAMVideoControl interface contains methods to flip a picture horizontally and/or vertically, as well as enumerate available frame rates. The following list identifies the methods of IAMVideoControl interface exposed by TAPI: GetCaps  Used to retrieve the capabilities of the video capture filter regarding flipping pictures, external triggering and available frame rates. SetMode Used to set the video control mode of operation.  GetMode Used to retrieve the video control mode of operation.  GetCurrentActualFrameRate Used to retrieve the actual frame rate at which the video capture filter is streaming.  GetMaxAvailableFrameRate Used to retrieve the maximum frame rate currently available on the video capture filter.  GetFrameRateList Used to retrieve the list of available frame rates.  For WDM capture devices and Videoconferencing Accelerators, the TAPI MSP Video Capture filter uses the IAMVideoControl interface handler provided in KsWDMCap.ax that relies on the PROPSETID_VIDCAP_VIDEOCONTROL property set to control additional aspects of the capture process such as enumerating available frame rates and image orientation. This property set consists of the following properties: KSPROPERTY_VIDEOCONTROL_CAPS Used to identify the video control capabilities of the device. This is a read-only property. KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE Used to retrieve the current actual frame rate, and current maximum available frame rate. This is a read-only property. KSPROPERTY_VIDEOCONTROL_FRAME_RATES  Used to enumerate the available frame rates. This is a read-only property. KSPROPERTY_VIDEOCONTROL_MODE  Used to control the mode of image production. This is a read/write property. The KSPROPERTY_VIDEOCONTROL_CAPS property uses the following structure: typedef struct {     KSPROPERTY Property;     ULONG      VideoControlCaps;            // KS_VideoControlFlags_* } KSPROPERTY_VIDEOCONTROL_CAPS_S, *PKSPROPERTY_VIDEOCONTROL_CAPS_S; where Property  Used to specify the property used.  VideoControlCaps  Used to specify the video control capabilities from the KS_VideoControlFlags_* of the property set.  When using the KSPROPERTY_VIDEOCONTROL_FRAME_RATES read-only property, the available frame rates are returned in a structure of type KSMULTIPLE_ITEM with individual values given in units of 100ns. Finally, the KSPROPERTY_VIDEOCONTROL_MODE read-write property uses the following structure: typedef struct {     KSPROPERTY Property;     LONG       Mode;                        // KS_VideoControlFlags_* } KSPROPERTY_VIDEOCONTROL_MODE_S, *PKSPROPERTY_VIDEOCONTROL_MODE_S; where Property  Used to specify the property used.  Mode  Used to specify the mode, from the KS_VideoControlFlags_* of the property set.   The IAMVideoControl interface uses the VideoControlFlags enumerated data type to describe flip modes. VideoControlFlags enumerated data type This enumerated data type is defined as follows: typedef enum tagVideoControlFlags     VideoControlFlag_FlipHorizontal        = 0x0001,     VideoControlFlag_FlipVertical          = 0x0002,     VideoControlFlag_ExternalTriggerEnable = 0x0004,     VideoControlFlag_Trigger               = 0x0008 } VideoControlFlags; where: VideoControlFlag_FlipHorizontal Specifies that the picture is flipped horizontally.  VideoControlFlag_FlipVertical Specifies that the picture is flipped vertically.  VideoControlFlag_ExternalTriggerEnable Sets up a stream to capture a trigger from an external source, for example, a push button on a camera. Buffers can be queued to the driver but will not be passed up from the WDM capture driver (for compression, display, or writing to a file) until the external event happens.  VideoControlFlag_Trigger In software, simulates an external trigger when the stream has the VideoControlFlag_ExternalTriggerEnable flag set.  GetCaps method This method is used to retrieve the capabilities of the TAPI MSP Video Capture filter regarding flipping pictures and external triggers. The GetCaps method is declared as follows: HRESULT GetCaps([IN]IPin *pPin, [OUT]long *pCapsFlags) where pPin  Used to specify the video output pin to query capabilities from. pCapsFlags Used to retrieve a value representing a combination of the flags from the VideoControlFlags enumeration.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter relies on the KSPROPERTY_VIDEOCONTROL_CAPS property and KSPROPERTY_VIDEOCONTROL_CAPS_S structure to implement the IAMVideoControl::GetCaps method.   SetMode method This method is used to set the video control mode of operation. The SetMode method is declared as follows: HRESULT SetMode([IN]IPin *pPin, [IN]long Mode) where pPin  Used to specify the pin to set the video control mode on. Used to specify a combination of the flags from the VideoControlFlags enumeration.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter relies on the KSPROPERTY_VIDEOCONTROL_MODE property and KSPROPERTY_VIDEOCONTROL_MODE_S structure to implement the IAMVideoControl::SetMode method.   GetMode method This method is used to retrieve the video control mode of operation. The GetCaps method is declared as follows: HRESULT GetCaps([IN]IPin *pPin, [OUT]long *Mode) where pPin  Used to specify the pin to get the video control mode from. Pointer to a value representing a combination of the flags from the VideoControlFlags enumeration.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter relies on the KSPROPERTY_VIDEOCONTROL_MODE property and KSPROPERTY_VIDEOCONTROL_MODE_S structure to implement the IAMVideoControl::GetMode method.   GetCurrentActualFrameRate method This method is used to retrieve the actual frame rate, expressed as a frame duration in 100 ns units. USB (Universal Serial Bus) and IEEE 1394 cameras may provide lower frame rates than requested, due to bandwidth availability. This is only available during video streaming. The GetCurrentActualFrameRate method is declared as follows: HRESULT GetCurrentActualFrameRate([IN]IPin *pPin, [OUT]LONGLONG * ActualFrameRate) where pPin  Used to specify the pin to retrieve the frame rate from. ActualFrameRate Pointer to the frame rate in frame duration in 100 nS units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter relies on the KSPROPERTY_VIDEOCONTROL_FRAME_RATES property and KSMULTIPLE_ITEM structure to implement the IAMVideoControl::GetCurrentActualFrameRate method.   GetFrameRateList method This method is used to retrieve the list of available frame rates. The GetFrameRateList method is declared as follows: HRESULT GetFrameRateList([IN]IPin *pPin, [IN]long iIndex, [IN]SIZE Dimensions, [OUT]long *ListSize, [OUT]LONGLONG **FrameRates) where pPin  Used to specify the pin to retrieve the frame rates from. iIndex  Used to specify the index of the format to query for frame rates. This index corresponds to the order in which formats are enumerated by IAMStreamConfig::GetStreamCaps. The value must range between 0 and the number of supported VIDEO_STREAM_CONFIG_CAPS structures returned by IAMStreamConfig::GetNumberOfCapabilities. Dimensions  Used to specify the frame's image size (width and height) in pixels. ListSize  Used to specify the number of elements in the list of frame rates. FrameRates Pointer to an array of frame rates in 100 ns units. Can be NULL if only ListSize is wanted.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter relies on the KSPROPERTY_VIDEOCONTROL_FRAME_RATES property and KSMULTIPLE_ITEM structure to implement the IAMVideoControl::GetFrameRateList method.  GetMaxAvailableFrameRate method This method is used to retrieve the maximum frame rate currently available, based on bus bandwidth usage for connections, such as USB (Universal Serial Bus) and IEEE 1394, where the maximum frame rate may be limited due to bandwidth availability. The GetMaxAvailableFrameRate method is declared as follows: HRESULT GetMaxAvailableFrameRate([IN]IPin *pPin, [IN]long iIndex, [IN]SIZE Dimensions, [OUT]LONGLONG *MaxAvailableFrameRate) where pPin  Used to specify the pin to retrieve the maximum frame rate from. iIndex  Used to specify the index of the format to query for frame rates. This index corresponds to the order in which formats are enumerated by IAMStreamConfig::GetStreamCaps. The value must range between 0 and the number of supported VIDEO_STREAM_CONFIG_CAPS structures returned by IAMStreamConfig::GetNumberOfCapabilities. Dimensions  Used to specify the frame's image size (width and height) in pixels. MaxAvailableFrameRate Pointer to the maximum available frame rate in frame duration in 100 nS units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter relies on the KSPROPERTY_VIDEOCONTROL_FRAME_RATES property and KSMULTIPLE_ITEM structure to implement the IAMVideoControl::GetMaxAvailableFrameRate method.  Video capture filter H.245 video capability MSP interface The TAPI MSP Capability module is responsible for coordinating capability advertisement and resolution with respect to the limits configured in the TAPI MSP Quality Controller. The TAPI MSP Video Capture filter implements the IH245VideoCapability interface on behalf of VfW and WDM capture devices (including Videoconferencing Accelerators) in order to provide the TAPI MSP Capability module with a table of estimated steady-state resource requirements as related to each format that the capture device supports. While run-time resource requirements fluctuate within a continuum, the steady-state resource requirements are meant to indicate relative resource requirements under near-ideal conditions and no network loss. At minimum, the resource requirements include the typical maximum bitrate and CPU utilization (in % of the host CPU) for each supported format. The steady-state resource requirement information is used only by the TAPI MSP Capability module to ensure that negotiated formats always fall within the maximum configured resource budget. Given the steady-state resource requirements of all filters and the resource limits configured in the TAPI MSP Quality Controller, the TAPI MSP Capability module is able to build the local simultaneous capability descriptors and to disable advertisement and selection of formats which exceed or approach the configured resource limits. Once streaming is active, fluctuations in actual bitrate and CPU load are then managed by the TAPI MSP Quality Controller.  IH245VideoCapability interface The IH245VideoCapability interface contains methods to enumerate, translate, and compare video formats. The IH245VideoCapability interface contains the following methods: GetH245VersionID Used to retrieve a version identifier that indicates the version of H.245 that the TAPI MSP Video Capture filter supports. GetFormatTable Used to retrieve a table of supported formats as related to estimated system resources. This table may be dynamically allocated by the TAPI MSP Video Capture filter.  ReleaseFormatTable Used to release the format table allocated by GetFormatTable. IntersectFormats Used to compare a local capability and remote capability and produce configuration structures and parameters that are compatible with both.  GetLocalFormat Used to retrieve local format parameters that are compatible with a specific remote capability and parameters. GetNegotiatedLimitProperty Used to retrieve the value of a negotiated limiting parameter.  ReleaseNegotiatedCapability Used to release resources that were allocated by IntersectFormats or GetLocalFormat.  SetIDBase Used to control the range of sequential numbers that uniquely identify individual capabilities FindIDByRange Used to find a specific capability that corresponds to a formatted AM_MEDIA_TYPE structure.  The IH245VideoCapability interface uses the NegotiatedVideoLimit enumerated data type to describe negotiated video limiting parameters. Only generic properties which are useful to the TAPI MSP Quality Controller module are defined. The IH245VideoCapability interface is not a standard DirectShow interface. Therefore, it is not implemented natively by KSProxy. Instead, the TAPI MSP Video Capture filter implements this interface with an interface handler using the DirectShow IAMStreamConfig interface to retrieve format information on each of the output pins of TAPI MSP Video Capture filter. NegotiatedVideoLimit enumerated data type This enumerated data type is defined as follows: typedef enum tagNegotiatedVideoLimit     NegotiatedVideo_MaxFrameRate,     NegotiatedVideo_MaxBitRate,     NegotiatedVideo_MaxBitsPerPicture, } NegotiatedVideoLimit; where: NegotiatedVideo_MaxFrameRate Specifies the smaller of the maximum continuous video frame rate that the receiver is capable of receiving or the transmitter is capable of transmitting.  NegotiatedVideo_MaxBitRate Specifies smaller of the maximum average video bit rate that the receiver is capable of receiving or the transmitter is capable of transmitting.  NegotiatedVideo_MaxBitsPerPicture Specifies the maximum number of bits that may be contained in a single video frame. If there is no negotiated maximum, this shall be zero.  VideoResourceBounds structure TAPI defines the VideoResourceBounds structure to specify the estimated maximum continuous resource requirements of the TAPI MSP Video Capture filter at a specific frame rate: typedef enum tag_VideoResourceBounds     int iPicturesPerSecond;     DWORD dwBitsPerPicture;     WORD wCPUUtilization; } VideoResourceBounds; where: iPicturesPerSecond Specifies an INTEGER value that indicates the video frame rate, in frames per second, for which the resource bounds are being specified. Frame rates of less than 1 frame per second are indicated by a negative value in units of seconds per frame.  dwBitsPerPicture Specifies a DWORD value that indicates the approximate average number of bits per video frame at an average frame rate of iPicturesPerSecond.  wCPUUtilization Specifies a WORD value that indicates the approximate average CPU utilization, in percent, of the TAPI MSP Video Capture filter at the average frame rate of iPicturesPerSecond.  H245VideoCapabilityMap structure TAPI defines the H245VideoCapabilityMap structure to specify the relationship between supported formats and estimated maximum system resources for the supported format: typedef enum tag_H245VideoCapabilityMap     AM_MEDIA_TYPE *pAMMediaType;     H245VideoCapability h245VideoCapability;     GUID filterGuid;     DWORD dwUniqueID;     UINT uNumRatesSupported;     VideoResourceBounds *pResourceBoundArray; } H245VideoCapabilityMap; where: pAMMediaType Specifies a pointer to an AM_MEDIA_TYPE structure that describes the format of the video stream.  h245VideoCapability Specifies the H.245 video format, including all parameters and options. This structure is H.245 version specific: its definition depends on the version of H.245 used by the TAPI MSP Video Capture filter. This structure may indicate format parameters for more than one standard video size at a time if the resource requirements are similar for all sizes.  filterGuid Specifies a GUID value that uniquely identifies the TAPI MSP Video Capture filter.  dwUniqueID Specifies a DWORD value that uniquely identifies the capability of the TAPI MSP Video Capture filter.  uNumRatesSupported This indicates the number of elements referenced by pResourceBoundArray and specifies the number of integral frame rates that are supported for the format options specified in pAMMediaType and h245VideoCapability.  pResourceBoundArray Specifies an array of VideoResourceBounds structures that indicate the approximate resource bounds of each supported integral frame rate.  H245VideoCapabilityTable structure TAPI defines the H245VideoCapabilityTable structure to specify the set of formats that are supported by the TAPI MSP Video Capture filter: typedef enum tag_H245VideoCapabilityTable     UINT uMappedCapabilities;     H245VideoCapabilityMap *pCapabilityArray; } H245VideoCapabilityTable; where: uMappedCapabilities Specifies  the  number of H245VideoCapabilityMap structures in pCapabilityArray.  pCapabilityArray Specifies a pointer to an array of H245VideoCapabilityMap structures.  GetH245VersionID method This method returns a DWORD value that identifies the platform version that the TAPI MSP Video Capture filter was designed for. The platform version is defined as TAPI_H245_VERSION_ID. The GetH245VersionID method is declared as: DWORD GetH245VersionID() GetFormatTable method This method is used to obtain H245VideoCapabilityMap structures for all formats and format options that the TAPI MSP Video Capture filter supports. The content of the capability information that the TAPI MSP Capability module obtains via the GetFormatTable method is a two dimensional table that relates every supported transmit format to steady-state resource requirements of that format. The GetFormatTable method is declared as follows: HRESULT GetFormatTable([IN]IPin *pPin, [OUT]H245VideoCapabilityTable *pTable) where pPin  Used to specify the video capture or still-image output pin of the capture device. The TAPI MSP Video Capture filter enumerates the list of formats supported by this pin to build its own video capability table. pTable Pointer to an H245VideoCapabilityTable structure.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error ReleaseFormatTable method This method is used to release memory allocated by the GetFormatTable method. The ReleaseFormatTable method is declared as follows: HRESULT ReleaseFormatTable([IN]H245VideoCapabilityTable *pTable) where pTable Pointer to an H245VideoCapabilityTable structure.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error IntersectFormats method This method is used to compare and intersect one local capability and one remote capability and to obtain configuration parameters. The IntersectFormats method is declared as follows: HRESULT IntersectFormats([IN]H245VideoCapability *pLocalCapability, [IN]H245VideoCapability *pRemoteCapability, [OUT]HANDLE *phIntersectionCookie, [OUT]H245VideoCapability *pIntersectedCapability, [IN]AM_MEDIA_TYPE *pAMMediaType) where pLocalCapability  Specifies the H.245 video format, including all parameters and options defined by H.245, of a local video capability. pRemoteCapability  Specifies the H.245 video format, including all parameters and options defined by H.245, of a remote video capability. phIntersectionCookie  Identifies the dynamic instance of intersected capabilities. When the TAPI MSP Video Capture filter creates the intersection, it may allocate memory for the intersected capability parameters. The intersection cookie identifies this allocation. This is used to release internal allocations and also as an argument to the GetNegotiatedLimitProperty method. pIntersectedCapability  Specifies the H.245 video format, of the resolved common local and remote capability options and limits. pAMMediaType Pointer to an AM_MEDIA_TYPE structure that has been initialized to regard negotiated options.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_INCOMPATIBLECAPS Failure E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetLocalFormat method This method is used to obtain the local TAPI MSP Video Capture filter configuration parameters that are compatible with a remote capability. The GetLocalFormat method is declared as follows: HRESULT GetLocalFormat([IN]H245VideoCapability *pRemoteCapability, [OUT]HANDLE *phIntersectionCookie, [IN]AM_MEDIA_TYPE *pAMMediaType) where pRemoteCapability  Specifies the H.245 video format, including all parameters and options defined by H.245, of a remote video capability. phIntersectionCookie  Identifies the dynamic instance of intersected capabilities. When the TAPI MSP Video Capture filter creates the intersection, it may allocate memory for the intersected capability parameters. The intersection cookie identifies this allocation. This is used to release internal allocations and also as an argument to the GetNegotiatedLimitProperty method. pAMMediaType Pointer to an AM_MEDIA_TYPE structure that has been initialized to regard negotiated options.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_INCOMPATIBLECAPS No local compatible capability exists E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error GetNegotiatedLimitProperty method This method is used to obtain negotiated limits that were determined by either the IntersectFormats or GetLocalFormat method. The GetNegotiatedLimitProperty method is declared as follows: HRESULT GetNegotiatedLimitProperty([IN]HANDLE hIntersectionCookie, [IN]NegotiatedVideoLimit LimitProperty, [OUT]DWORD *pdwValue) where hIntersectionCookie  Identifies the dynamic instance of intersected capabilities. LimitProperty  Identifies the limit property being retrieved. pdwValue Pointer to a DWORD value to receive the value of the specified limit property.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error ReleaseNegotiatedCapability method This method is used to release the TAPI MSP Video Capture filter internal memory allocated by either the IntersectFormats or GetLocalFormat method. The ReleaseNegotiatedCapability method is declared as follows: HRESULT ReleaseNegotiatedCapability([IN]HANDLE hIntersectionCookie) where hIntersectionCookie  Identifies the dynamic instance of intersected capabilities. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error SetIDBase method This method is used to control the sequential numbering range used to uniquely identify the TAPI MSP Video Capture filter capabilities. The SetIDBase method is declared as follows: HRESULT SetIDBase([IN]DWORD dwIDBase) where dwIDBase  A DWORD value that indicates the beginning number in the sequence . This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error FindIDByRange method This method is used to obtain the unique format ID of a capability that corresponds to an AM_MEDIA_TYPE. The FindIDByRange method is declared as follows: HRESULT FindIDByRange([IN]AM_MEDIA_TYPE *pAMMediaType,[OUT]DWORD *pdwID) where pAMMediaType Pointer to an AM_MEDIA_TYPE structure that has been initialized indicate a specific format. pdwID  Pointer to a DWORD output parameter that will contain the unique format ID. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Video capture output pin TAPI interfaces This section documents the list of video capture output pin TAPI interfaces indirectly exposed to applications. Those applications use TAPI IT* interfaces whose method calls are delegated to the interfaces presented here. For VfW, WDM capture devices and Videoconferencing Accelerators, the TAPI MSP Video Capture filter implements the ICPUControl interface to control the maximum capture and post-processing time per frame and CPU load not be exceeded by the capture device, the IFrameRateControl interface to initialize and regulate the frame rate of the capture output pin, the IH245EncoderCommand interface to communicate H.245 commands to the compressed video output pin, the INetworkStats interface to inform the compressed video output pin of the transmission channel conditions (packet loss ), the IProgressiveRefinement interface to communicate progressive refinement H.245 commands to the compressed video or still-image output pin, and the IBitrateControl interface to initialize and regulate the outgoing bitrate of the compressed video output pin. Note that for VfW and traditional WDM capture devices, it is the encoder function that implements the IH245EncoderCommand, IProgressiveRefinement, INetworkStats, ICPUControl, and IBitrateControl interfaces. Therefore, those interfaces are only available on the TAPI MSP Video Capture filter if it isn t connected to a downstream installable codec. VfW and WDM capture device capture output pin TAPI interfaces The TAPI MSP Video Capture filter only exposes two interfaces supported by its capture video output pin to the TAPI MSP Quality Controller whenever it is connected to an installable codec. The TAPI MSP Quality Controller uses the optional ICPUControl interface to initialize and adjust the maximum capture and post-processing time per frame and CPU load not be exceeded by the capture device. Similarly, it uses the IFrameRateControl interface to initialize and regulate the frame rate of the capture video output pin. The TAPI MSP calls QueryInterface on the IPin interface exposed by the  capture output pin of the TAPI MSP Video Capture filter to get pointers to the interfaces defined in this section. ICPUControl interface Capture output pins may implement the optional ICPUControl interface. The methods on this interface are called at the beginning of a call to initialize the maximum CPU load and frame post-processing time, and then periodically by the TAPI MSP Quality Controller during the entire call. The initial and limit values for the maximum CPU load and frame post-processing time are based on user-defined settings provided by the application. See section   REF _Ref443191700 \r \h  9.2.3  for more information on the ICPUControl interface definition. For VfW frame grabbing devices, the post-processing time is composed of the time spent between the request for a grab occurred and the moment the frame was returned from the capture device, as well as the black banding code execution time. For VfW streaming devices, the post-processing time only measures the black banding code time. WDM capture devices are streaming devices. However, a lot of them appear to function better (less CPU usage) and easier to control when used in frame grabbing mode, that is, when there is only one outstanding overlapped IO. Here again, for WDM capture devices used in frame grabbing mode, the post-processing time is composed of the time spent between the request for a grab occurred and the moment the frame was returned from the capture device, as well as the black banding code execution time. For WDM capture devices used in streaming mode, the post-processing time only measures the black banding code time. IFrameRateControl interface The IFrameRateControl interface specifies a target frame rate to the capture output pin of the video capture filter. The methods on this interface are called at the beginning of a call by the TAPI MSP Quality Controller to initialize the target frame rates, and then periodically during the entire call. The dynamic values for the target frame rates are based on the TAPI MSP Quality Controller CPU usage measurements using NT s CPU performance counters, as well as the past performance of the TAPI MSP Video Encoder filter output bitrate controller. The initial and limit values for the target frame rate are based on user-defined settings provided by the application to the TAPI MSP Quality Controller and the result of capability negotiations between the two connected endpoints provided by the TAPI MSP Channel Controller. The IFrameRateControl interface is defined in section   REF _Ref442843458 \r \h  9.2.5 For VfW frame grabbing devices, or WDM capture devices used in frame grabbing mode, the capture frame rate is adjusted by regulating the time between each request for a frame grab. VfW and WDM streaming devices are not able to easily adjust their capture frame rate on the fly. Therefore, VfW and WDM streaming capture devices are always asked to capture at 30fps, but only a fraction of those frames are delivered to the downstream filter, hence, achieving dynamic frame rate control.  Compressed video output pin TAPI interfaces The TAPI MSP Video Capture filter exposes a few interfaces supported by its compressed video output pin to the TAPI MSP Channel Controller, the TAPI MSP Network Sink filter, or the TAPI MSP Quality Controller. The TAPI MSP Channel Controller uses the IH245EncoderCommand interface to communicate H.245 commands to the compressed video output pin. This same TAPI MSP Channel Controller uses the IProgressiveRefinement interface to communicate progressive refinement H.245 commands to the compressed video or still-image output pin. The network sink filter uses the INetworkStats interface to inform the compressed video output pin of the transmission channel conditions (packet loss ). The TAPI MSP Quality Controller uses the optional ICPUControl interface to initialize and adjust the maximum encoding time per frame and CPU load not be exceeded by the encoder s compression algorithm. Similarly, it uses the IBitrateControl and IFrameRateControl interfaces to initialize and regulate the outgoing bitrate and frame rate of the compressed video output pin. The TAPI MSP calls QueryInterface on the IPin interface exposed by the video output pin of the TAPI MSP Video Capture filter to get pointers to the IH245EncoderCommand, IProgressiveRefinement, INetworkStats, ICPUControl, IBitrateControl, and IFrameRateControl interfaces. The TAPI MSP Video Capture filter implements those interfaces using the generic IKsControl interface methods to control the WDM or Videoconferencing Accelerator video output stream. Note that for VfW and traditional WDM capture devices, it is the encoder function that implements the IH245EncoderCommand, IProgressiveRefinement, INetworkStats, ICPUControl, and IBitrateControl interfaces. Therefore, those interfaces are only available on the TAPI MSP Video Capture filter if it isn t connected to a downstream installable codec. The IAMTVTuner, IAMTVAudio, IAMAnalogVideoDecoder, and IAMAnalogVideoEncoder interfaces, are not explicitly used by the TAPI MSP. The GUIDs of the new property sets introduced in this section are defined as follows: PROPSETID_H245COMMAND 35343268-5245-4945-5252-45464C494850 PROPSETID_NETWORKSTATS 7374656E-5245-4945-5252-45464C494850 PROPSETID_CPUCONTROL 63757063-5245-4945-5252-45464C494850 PROPSETID_BITRATECONTROL 63737062-5245-4945-5252-45464C494850 PROPSETID_FRAMERATECONTROL 63737066-5245-4945-5252-45464C494850 To set and retrieve values for some of the properties in those new sets, the following structure is defined. typedef struct {     KSPROPERTY Property;     union {     DWORD      dwParam;     LONGLONG   llParam;     } } KSPROPERTY_PARAM_S; where Property  Specifies the property.  dwParam Specifies a parameter for the property as a DWORD.  llParam Specifies a parameter for the property as a LONGLONG.  To retrieve minimum, maximum, stepping delta and default values for some of the properties in those new sets, the following structure is defined. typedef struct {   KSPROPERTY_DESCRIPTION   PropertyDescription;   KSPROPERTY_MEMBERSHEADER MembersHeader;   union {      KSPROPERTY_STEPPING_LONG SteppingLong;      KSPROPERTY_STEPPING_LONGLONG SteppingLongLong;      LONG     DefaultLong;      LONGLONG DefaultLongLong; } KSPROPERTY_LIST_S; where PropertyDescription Specifies access flags (KSPROPERTY_TYPE_GET and KSPROPERTY_TYPE_SET), the inclusive size of the entire values information, the property value type information, and the number of members lists that would typically follow the structure.  MembersHeader Used to provide information on a property member header.  SteppingLong Specifies the stepping delta, minimum and maximum values as LONGs.  SteppingLongLong Specifies the stepping delta, minimum and maximum values as LONGLONGs.  DefaultLong Specifies the default value as a LONG.  DefaultLongLong Specifies the default value as a LONGLONG.  IH245EncoderCommand interface H.245 commands exist for various purposes. Fast update requests are generally issued when source switching occurs in multipoint applications, or packet loss was detected. The flow control command is used to allow the bit rate of the video stream to be controlled by the remote endpoint. This has a number of purposes: interworking with terminals that only support a finite number of bit rates; multi-point applications where the rates from different sources should be matched; and flow control is congested. The temporal/spatial trade-off command is used by a remote endpoint to indicate preferences in terms of video quality vs. frame rate. In order to handle H.245 commands and indications, the compressed video output pin provides the TAPI MSP Channel Controller with a pointer to an IH245EncoderCommand interface containing the following methods: videoFastUpdadePicture  Used to command the compressed video output pin to enter the fast-update mode at its earliest opportunity.  videoFastUpdateGOB  Used to command the compressed video output to perform a fast update of one or more GOBs. videoFastUpdateMB  Used to command the compressed video output pin to perform a fast update of one or more MBs. videoSendSyncEveryGOB Used to command the compressed video output pin to use sync for every GOB as defined in H.263. videoSendSyncEveryGOBCancel Used to command the compressed video output pin to decide the frequency of GOB syncs. videoNotDecodedMBs Used to indicate to the compressed video output pin that a set of MBs has been received with errors and that any MB in the specified set has been treated as not coded. Note that the flow control, temporal/spatial trade-off command and mode changes are not propagated to the video output pin directly. Those commands are implemented using other means as described in sections   REF _Ref431552954 \r \h  9.2.1.6  REF _Ref428201104 \r \h  9.2.1.8 The IH245EncoderCommand interface is not a standard DirectShow interface. The TAPI MSP Video Capture filter implements this interface using the generic IKsControl interface and a property set called PROPSETID_H245COMMAND. The properties defined in this new set are controlled on a stream basis. The PROPSETID_H245COMMAND property set contains the following properties: KSPROPERTY_H245COMMAND_VIDEOFASTUPDATEPICTURE  Used to command the compressed video output stream to enter the fast-update picture mode at its earliest opportunity. This is a write-only property. KSPROPERTY_H245COMMAND_VIDEOFASTUPDATEGOB  Used to command the compressed video output stream to perform a fast update of one or more GOBs. This is a write-only property. KSPROPERTY_H245COMMAND_VIDEOFASTUPDATEMB  Used to command the compressed video output stream to perform a fast update of one or more MBs. This is a write-only property. KSPROPERTY_H245COMMAND_SENDSYNCEVERYGOB  Used to command the compressed video output stream to perform a fast update of one or more GOBs. This is a write-only property. KSPROPERTY_H245INDICATION_VIDEONOTDECODEDMB  Used to command the compressed video output stream to perform a fast update of one or more GOBs. This is a write-only property. videoFastUpdatePicture command This H.245 command is used to specify to the compressed video output pin to enter the fast-update picture mode at its earliest opportunity. To handle this command, we define the videoFastUpdatePicture method on the IH245EncoderCommand interface as follows: HRESULT videoFastUpdatePicture() This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_NOTIMPL Method is not supported NOERROR No error This command shall be used with all video compression algorithms as a generic way to generate a keyframe (I-frame). The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The first parameter is a pointer to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_H245COMMAND, a KSPROPERTY.Id field set to KSPROPERTY_H245COMMAND_VIDEOFASTUPDATEPICTURE and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_SET. videoFastUpdateGOB command This H.245 command is used to specify to the compressed video output pin to perform a fast update of one or more GOBs. To handle this command, we define the videoFastUpdateGOB method on the IH245EncoderCommand interface as follows: HRESULT videoFastUpdateGOB([IN]DWORD dwFirstGOB, [IN]DWORD dwNumberOfGOBs) where dwFirstGOB  Specifies the number of the first GOB to be updated. This value is only valid between 0 and 17.  dwNumberOfGOBs  Specifies the number of GOBs to be updated. This value is only valid between 1 and 18.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error This command shall only be used with video compression algorithms that define GOBs such as H.261 and H.263. The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_H245COMMAND, a KSPROPERTY.Id field set to KSPROPERTY_H245COMMAND_VIDEOFASTUPDATEGOB and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_SET. The PropertyData parameter points to  a VIDEOFASTUPDATEGOB_S structure defined as follows: typedef struct {     DWORD         dwFirstGOB;     DWORD         dwNumberOfGOBs; } VIDEOFASTUPDATEGOB_S; where dwFirstGOB  Specifies the number of the first GOB to be updated. This value is only valid between 0 and 17.  dwNumberOfGOBs  Specifies the number of GOBs to be updated. This value is only valid between 1 and 18.  videoFastUpdateMB command This H.245 command is used to specify to the compressed video output pin to perform a fast update of one or more MBs. To handle this command, we define the videoFastUpdateMB method on the IH245EncoderCommand interface as follows: HRESULT videoFastUpdateMB([IN]DWORD dwFirstGOB, [IN]DWORD dwFirstMB, [IN]DWORD dwNumberOfMBs) where dwFirstGOB  Specifies the number of the first GOB to be updated and is only relative to H.263. This value is only valid between 0 and 255. dwFirstMB  Specifies the number of the first MB to be updated and is only relative to H.261. This value is only valid between 1 and 8192.  dwNumberOfMBs  Specifies the number of MBs to be updated. This value is only valid between 1 and 8192.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error This command shall only be used with video compression algorithms that define MBs such as H.261 and H.263. The encoder may respond to this command with a GOB update which includes the MBs requested. The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_H245COMMAND, a KSPROPERTY.Id field set to KSPROPERTY_H245COMMAND_VIDEOFASTUPDATEMB and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_SET. The PropertyData parameter points to  a VIDEOFASTUPDATEMB_S structure defined as follows: The VIDEOFASTUPDATEMB_S structure is defined as follows: typedef struct {     DWORD         dwFirstGOB;     DWORD         dwFirstMB;     DWORD         dwNumberOfMBs; } VIDEOFASTUPDATEMB_S; where dwFirstGOB  Specifies the number of the first GOB to be updated and is only relative to H.263. This value is only valid between 0 and 255. dwFirstMB  Specifies the number of the first MB to be updated and is only relative to H.261. This value is only valid between 1 and 8192.  dwNumberOfMBs  Specifies the number of MBs to be updated. This value is only valid between 1 and 8192.  videoSendSyncEveryGOB and videoSendSyncEveryGOBCancel commands The videoSendSyncEveryGOB H.245 command is used to specify to the compressed video output pin to use sync for every GOB as defined in H.263. Reciprocally, the videoSendSyncEveryGOBCancel command is used to allow the video output pin to decide the frequency of GOB syncs. To handle these commands, we define the videoSendSyncEveryGOB method on the IH245EncoderCommand interface as follows: HRESULT videoSendSyncEveryGOB([IN]BOOL fEnable) where fEnable  If set to TRUE, specifies that the video output pin should use sync for every GOB; if set to FALSE, specifies that the video output pin should decide the frequency of GOB syncs on its own. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_NOTIMPL Method is not supported NOERROR No error This command shall only be used with video encoded according to H.263. The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_H245COMMAND, a KSPROPERTY.Id field set to KSPROPERTY_H245COMMAND_SENDSYNCEVERYGOB and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_SET. The PropertyData parameter points to a boolean. If set to TRUE, this boolean specifies that the video output stream should use sync for every GOB; if set to FALSE, it specifies that the video output stream should decide the frequency of GOB syncs on its own. videoNotDecodedMBs indication This H.245 indication is used to indicate to the compressed video output pin that a set of MBs has been received with errors and that any MB in the specified set has been treated as not coded. To handle this indication, we define the videoNotDecodedMBs method on the IH245EncoderCommand interface as follows: HRESULT videoNotDecodedMBs([IN]DWORD dwFirstMB, [IN]DWORD dwNumberOfMBs, [IN]DWORD dwTemporalReference) where dwFirstMB  Specifies the number of the first MB treated as not coded. This value is only valid between 1 and 8192. dwNumberOfMBs  Specifies the number of MBs treated as not coded. This value is only valid between 1 and 8192. dwTemporalReference  Specifies the temporal reference of the picture containing not decoded MBs. This value is only valid between 0 and 255. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error This compressed video output pin may use this information to compensate transmission errors, as illustrated in Appendix II of H.263. The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_H245COMMAND, a KSPROPERTY.Id field set to KSPROPERTY_H245INDICATION_VIDEONOTDECODEDMBS and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_SET. The PropertyData parameter points to  a VIDEONOTDECODEDMBS_S structure defined as follows: The VIDEONOTDECODEDMBS_S structure is defined as follows: typedef struct {     DWORD         dwFirstMB;     DWORD         dwNumberOfMBs;     DWORD         dwTemporalReference; } VIDEONOTDECODEDMBS_S; where dwFirstMB  Specifies the number of the first MB treated as not coded. This value is only valid between 1 and 8192.  dwNumberOfMBs  Specifies the number of MBs treated as not coded. This value is only valid between 1 and 8192.  dwTemporalReference  Specifies the temporal reference of the picture containing not decoded MBs. This value is only valid between 0 and 255.  FlowControl command The flow control command is used to allow the bit rate of the video stream to be controlled by the remote endpoint. This has a number of purposes: interworking with terminals that only support a finite number of bit rates; multi-point applications where the rates from different sources should be matched; and flow control is congested. This command is propagated to the compressed video output pin using the IBitrateControl::SetMaxBitrate method as described in section   REF _Ref431542650 \r \h  9.2.4.1 videoTemporalSpatialTradeOff  command The temporal/spatial trade-off command is used by a remote endpoint to indicate preferences in terms of video quality vs. frame rate. This command is not propagated directly to the compressed video output pin. Instead, and only if necessary, the TAPI MSP dynamically adjusts the frame rate on the compressed video output pin using the IFrameRateControl::SetMaxFrameRate method as described in section   REF _Ref431534800 \r \h  9.2.5.1 H.245 mode requests The mode request procedures allow a terminal to request a remote terminal to use a particular mode of operation in its transmit direction. The TAPI MSP does not propagate those requests down to the compressed video output pin. Instead, new formats are set on the compressed video output pins, based on the content of the video mode request. The TAPI MSP Video Capture filter handles this operation dynamically, without pausing or stopping the streams, whenever possible. INetworkStats interface Compressed video output streams may have smart ways to improve their resiliency to packet loss. They may decide to code their data in different ways or use some specific redundancy payload definitions to provide better error resilience. Compressed video or still-image output pins may support the INetworkStats interface that can be used to communicate the network channel characteristics (losses). The INetworkStats interface methods are called by the TAPI video capture filter periodically based on monitored network performances. The compressed output pin is responsible for taking appropriate actions, if needed. The INetworkStats interface contains the following methods: SetChannelErrors  Used to inform the compressed output pin of the error channel conditions.  GetChannelErrors Used to supply to the network sink filter the error channel conditions the compressed output pin is currently setup for. GetChannelErrorsRange Used to retrieve support, minimum, maximum, and default values for the error channel conditions the compressed output pin may be setup for. SetPacketLossRate Used to inform the compressed output pin of the channel packet loss rate. GetPacketLossRate Used to supply to the network sink filter the channel packet loss rate the compressed output pin is currently setup for. GetPacketLossRateRange Used to retrieve support, minimum, maximum, and default values for the channel packet loss rate the compressed output pin may be setup for. The INetworkStats interface is not a standard DirectShow interface. The TAPI MSP Video Capture filter implements this interface using the generic IKsControl interface and a property set called PROPSETID_NETWORKSTATS. The properties defined in this new set are controlled on a stream basis. The PROPSETID_NETWORKSTATS property set contains the following properties: KSPROPERTY_NETWORKSTATS_CHANNELERRORS  Used to inform the compressed output pin of the error channel conditions, or supply to the network sink filter the error channel conditions the compressed video output pin is currently setup for. This is a read/write property. KSPROPERTY_NETWORKSTATS_PACKETLOSSRATE Used to inform the compressed output pin of the channel packet loss rate, or supply to the network sink filter the packet loss rate the compressed video output pin is currently setup for. This is a read/write property.  To set and retrieve values for the first property, the following structure is defined: typedef struct {     DWORD      dwRandomBitErrorRate;     DWORD      dwBurstErrorDuration;     DWORD      dwBurstErrorMaxFrequency; } CHANNELERRORS; where dwRandomBitErrorRate Specifies the random bit error rate of the channel in multiples of 10-6.  dwBurstErrorDuration Specifies the duration for short burst errors in ms.  dwBurstErrorMaxFrequency Specifies the maximum frequency for short burst errors in Hz.  SetChannelErrors method This network statistics method is used to inform the compressed output pin of the error channel conditions. The SetChannelErrors method is declared as follows: HRESULT SetChannelErrors([IN]CHANNELERRORS *pChannelErrors, [IN]DWORD dwLayerId) where pChannelErrors Specifies the error channel conditions.  dwLayerId Specifies the ID of the encoding layer the error channel conditions apply to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_NETWORKSTATS, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_NETWORKSTATS_CHANNELERRORS and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_SET and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the error channel conditions apply to. The PropertyData parameter points to  a CHANNELERRORS structure. GetChannelErrors method This network statistics method is used to supply to the network sink filter the error channel conditions the compressed output pin is currently setup for. The GetChannelErrors method is declared as follows: HRESULT GetChannelErrors([OUT]CHANNELERRORS *pChannelErrors, [IN]DWORD dwLayerId) where pChannelErrors Specifies a pointer to a structure to receive error channel conditions.  dwLayerId Specifies the ID of the encoding layer the error channel conditions apply to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_NETWORKSTATS, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_NETWORKSTATS_CHANNELERRORS and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_GET and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the error channel conditions apply to. The PropertyData parameter points to  a CHANNELERRORS structure. GetChannelErrorsRange method This CPU control method is used to retrieve support, minimum, maximum, and default values for the channel error conditions the compressed output pin may be setup for. The GetChannelErrorsRange method is declared as follows: HRESULT GetChannelErrorsRange([OUT]CHANNELERRORS *pMin, [OUT]CHANNELERRORS *pMax, [OUT]CHANNELERRORS *pSteppingDelta, [OUT]CHANNELERRORS *pDefault, [IN]DWORD dwLayerId) where Used to retrieve the minimum values of channel error conditions the compressed video output pin maybe setup for.  Used to retrieve the maximum values of channel error conditions the compressed video output pin maybe setup for.  pSteppingDelta Used to retrieve the stepping delta values of channel error conditions the compressed video output pin maybe setup for.  pDefault Used to retrieve the default  values of channel error conditions the compressed video output pin maybe setup for.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty twice. The first call retrieves the minimum, maximum and stepping values. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_NETWORKSTATS, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_NETWORKSTATS_CHANNELERRORS and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_BASICSUPPORT and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the error channel conditions apply to. The PropertyData parameter points to  a KSCHANNELERRORS_LIST_S structure defined as follows: typedef struct {   KSPROPERTY_DESCRIPTION   PropertyDescription;   KSPROPERTY_MEMBERSHEADER MembersHeader;   union {     KSPROPERTY_STEPPING_LONG SteppingRandomBitErrorRate;     LONG DefaultRandomBitErrorRate;   union {     KSPROPERTY_STEPPING_LONG SteppingBurstErrorDuration;     LONG DefaultBurstErrorDuration;   union {     KSPROPERTY_STEPPING_LONG SteppingBurstErrorMaxFrequency;     LONG DefaultBurstErrorMaxFrequency; } KSCHANNELERRORS_LIST_S; where PropertyDescription Specifies access flags (KSPROPERTY_TYPE_GET and KSPROPERTY_TYPE_SET), the inclusive size of the entire values information, the property value type information, and the number of members lists that would typically follow the structure.  MembersHeader Used to provide information on a property member header.  RandomBitErrorRate Used to specify values for random bit error rate.  BurstErrorDuration Used to specify values for short burst errors.  BurstErrorMaxFrequency Used to specify values for the maximum frequency for short burst errors.  The second call retrieves the default values. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_NETWORKSTATS, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_NETWORKSTATS_CHANNELERRORS and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_DEFAULTVALUES and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the error channel conditions apply to. The PropertyData parameter points to  a KSCHANNELERRORS_LIST_S structure. SetPacketLossRate method This network statistics method is used to inform the compressed output pin of the channel packet loss rate. The SetPacketLossRate method is declared as follows: HRESULT SetPacketLossRate([IN]DWORD dwPacketLossRate, [IN]DWORD dwLayerId) where dwPacketLossRate Specifies the packet loss rate of the channel in multiples of 10-6.  dwLayerId Specifies the ID of the encoding layer the error channel packet loss rate applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_NETWORKSTATS, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_NETWORKSTATS_PACKETLOSSRATE and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_SET and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the channel packet loss rate applies to. The PropertyData parameter points to  a DWORD specifying the packet loss rate of the channel in multiples of 10-6. GetPacketLossRate method This network statistics method is used to supply to the network sink filter the packet loss rate channel conditions the compressed output pin is currently setup for. The GetPacketLossRate method is declared as follows: HRESULT GetPacketLossRate([OUT]DWORD *pdwPacketLossRate, [IN]DWORD dwLayerId) where pdwPacketLossRate Specifies a pointer to a DWORD to receive the packet loss rate of the channel the compressed output pin is currently setup for in multiples of 10-6.  dwLayerId Specifies the ID of the encoding layer the packet loss rate applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_NETWORKSTATS, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_NETWORKSTATS_PACKETLOSSRATE and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_GET and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the channel packet loss rate applies to. The PropertyData parameter points to a DWORD to receive the packet loss rate of the channel in multiples of 10-6 the compressed output pin is currently setup for. GetPacketLossRateRange method This CPU control method is used to retrieve support, minimum, maximum, and default values for the packet loss rate conditions the compressed output pin may be setup for. The GetPacketLossRateRange method is declared as follows: HRESULT GetPacketLossRateRange([OUT]DWORD *pMin, [OUT]DWORD *pMax, [OUT]DWORD *pSteppingDelta, [OUT]DWORD *pDefault, [IN]DWORD dwLayerId) where Used to retrieve the minimum packet loss rate the compressed video output pin maybe setup for.  Used to retrieve the maximum packet loss rate the compressed video output pin maybe setup for.  pSteppingDelta Used to retrieve the stepping delta values of packet loss rate the compressed video output pin maybe setup for.  pDefault Used to retrieve the default packet loss rate the compressed video output pin is setup for.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty twice. The first call retrieves the minimum, maximum and stepping values. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_NETWORKSTATS, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_NETWORKSTATS_PACKETLOSSRATE and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_BASICSUPPORT and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the packet loss rate of the channel applies to. The PropertyData parameter points to  a KSPROPERTY_LIST_S structure. The output stream updates the KSPROPERTY_LIST_S.SteppingLong field with the appropriate minimum, maximum, and stepping delta values. The second call retrieves the default values. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_NETWORKSTATS, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_NETWORKSTATS_PACKETLOSSRATE and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_DEFAULTVALUES and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the packet loss rate of the channel applies to. The PropertyData parameter points to  a KSPROPERTY_LIST_S structure. The output stream updates the KSPROPERTY_LIST_S.DefaultLong field with the appropriate default value. ICPUControl interface Compressed video output streams may also support the optional ICPUControl interface in order to receive bounds on the encoding time (latency) and CPU load that should not be exceeded during the compression process. The methods on this interface are called at the beginning of a call to initialize the maximum CPU load and frame encoding time, and then periodically by the TAPI MSP Quality Controller during the entire call. The initial and limit values for the maximum CPU load and frame encoding time are based on user-defined settings provided by the application. The ICPUControl interface contains the following methods: SetMaxProcessingTime  Used to specify to the compressed video output pin the maximum encoding time per frame, in 100-nanosecond units. GetMaxProcessingTime Used to retrieve the maximum encoding time per frame the compressed video output pin is currently setup for, in 100-nanosecond units. GetMaxProcessingTimeRange Used to retrieve support, minimum, maximum, and default values for the maximum encoding time per frame the compressed video output pin may be setup for, in 100-nanosecond units. SetMaxCPULoad  Used to specify to the compressed video output pin the maximum encoding algorithm CPU load. GetMaxCPULoad Used to retrieve the maximum encoding algorithm CPU load the compressed video output pin is currently setup for. GetMaxCPULoadRange Used to retrieve support, minimum, maximum, and default values for the maximum CPU load the compressed video output pin may be setup for, in 100-nanosecond units. The optional ICPUControl interface is not a standard DirectShow interface. The TAPI MSP Video Capture filter implements this interface using the generic IKsControl interface and a property set called PROPSETID_CPUCONTROL. The properties defined in this new set are controlled on a stream basis. The PROPSETID_CPUCONTROL property set contains the following properties: KSPROPERTY_CPUCONTROL_MAXPROCESSINGTIME  Used to specify to the compressed video output pin the maximum encoding time per frame, or supply to the TAPI MSP Quality Controller the maximum encoding time per frame the compressed video output pin is currently setup for. This is a read/write property. KSPROPERTY_CPUCONTROL_MAXCPULOAD Used to specify to the compressed video output pin the maximum encoding algorithm CPU load, or supply to the TAPI MSP Quality Controller the maximum encoding algorithm CPU load the compressed video output pin is currently setup for. This is a read/write property. SetMaxProcessingTime method This CPU control method is used to specify to the compressed video output pin the maximum encoding time per frame. The SetMaxProcessingTime method is declared as follows: HRESULT SetMaxProcessingTime([IN]REFERENCE_TIME MaxProcessingTime) where MaxProcessingTime Specifies the maximum encoding time per frame, in 100-nanosecond units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_CPUCONTROL, a KSPROPERTY.Id field set to KSPROPERTY_CPUCONTROL_MAXPROCESSINGTIME and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_SET. The PropertyData parameter points to a REFERENCE_TIME value specifying the maximum encoding time per frame, in 100-nanosecond units. GetMaxProcessingTime method This CPU control method is used to retrieve the maximum encoding time per frame the compressed video output pin is currently setup for or for an hypothetical CPU load. The GetMaxProcessingTime method is declared as follows: HRESULT GetMaxProcessingTime([OUT]REFERENCE_TIME *pMaxProcessingTime, [IN]DWORD dwMaxCPULoad) where pMaxProcessingTime Used to retrieve the maximum encoding time per frame the compressed video output pin is currently setup for, in 100-nanosecond units.  dwMaxCPULoad Specifies an hypothetical CPU load, in percentage units. If this parameter is set to -1, this method shall use the value of the CPU load  the compressed video output pin is currently setup for. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_CPUCONTROL, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_CPUCONTROL_MAXPROCESSINGTIME and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_GET and the KSPROPERTY_PARAM_S.dwParam set to -1 or an hypothetical CPU load, in percentage units. The PropertyData parameter points to a REFERENCE_TIME value to receive the maximum encoding time per frame, in 100-nanosecond units. GetMaxProcessingTimeRange method This CPU control method is used to retrieve support, minimum, maximum, and default encoding time per frame the compressed video output pin may be setup for or for an hypothetical CPU load. The GetMaxProcessingTimeRange method is declared as follows: HRESULT GetMaxProcessingTimeRange([OUT]REFERENCE_TIME *pMin, [OUT]REFERENCE_TIME *pMax, [OUT]REFERENCE_TIME *pSteppingDelta, [OUT]REFERENCE_TIME *pDefault, [IN]DWORD dwMaxCPULoad) where Used to retrieve the minimum value of encoding time per frame the compressed video output pin maybe setup for, in 100-nanosecond units.  Used to retrieve the maximum value of encoding time per frame the compressed video output pin maybe setup for, in 100-nanosecond units.  pSteppingDelta Used to retrieve the stepping delta of encoding time per frame the compressed video output pin maybe setup for, in 100-nanosecond units.  pDefault Used to retrieve the default value of encoding time per frame the compressed video output pin is setup for, in 100-nanosecond units.  dwMaxCPULoad Specifies an hypothetical CPU load, in percentage units. If this parameter is set to -1, this method shall use the value of the CPU load  the compressed video output pin is currently setup for. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty twice. The first call retrieves the minimum, maximum and stepping values. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_CPUCONTROL, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_CPUCONTROL_MAXPROCESSINGTIME and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_BASICSUPPORT and the KSPROPERTY_PARAM_S.dwParam set to -1 or an hypothetical CPU load, in percentage units. The PropertyData parameter points to  a KSPROPERTY_LIST_S structure. The output stream updates the KSPROPERTY_LIST_S.SteppingLongLong field with the appropriate minimum, maximum, and stepping delta values. The second call retrieves the default value. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_CPUCONTROL, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_CPUCONTROL_MAXPROCESSINGTIME and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_DEFAULTVALUES and the KSPROPERTY_PARAM_S.dwParam set to -1 or an hypothetical CPU load, in percentage units. The PropertyData parameter points to  a KSPROPERTY_LIST_S structure. The output stream updates the KSPROPERTY_LIST_S.DefaultLongLong field with the appropriate default value. SetMaxCPULoad method This CPU control method is used to specify to the compressed video output pin the maximum encoding algorithm CPU load. The SetMaxCPULoad method is declared as follows: HRESULT SetMaxCPULoad([IN]DWORD dwMaxCPULoad) where dwMaxCPULoad Specifies the maximum encoding algorithm CPU load, in percentage units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_CPUCONTROL, a KSPROPERTY.Id field set to KSPROPERTY_CPUCONTROL_MAXCPULOAD and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_SET. The PropertyData parameter points to a DWORD value that specifies the maximum encoding algorithm CPU load, in percentage units. GetMaxCPULoad method This CPU control method is used to retrieve the maximum encoding algorithm CPU load the compressed video output pin is currently setup for or for an hypothetical maximum encoding time per frame. The GetMaxCPULoad method is declared as follows: HRESULT GetMaxCPULoad([OUT]DWORD *pdwMaxCPULoad, [IN]REFERENCE_TIME MaxProcessingTime) where pdwMaxCPULoad Used to retrieve the maximum encoding algorithm CPU load the compressed video output pin is currently setup for, in percentage units.  MaxProcessingTime Specifies an hypothetical maximum encoding time per frame, in 100-nanosecond units. If this parameter is set to -1, this method shall use the value of the maximum encoding time per frame the compressed video output pin is currently setup for. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_CPUCONTROL, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_CPUCONTROL_MAXCPULOAD and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_GET and the KSPROPERTY_PARAM_S.llParam set to -1 or an hypothetical maximum encoding time per frame, in 100-nanosecond units. The PropertyData parameter points to a DWORD value to receive the maximum encoding algorithm CPU load, in percentage units. GetMaxCPULoadRange method This CPU control method is used to retrieve support, minimum, maximum, and default encoding algorithm CPU load the compressed video output pin may be setup for or for an hypothetical maximum encoding time per frame. The GetMaxCPULoadRange method is declared as follows: HRESULT GetMaxCPULoadRange([OUT]DWORD *pMin, [OUT]DWORD *pMax, [OUT]DWORD *pSteppingDelta, [OUT]DWORD *pDefault, [IN]REFERENCE_TIME MaxProcessingTime) where Used to retrieve the minimum value of encoding algorithm CPU load the compressed video output pin maybe setup for, in percentage units.  Used to retrieve the maximum value of encoding algorithm CPU load the compressed video output pin maybe setup for, in percentage units.  pSteppingDelta Used to retrieve the stepping delta of encoding algorithm CPU load the compressed video output pin maybe setup for, in percentage units.  pDefault Used to retrieve the default value of encoding algorithm CPU load the compressed video output pin is setup for, in percentage units.  MaxProcessingTime Specifies an hypothetical maximum encoding time per frame, in 100-nanosecond units. If this parameter is set to -1, this method shall use the value of the maximum encoding time per frame the compressed video output pin is currently setup for. This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty twice. The first call retrieves the minimum, maximum and stepping values. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_CPUCONTROL, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_CPUCONTROL_MAXCPULOAD and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_BASICSUPPORT and the KSPROPERTY_PARAM_S.llParam set to -1 or an hypothetical maximum encoding time per frame, in 100-nanosecond units. The PropertyData parameter points to  a KSPROPERTY_LIST_S structure. The output stream updates the KSPROPERTY_LIST_S.SteppingLong field with the appropriate minimum, maximum, and stepping delta values. The second call retrieves the default value. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_CPUCONTROL, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_CPUCONTROL_MAXCPULOAD and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_DEFAULTVALUES and the KSPROPERTY_PARAM_S.llParam set to -1 or an hypothetical maximum encoding time per frame, in 100-nanosecond units. The PropertyData parameter points to  a KSPROPERTY_LIST_S structure. The output stream updates the KSPROPERTY_LIST_S.DefaultLong field with the appropriate default value. IBitrateControl interface The IBitrateControl interface specifies a maximum bitrate to the compressed video output stream. The methods on this interface are called at the beginning of a call by the TAPI MSP Quality Controller to initialize the target bitrate, and then periodically during the entire call. The dynamic values for the target bitrates are based on network statistics provided by the TAPI MSP Network Sink filter to the TAPI MSP Quality Controller. The initial and limit values for the target bitrate are based on user-defined settings provided by the application to the TAPI MSP Quality Controller and the result of capability negotiations between the two connected endpoints provided by the TAPI MSP Channel Controller. Note that the IBitrateControl::SetMaxBitrate is also called by the TAPI MSP Channel Controller whenever it receives a FlowControl command. The IBitrateControl interface contains the following methods: SetMaxBitrate  Used to specify to the compressed video output pin the upper limit in bandwidth transmission. GetMaxBitrate Used to retrieve the upper limit in bandwidth transmission the compressed video output pin is currently setup for. GetMaxBitrateRange Used to retrieve support, minimum, maximum, and default values for the upper limit in bandwidth transmission the compressed video output pin may be setup for. The IBitrateControl interface is not a standard DirectShow interface. The TAPI MSP Video Capture filter implements this interface using the generic IKsControl interface and a property set called PROPSETID_BITRATECONTROL. The properties defined in this new set are controlled on a stream basis. The PROPSETID_ BITRATECONTROL property set contains the following property: KSPROPERTY_BITRATECONTROL_MAXBITRATE  Used to specify to the compressed video output pin the upper limit in bandwidth transmission, or supply to the TAPI MSP Quality Controller the upper limit in bandwidth transmission the compressed video output pin is currently setup for. This is a read/write property. SetMaxBitrate method This bitrate control method is used to specify to the compressed video output pin the upper limit in bandwidth transmission. The SetMaxBitrate method is declared as follows: HRESULT SetMaxBitrate([IN]DWORD dwMaxBitrate, [IN]DWORD dwLayerId) where dwMaxBitrate Specifies the new upper limit in bandwidth transmission in bits/s.  dwLayerId Specifies the ID of the encoding layer the new upper limit in bandwidth transmission applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Whenever this method is called, the compressed video output pin updates its internal compression parameters accordingly (e.g., quantization parameters) to generate compressed data at the new target bitrate.  Compression parameters are adjusted independently of network protocol overhead. The dwMaxBitrate value characterizes the target bitrate without the RTP/UDP/IP network stream headers. Note that both the TAPI MSP Channel Controller (FlowControl H.245 command) and TAPI MSP Quality Controller may call upon this method to adjust the output bitrate of the compressed video output pin. The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_BITRATECONTROL, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_BITRATECONTROL_MAXBITRATE, KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_SET and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the upper limit in bandwidth transmission applies to. The PropertyData parameter points to a DWORD specifying the upper limit in bandwidth transmission in bits/s. GetMaxBitrate method This method is used to retrieve the upper limit in bandwidth transmission the compressed video output pin is currently setup for. The GetMaxBitrate method is declared as follows: HRESULT GetMaxBitrate([OUT]DWORD *pdwMaxBitrate, [IN]DWORD dwLayerId) where pdwMaxBitrate Used to receive to the compressed video output pin the upper limit in bandwidth transmission in bits/s.  dwLayerId Specifies the ID of the encoding layer the new upper limit in bandwidth transmission applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_BITRATECONTROL, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_BITRATECONTROL_MAXBITRATE, KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_GET and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the upper limit in bandwidth transmission applies to. The PropertyData parameter points to a DWORD to receive the upper limit in bandwidth transmission in bits/s. GetMaxBitrateRange method This method is used to retrieve support, minimum, maximum, and default values for the upper limit in bandwidth transmission the compressed video output pin may be setup for. The GetMaxBitrateRange method is declared as follows: HRESULT GetMaxBitrateRange([OUT]DWORD *pMin, [OUT]DWORD *pMax, [OUT]DWORD *pSteppingDelta, [OUT]DWORD *pDefault, [IN]DWORD dwLayerId) where Used to retrieve the minimum limit in bandwidth transmission the compressed video output pin maybe setup for, in bits/s.  Used to retrieve the maximum limit in bandwidth transmission the compressed video output pin maybe setup for, in bits/s.  pSteppingDelta Used to retrieve the stepping delta in bandwidth transmission the compressed video output pin maybe setup for, in bits/s.  pDefault Used to retrieve the default limit in bandwidth transmission the compressed video output pin is setup for, in bits/s.  dwLayerId Specifies the ID of the encoding layer the command applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty twice. The first call retrieves the minimum, maximum and stepping values. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_BITRATECONTROL, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_BITRATECONTROL_MAXBITRATE and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_BASICSUPPORT and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the command applies to. The PropertyData parameter points to  a KSPROPERTY_LIST_S structure. The output stream updates the KSPROPERTY_LIST_S.SteppingLong field with the appropriate minimum, maximum, and stepping delta values. The second call retrieves the default value. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_BITRATECONTROL, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_BITRATECONTROL_MAXBITRATE and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_DEFAULTVALUES and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the command applies to. The PropertyData parameter points to  a KSPROPERTY_LIST_S structure. The output stream updates the KSPROPERTY_LIST_S.DefaultLong field with the appropriate default value. IFrameRateControl interface The IFrameRateControl interface specifies a target frame rate to the preview or compressed video output pins. The methods on this interface are called at the beginning of a call by the TAPI MSP Quality Controller to initialize the target frame rates, and then periodically during the entire call. The dynamic values for the target frame rates are based on the TAPI MSP Quality Controller CPU usage measurements using NT s CPU performance counters, as well as the past performance of the output bitrate controller. The initial and limit values for the target frame rate are based on user-defined settings provided by the application to the TAPI MSP Quality Controller and the result of capability negotiations between the two connected endpoints provided by the TAPI MSP Channel Controller. The IFrameRateControl interface contains the following methods: SetMaxFrameRate  Used to specify to the preview or compressed video output pin the video frame's average display time. GetMaxFrameRate Used to retrieve the video frame's average display time the preview or compressed video output pin are currently setup for. GetMaxFrameRateRange Used to retrieve support, minimum, maximum, and default values for the video frame's average display time the preview or compressed video output pin may be setup for. The IFrameRateControl interface is not a standard DirectShow interface. The TAPI MSP Video Capture filter implements this interface using the generic IKsControl interface and a property set called PROPSETID_FRAMERATECONTROL. The properties defined in this set are handled on a stream basis, allowing for different frame rates on the preview and compressed video output pins. The PROPSETID_ FRAMERATECONTROL property set contains the following property: KSPROPERTY_FRAMERATECONTROL_MAXFRAMERATE  Used to specify to the preview or compressed video output pin the video frame's average display time, or supply to the TAPI MSP Quality Controller the video frame's average display time the preview or compressed video output pin are currently setup for. This is a read/write property. SetMaxFrameRate method This frame rate control method is used to specify to the preview or compressed video output pin the video frame s average display time. The SetMaxFrameRate method is declared as follows: HRESULT SetMaxFrameRate([IN]REFERENCE_TIME AvgTimePerFrame) where AvgTimePerFrame  Specifies a REFERENCE_TIME value that indicates the video frame's average display time, in 100-nanosecond units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error Whenever this method is called, the compressed video output pin updates its internal compression parameters accordingly (e.g., quantization parameters) maintain a constant bitrate as specified in VIDEOINFOHEADER_H263.dwBitRate or the last call to IBitrateControl::SetMaxBitrate.  The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_FRAMERATECONTROL, a KSPROPERTY.Id field set to KSPROPERTY_FRAMERATECONTROL_MAXFRAMERATE and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_SET. The PropertyData parameter points to a REFERENCE_TIME value that specifies the video frame's average display time, in 100-nanosecond units. GetMaxFrameRate method This method is used to retrieve the video frame's average display time the preview or compressed video output pin is currently setup for. The GetMaxFrameRate method is declared as follows: HRESULT GetMaxFrameRate([OUT]REFERENCE_TIME *pAvgTimePerFrame) where pAvgTimePerFrame Used to receive a REFERENCE_TIME value that indicates the video frame's average display time, in 100-nanosecond units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_FRAMERATECONTROL, a KSPROPERTY.Id field set to KSPROPERTY_FRAMERATECONTROL_MAXFRAMERATE and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_GET. The PropertyData parameter points to a REFERENCE_TIME value to receive video frame's average display time, in 100-nanosecond units. GetMaxFrameRateRange method This method is used to retrieve the minimum, maximum, and default values for the video frame average display time the preview or compressed video output pin may be setup for. The GetMaxFrameRateRange method is declared as follows: HRESULT GetMaxFrameRateRange([OUT]REFERENCE_TIME *pMin, [OUT]REFERENCE_TIME *pMax, [OUT]REFERENCE_TIME *pSteppingDelta, [OUT]REFERENCE_TIME *pDefault) where Used to retrieve the minimum video frame display time, in 100-nanosecond units.  Used to retrieve the maximum video frame display time, in 100-nanosecond units.  pSteppingDelta Used to retrieve the stepping delta in video frame display time, in 100-nanosecond units.  pDefault Used to retrieve the default video frame display time, in 100-nanosecond units.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the video output stream by calling IKsControl::KsProperty twice. The first call retrieves the minimum, maximum and stepping values. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_FRAMERATECONTROL, a KSPROPERTY.Id field set to KSPROPERTY_FRAMERATECONTROL_MAXFRAMERATE and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_BASICSUPPORT. The PropertyData parameter points to  a KSPROPERTY_LIST_S structure. The output stream updates the KSPROPERTY_LIST_S.SteppingLongLong field with the appropriate minimum, maximum, and stepping delta values. The second call retrieves the default value. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_FRAMERATECONTROL, a KSPROPERTY.Id field set to KSPROPERTY_FRAMERATECONTROL_MAXFRAMERATE and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_DEFAULTVALUES. The PropertyData parameter points to  a KSPROPERTY_LIST_S structure. The output stream updates the KSPROPERTY_LIST_S.DefaultLongLong field with the appropriate default value. IProgressiveRefinement interface H.245 progressive refinement commands exist to allow for transmission of high resolution still images that are continuously improved on the remote endpoint as more data is received and decompressed. In order to handle those commands, the compressed video output pin provides the TAPI MSP Channel Controller with a pointer to an IProgressiveRefinement interface. The IProgressiveRefinement interface is defined in section   REF _Ref429812311 \r \h  Video preview output pin TAPI interfaces This section documents the list of video preview output pin TAPI interfaces indirectly exposed to applications. Those applications use TAPI IT* interfaces whose method calls are delegated to the interfaces presented here. We distinguish between VfW and WDM capture devices that only provide the ICPUControl interface to control the maximum capture and post-processing time per frame and CPU load not be exceeded by the capture device for preview, and the IFrameRateControl interface to initialize and regulate the frame rate of the preview output pin; and Videoconferencing Accelerators that natively support those interfaces on their preview output pin. VfW and WDM capture device preview output pin TAPI interfaces The TAPI MSP Video Capture filter exposes two interfaces supported by its preview video output pin to the TAPI MSP Quality Controller. The TAPI MSP Quality Controller uses the optional ICPUControl interface to initialize and adjust the maximum capture and post-processing time per frame and CPU load not be exceeded by the capture device preview pin. Similarly, it uses the IFrameRateControl interface to initialize and regulate the frame rate of the preview video output pin. The TAPI MSP calls QueryInterface on the IPin interface exposed by the preview output pin of the TAPI MSP Video Capture filter to get pointers to the ICPUControl and IFrameRateControl interfaces. ICPUControl interface Preview output pins may implement the optional ICPUControl interface. The methods on this interface are called at the beginning of a call to initialize the maximum CPU load and frame post-processing time, and then periodically by the TAPI MSP Quality Controller during the entire call. The initial and limit values for the maximum CPU load and frame post-processing time are based on user-defined settings provided by the application. See section   REF _Ref443191700 \r \h  9.2.3  for more information on the ICPUControl interface definition. For VfW frame grabbing devices, the post-processing time is composed of the time spent between the request for a grab occurred and the moment the frame was returned from the capture device, the black banding code execution time, as well as the color conversion code execution time if the native video capture device format requires a conversion from YUV to RGB for instance. For VfW streaming devices, the post-processing time only measures the black banding code time and color conversion time. WDM capture devices are streaming devices. However, a lot of them appear to function better (less CPU usage) and easier to control when used in frame grabbing mode, that is, when there is only one outstanding overlapped IO. Here again, for WDM capture devices used in frame grabbing mode, the post-processing time is composed of the time spent between the request for a grab occurred and the moment the frame was returned from the capture device, the black banding code execution time and color conversion time. For WDM capture devices used in streaming mode, the post-processing time only measures the black banding code time and color conversion time. IFrameRateControl interface The IFrameRateControl interface specifies a target frame rate to the preview output pin of the video capture filter. The methods on this interface are called at the beginning of a call by the TAPI MSP Quality Controller to initialize the target frame rates, and then periodically during the entire call. The dynamic values for the target frame rates are based on the TAPI MSP Quality Controller CPU usage measurements using NT s CPU performance counters. The initial and limit values for the target frame rate are based on user-defined settings provided by the application to the TAPI MSP Quality Controller. The IFrameRateControl interface is defined in section   REF _Ref442843458 \r \h  9.2.5 For VfW frame grabbing devices, or WDM capture devices used in frame grabbing mode, the capture frame rate is adjusted by regulating the time between each request for a frame grab. VfW and WDM streaming devices are not able to easily adjust their capture frame rate on the fly. Therefore, VfW and WDM streaming capture devices are always asked to capture at 30fps, but only a fraction of those frames are delivered to the downstream filter, hence, achieving dynamic frame rate control.  Videoconferencing Accelerator preview output pin TAPI interfaces The TAPI MSP Video Capture filter exposes two interfaces supported by the preview output pin to the TAPI MSP Quality Controller. The TAPI MSP Quality Controller uses the optional ICPUControl interface to initialize and adjust the maximum post-processing time per frame and CPU load not to be exceeded by the TAPI MSP Video Capture filter for preview. Similarly, it uses the IFrameRateControl interface to initialize and regulate the frame rate of the preview video output pin. The TAPI MSP calls QueryInterface on the IPin interface exposed by the preview video output pin of the TAPI MSP Video Capture filter to get pointers to the ICPUControl and IFrameRateControl interfaces. The TAPI MSP Video Capture filter implements those interfaces by calling the IKsControl methods on the Videoconferencing Accelerator preview video output stream. The GUIDs of the PROPSETID_CPUCONTROL and PROPSETID_FRAMERATECONTROL property sets are defined as follows: PROPSETID_CPUCONTROL 63757063-5245-4945-5252-45464C494850 PROPSETID_FRAMERATECONTROL 63737066-5245-4945-5252-45464C494850 ICPUControl interface Preview output pins may implement the optional ICPUControl interface. The methods on this interface are called at the beginning of a call to initialize the maximum CPU load and frame post-processing time, and then periodically by the TAPI MSP Quality Controller during the entire call. The initial and limit values for the maximum CPU load and frame post-processing time are based on user-defined settings provided by the application. See section   REF _Ref443191700 \r \h  9.2.3  for more information on the ICPUControl interface. IFrameRateControl interface The IFrameRateControl interface specifies a target frame rate to the preview and compressed video output pins of the Videoconferencing Accelerator. The methods on this interface are called at the beginning of a call by the TAPI MSP Quality Controller to initialize the target frame rates, and then periodically during the entire call. The dynamic values for the target frame rates are based on the TAPI MSP Quality Controller CPU usage measurements using NT s CPU performance counters, as well as the past performance of the Videoconferencing Accelerator output bitrate controller. The initial and limit values for the target frame rate are based on user-defined settings provided by the application to the TAPI MSP Quality Controller and the result of capability negotiations between the two connected endpoints provided by the TAPI MSP Channel Controller. The IFrameRateControl interface is defined in section   REF _Ref442843458 \r \h  9.2.5 Compressed still-image output pin TAPI interfaces The TAPI MSP Video Capture filter exposes a few interfaces supported by the compressed still-image output pin directly to the TAPI MSP Channel Controller, the TAPI MSP Quality Controller,  or the TAPI MSP Network Sink filter. TAPI MSP Channel Controller uses the IProgressiveRefinement interface to communicate progressive refinement H.245 commands to the compressed video or still-image output pin. The network sink filter uses the INetworkStats interface to inform the compressed still-image output pin of the transmission channel conditions (packet loss ), as described in section   REF _Ref427926473 \r \h  9.2.2 . The TAPI MSP Quality Controller uses the optional ICPUControl interface to initialize and adjust the maximum encoding time per frame and CPU load not be exceeded by the encoder s compression algorithm, as defined in section   REF _Ref443191703 \r \h  9.2.3 . Similarly, it uses the IBitrateControl interface (introduced in section   REF _Ref442843459 \r \h  9.2.4 ) to initialize and regulate the outgoing bitrate of the compressed still-image output pin. The TAPI MSP calls QueryInterface on the IPin interface exposed by the still-image output pin of the TAPI MSP Video Capture filter to get pointers to the IProgressiveRefinement, INetworkStats, ICPUControl and IBitrateControl interfaces. The TAPI MSP Video Capture filter implements those interfaces calling the IKsControl methods exposed on the Videoconferencing Accelerator still-image output stream. Note that for VfW and traditional WDM capture devices, it is the encoder function that implements the IProgressiveRefinement, INetworkStats, ICPUControl and IBitrateControl interfaces. Therefore, those interfaces are only available on the TAPI MSP Video Capture filter if it isn t connected to a downstream installable codec. The GUIDs of the property sets discussed in this section are defined as follows: PROPSETID_NETWORKSTATS 7374656E-5245-4945-5252-45464C494850 PROPSETID_CPUCONTROL 63757063-5245-4945-5252-45464C494850 PROPSETID_BITRATECONTROL 63737062-5245-4945-5252-45464C494850 PROPSETID_PROGRESSIVEREFINEMENT 676F7270-5245-4945-5252-45464C494850 IProgressiveRefinement interface H.245 progressive refinement commands exist to allow for transmission of high resolution still images that are continuously improved on the remote endpoint as more data is received and decompressed. In order to handle those commands, the compressed still-image output pin provides the TAPI MSP Channel Controller with a pointer to an IProgressiveRefinement interface containing the following methods: doOneProgression Used to command the compressed still-image output pin to begin producing a progressive refinement sequence for one picture. doContinuousProgressions Used to command the compressed still-image output pin to begin producing progressive refinement sequences for several pictures. doOneIndependentProgression Used to command the compressed still-image output pin to begin an independent progressive refinement sequence for one Intra picture. doContinuousIndependentProgressions Used to command the compressed still-image output pin to begin an independent progressive refinement sequence several Intra pictures. progressiveRefinementAbortOne Used to command the compressed still-image output pin to terminate a progressive refinement sequence for the current picture. progressiveRefinementAbortContinuous Used to command the compressed still-image output pin to terminate a progressive refinement sequence for all pictures. These methods return an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_NOTIMPL Method is not supported NOERROR No error The IProgressiveRefinement interface is not a standard DirectShow interface. The TAPI MSP Video Capture filter implements this interface using the generic IKsControl interface and a property set called PROPSETID_PROGRESSIVEREFINEMENT. The properties defined in this set are controlled on a stream basis. The PROPSETID_PROGRESSIVEREFINEMENT property set contains the following properties: KSPROPERTY_PROGRESSIVEREFINEMENT_DOONEPROGRESSION Used to command the compressed still-image output stream to begin producing a progressive refinement sequence for one picture. This is a write-only property. KSPROPERTY_PROGRESSIVEREFINEMENT_DOCONTINUOUSPROGRESSIONS Used to command the compressed still-image output stream to begin producing progressive refinement sequences for several pictures. This is a write-only property. KSPROPERTY_PROGRESSIVEREFINEMENT_DOONEINDEPENDENTPROGRESSION Used to command the compressed still-image output stream to begin an independent progressive refinement sequence for one Intra picture. This is a write-only property. KSPROPERTY_PROGRESSIVEREFINEMENT_DOCONTINUOUSINDEPENDENTPROGRESSIONS Used to command the compressed still-image output stream to begin an independent progressive refinement sequence several Intra pictures. This is a write-only property. KSPROPERTY_PROGRESSIVEREFINEMENT_ABORTONE Used to command the compressed still-image output stream to terminate a progressive refinement sequence for the current picture. This is a write-only property. KSPROPERTY_PROGRESSIVEREFINEMENT_ABORTCONTINUOUS Used to command the compressed still-image output stream to terminate a progressive refinement sequence for all pictures. This is a write-only property. doOneProgression method This H.245 progressive refinement command is used to specify to the compressed still-image output pin to begin producing a progressive refinement sequence. The doOneProgression method is declared as follows: HRESULT doOneProgression() In this mode, the compressed still-image output pin produces video data consisting of one picture followed by a sequence of zero or more frames of refinement of the quality of the same picture. The compressed still-image output pin stays in this mode until it decides an acceptable fidelity level has been reached or the progressiveRefinementAbortOne command is received. In addition, the compressed still-image output pin shall insert the Progressive Refinement Segment Start Tag and the Progressive Refinement Segment End Tag to mark the beginning and end of the progressive refinement as defined in the Supplemental Enhancement Information Specification (Annex L) of Recommendation H.263. The TAPI MSP Video Capture filter propagates this command to the still-image output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_PROGRESSIVEREFINEMENT, a KSPROPERTY.Id field set to KSPROPERTY_PROGRESSIVEREFINEMENT_DOONEPROGRESSION and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_SET. doContinuousProgressions method This H.245 progressive refinement command is used to specify to the compressed still-image output pin to begin producing a progressive refinement sequence. The doContinuousProgressions method is declared as follows: HRESULT doContinuousProgressions() In this mode, the compressed still-image output pin produces video data consisting of one picture followed by a sequence of zero or more frames of refinement of the quality of the same picture. When the compressed still-image output pin decides an acceptable fidelity level has been reached or the progressiveRefinementAbortOne command is received, it stops refining the current progression and begins another progressive refinement for a different picture. The sequence of progressive refinements continues until the progressiveRefinementAbortContinuous command is received. In addition, the compressed still-image output pin shall insert Progressive Refinement Segment Start Tags and Progressive Refinement Segment End Tags to mark the start and end of each progressive refinement as defined in the Supplemental Enhancement Information Specification (Annex L) of Recommendation H.263. The TAPI MSP Video Capture filter propagates this command to the still-image output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_PROGRESSIVEREFINEMENT, a KSPROPERTY.Id field set to KSPROPERTY_PROGRESSIVEREFINEMENT_DOCONTINUOUSPROGRESSIONS and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_SET. doOneIndependentProgression method This H.245 progressive refinement command is used to specify to the compressed still-image output pin to begin an independent progressive refinement sequence. The doOneIndependentProgression method is declared as follows: HRESULT doOneIndependentProgression() In this mode, the compressed still-image output pin produces video data consisting of one Intra picture followed by a sequence of zero or more frames of refinement of the quality of the same picture. The compressed still-image output pin stays in this mode until either it decides an acceptable fidelity level has been reached or the progressiveRefinementAbortOne command is received. In addition, the compressed still-image output pin shall insert the Progressive Refinement Segment Start Tag and the Progressive Refinement Segment End Tag to mark the beginning and end of the progressive refinement as defined in the Supplemental Enhancement Information Specification (Annex L) of Recommendation H.263. The TAPI MSP Video Capture filter propagates this command to the still-image output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_PROGRESSIVEREFINEMENT, a KSPROPERTY.Id field set to KSPROPERTY_PROGRESSIVEREFINEMENT_DOONEINDEPENDENTPROGRESSION and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_SET. doContinuousIndependentProgressions method This H.245 progressive refinement command is used to specify to the compressed still-image output pin to begin producing independent progressive refinement sequences. The doContinuousIndependentProgressions method is declared as follows: HRESULT doContinuousIndependentProgressions() In this mode, the compressed still-image output pin produces video data consisting of one Intra picture followed by a sequence of zero or more frames of refinement of the quality of the same picture. When the compressed still-image output pin decides an acceptable fidelity level has been reached or the progressiveRefinementAbortOne command is received, it stops refining the current progression and begins another independent progressive refinement for a different picture. The sequence of independent progressive refinements continues until the progressiveRefinementAbortContinuous command is received. In addition, the terminal shall insert Progressive Refinement Segment Start Tags and Progressive Refinement Segment End Tags to mark the start and end of each independent progressive refinement as defined in the Supplemental Enhancement Information Specification (Annex L) of Recommendation H.263. The TAPI MSP Video Capture filter propagates this command to the still-image output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_PROGRESSIVEREFINEMENT, a KSPROPERTY.Id field set to KSPROPERTY_PROGRESSIVEREFINEMENT_DOCONTINUOUSINDEPENDENTPROGRESSIONS and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_SET. progressiveRefinementAbortOne method This H.245 progressive refinement command is used to specify to the compressed still-image output pin to terminate doOneProgression, doOneIndependentProgression, or the current progressive refinement in the sequence of progressive refinements in either doContinuousProgressions or doContinuousIndependentProgressions. The progressiveRefinementAbortOne method is declared as follows: HRESULT progressiveRefinementAbortOne() The TAPI MSP Video Capture filter propagates this command to the still-image output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_PROGRESSIVEREFINEMENT, a KSPROPERTY.Id field set to KSPROPERTY_PROGRESSIVEREFINEMENT_ABORTONE and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_SET. progressiveRefinementAbortContinuous method This H.245 progressive refinement command is used to specify to the compressed still-image output pin to terminate either doContinuousProgressions or doContinuousIndependentProgressions. The progressiveRefinementAbortContinuous method is declared as follows: HRESULT progressiveRefinementAbortContinuous() The TAPI MSP Video Capture filter propagates this command to the still-image output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY structure, with a KSPROPERTY.Set field set to PROPSETID_PROGRESSIVEREFINEMENT, a KSPROPERTY.Id field set to KSPROPERTY_PROGRESSIVEREFINEMENT_ABORTCONTINUOUS and KSPROPERTY.Flags field set to KSPROPERTY_TYPE_SET. INetworkStats interface Compressed still-image output pins may chose to also expose an INetworkStats interface. The TAPI MSP Network Sink filter calls methods on this interface periodically based on monitored network performances. The compressed still-image output pin is responsible for taking appropriate actions, if needed. See section   REF _Ref427926473 \r \h  9.2.2  for more information on the INetworkStats interface. ICPUControl interface Compressed still-image output pins may implement the optional ICPUControl interface. The methods on this interface are called at the beginning of a call to initialize the maximum CPU load and frame encoding time, and then periodically by the TAPI MSP Quality Controller during the entire call. The initial and limit values for the maximum CPU load and frame encoding time are based on user-defined settings provided by the application. See section   REF _Ref443191704 \r \h  9.2.3  for more information on the ICPUControl interface. IBitrateControl interface The IBitrateControl interface specifies a maximum bitrate to the still-image output pin. The methods on this interface are called at the beginning of a call by the TAPI MSP Quality Controller to initialize the target bitrate, and then periodically during the entire call. The dynamic values for the target bitrates are based on network statistics provided by the TAPI MSP Network Sink filter to the TAPI MSP Quality Controller. The initial and limit values for the target bitrate are based on user-defined settings provided by the application to the TAPI MSP Quality Controller and the result of capability negotiations between the two connected endpoints provided by the TAPI MSP Channel Controller. See section   REF _Ref442843461 \r \h  9.2.4  for more information on the IBitrateControl interface. RTP packetization descriptor output pin TAPI interface The TAPI MSP Video Capture filter exposes a new interface supported by the RTP packetization descriptor output pin to the network sink filter. The network sink filter uses the IRTPPDControl interface to dynamically modify or query for the maximum RTP packet size on the RTP Packetization descriptor output pin. Note that in most scenarios, the maximum RTP packet size will be set once at stream creation time through the RTP_PD_INFO structure and never change. The TAPI MSP calls QueryInterface on the IPin interface exposed by the RTP packetization descriptor output pin of the TAPI MSP Video Capture filter to get a pointer to the IRTPPDControl interface. The TAPI MSP Video Capture filter implements this interface using the generic IKsControl interface and a property set called PROPSETID_RTPPDCONTROL. The properties defined in this set are controlled on a stream basis. The GUID of the PROPSETID_RTPPDCONTROL property set is defined as follows: PROPSETID_RTPPDCONTROL 74636470-5245-4945-5252-45464C494850 IRTPPDControl interface In order to dynamically adjust the maximum RTP packet size, the RTP packetization descriptor output pin provides the network filter with a pointer to an IRTPPDControl interface containing the following methods: SetMaxRTPPacketSize Used to dynamically adjust the maximum RTP packet size (in bytes) to be described by the list of packetization descriptors. Typically, this number is just below the MTU size of the network. GetMaxRTPPacketSize Used to supply to the network sink filter the current maximum RTP packet size (in bytes) described by the list of packetization descriptors. GetMaxRTPPacketSizeRange Used to support, minimum, maximum, and default values for the maximum RTP packet size (in bytes) described by the list of packetization descriptors. The IRTPPDControl interface is not a standard DirectShow interface. The TAPI MSP Video Capture filter implements this interface using the generic IKsControl interface and a property set called PROPSETID_RTPPDCONTROL. The properties defined in this set are controlled on a stream basis. The PROPSETID_RTPPDCONTROL property set contains the following property: KSPROPERTY_RTPPDCONTROL_MAXRTPPACKETSIZE  Used to retrieve/set the maximum RTP packet size. This is a read/write property. SetMaxRTPPacketSize method This RTP packetization descriptor control method is used to dynamically adjust the maximum RTP packet size (in bytes) to be described by the list of packetization descriptor. Typically, this number is just below the MTU size of the network. The SetMaxRTPPacketSize method is declared as follows: HRESULT SetMaxRTPPacketSize([IN]DWORD dwMaxRTPPacketSize, [IN]DWORD dwLayerId) where dwMaxRTPPacketSize Specifies the maximum RTP packet size (in bytes) to be described by the list of packetization descriptors.  dwLayerId Specifies the ID of the encoding layer the maximum RTP packet size applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_INVALIDARG Invalid argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the RTP packetization descriptor output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_RTPPDCONTROL, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_RTPPDCONTROL_MAXRTPPACKETSIZE, KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_SET and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the maximum RTP packet size applies to. The PropertyData parameter points to a DWORD specifying the maximum RTP packet size (in bytes) to be described by the list of packetization descriptors. GetMaxRTPPacketSize method This RTP packetization descriptor control method is used to supply to the network sink filter the maximum RTP packet size (in bytes) described by the list of packetization descriptors. The GetMaxRTPPacketSize method is declared as follows: HRESULT GetMaxRTPPacketSize([OUT]DWORD *pdwMaxRTPPacketSize, [IN]DWORD dwLayerId) where pdwMaxRTPPacketSize Specifies a pointer to a DWORD to receive the maximum RTP packet size (in bytes) described by the list of packetization descriptors.  dwLayerId Specifies the ID of the encoding layer the maximum RTP packet size applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the RTP packetization descriptor output stream by calling IKsControl::KsProperty. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_RTPPDCONTROL, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_RTPPDCONTROL_MAXRTPPACKETSIZE, KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_GET and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the maximum RTP packet size applies to. The PropertyData parameter points to a DWORD to receive the maximum RTP packet size (in bytes) to be described by the list of packetization descriptors. GetMaxRTPPacketSizeRange method This RTP packetization descriptor control method is used to supply to the network sink filter the minimum, maximum, and default values for the RTP packet size (in bytes) described by the list of packetization descriptors. The GetMaxRTPPacketSizeRange method is declared as follows: HRESULT GetMaxRTPPacketSizeRange([OUT]DWORD *pMin, [OUT]DWORD *pMax, [OUT]DWORD *pSteppingDelta, [OUT]DWORD *pDefault, [IN]DWORD dwLayerId) where Used to retrieve the minimum RTP packet size (in bytes) described by the list of packetization descriptors.  Used to retrieve the maximum RTP packet size (in bytes) described by the list of packetization descriptors.  pSteppingDelta Used to retrieve the stepping delta in RTP packet size (in bytes) described by the list of packetization descriptors s.  pDefault Used to retrieve the default RTP packet size (in bytes) described by the list of packetization descriptors.  dwLayerId Specifies the ID of the encoding layer the command applies to. For standard video encoders, this field is always set to 0. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc.  This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed: HRESULT Meaning E_FAIL Failure E_POINTER Null pointer argument E_NOTIMPL Method is not supported NOERROR No error The TAPI MSP Video Capture filter propagates this command to the RTP packetization descriptor output stream by calling IKsControl::KsProperty twice. The first call retrieves the minimum, maximum and stepping values. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_RTPPDCONTROL, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_RTPPDCONTROL_MAXRTPPACKETSIZE and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_BASICSUPPORT and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the command applies to. The PropertyData parameter points to  a KSPROPERTY_LIST_S structure. The output stream updates the KSPROPERTY_LIST_S.SteppingLong field with the appropriate minimum, maximum, and stepping delta values. The second call retrieves the default value. The Property parameter points to a KSPROPERTY_PARAM_S structure, with a KSPROPERTY_PARAM_S.Property.Set field set to PROPSETID_RTPPDCONTROL, a KSPROPERTY_PARAM_S.Property.Id field set to KSPROPERTY_RTPPDCONTROL_MAXRTPPACKETSIZE and KSPROPERTY_PARAM_S.Property.Flags field set to KSPROPERTY_TYPE_DEFAULTVALUES and the KSPROPERTY_PARAM_S.dwParam set to the ID of the encoding layer the command applies to. The PropertyData parameter points to  a KSPROPERTY_LIST_S structure. The output stream updates the KSPROPERTY_LIST_S.DefaultLong field with the appropriate default value. References TAPI specifications Available from Microsoft: Microsoft  TAPI  Video Decoder Filter   Streams and Interfaces This design specification describes a video decoder filter architecture for Microsoft NetMeeting 3.0 and other third-party conferencing applications in the Microsoft TAPI environment using DirectShow. Microsoft  TAPI  Video Encoder Filter   Streams and Interfaces This design specification describes a video encoder filter architecture for Microsoft NetMeeting 3.0 and other third-party conferencing applications in the Microsoft TAPI environment using DirectShow. Videoconferencing Acceleration with WDM   RTP Pre-Packetized H.26x Video Encoding This design specification describes a video hardware compression acceleration architecture for Microsoft NetMeeting 3.0 and other third-party videoconferencing applications in the Microsoft TAPI environment using WDM. Videoconferencing Acceleration with WDM   RTP Packetized H.26x Video Decoding This design specification describes a video hardware decompression acceleration architecture for Microsoft NetMeeting 3.0 and other third-party videoconferencing applications in the Microsoft TAPI environment using WDM. Audioconferencing Acceleration with WDM   G.Series Audio Encoding This design specification describes an audio hardware compression acceleration architecture for Microsoft NetMeeting 3.0 and other third-party audioconferencing applications in the Microsoft TAPI environment using WDM. DirectShow SDK articles and documentation Available from  HYPERLINK "http://www.microsoft.com/directx/pavilion/dshow" http://www.microsoft.com/directx/pavilion/dshow WDM Stream class, WDM articles and documentation Available from  HYPERLINK "/hwdev/desinit/" http://www.microsoft.com/hwdev/desinit/ WDM: Introduction to Win32 Driver Model Introduces WDM, which is being developed to provide an operating system-independent framework for creating device drivers for some classes of devices. WDM for Windows and Windows NT Presents information about WDM support for several device classes under Windows 98 and Windows 2000. WDM Kernel Streaming Introduces the concept of kernel-mode streaming and describes the role of the different components of WDM Streaming architecture. WDM USB Driver Interface Describes the interface offered to client drivers by the operating-system USB driver stack. When to Write WDM Class Drivers Explores whether the best approach for supporting a particular device is to write an additional WDM solution or to use the Microsoft-supplied WDM drivers supplemented with device-specific minidrivers. VfW-to-WDM Video Capture Mapper on Windows 98 and Windows 2000 Discusses the architecture and limitations of the VfW-to-WDM mapper for video capture devices. Navigating to WDM Video Capture Supplies pointers to documents relevant to vendors who are developing video capture-related products for the Microsoft Windows 98 and Windows 2000 operating systems under WDM. VfW-to-WDM Mapper to Support Analog Solutions Presents information about how the Video for Windows-to-WDM mapper support works under Windows 2000. WDM Video Capture Overview Provides an overview of video capture for the Microsoft Windows 98 and Windows 2000 under WDM. In the WDM DDK Documentation: Kernel-Mode Streaming Reference Stream Class Driver Reference Kernel Streaming Proxy Reference Stream Class Video Capture Minidriver Reference ITU communications standards Available from   HYPERLINK http://www.itu.int/itudoc/itu-t/rec/h  http://www.itu.int/itudoc/itu-t/rec/h Recommendation H.245 v3 (09/97)   Control protocol for multimedia communication Recommendation H.261 (03/93)   Video codec for audiovisual services at px64 kbit/s Recommendation H.263 (03/96)   Video coding for low bit rate communication Recommendation H.263 v2 (01/98)   Video coding for low bit rate communication ITU home page:   HYPERLINK http://www.itu.int/home  http://www.itu.int/home IETF Request for comments Available from  HYPERLINK "http://www.isi.edu/in-notes" http://www.isi.edu/in-notes RFC 1889   RTP: A Transport Protocol for real-time Applications RFC 2032   RTP Payload Format for H.261 video streams RFC 2190   RTP Payload Format for H.263 video streams RFC 2429   RTP Payload Format for the 1998 Version of ITU-T Rec. H.263 Video (H.263+) Microsoft Corporation Company Confidential  SAVEDATE \@ "M/d/yy" \* MERGEFORMAT 2/28/99        Draft - Microsoft Corporation Company Confidential      SAVEDATE \@ "h:mm am/pm" \* MERGEFORMAT  3:48 PM Microsoft Corporation Company Confidential  SAVEDATE \@ "M/d/yy" \* MERGEFORMAT 2/28/99        Draft - Microsoft Corporation Company Confidential      SAVEDATE \@ "h:mm am/pm" \* MERGEFORMAT  3:48 PM Revision 0.207            WDM Connection and Streaming Architecture Revision 0.1.  REVNUM  \* MERGEFORMAT              TITLE  \* MERGEFORMAT  Microsoft  TAPI  Video Capture Filter  DATE  02/28/99            Microsoft Corporation Company Confidential            TIME  3:49 PM  SAVEDATE \@ "M/d/yy" \* MERGEFORMAT 2/28/99       Draft - Microsoft Corporation Company Confidential       SAVEDATE \@ "h:mm am/pm" \* MERGEFORMAT  3:48 PM Microsoft Corporation Company Confidential  SAVEDATE \@ "M/d/yy" \* MERGEFORMAT 2/28/99        Draft - Microsoft Corporation Confidential      SAVEDATE \@ "h:mm am/pm" \* MERGEFORMAT  3:48 PM User mode Still-Image Pin ICPUControl KSXBar Kernel mode KSProxy Functions Video capture hardware Digital video capture minidriver (USB/1394) Analog video capture minidriver (PCI/VPE) Stream class IRTPPDControl Optional RTP Packetization Descriptor Pin Optional Compressed Still-Image Pin IProgressiveRefinement INetworkStats IBitrateControl ICPUControl Format Change IFrameRateControl ICPUControl IFrameRateControl ICPUControl IAMVfwCaptureDialogs Capture Pin TAPI MSP Video Encoder Filter Capture video data Preview video data IRTPPDControl Frame Rate Control Change Format Change Frame Rate Control Change Format Change Smart Optional RTP Packetization Descriptor Pin Optional Compressed Still-Image Pin IProgressiveRefinement INetworkStats IBitrateControl ICPUControl ICPUControl IFrameRateControl Video Capture Driver IRTPPDControl Preview Pin TAPI MSP Video Renderer Sink Filter IAMVfwCaptureDialogs IAMVideoProcAmp IAMCameraControl IAMVideoControl IH245VideoCapability IH245EncoderCommand IProgressiveRefinement INetworkStats IBitrateControl ICPUControl IFrameRateControl TAPI MSP Video Capture Filter RTP Packetization Descriptor Pin Packetization descriptor data Compressed video data Preview video data TAPI MSP Video Capture Filter H.26x Encoding Frame Rate Control Change Format Change Change Frame Rate Control Format Change Smart Video Capture Driver H.263 Video I-Frame Payload header - F=0, P=0, SBIT=007, EBIT=000, SRC=011, R=00000, I=1, A=0, S=0, DBQ=00, TRB=000, TR=00000000 Payload header - F=0, P=0, SBIT=000, EBIT=001, SRC=011, R=00000, I=1, A=0, S=0, DBQ=00, TRB=000, TR=00000000 0x00806038 0x00806001 0x00806000 dwThisHeaderLength dwPayloadHeaderOffset dwPayloadHeaderLength dwPayloadStartBitOffset21247 dwPayloadEndBitOffset .26031 fEndMarkerBit dwLayerId dwTimestamp dwVideoAttributes dwReserved dwThisHeaderLength dwPayloadHeaderOffset dwPayloadHeaderLength dwPayloadStartBitOffset10784 dwPayloadEndBitOffset .21246 fEndMarkerBit dwLayerId dwTimestamp dwVideoAttributes dwReserved RTP_PD RTP_PD RTP_PD_HEADER dwThisHeaderLength dwPayloadHeaderOffset dwPayloadHeaderLength dwPayloadStartBitOffset dwPayloadEndBitOffset .10783 fEndMarkerBit dwLayerId dwTimestamp dwVideoAttributes dwReserved Payload header - F=0, P=0, SBIT=000, EBIT=000, SRC=011, R=00000, I=1, A=0, S=0, DBQ=00, TRB=000, TR=00000000 RTP_PD dwThisHeaderLength dwTotalByteLength ..128 dwNumHeaders dwReserved IRTPPDControl Video Capture Driver 32-bit VfW capture driver (.SYS) IRTPPDControl Optional RTP Packetization Descriptor Pin ICPUControl IFrameRateControl TAPI MSP Network Send Filter TAPI MSP Video Renderer Filter TAPI MSP TAPI MSP Video Capture Filter TAPI MSP Video Capture Source Filter Compressed Video Pin Optional Compressed Still-Image Pin RTP Packetization Descriptor Pin IH245EncoderCommand IProgressiveRefinement INetworkStats IBitrateControl ICPUControl IFrameRateControl IProgressiveRefinement INetworkStats IBitrateControl ICPUControl IAMCrossbar IAMVideoProcAmp IAMCameraControl IAMVideoControl IH245VideoCapability TAPI MSP Network Send Sink Filter TAPI MSP Video Renderer Sink Filter Preview Pin Preview Pin TAPI MSP Video Capture Filter TAPI MSP Video Renderer Sink Filter Change Frame Rate Control Format Change Change Frame Rate Control H.26x Encoding Preview video data Compressed video data Packetization descriptor data TAPI MSP Network Send Sink Filter TAPI MSP Video Capture Source Filter Compressed Video Pin RTP Packetization Descriptor Pin IH245EncoderCommand IProgressiveRefinement INetworkStats IBitrateControl ICPUControl IFrameRateControl IAMVideoProcAmp IAMCameraControl IAMVideoControl IH245VideoCapability TAPI MSP Video Renderer Sink Filter Preview Pin IRTPPDControl ICPUControl IFrameRateControl TAPI MSP Video Capture Filter 32-bit VfW capture driver (.DLL) Video Capture Driver Format Change Change Frame Rate Control Format Change Change Frame Rate Control Preview Capture TAPI MSP Network Send Sink Filter TAPI MSP Video Capture Source Filter Compressed Video Pin RTP Packetization Descriptor IH245EncoderCommand IProgressiveRefinement INetworkStats IBitrateControl ICPUControl IAMVideoProcAmp IAMCameraControl IAMVideoControl IH245VideoCapability TAPI MSP Video Renderer Sink Filter Preview Pin IRTPPDControl TAPI MSP Video Encoder Filter Capture Pin IAMVideoProcAmp IAMCameraControl IAMVideoControl IFrameRateControl ICPUControl IFrameRateControl ICPUControl TAPI MSP Video Capture Filter TAPI MSP Network Send Filter TAPI MSP Video Renderer Filter TAPI MSP Functions 32 bit DCAP32.DLL 16 bit Video capture hardware Thunks 16-bit VfW capture driver DCAP16.DLL ICPUControl IRTPPDControl Optional RTP Packetization Descriptor Pin Optional Compressed Still-Image Pin IProgressiveRefinement INetworkStats IBitrateControl ICPUControl TAPI MSP Video Capture Filter DCAP32.DLL TAPI MSP Network Send Filter TAPI MSP Video Renderer Filter TAPI MSP Functions User mode Kernel mode Video capture hardware Still-Image Pin Compressed still-image data Change IRTPPDControl Optional RTP Packetization Descriptor Pin Optional Compressed Still-Image Pin IProgressiveRefinement INetworkStats IBitrateControl ICPUControl Packetization descriptor data H.26x Encoding Format Change IAMVideoProcAmp IAMCameraControl IAMVideoControl IH245VideoCapability IH245EncoderCommand IProgressiveRefinement INetworkStats IBitrateControl ICPUControl RTP Packetization Descriptor Compressed Video Pin TAPI MSP Video Capture Source Filter TAPI MSP Network Send Sink Filter Capture still-image data IRTPPDControl Change Format Change Compressed Video Pin TAPI MSP Video Capture Source Filter TAPI MSP Network Send Sink Filter Packetization descriptor data Compressed still-image data H.26x Encoding Change Format Change Still-image Change Format Change ~ytoje`[ ~ytoje`[ ~ytoje`[ ~ytoje`[ }zwtqnkheb ~{xurpmpjgda wtqnkheb {xurol }xsnid_ZUP ~ytoje`[VQ {vqlgYTO zwtqnid_Z ~ytoje` |yvsnid_ }olid_ }vqmha\ |wrmhc^Y |wrmhc^Y zupkfa\W zupkfa\ ~ytoje`[ {vqc^Y |wifc`] }xsnida^[ |yvqlgb]X spmhc^Y {vqnkhc^ |yvspmj\ }xsnid_Q ~{xlifc ~wsnie` |uqlgc^ {vokfa] ~ytqnifc` }xsnid_ZW ~yuroa^[ wtqlif |yvqlgb_\ ~ytoje`[ }zwtqni] ~ytoje` |wrmhc^Y zwtoje`[ ~{xupkgb {vqnkhc^ zurolgb^ }xspmje` ~ytoje`]X {vqlifc^ ~ytoli[X }xsojea\ ~yupkgb] ~zuplgb^ }xsnid_Z ~ytolifcW }xsnifc` |ytojeb_\ |ytojeb_\ |ytojeb] |yvqlgb] |nkhc`] ~yurolia\ ~{xurol^[ |yvql }xspm_\Y }xsnifc` |wtqnid` {vqlgb]Z |ytqnkfa\ |nkhc`] |ykhe`] |yvqlifc {xurmhd_ ~{vspmjgd |wrnid` {vqlgb]X }xsnid_Z }vrmhd_ }ytokfa zurolgb {vqlif ~pmjeb_ ~{xsnid_ zurolgd_Z |yvqlgb] |wrnkheb |xurol^[ ~yurolifa zwtqn`]Z spmheb_ ~{vspmhc^ ~pmjeb |yvsnifc` zurolgb^ ~ytojeb_\ }xspmje` |yvqlhc\ {vqnkhc^ ~ytolid_ zuqlgc`] |wrnid` |xsnje`\ }xlifa^ ~{xspmje` {vqlgb] ~yvskheb }zwtolgb^ }xsojea\ ~{vqmha] }zurolifc ~pmjeb_ {xumjgda\ yvsnkhe` {xurmhc^ {vqlgb] tqnkhb_ }zwtqnk MSO Palette  )$+*($''-2@7-0=0''8L9=CEHIH+6OUNFT@GHE !E.'.EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE MSO Palette  )$+*($''-2@7-0=0''8L9=CEHIH+6OUNFT@GHE !E.'.EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE 1AQ"aq PwedS W^1*1j 5iZ<z ri/%:5~ mE^_~2J {sr~Q? Z]z<`_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\video\tapivcap\tapivcap.doc ===
{\rtf1\ansi \deff0\deflang1033

{\fonttbl
{\f0\froman Times New Roman;}
{\f2\fswiss Arial;}
{\f19\fmodern\fcharset0\fprq1 Courier New;}
}

{\colortbl;
\red0\green0\blue0;
\red0\green0\blue255;
\red0\green255\blue255;
\red0\green255\blue0;
\red255\green0\blue255;
\red255\green0\blue0;
\red255\green255\blue0;
\red255\green255\blue255;
\red0\green0\blue127;
\red0\green127\blue127;
\red0\green127\blue0;
\red127\green0\blue127;
\red127\green0\blue0;
\red127\green127\blue0;
\red127\green127\blue127;
\red192\green192\blue192;
}


{\stylesheet
{\s243\li-1800\sl-210\tqr\tx6960 \b\f2\fs19\lang1033 header;}
{\s251\sb160\sa40\sl-280\keepn \b\f2\lang1033 heading 4;}
{\s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 heading 3;}
{\s253\li-1800\sb160\sa60\sl-380\keepn \b\f0\fs34\lang1033 heading 2;}
{\s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 heading 1;}
{\*\cs10 \additive Default Paragraph Font;}
{\sa160\sl240 \fs21\lang1033 Normal;}
{\s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 Ex;}
{\s44\li-1770\ri30\sb50\sl-80\brdrt\brdrs\brdrw15\brdrcf2 \fs12\lang1033 header rule;}
{\s45\li-1800\sa180\sl-440\keepn\tx0 \b\f2\fs40\up8\lang1033 Rh1;}
{\s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Rmh;}
{\s50\sl-240\keepn \f0\fs21\lang1033 Term1;}
{\s53\li280\sl-240\keepn \f0\fs21\lang1033 Term2;}
{\s54\li280\sa80\sl-240 \f0\fs21\lang1033 Def1;}
{\s55\li560\sa80\sl-240 \f0\fs21\lang1033 Def2;}
{\s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 Rule;}
{\s93\sl240 \fs21\lang1033 
Index Link;}
{\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 Table Text;}
}

\paperw12240\paperh15840\margl3330\margr1530\margt-2540\margb-2220\gutter420 
\facingp\deftab280\widowctrl\ftnbj 

\sectd \binfsxn1\binsxn1\linex0\headery1990\footery360\endnhere\titlepg 

{\headerl \pard\plain \s243\li-1800\sl-210\tqr\tx6960 \b\f2\fs19\lang1033 
{\field\flddirty{\*\fldinst PAGE}{\fldrslt 4}}{\expnd50  }TAPIVCap Reference - 06/17/99\par 
\pard\plain \s44\li-1770\ri30\sb50\sl-80\brdrt\brdrs\brdrw15\brdrcf2 \fs12\lang1033 \par }

{\headerr \pard\plain \s243\li-1800\sl-210\tqr\tx6960 \b\f2\fs19\lang1033 
\tab TAPIVCap Reference - 06/17/99{\expnd50   }
{\field\flddirty{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s44\li-1770\ri30\sb50\sl-80\brdrt\brdrs\brdrw15\brdrcf2 \fs12\lang1033 
\par }
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 Contents\par 
\pard\plain \s93\sl240 \fs21\lang1033 
To display a list of topics by category, click any 
of the contents entries below. To display an alphabetical list of 
topics, choose the Index button.\par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 Introduction\par 
\pard\plain \sa160\sl240 \fs21\lang1033 This DLL implements the TAPI MSP Video Capture filter. This filter reuses 
some of the code that has been developed for the off-the-shelf VfW (QCAP) and 
WDM (KSProxy) video capture filters, but adds a significant amount of 
powerful processing functions to the capture process to meet all the 
requirements discussed in section 4 of "Microsoft Video Capture Filter.doc".\par 

This DLL adds support for  extended bitmap info headers for H.261 and H.263 
video streams to communicate to the TAPI MSP Video Capture filter a list of 
media types supported by the remote endpoint. Still, the decision to use 
optional compression modes is left to the TAPI MSP Video Capture filter. The 
current VfW off-the-shelf capture filter does not have a way to expose all 
the capabilities of the capture device. We create our own media type 
enumeration process to compensate for this limitation.\par 

The TAPI MSP Video Capture filter also supports a number of DirectShow 
interfaces (IAMVfwCaptureDialogs, IAMCrossbar, IAMVideoProcAmp, 
IAMCameraControl, IAMVideoControl) to provide better control over the capture 
process to TAPI applications.\par 

It implements a new H.245 Video Capability interface (IH245VideoCapability) 
to be used by the MSP in order to provide the TAPI MSP Capability module with 
a table of estimated steady-state resource requirements as related to each 
format that the capture device supports.\par 

A new H.245 command interface (IH245EncoderCommand) is implemented to 
communicate to the TAPI MSP Video Capture filter requests for I-frame, group 
of blocks, or macro-block updates due to packet loss or multi-point switching. 
We implement a network statistics interface (INetworkStats), to allow the 
network to provide feedback on the channel conditions to the compressed video 
output pin of the TAPI MSP Video Capture filter. The TAPI MSP Video Capture 
filter is responsible for taking appropriate actions, if needed. The TAPI MSP 
Video Capture filter also implements three control interfaces (ICPUControl, 
IFrameRateControl, IBitrateControl) to be used by the TAPI MSP Quality 
Controller to provide the best user experience.\par 

The TAPI MSP Video Capture filter also exposes a preview output pin that can 
be controlled independently of the capture output pin. The data produced by 
this pin will be rendered using overlay or a video port if supported by the 
capture device.\par 

The TAPI MSP Video Capture filter exposes an interface (IProgressiveRefinement) 
on its compressed video output pin to allow for transmission of 
high-resolution stills that are continuously improved on the remote endpoint 
as more data is received and decompressed. The TAPI MSP Video Capture filter 
may also elect to implement this same interface on an optional separate and 
dedicated still-image output pin.\par 

Finally, the TAPI MSP Video Capture filter exposes an RTP packetization 
descriptor output pin synchronized to the compressed capture output pin. The 
downstream RTP Network Sink filter uses this second pin to understand how to 
better fragment the compressed video data into network RTP packets.\par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 Implementation\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 VfW capture devices\par 
\pard\plain \sa160\sl240 \fs21\lang1033 The TAPI MSP Video Capture filter talks directly to the VfW capture driver 
using SendDriverMessage. This filter uses the existing DShow code 
implemented in QCAP but adds the necessary functions to perform smart 
teeing of the capture data to the preview pin. It replaces the 
streaming-only code used by QCAP with frame grabbing code whenever 
necessary. It controls the rate at which frames are being captured by 
adjusting the rate at which DVM_FRAME message are being sent to the driver 
in frame grabbing mode, or only returning a fraction of the frames being 
captured in streaming mode. It performs format and Vfw to ITU-T size 
conversions to bring the format of the captured video data to a format that 
can easily be used for rendering, and directly encoded by the downstream 
TAPI MSP Video Encoder filter if an installable codecs is registered with 
the TAPI MSP. If there is no installable codec registered, the TAPI MSP 
Video Capture filter also performs H.26x encoding, generating a compressed 
video capture output stream in H.26x format, as well as an RTP packetization 
descriptor output data stream. Finally, the TAPI MSP Video Capture filter 
does all the necessary sequencing to pause the existing video streams 
whenever it is being asked to generate still-image data, grab a 
high-resolution snapshot, deliver it in progressively rendered form, and 
restart the video streams.\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 WDM capture devices\par 
\pard\plain \sa160\sl240 \fs21\lang1033 The TAPI MSP Video Capture filter talks directly to the WDM capture driver 
using IOCTLs. This filter uses the existing code implemented in KSProxy 
but adds the necessary functions to perform smart teeing of the capture 
data to the preview pin, if necessary. It controls the rate at which frames 
are being captured by adjusting the rate at which buffers are being 
submitted to the driver in frame grabbing mode, or only returning a fraction 
of the frames being captured in streaming mode using overlapped IOs. It 
performs format and Vfw to ITU-T size conversions to bring the format of the 
captured video data to a format that can easily be used for rendering, and 
directly encoded by the downstream TAPI MSP Video Encoder filter if an 
installable codecs is registered with the TAPI MSP. If there is no 
installable codec registered, the TAPI MSP Video Capture filter also performs 
H.26x encoding, generating a compressed video capture output stream in H.26x 
format, as well as an RTP packetization descriptor output data stream. 
Finally, the TAPI MSP Video Capture filter does all the necessary sequencing 
to pause the existing video streams whenever it is being asked to generate 
still-image data, grab a high-resolution snapshot, deliver it in 
progressively rendered form, and restart the video streams.\par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 Video capture filter application interfaces\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 IAMVfwCaptureDialogs application interface\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IAMVfwCaptureDialogs methods\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IAMVfwCaptureDialogs structures and enums\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 IAMCrossbar application interface\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IAMCrossbar methods\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IAMCrossbar structures and enums\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 IAMVideoProcAmp application interface\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IAMVideoProcAmp methods\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IAMVideoProcAmp structures and enums\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 IAMCameraControl application interface\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IAMCameraControl methods\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IAMCameraControl structures and enums\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 IAMVideoControl application interface\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IAMVideoControl methods\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IAMVideoControl structures and enums\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 IVideoDeviceControl application interface\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IVideoDeviceControl methods\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IVideoDeviceControl structures and enums\par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 Video capture filter MSP interfaces\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 IH245VideoCapability application interface\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IH245VideoCapability methods\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IH245VideoCapability structures and enums\par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 Video capture filter output pin TAPI interfaces\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 ICPUControl interface\par 
\pard\plain \s93\sl240 \fs21\lang1033 
ICPUControl methods\par 
\pard\plain \s93\sl240 \fs21\lang1033 
ICPUControl structures and enums\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 IFrameRateControl interface\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IFrameRateControl methods\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IFrameRateControl structures and enums\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 IBitrateControl interface\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IBitrateControl methods\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IBitrateControl structures and enums\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 INetworkStats interface\par 
\pard\plain \s93\sl240 \fs21\lang1033 
INetworkStats methods\par 
\pard\plain \s93\sl240 \fs21\lang1033 
INetworkStats structures and enums\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 IH245EncoderCommand interface\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IH245EncoderCommand methods\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IH245EncoderCommand structures and enums\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 IProgressiveRefinement interface\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IProgressiveRefinement methods\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IProgressiveRefinement structures and enums\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 IRTPPDControl interface\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IRTPPDControl methods\par 
\pard\plain \s93\sl240 \fs21\lang1033 
IRTPPDControl structures and enums\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 Common control structures and enums\par 
\pard\plain \s93\sl240 \fs21\lang1033 
Common control structures\par 
\pard\plain \s93\sl240 \fs21\lang1033 
Common control enums\par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 Classes\par 
\pard\plain \s93\sl240 \fs21\lang1033 
Classes\par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 Modules\par 
\pard\plain \s93\sl240 \fs21\lang1033 
Modules\par 
\pard\plain \s93\sl240 \fs21\lang1033 
Constants\par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 Code information\par 
\pard\plain \sa160\sl240 \fs21\lang1033 The only libraries necessary in retail mode (w/o property pages) are ........\\dev\\tools\\amovsdk.20\\lib\\strmbase.lib ......\\ddk\\lib\\i386\\ksuser.lib ......\\ddk\\lib\\i386\\ksguid.lib kernel32.lib ole32.lib uuid.lib msvcrt.lib\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 Exports\par 
\pard\plain \sa160\sl240 \fs21\lang1033 DllCanUnloadNow 
DllGetClassObject\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 Imports\par 
\pard\plain \sa160\sl240 \fs21\lang1033 KERNEL32.DLL: 
CloseHandle 
CreateEventA 
DeviceIoControl 
DisableThreadLibraryCalls 
FreeLibrary 
GetLastError 
GetOverlappedResult 
GetVersionExA 
InterlockedDecrement 
InterlockedIncrement 
RtlZeroMemory\par 

MSVCRT.DLL: 
??2@YAPAXI@Z 
??3@YAXPAX@Z 
_EH_prolog 
__CxxFrameHandler 
_purecall 
memcmp\par 
\pard\plain \s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 Code size\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Compile options: /nologo /MDd /W3 /GX /O1 /X /I "....\\inc" /I "......\\ddk\\inc" /I "........\\dev\\tools\\amovsdk.20\\include" /I "........\\dev\\tools\\amovsdk.20\\classes\\base" /I "........\\dev\\ntddk\\inc" /I "........\\dev\\inc" /I "........\\dev\\tools\\c32\\inc" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "DLL" /D "STRICT" /FR"Release/" /Fp"Release/TAPIKsIf.pch" /YX /Fo"Release/" /Fd"Release/" /FD /c\par 

Link options: ........\\dev\\tools\\amovsdk.20\\lib\\strmbase.lib ......\\ddk\\lib\\i386\\ksuser.lib ......\\ddk\\lib\\i386\\ksguid.lib comctl32.lib msvcrt.lib winmm.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /base:"0x1e180000" /entry:"DllEntryPoint" /dll /incremental:no /pdb:"Release/TAPIKsIf.pdb" /map:"Release/TAPIKsIf.map" /machine:I386 /nodefaultlib /def:".\\TAPIKsIf.def" /out:"Release/TAPIKsIf.ax" /implib:"Release/TAPIKsIf.lib"\par 

Resulting size: 28KB\par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 Classes\par 
\pard\plain \s93\sl240 \fs21\lang1033 
\par 
\pard\plain \s93\sl240 \fs21\lang1033 
\pard\plain \s93\sl240 \fs21\lang1033 
CCameraControlProperties{\v CCameraControlProperties}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCameraControlProperty{\v CCameraControlProperty}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCapturePin{\v CCapturePin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCaptureProperties{\v CCaptureProperties}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCaptureProperty{\v CCaptureProperty}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCPUCProperties{\v CCPUCProperties}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCPUCProperty{\v CCPUCProperty}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CKSPropertyEditor{\v CKSPropertyEditor}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CNetworkStatsProperties{\v CNetworkStatsProperties}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CNetworkStatsProperty{\v CNetworkStatsProperty}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
COverlayPin{\v COverlayPin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CPreviewPin{\v CPreviewPin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CPreviewProperties{\v CPreviewProperties}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CPreviewProperty{\v CPreviewProperty}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CProcAmpProperties{\v CProcAmpProperties}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CProcAmpProperty{\v CProcAmpProperty}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CProgRefProperties{\v CProgRefProperties}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CRtpPdPin{\v CRtpPdPin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CRtpPdProperties{\v CRtpPdProperties}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CRtpPdProperty{\v CRtpPdProperty}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin{\v CTAPIBasePin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap{\v CTAPIVCap}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap{\v CTAPIVCap_1}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap{\v CTAPIVCap_2}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CWDMCapDev{\v CWDMCapDev}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CWDMDialog{\v CWDMDialog}\par 

\par 
\pard\plain \s93\sl240 \fs21\lang1033 
\pard\plain \s93\sl240 \fs21\lang1033 
CCapturePin::CCapturePin{\v CCapturePin__CCapturePin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCapturePin::CreateCapturePin{\v CCapturePin__CreateCapturePin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCapturePin::GetPages{\v CCapturePin__GetPages}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCapturePin::m_pCaptureFilter{\v CCapturePin__m_pCaptureFilter}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCapturePin::NonDelegatingQueryInterface{\v CCapturePin__NonDelegatingQueryInterface}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCapturePin::videoFastUpdateGOB{\v CCapturePin__videoFastUpdateGOB}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCapturePin::videoFastUpdateMB{\v CCapturePin__videoFastUpdateMB}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCapturePin::videoFastUpdatePicture{\v CCapturePin__videoFastUpdatePicture}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCapturePin::videoNotDecodedMBs{\v CCapturePin__videoNotDecodedMBs}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCapturePin::videoSendSyncEveryGOB{\v CCapturePin__videoSendSyncEveryGOB}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CCapturePin::~CCapturePin{\v CCapturePin__.7eCCapturePin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::Prepare{\v CTAPIVCap__Prepare}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::Unprepare{\v CTAPIVCap__Unprepare}\par 

\par 
\pard\plain \s93\sl240 \fs21\lang1033 
\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::Active{\v CTAPIBasePin__Active}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::ActivePause{\v CTAPIBasePin__ActivePause}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::ActiveRun{\v CTAPIBasePin__ActiveRun}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::CheckMediaType{\v CTAPIBasePin__CheckMediaType}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::CloseSoftCamCtrl{\v CTAPIBasePin__CloseSoftCamCtrl}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::Commit{\v CTAPIBasePin__Commit}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::CTAPIBasePin{\v CTAPIBasePin__CTAPIBasePin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::DecideAllocator{\v CTAPIBasePin__DecideAllocator}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::DecideBufferSize{\v CTAPIBasePin__DecideBufferSize}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::Decommit{\v CTAPIBasePin__Decommit}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::Flush{\v CTAPIBasePin__Flush}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetBuffer{\v CTAPIBasePin__GetBuffer}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetCurrentCPULoad{\v CTAPIBasePin__GetCurrentCPULoad}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetCurrentFrameRate{\v CTAPIBasePin__GetCurrentFrameRate}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetCurrentProcessingTime{\v CTAPIBasePin__GetCurrentProcessingTime}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetFormat{\v CTAPIBasePin__GetFormat}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetMaxCPULoad{\v CTAPIBasePin__GetMaxCPULoad}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetMaxCPULoadRange{\v CTAPIBasePin__GetMaxCPULoadRange}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetMaxFrameRate{\v CTAPIBasePin__GetMaxFrameRate}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetMaxFrameRateRange{\v CTAPIBasePin__GetMaxFrameRateRange}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetMaxProcessingTime{\v CTAPIBasePin__GetMaxProcessingTime}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetMaxProcessingTimeRange{\v CTAPIBasePin__GetMaxProcessingTimeRange}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetMediaType{\v CTAPIBasePin__GetMediaType}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetNumberOfCapabilities{\v CTAPIBasePin__GetNumberOfCapabilities}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetProperties{\v CTAPIBasePin__GetProperties}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::GetStreamCaps{\v CTAPIBasePin__GetStreamCaps}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::Inactive{\v CTAPIBasePin__Inactive}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::IsSoftCamCtrlOpen{\v CTAPIBasePin__IsSoftCamCtrlOpen}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_AvgTimePerFrameRangeDefault{\v CTAPIBasePin__m_AvgTimePerFrameRangeDefault}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_AvgTimePerFrameRangeMax{\v CTAPIBasePin__m_AvgTimePerFrameRangeMax}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_AvgTimePerFrameRangeMin{\v CTAPIBasePin__m_AvgTimePerFrameRangeMin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_AvgTimePerFrameRangeSteppingDelta{\v CTAPIBasePin__m_AvgTimePerFrameRangeSteppingDelta}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_CurrentAvgTimePerFrame{\v CTAPIBasePin__m_CurrentAvgTimePerFrame}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_CurrentProcessingTime{\v CTAPIBasePin__m_CurrentProcessingTime}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_dwBitrateRangeDefault{\v CTAPIBasePin__m_dwBitrateRangeDefault}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_dwBitrateRangeMax{\v CTAPIBasePin__m_dwBitrateRangeMax}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_dwBitrateRangeMin{\v CTAPIBasePin__m_dwBitrateRangeMin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_dwBitrateRangeSteppingDelta{\v CTAPIBasePin__m_dwBitrateRangeSteppingDelta}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_dwConversionType{\v CTAPIBasePin__m_dwConversionType}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_dwCurrentBitrate{\v CTAPIBasePin__m_dwCurrentBitrate}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_dwCurrentCPULoad{\v CTAPIBasePin__m_dwCurrentCPULoad}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_dwFrame{\v CTAPIBasePin__m_dwFrame}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_dwLastIFrameTime{\v CTAPIBasePin__m_dwLastIFrameTime}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_dwLastTimestamp{\v CTAPIBasePin__m_dwLastTimestamp}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_dwMaxBitrate{\v CTAPIBasePin__m_dwMaxBitrate}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_dwMaxCPULoad{\v CTAPIBasePin__m_dwMaxCPULoad}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_dwNumBytesDelivered{\v CTAPIBasePin__m_dwNumBytesDelivered}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_dwNumFramesDelivered{\v CTAPIBasePin__m_dwNumFramesDelivered}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_fConvert{\v CTAPIBasePin__m_fConvert}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_fFlipHorizontal{\v CTAPIBasePin__m_fFlipHorizontal}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_fFlipVertical{\v CTAPIBasePin__m_fFlipVertical_1}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_fFlipVertical{\v CTAPIBasePin__m_fFlipVertical}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_fPeriodicIFrames{\v CTAPIBasePin__m_fPeriodicIFrames}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_fSoftCamCtrl{\v CTAPIBasePin__m_fSoftCamCtrl}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_fTemporalCompress{\v CTAPIBasePin__m_fTemporalCompress}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_hIC{\v CTAPIBasePin__m_hIC}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_MaxAvgTimePerFrame{\v CTAPIBasePin__m_MaxAvgTimePerFrame}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_MaxProcessingTime{\v CTAPIBasePin__m_MaxProcessingTime}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_parms{\v CTAPIBasePin__m_parms}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_pbiIn{\v CTAPIBasePin__m_pbiIn}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_pbiInt{\v CTAPIBasePin__m_pbiInt}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_pbiOut{\v CTAPIBasePin__m_pbiOut}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_pbiSCCIn{\v CTAPIBasePin__m_pbiSCCIn}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_pbiSCCOut{\v CTAPIBasePin__m_pbiSCCOut}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_pbyCamCtrl{\v CTAPIBasePin__m_pbyCamCtrl}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_pbyOut{\v CTAPIBasePin__m_pbyOut}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::m_pCaptureFilter{\v CTAPIBasePin__m_pCaptureFilter}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::NonDelegatingQueryInterface{\v CTAPIBasePin__NonDelegatingQueryInterface}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::OpenSoftCamCtrl{\v CTAPIBasePin__OpenSoftCamCtrl}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::Reconnect{\v CTAPIBasePin__Reconnect}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::ReleaseBuffer{\v CTAPIBasePin__ReleaseBuffer}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::SendFrame{\v CTAPIBasePin__SendFrame}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::SetFormat{\v CTAPIBasePin__SetFormat}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::SetMaxCPULoad{\v CTAPIBasePin__SetMaxCPULoad}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::SetMaxFrameRate{\v CTAPIBasePin__SetMaxFrameRate}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::SetMaxProcessingTime{\v CTAPIBasePin__SetMaxProcessingTime}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::SetMediaType{\v CTAPIBasePin__SetMediaType}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::SetProperties{\v CTAPIBasePin__SetProperties}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIBasePin::~CTAPIBasePin{\v CTAPIBasePin__.7eCTAPIBasePin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::ReleaseFrame{\v CTAPIVCap__ReleaseFrame}\par 

\par 
\pard\plain \s93\sl240 \fs21\lang1033 
\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::Get{\v CTAPIVCap__Get}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::GetCurrentDevice{\v CTAPIVCap__GetCurrentDevice}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::GetDeviceInfo{\v CTAPIVCap__GetDeviceInfo}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::GetNumDevices{\v CTAPIVCap__GetNumDevices}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::GetRange{\v CTAPIVCap__GetRange}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_fDialogUp{\v CTAPIVCap__m_fDialogUp_2}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_fDialogUp{\v CTAPIVCap__m_fDialogUp}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_fDialogUp{\v CTAPIVCap__m_fDialogUp_1}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_lock{\v CTAPIVCap__m_lock_2}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_lock{\v CTAPIVCap__m_lock_1}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_lock{\v CTAPIVCap__m_lock}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_pCapturePin{\v CTAPIVCap__m_pCapturePin_2}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_pCapturePin{\v CTAPIVCap__m_pCapturePin_1}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_pCapturePin{\v CTAPIVCap__m_pCapturePin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_pOverlayPin{\v CTAPIVCap__m_pOverlayPin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_pOverlayPin{\v CTAPIVCap__m_pOverlayPin_2}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_pOverlayPin{\v CTAPIVCap__m_pOverlayPin_1}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_pPreviewPin{\v CTAPIVCap__m_pPreviewPin_2}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_pPreviewPin{\v CTAPIVCap__m_pPreviewPin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_pPreviewPin{\v CTAPIVCap__m_pPreviewPin_1}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::m_pRtpPdPin{\v CTAPIVCap__m_pRtpPdPin}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::Set{\v CTAPIVCap__Set}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CTAPIVCap::SetCurrentDevice{\v CTAPIVCap__SetCurrentDevice}\par 

\par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 Common control enums\par 
\pard\plain \s93\sl240 \fs21\lang1033 
\par 
\pard\plain \s93\sl240 \fs21\lang1033 
\par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 Common control structures\par 
\pard\plain \s93\sl240 \fs21\lang1033 
\par 
\pard\plain \s93\sl240 \fs21\lang1033 
\par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 Constants\par 
\pard\plain \s93\sl240 \fs21\lang1033 
\par 
\pard\plain \s93\sl240 \fs21\lang1033 
\pard\plain \s93\sl240 \fs21\lang1033 
CONVERSIONTYPE_DECODE{\v CONVERSIONTYPE_DECODE}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CONVERSIONTYPE_ENCODE{\v CONVERSIONTYPE_ENCODE}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CONVERSIONTYPE_NONE{\v CONVERSIONTYPE_NONE}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
CONVERSIONTYPE_SCALER{\v CONVERSIONTYPE_SCALER}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
DISPLAY_DLG_OFF{\v DISPLAY_DLG_OFF}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
DISPLAY_DLG_ON{\v DISPLAY_DLG_ON}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
FORMAT_DLG_OFF{\v FORMAT_DLG_OFF}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
FORMAT_DLG_ON{\v FORMAT_DLG_ON}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
NUM_4BIT_ENTRIES{\v NUM_4BIT_ENTRIES}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
NUM_8BIT_ENTRIES{\v NUM_8BIT_ENTRIES}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
SOURCE_DLG_OFF{\v SOURCE_DLG_OFF}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
SOURCE_DLG_ON{\v SOURCE_DLG_ON}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_BI_BITFIELDS{\v VIDEO_FORMAT_BI_BITFIELDS}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_BI_RGB{\v VIDEO_FORMAT_BI_RGB}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_BI_RLE4{\v VIDEO_FORMAT_BI_RLE4}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_BI_RLE8{\v VIDEO_FORMAT_BI_RLE8}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_CVID{\v VIDEO_FORMAT_CVID}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_112_80{\v VIDEO_FORMAT_IMAGE_SIZE_112_80}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_120_90{\v VIDEO_FORMAT_IMAGE_SIZE_120_90}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_128_96{\v VIDEO_FORMAT_IMAGE_SIZE_128_96}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_144_112{\v VIDEO_FORMAT_IMAGE_SIZE_144_112}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_160_120{\v VIDEO_FORMAT_IMAGE_SIZE_160_120}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_160_128{\v VIDEO_FORMAT_IMAGE_SIZE_160_128}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_176_144{\v VIDEO_FORMAT_IMAGE_SIZE_176_144}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_192_160{\v VIDEO_FORMAT_IMAGE_SIZE_192_160}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_200_150{\v VIDEO_FORMAT_IMAGE_SIZE_200_150}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_208_176{\v VIDEO_FORMAT_IMAGE_SIZE_208_176}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_224_192{\v VIDEO_FORMAT_IMAGE_SIZE_224_192}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_240_180{\v VIDEO_FORMAT_IMAGE_SIZE_240_180}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_240_208{\v VIDEO_FORMAT_IMAGE_SIZE_240_208}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_256_224{\v VIDEO_FORMAT_IMAGE_SIZE_256_224}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_272_240{\v VIDEO_FORMAT_IMAGE_SIZE_272_240}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_280_210{\v VIDEO_FORMAT_IMAGE_SIZE_280_210}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_288_256{\v VIDEO_FORMAT_IMAGE_SIZE_288_256}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_304_272{\v VIDEO_FORMAT_IMAGE_SIZE_304_272}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_320_240{\v VIDEO_FORMAT_IMAGE_SIZE_320_240}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_320_288{\v VIDEO_FORMAT_IMAGE_SIZE_320_288}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_336_288{\v VIDEO_FORMAT_IMAGE_SIZE_336_288}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_352_288{\v VIDEO_FORMAT_IMAGE_SIZE_352_288}\par 

\pard\plain \s93\sl240 \fs21\lang1033 
VIDEO_FORMAT_IMAGE_SIZE_40_30{\v VIDEO_FORMAT_IMAGE_SIZE_40_30}\par 

\pard\plain \s93\sl240 \fs21\lang1033 