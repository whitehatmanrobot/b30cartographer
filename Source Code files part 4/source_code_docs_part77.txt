g1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 iPosition}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a position in the media type list.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pMediaType}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to the media type at the }{\i\insrsid1197183 iPosition}{\insrsid1197183 
 position in the list of supported media types.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::GetMode
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::GetMode(long}{\insrsid1197183  }{
\i\insrsid1197183 Mode}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the video control mode of operation.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VIDCTRL.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 Mode}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to a value representing a combination of the flags from the }{\b\insrsid1197183 
VideoControlFlags}{\insrsid1197183  enumeration.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::GetNumberOfCapabilities
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::GetNumberOfCapabilities(int*}{
\insrsid1197183  }{\i\insrsid1197183 piCount}{\b\insrsid1197183 , int*}{\insrsid1197183  }{\i\insrsid1197183 piSize}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the number of stream capabilities structures.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 piCount}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to an int to receive the number of }{\b\insrsid1197183 
VIDEO_STREAM_CONFIG_CAPS}{\insrsid1197183  structures supported.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 piSize}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to an int to receive the size of the }{\b\insrsid1197183 
VIDEO_STREAM_CONFIG_CAPS}{\insrsid1197183  configuration structure.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::GetProperties
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::GetProperties(ALLOCATOR_PROPERTIES*}{
\insrsid1197183  }{\i\insrsid1197183 pProps}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the properties being used on this allocator.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/BASEPIN.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Th
is method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pProps}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to the requested allocator properties.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::GetStreamCaps
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::GetStreamCaps(int}{\insrsid1197183  }{
\i\insrsid1197183 iIndex}{\b\insrsid1197183 , AM_MEDIA_TYPE**}{\insrsid1197183  }{\i\insrsid1197183 ppmt}{\b\insrsid1197183 , LPBYTE}{\insrsid1197183  }{\i\insrsid1197183 pSCC}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve a video stream capability pair.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 iIndex}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the index to the desired media type and capability pair.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ppmt}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the address of a pointer to an }{\b\insrsid1197183 AM_MEDIA_TYPE}{\insrsid1197183 
 structure.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pSCC}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a }{\b\insrsid1197183 VIDEO_STREAM_CONFIG_CAPS}{\insrsid1197183 
 configuration structure.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::Inactive
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::Inactive(void) }{\insrsid1197183 
\par This method is called by the }{\b\insrsid1197183 CBaseFilter}{\insrsid1197183  implementation when the state changes from either paused or running to stopped.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/BASEPIN.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::IsSoftCamCtrlOpen
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::IsSoftCamCtrlOpen(void) }{\insrsid1197183 

\par This method checks if a software-only camera controller has already been opened.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/CAMERACS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns TRUE if a software-only camera controller has already been opened
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_AvgTimePerFrameRangeDefault
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 REFERENCE_TIME CTAPIBasePin::m_AvgTimePerFrameRangeDefault}{\insrsid1197183 
\par Target frame rate default.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_AvgTimePerFrameRangeMax
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 REFERENCE_TIME CTAPIBasePin::m_AvgTimePerFrameRangeMax}{\insrsid1197183 
\par Maximum target frame rate.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_AvgTimePerFrameRangeMin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 REFERENCE_TIME CTAPIBasePin::m_AvgTimePerFrameRangeMin}{\insrsid1197183 
\par Minimum target frame rate.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_AvgTimePerFrameRangeSteppingDelta
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 REFERENCE_TIME CTAPIBasePin::m_AvgTimePerFrameRangeSteppingDelta}{\insrsid1197183 
\par Target frame rate stepping delta.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_CurrentAvgTimePerFrame
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 REFERENCE_TIME CTAPIBasePin::m_CurrentAvgTimePerFrame}{\insrsid1197183 
\par Current frame rate.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_CurrentProcessingTime
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 REFERENCE_TIME CTAPIBasePin::m_CurrentProcessingTime}{\insrsid1197183 
\par Current processing time.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_dwBitrateRangeDefault
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CTAPIBasePin::m_dwBitrateRangeDefault}{\insrsid1197183 
\par Default target bitrate.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_dwBitrateRangeMax
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CTAPIBasePin::m_dwBitrateRangeMax}{\insrsid1197183 
\par Maximum target bitrate.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_dwBitrateRangeMin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CTAPIBasePin::m_dwBitrateRangeMin}{\insrsid1197183 
\par Minimum target bitrate.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_dwBitrateRangeSteppingDelta
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CTAPIBasePin::m_dwBitrateRangeSteppingDelta}{\insrsid1197183 
\par Target bitrate stepping delta.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_dwConversionType
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CTAPIBasePin::m_dwConversionType}{\insrsid1197183 
\par Specifies the format conversion operation necessary to go from the format of the captured video frames to the format of the data actually generated by the pin. It can be any combination of the following constants:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CONVERSIONTYPE_NONE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No conversion operation necessary
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CONVERSIONTYPE_ENCODE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies an encoding operation
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CONVERSIONTYPE_DECODE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a decoding operation
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CONVERSIONTYPE_SCALER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies an image size change
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_dwCurrentBitrate
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CTAPIBasePin::m_dwCurrentBitrate}{\insrsid1197183 
\par Current bitrate.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_dwCurrentCPULoad
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CTAPIBasePin::m_dwCurrentCPULoad}{\insrsid1197183 
\par Current CPU load.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_dwFrame
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CTAPIBasePin::m_dwFrame}{\insrsid1197183 
\par Current frame number.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_dwLastIFrameTime
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CTAPIBasePin::m_dwLastIFrameTime}{\insrsid1197183 
\par Remembers the last time we sent an I-frame downstream.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_dwLastTimestamp
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CTAPIBasePin::m_dwLastTimestamp}{\insrsid1197183 
\par Timestamps of the last frame generated, normalized to 29.97Hz.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_dwMaxBitrate
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CTAPIBasePin::m_dwMaxBitrate}{\insrsid1197183 
\par Target bitrate.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_dwMaxCPULoad
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CTAPIBasePin::m_dwMaxCPULoad}{\insrsid1197183 
\par Maximum CPU load.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_dwNumBytesDelivered
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CTAPIBasePin::m_dwNumBytesDelivered}{\insrsid1197183 
\par Counts number of bytes delivered, reset every second or so.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_dwNumFramesDelivered
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CTAPIBasePin::m_dwNumFramesDelivered}{\insrsid1197183 
\par Counts number of frames delivered, reset every second or so.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_fConvert
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL CTAPIBasePin::m_fConvert}{\insrsid1197183 
\par Set to TRUE after an ICM converter has been open successfully.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_fFlipHorizontal
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL CTAPIBasePin::m_fFlipHorizontal}{\insrsid1197183 
\par Set to TRUE if image is to be flipped horizontally.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_fFlipVertical
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL CTAPIBasePin::m_fFlipVertical}{\insrsid1197183 
\par Affects the quality of en encoded video stream.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_fFlipVertical
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL CTAPIBasePin::m_fFlipVertical}{\insrsid1197183 
\par Set to TRUE if image is to be flipped vertically.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_fPeriodicIFrames
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL CTAPIBasePin::m_fPeriodicIFrames}{\insrsid1197183 
\par Set to TRUE to generate I-frame periodically.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_fSoftCamCtrl
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL CTAPIBasePin::m_fSoftCamCtrl}{\insrsid1197183 
\par Set to TRUE after a software-only camera controller has been opened.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Do we really need m_dwNumFramesDelivered to be a member variable of this class?
\par Do we really need m_dwNumBytesDelivered to be a member variable of this class?
\par Do we really need this?
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_fTemporalCompress
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL CTAPIBasePin::m_fTemporalCompress}{\insrsid1197183 
\par Set to TRUE when the encoder uses some form or prediction.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_hIC
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HIC CTAPIBasePin::m_hIC}{\insrsid1197183 
\par Handle to the ICM image converter.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_MaxAvgTimePerFrame
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 REFERENCE_TIME CTAPIBasePin::m_MaxAvgTimePerFrame}{\insrsid1197183 
\par Target frame rate.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_MaxProcessingTime
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 REFERENCE_TIME CTAPIBasePin::m_MaxProcessingTime}{\insrsid1197183 
\par Maximum processing time.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_parms
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 ALLOCATOR_PROPERTIES CTAPIBasePin::m_parms}{\insrsid1197183 
\par Out allocator properties.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Supports IPin. Never created by COM, so no CreateInstance or entry in global FactoryTemplate table. Only ever created by a }{\b\insrsid1197183 CTAPIVCap}{\insrsid1197183  object and returned via the EnumPins interface
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_parms
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 ALLOCATOR_PROPERTIES CTAPIBasePin::m_parms}{\insrsid1197183 
\par Out allocator properties.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_pbiIn
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 PBITMAPINFOHEADER CTAPIBasePin::m_pbiIn}{\insrsid1197183 
\par Pointer to the input format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_pbiInt
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 PBITMAPINFOHEADER CTAPIBasePin::m_pbiInt}{\insrsid1197183 
\par Pointer to the intermediate format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_pbiOut
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 PBITMAPINFOHEADER CTAPIBasePin::m_pbiOut}{\insrsid1197183 
\par Pointer to the output format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_pbiSCCIn
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 PBITMAPINFOHEADER CTAPIBasePin::m_pbiSCCIn}{\insrsid1197183 
\par Pointer to the input format of a software-only camera controlled operation.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_pbiSCCOut
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 PBITMAPINFOHEADER CTAPIBasePin::m_pbiSCCOut}{\insrsid1197183 
\par Pointer to the output format of a software-only camera controlled operation.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_pbyCamCtrl
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 PBYTE CTAPIBasePin::m_pbyCamCtrl}{\insrsid1197183 
\par Intermediate buffer used in a software-only camera controlled operation.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_pbyOut
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 PBYTE CTAPIBasePin::m_pbyOut}{\insrsid1197183 
\par Pointer to the output buffer used in a conversion operation.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::m_pCaptureFilter
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CTAPIVCap* CTAPIBasePin::m_pCaptureFilter}{\insrsid1197183 
\par Pointer to the filter that owns us.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::NonDelegatingQueryInterface
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::NonDelegatingQueryInterface(REFIID}{
\insrsid1197183  }{\i\insrsid1197183 riid}{\b\insrsid1197183 , PVOID*}{\insrsid1197183  }{\i\insrsid1197183 ppv}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is the nondelegating interface query function. It returns a pointer to the specified interface if supported. The only interfaces explicitly supported being }{\b\insrsid1197183 IAMStreamConfig}{\insrsid1197183 , }{\b\insrsid1197183 
IAMStreamControl}{\insrsid1197183 , }{\b\insrsid1197183 ICPUControl}{\insrsid1197183 , }{\b\insrsid1197183 IFrameRateControl}{\insrsid1197183  and }{\b\insrsid1197183 IBitrateControl}{\insrsid1197183 .
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/BASEPIN.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the implementation of the interface.
 HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 riid}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the identifier of the interface to return.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ppv}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the place in which to put the interface pointer.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::OpenConverter
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::OpenConverter(PBITMAPINFOHEADER}{
\insrsid1197183  }{\i\insrsid1197183 pbiIn}{\b\insrsid1197183 , PBITMAPINFOHEADER}{\insrsid1197183  }{\i\insrsid1197183 pbiOut}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method opens a format converter.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/CONVERT.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pbiIn}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the input format.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pbiOut}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the output format.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Verify error management
\par Use the new format definition after the decoder has been implemented
\par Basd on the result of the previous call, re-allocate if necessary
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::OpenSoftCamCtrl
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::OpenSoftCamCtrl(void) }{\insrsid1197183 

\par This method opens a software-only camera controller.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/CAMERACS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Verify error management
\par Add software-only operators for RGB16, RGB8 and RGB4
\par Find a way to go around this extra memory copy in the preview case
\par Add software-only operators for RGB16, RGB8 and RGB4
\par Find a way to go around this extra memory copy in the preview case
\par Add software-only operators for RGB16, RGB8 and RGB4
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::Reconnect
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::Reconnect(void) }{\insrsid1197183 
\par This method is used to reconnect a pin to a downstream pin with a new format.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::ReleaseBuffer
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::ReleaseBuffer(IMediaSample*}{
\insrsid1197183  }{\i\insrsid1197183 pSample}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to release the }{\b\insrsid1197183 CMediaSample}{\insrsid1197183  object. The final call to Release() on }{\b\insrsid1197183 IMediaSample}{\insrsid1197183  will call this method.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/BASEPIN.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 S_OK
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pSample}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to the buffer to release.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::ScaleDIB
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::ScaleDIB(PBITMAPINFOHEADER}{
\insrsid1197183  }{\i\insrsid1197183 pbiSrc}{\b\insrsid1197183 , PBYTE}{\insrsid1197183  }{\i\insrsid1197183 pbySrc}{\b\insrsid1197183 , PBITMAPINFOHEADER}{\insrsid1197183  }{\i\insrsid1197183 pbiSrc}{\b\insrsid1197183 , PBYTE}{\insrsid1197183  }{
\i\insrsid1197183 pbyDst}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method a bitmap. For now, RGB24 only.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/CONVERT.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pbiSrc}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the input bitmap format.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pbySrc}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the input bitmap.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pbiSrc}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the output bitmap format.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pbyDst}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the output bitmap.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 
You'll need a function like this one for RGB16 and RGB8 too. In RGB8, make sure you use the Indeo palette.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::ScaleDIB
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::ScaleDIB(PBITMAPINFOHEADER}{
\insrsid1197183  }{\i\insrsid1197183 pbi}{\b\insrsid1197183 , PBYTE}{\insrsid1197183  }{\i\insrsid1197183 pbySrc}{\b\insrsid1197183 , PBYTE}{\insrsid1197183  }{\i\insrsid1197183 pbyDst}{\b\insrsid1197183 , LPRECT}{\insrsid1197183  }{\i\insrsid1197183 
prcRect}{\b\insrsid1197183 , BOOL}{\insrsid1197183  }{\i\insrsid1197183 fFlipHorizontal}{\b\insrsid1197183 , BOOL}{\insrsid1197183  }{\i\insrsid1197183 fFlipVertical}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method scales/flips a bitmap rectangle. For now, RGB24 only.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/CONVERT.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method 
returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pbi}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the bitmap format.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pbySrc}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the input bitmap.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pbyDst}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the output bitmap.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 prcRect}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the relevant rectangle in the input bitmap.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 fFlipHorizontal}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Set to TRUE if the output bitmap is to be flipped horizontally.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 fFlipVertical}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Set to TRUE if the output bitmap is to be flipped vertically.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 
You'll need a function like this one for RGB16 and RGB8 too. In RGB8, make sure you use the Indeo palette.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::SendFrame
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::SendFrame(CFrameSample}{\insrsid1197183  
}{\i\insrsid1197183 pSample}{\b\insrsid1197183 , LPTHKVIDEOHDR}{\insrsid1197183  }{\i\insrsid1197183 ptvh}{\b\insrsid1197183 , PDWORD}{\insrsid1197183  }{\i\insrsid1197183 pdwBytesUsed}{\b\insrsid1197183 , BOOL}{\insrsid1197183  }{\i\insrsid1197183 
bDiscon}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to send a a media sample downstream.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/BASEPIN.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT valu
e that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 S_OK
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 S_FALSE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 If the pin is off (IAMStreamControl)
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pSample}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to the media sample to send downstream.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ptvh}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to the video header of the video capture buffer associated to this sample.

\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pdwBytesUsed}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a DWORD to receive the s
ize of the frame that has been delivered downstream.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 bDiscon}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Set to TRUE if this is the first frame we ever sent downstream.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 
What you really want to do, if possible, is simply update the sample pointer to point to m_pbyCamCtrl instead of the video capture buffer.
\par This is probably not representative of what the encoder has generated, but who cares?
\par Put some frame-grabbing specific timings here
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::SetFormat
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::SetFormat(AM_MEDIA_TYPE*}{
\insrsid1197183  }{\i\insrsid1197183 pmt}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to set a specific media type on a pin.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pmt}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to an }{\b\insrsid1197183 AM_MEDIA_TYPE}{\insrsid1197183  structure.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::SetMaxBitrate
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::SetMaxBitrate(DWORD}{\insrsid1197183  }{
\i\insrsid1197183 dwMaxBitrate}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwLayerId}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to specify to the output pin the upper limit in bandwidth transmission.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/BITRATE.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method retu
rns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwMaxBitrate}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the new limit in bandwidth transmission to an output pin, in bits/s.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwLayerId}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies the ID of the encoding layer the call applies to. For standard audio and video encoders, this field is always set to 0
. In the case of multi-layered encoders, this field shall be set to 0 for the base layer, 1 for the first enhancement layer, 2 for the next enhancement layer, etc
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::SetMaxCPULoad
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::SetMaxCPULoad(DWORD}{\insrsid1197183  }{
\i\insrsid1197183 dwMaxCPULoad}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to specify to the compressed video output pin the maximum encoding algorithm CPU load.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/CPUC.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the implementation of th
e interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwMaxCPULoad}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the maximum encoding algorithm CPU load, in percentage units.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::SetMaxFrameRate
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::SetMaxFrameRate(REFERENCE_TIME}{
\insrsid1197183  }{\i\insrsid1197183 AvgTimePerFrame}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to specify to the output pin the new video frame's average display time.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FPSRATE.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 AvgTimePerFrame}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Used to specify the new video frame's average display time to an output pin, in 100-nanosecond units.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::SetMaxProcessingTime
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::SetMaxProcessingTime(REFERENCE_TIME}{
\insrsid1197183  }{\i\insrsid1197183 MaxProcessingTime}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to specify to the compressed video output pin the maximum encoding time per frame, in 100-nanosecond units.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/CPUC.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This meth
od returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 MaxProcessingTime}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the maximum encoding time per frame, in 100-nanosecond units.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::SetMediaType
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::SetMediaType(CMediaType*}{
\insrsid1197183  }{\i\insrsid1197183 pMediaType}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to set a specific media type on a pin.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pMediaType}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to the media type.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Beware if you are previewing at the same time!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::SetMode
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::SetMode(long}{\insrsid1197183  }{
\i\insrsid1197183 Mode}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to set the video control mode of operation.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VIDCTRL.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 Mode}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify a combination of the flags from the }{\b\insrsid1197183 VideoControlFlags}{
\insrsid1197183  enumeration.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::SetProperties
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::SetProperties(ALLOCATOR_PROPERTIES*}{
\insrsid1197183  }{\i\insrsid1197183 pRequest}{\b\insrsid1197183 , ALLOCATOR_PROPERTIES*}{\insrsid1197183  }{\i\insrsid1197183 pActual}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to specify the size, number, and alignment of blocks.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/BASEPIN.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pRequest}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to the requested allocator properties.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pActual}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to the allocator properties actually set.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIBasePin::~CTAPIBasePin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 void}{\insrsid1197183  }{\b\insrsid1197183 CTAPIBasePin::~CTAPIBasePin(void) }{\insrsid1197183 

\par This method is the destructor for the }{\b\insrsid1197183 CTAPIBasePin}{\insrsid1197183  object.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/BASEPIN.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Nada.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap Class
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 class CTAPIVCap}{\insrsid1197183 
\par This class implements the TAPI Video Capture Source filter.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICE.H
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap Class
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 class CTAPIVCap}{\insrsid1197183 
\par This class implements the TAPI VfW Capture Source filter.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICE.H
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap Class
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 class CTAPIVCap}{\insrsid1197183 
\par This class implements the TAPI VfW Capture Source filter.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.H
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::Capture
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::Capture(void) }{\insrsid1197183 
\par This method is used to run the capture loop. Executes while in the run state.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WRKRTHD.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Remove this before checkin!
\par Hmmm, you're assuming always 6 buffers here... KABOOM!
\par Hmmm, you're assuming always 6 buffers here... KABOOM!
\par Isn't there a better way to return the buffer to the device?
\par Isn't there a better way to return the buffer to the device?
\par Remove all OutputDebugString
\par Remove all OutputDebugString
\par Remove all OutputDebugString
\par Remove all OutputDebugString
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::ChangeThdState
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::ChangeThdState(void) }{\insrsid1197183 
\par This method changes the state of the capture worker thread.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WRKRTHD.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns new thread state
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::CreateInstance
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CUnknown*}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::CreateInstance(LPUNKNOWN}{\insrsid1197183 
 }{\i\insrsid1197183 pUnkOuter}{\b\insrsid1197183 , HRESULT*}{\insrsid1197183  }{\i\insrsid1197183 pHr}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is called by DShow to create an instance of the TAPI VfW Capture Source filter referred to in the global structure }{\b\insrsid1197183 g_Templates}{\insrsid1197183 .
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns a pointer to the nondelegating CUnknown portion of the object, or NULL otherwise.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pUnkOuter}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the outer unknown, if any.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pHr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the place in which to put any error return.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Step through this code!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::CreatePins
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::CreatePins(DWORD}{\insrsid1197183  }{
\i\insrsid1197183 dwMilliSecsTimeout}{\b\insrsid1197183 , FILTER_STATE*}{\insrsid1197183  }{\i\insrsid1197183 State}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the current state of the filter. We don't send any data during PAUSE, so to avoid hanging renderers, we need to return VFW_S_CANT_CUE when paused.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwMilliSecsTimeout}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the duration of the time-out, in milliseconds.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 State}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the name of the filter being added.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 You should delete the created pins if one of the pins fails to be created!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::CreateThd
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::CreateThd(void) }{\insrsid1197183 
\par This method creates the capture worker thread.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WRKRTHD.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns TRUE on success, FALSE otherwise.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::CTAPIVCap
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 void}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::CTAPIVCap(void) }{\insrsid1197183 
\par This method is the constructor for the }{\b\insrsid1197183 CTAPIVCap}{\insrsid1197183  object. It only gets the OS type.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Nada.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Use some const defines, please!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::DestroyThd
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::DestroyThd(void) }{\insrsid1197183 
\par This method waita for the worker thread to die before performing some cleanup.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WRKRTHD.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns TRUE
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::FindIDByRange
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::FindIDByRange(AM_MEDIA_TYPE*}{
\insrsid1197183  }{\i\insrsid1197183 pAMMediaType}{\b\insrsid1197183 , DWORD*}{\insrsid1197183  }{\i\insrsid1197183 pdwID}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to obtain the unique format ID of a capability that corresponds to an }{\b\insrsid1197183 AM_MEDIA_TYPE}{\insrsid1197183 .
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/H245VIDC.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pAMMediaType}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to an }{\b\insrsid1197183 AM_MEDIA_TYPE}{\insrsid1197183 
 structure that has been initialized indicate a specific format.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pdwID}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a DWORD output parameter that will contain the unique format ID.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Put some real code here!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::Get
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::Get(VideoProcAmpProperty}{\insrsid1197183  }
{\i\insrsid1197183 Property}{\b\insrsid1197183 , long*}{\insrsid1197183  }{\i\insrsid1197183 plValue}{\b\insrsid1197183 , VideoProcAmpFlags*}{\insrsid1197183  }{\i\insrsid1197183 plFlags}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the value of a video quality setting.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/PROCAMP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_PROP_ID_UNSUPPORTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The specified property ID is not supported for the specified property set
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 Property}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the video quality setting to get the value of. Use a member of the }{
\b\insrsid1197183 VideoProcAmpProperty}{\insrsid1197183  enumerated type.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plValue}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to retrieve the current value of the video quality setting.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plFlags}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to a member of the }{\b\insrsid1197183 VideoProcAmpFlags}{\insrsid1197183 
 enumerated type.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Put some real code here!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::Get
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::Get(CameraControlProperty}{\insrsid1197183  
}{\i\insrsid1197183 Property}{\b\insrsid1197183 , long*}{\insrsid1197183  }{\i\insrsid1197183 plValue}{\b\insrsid1197183 , long*}{\insrsid1197183  }{\i\insrsid1197183 plFlags}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the value of a camera control setting.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/CAMERAC.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_PROP_ID_UNSUPPORTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The specified property ID is not supported for the specified property set
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 Property}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the camera control setting to get the value of. Use a member of the }{
\b\insrsid1197183 CameraControlProperty}{\insrsid1197183  enumerated type.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plValue}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to retrieve the current value of the camera control setting.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plFlags}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to a member of the }{\b\insrsid1197183 CameraControlFlags}{\insrsid1197183  
enumerated type.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetCaps
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetCaps(IPin*}{\insrsid1197183  }{
\i\insrsid1197183 pPin}{\b\insrsid1197183 , long*}{\insrsid1197183  }{\i\insrsid1197183 pCapsFlags}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the capabilities of the TAPI MSP Video Capture filter regarding flipping pictures and external triggers.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VIDCTRL.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pPin}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the video output pin to query capabilities from.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pCapsFlags}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to retrieve a value representing a combination of the flags from the }{\b\insrsid1197183 
VideoControlFlags}{\insrsid1197183  enumeration.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetCurrentActualFrameRate
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetCurrentActualFrameRate(IPin*}{
\insrsid1197183  }{\i\insrsid1197183 pPin}{\b\insrsid1197183 , LONGLONG*}{\insrsid1197183  }{\i\insrsid1197183 ActualFrameRate}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the actual frame rate, expressed as a frame duration in 100 ns units.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VIDCTRL.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pPin}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the pin to retrieve the frame rate from.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ActualFrameRate}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the frame rate in frame duration in 100 nS units.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetCurrentDevice
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetCurrentDevice(PDWORD}{\insrsid1197183  }{
\i\insrsid1197183 pdwDeviceIndex}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to determine the index of the capture device currently used.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVENUM.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This me
thod returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VFW_E_NO_CAPTURE_HARDWARE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No Capture hardware is available
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pdwDeviceIndex}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a DWORD to receive the index of the capture device currently used.

\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetDeviceInfo
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetDeviceInfo(DWORD}{\insrsid1197183  }{
\i\insrsid1197183 dwDeviceIndex}{\b\insrsid1197183 , PDEVICEINFO}{\insrsid1197183  }{\i\insrsid1197183 pDeviceInfo}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve information about a capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVENUM.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the implementation of the interface. 
HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwDeviceIndex}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the device index of the capture device to return information about.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pDeviceInfo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a }{\b\insrsid1197183 DEVICEINFO}{\insrsid1197183 
 structure to receive information about a capture device.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetFormatTable
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetFormatTable(IPin*}{\insrsid1197183  }{
\i\insrsid1197183 pPin}{\b\insrsid1197183 , H245VideoCapabilityTable*}{\insrsid1197183  }{\i\insrsid1197183 pTable}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to obtain }{\b\insrsid1197183 H245VideoCapabilityMap}{\insrsid1197183 
 structures for all formats and format options that the TAPI MSP Video Capture filter supports. The content of the capability information that the TAPI MSP Capability module obtains via this method is a t
wo dimensional table that relates every supported transmit format to steady-state resource requirements of that format.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/H245VIDC.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on 
the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pPin}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to the video capture or still-image output pi
n of the capture device. The TAPI MSP Video Capture filter enumerates the list of formats supported by this pin to build its own video capability table.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pTable}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to an }{\b\insrsid1197183 H245VideoCapabilityTable}{\insrsid1197183 
 structure.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The memory allocated by }{\b\insrsid1197183 GetFormatTable}{\insrsid1197183  is released by calling }{
\b\insrsid1197183 ReleaseFormatTable}{\insrsid1197183 
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Put some real code here!
\par Put some real code here!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetFrameRateList
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetFrameRateList(IPin*}{\insrsid1197183  }{
\i\insrsid1197183 pPin}{\b\insrsid1197183 , long}{\insrsid1197183  }{\i\insrsid1197183 iIndex}{\b\insrsid1197183 , SIZE}{\insrsid1197183  }{\i\insrsid1197183 Dimensions}{\b\insrsid1197183 , long*}{\insrsid1197183  }{\i\insrsid1197183 ListSize}{
\b\insrsid1197183 , LONGLONG**}{\insrsid1197183  }{\i\insrsid1197183 MaxAvailableFrameRate}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the list of available frame rates.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VIDCTRL.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the 
implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pPin}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the pin to retrieve the frame rates from.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 iIndex}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Used to specify the index of the format to query for frame rates. This index corresponds to the order in which formats are enumerated by IAMStreamConfig::GetStreamCaps. The value must range between 0 and the number of supported }{\b\insrsid1197183 
VIDEO_STREAM_CONFIG_CAPS}{\insrsid1197183  structures returned by IAMStreamConfig::GetNumberOfCapabilities.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 Dimensions}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the frame's image size (width and height) in pixels.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ListSize}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the number of elements in the list of frame rates.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 MaxAvailableFrameRate}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to an array of frame rates in 100 ns units. Can be NULL if only }{\i\insrsid1197183 
ListSize}{\insrsid1197183  is wanted.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetH245VersionID
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetH245VersionID(void) }{\insrsid1197183 

\par This method is used to retrieve a DWORD value that identifies the platform version that the TAPI MSP Video Capture filter was designed for. The platform version is defined as TAPI_H245_VERSION_ID.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/H245VIDC.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value
 that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Validate the H.245 version with Mike
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetLocalFormat
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetLocalFormat(H245VideoCapability*}{
\insrsid1197183  }{\i\insrsid1197183 pRemoteCapability}{\b\insrsid1197183 , HANDLE*}{\insrsid1197183  }{\i\insrsid1197183 phIntersectionCookie}{\b\insrsid1197183 , AM_MEDIA_TYPE*}{\insrsid1197183  }{\i\insrsid1197183 pAMMediaType}{\b\insrsid1197183 ) }{
\insrsid1197183 
\par This method is used to obtain the local TAPI MSP Video Capture filter configuration parameters that are compatible with a remote capability.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/H245VIDC.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pRemoteCapability}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies the H.245 video format, including all parameters and options defined by H.245, of a remote video capability.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 phIntersectionCookie}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Identif
ies the dynamic instance of intersected capabilities. When the TAPI MSP Video Capture filter creates the intersection, it may allocate memory for the intersected capability parameters. The intersection cookie identifies this allocation. This is used to re
lease internal allocations and also as an argument to the }{\b\insrsid1197183 GetNegotiatedLimitProperty}{\insrsid1197183  method.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pAMMediaType}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to an }{\b\insrsid1197183 AM_MEDIA_TYPE}{\insrsid1197183 
 structure that has been initialized to regard negotiated options.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 GetNegotiatedLimitProperty}{\insrsid1197183 
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Put some real code here!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetMaxAvailableFrameRate
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetMaxAvailableFrameRate(IPin*}{
\insrsid1197183  }{\i\insrsid1197183 pPin}{\b\insrsid1197183 , long}{\insrsid1197183  }{\i\insrsid1197183 iIndex}{\b\insrsid1197183 , SIZE}{\insrsid1197183  }{\i\insrsid1197183 Dimensions}{\b\insrsid1197183 , LONGLONG*}{\insrsid1197183  }{
\i\insrsid1197183 MaxAvailableFrameRate}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the maximum frame rate currently available, based on bus bandwidth usage for connections, such as USB (Universal Serial Bus) and IEEE 1394, where the maximum frame rate may be limited due to bandwidth availability.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VIDCTRL.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 T
his method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pPin}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the pin to retrieve the frame rate from.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 iIndex}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Used to specify the index of the format to query for frame rates. This index corresponds to the order in which formats are enumerated by IAMStreamConfig::GetStreamCaps. The value must range between 0 and the number of supported }{\b\insrsid1197183 
VIDEO_STREAM_CONFIG_CAPS}{\insrsid1197183  structures returned by IAMStreamConfig::GetNumberOfCapabilities.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 Dimensions}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the frame's image size (width and height) in pixels.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 MaxAvailableFrameRate}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the maximum available frame rate in frame duration in 100 nS units.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetMode
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetMode(IPin*}{\insrsid1197183  }{
\i\insrsid1197183 pPin}{\b\insrsid1197183 , long}{\insrsid1197183  }{\i\insrsid1197183 Mode}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the video control mode of operation.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VIDCTRL.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pPin}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the pin to get the video control mode from.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 Mode}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to a value representing a combination of the flags from the }{\b\insrsid1197183 
VideoControlFlags}{\insrsid1197183  enumeration.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetNegotiatedLimitProperty
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetNegotiatedLimitProperty(HANDLE}{
\insrsid1197183  }{\i\insrsid1197183 hIntersectionCookie}{\b\insrsid1197183 , NegotiatedVideoLimit}{\insrsid1197183  }{\i\insrsid1197183 LimitProperty}{\b\insrsid1197183 , DWORD*}{\insrsid1197183  }{\i\insrsid1197183 pdwValue}{\b\insrsid1197183 ) }{
\insrsid1197183 
\par This method is used to obtain negotiated limits that were determined by either the }{\b\insrsid1197183 IntersectFormats}{\insrsid1197183  or }{\b\insrsid1197183 GetLocalFormat}{\insrsid1197183  method.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/H245VIDC.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the im
plementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hIntersectionCookie}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Identifies the dynamic instance of intersected capabilities.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 LimitProperty}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Identifies the limit property being retrieved.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pdwValue}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a DWORD to receive the value of the specified limit property.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 IntersectFormats}{\insrsid1197183 , }{\b\insrsid1197183 GetLocalFormat}{\insrsid1197183 
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Are you sure 0 is not a valid handle here?
\par Put some real code here!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetNumDevices
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetNumDevices(PDWORD}{\insrsid1197183  }{
\i\insrsid1197183 pdwNumDevices}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to determine the number of installed capture devices. This number includes only enabled devices.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVENUM.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pdwNumDevices}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a DWORD to receive the number of installed capture devices.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetPages
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetPages(CAUUID*}{\insrsid1197183  }{
\i\insrsid1197183 pPages}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method Fills a counted array of GUID values where each GUID specifies the CLSID of each property page that can be displayed in the property sheet for this object.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT va
lue that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_OUTOFMEMORY
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Allocation failed
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pPages}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies a pointer to a caller-allocated CAUUID structure that must be initialized and filled before returning. The pElems field in the CAUUID structure is allocated by the callee with CoTaskMemAlloc and freed by the caller with CoTaskMemFree.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetPin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetPin(int}{\insrsid1197183  }{
\i\insrsid1197183 n}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method returns a non-addrefed pointer to the }{\b\insrsid1197183 cBasePin}{\insrsid1197183  of a pin.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns NULL or a pointer to a }{\b\insrsid1197183 CBasePin}{\insrsid1197183  object.

\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 n}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the number of the pin.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetPinCount
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetPinCount(void) }{\insrsid1197183 
\par This method returns the pin count. There is typically a Capture Pin, a Preview pin, and sometimes an Overlay pin.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns the number of pins.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetRange
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetRange(VideoProcAmpProperty}{
\insrsid1197183  }{\i\insrsid1197183 Property}{\b\insrsid1197183 , long*}{\insrsid1197183  }{\i\insrsid1197183 plMin}{\b\insrsid1197183 , long*}{\insrsid1197183  }{\i\insrsid1197183 plMax}{\b\insrsid1197183 , long*}{\insrsid1197183  }{\i\insrsid1197183 
plSteppingDelta}{\b\insrsid1197183 , long*}{\insrsid1197183  }{\i\insrsid1197183 plDefault}{\b\insrsid1197183 , VideoProcAmpFlags*}{\insrsid1197183  }{\i\insrsid1197183 plCapsFlags}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the minimum, maximum, and default values for specific video quality settings.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/PROCAMP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESUL
T value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_PROP_ID_UNSUPPORTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The specified property ID is not supported for the specified property set
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 Property}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the video quality setting to determine the range of. Use a member of the }{
\b\insrsid1197183 VideoProcAmpProperty}{\insrsid1197183  enumerated type.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plMin}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to retrieve the minimum value of the video quality setting range.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plMax}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to retrieve the maximum value of the video quality setting range.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plSteppingDelta}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to retrieve the stepping delta of the video quality setting range.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plDefault}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to retrieve the default value of the video quality setting range.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plCapsFlags}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to retrieve the capabilities of the video quality setting. Pointer to a member of the }{
\b\insrsid1197183 VideoProcAmpFlags}{\insrsid1197183  enumerated type.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Put some real code here!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetRange
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetRange(CameraControlProperty}{
\insrsid1197183  }{\i\insrsid1197183 Property}{\b\insrsid1197183 , long*}{\insrsid1197183  }{\i\insrsid1197183 plMin}{\b\insrsid1197183 , long*}{\insrsid1197183  }{\i\insrsid1197183 plMax}{\b\insrsid1197183 , long*}{\insrsid1197183  }{\i\insrsid1197183 
plSteppingDelta}{\b\insrsid1197183 , long*}{\insrsid1197183  }{\i\insrsid1197183 plDefault}{\b\insrsid1197183 , long*}{\insrsid1197183  }{\i\insrsid1197183 plCapsFlags}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the minimum, maximum, and default values for specific camera control settings.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/CAMERAC.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_PROP_ID_UNSUPPORTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The specified property ID is not supported for the specified property set
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 Property}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the camera control setting to determine the range of. Use a member of the }{
\b\insrsid1197183 CameraControlProperty}{\insrsid1197183  enumerated type.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plMin}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to retrieve the minimum value of the camera control setting range.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plMax}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to retrieve the maximum value of the camera control setting range.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plSteppingDelta}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to retrieve the stepping delta of the camera control setting range.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plDefault}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to retrieve the default value of the camera control setting range.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plCapsFlags}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to retrieve the capabilities of the camera control setting. Pointer to a member of the }{
\b\insrsid1197183 CameraControlFlags}{\insrsid1197183  enumerated type.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::GetState
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::GetState(DWORD}{\insrsid1197183  }{
\i\insrsid1197183 dwMilliSecsTimeout}{\b\insrsid1197183 , FILTER_STATE*}{\insrsid1197183  }{\i\insrsid1197183 State}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the current state of the filter. We don't send any data during PAUSE, so to avoid hanging renderers, we need to return VFW_S_CANT_CUE when paused.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HR
ESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwMilliSecsTimeout}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the duration of the time-out, in milliseconds.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 State}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the name of the filter being added.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::IntersectFormats
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::IntersectFormats(H245VideoCapability*}{
\insrsid1197183  }{\i\insrsid1197183 pLocalCapability}{\b\insrsid1197183 , H245VideoCapability*}{\insrsid1197183  }{\i\insrsid1197183 pRemoteCapability}{\b\insrsid1197183 , HANDLE*}{\insrsid1197183  }{\i\insrsid1197183 phIntersectionCookie}{
\b\insrsid1197183 , H245VideoCapability*}{\insrsid1197183  }{\i\insrsid1197183 pIntersectedCapability}{\b\insrsid1197183 , AM_MEDIA_TYPE*}{\insrsid1197183  }{\i\insrsid1197183 pAMMediaType}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to compare and intersect one local capability and one remote capability and to obtain configuration parameters.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/H245VIDC.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pLocalCapability}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies the H.245 video format, including all parameters and options defined by H.245, of a local video capability.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pRemoteCapability}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the H.245 video format, inc
luding all parameters and options defined by H.245, of a remote video capability.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 phIntersectionCookie}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Identifies the dynamic instance of intersected capabilities. When the TAPI MSP Video Capture filter creates the intersection, it may allocate memory for 
the intersected capability parameters. The intersection cookie identifies this allocation. This is used to release internal allocations and also as an argument to the }{\b\insrsid1197183 GetNegotiatedLimitProperty}{\insrsid1197183  method.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pIntersectedCapability}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the H.245 video forma
t, of the resolved common local and remote capability options and limits.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pAMMediaType}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to an }{\b\insrsid1197183 AM_MEDIA_TYPE}{\insrsid1197183 
 structure that has been initialized to regard negotiated options.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 GetNegotiatedLimitProperty}{\insrsid1197183 
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Put some real code here!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::JoinFilterGraph
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::JoinFilterGraph(IFilterGraph}{
\insrsid1197183  }{\i\insrsid1197183 pGraph}{\b\insrsid1197183 , LPCWSTR}{\insrsid1197183  }{\i\insrsid1197183 pName}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to inform a filter that it has joined a filter graph.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pGraph}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to the filter graph to join.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pName}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the name of the filter being added.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 We don't validate input parameters as both pointers can be NULL when we leave the graph.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Why only this device but not all installed devices?
\par The following delete may complain that m_user.pvi has been freed already investigate!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_fDialogUp
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL CTAPIVCap::m_fDialogUp}{\insrsid1197183 
\par Set to TRUE if a VfW driver dialog box is up
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Describe and clean up other members
\par Not all these need to be dynamic! Use constants whenever possibe. Camera control
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_fDialogUp
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL CTAPIVCap::m_fDialogUp}{\insrsid1197183 
\par Set to TRUE if a VfW driver dialog box is up
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_fDialogUp
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL CTAPIVCap::m_fDialogUp}{\insrsid1197183 
\par Set to TRUE if a VfW driver dialog box is up
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_lock
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CCritSec CTAPIVCap::m_lock}{\insrsid1197183 
\par Critical section used for locking by the }{\b\insrsid1197183 CBaseFilter}{\insrsid1197183  base class.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_lock
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CCritSec CTAPIVCap::m_lock}{\insrsid1197183 
\par Critical section used for locking by the }{\b\insrsid1197183 CBaseFilter}{\insrsid1197183  base class.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_lock
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CCritSec CTAPIVCap::m_lock}{\insrsid1197183 
\par Critical section used for locking by the }{\b\insrsid1197183 CBaseFilter}{\insrsid1197183  base class.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_pCapturePin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CCapturePin CTAPIVCap::m_pCapturePin}{\insrsid1197183 
\par Pointer to the capture pin object
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_pCapturePin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CCapturePin CTAPIVCap::m_pCapturePin}{\insrsid1197183 
\par Pointer to the capture pin object
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_pCapturePin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CCapturePin CTAPIVCap::m_pCapturePin}{\insrsid1197183 
\par Pointer to the capture pin object
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_pOverlayPin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 COverlayPin CTAPIVCap::m_pOverlayPin}{\insrsid1197183 
\par Pointer to the overlay pin object
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_pOverlayPin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 COverlayPin CTAPIVCap::m_pOverlayPin}{\insrsid1197183 
\par Pointer to the overlay pin object
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_pOverlayPin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 COverlayPin CTAPIVCap::m_pOverlayPin}{\insrsid1197183 
\par Pointer to the overlay pin object
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_pPreviewPin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CPreviewPin CTAPIVCap::m_pPreviewPin}{\insrsid1197183 
\par Pointer to the preview pin object
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_pPreviewPin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CPreviewPin CTAPIVCap::m_pPreviewPin}{\insrsid1197183 
\par Pointer to the preview pin object
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_pPreviewPin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CPreviewPin CTAPIVCap::m_pPreviewPin}{\insrsid1197183 
\par Pointer to the preview pin object
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::m_pRtpPdPin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CPreviewPin CTAPIVCap::m_pRtpPdPin}{\insrsid1197183 
\par Pointer to the Rtp Pd pin object
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::NonDelegatingQueryInterface
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::NonDelegatingQueryInterface(REFIID}{
\insrsid1197183  }{\i\insrsid1197183 riid}{\b\insrsid1197183 , PVOID*}{\insrsid1197183  }{\i\insrsid1197183 ppv}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is the nondelegating interface query function. It returns a pointer to the specified interface if supported. The only interfaces explicitly supported being }{\b\insrsid1197183 IAMVfwCaptureDialogs}{\insrsid1197183 , }{\b\insrsid1197183 
IAMVideoProcAmp}{\insrsid1197183 , }{\b\insrsid1197183 IAMCameraControl}{\insrsid1197183 , }{\b\insrsid1197183 IH245VideoCapability}{\insrsid1197183 , }{\b\insrsid1197183 IPersistStream}{\insrsid1197183  and }{\b\insrsid1197183 IPersistPropertyBag}{
\insrsid1197183 .
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 riid}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the identifier of the interface to return.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ppv}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the place in which to put the interface pointer.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::Pause
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::Pause(void) }{\insrsid1197183 
\par This method transitions the filter the filter to State_Paused state if it is not in this state already.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the implementati
on of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Actually, we want to be able and see the source dialog while running...
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::PauseThd
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::PauseThd(void) }{\insrsid1197183 
\par This method puts the capture worker thread in a paused state and wait for it to get there.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WRKRTHD.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the implement
ation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::Prepare
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::Prepare(void) }{\insrsid1197183 
\par This method is used to allocate resources in preparation for capture loop.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WRKRTHD.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Do some real error handling here
\par Before you can do the following you need to decouple the samples from the capture buffers. This means using two different queues: one for the capture samples, and o
ne for the capture buffers. This will also allow for a much smaller number of samples than capture buffers.
\par Do some real error handling here
\par Before you can do the following you need to decouple the samples from the capture buffers. This means using two dif
ferent queues: one for the capture samples, and one for the capture buffers. This will also allow for a much smaller number of samples than capture buffers.
\par Do some real error handling here
\par Before you can do the following you need to decouple the samples f
rom the capture buffers. This means using two different queues: one for the preview samples, and one for the capture buffers. This will also allow for a much smaller number of samples than capture buffers.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::ReleaseFormatTable
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::ReleaseFormatTable(H245VideoCapabilityTable*
}{\insrsid1197183  }{\i\insrsid1197183 pTable}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to to release memory allocated by the }{\b\insrsid1197183 GetFormatTable}{\insrsid1197183  method.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/H245VIDC.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value t
hat depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pTable}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to an }{\b\insrsid1197183 H245VideoCapabilityTable}{\insrsid1197183 
 structure.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 GetFormatTable}{\insrsid1197183 
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Put some real code here!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::ReleaseFrame
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::ReleaseFrame(LPTHKVIDEOHDR}{\insrsid1197183 
 }{\i\insrsid1197183 ptvh}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to return a buffer to the capture driver.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WRKRTHD.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 S_FALSE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 If the pin is off (IAMStreamControl)
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ptvh}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 ???.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Remove this before checkin!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::ReleaseNegotiatedCapability
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::ReleaseNegotiatedCapability(HANDLE}{
\insrsid1197183  }{\i\insrsid1197183 hIntersectionCookie}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to release the TAPI MSP Video Capture filter internal memory allocated by either the }{\b\insrsid1197183 IntersectFormats}{\insrsid1197183  or }{\b\insrsid1197183 GetLocalFormat}{\insrsid1197183  method.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/H245VIDC.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hIntersectionCookie}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Identifies the dynamic instance of intersected capabilities.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 IntersectFormats}{\insrsid1197183 , }{\b\insrsid1197183 GetLocalFormat}{\insrsid1197183 
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Are you sure 0 is not a valid handle here?
\par Put some real code here!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::Run
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::Run(REFERENCE_TIME}{\insrsid1197183  }{
\i\insrsid1197183 tStart}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method transitions the filter from paused to running state if it is not in this state already.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the implementation of the interface
. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 tStart}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the reference time value corresponding to stream time 0.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::RunThd
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::RunThd(void) }{\insrsid1197183 
\par This method puts the worker thread into the run state. This call does not wait for the state transition to be complete before returning.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WRKRTHD.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns TRUE on success, FALSE otherwise
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::Set
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::Set(CameraControlProperty}{\insrsid1197183  
}{\i\insrsid1197183 Property}{\b\insrsid1197183 , long}{\insrsid1197183  }{\i\insrsid1197183 lValue}{\b\insrsid1197183 , long}{\insrsid1197183  }{\i\insrsid1197183 Flags}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to set the value of a camera control setting.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/CAMERAC.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_PROP_ID_UNSUPPORTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The specified property ID is not supported for the specified property set
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 Property}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the camera control setting to set the value of. Use a member of the }{
\b\insrsid1197183 CameraControlProperty}{\insrsid1197183  enumerated type.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lValue}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the new value of the camera control setting.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 Flags}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 A member of the }{\b\insrsid1197183 CameraControlFlags}{\insrsid1197183  enumerated type.

\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::Set
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::Set(VideoProcAmpProperty}{\insrsid1197183  }
{\i\insrsid1197183 Property}{\b\insrsid1197183 , long}{\insrsid1197183  }{\i\insrsid1197183 lValue}{\b\insrsid1197183 , VideoProcAmpFlags}{\insrsid1197183  }{\i\insrsid1197183 Flags}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to set the value of a video quality setting.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/PROCAMP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT val
ue that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_PROP_ID_UNSUPPORTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The specified property ID is not supported for the specified property set
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 Property}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the video quality setting to set the value of. Use a member of the }{
\b\insrsid1197183 VideoProcAmpProperty}{\insrsid1197183  enumerated type.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lValue}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the new value of the video quality setting.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 Flags}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 A member of the }{\b\insrsid1197183 VideoProcAmpFlags}{\insrsid1197183  enumerated type.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Put some real code here!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::SetCurrentDevice
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::SetCurrentDevice(DWORD}{\insrsid1197183  }{
\i\insrsid1197183 dwDeviceIndex}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to specify the index of the capture device to use.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVENUM.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VFW_E_NOT_STOPPED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Need to stop this filter first
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VFW_E_NO_CAPTURE_HARDWARE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No Capture hardware is available
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwDeviceIndex}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the index of the capture device to use.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::SetIDBase
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::SetIDBase(DWORD}{\insrsid1197183  }{
\i\insrsid1197183 dwIDBase}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to control the sequential numbering range used to uniquely identify the TAPI MSP Video Capture filter capabilities.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/H245VIDC.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwIDBase}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a DWORD value that indicates the beginning number in the sequence.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 This dwIDBase value probably has a range. Figure it out and validate input param...
\par Put some real code here!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::SetMode
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::SetMode(IPin*}{\insrsid1197183  }{
\i\insrsid1197183 pPin}{\b\insrsid1197183 , long}{\insrsid1197183  }{\i\insrsid1197183 Mode}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to set the video control mode of operation.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VIDCTRL.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT v
alue that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_NOTIMPL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Method is not supported
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pPin}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify the pin to set the video control mode on.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 Mode}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Used to specify a combination of the flags from the }{\b\insrsid1197183 VideoControlFlags}{
\insrsid1197183  enumeration.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::SetSyncSource
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::SetSyncSource(void) }{\insrsid1197183 

\par This method identifies the reference clock to which the filter should synchronize activity.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the implementat
ion of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The }{\i\insrsid1197183 pClock}{\insrsid1197183  parameter can be NULL, meaning that the filter 
should run as fast as possible at its current quality settings without any attempt to synchronize...
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::Stop
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::Stop(void) }{\insrsid1197183 
\par This method transitions the filter the filter to State_Stopped state if it is not in this state already.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::StopThd
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::StopThd(void) }{\insrsid1197183 
\par This method puts the capture worker thread in a stopped state.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WRKRTHD.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns TRUE
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::ThreadProc
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::ThreadProc(void) }{\insrsid1197183 
\par Capture worker thread.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WRKRTHD.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns 0.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 General strategy for thread synchronization: 
as much as possible we try to handle thread state transitions without trying to grab any critical sections. we use InterlockedExchange of a thread state variable and count on the fact that only Active and Inactive and the ThreadProc can change the thread 
state
\par this works because: the caller of Active/Inactive is serialized so we will never try to make two state changes simultaneously. so state transitions boil down to a few simple possibilities:
\par Not->Create   - Create() does this. effectively serializes Create so that the first thread does the work and subsequent threads fail.
\par Create->Init  - worker does this when it starts up. worker will always proceed to Pause, this state exists only to make debugging easier. Init->Pause   - worker does this when done with initialization.
\par Pause->Run    - user does  this via Run() Run->Pause    - user does this via Pause()
\par Run->Stop     - user does this via Stop() Pause->Stop   - user does this via Stop()
\par Stop->Destroy - another debugging state. worker sets destroy to indic
ate that it has noticed Stop request and is not shutting down thread always proceeds to Exit from Destroy->Exit - worker does this prior to dying.  this is a debug transition Exit->Not     - Destroy() does this after waiting for the worker to die.
\par When Active returns, worker should always be in Pause or Run state When Inactive returns, worker should always be in Not state (worker does not exist)
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::ThreadProcInit
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::ThreadProcInit(void) }{\insrsid1197183 

\par Thread init stub.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WRKRTHD.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns 0
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::Unprepare
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::Unprepare(void) }{\insrsid1197183 
\par This method is used to free resources used by the capture loop.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WRKRTHD.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns NOERROR
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CTAPIVCap::~CTAPIVCap
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 void}{\insrsid1197183  }{\b\insrsid1197183 CTAPIVCap::~CTAPIVCap(void) }{\insrsid1197183 
\par This method is the destructor for the }{\b\insrsid1197183 CTAPIVCap}{\insrsid1197183  object.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Nada.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::AddBuffer
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::AddBuffer(PVIDEOHDR}{\insrsid1197183  }{
\i\insrsid1197183 pVHdr}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 cbVHdr}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to post a data buffer to a VfW capture device when video streaming.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pVHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a PVIDEOHDR structure identifying the video buffer.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 cbVHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the size of the structure pointed to by the }{\i\insrsid1197183 pVHdr}{
\insrsid1197183  parameter.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::AllocateBuffer
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::AllocateBuffer(LPTHKVIDEOHDR *}{
\insrsid1197183  }{\i\insrsid1197183 pptvh}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwIndex}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 cbBuffer}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to allocate a data buffer when video streaming from a VfW capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pptvh}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the address of a pointer to a THKVIDEOHDR structure to receive the video buffer.

\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwIndex}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the positional index of the video buffer.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 cbBuffer}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the size of the video buffer.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::AllocateHeaders
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::AllocateHeaders(DWORD}{\insrsid1197183  }{
\i\insrsid1197183 dwNumHdrs}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 cbHdr}{\b\insrsid1197183 , LPVOID*}{\insrsid1197183  }{\i\insrsid1197183 ppaHdr}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to video headers for data buffers used with a VfW capture device in streaming mode.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that 
depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwNumHdrs}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the number of video headers to allocate.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 cbHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the size of the video headers to allocate.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ppaHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the address of a pointer to receive the video headers allocated.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::ConnectToDriver
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::ConnectToDriver(void) }{\insrsid1197183 

\par This method is used to open a VfW capture device, get its format capibilities, and set a default format.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 You may have to do some palette work here
\par This should be adjusted on the available memory and the type of capture (streaming 4 buffs vs. frame grabbing 1 buff)
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::CreateVfWCapDev
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CVfWCapDev*}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::CreateVfWCapDev(CTAPIVCap*}{
\insrsid1197183  }{\i\insrsid1197183 pCaptureFilter}{\b\insrsid1197183 , CCapDev**}{\insrsid1197183  }{\i\insrsid1197183 ppCapDev}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This helper function creates an object to interact with the VfW capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_OUTOFMEMORY
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Out of memory
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pCaptureFilter}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to the owner filter.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ppCapDev}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the address of a pointer to the newly created }{\b\insrsid1197183 CVfWCapDev}{
\insrsid1197183  object.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::CVfWCapDev
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 void}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::CVfWCapDev(void) }{\insrsid1197183 
\par This method is the constructor for the }{\b\insrsid1197183 CVfWCapDev}{\insrsid1197183  object.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Nada.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::DisconnectFromDriver
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::DisconnectFromDriver(void) }{
\insrsid1197183 
\par This method is used to release the capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::FreeBuffer
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::FreeBuffer(PVIDEOHDR}{\insrsid1197183  }{
\i\insrsid1197183 pVHdr}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to free a data buffer that was used with a VfW capture device in streaming mode.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pVHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a PVIDEOHDR structure identifying the video buffer.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::GetFormatFromDriver
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::GetFormatFromDriver(VIDEOINFOHEADER **}{
\insrsid1197183  }{\i\insrsid1197183 ppvi}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the VfW capture device format in use.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ppvi}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies the address of a pointer to a video info header structure to receive the video format description.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Verify the value for this fps
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::GrabFrame
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::GrabFrame(PVIDEOHDR}{\insrsid1197183  }{
\i\insrsid1197183 pVHdr}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to grab a video frame from a VfW capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT valu
e that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pVHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a VIDEOHDR structure to receive the video frame.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::HasDialog
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::HasDialog(int}{\insrsid1197183  }{
\i\insrsid1197183 iDialog}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to determine if the specified dialog box exists in the driver.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VFWDLGS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_UNEXPECTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Unrecoverable error
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 S_OK
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 If the driver contains the dialog box
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 S_FALSE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 If the driver doesn't contain the dialog box
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 iDialog}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the desired dialog box. This is a member of the }{\b\insrsid1197183 VfwCaptureDialogs
}{\insrsid1197183  enumerated data type.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::InitializeStreaming
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::InitializeStreaming(DWORD}{\insrsid1197183 
 }{\i\insrsid1197183 usPerFrame}{\b\insrsid1197183 , DWORD_PTR}{\insrsid1197183  }{\i\insrsid1197183 hEvtBufferDone}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to initialize a VfW capture device for streaming.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESU
LT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 usPerFrame}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the frame rate to be used.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hEvtBufferDone}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to the event to be signaled whenever a frame is available.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::IsBufferDone
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::IsBufferDone(PVIDEOHDR}{\insrsid1197183  }{
\i\insrsid1197183 pVHdr}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to check the DONE status of a video streaming buffer.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns TRUE if the buffer is DONE, FALSE otherwise.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pVHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a PVIDEOHDR structure identifying the video buffer.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::NonDelegatingQueryInterface
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::NonDelegatingQueryInterface(REFIID}{
\insrsid1197183  }{\i\insrsid1197183 riid}{\b\insrsid1197183 , PVOID*}{\insrsid1197183  }{\i\insrsid1197183 ppv}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is the nondelegating interface query function. It returns a pointer to the specified interface if supported. The only interfaces explicitly supported being }{\b\insrsid1197183 IAMVfWCaptureDialogs}{\insrsid1197183 .
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 riid}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the identifier of the interface to return.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ppv}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the place in which to put the interface pointer.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::ProfileCaptureDevice
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::ProfileCaptureDevice(void) }{
\insrsid1197183 
\par This method is used to determine the list of formats supported by a VfW capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the
 implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_UNEXPECTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Unrecoverable error
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::SendDriverMessage
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::SendDriverMessage(int}{\insrsid1197183  }{
\i\insrsid1197183 iDialog}{\b\insrsid1197183 , int}{\insrsid1197183  }{\i\insrsid1197183 uMsg}{\b\insrsid1197183 , long}{\insrsid1197183  }{\i\insrsid1197183 dw1}{\b\insrsid1197183 , long}{\insrsid1197183  }{\i\insrsid1197183 dw2}{\b\insrsid1197183 ) }{
\insrsid1197183 
\par This method is used to send a driver-specific message.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VFWDLGS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the 
implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_UNEXPECTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Unrecoverable error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 iDialog}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the desired dialog box. This is a member of the }{\b\insrsid1197183 VfwCaptureDialogs
}{\insrsid1197183  enumerated data type.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 uMsg}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the message to send to the driver.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dw1}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies message data.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dw2}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies message data.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::SendFormatToDriver
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::SendFormatToDriver(LONG}{\insrsid1197183  }
{\i\insrsid1197183 biWidth}{\b\insrsid1197183 , LONG}{\insrsid1197183  }{\i\insrsid1197183 biHeight}{\b\insrsid1197183 , LONG}{\insrsid1197183  }{\i\insrsid1197183 biCompression}{\b\insrsid1197183 , WORD}{\insrsid1197183  }{\i\insrsid1197183 biBitCount}{
\b\insrsid1197183 , REFERENCE_TIME}{\insrsid1197183  }{\i\insrsid1197183 AvgTimePerFrame}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to tell the VfW capture device what format to use.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an
 HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 biWidth}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the image width.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 biHeight}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the image height.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 biCompression}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the format type.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 biBitCount}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the number of bits per pixel.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 AvgTimePerFrame}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the frame rate.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Fix units for fps
\par Rename those variables - it's the format, not the number of colors...
\par Copy the palette if there is one
\par Do I need to set a palette too?  Do I care?
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::ShowDialog
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::ShowDialog(int}{\insrsid1197183  }{
\i\insrsid1197183 iDialog}{\b\insrsid1197183 , HWND}{\insrsid1197183  }{\i\insrsid1197183 hwnd}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to displaay the specified dialog box.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VFWDLGS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_UNEXPECTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Unrecoverable error
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VFW_E_NOT_STOPPED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The operation could not be performed because the filter is not stopped
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VFW_E_CANNOT_CONNECT
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No combination of intermediate filters could be found to make the connection
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 iDialog}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the desired dialog box. This is a member of the }{\b\insrsid1197183 VfwCaptureDialogs
}{\insrsid1197183  enumerated data type.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hwnd}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the handle of the dialog box's parent window.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::StartStreaming
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::StartStreaming(void) }{\insrsid1197183 

\par This method is used to start streaming from a VfW capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::StopStreaming
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::StopStreaming(void) }{\insrsid1197183 

\par This method is used to stop streaming from a VfW capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::TerminateStreaming
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::TerminateStreaming(void) }{\insrsid1197183 

\par This method is used to tell a VfW capture device to terminate streaming.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CVfWCapDev::~CVfWCapDev
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 void}{\insrsid1197183  }{\b\insrsid1197183 CVfWCapDev::~CVfWCapDev(void) }{\insrsid1197183 
\par This method is the destructor for the }{\b\insrsid1197183 CVfWCapDev}{\insrsid1197183  object.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEV.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Nada.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev Class
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 class CWDMCapDev}{\insrsid1197183 
\par This class provides access to the streaming class driver, through which we acess the video capture mini-driver properties using IOCtls.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICE.H
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::AddBuffer
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::AddBuffer(PVIDEOHDR}{\insrsid1197183  }{
\i\insrsid1197183 pVHdr}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 cbVHdr}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to post a data buffer to a VfW capture device when video streaming.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on th
e implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pVHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a PVIDEOHDR structure identifying the video buffer.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 cbVHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the size of the structure pointed to by the }{\i\insrsid1197183 pVHdr}{
\insrsid1197183  parameter.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::AllocateBuffer
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::AllocateBuffer(LPTHKVIDEOHDR *}{
\insrsid1197183  }{\i\insrsid1197183 pptvh}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwIndex}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 cbBuffer}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to allocate a data buffer when video streaming from a VfW capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the 
implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pptvh}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the address of a pointer to a THKVIDEOHDR structure to receive the video buffer.

\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwIndex}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the positional index of the video buffer.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 cbBuffer}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the size of the video buffer.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::AllocateHeaders
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::AllocateHeaders(DWORD}{\insrsid1197183  }{
\i\insrsid1197183 dwNumHdrs}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 cbHdr}{\b\insrsid1197183 , LPVOID*}{\insrsid1197183  }{\i\insrsid1197183 ppaHdr}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to video headers for data buffers used with a WDM capture device in streaming mode.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the implementation of the interface. HRESULT c
an include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwNumHdrs}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the number of video headers to allocate.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 cbHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the size of the video headers to allocate.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ppaHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the address of a pointer to receive the video headers allocated.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Remove this before checkin!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::ConnectToDriver
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::ConnectToDriver(void) }{\insrsid1197183 

\par This method is used to open a WDM capture device, get its format capibilities, and set a default format.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Verify error management
\par You may have to do some palette work here
\par This should be adjusted on the available memory and the type of capture (streaming 4 buffs vs. frame grabbing 1 buff)
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::CreateDriverSupportedDataRanges
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::CreateDriverSupportedDataRanges(void) }{
\insrsid1197183 
\par This method builds the list of video data ranges supported by the capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns the number of valid data ranges in the list.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::CreateWDMCapDev
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CWDMCapDev*}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::CreateWDMCapDev(CTAPIVCap*}{
\insrsid1197183  }{\i\insrsid1197183 pCaptureFilter}{\b\insrsid1197183 , CCapDev**}{\insrsid1197183  }{\i\insrsid1197183 ppCapDev}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This helper function creates an object to interact with the WDM capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_OUTOFMEMORY
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Out of memory
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pCaptureFilter}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to the owner filter.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ppCapDev}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the address of a pointer to the newly created }{\b\insrsid1197183 CWDMCapDev}{
\insrsid1197183  object.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::CWDMCapDev
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 void}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::CWDMCapDev(void) }{\insrsid1197183 
\par This method is the constructor for the }{\b\insrsid1197183 CWDMCapDev}{\insrsid1197183  object.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Nada.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::DeQueueHeader
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 LPVIDEOHDR}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::DeQueueHeader(void) }{\insrsid1197183 

\par This function dequeues a video buffer from the list of video buffers used for streaming.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns a valid pointer if successful, or NULL otherwise.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::DeviceIoControl
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::DeviceIoControl(HANDLE}{\insrsid1197183  }{
\i\insrsid1197183 hFile}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwIoControlCode}{\b\insrsid1197183 , LPVOID}{\insrsid1197183  }{\i\insrsid1197183 lpInBuffer}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 
nInBufferSize}{\b\insrsid1197183 , LPVOID}{\insrsid1197183  }{\i\insrsid1197183 lpOutBuffer}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 nOutBufferSize}{\b\insrsid1197183 , LPDWORD}{\insrsid1197183  }{\i\insrsid1197183 lpBytesReturned}
{\b\insrsid1197183 , BOOL}{\insrsid1197183  }{\i\insrsid1197183 bOverlapped}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function wraps around ::DeviceIOControl.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns TRUE if successful, or FALSE otherwise.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hFile}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Handle to the device that is to perform the operation.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwIoControlCode}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the control code for the operation.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lpInBuffer}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to a buffer that contains the data required to perform the operation.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 nInBufferSize}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the size, in bytes, of the buffer pointed to by }{\i\insrsid1197183 lpInBuffer}{
\insrsid1197183 .
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lpOutBuffer}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to a buffer that receives the operation's output data.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 nOutBufferSize}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the size, in bytes, of the buffer pointed to by }{\i\insrsid1197183 lpOutBuffer}{
\insrsid1197183 .
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lpBytesReturned}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Pointer to a variable that receives the size, in bytes, of the data stored into the buffer pointed to by }{\i\insrsid1197183 lpOutBuffer}{\insrsid1197183 .
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 bOverlapped}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 If TRUE, the operation is performed asynchronously, if FALSE, the operation is synchronous.

\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::DisconnectFromDriver
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::DisconnectFromDriver(void) }{
\insrsid1197183 
\par This method is used to release the capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::FindMatchDataRangeVideo
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::FindMatchDataRangeVideo(PBITMAPINFOHEADER}{
\insrsid1197183  }{\i\insrsid1197183 pbiHdr}{\b\insrsid1197183 , BOOL}{\insrsid1197183  }{\i\insrsid1197183 pfValidMatch}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method either finds a video data range compatible with the bitamp info header passed in, or the prefered video data range.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns a valid pointer to a }{\b\insrsid1197183 KS_DATARANGE_VIDEO}{\insrsid1197183 
 structure if successful, or a NULL pointer otherwise.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pbiHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Bitmap info header to match.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pfValidMatch}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Set to TRUE if a match was found, FALSE otherwise.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 \\redrum\\slmro\\proj\\wdm10\\src\\dvd\\amovie\\proxy\\filter\\ksutil.cpp(207):KsGetMediaTypes(
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::FreeBuffer
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::FreeBuffer(PVIDEOHDR}{\insrsid1197183  }{
\i\insrsid1197183 pVHdr}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to free a data buffer that was used with a VfW capture device in streaming mode.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pVHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a PVIDEOHDR structure identifying the video buffer.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::GetDefaultValue
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::GetDefaultValue(GUID}{\insrsid1197183  }{
\i\insrsid1197183 guidPropertySet}{\b\insrsid1197183 , ULONG}{\insrsid1197183  }{\i\insrsid1197183 ulPropertyId}{\b\insrsid1197183 , PLONG}{\insrsid1197183  }{\i\insrsid1197183 plDefValue}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function gets the default value of a video property of a capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 guidPropertySet}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
GUID of the KS property set we are touching. It is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ulPropertyId}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
ID of the property we are touching. It is either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plDefValue}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to a LONG to receive the default value.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::GetDriverDetails
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::GetDriverDetails(void) }{\insrsid1197183 

\par This method is used to dump the list of capabilities of a WDM capture device. This code should used in DEBUG mode only!
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Nade
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::GetDriverSupportedDataRanges
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::GetDriverSupportedDataRanges(void) }{
\insrsid1197183 
\par This method returns the list of video data ranges supported by the capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns the number of valid data ranges in the list.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::GetFormatFromDriver
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::GetFormatFromDriver(VIDEOINFOHEADER **}{
\insrsid1197183  }{\i\insrsid1197183 ppvi}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve the WDM capture device format in use.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ppvi}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies the address of a pointer to a video info header structure to receive the video format description.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::GetPropertyValue
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::GetPropertyValue(GUID}{\insrsid1197183  }{
\i\insrsid1197183 guidPropertySet}{\b\insrsid1197183 , ULONG}{\insrsid1197183  }{\i\insrsid1197183 ulPropertyId}{\b\insrsid1197183 , PLONG}{\insrsid1197183  }{\i\insrsid1197183 plValue}{\b\insrsid1197183 , PULONG}{\insrsid1197183  }{\i\insrsid1197183 
pulFlags}{\b\insrsid1197183 , PULONG}{\insrsid1197183  }{\i\insrsid1197183 pulCapabilities}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function gets the current value of a video property of a capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 guidPropertySet}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
GUID of the KS property set we are touching. It is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ulPropertyId}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 ID of the property we ar
e touching. It is either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plValue}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to a LONG to receive the current value.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pulFlags}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Pointer to a ULONG to receive the current flags. We only care about KSPROPERTY_*_FLAGS_MANUAL or KSPROPERTY_*_FLAGS_AUTO.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pulCapabilities}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Pointer to a ULONG to receive the capabilities. We only care about KSPROPERTY_*_FLAGS_MANUAL or KSPROPERTY_*_FLAGS_AUTO.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Developer Notes

\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 KSPROPERTY_VIDEOPROCAMP_S == KSPROPERTY_CAMERACONTROL_S.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::GetRangeValues
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::GetRangeValues(GUID}{\insrsid1197183  }{
\i\insrsid1197183 guidPropertySet}{\b\insrsid1197183 , ULONG}{\insrsid1197183  }{\i\insrsid1197183 ulPropertyId}{\b\insrsid1197183 , PLONG}{\insrsid1197183  }{\i\insrsid1197183 plMin}{\b\insrsid1197183 , PLONG}{\insrsid1197183  }{\i\insrsid1197183 plMax}{
\b\insrsid1197183 , PLONG}{\insrsid1197183  }{\i\insrsid1197183 plStep}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function gets the range values of a video property of a capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 guidPropertySet}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
GUID of the KS property set we are touching. It is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ulPropertyId}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 ID of the property we are touching. It is either KSPROPERTY_VIDEOPROCAMP_* or KSPROPE
RTY_CAMERACONTROL_*.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plMin}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to a LONG to receive the minimum value.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plMax}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to a LONG to receive the maximum value.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 plStep}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to a LONG to receive the step value.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::GrabFrame
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::GrabFrame(PVIDEOHDR}{\insrsid1197183  }{
\i\insrsid1197183 pVHdr}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to grab a video frame from a VfW capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pVHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a VIDEOHDR structure to receive the video frame.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::HasDialog
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::HasDialog(int}{\insrsid1197183  }{
\i\insrsid1197183 iDialog}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to determine if the specified dialog box exists in the driver.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WDMDLGS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the implementation of the interface
. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_UNEXPECTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Unrecoverable error
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 S_OK
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 If the driver contains the dialog box
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 S_FALSE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 If the driver doesn't contain the dialog box
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 iDialog}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the desired dialog box. This is a member of the }{\b\insrsid1197183 VfwCaptureDialogs
}{\insrsid1197183  enumerated data type.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::InitializeStreaming
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::InitializeStreaming(DWORD}{\insrsid1197183 
 }{\i\insrsid1197183 usPerFrame}{\b\insrsid1197183 , DWORD_PTR}{\insrsid1197183  }{\i\insrsid1197183 hEvtBufferDone}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to initialize a WDM capture device for streaming.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 usPerFrame}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the frame rate to be used.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hEvtBufferDone}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to the event to be signaled whenever a frame is available.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::IsBufferDone
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::IsBufferDone(PVIDEOHDR}{\insrsid1197183  }{
\i\insrsid1197183 pVHdr}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to check the DONE status of a video streaming buffer.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns TRUE if the buffer is DONE, FALSE otherwise.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pVHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a PVIDEOHDR structure identifying the video buffer.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::m_dwDeviceID
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CWDMCapDev::m_dwDeviceID}{\insrsid1197183 
\par Capture device ID.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::m_hDriver
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HANDLE CWDMCapDev::m_hDriver}{\insrsid1197183 
\par This member holds the driver file handle.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::m_pVideoDataRanges
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 PVIDEO_DATA_RANGES CWDMCapDev::m_pVideoDataRanges}{\insrsid1197183 
\par This member points to the video data range structure.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::NonDelegatingQueryInterface
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::NonDelegatingQueryInterface(REFIID}{
\insrsid1197183  }{\i\insrsid1197183 riid}{\b\insrsid1197183 , PVOID*}{\insrsid1197183  }{\i\insrsid1197183 ppv}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is the nondelegating interface query function. It returns a pointer to the specified interface if supported. The only interfaces explicitly supported being }{\b\insrsid1197183 IAMVfWCaptureDialogs}{\insrsid1197183 .
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 riid}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the identifier of the interface to return.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ppv}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the place in which to put the interface pointer.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::ProfileCaptureDevice
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::ProfileCaptureDevice(void) }{
\insrsid1197183 
\par This method is used to determine the list of formats supported by a WDM capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value t
hat depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_UNEXPECTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Unrecoverable error
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::QueueHeader
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 void}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::QueueHeader(LPVIDEOHDR}{\insrsid1197183  }{
\i\insrsid1197183 lpVHdr}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function actually adds the video buffer to the list of video buffers used for streaming.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lpVHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to a }{\b\insrsid1197183 VIDEOHDR}{\insrsid1197183  structure describing a video 
buffer to add to the list of streaming buffers.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::QueueRead
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::QueueRead(DWORD}{\insrsid1197183  }{
\i\insrsid1197183 dwIndex}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function queues a read operation on a video streaming pin.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns TRUE if successful, or FALSE otherwise.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwIndex}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Index of the video structure in read buffer.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Remove this before checkin!
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::SendFormatToDriver
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::SendFormatToDriver(LONG}{\insrsid1197183  }
{\i\insrsid1197183 biWidth}{\b\insrsid1197183 , LONG}{\insrsid1197183  }{\i\insrsid1197183 biHeight}{\b\insrsid1197183 , LONG}{\insrsid1197183  }{\i\insrsid1197183 biCompression}{\b\insrsid1197183 , WORD}{\insrsid1197183  }{\i\insrsid1197183 biBitCount}{
\b\insrsid1197183 , REFERENCE_TIME}{\insrsid1197183  }{\i\insrsid1197183 AvgTimePerFrame}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to tell the VfW capture device what format to use.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT val
ue that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 biWidth}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the image width.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 biHeight}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the image height.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 biCompression}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the format type.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 biBitCount}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the number of bits per pixel.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 AvgTimePerFrame}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the frame rate.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Fix units for fps
\par Rename those variables - it's the format, not the number of colors...
\par Copy the palette if there is one
\par Allocate size for DATAPINCONNECT dynamically
\par Read this from somewhere
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::SetPropertyValue
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::SetPropertyValue(GUID}{\insrsid1197183  }{
\i\insrsid1197183 guidPropertySet}{\b\insrsid1197183 , ULONG}{\insrsid1197183  }{\i\insrsid1197183 ulPropertyId}{\b\insrsid1197183 , LONG}{\insrsid1197183  }{\i\insrsid1197183 lValue}{\b\insrsid1197183 , ULONG}{\insrsid1197183  }{\i\insrsid1197183 ulFlags
}{\b\insrsid1197183 , ULONG}{\insrsid1197183  }{\i\insrsid1197183 ulCapabilities}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function sets the current value of a video property of a capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 guidPropertySet}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 GUID of the KS property set we are touching. It is either PROPSET
ID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ulPropertyId}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
ID of the property we are touching. It is either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lValue}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 New value.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ulFlags}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 New flags. We only care about KSPROPERTY_*_FLAGS_MANUAL or KSPROPERTY_*_FLAGS_AUTO.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ulCapabilities}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 New capabilities. We only care about KSPROPERTY_*_FLAGS_MANUAL or KSPROPERTY_*_FLAGS_AUTO.

\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Developer Notes

\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 KSPROPERTY_VIDEOPROCAMP_S == KSPROPERTY_CAMERACONTROL_S.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::SetState
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::SetState(KSSTATE}{\insrsid1197183  }{
\i\insrsid1197183 ksState}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function sets the state of the kernel streaming video pin.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns TRUE if successful, or FALSE otherwise.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ksState}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 New state.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::ShowDialog
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::ShowDialog(int}{\insrsid1197183  }{
\i\insrsid1197183 iDialog}{\b\insrsid1197183 , HWND}{\insrsid1197183  }{\i\insrsid1197183 hwnd}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to displaay the specified dialog box.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WDMDLGS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_UNEXPECTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Unrecoverable error
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VFW_E_NOT_STOPPED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The operation could not be performed because the filter is not stopped
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VFW_E_CANNOT_CONNECT
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No combination of intermediate filters could be found to make the connection
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 iDialog}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the desired dialog box. This is a member of the }{\b\insrsid1197183 VfwCaptureDialogs
}{\insrsid1197183  enumerated data type.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hwnd}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the handle of the dialog box's parent window.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::Start
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::Start(void) }{\insrsid1197183 
\par This function puts the kernel streaming video pin in streaming mode.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns TRUE if successful, or FALSE otherwise.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::StartStreaming
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::StartStreaming(void) }{\insrsid1197183 

\par This method is used to start streaming from a VfW capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::Stop
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::Stop(void) }{\insrsid1197183 
\par This function stops streaming on the kernel streaming video pin.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns TRUE if successful, or FALSE otherwise.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::StopStreaming
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::StopStreaming(void) }{\insrsid1197183 

\par This method is used to stop streaming from a VfW capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This method returns an HRESULT value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::TerminateStreaming
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::TerminateStreaming(void) }{\insrsid1197183 

\par This method is used to tell a WDM capture device to terminate streaming.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the 
implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMCapDev::~CWDMCapDev
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 void}{\insrsid1197183  }{\b\insrsid1197183 CWDMCapDev::~CWDMCapDev(void) }{\insrsid1197183 
\par This method is the destructor for the }{\b\insrsid1197183 CWDMCapDev}{\insrsid1197183  object. Closes the driver file handle and releases the video data range memory
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICEW.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Nada.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog Class
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 class CWDMDialog}{\insrsid1197183 
\par This class provides support for property pages to be displayed within a property sheet.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WDMDLGS.H
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::BaseDlgProc
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 CWDMDialog::BaseDlgProc(HWND}{\insrsid1197183  }{
\i\insrsid1197183 hDlg}{\b\insrsid1197183 , UINT}{\insrsid1197183  }{\i\insrsid1197183 uMessage}{\b\insrsid1197183 , WPARAM}{\insrsid1197183  }{\i\insrsid1197183 wParam}{\b\insrsid1197183 , LPARAM}{\insrsid1197183  }{\i\insrsid1197183 lParam}{
\b\insrsid1197183 ) }{\insrsid1197183 
\par This function implements the dialog box procedure for the page of a property sheet.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WDMDLGS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Except in response to the WM_INITDIALOG message, the dialog box procedure returns nonzero if it processes the message, and zero if it does not.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hDlg}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Handle to dialog box.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 uMessage}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Message sent to the dialog box.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 wParam}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 First message parameter.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lParam}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Second message parameter.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::Create
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HPROPSHEETPAGE}{\insrsid1197183  }{\b\insrsid1197183 CWDMDialog::Create(void) }{\insrsid1197183 

\par This function creates a new page for a property sheet.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WDMDLGS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns the handle to the new property sheet if successful, or NULL otherwise.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::CWDMDialog
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 void}{\insrsid1197183  }{\b\insrsid1197183 CWDMDialog::CWDMDialog(int}{\insrsid1197183  }{
\i\insrsid1197183 DlgId}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwNumControls}{\b\insrsid1197183 , GUID}{\insrsid1197183  }{\i\insrsid1197183 guidPropertySet}{\b\insrsid1197183 , PPROPSLIDECONTROL}{\insrsid1197183  }{
\i\insrsid1197183 pPC}{\b\insrsid1197183 , PDWORD}{\insrsid1197183  }{\i\insrsid1197183 pdwHelp}{\b\insrsid1197183 , CWDMPin *}{\insrsid1197183  }{\i\insrsid1197183 pCWDMPin}{\b\insrsid1197183 ) }{\insrsid1197183 
\par Property page class constructor.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WDMDLGS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 DlgId}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Resource ID of the property page dialog.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwNumControls}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Number of controls to display in the page.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 guidPropertySet}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 GUID of the KS property set we are showing in the property page.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pPC}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the list of slider controls to be displayed in the property page.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pdwHelp}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the list of help IDs to be displayed in the property page.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pCWDMPin}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the kernel streaming object we will query the property on.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::DoCommand
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 int}{\insrsid1197183  }{\b\insrsid1197183 CWDMDialog::DoCommand(WORD}{\insrsid1197183  }{
\i\insrsid1197183 wCmdID}{\b\insrsid1197183 , WORD}{\insrsid1197183  }{\i\insrsid1197183 hHow}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function handles WM_COMMAND. This is where a click on the Default button or one of the Auto checkboxes is handled
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WDMDLGS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Always returns 1.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 wCmdID}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Command ID.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hHow}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Notification code.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::m_bChanged
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL CWDMDialog::m_bChanged}{\insrsid1197183 
\par This member is set to TRUE after the page has been changed.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::m_bInit
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL CWDMDialog::m_bInit}{\insrsid1197183 
\par This member is set to TRUE after the page has been initialized.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::m_DlgID
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 int CWDMDialog::m_DlgID}{\insrsid1197183 
\par Resource ID of the property page dialog.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::m_dwNumControls
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD CWDMDialog::m_dwNumControls}{\insrsid1197183 
\par Number of controls to\\ display in the page.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::m_guidPropertySet
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 GUID CWDMDialog::m_guidPropertySet}{\insrsid1197183 
\par GUID of the KS property we are showing in the property page.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::m_hDlg
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HWND CWDMDialog::m_hDlg}{\insrsid1197183 
\par Window handle of the property page.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::m_pCWDMPin
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 CWDMPin * CWDMDialog::m_pCWDMPin}{\insrsid1197183 
\par Pointer to the kernel streaming object we will query the property on.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::m_pdwHelp
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 PDWORD CWDMDialog::m_pdwHelp}{\insrsid1197183 
\par Pointer to the list of help IDs to be displayed in the property page.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::m_pPC
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 PPROPSLIDECONTROL CWDMDialog::m_pPC}{\insrsid1197183 
\par Pointer to the list of slider controls to be displayed in the property page.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::QueryCancel
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 int}{\insrsid1197183  }{\b\insrsid1197183 CWDMDialog::QueryCancel(void) }{\insrsid1197183 
\par This function handles PSN_QUERYCANCEL by resetting the values of the controls.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WDMDLGS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Always returns 0.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CWDMDialog::SetActive
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 int}{\insrsid1197183  }{\b\insrsid1197183 CWDMDialog::SetActive(void) }{\insrsid1197183 
\par This function handles PSN_SETACTIVE by intializing all the property page controls.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WDMDLGS.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Always returns 0.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 GetCapDeviceInfo
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 GetCapDeviceInfo(DWORD}{\insrsid1197183  }{
\i\insrsid1197183 dwDeviceIndex}{\b\insrsid1197183 , PDEVICEINFO}{\insrsid1197183  }{\i\insrsid1197183 pDeviceInfo}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to retrieve information about a capture device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVENUM.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT value that depends on the implementatio
n of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_FAIL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Failure
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_INVALIDARG
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Invalid argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VFW_E_NO_CAPTURE_HARDWARE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No Capture hardware is available
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwDeviceIndex}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the device index of the capture device to return information about.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pDeviceInfo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a }{\b\insrsid1197183 DEVICEINFO}{\insrsid1197183 
 structure to receive information about a capture device.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 GetNumCapDevices
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 HRESULT}{\insrsid1197183  }{\b\insrsid1197183 GetNumCapDevices(PDWORD}{\insrsid1197183  }{
\i\insrsid1197183 pdwNumDevices}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This method is used to determine the number of installed capture devices. This number includes only enabled devices.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVENUM.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This method returns an HRESULT
 value that depends on the implementation of the interface. HRESULT can include one of the following standard constants, or other values not listed:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 E_POINTER
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Null pointer argument
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NOERROR
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 No error
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pdwNumDevices}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a DWORD to receive the number of installed capture devices.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Developer Notes

\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 
MSDN references: DirectX 5, DirectX Media, DirectShow, Application Developer's Guide "Enumerate and Access Hardware Devices in DirectShow Applications"
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Could there be another bag property we could use to get version info for WDM devices?
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 GetProcOrd
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 FARPROC}{\insrsid1197183  }{\b\insrsid1197183 GetProcOrd(HINSTANCE}{\insrsid1197183  }{
\i\insrsid1197183 hinstDll}{\b\insrsid1197183 , UINT}{\insrsid1197183  }{\i\insrsid1197183 ord}{\b\insrsid1197183 ) }{\insrsid1197183 
\par GetProcAddress on a DLL by ordinal.
\par Win95 does not let you GetProcAddress on KERNEL32 by ordinal, so we need to do it the evil way.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hinstDll}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
The instance handle of the DLL we want to get the ordinal from.  The only DLL you need to use this function for is KERNEL32.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 ord}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The ordinal you want to retrieve.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 OpenVxDHandle
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 OpenVxDHandle(HANDLE}{\insrsid1197183  }{
\i\insrsid1197183 hEvent}{\b\insrsid1197183 ) }{\insrsid1197183 
\par On Win9x we have to convert the event handle we will be using as a callback into a VxD handle. Ssince the Win9x kernel does not publish this entry point we dynamically link to it.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/WRKRTHD.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns mapped event handle
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hEvent}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a event handle.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 TemplateThunk
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 TemplateThunk(FARPROC}{\insrsid1197183  }{
\i\insrsid1197183 fp}{\b\insrsid1197183 , PCSTR}{\insrsid1197183  }{\i\insrsid1197183 pszSig}{\b\insrsid1197183 ) }{\insrsid1197183 
\par Call down, passing all sorts of random parameters.
\par Parameter signature is as follows:
\par p = 0:32 pointer to convert to 16:16 pointer l = a 32-bit integer s = a 16-bit integer
\par P = returns a pointer L = returns a 32-bit integer S = returns a 16-bit signed integer U = returns a 16-bit unsigned integer
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 fp}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 16:16 function to call.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 pszSig}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Function signature.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 ThunkGetProcAddresses
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 void}{\insrsid1197183  }{\b\insrsid1197183 ThunkGetProcAddresses(void) }{\insrsid1197183 
\par Get all the necessary proc addresses.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 ThunkInit
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 void}{\insrsid1197183  }{\b\insrsid1197183 ThunkInit(void) }{\insrsid1197183 
\par Initialize the various goo we need in KERNEL32.
\par Returns FALSE if we cannot initialize the thunks. (For example, if the platform doesn't support flat thunks.)
\par Note that you must never ever call this function more than once.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 ThunkInit
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 void}{\insrsid1197183  }{\b\insrsid1197183 ThunkInit(void) }{\insrsid1197183 
\par GetProcAddress16 our brains out.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 ThunkTerm
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 void}{\insrsid1197183  }{\b\insrsid1197183 ThunkTerm(void) }{\insrsid1197183 
\par Free it.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoCapDriverDescAndVer
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoCapDriverDescAndVer(DWORD}{\insrsid1197183  }{
\i\insrsid1197183 dwDeviceID}{\b\insrsid1197183 , LPTSTR}{\insrsid1197183  }{\i\insrsid1197183 lpszDesc}{\b\insrsid1197183 , UINT}{\insrsid1197183  }{\i\insrsid1197183 cbDesc}{\b\insrsid1197183 , LPTSTR}{\insrsid1197183  }{\i\insrsid1197183 lpszVer}{
\b\insrsid1197183 , UINT}{\insrsid1197183  }{\i\insrsid1197183 cbVer}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function gets strings for the description and version of a video capture driver
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns zero if the function was successful. Otherwise, it returns an error number.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwDeviceID}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the index of which video driver to get information about.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lpszDesc}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a place to return the description
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 cbDesc}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the length of the description string
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lpszVer}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a place to return the version
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 cbVer}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the length of the version string
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Use this function to get strings describing the driver and its version
\par /***************************************************************************
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoClose
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoClose(HVIDEO}{\insrsid1197183  }{\i\insrsid1197183 
hVideo}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function closes the specified video device channel.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Returns zero if the function was successful. Otherwise, it returns an error number. The following errors are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_INVALHANDLE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specified device handle is invalid.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_NONSPECIFIC
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The driver failed to close the channel.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hVideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies a handle to the video device channel. If this function is successful, the handle is invalid after this call.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 If buffers have been sent with }{\b\insrsid1197183 videoStreamAddBuffer}{\insrsid1197183 
 and they haven't been returned to the application, the close operation fails. You can use }{\b\insrsid1197183 videoStreamReset}{\insrsid1197183  to mark all pending buffers as done.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 videoOpen}{\insrsid1197183  }{\b\insrsid1197183 videoStreamInit}{\insrsid1197183  }{
\b\insrsid1197183 videoStreamFini}{\insrsid1197183  }{\b\insrsid1197183 videoStreamReset}{\insrsid1197183 
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoConfigure
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoConfigure(HVIDEO}{\insrsid1197183  }{
\i\insrsid1197183 hVideo}{\b\insrsid1197183 , UINT}{\insrsid1197183  }{\i\insrsid1197183 msg}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwFlags}{\b\insrsid1197183 , LPDWORD}{\insrsid1197183  }{\i\insrsid1197183 lpdwReturn}{
\b\insrsid1197183 , LPVOID}{\insrsid1197183  }{\i\insrsid1197183 lpData1}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwSize1}{\b\insrsid1197183 , LPVOID}{\insrsid1197183  }{\i\insrsid1197183 lpData2}{\b\insrsid1197183 , DWORD}{
\insrsid1197183  }{\i\insrsid1197183 dwSize2}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function sets or retrieves the options for a configurable driver.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Returns zero if the function was successful. Otherwise, it returns an error number. The following errors are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_INVALHANDLE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specified device handle is invalid.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_NOTSUPPORTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Function is not supported.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hVideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to the video device channel.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 msg}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the option to set or retrieve. The following options are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DVM_PALETTE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates a palette is being sent to the driver or retrieved from the driver.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DVM_PALETTERGB555
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates an RGB555 palette is being sent to the driver.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DVM_FORMAT
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates format information is being sent to the driver or retrieved from the driver.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwFlags}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies flags for configuring or interrogating the device driver. The fol
lowing flags are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_CONFIGURE_SET
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates values are being sent to the driver.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_CONFIGURE_GET
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates values are being obtained from the driver.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_CONFIGURE_QUERY
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Determines if the driver supports the option specified by }{\i\insrsid1197183 msg}{
\insrsid1197183 . This flag should be combined with either the VIDEO_CONFIGURE_SET or VIDEO_CONFIGURE_GET flag. If this flag is set, the }{\i\insrsid1197183 lpData1}{\insrsid1197183 , }{\i\insrsid1197183 dwSize1}{\insrsid1197183 , }{\i\insrsid1197183 
lpData2}{\insrsid1197183 , and }{\i\insrsid1197183 dwSize2}{\insrsid1197183  parameters are ignored.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_CONFIGURE_QUERYSIZE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns the size, in bytes, of the configuration option in }{\i\insrsid1197183 lpdwReturn}{
\insrsid1197183 . This flag is only valid if the VIDEO_CONFIGURE_GET flag is also set.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_CONFIGURE_CURRENT
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Requests the current value. This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_CONFIGURE_NOMINAL
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Requests the nominal va
lue. This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_CONFIGURE_MIN
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Requests the minimum value. This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_CONFIGURE_MAX
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Get the maximum value. This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.

\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lpdwReturn}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Points to a DWORD used for returning information from the driver.  If the VIDEO_CONFIGURE_QUERYSIZE flag is set, }{\i\insrsid1197183 lpdwReturn}{\insrsid1197183  is filled with the size of the configuration option.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lpData1}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to message specific data.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwSize1}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the size, in bytes, of the }{\i\insrsid1197183 lpData1}{\insrsid1197183  buffer.

\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lpData2}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to message specific data.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwSize2}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the size, in bytes, of the }{\i\insrsid1197183 lpData2}{\insrsid1197183  buffer.

\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 videoOpen}{\insrsid1197183  }{\b\insrsid1197183 videoMessage}{\insrsid1197183 
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoDialog
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoDialog(HVIDEO}{\insrsid1197183  }{\i\insrsid1197183 
hVideo}{\b\insrsid1197183 , HWND}{\insrsid1197183  }{\i\insrsid1197183 hWndParent}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwFlags}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function displays a channel-specific dialog box used to set configuration parameters.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns ze
ro if the function was successful. Otherwise, it returns an error number. The following errors are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_INVALHANDLE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specified device handle is invalid.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_NOTSUPPORTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Function is not supported.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hVideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to the video device channel.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hWndParent}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the parent window handle.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwFlags}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies flags for the dialog box. The following flag is defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_DLG_QUERY
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 If this flag is set, the driver immediately 
returns zero if it supplies a dialog box for the channel, or DV_ERR_NOTSUPPORTED if it does not.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Typically, each dialog box displayed by this function lets the user select options appropriate for the channel. For example, a VIDEO_IN channel dialog box lets the user select the image dimensions and bit depth.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 videoOpen}{\insrsid1197183  }{\b\insrsid1197183 videoConfigureStorage}{\insrsid1197183 
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoFunc
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 void CALLBACK}{\insrsid1197183  }{\b\insrsid1197183 videoFunc(HVIDEO}{\insrsid1197183  }{
\i\insrsid1197183 hVideo}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 wMsg}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwInstance}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwParam1}{
\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwParam2}{\b\insrsid1197183 ) }{\insrsid1197183 
\par }{\b\insrsid1197183 videoFunc}{\insrsid1197183  is a placeholder for an 
application-supplied function name. The actual name must be exported by including it in an EXPORTS statement in the DLL's module-definition file. This is used only when a callback function is specified in }{\b\insrsid1197183 videoStreamInit}{
\insrsid1197183 .
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hVideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to the video device channel associated with the callback.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 wMsg}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies the MM_DRVM_ messages. Messages indicate errors and when image data is available. For information on these messages, see }{\b\insrsid1197183 videoStreamInit}{\insrsid1197183 .
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwInstance}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the user instance data specified with }{\b\insrsid1197183 videoStreamInit}{
\insrsid1197183 .
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwParam1}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a parameter for the message.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwParam2}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a parameter for the message.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Because the callback is accessed at interrupt time, 
it must reside in a DLL and its code segment must be specified as FIXED in the module-definition file for the DLL. Any data the callback accesses must be in a FIXED data segment as well. The callback may not make any system calls except for }{
\b\insrsid1197183 PostMessage}{\insrsid1197183 , }{\b\insrsid1197183 timeGetSystemTime}{\insrsid1197183 , }{\b\insrsid1197183 timeGetTime}{\insrsid1197183 , }{\b\insrsid1197183 timeSetEvent}{\insrsid1197183 , }{\b\insrsid1197183 timeKillEvent}{
\insrsid1197183 , }{\b\insrsid1197183 midiOutShortMsg}{\insrsid1197183 , }{\b\insrsid1197183 midiOutLongMsg}{\insrsid1197183 , and }{\b\insrsid1197183 OutputDebugStr}{\insrsid1197183 .
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 videoOpen}{\insrsid1197183  }{\b\insrsid1197183 videoStreamFini}{\insrsid1197183  }{
\b\insrsid1197183 videoClose}{\insrsid1197183 
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoGetChannelCaps
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoGetChannelCaps(HVIDEO}{\insrsid1197183  }{
\i\insrsid1197183 hVideo}{\b\insrsid1197183 , LPCHANNEL_CAPS}{\insrsid1197183  }{\i\insrsid1197183 lpChannelCaps}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwSize}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function retrieves a description of the capabilities of a channel.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns zero if the function is successful. Otherwise, it returns an error number. The following 
errors are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_INVALHANDLE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specified device handle is invalid.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_UNSUPPORTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Function is not supported.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hVideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to the video device channel.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lpChannelCaps}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a far pointer to a }{\b\insrsid1197183 CHANNEL_CAPS}{\insrsid1197183  structure.

\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwSize}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the size, in bytes, of the }{\b\insrsid1197183 CHANNEL_CAPS}{\insrsid1197183 
 structure.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The }{\b\insrsid1197183 CHANNEL_CAPS}{\insrsid1197183 
 structure returns the capability information. For example, capability information might include whether or not the channel can crop and scale images, or show overlay.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoGetNumDevs
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoGetNumDevs(void) }{\insrsid1197183 
\par This function returns the number of MSVIDEO devices installed.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VIDEO.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns the number of MSVIDEO devices listed in the 
[drivers] (or [drivers32] for NT) section of the SYSTEM.INI file.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Because the indexes of the MSVIDEO devices in the SYSTEM.INI file can be non-contiguous, applications should not assume the indexes range between zero and the number of devices minus one.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 videoOpen}{\insrsid1197183 
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoMessage
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoMessage(HVIDEO}{\insrsid1197183  }{
\i\insrsid1197183 hVideo}{\b\insrsid1197183 , UINT}{\insrsid1197183  }{\i\insrsid1197183 wMsg}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwP1}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwP2}{\b\insrsid1197183 ) 
}{\insrsid1197183 
\par This function sends messages to a video device channel.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns the message specific value returned from the driver.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hVideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the handle to the video device channel.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 wMsg}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the message to send.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwP1}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the first parameter for the message.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwP2}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the second parameter for the message.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This function is used for configuration messages such as DVM_SRC_RECT and DVM_DST_RECT, and device specific messages.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 videoConfigure}{\insrsid1197183 
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoOpen
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoOpen(LPHVIDEO}{\insrsid1197183  }{\i\insrsid1197183 
lphvideo}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwDeviceID}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwFlags}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function opens a channel on the specified video device.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Returns zero if the function was successful. Otherwise, it returns an error number. The following errors are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_BADDEVICEID
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the specified device ID is out of range.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_ALLOCATED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the specified resource is already allocated.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_NOMEM
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the device is unable to allocate or lock memory.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lphvideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a far pointer to a buffer used to return an }{\b\insrsid1197183 HVIDEO}{
\insrsid1197183  handle. The video capture driver uses this location to return a handle that uniquely identifies the opened video device channel. Use the returned handle to identify the device channel when calling other video functions.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwDeviceID}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Identifies the video device to open. The value of }{\i\insrsid1197183 dwDeviceID}{
\insrsid1197183  varies from zero to one less than the number of video capture devices installed in the system.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwFlags}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies flags for opening the device. The following flags are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_EXTERNALIN
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies the channel is opened for external input. Typically, external input channels capture images into a frame buffer.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_EXTERNALOUT
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies the channel is opened for external output. Typically, external output channels display images stored in a frame buffer on an auxilary monitor or overlay.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_IN
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies the channel is opened for video input. Video input channels transfer images from a frame buffer to system memory buffers.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_OUT
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the channel is opened 
for video output. Video output channels transfer images from system memory buffers to a frame buffer.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 At a minimum, all capture drivers support a VIDEO_EXTERNALIN and a VIDEO_IN channel. Use }{
\b\insrsid1197183 videoGetNumDevs}{\insrsid1197183  to determine the number of video devices present in the system.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 videoClose}{\insrsid1197183 
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoRegGetDriverByIndex
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 videoRegGetDriverByIndex(DWORD}{\insrsid1197183  }{
\i\insrsid1197183 dwDeviceID}{\b\insrsid1197183 , LPDEVNODE}{\insrsid1197183  }{\i\insrsid1197183 lpDevnode}{\b\insrsid1197183 , LPBOOL}{\insrsid1197183  }{\i\insrsid1197183 lpEnabled}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function returns information about a capture driver by index from the registry.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VIDEO.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns TRUE if successful, or FALSE if a driver was not found with the }{\i\insrsid1197183 dwDeviceID}
{\insrsid1197183  index.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwDeviceID}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Identifies the video device to open. The value of }{\i\insrsid1197183 dwDeviceID}{
\insrsid1197183  varies from zero to one less than the number of video capture devices installed in the system.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lpDevnode}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a far pointer to a buffer used to return an }{\b\insrsid1197183 DEVNODE}{
\insrsid1197183  handle.  For non Plug-and-Play devices, this return value will be NULL.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lpEnabled}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a far pointer to a buffer used to return a }{\b\insrsid1197183 BOOL}{\insrsid1197183 
 flag.  If this value is TRUE, the driver is enabled, if FALSE, the corresponding device is disabled.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Because the indexes of the MSVIDEO devices in the SYSTEM.INI file can be non-contiguous, applications should not assume the indexes range between zero and the number of devices minus one.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoRegOpenMSVideoKey
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 BOOL}{\insrsid1197183  }{\b\insrsid1197183 videoRegOpenMSVideoKey(void) }{\insrsid1197183 
\par This function returns a key for the msvideo node in the registry. If the key does not exist it will be created, and the default entries made.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VIDEO.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns Key on success, else NULL.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoStreamFini
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoStreamFini(HVIDEO}{\insrsid1197183  }{
\i\insrsid1197183 hVideo}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function terminates streaming from the specified device channel.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Returns zero if the function was successful. Otherwise, it returns an error number. The following errors are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_INVALHANDLE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the device handle specified is invalid.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_STILLPLAYING
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates there are still buffers in the queue.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hVideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to the video device channel.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 If there are buffers that have been sent with }{\b\insrsid1197183 videoStreamAddBuffer}{
\insrsid1197183  that haven't been returned to the application, this operation will fail. Use }{\b\insrsid1197183 videoStreamReset}{\insrsid1197183  to return all pending buffers.
\par Each call to }{\b\insrsid1197183 videoStreamInit}{\insrsid1197183  must be matched with a call to }{\b\insrsid1197183 videoStreamFini}{\insrsid1197183 .
\par For VIDEO_EXTERNALIN channels, this function is used to halt capturing of data to the frame buffer.
\par For VIDEO_EXTERNALOUT channels supporting overlay, this function is used to disable the overlay.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 videoStreamInit}{\insrsid1197183 
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoStreamInit
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoStreamInit(HVIDEO}{\insrsid1197183  }{
\i\insrsid1197183 hVideo}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwMicroSecPerFrame}{\b\insrsid1197183 , DWORD_PTR}{\insrsid1197183  }{\i\insrsid1197183 dwCallback}{\b\insrsid1197183 , DWORD_PTR}{\insrsid1197183  }{
\i\insrsid1197183 dwCallbackInstance}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwFlags}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function initializes a video device channel for streaming.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns zero if the function was successful. Otherwise, 
it returns an error number. The following errors are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_BADDEVICEID
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the device ID specified in }{\i\insrsid1197183 hVideo}{\insrsid1197183  is not valid.

\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_ALLOCATED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the resource specified is already allocated.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_NOMEM
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the device is unable to allocate or lock memory.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hVideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to the video device channel.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwMicroSecPerFrame}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the number of microseconds between frames.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwCallback}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the address of a callback function or a handle to a window called duri
ng video streaming. The callback function or window processes messages related to the progress of streaming.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwCallbackInstance}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies user instance data passed to the callback function. This parameter is not used with window callbacks.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwFlags}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies flags for opening the device channel. The following flags are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CALLBACK_WINDOW
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 If this flag is specified, }{\i\insrsid1197183 dwCallback}{\insrsid1197183  is a window handle.

\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CALLBACK_FUNCTION
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 If this flag is specified, }{\i\insrsid1197183 dwCallback}{\insrsid1197183 
 is a callback procedure address.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
If a window or function is chosen to receive callback information, the following messages are sent to it to indicate the progress of video input:
\par MM_DRVM_OPEN is sent at the time of }{\b\insrsid1197183 videoStreamInit}{\insrsid1197183 
\par MM_DRVM_CLOSE is sent at the time of }{\b\insrsid1197183 videoStreamFini}{\insrsid1197183 
\par MM_DRVM_DATA is sent when a buffer of image data is available
\par MM_DRVM_ERROR is sent when an error occurs
\par Callback functions must reside in a DLL. You do not have to use }{\b\insrsid1197183 MakeProcInstance}{\insrsid1197183  to get a procedure-instance address for the callback function.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoStreamPrepareHeader
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoStreamPrepareHeader(HVIDEO}{\insrsid1197183  }{
\i\insrsid1197183 hVideo}{\b\insrsid1197183 , LPVIDEOHDR}{\insrsid1197183  }{\i\insrsid1197183 lpvideoHdr}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwSize}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function prepares a buffer for video streaming.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns zero if the functio
n was successful. Otherwise, it returns an error number. The following errors are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_INVALHANDLE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the specified device handle is invalid.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_NOMEM
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the device is unable to allocate or lock memory.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hVideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to the video device channel.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lpvideoHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a }{\b\insrsid1197183 VIDEOHDR}{\insrsid1197183 
 structure identifying the buffer to be prepared.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwSize}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the size of the }{\b\insrsid1197183 VIDEOHDR}{\insrsid1197183  structure in bytes.

\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Use this function after }{\b\insrsid1197183 videoStreamInit}{\insrsid1197183  or after }{
\b\insrsid1197183 videoStreamReset}{\insrsid1197183  to prepare the data buffers for streaming data.
\par The }{\b\insrsid1197183 VIDEOHDR}{\insrsid1197183  data structure and the data block pointed to by its }{\b\insrsid1197183 lpData}{\insrsid1197183  member must be allocated with }{\b\insrsid1197183 GlobalAlloc}{\insrsid1197183 
 using the GMEM_MOVEABLE and GMEM_SHARE flags, and locked with }{\b\insrsid1197183 GlobalLock}{\insrsid1197183 . 
Preparing a header that has already been prepared will have no effect and the function will return zero. Typically, this function is used to ensure that the buffer will be available for use at interrupt time.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 videoStreamUnprepareHeader}{\insrsid1197183 
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoStreamReset
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoStreamReset(HVIDEO}{\insrsid1197183  }{
\i\insrsid1197183 hVideo}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function stops streaming on the specified video device channel and resets the current position to zero.  All pending buffers are marked as done and are returned to the application.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Returns zero if the function was successful. Otherwise, it returns an error number. The following errors are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_INVALHANDLE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the device handle specified is invalid.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_NOTSUPPORTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the device does not support this function.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hVideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to the video device channel.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 videoStreamReset}{\insrsid1197183  }{\b\insrsid1197183 videoStreamStop}{\insrsid1197183  }{
\b\insrsid1197183 videoStreamAddBuffer}{\insrsid1197183  }{\b\insrsid1197183 videoStreamClose}{\insrsid1197183  /***************************************************************************
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoStreamStart
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoStreamStart(HVIDEO}{\insrsid1197183  }{
\i\insrsid1197183 hVideo}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function starts streaming on the specified video device channel.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Returns zero if the function was successful. Otherwise, it returns an error number. The following errors are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_INVALHANDLE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the device handle specified is invalid.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_NOTSUPPORTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the device does not support this function.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hVideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to the video device channel.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 videoStreamReset}{\insrsid1197183  }{\b\insrsid1197183 videoStreamStop}{\insrsid1197183  }{
\b\insrsid1197183 videoStreamAddBuffer}{\insrsid1197183  }{\b\insrsid1197183 videoStreamClose}{\insrsid1197183  /***************************************************************************
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoStreamStop
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoStreamStop(HVIDEO}{\insrsid1197183  }{
\i\insrsid1197183 hVideo}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function stops streaming on a video channel.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Returns zero if the function was successful. Otherwise, it returns an error number. The followin
g error is defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_INVALHANDLE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the specified device handle is invalid.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_NOTSUPPORTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the device does not support this function.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hVideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to the video device channel.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 If there are any buffers in the queue, the current buffer will be marked as done (the }{
\b\insrsid1197183 dwBytesRecorded}{\insrsid1197183  member in the }{\b\insrsid1197183 VIDEOHDR}{\insrsid1197183 
 header will contain the actual length of data), but any empty buffers in the queue will remain there. Calling this function when the channel is not started has no effect, and the function returns zero.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 videoStreamStart}{\insrsid1197183  }{\b\insrsid1197183 videoStreamReset}{\insrsid1197183 
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoStreamUnprepareHeader
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoStreamUnprepareHeader(HVIDEO}{\insrsid1197183  }{
\i\insrsid1197183 hVideo}{\b\insrsid1197183 , LPVIDEOHDR}{\insrsid1197183  }{\i\insrsid1197183 lpvideoHdr}{\b\insrsid1197183 , DWORD}{\insrsid1197183  }{\i\insrsid1197183 dwSize}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function clears the preparation performed by }{\b\insrsid1197183 videoStreamPrepareHeader}{\insrsid1197183 .
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Returns zero if the function was successful. Otherwise, it returns an error number. The following errors are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_INVALHANDLE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the device handle specified is invalid.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_STILLPLAYING
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the structure identified by }{\i\insrsid1197183 lpvideoHdr}{\insrsid1197183 
 is still in the queue.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hVideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to the video device channel.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 lpvideoHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to a }{\b\insrsid1197183 VIDEOHDR}{\insrsid1197183 
 structure identifying the data buffer to be unprepared.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 dwSize}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the size of the }{\b\insrsid1197183 VIDEOHDR}{\insrsid1197183  structure in bytes.

\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 This function is the complementary function to }{\b\insrsid1197183 videoStreamPrepareHeader}{
\insrsid1197183 . You must call this function before freeing the data buffer with }{\b\insrsid1197183 GlobalFree}{\insrsid1197183 . After passing a buffer to the device driver with }{\b\insrsid1197183 videoStreamAddBuffer}{\insrsid1197183 
, you must wait until the driver is finished with the buffer before calling }{\b\insrsid1197183 videoStreamUnprepareHeader}{\insrsid1197183 . Unpreparing a buffer that has not been prepared or has b
een already unprepared has no effect, and the function returns zero.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 See Also
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 videoStreamPrepareHeader}{\insrsid1197183 
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 videoUpdate
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 DWORD}{\insrsid1197183  }{\b\insrsid1197183 videoUpdate(HVIDEO}{\insrsid1197183  }{\i\insrsid1197183 
hVideo}{\b\insrsid1197183 , HWND}{\insrsid1197183  }{\i\insrsid1197183 hWnd}{\b\insrsid1197183 , HDC}{\insrsid1197183  }{\i\insrsid1197183 hDC}{\b\insrsid1197183 ) }{\insrsid1197183 
\par This function directs a channel to repaint the display.  It applies only to VIDEO_EXTERNALOUT channels.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/THUNK.C
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Return Value
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Returns zero if the function was successful. Otherwise, it returns an error number. The following errors are defined:
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_UNSUPPORTED
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specified message is unsupported.
\par }\pard\plain \s21\ql \li280\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DV_ERR_INVALHANDLE
\par }\pard\plain \s23\ql \li560\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin560\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Indicates the device handle specified is invalid.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Parameters
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hVideo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to the video device channel.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hWnd}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the handle of the window to be used by the channel for image display.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\i\insrsid1197183 hDC}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a handle to a device context.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Comments
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
This message is normally sent whenever the client window receives a WM_MOVE, WM_SIZE, or WM_PAINT message.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CONVERSIONTYPE_DECODE constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000002 CONVERSIONTYPE_DECODE;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/BASEPIN.H
\par Specifies a decoding operation.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CONVERSIONTYPE_ENCODE constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000001 CONVERSIONTYPE_ENCODE;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/BASEPIN.H
\par Specifies an encoding operation.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CONVERSIONTYPE_NONE constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000000 CONVERSIONTYPE_NONE;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/BASEPIN.H
\par No conversion operation necessary.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 CONVERSIONTYPE_SCALER constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000004 CONVERSIONTYPE_SCALER;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/BASEPIN.H
\par Specifies an image size change.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DISPLAY_DLG_OFF constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000000 DISPLAY_DLG_OFF;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Disable display dialog.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DISPLAY_DLG_ON constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000002 DISPLAY_DLG_ON;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Enable display dialog.
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 To Do
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\cf6\insrsid1197183 Use the two following keys or get rid of them
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 FORMAT_DLG_OFF constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000000 FORMAT_DLG_OFF;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Disable video format dialog.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 FORMAT_DLG_ON constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000001 FORMAT_DLG_ON;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Enable video format dialog.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NUM_4BIT_ENTRIES constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 16 NUM_4BIT_ENTRIES;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Number of entries in a 4bit palette.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 NUM_8BIT_ENTRIES constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 256 NUM_8BIT_ENTRIES;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Number of entries in an 8bit palette.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 SOURCE_DLG_OFF constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000000 SOURCE_DLG_OFF;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Disable source dialog.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 SOURCE_DLG_ON constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000002 SOURCE_DLG_ON;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Enable source dialog.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_BI_BITFIELDS constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const BI_BITFIELDS VIDEO_FORMAT_BI_BITFIELDS;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par RGB Bit Fields video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_BI_RGB constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const BI_RGB VIDEO_FORMAT_BI_RGB;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par RGB video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_BI_RLE4 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const BI_RLE4 VIDEO_FORMAT_BI_RLE4;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par RLE 4 video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_BI_RLE8 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const BI_RLE8 VIDEO_FORMAT_BI_RLE8;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par RLE 8 video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_CVID constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const MAKEFOURCC('c','v','i','d') VIDEO_FORMAT_CVID;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Cinepack video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_112_80 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000010 VIDEO_FORMAT_IMAGE_SIZE_112_80;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 112x80 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_120_90 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000020 VIDEO_FORMAT_IMAGE_SIZE_120_90;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 120x90 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_128_96 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000040 VIDEO_FORMAT_IMAGE_SIZE_128_96;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 128x96 (SQCIF) pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_144_112 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000080 VIDEO_FORMAT_IMAGE_SIZE_144_112;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 144x112 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_160_120 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000100 VIDEO_FORMAT_IMAGE_SIZE_160_120;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 160x120 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_160_128 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000200 VIDEO_FORMAT_IMAGE_SIZE_160_128;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 160x128 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_176_144 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000400 VIDEO_FORMAT_IMAGE_SIZE_176_144;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 176x144 (QCIF) pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_192_160 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000800 VIDEO_FORMAT_IMAGE_SIZE_192_160;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 192x160 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_200_150 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00001000 VIDEO_FORMAT_IMAGE_SIZE_200_150;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 200x150 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_208_176 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00002000 VIDEO_FORMAT_IMAGE_SIZE_208_176;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 208x176 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_224_192 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00004000 VIDEO_FORMAT_IMAGE_SIZE_224_192;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 224x192 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_240_180 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00008000 VIDEO_FORMAT_IMAGE_SIZE_240_180;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 240x180 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_240_208 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00010000 VIDEO_FORMAT_IMAGE_SIZE_240_208;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 240x208 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_256_224 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00020000 VIDEO_FORMAT_IMAGE_SIZE_256_224;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 256x224 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_272_240 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00040000 VIDEO_FORMAT_IMAGE_SIZE_272_240;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 272x240 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_280_210 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00080000 VIDEO_FORMAT_IMAGE_SIZE_280_210;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 280x210 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_288_256 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00100000 VIDEO_FORMAT_IMAGE_SIZE_288_256;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 288x256 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_304_272 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00200000 VIDEO_FORMAT_IMAGE_SIZE_304_272;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 304x272 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_320_240 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00400000 VIDEO_FORMAT_IMAGE_SIZE_320_240;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 320x240 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_320_288 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00800000 VIDEO_FORMAT_IMAGE_SIZE_320_288;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 320x288 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_336_288 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x01000000 VIDEO_FORMAT_IMAGE_SIZE_336_288;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 336x288 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_352_288 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x02000000 VIDEO_FORMAT_IMAGE_SIZE_352_288;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 352x288 (CIF) pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_40_30 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000001 VIDEO_FORMAT_IMAGE_SIZE_40_30;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 40x30 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_640_480 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x04000000 VIDEO_FORMAT_IMAGE_SIZE_640_480;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 640x480 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_64_48 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000002 VIDEO_FORMAT_IMAGE_SIZE_64_48;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 64x48 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_80_60 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000004 VIDEO_FORMAT_IMAGE_SIZE_80_60;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 80x60 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IMAGE_SIZE_96_64 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000008 VIDEO_FORMAT_IMAGE_SIZE_96_64;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 96x64 pixel frames.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_INTELH261 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const MAKEFOURCC('h','2','6','1') VIDEO_FORMAT_INTELH261;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Intel H.261 video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_INTELH263 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const MAKEFOURCC('h','2','6','3') VIDEO_FORMAT_INTELH263;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Intel H.263 video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_IV32 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const MAKEFOURCC('I','V','3','2') VIDEO_FORMAT_IV32;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Intel Indeo IV32 video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_MRLE constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const MAKEFOURCC('M','R','L','E') VIDEO_FORMAT_MRLE;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Microsoft RLE video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_MSH261 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const MAKEFOURCC('M','2','6','1') VIDEO_FORMAT_MSH261;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Microsoft H.261 video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_MSH263 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const MAKEFOURCC('M','2','6','3') VIDEO_FORMAT_MSH263;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Microsoft H.263 video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_MSVC constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const MAKEFOURCC('M','S','V','C') VIDEO_FORMAT_MSVC;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Microsoft CRAM video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_NUM_COLORS_16 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000001 VIDEO_FORMAT_NUM_COLORS_16;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 16 colors.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_NUM_COLORS_16777216 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000008 VIDEO_FORMAT_NUM_COLORS_16777216;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 16777216 colors.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_NUM_COLORS_256 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000002 VIDEO_FORMAT_NUM_COLORS_256;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 256 colors.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_NUM_COLORS_65536 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000004 VIDEO_FORMAT_NUM_COLORS_65536;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses 65536 colors.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_NUM_COLORS_I420 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000020 VIDEO_FORMAT_NUM_COLORS_I420;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses the I420 compressed format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_NUM_COLORS_IYUV constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000040 VIDEO_FORMAT_NUM_COLORS_IYUV;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses the IYUV compressed format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_NUM_COLORS_M261 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000200 VIDEO_FORMAT_NUM_COLORS_M261;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses the M261 compressed format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_NUM_COLORS_M263 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000400 VIDEO_FORMAT_NUM_COLORS_M263;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses the M263 compressed format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_NUM_COLORS_UYVY constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000100 VIDEO_FORMAT_NUM_COLORS_UYVY;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses the UYVY compressed format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_NUM_COLORS_YUY2 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000080 VIDEO_FORMAT_NUM_COLORS_YUY2;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses the YUY2 compressed format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_NUM_COLORS_YVU9 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 0x00000010 VIDEO_FORMAT_NUM_COLORS_YVU9;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Video input device uses the YVU9 compressed format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_NUM_IMAGE_SIZE constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const 27 VIDEO_FORMAT_NUM_IMAGE_SIZE;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Number of video input sizes used by the device.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_UNKNOWN constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const WAVE_FORMAT_UNKNOWN VIDEO_FORMAT_UNKNOWN;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Constant for unknown video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_VDEC constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const MAKEFOURCC('V','D','E','C') VIDEO_FORMAT_VDEC;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Color QuickCam video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEO_FORMAT_YVU9 constant
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 const MAKEFOURCC('Y','V','U','9') VIDEO_FORMAT_YVU9;}{\insrsid1197183 
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/FORMATS.H
\par Intel Indeo YVU9 video format.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 BUFSTRUCT Structure
\par }\pard\plain \s16\ql \li0\ri0\sl-220\slmult0\widctlpar\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800\faauto\rin0\lin0\itap0 \f2\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 typedef struct \{
\par \tab LPVIDEOHDR lpVHdr;
\par \tab BOOL fReady;
\par \} BUFSTRUCT;
\par 
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The }{\b\insrsid1197183 BUFSTRUCT}{\insrsid1197183 
 structure holds the status of each video streaming buffer.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICE.H
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Members
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 lpVHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies a pointer to the video header of a video streaming buffer.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 fReady}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Set to TRUE if the video buffer is available for video streaming, FALSE if is locked by the application or queued for an asynchronous read.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 DATAPINCONNECT Structure
\par }\pard\plain \s16\ql \li0\ri0\sl-220\slmult0\widctlpar\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800\faauto\rin0\lin0\itap0 \f2\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 typedef struct \{
\par \tab KSPIN_CONNECT Connect;
\par \tab KS_DATAFORMAT_VIDEOINFOHEADER Data;
\par \} DATAPINCONNECT;
\par 
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The }{\b\insrsid1197183 DATAPINCONNECT}{\insrsid1197183 
 structure is used to connect to a streaming video pin.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICE.H
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Members
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 Connect}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Describes how the connection is to be done.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 Data}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Describes the video format of the video data streaming from a video pin.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 KS_HEADER_AND_INFO Structure
\par }\pard\plain \s16\ql \li0\ri0\sl-220\slmult0\widctlpar\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800\faauto\rin0\lin0\itap0 \f2\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 typedef struct \{
\par \tab KSSTREAM_HEADER StreamHeader;
\par \tab KS_FRAME_INFO FrameInfo;
\par \} KS_HEADER_AND_INFO;
\par 
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The }{\b\insrsid1197183 KS_HEADER_AND_INFO}{\insrsid1197183 
 structure is used stream data from a video pin.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICE.H
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Members
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 StreamHeader}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Describes how the streaming is to be done.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 FrameInfo}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Describes the video format of the video data streaming from a video pin.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 ThdState
\par }\pard\plain \s16\ql \li0\ri0\sl-220\slmult0\widctlpar\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800\faauto\rin0\lin0\itap0 \f2\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 enum ThdState \{
\par \tab TS_Not,
\par \tab TS_Create,
\par \tab TS_Init,
\par \tab TS_Pause,
\par \tab TS_Run,
\par \tab TS_Stop,
\par \tab TS_Destroy,
\par \tab TS_Exit
\par \};
\par 
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The }{\b\insrsid1197183 ThdState}{\insrsid1197183 
 enum is used to change and keep track of that capture worker thread state.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/TAPIVCAP.H
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Members
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 TS_Not}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Worker thread hasn't been created yet.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 TS_Create}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Worker thread has been created.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 TS_Init}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Worker thread hasn't been initialized.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 TS_Pause}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Worker thread is in the Pause state.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 TS_Run}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Worker thread is in the Run state.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 TS_Stop}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Worker thread is in the Stop state.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 TS_Destroy}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Worker thread hasn't been destroyed.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 TS_Exit}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Worker thread hasn't been asked to exit.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VideoControlFlags
\par }\pard\plain \s16\ql \li0\ri0\sl-220\slmult0\widctlpar\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800\faauto\rin0\lin0\itap0 \f2\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 enum VideoControlFlags \{
\par \tab VideoControlFlag_FlipHorizontal,
\par \tab VideoControlFlag_FlipVertical,
\par \tab VideoControlFlag_ExternalTriggerEnable,
\par \tab VideoControlFlag_Trigger
\par \};
\par 
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The }{\b\insrsid1197183 VideoControlFlags}{\insrsid1197183  enum is used to describe video modes.

\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/VIDCTRL.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Members
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 VideoControlFlag_FlipHorizontal}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies that the camera control setting can be modified manually.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 VideoControlFlag_FlipVertical}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies that the camera control setting can be modified automatically.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 VideoControlFlag_ExternalTriggerEnable}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies that the camera control setting can be modified automatically.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 VideoControlFlag_Trigger}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies that the camera control setting can be modified automatically.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEOFASTUPDATEGOB_S Structure
\par }\pard\plain \s16\ql \li0\ri0\sl-220\slmult0\widctlpar\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800\faauto\rin0\lin0\itap0 \f2\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 typedef struct \{
\par \tab DWORD dwFirstGOB;
\par \tab DWORD dwNumberOfGOBs;
\par \} VIDEOFASTUPDATEGOB_S;
\par 
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The }{\b\insrsid1197183 VIDEOFASTUPDATEGOB_S}{\insrsid1197183 
 structure is used with the KSPROPERTY_H245VIDENCCOMMAND_VIDEOFASTUPDATEGOB property.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/H245VIDE.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Members
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 dwFirstGOB}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the number of the first GOB to be updated. This value is only valid between 0 and 17.

\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 dwNumberOfGOBs}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the number of GOBs to be updated. This value is only valid between 1 and 18.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEOFASTUPDATEMB_S Structure
\par }\pard\plain \s16\ql \li0\ri0\sl-220\slmult0\widctlpar\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800\faauto\rin0\lin0\itap0 \f2\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 typedef struct \{
\par \tab DWORD dwFirstGOB;
\par \tab DWORD dwFirstMB;
\par \tab DWORD dwNumberOfMBs;
\par \} VIDEOFASTUPDATEMB_S;
\par 
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The }{\b\insrsid1197183 VIDEOFASTUPDATEMB_S}{\insrsid1197183  structure is used with the 
KSPROPERTY_H245VIDENCCOMMAND_VIDEOFASTUPDATEMB property.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/H245VIDE.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Members
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 dwFirstGOB}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the number of the first GOB to be 
updated and is only relative to H.263. This value is only valid between 0 and 255.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 dwFirstMB}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies the number of the first MB to be updated and is only relative to H.261. This value is only valid between 1 and 8192.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 dwNumberOfMBs}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the number of MBs to be updated. This value is only valid between 1 and 8192.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 VIDEONOTDECODEDMBS_S Structure
\par }\pard\plain \s16\ql \li0\ri0\sl-220\slmult0\widctlpar\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800\faauto\rin0\lin0\itap0 \f2\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 typedef struct \{
\par \tab DWORD dwFirstMB;
\par \tab DWORD dwNumberOfMBs;
\par \tab DWORD dwTemporalReference;
\par \} VIDEONOTDECODEDMBS_S;
\par 
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The }{\b\insrsid1197183 VIDEONOTDECODEDMBS_S}{\insrsid1197183  structure is used with 
the KSPROPERTY_H245VIDENCINDICATION_VIDEONOTDECODEDMBS property.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/H245VIDE.CPP
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Members
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 dwFirstMB}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies the number of the first MB treated as not coded. This value is only valid between 1 and 8192.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 dwNumberOfMBs}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Specifies the number of MBs treated as not coded. This value is only valid between 1 and 8192.

\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 dwTemporalReference}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
Specifies the temporal reference of the picture containing not decoded MBs. This value is only valid between 0 and 255.
\par }\pard\plain \s24\ql \li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\widctlpar\brdrb\brdrs\brdrw15\brdrcf2 \faauto\rin30\lin-1770\itap0 \fs8\cf8\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 
\par }\pard\plain \s1\ql \li-1800\ri0\sb200\sa80\sl-440\slmult0\keepn\widctlpar\faauto\outlinelevel0\rin0\lin-1800\itap0 \b\fs40\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 WDMVIDEOBUFF Structure
\par }\pard\plain \s16\ql \li0\ri0\sl-220\slmult0\widctlpar\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800\faauto\rin0\lin0\itap0 \f2\fs16\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 typedef struct \{
\par \tab OVERLAPPED Overlap;
\par \tab BOOL fBlocking;
\par \tab KS_HEADER_AND_INFO SHGetImage;
\par \tab LPVIDEOHDR pVideoHdr;
\par \} WDMVIDEOBUFF;
\par 
\par }\pard\plain \ql \li0\ri0\sa160\sl240\slmult0\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 The }{\b\insrsid1197183 WDMVIDEOBUFF}{\insrsid1197183 
 structure is used to queue asynchronous read on a video streaming pin.
\par Defined in: P:/W98GOLD/WDM10/CAPTURE/AMOVIE/TAPIVCAP.SLM/DEVICE.H
\par }\pard\plain \s19\ql \li0\ri0\sb20\sl-220\slmult0\keepn\widctlpar\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240\faauto\rin0\lin0\itap0 \b\f1\fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Members
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 Overlap}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Structure used for overlapping IOs.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 fBlocking}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Set to TRUE if read is going to block.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 SHGetImage}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Video streaming structure used on the video pin to get video data.
\par }\pard\plain \s20\ql \li0\ri0\sl-240\slmult0\keepn\widctlpar\faauto\rin0\lin0\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\insrsid1197183 pVideoHdr}{\insrsid1197183 
\par }\pard\plain \s22\ql \li280\ri0\sa80\sl-240\slmult0\widctlpar\faauto\rin0\lin280\itap0 \fs21\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\insrsid1197183 Pointer to the video header for this WDM video buffer.
\par }}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\readme.txt ===
Copyright (c) 1999  Microsoft Corporation


Phone TSP



Overview:
~~~~~~~~~
Hidphone is a TSP (telephony service provider) that implements support for 
USB phone devices that are HID (human interface device) compliant.

The TSP communicates with the HID interface that provides abstraction for
the phone devices. The TSP enumerates the HID phone devices available on the
system and makes them available to TAPI applications. The TSP provides 
thread-safe access to these phone devices. TAPISRV communicates with this TSP
when it needs access to these phone devices. The TSP provides
the TSP API functions that TAPISRV uses to call the TSP. 



The following files implement the TSP
    hidphone.h  - this file contains all the variables used by the TSP
    hidphone.c  - this file contains the implementations of the TSPI functions


The following declare the main DLL exports:
    hidphone.def 


The following files declare all the strings used throughout the TSP:
    hidphone.rc
    resource.h

The following files provide functions to get the wave ids of the audio devices
associated with the phones:
    audio.h
    audio.cpp

The following file discovers the Hid phone devices on the system
    pnp.c

The following file helps in sending and receiving reports from the HID device
    report.c

The following define and implement the logging functionality:
    mylog.h
    mylog.c

The following define and implement the heap trace inorder to detect memory leaks:
    mymem.h
    mymem.c


How to use the TSP:
~~~~~~~~~~~~~~~~~~~~~~

Copy hidphone.tsp to the %windir%\winnt\system32 directory
Add the tsp in the control panel.

The tsp can now be accessed by TAPI applications


What functionality does this TSP show:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Enumerate the supported HID-compliant phone devices
* Negotiates TAPI version 2.0 - 3.0 
* Discovers the capabilities of each phone device supported
* Provides information about the phones when requested
* Receive and send input, feature and output reports from and to the device.
* Send Phone state and Phone Button events to TAPISRV
* Plug and play capability
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\rend.txt ===
Const RENDBIND_AUTHENTICATE                   =&H00000001
Const RENDBIND_DEFAULTDOMAINNAME              =&H00000002
Const RENDBIND_DEFAULTUSERNAME                =&H00000004
Const RENDBIND_DEFAULTPASSWORD                =&H00000008
Const RENDBIND_DEFAULTCREDENTIALS             =&H0000000e
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\tapi.txt ===
Public Const LINEADDRCAPFLAGS_FWDNUMRINGS            =&H00000001
Public Const LINEADDRCAPFLAGS_PICKUPGROUPID          =&H00000002
Public Const LINEADDRCAPFLAGS_SECURE                 =&H00000004
Public Const LINEADDRCAPFLAGS_BLOCKIDDEFAULT         =&H00000008
Public Const LINEADDRCAPFLAGS_BLOCKIDOVERRIDE        =&H00000010
Public Const LINEADDRCAPFLAGS_DIALED                 =&H00000020
Public Const LINEADDRCAPFLAGS_ORIGOFFHOOK            =&H00000040
Public Const LINEADDRCAPFLAGS_DESTOFFHOOK            =&H00000080
Public Const LINEADDRCAPFLAGS_FWDCONSULT             =&H00000100
Public Const LINEADDRCAPFLAGS_SETUPCONFNULL          =&H00000200
Public Const LINEADDRCAPFLAGS_AUTORECONNECT          =&H00000400
Public Const LINEADDRCAPFLAGS_COMPLETIONID           =&H00000800
Public Const LINEADDRCAPFLAGS_TRANSFERHELD           =&H00001000
Public Const LINEADDRCAPFLAGS_TRANSFERMAKE           =&H00002000
Public Const LINEADDRCAPFLAGS_CONFERENCEHELD         =&H00004000
Public Const LINEADDRCAPFLAGS_CONFERENCEMAKE         =&H00008000
Public Const LINEADDRCAPFLAGS_PARTIALDIAL            =&H00010000
Public Const LINEADDRCAPFLAGS_FWDSTATUSVALID         =&H00020000
Public Const LINEADDRCAPFLAGS_FWDINTEXTADDR          =&H00040000
Public Const LINEADDRCAPFLAGS_FWDBUSYNAADDR          =&H00080000
Public Const LINEADDRCAPFLAGS_ACCEPTTOALERT          =&H00100000
Public Const LINEADDRCAPFLAGS_CONFDROP               =&H00200000
Public Const LINEADDRCAPFLAGS_PICKUPCALLWAIT         =&H00400000
Public Const LINEADDRCAPFLAGS_PREDICTIVEDIALER       =&H00800000
Public Const LINEADDRCAPFLAGS_QUEUE                  =&H01000000
Public Const LINEADDRCAPFLAGS_ROUTEPOINT             =&H02000000
Public Const LINEADDRCAPFLAGS_HOLDMAKESNEW           =&H04000000
Public Const LINEADDRCAPFLAGS_NOINTERNALCALLS        =&H08000000
Public Const LINEADDRCAPFLAGS_NOEXTERNALCALLS        =&H10000000
Public Const LINEADDRCAPFLAGS_SETCALLINGID           =&H20000000
Public Const LINEADDRCAPFLAGS_ACDGROUP               =&H40000000

Public Const LINEADDRESSMODE_ADDRESSID               =&H00000001
Public Const LINEADDRESSMODE_DIALABLEADDR            =&H00000002

Public Const LINEADDRESSSHARING_PRIVATE              =&H00000001
Public Const LINEADDRESSSHARING_BRIDGEDEXCL          =&H00000002
Public Const LINEADDRESSSHARING_BRIDGEDNEW           =&H00000004
Public Const LINEADDRESSSHARING_BRIDGEDSHARED        =&H00000008
Public Const LINEADDRESSSHARING_MONITORED            =&H00000010

Public Const LINEADDRESSSTATE_OTHER                  =&H00000001
Public Const LINEADDRESSSTATE_DEVSPECIFIC            =&H00000002
Public Const LINEADDRESSSTATE_INUSEZERO              =&H00000004
Public Const LINEADDRESSSTATE_INUSEONE               =&H00000008
Public Const LINEADDRESSSTATE_INUSEMANY              =&H00000010
Public Const LINEADDRESSSTATE_NUMCALLS               =&H00000020
Public Const LINEADDRESSSTATE_FORWARD                =&H00000040
Public Const LINEADDRESSSTATE_TERMINALS              =&H00000080
Public Const LINEADDRESSSTATE_CAPSCHANGE             =&H00000100

Public Const LINEADDRESSTYPE_PHONENUMBER             =&H00000001
Public Const LINEADDRESSTYPE_SDP                     =&H00000002
Public Const LINEADDRESSTYPE_EMAILNAME               =&H00000004
Public Const LINEADDRESSTYPE_DOMAINNAME              =&H00000008
Public Const LINEADDRESSTYPE_IPADDRESS               =&H00000010

Public Const LINEADDRFEATURE_FORWARD                 =&H00000001
Public Const LINEADDRFEATURE_MAKECALL                =&H00000002
Public Const LINEADDRFEATURE_PICKUP                  =&H00000004
Public Const LINEADDRFEATURE_SETMEDIACONTROL         =&H00000008
Public Const LINEADDRFEATURE_SETTERMINAL             =&H00000010
Public Const LINEADDRFEATURE_SETUPCONF               =&H00000020
Public Const LINEADDRFEATURE_UNCOMPLETECALL          =&H00000040
Public Const LINEADDRFEATURE_UNPARK                  =&H00000080
Public Const LINEADDRFEATURE_PICKUPHELD              =&H00000100
Public Const LINEADDRFEATURE_PICKUPGROUP             =&H00000200
Public Const LINEADDRFEATURE_PICKUPDIRECT            =&H00000400
Public Const LINEADDRFEATURE_PICKUPWAITING           =&H00000800
Public Const LINEADDRFEATURE_FORWARDFWD              =&H00001000
Public Const LINEADDRFEATURE_FORWARDDND              =&H00002000

Public Const LINEAGENTFEATURE_SETAGENTGROUP          =&H00000001
Public Const LINEAGENTFEATURE_SETAGENTSTATE          =&H00000002
Public Const LINEAGENTFEATURE_SETAGENTACTIVITY       =&H00000004
Public Const LINEAGENTFEATURE_AGENTSPECIFIC          =&H00000008
Public Const LINEAGENTFEATURE_GETAGENTACTIVITYLIST   =&H00000010
Public Const LINEAGENTFEATURE_GETAGENTGROUP          =&H00000020

Public Const LINEAGENTSTATE_LOGGEDOFF                =&H00000001
Public Const LINEAGENTSTATE_NOTREADY                 =&H00000002
Public Const LINEAGENTSTATE_READY                    =&H00000004
Public Const LINEAGENTSTATE_BUSYACD                  =&H00000008
Public Const LINEAGENTSTATE_BUSYINCOMING             =&H00000010
Public Const LINEAGENTSTATE_BUSYOUTBOUND             =&H00000020
Public Const LINEAGENTSTATE_BUSYOTHER                =&H00000040
Public Const LINEAGENTSTATE_WORKINGAFTERCALL         =&H00000080
Public Const LINEAGENTSTATE_UNKNOWN                  =&H00000100
Public Const LINEAGENTSTATE_UNAVAIL                  =&H00000200

Public Const LINEAGENTSTATUS_GROUP                   =&H00000001
Public Const LINEAGENTSTATUS_STATE                   =&H00000002
Public Const LINEAGENTSTATUS_NEXTSTATE               =&H00000004
Public Const LINEAGENTSTATUS_ACTIVITY                =&H00000008
Public Const LINEAGENTSTATUS_ACTIVITYLIST            =&H00000010
Public Const LINEAGENTSTATUS_GROUPLIST               =&H00000020
Public Const LINEAGENTSTATUS_CAPSCHANGE              =&H00000040
Public Const LINEAGENTSTATUS_VALIDSTATES             =&H00000080
Public Const LINEAGENTSTATUS_VALIDNEXTSTATES         =&H00000100

Public Const LINEAGENTSTATEEX_NOTREADY               =&H00000001
Public Const LINEAGENTSTATEEX_READY                  =&H00000002
Public Const LINEAGENTSTATEEX_BUSYACD                =&H00000004
Public Const LINEAGENTSTATEEX_BUSYINCOMING           =&H00000008
Public Const LINEAGENTSTATEEX_BUSYOUTGOING           =&H00000010
Public Const LINEAGENTSTATEEX_UNKNOWN                =&H00000020
Public Const LINEAGENTSTATEEX_RELEASED               =&H00000040

Public Const LINEAGENTSTATUSEX_NEWAGENT              =&H00000001
Public Const LINEAGENTSTATUSEX_STATE                 =&H00000002
Public Const LINEAGENTSTATUSEX_UPDATEINFO            =&H00000004

Public Const LINEAGENTSESSIONSTATE_NOTREADY          =&H00000001
Public Const LINEAGENTSESSIONSTATE_READY             =&H00000002
Public Const LINEAGENTSESSIONSTATE_BUSYONCALL        =&H00000004
Public Const LINEAGENTSESSIONSTATE_BUSYWRAPUP        =&H00000008
Public Const LINEAGENTSESSIONSTATE_ENDED             =&H00000010
Public Const LINEAGENTSESSIONSTATE_RELEASED          =&H00000020

Public Const LINEAGENTSESSIONSTATUS_NEWSESSION       =&H00000001
Public Const LINEAGENTSESSIONSTATUS_STATE            =&H00000002
Public Const LINEAGENTSESSIONSTATUS_UPDATEINFO       =&H00000004

Public Const LINEQUEUESTATUS_UPDATEINFO              =&H00000001
Public Const LINEQUEUESTATUS_NEWQUEUE                =&H00000002
Public Const LINEQUEUESTATUS_QUEUEREMOVED            =&H00000004

Public Const LINEGROUPSTATUS_NEWGROUP                =&H00000001
Public Const LINEGROUPSTATUS_GROUPREMOVED            =&H00000002

Public Const LINEPROXYSTATUS_OPEN                    =&H00000001
Public Const LINEPROXYSTATUS_CLOSE                   =&H00000002
Public Const LINEPROXYSTATUS_ALLOPENFORACD           =&H00000004

Public Const LINEANSWERMODE_NONE                     =&H00000001
Public Const LINEANSWERMODE_DROP                     =&H00000002
Public Const LINEANSWERMODE_HOLD                     =&H00000004

Public Const LINEBEARERMODE_VOICE                    =&H00000001
Public Const LINEBEARERMODE_SPEECH                   =&H00000002
Public Const LINEBEARERMODE_MULTIUSE                 =&H00000004
Public Const LINEBEARERMODE_DATA                     =&H00000008
Public Const LINEBEARERMODE_ALTSPEECHDATA            =&H00000010
Public Const LINEBEARERMODE_NONCALLSIGNALING         =&H00000020
Public Const LINEBEARERMODE_PASSTHROUGH              =&H00000040
Public Const LINEBEARERMODE_RESTRICTEDDATA           =&H00000080

Public Const LINEBUSYMODE_STATION                    =&H00000001
Public Const LINEBUSYMODE_TRUNK                      =&H00000002
Public Const LINEBUSYMODE_UNKNOWN                    =&H00000004
Public Const LINEBUSYMODE_UNAVAIL                    =&H00000008

Public Const LINECALLCOMPLCOND_BUSY                  =&H00000001
Public Const LINECALLCOMPLCOND_NOANSWER              =&H00000002

Public Const LINECALLCOMPLMODE_CAMPON                =&H00000001
Public Const LINECALLCOMPLMODE_CALLBACK              =&H00000002
Public Const LINECALLCOMPLMODE_INTRUDE               =&H00000004
Public Const LINECALLCOMPLMODE_MESSAGE               =&H00000008

Public Const LINECALLFEATURE_ACCEPT                  =&H00000001
Public Const LINECALLFEATURE_ADDTOCONF               =&H00000002
Public Const LINECALLFEATURE_ANSWER                  =&H00000004
Public Const LINECALLFEATURE_BLINDTRANSFER           =&H00000008
Public Const LINECALLFEATURE_COMPLETECALL            =&H00000010
Public Const LINECALLFEATURE_COMPLETETRANSF          =&H00000020
Public Const LINECALLFEATURE_DIAL                    =&H00000040
Public Const LINECALLFEATURE_DROP                    =&H00000080
Public Const LINECALLFEATURE_GATHERDIGITS            =&H00000100
Public Const LINECALLFEATURE_GENERATEDIGITS          =&H00000200
Public Const LINECALLFEATURE_GENERATETONE            =&H00000400
Public Const LINECALLFEATURE_HOLD                    =&H00000800
Public Const LINECALLFEATURE_MONITORDIGITS           =&H00001000
Public Const LINECALLFEATURE_MONITORMEDIA            =&H00002000
Public Const LINECALLFEATURE_MONITORTONES            =&H00004000
Public Const LINECALLFEATURE_PARK                    =&H00008000
Public Const LINECALLFEATURE_PREPAREADDCONF          =&H00010000
Public Const LINECALLFEATURE_REDIRECT                =&H00020000
Public Const LINECALLFEATURE_REMOVEFROMCONF          =&H00040000
Public Const LINECALLFEATURE_SECURECALL              =&H00080000
Public Const LINECALLFEATURE_SENDUSERUSER            =&H00100000
Public Const LINECALLFEATURE_SETCALLPARAMS           =&H00200000
Public Const LINECALLFEATURE_SETMEDIACONTROL         =&H00400000
Public Const LINECALLFEATURE_SETTERMINAL             =&H00800000
Public Const LINECALLFEATURE_SETUPCONF               =&H01000000
Public Const LINECALLFEATURE_SETUPTRANSFER           =&H02000000
Public Const LINECALLFEATURE_SWAPHOLD                =&H04000000
Public Const LINECALLFEATURE_UNHOLD                  =&H08000000
Public Const LINECALLFEATURE_RELEASEUSERUSERINFO     =&H10000000
Public Const LINECALLFEATURE_SETTREATMENT            =&H20000000
Public Const LINECALLFEATURE_SETQOS                  =&H40000000
Public Const LINECALLFEATURE_SETCALLDATA             =&H80000000

Public Const LINECALLFEATURE2_NOHOLDCONFERENCE       =&H00000001
Public Const LINECALLFEATURE2_ONESTEPTRANSFER        =&H00000002
Public Const LINECALLFEATURE2_COMPLCAMPON            =&H00000004
Public Const LINECALLFEATURE2_COMPLCALLBACK          =&H00000008
Public Const LINECALLFEATURE2_COMPLINTRUDE           =&H00000010
Public Const LINECALLFEATURE2_COMPLMESSAGE           =&H00000020
Public Const LINECALLFEATURE2_TRANSFERNORM           =&H00000040
Public Const LINECALLFEATURE2_TRANSFERCONF           =&H00000080
Public Const LINECALLFEATURE2_PARKDIRECT             =&H00000100
Public Const LINECALLFEATURE2_PARKNONDIRECT          =&H00000200

Public Const LINECALLHUBTRACKING_NONE                =&H00000000
Public Const LINECALLHUBTRACKING_PROVIDERLEVEL       =&H00000001
Public Const LINECALLHUBTRACKING_ALLCALLS            =&H00000002

Public Const LINECALLINFOSTATE_OTHER                 =&H00000001
Public Const LINECALLINFOSTATE_DEVSPECIFIC           =&H00000002
Public Const LINECALLINFOSTATE_BEARERMODE            =&H00000004
Public Const LINECALLINFOSTATE_RATE                  =&H00000008
Public Const LINECALLINFOSTATE_MEDIAMODE             =&H00000010
Public Const LINECALLINFOSTATE_APPSPECIFIC           =&H00000020
Public Const LINECALLINFOSTATE_CALLID                =&H00000040
Public Const LINECALLINFOSTATE_RELATEDCALLID         =&H00000080
Public Const LINECALLINFOSTATE_ORIGIN                =&H00000100
Public Const LINECALLINFOSTATE_REASON                =&H00000200
Public Const LINECALLINFOSTATE_COMPLETIONID          =&H00000400
Public Const LINECALLINFOSTATE_NUMOWNERINCR          =&H00000800
Public Const LINECALLINFOSTATE_NUMOWNERDECR          =&H00001000
Public Const LINECALLINFOSTATE_NUMMONITORS           =&H00002000
Public Const LINECALLINFOSTATE_TRUNK                 =&H00004000
Public Const LINECALLINFOSTATE_CALLERID              =&H00008000
Public Const LINECALLINFOSTATE_CALLEDID              =&H00010000
Public Const LINECALLINFOSTATE_CONNECTEDID           =&H00020000
Public Const LINECALLINFOSTATE_REDIRECTIONID         =&H00040000
Public Const LINECALLINFOSTATE_REDIRECTINGID         =&H00080000
Public Const LINECALLINFOSTATE_DISPLAY               =&H00100000
Public Const LINECALLINFOSTATE_USERUSERINFO          =&H00200000
Public Const LINECALLINFOSTATE_HIGHLEVELCOMP         =&H00400000
Public Const LINECALLINFOSTATE_LOWLEVELCOMP          =&H00800000
Public Const LINECALLINFOSTATE_CHARGINGINFO          =&H01000000
Public Const LINECALLINFOSTATE_TERMINAL              =&H02000000
Public Const LINECALLINFOSTATE_DIALPARAMS            =&H04000000
Public Const LINECALLINFOSTATE_MONITORMODES          =&H08000000
Public Const LINECALLINFOSTATE_TREATMENT             =&H10000000
Public Const LINECALLINFOSTATE_QOS                   =&H20000000
Public Const LINECALLINFOSTATE_CALLDATA              =&H40000000

Public Const LINECALLORIGIN_OUTBOUND                 =&H00000001
Public Const LINECALLORIGIN_INTERNAL                 =&H00000002
Public Const LINECALLORIGIN_EXTERNAL                 =&H00000004
Public Const LINECALLORIGIN_UNKNOWN                  =&H00000010
Public Const LINECALLORIGIN_UNAVAIL                  =&H00000020
Public Const LINECALLORIGIN_CONFERENCE               =&H00000040
Public Const LINECALLORIGIN_INBOUND                  =&H00000080

Public Const LINECALLPARAMFLAGS_SECURE               =&H00000001
Public Const LINECALLPARAMFLAGS_IDLE                 =&H00000002
Public Const LINECALLPARAMFLAGS_BLOCKID              =&H00000004
Public Const LINECALLPARAMFLAGS_ORIGOFFHOOK          =&H00000008
Public Const LINECALLPARAMFLAGS_DESTOFFHOOK          =&H00000010
Public Const LINECALLPARAMFLAGS_NOHOLDCONFERENCE     =&H00000020
Public Const LINECALLPARAMFLAGS_PREDICTIVEDIAL       =&H00000040
Public Const LINECALLPARAMFLAGS_ONESTEPTRANSFER      =&H00000080

Public Const LINECALLPARTYID_BLOCKED                 =&H00000001
Public Const LINECALLPARTYID_OUTOFAREA               =&H00000002
Public Const LINECALLPARTYID_NAME                    =&H00000004
Public Const LINECALLPARTYID_ADDRESS                 =&H00000008
Public Const LINECALLPARTYID_PARTIAL                 =&H00000010
Public Const LINECALLPARTYID_UNKNOWN                 =&H00000020
Public Const LINECALLPARTYID_UNAVAIL                 =&H00000040

Public Const LINECALLPRIVILEGE_NONE                  =&H00000001
Public Const LINECALLPRIVILEGE_MONITOR               =&H00000002
Public Const LINECALLPRIVILEGE_OWNER                 =&H00000004

Public Const LINECALLREASON_DIRECT                   =&H00000001
Public Const LINECALLREASON_FWDBUSY                  =&H00000002
Public Const LINECALLREASON_FWDNOANSWER              =&H00000004
Public Const LINECALLREASON_FWDUNCOND                =&H00000008
Public Const LINECALLREASON_PICKUP                   =&H00000010
Public Const LINECALLREASON_UNPARK                   =&H00000020
Public Const LINECALLREASON_REDIRECT                 =&H00000040
Public Const LINECALLREASON_CALLCOMPLETION           =&H00000080
Public Const LINECALLREASON_TRANSFER                 =&H00000100
Public Const LINECALLREASON_REMINDER                 =&H00000200
Public Const LINECALLREASON_UNKNOWN                  =&H00000400
Public Const LINECALLREASON_UNAVAIL                  =&H00000800
Public Const LINECALLREASON_INTRUDE                  =&H00001000
Public Const LINECALLREASON_PARKED                   =&H00002000
Public Const LINECALLREASON_CAMPEDON                 =&H00004000
Public Const LINECALLREASON_ROUTEREQUEST             =&H00008000

Public Const LINECALLSELECT_LINE                     =&H00000001
Public Const LINECALLSELECT_ADDRESS                  =&H00000002
Public Const LINECALLSELECT_CALL                     =&H00000004
Public Const LINECALLSELECT_DEVICEID                 =&H00000008
Public Const LINECALLSELECT_CALLID                   =&H00000010

Public Const LINECALLSTATE_IDLE                      =&H00000001
Public Const LINECALLSTATE_OFFERING                  =&H00000002
Public Const LINECALLSTATE_ACCEPTED                  =&H00000004
Public Const LINECALLSTATE_DIALTONE                  =&H00000008
Public Const LINECALLSTATE_DIALING                   =&H00000010
Public Const LINECALLSTATE_RINGBACK                  =&H00000020
Public Const LINECALLSTATE_BUSY                      =&H00000040
Public Const LINECALLSTATE_SPECIALINFO               =&H00000080
Public Const LINECALLSTATE_CONNECTED                 =&H00000100
Public Const LINECALLSTATE_PROCEEDING                =&H00000200
Public Const LINECALLSTATE_ONHOLD                    =&H00000400
Public Const LINECALLSTATE_CONFERENCED               =&H00000800
Public Const LINECALLSTATE_ONHOLDPENDCONF            =&H00001000
Public Const LINECALLSTATE_ONHOLDPENDTRANSFER        =&H00002000
Public Const LINECALLSTATE_DISCONNECTED              =&H00004000
Public Const LINECALLSTATE_UNKNOWN                   =&H00008000

Public Const LINECALLTREATMENT_SILENCE               =&H00000001
Public Const LINECALLTREATMENT_RINGBACK              =&H00000002
Public Const LINECALLTREATMENT_BUSY                  =&H00000003
Public Const LINECALLTREATMENT_MUSIC                 =&H00000004

Public Const LINECARDOPTION_PREDEFINED               =&H00000001
Public Const LINECARDOPTION_HIDDEN                   =&H00000002

Public Const LINECONNECTEDMODE_ACTIVE                =&H00000001
Public Const LINECONNECTEDMODE_INACTIVE              =&H00000002
Public Const LINECONNECTEDMODE_ACTIVEHELD            =&H00000004
Public Const LINECONNECTEDMODE_INACTIVEHELD          =&H00000008
Public Const LINECONNECTEDMODE_CONFIRMED             =&H00000010

Public Const LINEDEVCAPFLAGS_CROSSADDRCONF           =&H00000001
Public Const LINEDEVCAPFLAGS_HIGHLEVCOMP             =&H00000002
Public Const LINEDEVCAPFLAGS_LOWLEVCOMP              =&H00000004
Public Const LINEDEVCAPFLAGS_MEDIACONTROL            =&H00000008
Public Const LINEDEVCAPFLAGS_MULTIPLEADDR            =&H00000010
Public Const LINEDEVCAPFLAGS_CLOSEDROP               =&H00000020
Public Const LINEDEVCAPFLAGS_DIALBILLING             =&H00000040
Public Const LINEDEVCAPFLAGS_DIALQUIET               =&H00000080
Public Const LINEDEVCAPFLAGS_DIALDIALTONE            =&H00000100
Public Const LINEDEVCAPFLAGS_MSP                     =&H00000200
Public Const LINEDEVCAPFLAGS_CALLHUB                 =&H00000400
Public Const LINEDEVCAPFLAGS_CALLHUBTRACKING         =&H00000800
Public Const LINEDEVCAPFLAGS_PRIVATEOBJECTS          =&H00001000

Public Const LINEDEVSTATE_OTHER                      =&H00000001
Public Const LINEDEVSTATE_RINGING                    =&H00000002
Public Const LINEDEVSTATE_CONNECTED                  =&H00000004
Public Const LINEDEVSTATE_DISCONNECTED               =&H00000008
Public Const LINEDEVSTATE_MSGWAITON                  =&H00000010
Public Const LINEDEVSTATE_MSGWAITOFF                 =&H00000020
Public Const LINEDEVSTATE_INSERVICE                  =&H00000040
Public Const LINEDEVSTATE_OUTOFSERVICE               =&H00000080
Public Const LINEDEVSTATE_MAINTENANCE                =&H00000100
Public Const LINEDEVSTATE_OPEN                       =&H00000200
Public Const LINEDEVSTATE_CLOSE                      =&H00000400
Public Const LINEDEVSTATE_NUMCALLS                   =&H00000800
Public Const LINEDEVSTATE_NUMCOMPLETIONS             =&H00001000
Public Const LINEDEVSTATE_TERMINALS                  =&H00002000
Public Const LINEDEVSTATE_ROAMMODE                   =&H00004000
Public Const LINEDEVSTATE_BATTERY                    =&H00008000
Public Const LINEDEVSTATE_SIGNAL                     =&H00010000
Public Const LINEDEVSTATE_DEVSPECIFIC                =&H00020000
Public Const LINEDEVSTATE_REINIT                     =&H00040000
Public Const LINEDEVSTATE_LOCK                       =&H00080000
Public Const LINEDEVSTATE_CAPSCHANGE                 =&H00100000
Public Const LINEDEVSTATE_CONFIGCHANGE               =&H00200000
Public Const LINEDEVSTATE_TRANSLATECHANGE            =&H00400000
Public Const LINEDEVSTATE_COMPLCANCEL                =&H00800000
Public Const LINEDEVSTATE_REMOVED                    =&H01000000

Public Const LINEDEVSTATUSFLAGS_CONNECTED            =&H00000001
Public Const LINEDEVSTATUSFLAGS_MSGWAIT              =&H00000002
Public Const LINEDEVSTATUSFLAGS_INSERVICE            =&H00000004
Public Const LINEDEVSTATUSFLAGS_LOCKED               =&H00000008

Public Const LINEDIALTONEMODE_NORMAL                 =&H00000001
Public Const LINEDIALTONEMODE_SPECIAL                =&H00000002
Public Const LINEDIALTONEMODE_INTERNAL               =&H00000004
Public Const LINEDIALTONEMODE_EXTERNAL               =&H00000008
Public Const LINEDIALTONEMODE_UNKNOWN                =&H00000010
Public Const LINEDIALTONEMODE_UNAVAIL                =&H00000020

Public Const LINEDIGITMODE_PULSE                     =&H00000001
Public Const LINEDIGITMODE_DTMF                      =&H00000002
Public Const LINEDIGITMODE_DTMFEND                   =&H00000004

Public Const LINEDISCONNECTMODE_NORMAL               =&H00000001
Public Const LINEDISCONNECTMODE_UNKNOWN              =&H00000002
Public Const LINEDISCONNECTMODE_REJECT               =&H00000004
Public Const LINEDISCONNECTMODE_PICKUP               =&H00000008
Public Const LINEDISCONNECTMODE_FORWARDED            =&H00000010
Public Const LINEDISCONNECTMODE_BUSY                 =&H00000020
Public Const LINEDISCONNECTMODE_NOANSWER             =&H00000040
Public Const LINEDISCONNECTMODE_BADADDRESS           =&H00000080
Public Const LINEDISCONNECTMODE_UNREACHABLE          =&H00000100
Public Const LINEDISCONNECTMODE_CONGESTION           =&H00000200
Public Const LINEDISCONNECTMODE_INCOMPATIBLE         =&H00000400
Public Const LINEDISCONNECTMODE_UNAVAIL              =&H00000800
Public Const LINEDISCONNECTMODE_NODIALTONE           =&H00001000
Public Const LINEDISCONNECTMODE_NUMBERCHANGED        =&H00002000
Public Const LINEDISCONNECTMODE_OUTOFORDER           =&H00004000
Public Const LINEDISCONNECTMODE_TEMPFAILURE          =&H00008000
Public Const LINEDISCONNECTMODE_QOSUNAVAIL           =&H00010000
Public Const LINEDISCONNECTMODE_BLOCKED              =&H00020000
Public Const LINEDISCONNECTMODE_DONOTDISTURB         =&H00040000
Public Const LINEDISCONNECTMODE_CANCELLED            =&H00080000

Public Const LINEERR_ALLOCATED                       =&H80000001
Public Const LINEERR_BADDEVICEID                     =&H80000002
Public Const LINEERR_BEARERMODEUNAVAIL               =&H80000003
Public Const LINEERR_CALLUNAVAIL                     =&H80000005
Public Const LINEERR_COMPLETIONOVERRUN               =&H80000006
Public Const LINEERR_CONFERENCEFULL                  =&H80000007
Public Const LINEERR_DIALBILLING                     =&H80000008
Public Const LINEERR_DIALDIALTONE                    =&H80000009
Public Const LINEERR_DIALPROMPT                      =&H8000000A
Public Const LINEERR_DIALQUIET                       =&H8000000B
Public Const LINEERR_INCOMPATIBLEAPIVERSION          =&H8000000C
Public Const LINEERR_INCOMPATIBLEEXTVERSION          =&H8000000D
Public Const LINEERR_INIFILECORRUPT                  =&H8000000E
Public Const LINEERR_INUSE                           =&H8000000F
Public Const LINEERR_INVALADDRESS                    =&H80000010
Public Const LINEERR_INVALADDRESSID                  =&H80000011
Public Const LINEERR_INVALADDRESSMODE                =&H80000012
Public Const LINEERR_INVALADDRESSSTATE               =&H80000013
Public Const LINEERR_INVALAPPHANDLE                  =&H80000014
Public Const LINEERR_INVALAPPNAME                    =&H80000015
Public Const LINEERR_INVALBEARERMODE                 =&H80000016
Public Const LINEERR_INVALCALLCOMPLMODE              =&H80000017
Public Const LINEERR_INVALCALLHANDLE                 =&H80000018
Public Const LINEERR_INVALCALLPARAMS                 =&H80000019
Public Const LINEERR_INVALCALLPRIVILEGE              =&H8000001A
Public Const LINEERR_INVALCALLSELECT                 =&H8000001B
Public Const LINEERR_INVALCALLSTATE                  =&H8000001C
Public Const LINEERR_INVALCALLSTATELIST              =&H8000001D
Public Const LINEERR_INVALCARD                       =&H8000001E
Public Const LINEERR_INVALCOMPLETIONID               =&H8000001F
Public Const LINEERR_INVALCONFCALLHANDLE             =&H80000020
Public Const LINEERR_INVALCONSULTCALLHANDLE          =&H80000021
Public Const LINEERR_INVALCOUNTRYCODE                =&H80000022
Public Const LINEERR_INVALDEVICECLASS                =&H80000023
Public Const LINEERR_INVALDEVICEHANDLE               =&H80000024
Public Const LINEERR_INVALDIALPARAMS                 =&H80000025
Public Const LINEERR_INVALDIGITLIST                  =&H80000026
Public Const LINEERR_INVALDIGITMODE                  =&H80000027
Public Const LINEERR_INVALDIGITS                     =&H80000028
Public Const LINEERR_INVALEXTVERSION                 =&H80000029
Public Const LINEERR_INVALGROUPID                    =&H8000002A
Public Const LINEERR_INVALLINEHANDLE                 =&H8000002B
Public Const LINEERR_INVALLINESTATE                  =&H8000002C
Public Const LINEERR_INVALLOCATION                   =&H8000002D
Public Const LINEERR_INVALMEDIALIST                  =&H8000002E
Public Const LINEERR_INVALMEDIAMODE                  =&H8000002F
Public Const LINEERR_INVALMESSAGEID                  =&H80000030
Public Const LINEERR_INVALPARAM                      =&H80000032
Public Const LINEERR_INVALPARKID                     =&H80000033
Public Const LINEERR_INVALPARKMODE                   =&H80000034
Public Const LINEERR_INVALPOINTER                    =&H80000035
Public Const LINEERR_INVALPRIVSELECT                 =&H80000036
Public Const LINEERR_INVALRATE                       =&H80000037
Public Const LINEERR_INVALREQUESTMODE                =&H80000038
Public Const LINEERR_INVALTERMINALID                 =&H80000039
Public Const LINEERR_INVALTERMINALMODE               =&H8000003A
Public Const LINEERR_INVALTIMEOUT                    =&H8000003B
Public Const LINEERR_INVALTONE                       =&H8000003C
Public Const LINEERR_INVALTONELIST                   =&H8000003D
Public Const LINEERR_INVALTONEMODE                   =&H8000003E
Public Const LINEERR_INVALTRANSFERMODE               =&H8000003F
Public Const LINEERR_LINEMAPPERFAILED                =&H80000040
Public Const LINEERR_NOCONFERENCE                    =&H80000041
Public Const LINEERR_NODEVICE                        =&H80000042
Public Const LINEERR_NODRIVER                        =&H80000043
Public Const LINEERR_NOMEM                           =&H80000044
Public Const LINEERR_NOREQUEST                       =&H80000045
Public Const LINEERR_NOTOWNER                        =&H80000046
Public Const LINEERR_NOTREGISTERED                   =&H80000047
Public Const LINEERR_OPERATIONFAILED                 =&H80000048
Public Const LINEERR_OPERATIONUNAVAIL                =&H80000049
Public Const LINEERR_RATEUNAVAIL                     =&H8000004A
Public Const LINEERR_RESOURCEUNAVAIL                 =&H8000004B
Public Const LINEERR_REQUESTOVERRUN                  =&H8000004C
Public Const LINEERR_STRUCTURETOOSMALL               =&H8000004D
Public Const LINEERR_TARGETNOTFOUND                  =&H8000004E
Public Const LINEERR_TARGETSELF                      =&H8000004F
Public Const LINEERR_UNINITIALIZED                   =&H80000050
Public Const LINEERR_USERUSERINFOTOOBIG              =&H80000051
Public Const LINEERR_REINIT                          =&H80000052
Public Const LINEERR_ADDRESSBLOCKED                  =&H80000053
Public Const LINEERR_BILLINGREJECTED                 =&H80000054
Public Const LINEERR_INVALFEATURE                    =&H80000055
Public Const LINEERR_NOMULTIPLEINSTANCE              =&H80000056
Public Const LINEERR_INVALAGENTID                    =&H80000057
Public Const LINEERR_INVALAGENTGROUP                 =&H80000058
Public Const LINEERR_INVALPASSWORD                   =&H80000059
Public Const LINEERR_INVALAGENTSTATE                 =&H8000005A
Public Const LINEERR_INVALAGENTACTIVITY              =&H8000005B
Public Const LINEERR_DIALVOICEDETECT                 =&H8000005C
Public Const LINEERR_USERCANCELLED                   =&H8000005D
Public Const LINEERR_INVALADDRESSTYPE                =&H8000005E
Public Const LINEERR_INVALAGENTSESSIONSTATE          =&H8000005F
Public Const LINEERR_DISCONNECTED                    =&H80000060
Public Const LINEERR_LASTERRORVALUE                  =&H80000060


Public Const LINEFEATURE_DEVSPECIFIC                 =&H00000001
Public Const LINEFEATURE_DEVSPECIFICFEAT             =&H00000002
Public Const LINEFEATURE_FORWARD                     =&H00000004
Public Const LINEFEATURE_MAKECALL                    =&H00000008
Public Const LINEFEATURE_SETMEDIACONTROL             =&H00000010
Public Const LINEFEATURE_SETTERMINAL                 =&H00000020
Public Const LINEFEATURE_SETDEVSTATUS                =&H00000040
Public Const LINEFEATURE_FORWARDFWD                  =&H00000080
Public Const LINEFEATURE_FORWARDDND                  =&H00000100

Public Const LINEFORWARDMODE_UNCOND                  =&H00000001
Public Const LINEFORWARDMODE_UNCONDINTERNAL          =&H00000002
Public Const LINEFORWARDMODE_UNCONDEXTERNAL          =&H00000004
Public Const LINEFORWARDMODE_UNCONDSPECIFIC          =&H00000008
Public Const LINEFORWARDMODE_BUSY                    =&H00000010
Public Const LINEFORWARDMODE_BUSYINTERNAL            =&H00000020
Public Const LINEFORWARDMODE_BUSYEXTERNAL            =&H00000040
Public Const LINEFORWARDMODE_BUSYSPECIFIC            =&H00000080
Public Const LINEFORWARDMODE_NOANSW                  =&H00000100
Public Const LINEFORWARDMODE_NOANSWINTERNAL          =&H00000200
Public Const LINEFORWARDMODE_NOANSWEXTERNAL          =&H00000400
Public Const LINEFORWARDMODE_NOANSWSPECIFIC          =&H00000800
Public Const LINEFORWARDMODE_BUSYNA                  =&H00001000
Public Const LINEFORWARDMODE_BUSYNAINTERNAL          =&H00002000
Public Const LINEFORWARDMODE_BUSYNAEXTERNAL          =&H00004000
Public Const LINEFORWARDMODE_BUSYNASPECIFIC          =&H00008000
Public Const LINEFORWARDMODE_UNKNOWN                 =&H00010000
Public Const LINEFORWARDMODE_UNAVAIL                 =&H00020000

Public Const LINEGATHERTERM_BUFFERFULL               =&H00000001
Public Const LINEGATHERTERM_TERMDIGIT                =&H00000002
Public Const LINEGATHERTERM_FIRSTTIMEOUT             =&H00000004
Public Const LINEGATHERTERM_INTERTIMEOUT             =&H00000008
Public Const LINEGATHERTERM_CANCEL                   =&H00000010

Public Const LINEGENERATETERM_DONE                   =&H00000001
Public Const LINEGENERATETERM_CANCEL                 =&H00000002

Public Const LINEINITIALIZEEXOPTION_USEHIDDENWINDOW      =&H00000001
Public Const LINEINITIALIZEEXOPTION_USEEVENT             =&H00000002
Public Const LINEINITIALIZEEXOPTION_USECOMPLETIONPORT    =&H00000003

Public Const LINEINITIALIZEEXOPTION_CALLHUBTRACKING      =&H80000000

Public Const LINELOCATIONOPTION_PULSEDIAL            =&H00000001

Public Const LINEMAPPER                              =&HFFFFFFFF

Public Const LINEMEDIACONTROL_NONE                   =&H00000001
Public Const LINEMEDIACONTROL_START                  =&H00000002
Public Const LINEMEDIACONTROL_RESET                  =&H00000004
Public Const LINEMEDIACONTROL_PAUSE                  =&H00000008
Public Const LINEMEDIACONTROL_RESUME                 =&H00000010
Public Const LINEMEDIACONTROL_RATEUP                 =&H00000020
Public Const LINEMEDIACONTROL_RATEDOWN               =&H00000040
Public Const LINEMEDIACONTROL_RATENORMAL             =&H00000080
Public Const LINEMEDIACONTROL_VOLUMEUP               =&H00000100
Public Const LINEMEDIACONTROL_VOLUMEDOWN             =&H00000200
Public Const LINEMEDIACONTROL_VOLUMENORMAL           =&H00000400

Public Const LINEMEDIAMODE_UNKNOWN                   =&H00000002
Public Const LINEMEDIAMODE_INTERACTIVEVOICE          =&H00000004
Public Const LINEMEDIAMODE_AUTOMATEDVOICE            =&H00000008
Public Const LINEMEDIAMODE_DATAMODEM                 =&H00000010
Public Const LINEMEDIAMODE_G3FAX                     =&H00000020
Public Const LINEMEDIAMODE_TDD                       =&H00000040
Public Const LINEMEDIAMODE_G4FAX                     =&H00000080
Public Const LINEMEDIAMODE_DIGITALDATA               =&H00000100
Public Const LINEMEDIAMODE_TELETEX                   =&H00000200
Public Const LINEMEDIAMODE_VIDEOTEX                  =&H00000400
Public Const LINEMEDIAMODE_TELEX                     =&H00000800
Public Const LINEMEDIAMODE_MIXED                     =&H00001000
Public Const LINEMEDIAMODE_ADSI                      =&H00002000
Public Const LINEMEDIAMODE_VOICEVIEW                 =&H00004000
Public Const LINEMEDIAMODE_VIDEO                     =&H00008000
Public Const LAST_LINEMEDIAMODE                      =&H00008000

Public Const LINEOFFERINGMODE_ACTIVE                 =&H00000001
Public Const LINEOFFERINGMODE_INACTIVE               =&H00000002

Public Const LINEOPENOPTION_SINGLEADDRESS            =&H80000000
Public Const LINEOPENOPTION_PROXY                    =&H40000000

Public Const LINEPARKMODE_DIRECTED                   =&H00000001
Public Const LINEPARKMODE_NONDIRECTED                =&H00000002

Public Const LINEPROXYREQUEST_SETAGENTGROUP          =&H00000001
Public Const LINEPROXYREQUEST_SETAGENTSTATE          =&H00000002
Public Const LINEPROXYREQUEST_SETAGENTACTIVITY       =&H00000003
Public Const LINEPROXYREQUEST_GETAGENTCAPS           =&H00000004
Public Const LINEPROXYREQUEST_GETAGENTSTATUS         =&H00000005
Public Const LINEPROXYREQUEST_AGENTSPECIFIC          =&H00000006
Public Const LINEPROXYREQUEST_GETAGENTACTIVITYLIST   =&H00000007
Public Const LINEPROXYREQUEST_GETAGENTGROUPLIST      =&H00000008

Public Const LINEPROXYREQUEST_CREATEAGENT                =&H00000009
Public Const LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD  =&H0000000A
Public Const LINEPROXYREQUEST_GETAGENTINFO               =&H0000000B
Public Const LINEPROXYREQUEST_CREATEAGENTSESSION         =&H0000000C
Public Const LINEPROXYREQUEST_GETAGENTSESSIONLIST        =&H0000000D
Public Const LINEPROXYREQUEST_SETAGENTSESSIONSTATE       =&H0000000E
Public Const LINEPROXYREQUEST_GETAGENTSESSIONINFO        =&H0000000F
Public Const LINEPROXYREQUEST_GETQUEUELIST               =&H00000010
Public Const LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD  =&H00000011
Public Const LINEPROXYREQUEST_GETQUEUEINFO               =&H00000012
Public Const LINEPROXYREQUEST_GETGROUPLIST               =&H00000013
Public Const LINEPROXYREQUEST_SETAGENTSTATEEX            =&H00000014

Public Const LINEREMOVEFROMCONF_NONE                 =&H00000001
Public Const LINEREMOVEFROMCONF_LAST                 =&H00000002
Public Const LINEREMOVEFROMCONF_ANY                  =&H00000003

Public Const LINEREQUESTMODE_MAKECALL                =&H00000001
Public Const LINEREQUESTMODE_MEDIACALL               =&H00000002
Public Const LINEREQUESTMODE_DROP                    =&H00000004
Public Const LAST_LINEREQUESTMODE                    =LINEREQUESTMODE_MEDIACALL

Public Const LINEROAMMODE_UNKNOWN                    =&H00000001
Public Const LINEROAMMODE_UNAVAIL                    =&H00000002
Public Const LINEROAMMODE_HOME                       =&H00000004
Public Const LINEROAMMODE_ROAMA                      =&H00000008
Public Const LINEROAMMODE_ROAMB                      =&H00000010

Public Const LINESPECIALINFO_NOCIRCUIT               =&H00000001
Public Const LINESPECIALINFO_CUSTIRREG               =&H00000002
Public Const LINESPECIALINFO_REORDER                 =&H00000004
Public Const LINESPECIALINFO_UNKNOWN                 =&H00000008
Public Const LINESPECIALINFO_UNAVAIL                 =&H00000010

Public Const LINETERMDEV_PHONE                       =&H00000001
Public Const LINETERMDEV_HEADSET                     =&H00000002
Public Const LINETERMDEV_SPEAKER                     =&H00000004

Public Const LINETERMMODE_BUTTONS                    =&H00000001
Public Const LINETERMMODE_LAMPS                      =&H00000002
Public Const LINETERMMODE_DISPLAY                    =&H00000004
Public Const LINETERMMODE_RINGER                     =&H00000008
Public Const LINETERMMODE_HOOKSWITCH                 =&H00000010
Public Const LINETERMMODE_MEDIATOLINE                =&H00000020
Public Const LINETERMMODE_MEDIAFROMLINE              =&H00000040
Public Const LINETERMMODE_MEDIABIDIRECT              =&H00000080

Public Const LINETERMSHARING_PRIVATE                 =&H00000001
Public Const LINETERMSHARING_SHAREDEXCL              =&H00000002
Public Const LINETERMSHARING_SHAREDCONF              =&H00000004

Public Const LINETOLLLISTOPTION_ADD                  =&H00000001
Public Const LINETOLLLISTOPTION_REMOVE               =&H00000002

Public Const LINETONEMODE_CUSTOM                     =&H00000001
Public Const LINETONEMODE_RINGBACK                   =&H00000002
Public Const LINETONEMODE_BUSY                       =&H00000004
Public Const LINETONEMODE_BEEP                       =&H00000008
Public Const LINETONEMODE_BILLING                    =&H00000010

Public Const LINETRANSFERMODE_TRANSFER               =&H00000001
Public Const LINETRANSFERMODE_CONFERENCE             =&H00000002

Public Const LINETRANSLATEOPTION_CARDOVERRIDE        =&H00000001
Public Const LINETRANSLATEOPTION_CANCELCALLWAITING   =&H00000002
Public Const LINETRANSLATEOPTION_FORCELOCAL          =&H00000004
Public Const LINETRANSLATEOPTION_FORCELD             =&H00000008

Public Const LINETRANSLATERESULT_CANONICAL           =&H00000001
Public Const LINETRANSLATERESULT_INTERNATIONAL       =&H00000002
Public Const LINETRANSLATERESULT_LONGDISTANCE        =&H00000004
Public Const LINETRANSLATERESULT_LOCAL               =&H00000008
Public Const LINETRANSLATERESULT_INTOLLLIST          =&H00000010
Public Const LINETRANSLATERESULT_NOTINTOLLLIST       =&H00000020
Public Const LINETRANSLATERESULT_DIALBILLING         =&H00000040
Public Const LINETRANSLATERESULT_DIALQUIET           =&H00000080
Public Const LINETRANSLATERESULT_DIALDIALTONE        =&H00000100
Public Const LINETRANSLATERESULT_DIALPROMPT          =&H00000200
Public Const LINETRANSLATERESULT_VOICEDETECT         =&H00000400

Public Const PHONEBUTTONFUNCTION_UNKNOWN             =&H00000000
Public Const PHONEBUTTONFUNCTION_CONFERENCE          =&H00000001
Public Const PHONEBUTTONFUNCTION_TRANSFER            =&H00000002
Public Const PHONEBUTTONFUNCTION_DROP                =&H00000003
Public Const PHONEBUTTONFUNCTION_HOLD                =&H00000004
Public Const PHONEBUTTONFUNCTION_RECALL              =&H00000005
Public Const PHONEBUTTONFUNCTION_DISCONNECT          =&H00000006
Public Const PHONEBUTTONFUNCTION_CONNECT             =&H00000007
Public Const PHONEBUTTONFUNCTION_MSGWAITON           =&H00000008
Public Const PHONEBUTTONFUNCTION_MSGWAITOFF          =&H00000009
Public Const PHONEBUTTONFUNCTION_SELECTRING          =&H0000000A
Public Const PHONEBUTTONFUNCTION_ABBREVDIAL          =&H0000000B
Public Const PHONEBUTTONFUNCTION_FORWARD             =&H0000000C
Public Const PHONEBUTTONFUNCTION_PICKUP              =&H0000000D
Public Const PHONEBUTTONFUNCTION_RINGAGAIN           =&H0000000E
Public Const PHONEBUTTONFUNCTION_PARK                =&H0000000F
Public Const PHONEBUTTONFUNCTION_REJECT              =&H00000010
Public Const PHONEBUTTONFUNCTION_REDIRECT            =&H00000011
Public Const PHONEBUTTONFUNCTION_MUTE                =&H00000012
Public Const PHONEBUTTONFUNCTION_VOLUMEUP            =&H00000013
Public Const PHONEBUTTONFUNCTION_VOLUMEDOWN          =&H00000014
Public Const PHONEBUTTONFUNCTION_SPEAKERON           =&H00000015
Public Const PHONEBUTTONFUNCTION_SPEAKEROFF          =&H00000016
Public Const PHONEBUTTONFUNCTION_FLASH               =&H00000017
Public Const PHONEBUTTONFUNCTION_DATAON              =&H00000018
Public Const PHONEBUTTONFUNCTION_DATAOFF             =&H00000019
Public Const PHONEBUTTONFUNCTION_DONOTDISTURB        =&H0000001A
Public Const PHONEBUTTONFUNCTION_INTERCOM            =&H0000001B
Public Const PHONEBUTTONFUNCTION_BRIDGEDAPP          =&H0000001C
Public Const PHONEBUTTONFUNCTION_BUSY                =&H0000001D
Public Const PHONEBUTTONFUNCTION_CALLAPP             =&H0000001E
Public Const PHONEBUTTONFUNCTION_DATETIME            =&H0000001F
Public Const PHONEBUTTONFUNCTION_DIRECTORY           =&H00000020
Public Const PHONEBUTTONFUNCTION_COVER               =&H00000021
Public Const PHONEBUTTONFUNCTION_CALLID              =&H00000022
Public Const PHONEBUTTONFUNCTION_LASTNUM             =&H00000023
Public Const PHONEBUTTONFUNCTION_NIGHTSRV            =&H00000024
Public Const PHONEBUTTONFUNCTION_SENDCALLS           =&H00000025
Public Const PHONEBUTTONFUNCTION_MSGINDICATOR        =&H00000026
Public Const PHONEBUTTONFUNCTION_REPDIAL             =&H00000027
Public Const PHONEBUTTONFUNCTION_SETREPDIAL          =&H00000028
Public Const PHONEBUTTONFUNCTION_SYSTEMSPEED         =&H00000029
Public Const PHONEBUTTONFUNCTION_STATIONSPEED        =&H0000002A
Public Const PHONEBUTTONFUNCTION_CAMPON              =&H0000002B
Public Const PHONEBUTTONFUNCTION_SAVEREPEAT          =&H0000002C
Public Const PHONEBUTTONFUNCTION_QUEUECALL           =&H0000002D
Public Const PHONEBUTTONFUNCTION_NONE                =&H0000002E

Public Const PHONEBUTTONMODE_DUMMY                   =&H00000001
Public Const PHONEBUTTONMODE_CALL                    =&H00000002
Public Const PHONEBUTTONMODE_FEATURE                 =&H00000004
Public Const PHONEBUTTONMODE_KEYPAD                  =&H00000008
Public Const PHONEBUTTONMODE_LOCAL                   =&H00000010
Public Const PHONEBUTTONMODE_DISPLAY                 =&H00000020

Public Const PHONEBUTTONSTATE_UP                     =&H00000001
Public Const PHONEBUTTONSTATE_DOWN                   =&H00000002
Public Const PHONEBUTTONSTATE_UNKNOWN                =&H00000004
Public Const PHONEBUTTONSTATE_UNAVAIL                =&H00000008

Public Const PHONEERR_ALLOCATED                      =&H90000001
Public Const PHONEERR_BADDEVICEID                    =&H90000002
Public Const PHONEERR_INCOMPATIBLEAPIVERSION         =&H90000003
Public Const PHONEERR_INCOMPATIBLEEXTVERSION         =&H90000004
Public Const PHONEERR_INIFILECORRUPT                 =&H90000005
Public Const PHONEERR_INUSE                          =&H90000006
Public Const PHONEERR_INVALAPPHANDLE                 =&H90000007
Public Const PHONEERR_INVALAPPNAME                   =&H90000008
Public Const PHONEERR_INVALBUTTONLAMPID              =&H90000009
Public Const PHONEERR_INVALBUTTONMODE                =&H9000000A
Public Const PHONEERR_INVALBUTTONSTATE               =&H9000000B
Public Const PHONEERR_INVALDATAID                    =&H9000000C
Public Const PHONEERR_INVALDEVICECLASS               =&H9000000D
Public Const PHONEERR_INVALEXTVERSION                =&H9000000E
Public Const PHONEERR_INVALHOOKSWITCHDEV             =&H9000000F
Public Const PHONEERR_INVALHOOKSWITCHMODE            =&H90000010
Public Const PHONEERR_INVALLAMPMODE                  =&H90000011
Public Const PHONEERR_INVALPARAM                     =&H90000012
Public Const PHONEERR_INVALPHONEHANDLE               =&H90000013
Public Const PHONEERR_INVALPHONESTATE                =&H90000014
Public Const PHONEERR_INVALPOINTER                   =&H90000015
Public Const PHONEERR_INVALPRIVILEGE                 =&H90000016
Public Const PHONEERR_INVALRINGMODE                  =&H90000017
Public Const PHONEERR_NODEVICE                       =&H90000018
Public Const PHONEERR_NODRIVER                       =&H90000019
Public Const PHONEERR_NOMEM                          =&H9000001A
Public Const PHONEERR_NOTOWNER                       =&H9000001B
Public Const PHONEERR_OPERATIONFAILED                =&H9000001C
Public Const PHONEERR_OPERATIONUNAVAIL               =&H9000001D
Public Const PHONEERR_RESOURCEUNAVAIL                =&H9000001F
Public Const PHONEERR_REQUESTOVERRUN                 =&H90000020
Public Const PHONEERR_STRUCTURETOOSMALL              =&H90000021
Public Const PHONEERR_UNINITIALIZED                  =&H90000022
Public Const PHONEERR_REINIT                         =&H90000023
Public Const PHONEERR_DISCONNECTED                   =&H90000024
Public Const PHONEERR_LASTERRORVALUE                 =&H90000024


Public Const PHONEFEATURE_GETBUTTONINFO              =&H00000001
Public Const PHONEFEATURE_GETDATA                    =&H00000002
Public Const PHONEFEATURE_GETDISPLAY                 =&H00000004
Public Const PHONEFEATURE_GETGAINHANDSET             =&H00000008
Public Const PHONEFEATURE_GETGAINSPEAKER             =&H00000010
Public Const PHONEFEATURE_GETGAINHEADSET             =&H00000020
Public Const PHONEFEATURE_GETHOOKSWITCHHANDSET       =&H00000040
Public Const PHONEFEATURE_GETHOOKSWITCHSPEAKER       =&H00000080
Public Const PHONEFEATURE_GETHOOKSWITCHHEADSET       =&H00000100
Public Const PHONEFEATURE_GETLAMP                    =&H00000200
Public Const PHONEFEATURE_GETRING                    =&H00000400
Public Const PHONEFEATURE_GETVOLUMEHANDSET           =&H00000800
Public Const PHONEFEATURE_GETVOLUMESPEAKER           =&H00001000
Public Const PHONEFEATURE_GETVOLUMEHEADSET           =&H00002000
Public Const PHONEFEATURE_SETBUTTONINFO              =&H00004000
Public Const PHONEFEATURE_SETDATA                    =&H00008000
Public Const PHONEFEATURE_SETDISPLAY                 =&H00010000
Public Const PHONEFEATURE_SETGAINHANDSET             =&H00020000
Public Const PHONEFEATURE_SETGAINSPEAKER             =&H00040000
Public Const PHONEFEATURE_SETGAINHEADSET             =&H00080000
Public Const PHONEFEATURE_SETHOOKSWITCHHANDSET       =&H00100000
Public Const PHONEFEATURE_SETHOOKSWITCHSPEAKER       =&H00200000
Public Const PHONEFEATURE_SETHOOKSWITCHHEADSET       =&H00400000
Public Const PHONEFEATURE_SETLAMP                    =&H00800000
Public Const PHONEFEATURE_SETRING                    =&H01000000
Public Const PHONEFEATURE_SETVOLUMEHANDSET           =&H02000000
Public Const PHONEFEATURE_SETVOLUMESPEAKER           =&H04000000
Public Const PHONEFEATURE_SETVOLUMEHEADSET           =&H08000000

Public Const PHONEHOOKSWITCHDEV_HANDSET              =&H00000001
Public Const PHONEHOOKSWITCHDEV_SPEAKER              =&H00000002
Public Const PHONEHOOKSWITCHDEV_HEADSET              =&H00000004

Public Const PHONEHOOKSWITCHMODE_ONHOOK              =&H00000001
Public Const PHONEHOOKSWITCHMODE_MIC                 =&H00000002
Public Const PHONEHOOKSWITCHMODE_SPEAKER             =&H00000004
Public Const PHONEHOOKSWITCHMODE_MICSPEAKER          =&H00000008
Public Const PHONEHOOKSWITCHMODE_UNKNOWN             =&H00000010

Public Const PHONEINITIALIZEEXOPTION_USEHIDDENWINDOW     =&H00000001
Public Const PHONEINITIALIZEEXOPTION_USEEVENT            =&H00000002
Public Const PHONEINITIALIZEEXOPTION_USECOMPLETIONPORT   =&H00000003

Public Const PHONELAMPMODE_DUMMY                     =&H00000001
Public Const PHONELAMPMODE_OFF                       =&H00000002
Public Const PHONELAMPMODE_STEADY                    =&H00000004
Public Const PHONELAMPMODE_WINK                      =&H00000008
Public Const PHONELAMPMODE_FLASH                     =&H00000010
Public Const PHONELAMPMODE_FLUTTER                   =&H00000020
Public Const PHONELAMPMODE_BROKENFLUTTER             =&H00000040
Public Const PHONELAMPMODE_UNKNOWN                   =&H00000080

Public Const PHONEPRIVILEGE_MONITOR                  =&H00000001
Public Const PHONEPRIVILEGE_OWNER                    =&H00000002

Public Const PHONESTATE_OTHER                        =&H00000001
Public Const PHONESTATE_CONNECTED                    =&H00000002
Public Const PHONESTATE_DISCONNECTED                 =&H00000004
Public Const PHONESTATE_OWNER                        =&H00000008
Public Const PHONESTATE_MONITORS                     =&H00000010
Public Const PHONESTATE_DISPLAY                      =&H00000020
Public Const PHONESTATE_LAMP                         =&H00000040
Public Const PHONESTATE_RINGMODE                     =&H00000080
Public Const PHONESTATE_RINGVOLUME                   =&H00000100
Public Const PHONESTATE_HANDSETHOOKSWITCH            =&H00000200
Public Const PHONESTATE_HANDSETVOLUME                =&H00000400
Public Const PHONESTATE_HANDSETGAIN                  =&H00000800
Public Const PHONESTATE_SPEAKERHOOKSWITCH            =&H00001000
Public Const PHONESTATE_SPEAKERVOLUME                =&H00002000
Public Const PHONESTATE_SPEAKERGAIN                  =&H00004000
Public Const PHONESTATE_HEADSETHOOKSWITCH            =&H00008000
Public Const PHONESTATE_HEADSETVOLUME                =&H00010000
Public Const PHONESTATE_HEADSETGAIN                  =&H00020000
Public Const PHONESTATE_SUSPEND                      =&H00040000
Public Const PHONESTATE_RESUME                       =&H00080000
Public Const PHONESTATE_DEVSPECIFIC                  =&H00100000
Public Const PHONESTATE_REINIT                       =&H00200000
Public Const PHONESTATE_CAPSCHANGE                   =&H00400000
Public Const PHONESTATE_REMOVED                      =&H00800000

Public Const PHONESTATUSFLAGS_CONNECTED              =&H00000001
Public Const PHONESTATUSFLAGS_SUSPENDED              =&H00000002

Public Const STRINGFORMAT_ASCII                      =&H00000001
Public Const STRINGFORMAT_DBCS                       =&H00000002
Public Const STRINGFORMAT_UNICODE                    =&H00000003
Public Const STRINGFORMAT_BINARY                     =&H00000004

Public Const TAPI_E_NOTENOUGHMEMORY                  =&H80040001
Public Const TAPI_E_NOITEMS                          =&H80040002
Public Const TAPI_E_NOTSUPPORTED                     =&H80040003
Public Const TAPI_E_INVALIDMEDIATYPE                 =&H80040004
Public Const TAPI_E_OPERATIONFAILED                  =&H80040005
Public Const TAPI_E_ALLOCATED                        =&H80040006
Public Const TAPI_E_CALLUNAVAIL                      =&H80040007
Public Const TAPI_E_COMPLETIONOVERRUN                =&H80040008
Public Const TAPI_E_CONFERENCEFULL                   =&H80040009
Public Const TAPI_E_DIALMODIFIERNOTSUPPORTED         =&H8004000A
Public Const TAPI_E_INUSE                            =&H8004000B
Public Const TAPI_E_INVALADDRESS                     =&H8004000C
Public Const TAPI_E_INVALADDRESSSTATE                =&H8004000D
Public Const TAPI_E_INVALCALLPARAMS                  =&H8004000E
Public Const TAPI_E_INVALCALLPRIVILEGE               =&H8004000F
Public Const TAPI_E_INVALCALLSTATE                   =&H80040010
Public Const TAPI_E_INVALCARD                        =&H80040011
Public Const TAPI_E_INVALCOMPLETIONID                =&H80040012
Public Const TAPI_E_INVALCOUNTRYCODE                 =&H80040013
Public Const TAPI_E_INVALDEVICECLASS                 =&H80040014
Public Const TAPI_E_INVALDIALPARAMS                  =&H80040015
Public Const TAPI_E_INVALDIGITS                      =&H80040016
Public Const TAPI_E_INVALGROUPID                     =&H80040017
Public Const TAPI_E_INVALLOCATION                    =&H80040018
Public Const TAPI_E_INVALMESSAGEID                   =&H80040019
Public Const TAPI_E_INVALPARKID                      =&H8004001A
Public Const TAPI_E_INVALRATE                        =&H8004001B
Public Const TAPI_E_INVALTIMEOUT                     =&H8004001C
Public Const TAPI_E_INVALTONE                        =&H8004001D
Public Const TAPI_E_INVALLIST                        =&H8004001E
Public Const TAPI_E_INVALMODE                        =&H8004001F
Public Const TAPI_E_NOCONFERENCE                     =&H80040020
Public Const TAPI_E_NODEVICE                         =&H80040021
Public Const TAPI_E_NOREQUEST                        =&H80040022
Public Const TAPI_E_NOTOWNER                         =&H80040023
Public Const TAPI_E_NOTREGISTERED                    =&H80040024
Public Const TAPI_E_REQUESTOVERRUN                   =&H80040025
Public Const TAPI_E_TARGETNOTFOUND                   =&H80040026
Public Const TAPI_E_TARGETSELF                       =&H80040027
Public Const TAPI_E_USERUSERINFOTOOBIG               =&H80040028
Public Const TAPI_E_REINIT                           =&H80040029
Public Const TAPI_E_ADDRESSBLOCKED                   =&H8004002A
Public Const TAPI_E_BILLINGREJECTED                  =&H8004002B
Public Const TAPI_E_INVALFEATURE                     =&H8004002C
Public Const TAPI_E_INVALBUTTONLAMPID                =&H8004002D
Public Const TAPI_E_INVALBUTTONSTATE                 =&H8004002E
Public Const TAPI_E_INVALDATAID                      =&H8004002F
Public Const TAPI_E_INVALHOOKSWITCHDEV               =&H80040030
Public Const TAPI_E_DROPPED                          =&H80040031
Public Const TAPI_E_NOREQUESTRECIPIENT               =&H80040032
Public Const TAPI_E_REQUESTQUEUEFULL                 =&H80040033
Public Const TAPI_E_DESTBUSY                         =&H80040034
Public Const TAPI_E_DESTNOANSWER                     =&H80040035
Public Const TAPI_E_DESTUNAVAIL                      =&H80040036
Public Const TAPI_E_REQUESTFAILED                    =&H80040037
Public Const TAPI_E_REQUESTCANCELLED                 =&H80040038
Public Const TAPI_E_INVALPRIVILEGE                   =&H80040039
Public Const TAPI_E_INVALIDDIRECTION                 =&H8004003A
Public Const TAPI_E_INVALIDTERMINAL                  =&H8004003B
Public Const TAPI_E_INVALIDTERMINALCLASS             =&H8004003C
Public Const TAPI_E_NODRIVER                         =&H8004003D
Public Const TAPI_E_MAXSTREAMS                       =&H8004003E
Public Const TAPI_E_NOTERMINALSELECTED               =&H8004003F
Public Const TAPI_E_TERMINALINUSE                    =&H80040040
Public Const TAPI_E_NOTSTOPPED                       =&H80040041
Public Const TAPI_E_MAXTERMINALS                     =&H80040042
Public Const TAPI_E_INVALIDSTREAM                    =&H80040043
Public Const TAPI_E_TIMEOUT                          =&H80040044
Public Const TAPI_E_CALLCENTER_GROUP_REMOVED         =&H80040045
Public Const TAPI_E_CALLCENTER_QUEUE_REMOVED         =&H80040046
Public Const TAPI_E_CALLCENTER_NO_AGENT_ID           =&H80040047
Public Const TAPI_E_CALLCENTER_INVALAGENTID          =&H80040048
Public Const TAPI_E_CALLCENTER_INVALAGENTGROUP       =&H80040049
Public Const TAPI_E_CALLCENTER_INVALPASSWORD         =&H8004004A
Public Const TAPI_E_CALLCENTER_INVALAGENTSTATE       =&H8004004B
Public Const TAPI_E_CALLCENTER_INVALAGENTACTIVITY    =&H8004004C
Public Const TAPI_E_REGISTRY_SETTING_CORRUPT         =&H8004004D
Public Const TAPI_E_TERMINAL_PEER                    =&H8004004E
Public Const TAPI_E_PEER_NOT_SET                     =&H8004004F
Public Const TAPI_E_NOEVENT                          =&H80040050
Public Const TAPI_E_INVALADDRESSTYPE                 =&H80040051
Public Const TAPI_E_RESOURCEUNAVAIL                  =&H80040052
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test2\blob.txt ===
<><v=0
o=qhuai 0 0 IN IP4 157.55.89.115
s=BridgeTestConf1
c=IN IP4 239.9.20.26/15
t=0 0
m=video 20000 RTP/AVP 34 31
m=audio 20040 RTP/AVP 0 4
><v=0
o=qhuai 0 0 IN IP4 157.55.89.115
s=BridgeTestConf2
c=IN IP4 239.9.20.26/15
t=0 0
m=video 20000 RTP/AVP 34 31
m=audio 20040 RTP/AVP 3
>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\apis\iphlpapi\dll\calltree.txt ===
CompareIfRow        
CompareIpAddrRow    
CompareTcpRow       
CompareUdpRow       
CompareIpNetRow     
CompareIpForwardRow 
GetIfNumber         
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              GetIpStatsFromStack 
              IsRouterRunning     
GetIfTable          
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              GetIfTableFromStack 
              IsRouterRunning     
              GetIfNumber         
GetIpAddrTable      
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              GetIpAddrTableFromStack
              IsRouterRunning     
              GetIpStatistics     
GetIpNetTable       
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              GetArpEntryCount    
              GetIpNetTableFromStack
              IsRouterRunning     
GetIpForwardTable   
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              GetIpForwardTableFromStack
              IsRouterRunning     
              GetIpStatistics     
GetTcpTable         
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              GetTcpTableFromStack
              IsRouterRunning     
              GetTcpStatistics    
GetUdpTable         
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              GetUdpTableFromStack
              IsRouterRunning     
              GetUdpStatistics    
GetIpStatistics     
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              GetIpStatsFromStack 
              IsRouterRunning     
GetIcmpStatistics   
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              GetIcmpStatsFromStack
              IsRouterRunning     
GetTcpStatistics    
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              GetTcpStatsFromStack
              IsRouterRunning     
GetUdpStatistics    
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              GetUdpStatsFromStack
              IsRouterRunning     
SetIfEntry          
              InternalSetIfEntry  
CreateIpForwardEntry
              InternalCreateIpForwardEntry
SetIpForwardEntry   
              InternalSetIpForwardEntry
DeleteIpForwardEntry
              InternalDeleteIpForwardEntry
SetIpStatistics     
              InternalSetIpStats  
CreateIpNetEntry    
              InternalCreateIpNetEntry
SetIpNetEntry       
              InternalSetIpNetEntry
DeleteIpNetEntry    
              InternalDeleteIpNetEntry
SetTcpEntry         
              InternalSetTcpEntry 
InitAdapterMappingTable
StoreAdapterToATInstanceMap
              InsertAdapterMap    
              LookUpAdapterMap    
StoreAdapterToIFInstanceMap
              InsertAdapterMap    
              LookUpAdapterMap    
GetIFInstanceFromAdapter
              LookUpAdapterMap    
GetATInstanceFromAdapter
              LookUpAdapterMap    
LookUpAdapterMap    
InsertAdapterMap    
UpdateAdapterToIFInstanceMapping
              TCPQueryInformationEx
              GetIpStatsFromStack 
              StoreAdapterToIFInstanceMap
UpdateAdapterToATInstanceMapping
              TCPQueryInformationEx
              AllocateAndGetArpEntTableFromStack
              StoreAdapterToATInstanceMap
InternalGetIfTable  
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              AllocateAndGetIfTableFromStack
              IsRouterRunning     
InternalGetIpAddrTable
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              AllocateAndGetIpAddrTableFromStack
              IsRouterRunning     
InternalGetIpNetTable
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              AllocateAndGetIpNetTableFromStack
              IsRouterRunning     
InternalGetIpForwardTable
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              AllocateAndGetIpForwardTableFromStack
              IsRouterRunning     
InternalGetTcpTable 
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              AllocateAndGetTcpTableFromStack
              IsRouterRunning     
InternalGetUdpTable 
              MprAdminMIBEntryGet 
              MprAdminMIBBufferFree
              AllocateAndGetUdpTableFromStack
              IsRouterRunning     
InternalSetIfEntry  
              MprAdminMIBEntrySet 
              SetIfEntryToStack   
              IsRouterRunning     
InternalCreateIpForwardEntry
              MprAdminMIBEntryCreate
              SetIpForwardEntryToStack
              IsRouterRunning     
InternalSetIpForwardEntry
              MprAdminMIBEntrySet 
              SetIpForwardEntryToStack
              IsRouterRunning     
InternalDeleteIpForwardEntry
              MprAdminMIBEntryDelete
              SetIpForwardEntryToStack
              IsRouterRunning     
InternalSetIpStats  
              MprAdminMIBEntrySet 
              SetIpStatsToStack   
              IsRouterRunning     
InternalCreateIpNetEntry
              MprAdminMIBEntryCreate
              SetIpNetEntryToStack
              IsRouterRunning     
InternalSetIpNetEntry
              MprAdminMIBEntrySet 
              SetIpNetEntryToStack
              IsRouterRunning     
InternalDeleteIpNetEntry
              MprAdminMIBEntryDelete
              SetIpNetEntryToStack
              IsRouterRunning     
InternalSetTcpEntry 
              MprAdminMIBEntrySet 
              SetTcpEntryToStack  
              IsRouterRunning     
OpenAdapterKey      
ReadRegistryDword   
GetAdapterIPInterfaceContext
              ReadRegistryDword   
              OpenAdapterKey      
GetAdapterIndex     
              AllocateAndGetIpAddrTableFromStack
              GetAdapterIPInterfaceContext
AddIPAddress        
              TCPSendIoctl        
DeleteIPAddress     
              TCPSendIoctl        
GetRTT              
              IcmpCreateFile      
              IcmpSendEcho        
              IcmpCloseHandle     
GetHopCounts        
              IcmpCreateFile      
              IcmpSendEcho        
              IcmpCloseHandle     
IsLocalAddress      
              AllocateAndGetIpAddrTableFromStack
AddArpEntry         
              SetIpNetEntryToStack
DeleteArpEntry      
              SetIpNetEntryToStack
NotifyAddrChange    
              TCPSendIoctl        
NotifyRouteChange   
              TCPSendIoctl        
IpReleaseAddress    
              DhcpReleaseParameters
IpRenewAddress      
              DhcpAcquireParameters
IpHlpDllEntry       
              MprAdminMIBServerDisconnect
              CloseTCPDriver      
              OpenTCPDriver       
              UpdateAdapterToATInstanceMapping
              UpdateAdapterToIFInstanceMapping
              InitAdapterMappingTable
IsRouterRunning     
              MprAdminMIBServerConnect
AllocateAndGetIfTableFromStack
              GetIpStatsFromStack 
              GetIfTableFromStack 
              UpdateAdapterToIFInstanceMapping
GetIfTableFromStack 
              AccessIfEntryInStack
SetIfEntryToStack   
              AccessIfEntryInStack
              UpdateAdapterToIFInstanceMapping
              GetIFInstanceFromAdapter
AccessIfEntryInStack
              TCPSetInformationEx 
              TCPQueryInformationEx
AllocateAndGetIpAddrTableFromStack
              GetIpStatsFromStack 
              GetIpAddrTableFromStack
GetIpAddrTableFromStack
              TCPQueryInformationEx
AllocateAndGetTcpTableFromStack
              GetTcpStatsFromStack
              GetTcpTableFromStack
GetTcpTableFromStack
              TCPQueryInformationEx
SetTcpEntryToStack  
              TCPSetInformationEx 
AllocateAndGetUdpTableFromStack
              GetUdpStatsFromStack
              GetUdpTableFromStack
GetUdpTableFromStack
              TCPQueryInformationEx
AllocateAndGetIpForwardTableFromStack
              GetIpStatsFromStack 
              GetIpForwardTableFromStack
GetIpForwardTableFromStack
              TCPQueryInformationEx
              GetIpStatsFromStack 
AllocateAndGetIpNetTableFromStack
              GetArpEntryCount    
              GetIpNetTableFromStack
              UpdateAdapterToATInstanceMapping
GetIpNetTableFromStack
              TCPQueryInformationEx
GetIpStatsFromStack 
              TCPQueryInformationEx
SetIpStatsToStack   
              TCPSetInformationEx 
GetIcmpStatsFromStack
              TCPQueryInformationEx
GetUdpStatsFromStack
              TCPQueryInformationEx
GetTcpStatsFromStack
              TCPQueryInformationEx
SetIpNetEntryToStack
              TCPSetInformationEx 
              UpdateAdapterToATInstanceMapping
              GetATInstanceFromAdapter
GetArpEntryCount    
              TCPQueryInformationEx
AllocateAndGetArpEntTableFromStack
              TCPQueryInformationEx
SetIpForwardEntryToStack
              SetIpRouteEntryToStack
SetIpRouteEntryToStack
              TCPSetInformationEx 
TCPQueryInformationEx
TCPSendIoctl        
TCPSetInformationEx 
OpenTCPDriver       
CloseTCPDriver      
MprAdminMIBBufferFree
MprAdminMIBEntryGet 
MprAdminMIBEntrySet 
MprAdminMIBEntryCreate
MprAdminMIBEntryDelete
MprAdminMIBServerDisconnect
MprAdminMIBServerConnect
IcmpCloseHandle     
IcmpSendEcho        
IcmpCreateFile      
DhcpReleaseParameters
DhcpAcquireParameters
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\apis\iphlpapi\dll\rfc1213.txt ===
Network Working Group									   K. McCloghrie
Request for Comments: 1213						Hughes LAN Systems, Inc.
Obsoletes: RFC 1158												 M. Rose
									   Performance Systems International
																 Editors
															  March 1991


		   Management Information Base for Network Management
					   of TCP/IP-based internets:
								 MIB-II

Status of this Memo

   This memo defines the second version of the Management Information
   Base (MIB-II) for use with network management protocols in TCP/IP-
   based internets.	 This RFC specifies an IAB standards track protocol
   for the Internet community, and requests discussion and suggestions
   for improvements.  Please refer to the current edition of the "IAB
   Official Protocol Standards" for the standardization state and status
   of this protocol.  Distribution of this memo is unlimited.

Table of Contents

   1. Abstract...............................................	 2
   2. Introduction ..........................................	 2
   3. Changes from RFC 1156 .................................	 3
   3.1 Deprecated Objects ...................................	 3
   3.2 Display Strings ......................................	 4
   3.3 Physical Addresses ...................................	 4
   3.4 The System Group .....................................	 5
   3.5 The Interfaces Group .................................	 5
   3.6 The Address Translation Group ........................	 6
   3.7 The IP Group .........................................	 6
   3.8 The ICMP Group .......................................	 7
   3.9 The TCP Group ........................................	 7
   3.10 The UDP Group .......................................	 7
   3.11 The EGP Group .......................................	 7
   3.12 The Transmission Group ..............................	 8
   3.13 The SNMP Group ......................................	 8
   3.14 Changes from RFC 1158 ................. .............	 9
   4. Objects ...............................................	10
   4.1 Format of Definitions ................................	10
   5. Overview ..............................................	10
   6. Definitions ...........................................	12
   6.1 Textual Conventions ..................................	12
   6.2 Groups in MIB-II .....................................	13
   6.3 The System Group .....................................	13


SNMP Working Group												[Page 1]

RFC 1213						 MIB-II						  March 1991


   6.4 The Interfaces Group .................................	16
   6.5 The Address Translation Group ........................	23
   6.6 The IP Group .........................................	26
   6.7 The ICMP Group .......................................	41
   6.8 The TCP Group ........................................	46
   6.9 The UDP Group ........................................	52
   6.10 The EGP Group .......................................	54
   6.11 The Transmission Group ..............................	60
   6.12 The SNMP Group ......................................	60
   7. Acknowledgements ......................................	67
   8. References ............................................	69
   9. Security Considerations ...............................	70
   10. Authors' Addresses ...................................	70

1.	Abstract

   This memo defines the second version of the Management Information
   Base (MIB-II) for use with network management protocols in TCP/IP-
   based internets.	 In particular, together with its companion memos
   which describe the structure of management information (RFC 1155)
   along with the network management protocol (RFC 1157) for TCP/IP-
   based internets, these documents provide a simple, workable
   architecture and system for managing TCP/IP-based internets and in
   particular the Internet community.

2.	Introduction

   As reported in RFC 1052, IAB Recommendations for the Development of
   Internet Network Management Standards [1], a two-prong strategy for
   network management of TCP/IP-based internets was undertaken.	 In the
   short-term, the Simple Network Management Protocol (SNMP) was to be
   used to manage nodes in the Internet community.	In the long-term,
   the use of the OSI network management framework was to be examined.
   Two documents were produced to define the management information: RFC
   1065, which defined the Structure of Management Information (SMI)
   [2], and RFC 1066, which defined the Management Information Base
   (MIB) [3].  Both of these documents were designed so as to be
   compatible with both the SNMP and the OSI network management
   framework.

   This strategy was quite successful in the short-term: Internet-based
   network management technology was fielded, by both the research and
   commercial communities, within a few months.	 As a result of this,
   portions of the Internet community became network manageable in a
   timely fashion.

   As reported in RFC 1109, Report of the Second Ad Hoc Network
   Management Review Group [4], the requirements of the SNMP and the OSI
   network management frameworks were more different than anticipated.
   As such, the requirement for compatibility between the SMI/MIB and
   both frameworks was suspended.  This action permitted the operational
   network management framework, the SNMP, to respond to new operational
   needs in the Internet community by producing this document.

   As such, the current network management framework for TCP/IP- based
   internets consists of: Structure and Identification of Management
   Information for TCP/IP-based internets, RFC 1155 [12], which
   describes how managed objects contained in the MIB are defined;
   Management Information Base for Network Management of TCP/IP-based
   internets: MIB-II, this memo, which describes the managed objects
   contained in the MIB (and supercedes RFC 1156 [13]); and, the Simple
   Network Management Protocol, RFC 1098 [5], which defines the protocol
   used to manage these objects.

3.	Changes from RFC 1156

   Features of this MIB include:

   (1)	incremental additions to reflect new operational
		requirements;

   (2)	upwards compatibility with the SMI/MIB and the SNMP;

   (3)	improved support for multi-protocol entities; and,

   (4)	textual clean-up of the MIB to improve clarity and
		readability.

   The objects defined in MIB-II have the OBJECT IDENTIFIER prefix:

	  mib-2		 OBJECT IDENTIFIER ::= { mgmt 1 }

   which is identical to the prefix used in MIB-I.

3.1.  Deprecated Objects

   In order to better prepare implementors for future changes in the
   MIB, a new term "deprecated" may be used when describing an object.
   A deprecated object in the MIB is one which must be supported, but
   one which will most likely be removed from the next version of the
   MIB (e.g., MIB-III).

   MIB-II marks one object as being deprecated:

	  atTable
   As a result of deprecating the atTable object, the entire Address
   Translation group is deprecated.

   Note that no functionality is lost with the deprecation of these
   objects: new objects providing equivalent or superior functionality
   are defined in MIB-II.

3.2.  Display Strings

   In the past, there have been misinterpretations of the MIB as to when
   a string of octets should contain printable characters, meant to be
   displayed to a human.  As a textual convention in the MIB, the
   datatype

	  DisplayString ::=
		  OCTET STRING

   is introduced.  A DisplayString is restricted to the NVT ASCII
   character set, as defined in pages 10-11 of [6].

   The following objects are now defined in terms of DisplayString:

	  sysDescr
	  ifDescr

   It should be noted that this change has no effect on either the
   syntax nor semantics of these objects.  The use of the DisplayString
   notation is merely an artifact of the explanatory method used in
   MIB-II and future MIBs.

   Further it should be noted that any object defined in terms of OCTET
   STRING may contain arbitrary binary data, in which each octet may
   take any value from 0 to 255 (decimal).

3.3.  Physical Addresses

   As a further, textual convention in the MIB, the datatype

	  PhysAddress ::=
		  OCTET STRING

   is introduced to represent media- or physical-level addresses.

   The following objects are now defined in terms of PhysAddress:

	  ifPhysAddress
	  atPhysAddress
	  ipNetToMediaPhysAddress
   It should be noted that this change has no effect on either the
   syntax nor semantics of these objects.  The use of the PhysAddress
   notation is merely an artifact of the explanatory method used in
   MIB-II and future MIBs.

3.4.  The System Group

   Four new objects are added to this group:

	  sysContact
	  sysName
	  sysLocation
	  sysServices

   These provide contact, administrative, location, and service
   information regarding the managed node.

3.5.  The Interfaces Group

   The definition of the ifNumber object was incorrect, as it required
   all interfaces to support IP.  (For example, devices without IP, such
   as MAC-layer bridges, could not be managed if this definition was
   strictly followed.)	The description of the ifNumber object is
   changed accordingly.

   The ifTable object was mistaken marked as read-write, it has been
   (correctly) re-designated as not-accessible.	 In addition, several
   new values have been added to the ifType column in the ifTable
   object:

	  ppp(23)
	  softwareLoopback(24)
	  eon(25)
	  ethernet-3Mbit(26)
	  nsip(27)
	  slip(28)
	  ultra(29)
	  ds3(30)
	  sip(31)
	  frame-relay(32)

   Finally, a new column has been added to the ifTable object:

	  ifSpecific

   which provides information about information specific to the media
   being used to realize the interface.

3.6.  The Address Translation Group

   In MIB-I this group contained a table which permitted mappings from
   network addresses (e.g., IP addresses) to physical addresses (e.g.,
   MAC addresses).	Experience has shown that efficient implementations
   of this table make two assumptions: a single network protocol
   environment, and mappings occur only from network address to physical
   address.

   The need to support multi-protocol nodes (e.g., those with both the
   IP and CLNP active), and the need to support the inverse mapping
   (e.g., for ES-IS), have invalidated both of these assumptions.  As
   such, the atTable object is declared deprecated.

   In order to meet both the multi-protocol and inverse mapping
   requirements, MIB-II and its successors will allocate up to two
   address translation tables inside each network protocol group.  That
   is, the IP group will contain one address translation table, for
   going from IP addresses to physical addresses.  Similarly, when a
   document defining MIB objects for the CLNP is produced (e.g., [7]),
   it will contain two tables, for mappings in both directions, as this
   is required for full functionality.

   It should be noted that the choice of two tables (one for each
   direction of mapping) provides for ease of implementation in many
   cases, and does not introduce undue burden on implementations which
   realize the address translation abstraction through a single internal
   table.

3.7.  The IP Group

   The access attribute of the variable ipForwarding has been changed
   from read-only to read-write.

   In addition, there is a new column to the ipAddrTable object,

	  ipAdEntReasmMaxSize

   which keeps track of the largest IP datagram that can be re-assembled
   on a particular interface.

   The descriptor of the ipRoutingTable object has been changed to
   ipRouteTable for consistency with the other IP routing objects.
   There are also three new columns in the ipRouteTable object,

	  ipRouteMask
	  ipRouteMetric5
	  ipRouteInfo
   the first is used for IP routing subsystems that support arbitrary
   subnet masks, and the latter two are IP routing protocol-specific.

   Two new objects are added to the IP group:

	  ipNetToMediaTable
	  ipRoutingDiscards

   the first is the address translation table for the IP group
   (providing identical functionality to the now deprecated atTable in
   the address translation group), and the latter provides information
   when routes are lost due to a lack of buffer space.

3.8.  The ICMP Group

   There are no changes to this group.

3.9.  The TCP Group

   Two new variables are added:

	  tcpInErrs
	  tcpOutRsts

   which keep track of the number of incoming TCP segments in error and
   the number of resets generated by a TCP.

3.10.  The UDP Group

   A new table:

	  udpTable

   is added.

3.11.  The EGP Group

   Experience has indicated a need for additional objects that are
   useful in EGP monitoring.  In addition to making several additions to
   the egpNeighborTable object, i.e.,

	  egpNeighAs
	  egpNeighInMsgs
	  egpNeighInErrs
	  egpNeighOutMsgs
	  egpNeighOutErrs
	  egpNeighInErrMsgs
	  egpNeighOutErrMsgs
	  egpNeighStateUps
	  egpNeighStateDowns
	  egpNeighIntervalHello
	  egpNeighIntervalPoll
	  egpNeighMode
	  egpNeighEventTrigger

   a new variable is added:

	  egpAs

   which gives the autonomous system associated with this EGP entity.

3.12.  The Transmission Group

   MIB-I was lacking in that it did not distinguish between different
   types of transmission media.	 A new group, the Transmission group, is
   allocated for this purpose:

	  transmission OBJECT IDENTIFIER ::= { mib-2 10 }

   When Internet-standard definitions for managing transmission media
   are defined, the transmission group is used to provide a prefix for
   the names of those objects.

   Typically, such definitions reside in the experimental portion of the
   MIB until they are "proven", then as a part of the Internet
   standardization process, the definitions are accordingly elevated and
   a new object identifier, under the transmission group is defined.  By
   convention, the name assigned is:

	  type OBJECT IDENTIFIER ::= { transmission number }

   where "type" is the symbolic value used for the media in the ifType
   column of the ifTable object, and "number" is the actual integer
   value corresponding to the symbol.

3.13.  The SNMP Group

   The application-oriented working groups of the IETF have been tasked
   to be receptive towards defining MIB variables specific to their
   respective applications.

   For the SNMP, it is useful to have statistical information.	A new
   group, the SNMP group, is allocated for this purpose:

	  snmp	 OBJECT IDENTIFIER ::= { mib-2 11 }
3.14.  Changes from RFC 1158

   Features of this MIB include:

   (1)	The managed objects in this document have been defined
		using the conventions defined in the Internet-standard
		SMI, as amended by the extensions specified in [14].  It
		must be emphasized that definitions made using these
		extensions are semantically identically to those in RFC
		1158.

   (2)	The PhysAddress textual convention has been introduced to
		represent media addresses.

   (3)	The ACCESS clause of sysLocation is now read-write.

   (4)	The definition of sysServices has been clarified.

   (5)	New ifType values (29-32) have been defined.  In
		addition, the textual-descriptor for the DS1 and E1
		interface types has been corrected.

   (6)	The definition of ipForwarding has been clarified.

   (7)	The definition of ipRouteType has been clarified.

   (8)	The ipRouteMetric5 and ipRouteInfo objects have been
		defined.

   (9)	The ACCESS clause of tcpConnState is now read-write, to
		support deletion of the TCB associated with a TCP
		connection.	 The definition of this object has been
		clarified to explain this usage.

   (10) The definition of egpNeighEventTrigger has been
		clarified.

   (11) The definition of several of the variables in the new
		snmp group have been clarified.	 In addition, the
		snmpInBadTypes and snmpOutReadOnlys objects are no longer
		present.  (However, the object identifiers associated
		with those objects are reserved to prevent future use.)

   (12) The definition of snmpInReadOnlys has been clarified.

   (13) The textual descriptor of the snmpEnableAuthTraps has
		been changed to snmpEnableAuthenTraps, and the definition
		has been clarified.
   (14) The ipRoutingDiscards object was added.

   (15) The optional use of an implementation-dependent, small
		positive integer was disallowed when identifying
		instances of the IP address and routing tables.

4.	Objects

   Managed objects are accessed via a virtual information store, termed
   the Management Information Base or MIB.	Objects in the MIB are
   defined using the subset of Abstract Syntax Notation One (ASN.1) [8]
   defined in the SMI.	In particular, each object has a name, a syntax,
   and an encoding.	 The name is an object identifier, an
   administratively assigned name, which specifies an object type.	The
   object type together with an object instance serves to uniquely
   identify a specific instantiation of the object.	 For human
   convenience, we often use a textual string, termed the OBJECT
   DESCRIPTOR, to also refer to the object type.

   The syntax of an object type defines the abstract data structure
   corresponding to that object type.  The ASN.1 language is used for
   this purpose.  However, the SMI [12] purposely restricts the ASN.1
   constructs which may be used.  These restrictions are explicitly made
   for simplicity.

   The encoding of an object type is simply how that object type is
   represented using the object type's syntax.	Implicitly tied to the
   notion of an object type's syntax and encoding is how the object type
   is represented when being transmitted on the network.

   The SMI specifies the use of the basic encoding rules of ASN.1 [9],
   subject to the additional requirements imposed by the SNMP.

4.1.  Format of Definitions

   Section 6 contains contains the specification of all object types
   contained in this MIB module.  The object types are defined using the
   conventions defined in the SMI, as amended by the extensions
   specified in [14].

5.	Overview

   Consistent with the IAB directive to produce simple, workable systems
   in the short-term, the list of managed objects defined here, has been
   derived by taking only those elements which are considered essential.

   This approach of taking only the essential objects is NOT
   restrictive, since the SMI defined in the companion memo provides
   three extensibility mechanisms: one, the addition of new standard
   objects through the definitions of new versions of the MIB; two, the
   addition of widely-available but non-standard objects through the
   experimental subtree; and three, the addition of private objects
   through the enterprises subtree.	 Such additional objects can not
   only be used for vendor-specific elements, but also for
   experimentation as required to further the knowledge of which other
   objects are essential.

   The design of MIB-II is heavily influenced by the first extensibility
   mechanism.  Several new variables have been added based on
   operational experience and need.	 Based on this, the criteria for
   including an object in MIB-II are remarkably similar to the MIB-I
   criteria:

   (1)	An object needed to be essential for either fault or
		configuration management.

   (2)	Only weak control objects were permitted (by weak, it is
		meant that tampering with them can do only limited
		damage).  This criterion reflects the fact that the
		current management protocols are not sufficiently secure
		to do more powerful control operations.

   (3)	Evidence of current use and utility was required.

   (4)	In MIB-I, an attempt was made to limit the number of
		objects to about 100 to make it easier for vendors to
		fully instrument their software.  In MIB-II, this limit
		was raised given the wide technological base now
		implementing MIB-I.

   (5)	To avoid redundant variables, it was required that no
		object be included that can be derived from others in the
		MIB.

   (6)	Implementation specific objects (e.g., for BSD UNIX) were
		excluded.

   (7)	It was agreed to avoid heavily instrumenting critical
		sections of code.  The general guideline was one counter
		per critical section per layer.

   MIB-II, like its predecessor, the Internet-standard MIB, contains
   only essential elements.	 There is no need to allow individual
   objects to be optional.	Rather, the objects are arranged into the
   following groups:
	  - System
	  - Interfaces
	  - Address Translation (deprecated)
	  - IP
	  - ICMP
	  - TCP
	  - UDP
	  - EGP
	  - Transmission
	  - SNMP

   These groups are the basic unit of conformance: This method is as
   follows: if the semantics of a group is applicable to an
   implementation, then it must implement all objects in that group.
   For example, an implementation must implement the EGP group if and
   only if it implements the EGP.

   There are two reasons for defining these groups: to provide a means
   of assigning object identifiers; and, to provide a method for
   implementations of managed agents to know which objects they must
   implement.

6.	Definitions

		  RFC1213-MIB DEFINITIONS ::= BEGIN

		  IMPORTS
				  mgmt, NetworkAddress, IpAddress, Counter, Gauge,
						  TimeTicks
					  FROM RFC1155-SMI
				  OBJECT-TYPE
						  FROM RFC-1212;

		  --  This MIB module uses the extended OBJECT-TYPE macro as
		  --  defined in [14];


		  --  MIB-II (same prefix as MIB-I)

		  mib-2		 OBJECT IDENTIFIER ::= { mgmt 1 }

		  -- textual conventions

		  DisplayString ::=
			  OCTET STRING
		  -- This data type is used to model textual information taken
		  -- from the NVT ASCII character set.	By convention, objects
		  -- with this syntax are declared as having
		  --
		  --	  SIZE (0..255)

		  PhysAddress ::=
			  OCTET STRING
		  -- This data type is used to model media addresses.  For many
		  -- types of media, this will be in a binary representation.
		  -- For example, an ethernet address would be represented as
		  -- a string of 6 octets.


		  -- groups in MIB-II

		  system	   OBJECT IDENTIFIER ::= { mib-2 1 }

		  interfaces   OBJECT IDENTIFIER ::= { mib-2 2 }

		  at		   OBJECT IDENTIFIER ::= { mib-2 3 }

		  ip		   OBJECT IDENTIFIER ::= { mib-2 4 }

		  icmp		   OBJECT IDENTIFIER ::= { mib-2 5 }

		  tcp		   OBJECT IDENTIFIER ::= { mib-2 6 }

		  udp		   OBJECT IDENTIFIER ::= { mib-2 7 }

		  egp		   OBJECT IDENTIFIER ::= { mib-2 8 }

		  -- historical (some say hysterical)
		  -- cmot	   OBJECT IDENTIFIER ::= { mib-2 9 }

		  transmission OBJECT IDENTIFIER ::= { mib-2 10 }

		  snmp		   OBJECT IDENTIFIER ::= { mib-2 11 }


		  -- the System group

		  -- Implementation of the System group is mandatory for all
		  -- systems.  If an agent is not configured to have a value
		  -- for any of these variables, a string of length 0 is
		  -- returned.

		  sysDescr OBJECT-TYPE
			  SYNTAX  DisplayString (SIZE (0..255))
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "A textual description of the entity.	 This value
					  should include the full name and version
					  identification of the system's hardware type,
					  software operating-system, and networking
					  software.	 It is mandatory that this only contain
					  printable ASCII characters."
			  ::= { system 1 }

		  sysObjectID OBJECT-TYPE
			  SYNTAX  OBJECT IDENTIFIER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The vendor's authoritative identification of the
					  network management subsystem contained in the
					  entity.  This value is allocated within the SMI
					  enterprises subtree (1.3.6.1.4.1) and provides an
					  easy and unambiguous means for determining `what
					  kind of box' is being managed.  For example, if
					  vendor `Flintstones, Inc.' was assigned the
					  subtree 1.3.6.1.4.1.4242, it could assign the
					  identifier 1.3.6.1.4.1.4242.1.1 to its `Fred
					  Router'."
			  ::= { system 2 }

		  sysUpTime OBJECT-TYPE
			  SYNTAX  TimeTicks
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The time (in hundredths of a second) since the
					  network management portion of the system was last
					  re-initialized."
			  ::= { system 3 }

		  sysContact OBJECT-TYPE
			  SYNTAX  DisplayString (SIZE (0..255))
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The textual identification of the contact person
					  for this managed node, together with information
					  on how to contact this person."
			  ::= { system 4 }

		  sysName OBJECT-TYPE
			  SYNTAX  DisplayString (SIZE (0..255))
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "An administratively-assigned name for this
					  managed node.	 By convention, this is the node's
					  fully-qualified domain name."
			  ::= { system 5 }

		  sysLocation OBJECT-TYPE
			  SYNTAX  DisplayString (SIZE (0..255))
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The physical location of this node (e.g.,
					  `telephone closet, 3rd floor')."
			  ::= { system 6 }

		  sysServices OBJECT-TYPE
			  SYNTAX  INTEGER (0..127)
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "A value which indicates the set of services that
					  this entity primarily offers.

					  The value is a sum.  This sum initially takes the
					  value zero, Then, for each layer, L, in the range
					  1 through 7, that this node performs transactions
					  for, 2 raised to (L - 1) is added to the sum.	 For
					  example, a node which performs primarily routing
					  functions would have a value of 4 (2^(3-1)).	In
					  contrast, a node which is a host offering
					  application services would have a value of 72
					  (2^(4-1) + 2^(7-1)).	Note that in the context of
					  the Internet suite of protocols, values should be
					  calculated accordingly:

						   layer  functionality
							   1  physical (e.g., repeaters)
							   2  datalink/subnetwork (e.g., bridges)
							   3  internet (e.g., IP gateways)
							   4  end-to-end  (e.g., IP hosts)
							   7  applications (e.g., mail relays)

					  For systems including OSI protocols, layers 5 and
					  6 may also be counted."
			  ::= { system 7 }
		  -- the Interfaces group

		  -- Implementation of the Interfaces group is mandatory for
		  -- all systems.

		  ifNumber OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of network interfaces (regardless of
					  their current state) present on this system."
			  ::= { interfaces 1 }


		  -- the Interfaces table

		  -- The Interfaces table contains information on the entity's
		  -- interfaces.  Each interface is thought of as being
		  -- attached to a `subnetwork'.  Note that this term should
		  -- not be confused with `subnet' which refers to an
		  -- addressing partitioning scheme used in the Internet suite
		  -- of protocols.

		  ifTable OBJECT-TYPE
			  SYNTAX  SEQUENCE OF IfEntry
			  ACCESS  not-accessible
			  STATUS  mandatory
			  DESCRIPTION
					  "A list of interface entries.	 The number of
					  entries is given by the value of ifNumber."
			  ::= { interfaces 2 }

		  ifEntry OBJECT-TYPE
			  SYNTAX  IfEntry
			  ACCESS  not-accessible
			  STATUS  mandatory
			  DESCRIPTION
					  "An interface entry containing objects at the
					  subnetwork layer and below for a particular
					  interface."
			  INDEX	  { ifIndex }
			  ::= { ifTable 1 }

		  IfEntry ::=
			  SEQUENCE {
				  ifIndex
					  INTEGER,
				  ifDescr
					  DisplayString,
				  ifType
					  INTEGER,
				  ifMtu
					  INTEGER,
				  ifSpeed
					  Gauge,
				  ifPhysAddress
					  PhysAddress,
				  ifAdminStatus
					  INTEGER,
				  ifOperStatus
					  INTEGER,
				  ifLastChange
					  TimeTicks,
				  ifInOctets
					  Counter,
				  ifInUcastPkts
					  Counter,
				  ifInNUcastPkts
					  Counter,
				  ifInDiscards
					  Counter,
				  ifInErrors
					  Counter,
				  ifInUnknownProtos
					  Counter,
				  ifOutOctets
					  Counter,
				  ifOutUcastPkts
					  Counter,
				  ifOutNUcastPkts
					  Counter,
				  ifOutDiscards
					  Counter,
				  ifOutErrors
					  Counter,
				  ifOutQLen
					  Gauge,
				  ifSpecific
					  OBJECT IDENTIFIER
			  }

		  ifIndex OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "A unique value for each interface.  Its value
					  ranges between 1 and the value of ifNumber.  The
					  value for each interface must remain constant at
					  least from one re-initialization of the entity's
					  network management system to the next re-
					  initialization."
			  ::= { ifEntry 1 }

		  ifDescr OBJECT-TYPE
			  SYNTAX  DisplayString (SIZE (0..255))
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "A textual string containing information about the
					  interface.  This string should include the name of
					  the manufacturer, the product name and the version
					  of the hardware interface."
			  ::= { ifEntry 2 }

		  ifType OBJECT-TYPE
			  SYNTAX  INTEGER {
						  other(1),			 -- none of the following
						  regular1822(2),
						  hdh1822(3),
						  ddn-x25(4),
						  rfc877-x25(5),
						  ethernet-csmacd(6),
						  iso88023-csmacd(7),
						  iso88024-tokenBus(8),
						  iso88025-tokenRing(9),
						  iso88026-man(10),
						  starLan(11),
						  proteon-10Mbit(12),
						  proteon-80Mbit(13),
						  hyperchannel(14),
						  fddi(15),
						  lapb(16),
						  sdlc(17),
						  ds1(18),			 -- T-1
						  e1(19),			 -- european equiv. of T-1
						  basicISDN(20),
						  primaryISDN(21),	 -- proprietary serial
						  propPointToPointSerial(22),
						  ppp(23),
						  softwareLoopback(24),
						  eon(25),			  -- CLNP over IP [11]
						  ethernet-3Mbit(26),
						  nsip(27),			  -- XNS over IP
						  slip(28),			  -- generic SLIP
						  ultra(29),		  -- ULTRA technologies
						  ds3(30),			  -- T-3
						  sip(31),			  -- SMDS
						  frame-relay(32)
					  }
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The type of interface, distinguished according to
					  the physical/link protocol(s) immediately `below'
					  the network layer in the protocol stack."
			  ::= { ifEntry 3 }

		  ifMtu OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The size of the largest datagram which can be
					  sent/received on the interface, specified in
					  octets.  For interfaces that are used for
					  transmitting network datagrams, this is the size
					  of the largest network datagram that can be sent
					  on the interface."
			  ::= { ifEntry 4 }

		  ifSpeed OBJECT-TYPE
			  SYNTAX  Gauge
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "An estimate of the interface's current bandwidth
					  in bits per second.  For interfaces which do not
					  vary in bandwidth or for those where no accurate
					  estimation can be made, this object should contain
					  the nominal bandwidth."
			  ::= { ifEntry 5 }

		  ifPhysAddress OBJECT-TYPE
			  SYNTAX  PhysAddress
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The interface's address at the protocol layer
					  immediately `below' the network layer in the
					  protocol stack.  For interfaces which do not have
					  such an address (e.g., a serial line), this object
					  should contain an octet string of zero length."
			  ::= { ifEntry 6 }

		  ifAdminStatus OBJECT-TYPE
			  SYNTAX  INTEGER {
						  up(1),	   -- ready to pass packets
						  down(2),
						  testing(3)   -- in some test mode
					  }
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The desired state of the interface.	The
					  testing(3) state indicates that no operational
					  packets can be passed."
			  ::= { ifEntry 7 }

		  ifOperStatus OBJECT-TYPE
			  SYNTAX  INTEGER {
						  up(1),	   -- ready to pass packets
						  down(2),
						  testing(3)   -- in some test mode
					  }
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The current operational state of the interface.
					  The testing(3) state indicates that no operational
					  packets can be passed."
			  ::= { ifEntry 8 }

		  ifLastChange OBJECT-TYPE
			  SYNTAX  TimeTicks
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The value of sysUpTime at the time the interface
					  entered its current operational state.  If the
					  current state was entered prior to the last re-
					  initialization of the local network management
					  subsystem, then this object contains a zero
					  value."
			  ::= { ifEntry 9 }

		  ifInOctets OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of octets received on the
					  interface, including framing characters."
			  ::= { ifEntry 10 }

		  ifInUcastPkts OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of subnetwork-unicast packets
					  delivered to a higher-layer protocol."
			  ::= { ifEntry 11 }

		  ifInNUcastPkts OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of non-unicast (i.e., subnetwork-
					  broadcast or subnetwork-multicast) packets
					  delivered to a higher-layer protocol."
			  ::= { ifEntry 12 }

		  ifInDiscards OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of inbound packets which were chosen
					  to be discarded even though no errors had been
					  detected to prevent their being deliverable to a
					  higher-layer protocol.  One possible reason for
					  discarding such a packet could be to free up
					  buffer space."
			  ::= { ifEntry 13 }

		  ifInErrors OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of inbound packets that contained
					  errors preventing them from being deliverable to a
					  higher-layer protocol."
			  ::= { ifEntry 14 }
		  ifInUnknownProtos OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of packets received via the interface
					  which were discarded because of an unknown or
					  unsupported protocol."
			  ::= { ifEntry 15 }

		  ifOutOctets OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of octets transmitted out of the
					  interface, including framing characters."
			  ::= { ifEntry 16 }

		  ifOutUcastPkts OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of packets that higher-level
					  protocols requested be transmitted to a
					  subnetwork-unicast address, including those that
					  were discarded or not sent."
			  ::= { ifEntry 17 }

		  ifOutNUcastPkts OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of packets that higher-level
					  protocols requested be transmitted to a non-
					  unicast (i.e., a subnetwork-broadcast or
					  subnetwork-multicast) address, including those
					  that were discarded or not sent."
			  ::= { ifEntry 18 }

		  ifOutDiscards OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of outbound packets which were chosen
					  to be discarded even though no errors had been
					  detected to prevent their being transmitted.	One
					  possible reason for discarding such a packet could
					  be to free up buffer space."
			  ::= { ifEntry 19 }

		  ifOutErrors OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of outbound packets that could not be
					  transmitted because of errors."
			  ::= { ifEntry 20 }

		  ifOutQLen OBJECT-TYPE
			  SYNTAX  Gauge
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The length of the output packet queue (in
					  packets)."
			  ::= { ifEntry 21 }

		  ifSpecific OBJECT-TYPE
			  SYNTAX  OBJECT IDENTIFIER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "A reference to MIB definitions specific to the
					  particular media being used to realize the
					  interface.  For example, if the interface is
					  realized by an ethernet, then the value of this
					  object refers to a document defining objects
					  specific to ethernet.	 If this information is not
					  present, its value should be set to the OBJECT
					  IDENTIFIER { 0 0 }, which is a syntatically valid
					  object identifier, and any conformant
					  implementation of ASN.1 and BER must be able to
					  generate and recognize this value."
			  ::= { ifEntry 22 }


		  -- the Address Translation group

		  -- Implementation of the Address Translation group is
		  -- mandatory for all systems.	 Note however that this group
		  -- is deprecated by MIB-II. That is, it is being included
		  -- solely for compatibility with MIB-I nodes, and will most
		  -- likely be excluded from MIB-III nodes.	 From MIB-II and
		  -- onwards, each network protocol group contains its own
		  -- address translation tables.

		  -- The Address Translation group contains one table which is
		  -- the union across all interfaces of the translation tables
		  -- for converting a NetworkAddress (e.g., an IP address) into
		  -- a subnetwork-specific address.	 For lack of a better term,
		  -- this document refers to such a subnetwork-specific address
		  -- as a `physical' address.

		  -- Examples of such translation tables are: for broadcast
		  -- media where ARP is in use, the translation table is
		  -- equivalent to the ARP cache; or, on an X.25 network where
		  -- non-algorithmic translation to X.121 addresses is
		  -- required, the translation table contains the
		  -- NetworkAddress to X.121 address equivalences.

		  atTable OBJECT-TYPE
			  SYNTAX  SEQUENCE OF AtEntry
			  ACCESS  not-accessible
			  STATUS  deprecated
			  DESCRIPTION
					  "The Address Translation tables contain the
					  NetworkAddress to `physical' address equivalences.
					  Some interfaces do not use translation tables for
					  determining address equivalences (e.g., DDN-X.25
					  has an algorithmic method); if all interfaces are
					  of this type, then the Address Translation table
					  is empty, i.e., has zero entries."
			  ::= { at 1 }

		  atEntry OBJECT-TYPE
			  SYNTAX  AtEntry
			  ACCESS  not-accessible
			  STATUS  deprecated
			  DESCRIPTION
					  "Each entry contains one NetworkAddress to
					  `physical' address equivalence."
			  INDEX	  { atIfIndex,
						atNetAddress }
			  ::= { atTable 1 }

		  AtEntry ::=
			  SEQUENCE {
				  atIfIndex
					  INTEGER,
				  atPhysAddress
					  PhysAddress,
				  atNetAddress
					  NetworkAddress
			  }

		  atIfIndex OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-write
			  STATUS  deprecated
			  DESCRIPTION
					  "The interface on which this entry's equivalence
					  is effective.	 The interface identified by a
					  particular value of this index is the same
					  interface as identified by the same value of
					  ifIndex."
			  ::= { atEntry 1 }

		  atPhysAddress OBJECT-TYPE
			  SYNTAX  PhysAddress
			  ACCESS  read-write
			  STATUS  deprecated
			  DESCRIPTION
					  "The media-dependent `physical' address.

					  Setting this object to a null string (one of zero
					  length) has the effect of invaliding the
					  corresponding entry in the atTable object.  That
					  is, it effectively dissasociates the interface
					  identified with said entry from the mapping
					  identified with said entry.  It is an
					  implementation-specific matter as to whether the
					  agent removes an invalidated entry from the table.
					  Accordingly, management stations must be prepared
					  to receive tabular information from agents that
					  corresponds to entries not currently in use.
					  Proper interpretation of such entries requires
					  examination of the relevant atPhysAddress object."
			  ::= { atEntry 2 }

		  atNetAddress OBJECT-TYPE
			  SYNTAX  NetworkAddress
			  ACCESS  read-write
			  STATUS  deprecated
			  DESCRIPTION
					  "The NetworkAddress (e.g., the IP address)
					  corresponding to the media-dependent `physical'
					  address."
			  ::= { atEntry 3 }


		  -- the IP group

		  -- Implementation of the IP group is mandatory for all
		  -- systems.

		  ipForwarding OBJECT-TYPE
			  SYNTAX  INTEGER {
						  forwarding(1),	-- acting as a gateway
						  not-forwarding(2) -- NOT acting as a gateway
					  }
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The indication of whether this entity is acting
					  as an IP gateway in respect to the forwarding of
					  datagrams received by, but not addressed to, this
					  entity.  IP gateways forward datagrams.  IP hosts
					  do not (except those source-routed via the host).

					  Note that for some managed nodes, this object may
					  take on only a subset of the values possible.
					  Accordingly, it is appropriate for an agent to
					  return a `badValue' response if a management
					  station attempts to change this object to an
					  inappropriate value."
			  ::= { ip 1 }

		  ipDefaultTTL OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The default value inserted into the Time-To-Live
					  field of the IP header of datagrams originated at
					  this entity, whenever a TTL value is not supplied
					  by the transport layer protocol."
			  ::= { ip 2 }

		  ipInReceives OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of input datagrams received from
					  interfaces, including those received in error."
			  ::= { ip 3 }

		  ipInHdrErrors OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of input datagrams discarded due to
					  errors in their IP headers, including bad
					  checksums, version number mismatch, other format
					  errors, time-to-live exceeded, errors discovered
					  in processing their IP options, etc."
			  ::= { ip 4 }

		  ipInAddrErrors OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of input datagrams discarded because
					  the IP address in their IP header's destination
					  field was not a valid address to be received at
					  this entity.	This count includes invalid
					  addresses (e.g., 0.0.0.0) and addresses of
					  unsupported Classes (e.g., Class E).	For entities
					  which are not IP Gateways and therefore do not
					  forward datagrams, this counter includes datagrams
					  discarded because the destination address was not
					  a local address."
			  ::= { ip 5 }

		  ipForwDatagrams OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of input datagrams for which this
					  entity was not their final IP destination, as a
					  result of which an attempt was made to find a
					  route to forward them to that final destination.
					  In entities which do not act as IP Gateways, this
					  counter will include only those packets which were
					  Source-Routed via this entity, and the Source-
					  Route option processing was successful."
			  ::= { ip 6 }

		  ipInUnknownProtos OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of locally-addressed datagrams
					  received successfully but discarded because of an
					  unknown or unsupported protocol."
			  ::= { ip 7 }

		  ipInDiscards OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of input IP datagrams for which no
					  problems were encountered to prevent their
					  continued processing, but which were discarded
					  (e.g., for lack of buffer space).	 Note that this
					  counter does not include any datagrams discarded
					  while awaiting re-assembly."
			  ::= { ip 8 }

		  ipInDelivers OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of input datagrams successfully
					  delivered to IP user-protocols (including ICMP)."
			  ::= { ip 9 }

		  ipOutRequests OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of IP datagrams which local IP
					  user-protocols (including ICMP) supplied to IP in
					  requests for transmission.  Note that this counter
					  does not include any datagrams counted in
					  ipForwDatagrams."
			  ::= { ip 10 }

		  ipOutDiscards OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of output IP datagrams for which no
					  problem was encountered to prevent their
					  transmission to their destination, but which were
					  discarded (e.g., for lack of buffer space).  Note
					  that this counter would include datagrams counted
					  in ipForwDatagrams if any such packets met this
					  (discretionary) discard criterion."
			  ::= { ip 11 }

		  ipOutNoRoutes OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of IP datagrams discarded because no
					  route could be found to transmit them to their
					  destination.	Note that this counter includes any
					  packets counted in ipForwDatagrams which meet this
					  `no-route' criterion.	 Note that this includes any
					  datagarms which a host cannot route because all of
					  its default gateways are down."
			  ::= { ip 12 }

		  ipReasmTimeout OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The maximum number of seconds which received
					  fragments are held while they are awaiting
					  reassembly at this entity."
			  ::= { ip 13 }

		  ipReasmReqds OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of IP fragments received which needed
					  to be reassembled at this entity."
			  ::= { ip 14 }

		  ipReasmOKs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of IP datagrams successfully re-
					  assembled."
			  ::= { ip 15 }

		  ipReasmFails OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of failures detected by the IP re-
					  assembly algorithm (for whatever reason: timed
					  out, errors, etc).  Note that this is not
					  necessarily a count of discarded IP fragments
					  since some algorithms (notably the algorithm in
					  RFC 815) can lose track of the number of fragments
					  by combining them as they are received."
			  ::= { ip 16 }

		  ipFragOKs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of IP datagrams that have been
					  successfully fragmented at this entity."
			  ::= { ip 17 }

		  ipFragFails OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of IP datagrams that have been
					  discarded because they needed to be fragmented at
					  this entity but could not be, e.g., because their
					  Don't Fragment flag was set."
			  ::= { ip 18 }

		  ipFragCreates OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of IP datagram fragments that have
					  been generated as a result of fragmentation at
					  this entity."
			  ::= { ip 19 }
		  -- the IP address table

		  -- The IP address table contains this entity's IP addressing
		  -- information.

		  ipAddrTable OBJECT-TYPE
			  SYNTAX  SEQUENCE OF IpAddrEntry
			  ACCESS  not-accessible
			  STATUS  mandatory
			  DESCRIPTION
					  "The table of addressing information relevant to
					  this entity's IP addresses."
			  ::= { ip 20 }

		  ipAddrEntry OBJECT-TYPE
			  SYNTAX  IpAddrEntry
			  ACCESS  not-accessible
			  STATUS  mandatory
			  DESCRIPTION
					  "The addressing information for one of this
					  entity's IP addresses."
			  INDEX	  { ipAdEntAddr }
			  ::= { ipAddrTable 1 }

		  IpAddrEntry ::=
			  SEQUENCE {
				  ipAdEntAddr
					  IpAddress,
				  ipAdEntIfIndex
					  INTEGER,
				  ipAdEntNetMask
					  IpAddress,
				  ipAdEntBcastAddr
					  INTEGER,
				  ipAdEntReasmMaxSize
					  INTEGER (0..65535)
			  }

		  ipAdEntAddr OBJECT-TYPE
			  SYNTAX  IpAddress
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The IP address to which this entry's addressing
					  information pertains."
			  ::= { ipAddrEntry 1 }
		  ipAdEntIfIndex OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The index value which uniquely identifies the
					  interface to which this entry is applicable.	The
					  interface identified by a particular value of this
					  index is the same interface as identified by the
					  same value of ifIndex."
			  ::= { ipAddrEntry 2 }

		  ipAdEntNetMask OBJECT-TYPE
			  SYNTAX  IpAddress
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The subnet mask associated with the IP address of
					  this entry.  The value of the mask is an IP
					  address with all the network bits set to 1 and all
					  the hosts bits set to 0."
			  ::= { ipAddrEntry 3 }

		  ipAdEntBcastAddr OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The value of the least-significant bit in the IP
					  broadcast address used for sending datagrams on
					  the (logical) interface associated with the IP
					  address of this entry.  For example, when the
					  Internet standard all-ones broadcast address is
					  used, the value will be 1.  This value applies to
					  both the subnet and network broadcasts addresses
					  used by the entity on this (logical) interface."
			  ::= { ipAddrEntry 4 }

		  ipAdEntReasmMaxSize OBJECT-TYPE
			  SYNTAX  INTEGER (0..65535)
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The size of the largest IP datagram which this
					  entity can re-assemble from incoming IP fragmented
					  datagrams received on this interface."
			  ::= { ipAddrEntry 5 }
		  -- the IP routing table

		  -- The IP routing table contains an entry for each route
		  -- presently known to this entity.

		  ipRouteTable OBJECT-TYPE
			  SYNTAX  SEQUENCE OF IpRouteEntry
			  ACCESS  not-accessible
			  STATUS  mandatory
			  DESCRIPTION
					  "This entity's IP Routing table."
			  ::= { ip 21 }

		  ipRouteEntry OBJECT-TYPE
			  SYNTAX  IpRouteEntry
			  ACCESS  not-accessible
			  STATUS  mandatory
			  DESCRIPTION
					  "A route to a particular destination."
			  INDEX	  { ipRouteDest }
			  ::= { ipRouteTable 1 }

		  IpRouteEntry ::=
			  SEQUENCE {
				  ipRouteDest
					  IpAddress,
				  ipRouteIfIndex
					  INTEGER,
				  ipRouteMetric1
					  INTEGER,
				  ipRouteMetric2
					  INTEGER,
				  ipRouteMetric3
					  INTEGER,
				  ipRouteMetric4
					  INTEGER,
				  ipRouteNextHop
					  IpAddress,
				  ipRouteType
					  INTEGER,
				  ipRouteProto
					  INTEGER,
				  ipRouteAge
					  INTEGER,
				  ipRouteMask
					  IpAddress,
				  ipRouteMetric5
					  INTEGER,
				  ipRouteInfo
					  OBJECT IDENTIFIER
			  }

		  ipRouteDest OBJECT-TYPE
			  SYNTAX  IpAddress
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The destination IP address of this route.  An
					  entry with a value of 0.0.0.0 is considered a
					  default route.  Multiple routes to a single
					  destination can appear in the table, but access to
					  such multiple entries is dependent on the table-
					  access mechanisms defined by the network
					  management protocol in use."
			  ::= { ipRouteEntry 1 }

		  ipRouteIfIndex OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The index value which uniquely identifies the
					  local interface through which the next hop of this
					  route should be reached.	The interface identified
					  by a particular value of this index is the same
					  interface as identified by the same value of
					  ifIndex."
			  ::= { ipRouteEntry 2 }

		  ipRouteMetric1 OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The primary routing metric for this route.  The
					  semantics of this metric are determined by the
					  routing-protocol specified in the route's
					  ipRouteProto value.  If this metric is not used,
					  its value should be set to -1."
			  ::= { ipRouteEntry 3 }

		  ipRouteMetric2 OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "An alternate routing metric for this route.	The
					  semantics of this metric are determined by the
					  routing-protocol specified in the route's
					  ipRouteProto value.  If this metric is not used,
					  its value should be set to -1."
			  ::= { ipRouteEntry 4 }

		  ipRouteMetric3 OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "An alternate routing metric for this route.	The
					  semantics of this metric are determined by the
					  routing-protocol specified in the route's
					  ipRouteProto value.  If this metric is not used,
					  its value should be set to -1."
			  ::= { ipRouteEntry 5 }

		  ipRouteMetric4 OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "An alternate routing metric for this route.	The
					  semantics of this metric are determined by the
					  routing-protocol specified in the route's
					  ipRouteProto value.  If this metric is not used,
					  its value should be set to -1."
			  ::= { ipRouteEntry 6 }

		  ipRouteNextHop OBJECT-TYPE
			  SYNTAX  IpAddress
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The IP address of the next hop of this route.
					  (In the case of a route bound to an interface
					  which is realized via a broadcast media, the value
					  of this field is the agent's IP address on that
					  interface.)"
			  ::= { ipRouteEntry 7 }

		  ipRouteType OBJECT-TYPE
			  SYNTAX  INTEGER {
						  other(1),		   -- none of the following

						  invalid(2),	   -- an invalidated route
										   -- route to directly
						  direct(3),	   -- connected (sub-)network

										   -- route to a non-local
						  indirect(4)	   -- host/network/sub-network
					  }
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The type of route.  Note that the values
					  direct(3) and indirect(4) refer to the notion of
					  direct and indirect routing in the IP
					  architecture.

					  Setting this object to the value invalid(2) has
					  the effect of invalidating the corresponding entry
					  in the ipRouteTable object.  That is, it
					  effectively dissasociates the destination
					  identified with said entry from the route
					  identified with said entry.  It is an
					  implementation-specific matter as to whether the
					  agent removes an invalidated entry from the table.
					  Accordingly, management stations must be prepared
					  to receive tabular information from agents that
					  corresponds to entries not currently in use.
					  Proper interpretation of such entries requires
					  examination of the relevant ipRouteType object."
			  ::= { ipRouteEntry 8 }

		  ipRouteProto OBJECT-TYPE
			  SYNTAX  INTEGER {
						  other(1),		  -- none of the following

										  -- non-protocol information,
										  -- e.g., manually configured
						  local(2),		  -- entries

										  -- set via a network
						  netmgmt(3),	  -- management protocol

										  -- obtained via ICMP,
						  icmp(4),		  -- e.g., Redirect

										  -- the remaining values are
										  -- all gateway routing
										  -- protocols
						  egp(5),
						  ggp(6),
						  hello(7),
						  rip(8),
						  is-is(9),
						  es-is(10),
						  ciscoIgrp(11),
						  bbnSpfIgp(12),
						  ospf(13),
						  bgp(14)
					  }
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The routing mechanism via which this route was
					  learned.	Inclusion of values for gateway routing
					  protocols is not intended to imply that hosts
					  should support those protocols."
			  ::= { ipRouteEntry 9 }

		  ipRouteAge OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of seconds since this route was last
					  updated or otherwise determined to be correct.
					  Note that no semantics of `too old' can be implied
					  except through knowledge of the routing protocol
					  by which the route was learned."
			  ::= { ipRouteEntry 10 }

		  ipRouteMask OBJECT-TYPE
			  SYNTAX  IpAddress
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "Indicate the mask to be logical-ANDed with the
					  destination address before being compared to the
					  value in the ipRouteDest field.  For those systems
					  that do not support arbitrary subnet masks, an
					  agent constructs the value of the ipRouteMask by
					  determining whether the value of the correspondent
					  ipRouteDest field belong to a class-A, B, or C
					  network, and then using one of:

						   mask			  network
						   255.0.0.0	  class-A
						   255.255.0.0	  class-B
						   255.255.255.0  class-C
					  If the value of the ipRouteDest is 0.0.0.0 (a
					  default route), then the mask value is also
					  0.0.0.0.	It should be noted that all IP routing
					  subsystems implicitly use this mechanism."
			  ::= { ipRouteEntry 11 }

		  ipRouteMetric5 OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "An alternate routing metric for this route.	The
					  semantics of this metric are determined by the
					  routing-protocol specified in the route's
					  ipRouteProto value.  If this metric is not used,
					  its value should be set to -1."
			  ::= { ipRouteEntry 12 }

		  ipRouteInfo OBJECT-TYPE
			  SYNTAX  OBJECT IDENTIFIER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "A reference to MIB definitions specific to the
					  particular routing protocol which is responsible
					  for this route, as determined by the value
					  specified in the route's ipRouteProto value.	If
					  this information is not present, its value should
					  be set to the OBJECT IDENTIFIER { 0 0 }, which is
					  a syntatically valid object identifier, and any
					  conformant implementation of ASN.1 and BER must be
					  able to generate and recognize this value."
			  ::= { ipRouteEntry 13 }


		  -- the IP Address Translation table

		  -- The IP address translation table contain the IpAddress to
		  -- `physical' address equivalences.  Some interfaces do not
		  -- use translation tables for determining address
		  -- equivalences (e.g., DDN-X.25 has an algorithmic method);
		  -- if all interfaces are of this type, then the Address
		  -- Translation table is empty, i.e., has zero entries.

		  ipNetToMediaTable OBJECT-TYPE
			  SYNTAX  SEQUENCE OF IpNetToMediaEntry
			  ACCESS  not-accessible
			  STATUS  mandatory
			  DESCRIPTION
					  "The IP Address Translation table used for mapping
					  from IP addresses to physical addresses."
			  ::= { ip 22 }

		  ipNetToMediaEntry OBJECT-TYPE
			  SYNTAX  IpNetToMediaEntry
			  ACCESS  not-accessible
			  STATUS  mandatory
			  DESCRIPTION
					  "Each entry contains one IpAddress to `physical'
					  address equivalence."
			  INDEX	  { ipNetToMediaIfIndex,
						ipNetToMediaNetAddress }
			  ::= { ipNetToMediaTable 1 }

		  IpNetToMediaEntry ::=
			  SEQUENCE {
				  ipNetToMediaIfIndex
					  INTEGER,
				  ipNetToMediaPhysAddress
					  PhysAddress,
				  ipNetToMediaNetAddress
					  IpAddress,
				  ipNetToMediaType
					  INTEGER
			  }

		  ipNetToMediaIfIndex OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The interface on which this entry's equivalence
					  is effective.	 The interface identified by a
					  particular value of this index is the same
					  interface as identified by the same value of
					  ifIndex."
			  ::= { ipNetToMediaEntry 1 }

		  ipNetToMediaPhysAddress OBJECT-TYPE
			  SYNTAX  PhysAddress
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The media-dependent `physical' address."
			  ::= { ipNetToMediaEntry 2 }
		  ipNetToMediaNetAddress OBJECT-TYPE
			  SYNTAX  IpAddress
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The IpAddress corresponding to the media-
					  dependent `physical' address."
			  ::= { ipNetToMediaEntry 3 }

		  ipNetToMediaType OBJECT-TYPE
			  SYNTAX  INTEGER {
						  other(1),		   -- none of the following
						  invalid(2),	   -- an invalidated mapping
						  dynamic(3),
						  static(4)
					  }
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The type of mapping.

					  Setting this object to the value invalid(2) has
					  the effect of invalidating the corresponding entry
					  in the ipNetToMediaTable.	 That is, it effectively
					  dissasociates the interface identified with said
					  entry from the mapping identified with said entry.
					  It is an implementation-specific matter as to
					  whether the agent removes an invalidated entry
					  from the table.  Accordingly, management stations
					  must be prepared to receive tabular information
					  from agents that corresponds to entries not
					  currently in use.	 Proper interpretation of such
					  entries requires examination of the relevant
					  ipNetToMediaType object."
			  ::= { ipNetToMediaEntry 4 }


		  -- additional IP objects

		  ipRoutingDiscards OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of routing entries which were chosen
					  to be discarded even though they are valid.  One
					  possible reason for discarding such an entry could
					  be to free-up buffer space for other routing
					  entries."
			  ::= { ip 23 }


		  -- the ICMP group

		  -- Implementation of the ICMP group is mandatory for all
		  -- systems.

		  icmpInMsgs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of ICMP messages which the
					  entity received.	Note that this counter includes
					  all those counted by icmpInErrors."
			  ::= { icmp 1 }

		  icmpInErrors OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP messages which the entity
					  received but determined as having ICMP-specific
					  errors (bad ICMP checksums, bad length, etc.)."
			  ::= { icmp 2 }

		  icmpInDestUnreachs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Destination Unreachable
					  messages received."
			  ::= { icmp 3 }

		  icmpInTimeExcds OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Time Exceeded messages
					  received."
			  ::= { icmp 4 }
		  icmpInParmProbs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Parameter Problem messages
					  received."
			  ::= { icmp 5 }

		  icmpInSrcQuenchs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Source Quench messages
					  received."
			  ::= { icmp 6 }

		  icmpInRedirects OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Redirect messages received."
			  ::= { icmp 7 }

		  icmpInEchos OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Echo (request) messages
					  received."
			  ::= { icmp 8 }

		  icmpInEchoReps OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Echo Reply messages received."
			  ::= { icmp 9 }

		  icmpInTimestamps OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Timestamp (request) messages
					  received."
			  ::= { icmp 10 }

		  icmpInTimestampReps OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Timestamp Reply messages
					  received."
			  ::= { icmp 11 }

		  icmpInAddrMasks OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Address Mask Request messages
					  received."
			  ::= { icmp 12 }

		  icmpInAddrMaskReps OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Address Mask Reply messages
					  received."
			  ::= { icmp 13 }

		  icmpOutMsgs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of ICMP messages which this
					  entity attempted to send.	 Note that this counter
					  includes all those counted by icmpOutErrors."
			  ::= { icmp 14 }

		  icmpOutErrors OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP messages which this entity did
					  not send due to problems discovered within ICMP
					  such as a lack of buffers.  This value should not
					  include errors discovered outside the ICMP layer
					  such as the inability of IP to route the resultant
					  datagram.	 In some implementations there may be no
					  types of error which contribute to this counter's
					  value."
			  ::= { icmp 15 }

		  icmpOutDestUnreachs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Destination Unreachable
					  messages sent."
			  ::= { icmp 16 }

		  icmpOutTimeExcds OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Time Exceeded messages sent."
			  ::= { icmp 17 }

		  icmpOutParmProbs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Parameter Problem messages
					  sent."
			  ::= { icmp 18 }

		  icmpOutSrcQuenchs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Source Quench messages sent."
			  ::= { icmp 19 }

		  icmpOutRedirects OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Redirect messages sent.  For a
					  host, this object will always be zero, since hosts
					  do not send redirects."
			  ::= { icmp 20 }

		  icmpOutEchos OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Echo (request) messages sent."
			  ::= { icmp 21 }

		  icmpOutEchoReps OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Echo Reply messages sent."
			  ::= { icmp 22 }

		  icmpOutTimestamps OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Timestamp (request) messages
					  sent."
			  ::= { icmp 23 }

		  icmpOutTimestampReps OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Timestamp Reply messages
					  sent."
			  ::= { icmp 24 }

		  icmpOutAddrMasks OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Address Mask Request messages
					  sent."
			  ::= { icmp 25 }
		  icmpOutAddrMaskReps OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of ICMP Address Mask Reply messages
					  sent."
			  ::= { icmp 26 }


		  -- the TCP group

		  -- Implementation of the TCP group is mandatory for all
		  -- systems that implement the TCP.

		  -- Note that instances of object types that represent
		  -- information about a particular TCP connection are
		  -- transient; they persist only as long as the connection
		  -- in question.

		  tcpRtoAlgorithm OBJECT-TYPE
			  SYNTAX  INTEGER {
						  other(1),	   -- none of the following

						  constant(2), -- a constant rto
						  rsre(3),	   -- MIL-STD-1778, Appendix B
						  vanj(4)	   -- Van Jacobson's algorithm [10]
					  }
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The algorithm used to determine the timeout value
					  used for retransmitting unacknowledged octets."
			  ::= { tcp 1 }

		  tcpRtoMin OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The minimum value permitted by a TCP
					  implementation for the retransmission timeout,
					  measured in milliseconds.	 More refined semantics
					  for objects of this type depend upon the algorithm
					  used to determine the retransmission timeout.	 In
					  particular, when the timeout algorithm is rsre(3),
					  an object of this type has the semantics of the
					  LBOUND quantity described in RFC 793."
			  ::= { tcp 2 }


		  tcpRtoMax OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The maximum value permitted by a TCP
					  implementation for the retransmission timeout,
					  measured in milliseconds.	 More refined semantics
					  for objects of this type depend upon the algorithm
					  used to determine the retransmission timeout.	 In
					  particular, when the timeout algorithm is rsre(3),
					  an object of this type has the semantics of the
					  UBOUND quantity described in RFC 793."
			  ::= { tcp 3 }

		  tcpMaxConn OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The limit on the total number of TCP connections
					  the entity can support.  In entities where the
					  maximum number of connections is dynamic, this
					  object should contain the value -1."
			  ::= { tcp 4 }

		  tcpActiveOpens OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of times TCP connections have made a
					  direct transition to the SYN-SENT state from the
					  CLOSED state."
			  ::= { tcp 5 }

		  tcpPassiveOpens OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of times TCP connections have made a
					  direct transition to the SYN-RCVD state from the
					  LISTEN state."
			  ::= { tcp 6 }
		  tcpAttemptFails OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of times TCP connections have made a
					  direct transition to the CLOSED state from either
					  the SYN-SENT state or the SYN-RCVD state, plus the
					  number of times TCP connections have made a direct
					  transition to the LISTEN state from the SYN-RCVD
					  state."
			  ::= { tcp 7 }

		  tcpEstabResets OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of times TCP connections have made a
					  direct transition to the CLOSED state from either
					  the ESTABLISHED state or the CLOSE-WAIT state."
			  ::= { tcp 8 }

		  tcpCurrEstab OBJECT-TYPE
			  SYNTAX  Gauge
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of TCP connections for which the
					  current state is either ESTABLISHED or CLOSE-
					  WAIT."
			  ::= { tcp 9 }

		  tcpInSegs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of segments received, including
					  those received in error.	This count includes
					  segments received on currently established
					  connections."
			  ::= { tcp 10 }

		  tcpOutSegs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of segments sent, including
					  those on current connections but excluding those
					  containing only retransmitted octets."
			  ::= { tcp 11 }

		  tcpRetransSegs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of segments retransmitted - that
					  is, the number of TCP segments transmitted
					  containing one or more previously transmitted
					  octets."
			  ::= { tcp 12 }


		  -- the TCP Connection table

		  -- The TCP connection table contains information about this
		  -- entity's existing TCP connections.

		  tcpConnTable OBJECT-TYPE
			  SYNTAX  SEQUENCE OF TcpConnEntry
			  ACCESS  not-accessible
			  STATUS  mandatory
			  DESCRIPTION
					  "A table containing TCP connection-specific
					  information."
			  ::= { tcp 13 }

		  tcpConnEntry OBJECT-TYPE
			  SYNTAX  TcpConnEntry
			  ACCESS  not-accessible
			  STATUS  mandatory
			  DESCRIPTION
					  "Information about a particular current TCP
					  connection.  An object of this type is transient,
					  in that it ceases to exist when (or soon after)
					  the connection makes the transition to the CLOSED
					  state."
			  INDEX	  { tcpConnLocalAddress,
						tcpConnLocalPort,
						tcpConnRemAddress,
						tcpConnRemPort }
			  ::= { tcpConnTable 1 }
		  TcpConnEntry ::=
			  SEQUENCE {
				  tcpConnState
					  INTEGER,
				  tcpConnLocalAddress
					  IpAddress,
				  tcpConnLocalPort
					  INTEGER (0..65535),
				  tcpConnRemAddress
					  IpAddress,
				  tcpConnRemPort
					  INTEGER (0..65535)
			  }

		  tcpConnState OBJECT-TYPE
			  SYNTAX  INTEGER {
						  closed(1),
						  listen(2),
						  synSent(3),
						  synReceived(4),
						  established(5),
						  finWait1(6),
						  finWait2(7),
						  closeWait(8),
						  lastAck(9),
						  closing(10),
						  timeWait(11),
						  deleteTCB(12)
					  }
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "The state of this TCP connection.

					  The only value which may be set by a management
					  station is deleteTCB(12).	 Accordingly, it is
					  appropriate for an agent to return a `badValue'
					  response if a management station attempts to set
					  this object to any other value.

					  If a management station sets this object to the
					  value deleteTCB(12), then this has the effect of
					  deleting the TCB (as defined in RFC 793) of the
					  corresponding connection on the managed node,
					  resulting in immediate termination of the
					  connection.

					  As an implementation-specific option, a RST
					  segment may be sent from the managed node to the
					  other TCP endpoint (note however that RST segments
					  are not sent reliably)."
			  ::= { tcpConnEntry 1 }

		  tcpConnLocalAddress OBJECT-TYPE
			  SYNTAX  IpAddress
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The local IP address for this TCP connection.  In
					  the case of a connection in the listen state which
					  is willing to accept connections for any IP
					  interface associated with the node, the value
					  0.0.0.0 is used."
			  ::= { tcpConnEntry 2 }

		  tcpConnLocalPort OBJECT-TYPE
			  SYNTAX  INTEGER (0..65535)
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The local port number for this TCP connection."
			  ::= { tcpConnEntry 3 }

		  tcpConnRemAddress OBJECT-TYPE
			  SYNTAX  IpAddress
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The remote IP address for this TCP connection."
			  ::= { tcpConnEntry 4 }

		  tcpConnRemPort OBJECT-TYPE
			  SYNTAX  INTEGER (0..65535)
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The remote port number for this TCP connection."
			  ::= { tcpConnEntry 5 }


		  -- additional TCP objects

		  tcpInErrs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of segments received in error
					  (e.g., bad TCP checksums)."
			  ::= { tcp 14 }

		  tcpOutRsts OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of TCP segments sent containing the
					  RST flag."
			  ::= { tcp 15 }


		  -- the UDP group

		  -- Implementation of the UDP group is mandatory for all
		  -- systems which implement the UDP.

		  udpInDatagrams OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of UDP datagrams delivered to
					  UDP users."
			  ::= { udp 1 }

		  udpNoPorts OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of received UDP datagrams for
					  which there was no application at the destination
					  port."
			  ::= { udp 2 }

		  udpInErrors OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of received UDP datagrams that could
					  not be delivered for reasons other than the lack
					  of an application at the destination port."
			  ::= { udp 3 }
		  udpOutDatagrams OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of UDP datagrams sent from this
					  entity."
			  ::= { udp 4 }


		  -- the UDP Listener table

		  -- The UDP listener table contains information about this
		  -- entity's UDP end-points on which a local application is
		  -- currently accepting datagrams.

		  udpTable OBJECT-TYPE
			  SYNTAX  SEQUENCE OF UdpEntry
			  ACCESS  not-accessible
			  STATUS  mandatory
			  DESCRIPTION
					  "A table containing UDP listener information."
			  ::= { udp 5 }

		  udpEntry OBJECT-TYPE
			  SYNTAX  UdpEntry
			  ACCESS  not-accessible
			  STATUS  mandatory
			  DESCRIPTION
					  "Information about a particular current UDP
					  listener."
			  INDEX	  { udpLocalAddress, udpLocalPort }
			  ::= { udpTable 1 }

		  UdpEntry ::=
			  SEQUENCE {
				  udpLocalAddress
					  IpAddress,
				  udpLocalPort
					  INTEGER (0..65535)
			  }

		  udpLocalAddress OBJECT-TYPE
			  SYNTAX  IpAddress
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The local IP address for this UDP listener.	In
					  the case of a UDP listener which is willing to
					  accept datagrams for any IP interface associated
					  with the node, the value 0.0.0.0 is used."
			  ::= { udpEntry 1 }

		  udpLocalPort OBJECT-TYPE
			  SYNTAX  INTEGER (0..65535)
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The local port number for this UDP listener."
			  ::= { udpEntry 2 }


		  -- the EGP group

		  -- Implementation of the EGP group is mandatory for all
		  -- systems which implement the EGP.

		  egpInMsgs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of EGP messages received without
					  error."
			  ::= { egp 1 }

		  egpInErrors OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of EGP messages received that proved
					  to be in error."
			  ::= { egp 2 }

		  egpOutMsgs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of locally generated EGP
					  messages."
			  ::= { egp 3 }

		  egpOutErrors OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of locally generated EGP messages not
					  sent due to resource limitations within an EGP
					  entity."
			  ::= { egp 4 }


		  -- the EGP Neighbor table

		  -- The EGP neighbor table contains information about this
		  -- entity's EGP neighbors.

		  egpNeighTable OBJECT-TYPE
			  SYNTAX  SEQUENCE OF EgpNeighEntry
			  ACCESS  not-accessible
			  STATUS  mandatory
			  DESCRIPTION
					  "The EGP neighbor table."
			  ::= { egp 5 }

		  egpNeighEntry OBJECT-TYPE
			  SYNTAX  EgpNeighEntry
			  ACCESS  not-accessible
			  STATUS  mandatory
			  DESCRIPTION
					  "Information about this entity's relationship with
					  a particular EGP neighbor."
			  INDEX	  { egpNeighAddr }
			  ::= { egpNeighTable 1 }

		  EgpNeighEntry ::=
			  SEQUENCE {
				  egpNeighState
					  INTEGER,
				  egpNeighAddr
					  IpAddress,
				  egpNeighAs
					  INTEGER,
				  egpNeighInMsgs
					  Counter,
				  egpNeighInErrs
					  Counter,
				  egpNeighOutMsgs
					  Counter,
				  egpNeighOutErrs
					  Counter,
				  egpNeighInErrMsgs
					  Counter,
				  egpNeighOutErrMsgs
					  Counter,
				  egpNeighStateUps
					  Counter,
				  egpNeighStateDowns
					  Counter,
				  egpNeighIntervalHello
					  INTEGER,
				  egpNeighIntervalPoll
					  INTEGER,
				  egpNeighMode
					  INTEGER,
				  egpNeighEventTrigger
					  INTEGER
			  }

		  egpNeighState OBJECT-TYPE
			  SYNTAX  INTEGER {
						  idle(1),
						  acquisition(2),
						  down(3),
						  up(4),
						  cease(5)
					  }
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The EGP state of the local system with respect to
					  this entry's EGP neighbor.  Each EGP state is
					  represented by a value that is one greater than
					  the numerical value associated with said state in
					  RFC 904."
			  ::= { egpNeighEntry 1 }

		  egpNeighAddr OBJECT-TYPE
			  SYNTAX  IpAddress
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The IP address of this entry's EGP neighbor."
			  ::= { egpNeighEntry 2 }

		  egpNeighAs OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The autonomous system of this EGP peer.	Zero
					  should be specified if the autonomous system
					  number of the neighbor is not yet known."
			  ::= { egpNeighEntry 3 }

		  egpNeighInMsgs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of EGP messages received without error
					  from this EGP peer."
			  ::= { egpNeighEntry 4 }

		  egpNeighInErrs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of EGP messages received from this EGP
					  peer that proved to be in error (e.g., bad EGP
					  checksum)."
			  ::= { egpNeighEntry 5 }

		  egpNeighOutMsgs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of locally generated EGP messages to
					  this EGP peer."
			  ::= { egpNeighEntry 6 }

		  egpNeighOutErrs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of locally generated EGP messages not
					  sent to this EGP peer due to resource limitations
					  within an EGP entity."
			  ::= { egpNeighEntry 7 }

		  egpNeighInErrMsgs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of EGP-defined error messages received
					  from this EGP peer."
			  ::= { egpNeighEntry 8 }

		  egpNeighOutErrMsgs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of EGP-defined error messages sent to
					  this EGP peer."
			  ::= { egpNeighEntry 9 }

		  egpNeighStateUps OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of EGP state transitions to the UP
					  state with this EGP peer."
			  ::= { egpNeighEntry 10 }

		  egpNeighStateDowns OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The number of EGP state transitions from the UP
					  state to any other state with this EGP peer."
			  ::= { egpNeighEntry 11 }

		  egpNeighIntervalHello OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The interval between EGP Hello command
					  retransmissions (in hundredths of a second).	This
					  represents the t1 timer as defined in RFC 904."
			  ::= { egpNeighEntry 12 }

		  egpNeighIntervalPoll OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The interval between EGP poll command
					  retransmissions (in hundredths of a second).	This
					  represents the t3 timer as defined in RFC 904."
			  ::= { egpNeighEntry 13 }

		  egpNeighMode OBJECT-TYPE
			  SYNTAX  INTEGER { active(1), passive(2) }
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The polling mode of this EGP entity, either
					  passive or active."
			  ::= { egpNeighEntry 14 }

		  egpNeighEventTrigger OBJECT-TYPE
			  SYNTAX  INTEGER { start(1), stop(2) }
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "A control variable used to trigger operator-
					  initiated Start and Stop events.	When read, this
					  variable always returns the most recent value that
					  egpNeighEventTrigger was set to.	If it has not
					  been set since the last initialization of the
					  network management subsystem on the node, it
					  returns a value of `stop'.

					  When set, this variable causes a Start or Stop
					  event on the specified neighbor, as specified on
					  pages 8-10 of RFC 904.  Briefly, a Start event
					  causes an Idle peer to begin neighbor acquisition
					  and a non-Idle peer to reinitiate neighbor
					  acquisition.	A stop event causes a non-Idle peer
					  to return to the Idle state until a Start event
					  occurs, either via egpNeighEventTrigger or
					  otherwise."
			  ::= { egpNeighEntry 15 }


		  -- additional EGP objects

		  egpAs OBJECT-TYPE
			  SYNTAX  INTEGER
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The autonomous system number of this EGP entity."
			  ::= { egp 6 }
		  -- the Transmission group

		  -- Based on the transmission media underlying each interface
		  -- on a system, the corresponding portion of the Transmission
		  -- group is mandatory for that system.

		  -- When Internet-standard definitions for managing
		  -- transmission media are defined, the transmission group is
		  -- used to provide a prefix for the names of those objects.

		  -- Typically, such definitions reside in the experimental
		  -- portion of the MIB until they are "proven", then as a
		  -- part of the Internet standardization process, the
		  -- definitions are accordingly elevated and a new object
		  -- identifier, under the transmission group is defined. By
		  -- convention, the name assigned is:
		  --
		  --	 type OBJECT IDENTIFIER	   ::= { transmission number }
		  --
		  -- where "type" is the symbolic value used for the media in
		  -- the ifType column of the ifTable object, and "number" is
		  -- the actual integer value corresponding to the symbol.


		  -- the SNMP group

		  -- Implementation of the SNMP group is mandatory for all
		  -- systems which support an SNMP protocol entity.	 Some of
		  -- the objects defined below will be zero-valued in those
		  -- SNMP implementations that are optimized to support only
		  -- those functions specific to either a management agent or
		  -- a management station.	In particular, it should be
		  -- observed that the objects below refer to an SNMP entity,
		  -- and there may be several SNMP entities residing on a
		  -- managed node (e.g., if the node is hosting acting as
		  -- a management station).

		  snmpInPkts OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of Messages delivered to the
					  SNMP entity from the transport service."
			  ::= { snmp 1 }

		  snmpOutPkts OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP Messages which were
					  passed from the SNMP protocol entity to the
					  transport service."
			  ::= { snmp 2 }

		  snmpInBadVersions OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP Messages which were
					  delivered to the SNMP protocol entity and were for
					  an unsupported SNMP version."
			  ::= { snmp 3 }

		  snmpInBadCommunityNames OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP Messages delivered to
					  the SNMP protocol entity which used a SNMP
					  community name not known to said entity."
			  ::= { snmp 4 }

		  snmpInBadCommunityUses OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP Messages delivered to
					  the SNMP protocol entity which represented an SNMP
					  operation which was not allowed by the SNMP
					  community named in the Message."
			  ::= { snmp 5 }

		  snmpInASNParseErrs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of ASN.1 or BER errors
					  encountered by the SNMP protocol entity when
					  decoding received SNMP Messages."
			  ::= { snmp 6 }
		  -- { snmp 7 } is not used

		  snmpInTooBigs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP PDUs which were
					  delivered to the SNMP protocol entity and for
					  which the value of the error-status field is
					  `tooBig'."
			  ::= { snmp 8 }

		  snmpInNoSuchNames OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP PDUs which were
					  delivered to the SNMP protocol entity and for
					  which the value of the error-status field is
					  `noSuchName'."
			  ::= { snmp 9 }

		  snmpInBadValues OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP PDUs which were
					  delivered to the SNMP protocol entity and for
					  which the value of the error-status field is
					  `badValue'."
			  ::= { snmp 10 }

		  snmpInReadOnlys OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number valid SNMP PDUs which were
					  delivered to the SNMP protocol entity and for
					  which the value of the error-status field is
					  `readOnly'.  It should be noted that it is a
					  protocol error to generate an SNMP PDU which
					  contains the value `readOnly' in the error-status
					  field, as such this object is provided as a means
					  of detecting incorrect implementations of the
					  SNMP."
			  ::= { snmp 11 }

		  snmpInGenErrs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP PDUs which were
					  delivered to the SNMP protocol entity and for
					  which the value of the error-status field is
					  `genErr'."
			  ::= { snmp 12 }

		  snmpInTotalReqVars OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of MIB objects which have been
					  retrieved successfully by the SNMP protocol entity
					  as the result of receiving valid SNMP Get-Request
					  and Get-Next PDUs."
			  ::= { snmp 13 }

		  snmpInTotalSetVars OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of MIB objects which have been
					  altered successfully by the SNMP protocol entity
					  as the result of receiving valid SNMP Set-Request
					  PDUs."
			  ::= { snmp 14 }

		  snmpInGetRequests OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP Get-Request PDUs which
					  have been accepted and processed by the SNMP
					  protocol entity."
			  ::= { snmp 15 }

		  snmpInGetNexts OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP Get-Next PDUs which have
					  been accepted and processed by the SNMP protocol
					  entity."
			  ::= { snmp 16 }

		  snmpInSetRequests OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP Set-Request PDUs which
					  have been accepted and processed by the SNMP
					  protocol entity."
			  ::= { snmp 17 }

		  snmpInGetResponses OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP Get-Response PDUs which
					  have been accepted and processed by the SNMP
					  protocol entity."
			  ::= { snmp 18 }

		  snmpInTraps OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP Trap PDUs which have
					  been accepted and processed by the SNMP protocol
					  entity."
			  ::= { snmp 19 }

		  snmpOutTooBigs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP PDUs which were
					  generated by the SNMP protocol entity and for
					  which the value of the error-status field is
					  `tooBig.'"
			  ::= { snmp 20 }
		  snmpOutNoSuchNames OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP PDUs which were
					  generated by the SNMP protocol entity and for
					  which the value of the error-status is
					  `noSuchName'."
			  ::= { snmp 21 }

		  snmpOutBadValues OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP PDUs which were
					  generated by the SNMP protocol entity and for
					  which the value of the error-status field is
					  `badValue'."
			  ::= { snmp 22 }

		  -- { snmp 23 } is not used

		  snmpOutGenErrs OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP PDUs which were
					  generated by the SNMP protocol entity and for
					  which the value of the error-status field is
					  `genErr'."
			  ::= { snmp 24 }

		  snmpOutGetRequests OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP Get-Request PDUs which
					  have been generated by the SNMP protocol entity."
			  ::= { snmp 25 }

		  snmpOutGetNexts OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP Get-Next PDUs which have
					  been generated by the SNMP protocol entity."
			  ::= { snmp 26 }

		  snmpOutSetRequests OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP Set-Request PDUs which
					  have been generated by the SNMP protocol entity."
			  ::= { snmp 27 }

		  snmpOutGetResponses OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP Get-Response PDUs which
					  have been generated by the SNMP protocol entity."
			  ::= { snmp 28 }

		  snmpOutTraps OBJECT-TYPE
			  SYNTAX  Counter
			  ACCESS  read-only
			  STATUS  mandatory
			  DESCRIPTION
					  "The total number of SNMP Trap PDUs which have
					  been generated by the SNMP protocol entity."
			  ::= { snmp 29 }

		  snmpEnableAuthenTraps OBJECT-TYPE
			  SYNTAX  INTEGER { enabled(1), disabled(2) }
			  ACCESS  read-write
			  STATUS  mandatory
			  DESCRIPTION
					  "Indicates whether the SNMP agent process is
					  permitted to generate authentication-failure
					  traps.  The value of this object overrides any
					  configuration information; as such, it provides a
					  means whereby all authentication-failure traps may
					  be disabled.

					  Note that it is strongly recommended that this
					  object be stored in non-volatile memory so that it
					  remains constant between re-initializations of the
					  network management system."
			  ::= { snmp 30 }

		  END

7.	Acknowledgements

   This document was produced by the SNMP Working Group:

			   Anne Ambler, Spider
			   Karl Auerbach, Sun
			   Fred Baker, ACC
			   David Bridgham, Epilogue Technology
			   Ken Brinkerhoff
			   Ron Broersma, NOSC
			   Brian Brown, Synoptics
			   Jack Brown, US Army
			   Theodore Brunner, Bellcore
			   Jeff Buffum, HP
			   Jeffrey Buffum, HP
			   John Burress, Wellfleet
			   Jeffrey D. Case, University of Tennessee at Knoxville
			   Chris Chiptasso, Spartacus
			   Paul Ciarfella, DEC
			   Bob Collet
			   John Cook, Chipcom
			   Tracy Cox, Bellcore
			   James R. Davin, MIT-LCS
			   Eric Decker, cisco
			   Kurt Dobbins, Cabletron
			   Nadya El-Afandi, Network Systems
			   Gary Ellis, HP
			   Fred Engle
			   Mike Erlinger
			   Mark S. Fedor, PSI
			   Richard Fox, Synoptics
			   Karen Frisa, CMU
			   Stan Froyd, ACC
			   Chris Gunner, DEC
			   Fred Harris, University of Tennessee at Knoxville
			   Ken Hibbard, Xylogics
			   Ole Jacobsen, Interop
			   Ken Jones
			   Satish Joshi, Synoptics
			   Frank Kastenholz, Racal-Interlan
			   Shimshon Kaufman, Spartacus
			   Ken Key, University of Tennessee at Knoxville
			   Jim Kinder, Fibercom
			   Alex Koifman, BBN
			   Christopher Kolb, PSI
			   Cheryl Krupczak, NCR
			   Paul Langille, DEC
			   Martin Lee Schoffstall, PSI
			   Peter Lin, Vitalink
			   John Lunny, TWG
			   Carl Malamud
			   Gary Malkin, FTP Software, Inc.
			   Randy Mayhew, University of Tennessee at Knoxville
			   Keith McCloghrie, Hughes LAN Systems
			   Donna McMaster, David Systems
			   Lynn Monsanto, Sun
			   Dave Perkins, 3COM
			   Jim Reinstedler, Ungerman Bass
			   Anil Rijsinghani, DEC
			   Kathy Rinehart, Arnold AFB
			   Kary Robertson
			   Marshall T. Rose, PSI (chair)
			   L. Michael Sabo, NCSC
			   Jon Saperia, DEC
			   Greg Satz, cisco
			   Martin Schoffstall, PSI
			   John Seligson
			   Steve Sherry, Xyplex
			   Fei Shu, NEC
			   Sam Sjogren, TGV
			   Mark Sleeper, Sparta
			   Lance Sprung
			   Mike St.Johns
			   Bob Stewart, Xyplex
			   Emil Sturniold
			   Kaj Tesink, Bellcore
			   Geoff Thompson, Synoptics
			   Dean Throop, Data General
			   Bill Townsend, Xylogics
			   Maurice Turcotte, Racal-Milgo
			   Kannan Varadhou
			   Sudhanshu Verma, HP
			   Bill Versteeg, Network Research Corporation
			   Warren Vik, Interactive Systems
			   David Waitzman, BBN
			   Steve Waldbusser, CMU
			   Dan Wintringhan
			   David Wood
			   Wengyik Yeong, PSI
			   Jeff Young, Cray Research

   In addition, the comments of the following individuals are also
   acknolwedged:

			   Craig A. Finseth, Minnesota Supercomputer Center, Inc.
			   Jeffrey C. Honig, Cornell University Theory Center
			   Philip R. Karn, Bellcore

8.	References

   [1] Cerf, V., "IAB Recommendations for the Development of Internet
	   Network Management Standards", RFC 1052, NRI, April 1988.

   [2] Rose M., and K. McCloghrie, "Structure and Identification of
	   Management Information for TCP/IP-based internets," RFC 1065,
	   TWG, August 1988.

   [3] McCloghrie, K., and M. Rose, "Management Information Base for
	   Network Management of TCP/IP-based internets, RFC 1066, TWG,
	   August 1988.

   [4] Cerf, V., "Report of the Second Ad Hoc Network Management Review
	   Group", RFC 1109, NRI, August 1989.

   [5] Case, J., Fedor, M., Schoffstall, M., and J. Davin, "Simple
	   Network Management Protocol (SNMP)", RFC 1098, University of
	   Tennessee at Knoxville, NYSERNet, Inc., Rensselaer Polytechnic
	   Institute, MIT Laboratory for Computer Science, April 1989.

   [6] Postel, J., and J. Reynolds, "TELNET Protocol Specification", RFC
	   854, USC/Information Sciences Institute, May 1983.

   [7] Satz, G., "Connectionless Network Protocol (ISO 8473) and End
	   System to Intermediate System (ISO 9542) Management Information
	   Base", RFC 1162, cisco Systems, Inc., June 1990.

   [8] Information processing systems - Open Systems Interconnection -
	   Specification of Abstract Syntax Notation One (ASN.1),
	   International Organization for Standardization, International
	   Standard 8824, December 1987.

   [9] Information processing systems - Open Systems Interconnection -
	   Specification of Basic Encoding Rules for Abstract Notation One
	   (ASN.1), International Organization for Standardization,
	   International Standard 8825, December 1987.

  [10] Jacobson, V., "Congestion Avoidance and Control", SIGCOMM 1988,
	   Stanford, California.

  [11] Hagens, R., Hall, N., and M. Rose, "Use of the Internet as a
	   Subnetwork for Experimentation with the OSI Network Layer", RFC
	   1070, U of Wiscsonsin - Madison, U of Wiscsonsin - Madison, The
	   Wollongong Group, February 1989.

  [12] Rose M., and K. McCloghrie, "Structure and Identification of
	   Management Information for TCP/IP-based internets", RFC 1155,
	   Performance Systems International, Hughes LAN Systems, May 1990.

  [13] Case, J., Fedor, M., Schoffstall, M., and J. Davin, "Simple
	   Network Management Protocol", RFC 1157, SNMP Research,
	   Performance Systems International, Performance Systems
	   International, MIT Laboratory for Computer Science, May 1990.

  [14] Rose, M., and K. McCloghrie, Editors, "Concise MIB Definitions",
	   RFC 1212, Performance Systems International, Hughes LAN Systems,
	   March 1991.

9.	Security Considerations

   Security issues are not discussed in this memo.

10.	 Authors' Addresses

   Keith McCloghrie
   Hughes LAN Systems
   1225 Charleston Road
   Mountain View, CA 94043
   1225 Charleston Road
   Mountain View, CA 94043

   Phone: (415) 966-7934

   EMail: kzm@hls.com


   Marshall T. Rose
   Performance Systems International
   5201 Great America Parkway
   Suite 3106
   Santa Clara, CA	95054

   Phone: +1 408 562 6222

   EMail: mrose@psi.com
   X.500:  rose, psi, us


SNMP Working Group											   [Page 70]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\commands\ipconfig\readme.txt ===
Usage:

ipconfig [option]
where option is one of:
/all -- show all information
/renew [Adapter] -- renew adapter or all adapters if none provided
/release [Adapter] -- release ...
/flushdns -- flush dns registrations
/registerdns -- static refresh (causes dns registrations?)
/displaydns -- show dns cache
/displayclassid Adapter -- show class id info
/setclassid Adapter ClassId
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\rip\iprip.ini ===
\Registry\Machine

    System
      CurrentControlSet
        Services
            IpRip 
                Parameters
                    SilentRip = REG_DWORD 0x0
                    AcceptHostRoutes = REG_DWORD 0x0
                    AnnounceHostRoutes = REG_DWORD 0x0
                    AcceptDefaultRoutes = REG_DWORD 0x0
                    AnnounceDefaultRoutes = REG_DWORD 0x0
                    EnablePoisonedReverse = REG_DWORD 0x1
                    EnableSplitHorizon = REG_DWORD 0x1
                    EnableTriggeredUpdates = REG_DWORD 0x1
                    RouteTimeout = REG_DWORD 0xb4
                    GarbageTimeout = REG_DWORD 0x78
                    LoggingLevel = REG_DWORD 0x3
                    UpdateFrequency = REG_DWORD 0x1e
                    OverwriteStaticRoutes = REG_DWORD 0x0
                    MaxTriggeredUpdateFrequency = REG_DWORD 0x05
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\rip\rip.ini ===
\Registry\Machine

    System
      CurrentControlSet
        Services
            Rip
                DependOnService = REG_MULTI_SZ "Tcpip" "EventLog"
                DisplayName = REG_SZ RIP Service
                ErrorControl = REG_DWORD 0x1
                ImagePath = REG_EXPAND_SZ %SystemRoot%\System32\rip.exe
                ObjectName = REG_SZ LocalSystem
                Start = REG_DWORD 0x2
                Type = REG_DWORD 0x10

            EventLog
                System
                    Rip
                        EventMessageFile = REG_EXPAND_SZ %SystemRoot%\System32\rip.exe
                        TypesSupported = REG_DWORD 0x7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\simple\calltree.txt ===
SimpInitializeEventLog
SimpTerminateEventLog
SimpLogEvent
              LogEventWorker
LogEventWorker
              DbgPrint
ServiceEntry
              WSAStartup
              socket
              WSAGetLastError
              select
              __WSAFDIsSet
              accept
              send
              closesocket
              ioctlsocket
              recvfrom
              sendto
              ReadRegistry
              AnnounceServiceStatus
              GetServicePort
              InitializeChargen
              InitializeQotdQuotes
              FormatQotdResponse
              FormatDaytimeResponse
              DeleteTcpClient
              AbortTcpClient
              AcceptTcpClient
              OpenUdpSocket
              OpenTcpSocket
              SimpLogEvent
              SimpTerminateEventLog
              SimpInitializeEventLog
OpenTcpSocket
              bind
              listen
              setsockopt
              socket
              closesocket
OpenUdpSocket
              bind
              socket
              closesocket
AcceptTcpClient
              accept
              CreateThread ThreadEntry
              AbortTcpClient
AbortTcpClient
              setsockopt
              closesocket
DeleteTcpClient
              setsockopt
              __WSAFDIsSet
              closesocket
              ioctlsocket
              AbortTcpClient
FormatDaytimeResponse
FormatQotdResponse
InitializeQotdQuotes
              SimpLogEvent
InitializeChargen
GetServicePort
              getservbyname
AnnounceServiceStatus
ControlResponse
              closesocket
              AnnounceServiceStatus
ReadRegistry
ThreadEntry
              recv
              setsockopt
              WSAGetLastError
              select
              send
              ioctlsocket
              DeleteTcpClient
DbgPrint
sendto
recvfrom
ioctlsocket
closesocket
send
accept
__WSAFDIsSet
select
WSAGetLastError
socket
WSAStartup
setsockopt
listen
bind
recv
getservbyname
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\simple\readme.txt ===
// MohsinA, 10-Feb-97

Fixing bugs and testing, simple tcp services.

> Control Panle, Network, add services, Simple TCP/IP Services.

> ren  \winnt\system32\simptcp.dll \winnt\system32\simptcp.old
> copy obj\i386\simptcp.dll \winnt\system32
> Control Panel, Network, Services, Simple TCP/IP Services
    stop, and then restart.

Testing:
> telnet
   connect: localhost
   port:    daytime

For assigned addresses refer to -- rfc1700.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\samples\simple\readme.txt ===
Simple IP samples.
-----------------

server.c:
----------

This is a very simple-minded TCP/UDP server. It listens on a specified port
for client connections. When a client connects, the server receives data
and echoes it back to the client.  For connection orientated protocols (TCP),
the server will continue to receive and echo data until the client indicates
that it is done sending.  For connectionless protocols (UDP), each datagram
is echoed individually.

Usage:
  server -f <family> -t <transport> -p <port> -a <address>

Where,
  Family is one of PF_INET, PF_INET6 or PF_UNSPEC.
  Protocol is either TCP or UDP.
  Port is the port number to listen on.
  Address is the IP address to bind to (typically used on multihomed
    machines to restrict reception to a particular network interface
    instead of allowing connections on any of the server's addresses).

In the case where both a protocol family and an address are specified, the
address must be a valid address in that protocol family.

By default the protocol family is left unspecified (PF_UNSPEC), which means
that the server will accept incoming connections using any supported protocol
family.  It does this by creating multiple server sockets, one per family.


Note:
----

There are differences in the way TCP and UDP "servers" can be written. For
TCP, the paradigm of bind(), listen() and accept() is widely implemented. 
For UDP, however, there are two things to consider:

1. listen() or accept() do not work on a UDP socket. These are APIs
that are oriented towards connection establishment, and are not applicable
to datagram protocols. To implement a UDP server, a process only needs to
do recvfrom() on the socket that is bound to a well-known port. Clients
will send datagrams to this port, and the server can process these.

2. Since there is no connection esablished, the server must treat each
datagram separately.


client.c
---------

A simple TCP/UDP client application. It connects to a specified IP address and
port and sends a small message. It can send only one message, or loop for a
specified number of iterations, sending data to the server and receiving a
response.

Usage:
  client -s <server> -f <family> -t <transport> -p <port> -b <bytes> -n <num>

Where,
  Server is a server name or IP address.
  Family is one of PF_INET, PF_INET6 or PF_UNSPEC.
  Protocol is either TCP or UDP.
  Port is the port number to listen on.
  Bytes is the number of extra data bytes to add to each message.
  Num specifies how many messages to send.
 
  '-n' without any arguments will cause the client to send & receive messages
  until interrupted by Ctrl-C.

Since the protocol family is left unspecified by default, the protcol family
which is used will be that of the address to which the server name resolves.
If a server name resolves into multiple addresses, the client will try them
sequentially until it finds one to which it can connect.


Note:
----
As explained for server.c, there is no concept of a connection in UDP
communications. However, we can use connect() on a UDP socket. This
establishes the remote (IPaddr, port) to used when sending a datagram.
Thus, we can use send() instead of sendto() on this socket.

This makes the code nearly identical for UDP and TCP sockets. However, it
must be realized that this is still connectionless datagram traffic for
UDP sockets, and must be treated as such.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\readme.txt ===
UNIMODEM 32-bit USER-MODE COMPONENT SOURCE DIRECTORY
----------------------------------------------------
5/30/1997 JosephJ Created


PLEASE SEE README.HTM FOR FURTHER INFORMATION.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\unimdm.ini ===
;; --------------------------------------------------------------------
;; --------------------------------------------------------------------

[ModemUI]
; DumpFlags:
;    00000001   DCB
;    00000002   MODEMSETTINGS
;    00000004   DEVCAPS

DumpFlags=0x00000000

; TraceFlags:
;    00000001   Warnings
;    00000002   Errors
;    00000004   General 
;    00000008   Function trace

TraceFlags=0x00000007

; BreakFlags:
;    00000001   Break on validate
;    00000040   Break on process attach
;    00000100   Break on API enter

BreakFlags=0x00000001


;; --------------------------------------------------------------------
;; --------------------------------------------------------------------


[Modem]
; DumpFlags:

DumpFlags=0x00000000

; TraceFlags:
;    00000001   Warnings
;    00000002   Errors
;    00000004   General 
;    00000008   Function trace
;    00010000   Detection queries
;    00020000   Class installer trace

TraceFlags=0x00020007

; BreakFlags:
;    00000001   Break on validate
;    00000040   Break on process attach
;    00000100   Break on API enter

BreakFlags=0x00000001



;; --------------------------------------------------------------------
;; --------------------------------------------------------------------

[SerialUI]
; DumpFlags:
;    00000001   DCB

DumpFlags=0x00000000

; TraceFlags:
;    00000001   Warnings
;    00000002   Errors
;    00000004   General 
;    00000008   Function trace

TraceFlags=0x00000007

; BreakFlags:
;    00000001   Break on validate
;    00000040   Break on process attach
;    00000100   Break on API enter

BreakFlags=0x00000001




;; --------------------------------------------------------------------
;; --------------------------------------------------------------------

[Unimdm]
; DumpFlags:

DumpFlags=0x00000000

; TraceFlags:
;    00000001   Warnings
;    00000002   Errors
;    00000004   General 
;    00000008   Function trace
;    00010000   dwDeviceID related
;    00020000   hdLine related
;    00040000   hdCall related
;    00080000   pLineDev related
;    00100000   pModemInfo related

TraceFlags=0x00000007

; BreakFlags:
;    00000001   Break on validate
;    00000040   Break on process attach
;    00000080   Break on process dettach
;    00000100   Break on API enter

BreakFlags=0x00000001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\inf\hkr.txt ===
8/8/96 JosephJ This file contains all the HKR addreg entries from all our INFs,
       excluding Responses entries. Also, some entries extend over several lines
       using the backslash char -- only the 1st line of those entries are
       present.

HKR,, AbortPlay, , "<h10><h18>at<cr>"
HKR,, AbortPlay, , "<h10>Aat<cr>"
HKR,, CallerIDOutSide, , O
HKR,, CallerIDPrivate, , P
HKR,, CDWaitPeriod, 1, c0, d4, 01, 00
HKR,, CompatibilityFlags, 1, 01, 00, 00, 00
HKR,, ConfigDelay, 1, b8, 0b, 00, 00
HKR,, ConfigDialog, , modemui.dll
HKR,, Contention, , *vcd
HKR,, DCB, 1, 1C, 00, 00, 00, 00, 00, 06, 00, 15, 20, 00, 00, 00, 00, 0a, 00, 0a, 00, 08, 00, 00, 11, 13, 00, 00, 00
HKR,, DCB, 1, 1C, 00, 00, 00, 00, 4B, 00, 00, 15, 20, 00, 00, 00, 00, 0a, 00, 0a, 00, 08, 00, 00, 11, 13, 00, 00, 00
HKR,, DCB, 1, 1C, 00, 00, 00, 00, 96, 00, 00, 15, 20, 00, 00, 00, 00, 0a, 00, 0a, 00, 08, 00, 00, 11, 13, 00, 00, 00
HKR,, DCB, 1, 1C, 00, 00, 00, 00, c2, 01, 00, 15, 20, 00, 00, 00, 00, 0a, 00, 0a, 00, 08, 00, 00, 11, 13, 00, 00, 00
HKR,, DCB, 1, 1C, 00, 00, 00, 00, C2, 01, 00, 15, 20, 00, 00, 00, 00, 0A, 00, 0A, 00, 08, 00, 00, 11, 13, 00, 00, 00, 00, 00
HKR,, DCB, 1, 1C, 00, 00, 00, 00, E1, 00, 00, 15, 20, 00, 00, 00, 00, 0a, 00, 0a, 00, 08, 00, 00, 11, 13, 00, 00, 00
HKR,, DCB, 1, 1C, 00, 00, 00, 2C, 01, 00, 00, 15, 20, 00, 00, 00, 00, 0a, 00, 0a, 00, 08, 00, 00, 11, 13, 00, 00, 00
HKR,, DCB, 1, 1C, 00, 00, 00, 60, 09, 00, 00, 11, 00, 00, 00, 00, 00, 0a, 00, 0a, 00, 08, 00, 00, 11, 13, 00, 00, 00
HKR,, DCB, 1, 1C, 00, 00, 00, 60, 09, 00, 00, 15, 20, 00, 00, 00, 00, 0a, 00, 0a, 00, 08, 00, 00, 11, 13, 00, 00, 00
HKR,, DCB, 1, 1C, 00, 00, 00, 80, 25, 00, 00, 15, 20, 00, 00, 00, 00, 0a, 00, 0a, 00, 08, 00, 00, 11, 13, 00, 00, 00
HKR,, DCB, 1, 1C, 00, 00, 00, B0, 04, 00, 00, 15, 20, 00, 00, 00, 00, 0a, 00, 0a, 00, 08, 00, 00, 11, 13, 00, 00, 00
HKR,, Default, 1, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, 01, 00, 00, 00, 10, 01, 00, 00
HKR,, DeviceType, 1, 00
HKR,, DeviceType, 1, 01
HKR,, DeviceType, 1, 02
HKR,, DeviceType, 1, 03
HKR,, DeviceType, 1, 04
HKR,, DeviceType, 1, 05
HKR,, DevLoader, , *VCOMM
HKR,, DevLoader, , *vcomm
HKR,, Enumerator, , serwave.vxd
HKR,, EnumPropPages, , "modemui.dll, EnumPropPages"
HKR,, EnumPropPages, , modemui.dll
HKR,, FClass, 1, 00, 00, 00, 00
HKR,, FClass, 1, 01, 00, 00, 00
HKR,, FClass, 1, 03, 00, 00, 00
HKR,, FClass, 1, 07, 00, 00, 00
HKR,, FClass, 1, 08, 00, 00, 00
HKR,, FClass, 1, 09, 00, 00, 00
HKR,, FClass, 1, 0a, 00, 00, 00
HKR,, FClass, 1, 0b, 00, 00, 00
HKR,, FClass, 1, 0B, 00, 00, 00
HKR,, FClass, 1, 0d, 00, 00, 00
HKR,, FClass, 1, 0f, 00, 00, 00
HKR,, FClass, 1, 19, 00, 00, 00
HKR,, FClass, 1, 1f, 00, 00, 00
HKR,, FClass, 1, 49, 00, 00, 00
HKR,, FClass, 1, 4b, 00, 00, 00
HKR,, FClass, 1, 4f, 00, 00, 00
HKR,, FClass, 1, 5f, 00, 00, 00
HKR,, ForwardDelay, 1, 88, 13
HKR,, FriendlyDriver, , unimodem.vxd
HKR,, FriendlyDriver, , Unimodem.VXD
HKR,, FriendlyDriver, , Unimodem.vxd
HKR,, HandsetCloseDelay, 1, 05, 00, 00, 00
HKR,, HandsetCloseDelay, 1, 1e, 00, 00, 00
HKR,, InactivityFormat, , "seconds"
HKR,, InactivityScale, 01, 00, 00, 00
HKR,, InactivityScale, 0a, 00, 00, 00
HKR,, InactivityScale, 1, 01, 00, 00, 00
HKR,, InactivityScale, 1, 0A, 00, 00, 00
HKR,, InactivityScale, 1, 0a, 00, 00, 00
HKR,, InactivityScale, 1, 0a, 00, 00, 00 
HKR,, InactivityScale, 1, 3c, 00, 00, 00
HKR,, InactivityScale, 1, 3C, 00, 00, 00
HKR,, InactivityScale, 1, 3c, 00, 00, 00
HKR,, InactivityScale, 1, 3C, 00, 00, 00
HKR,, InactivityScale, 1, 3c, 00, 00, 00
HKR,, InactivityScale, 1, 68, 01, 00, 00
HKR,, Override, , Paralink.vxd
HKR,, Override, , ppm.vxd
HKR,, PortDriver, , "serial.vxd"
HKR,, PortDriver, , ppm.vxd
HKR,, PortDriver, , Serial.vxd
HKR,, PortDriver, , serial.vxd
HKR,, PortDriver, , SERIAL.VXD
HKR,, PortSubClass, 1, 02
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, c2, 01, 00, 00, c2, 01, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 2c, 01, 00, 00, 2c, 01, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, b0, 04, 00, 00, b0, 04, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 10, 00, 00, 00, 00, C2, 01, 00, 00, FA, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 10, 00, 00, 00, 00, E1, 00, 00, 00, FA, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 30, 00, 00, 00, 00, c2, 01, 00, 00, c2, 01, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 00, 00, 00, 00, 10, 00, 00, 00, 00, c2, 01, 00, 00, c2, 01, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 00, 00, 00, 00, 10, 01, 00, 00, b0, 04, 00, 00, b0, 04, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 01, 00, 00, 00, b0, 00, 00, 00, 00, c2, 01, 00, 00, fa, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0d, 00, 00, 00, 60, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 00, 01, 00, 00, 00, C2, 01, 00, 40, 83, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 30, 00, 00, 00, 00, 96, 00, 00, 00, 96, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 36, 00, 00, 00, 00, c2, 01, 00, 00, fa, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 60, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, C2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, C2, 01, 00, 00, 96, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, C2, 01, 00, 00, e1, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, C2, 01, 00, 00, F4, 01, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 03, 01, 00, 00, 00, C2, 01, 00, 00, F4, 01, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 10, 00, 00, 00, 00, e1, 00, 00, 00, e1, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 00, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 7f, 01, 00, 00, 00, C2, 01, 00, 40, 83, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 5a, 00, 00, 00, 5a, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 37, 02, 00, 00, 00, c2, 01, 00, 80, 25, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, 64, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 00, 00, 00, 00, 30, 00, 00, 00, 00, c2, 01, 00, 00, fa, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 30, 00, 00, 00, 00, c2, 01, 00, 00, fa, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 05, 00, 00, 00, 10, 02, 00, 00, 00, c2, 01, 00, 00, c2, 01, 00
HKR,, Properties, 1, 00, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 00, 01, 00, 00, b0, 04, 00, 00, b0, 04, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, 00, 00, 00, 00, 37, 00, 00, 00, 00, c2, 01, 00, 00, fa, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, 70, 01, 00, 00, 00, e1, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, FF, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, B7, 03, 00, 00, 00, E1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 10, 00, 00, 00, 00, c2, 01, 00, 00, fa, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, FF, 05, 00, 00, 00, C2, 01, 00, 00, FA, 00, 00
HKR,, Properties, 1, 00, 00, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, FF, 05, 00, 00, 00, E1, 00, 00, 00, FA, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 10, 03, 00, 00, b0, 04, 00, 00, b0, 04, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 70, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 73, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 00, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 00, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 00, fa, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 00, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 00, 00, 00, 00, 37, 03, 00, 00, 40, 5e, 02, 00, 00, fa, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 19, 00, 00, 00, fa, 05, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b0, 03, 00, 00, 00, 96, 00, 00, 80, 70, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 5a, 00, 00, 00, 5a, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 77, 07, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 5a, 00, 00, 00, 5a, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 77, 07, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 5a, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 07, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 5a, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 77, 07, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 5a, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 64, 00, 00, 00, 5a, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 78, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, 0d, 00, 00, 00, 50, 01, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 78, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0d, 00, 00, 00, 50, 01, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 78, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 78, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, 78, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 01, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 30, 03, 00, 00, 00, 96, 00, 00, 00, 96, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 00, 03, 00, 00, b0, 04, 00, 00, b0, 04, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 32, 03, 00, 00, 00, 96, 00, 00, 00, 96, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 50, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, e1, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 37, 00, 00, 00, 00, c2, 01, 00, 00, fa, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 01, 00, 00, 00, 0d, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 03, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, 4b, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0d, 00, 00, 00, 37, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0d, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 50, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 70, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 73, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 7f, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f0, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, 4b, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, 4b, 00, 00, b0, 04, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 00, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, e1, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 40, 01, 00, 00, 1e, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 40, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 50, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 40, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 33, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, c2, 01, 00, 00, c2, 01, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 10, 01, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 10, 01, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 10, 01, 00, 00, 00, c2, 01, 00, 00, c2, 01, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 10, 01, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 10, 01, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 10, 01, 00, 00, 2c, 01, 00, 00, 2c, 01, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 10, 01, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 10, 01, 00, 00, b0, 04, 00, 00, b0, 04, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, 00, 01, 00, 00, 00, C2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, 00, 01, 00, 00, 00, E1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 00, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 00, 03, 00, 00, 00, c2, 01, 00, 00, c2, 01, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 00, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 00, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 10, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 10, 03, 00, 00, 00, c2, 01, 00, 00, c2, 01, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 10, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 10, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 70, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 73, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 73, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 73, 03, 00, 00, 00, e1, 00, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 73, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f3, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 1e, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 2D, 00, 00, 00, FF, 00, 00, 00, 00, 00, 00, 00, 0F, 00, 00, 00, 77, 07, 00, 00, 00, C2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 37, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 39, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3a, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3b, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3b, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 03, 00, 00, 80, 25, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, 3c, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 01, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, 3c, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 01, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, 3c, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b7, 03, 00, 00, 00, e1, 00, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, 3c, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b7, 03, 00, 00, 00, e1, 00, 00, a0, 41, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, 3c, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, c0, 5d, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 80, 25, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3C, 00, 00, 00, FF, 00, 00, 00, 00, 00, 00, 00, 0F, 00, 00, 00, F7, 07, 00, 00, 00, 96, 00, 00, 00, 4B, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 3f, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f0, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 3c, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 50, 00, 00, 00, ff, 00, 00, 00, 01, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0d, 00, 00, 00, 40, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0d, 00, 00, 00, 40, 03, 00, 00, b0, 04, 00, 00, b0, 04, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 0f, 00, 00, 00, 07, 00, 00, 00, 0d, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 0f, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 0f, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 3c, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 80, 25, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, c0, 12, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 5a, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 63, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 00, 96, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 64, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 64, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 64, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 64, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 64, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 30, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 64, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 64, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 64, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 64, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 64, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 3f, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 64, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 3f, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 64, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 00, e1, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, 78, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0d, 00, 00, 00, 50, 01, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, fd, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0d, 00, 00, 00, ff, 03, 00, 00, 00, 84, 03, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, fd, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0d, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 80, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, b7, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, 07, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, 07, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 03, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 00, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 00, 03, 00, 00, 80, 25, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 10, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, 84, 03, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 01, 00, 00, 00, c2, 01, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 01, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 03, 00, 00, 00, c2, 01, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, 40, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 03, 00, 00, b0, 04, 00, 00, b0, 04, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 50, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 50, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, c0, 12, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b7, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b7, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, c3, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, d0, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f0, 03, 00, 00, 00, 4b, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f0, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, e1, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 2a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 01, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 2a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 3c, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 36, 03, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 3c, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 59, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 59, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, 7f, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 31, 03, 00, 00, 00, 4b, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 33, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, 4b, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 3b, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 3f, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 47, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, 09, 00, 00, c0, 12, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, 5A, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, 77, 03, 00, 00, 00, 84, 03, 00, 40, 83, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, 5A, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, 77, 03, 00, 00, 00, C2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, 5A, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, 77, 03, 00, 00, 00, C2, 01, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, 5A, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, 7F, 03, 00, 00, 00, E1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 7f, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, c6, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, c7, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, c7, 03, 00, 00, 00, c2, 01, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, c7, 03, 00, 00, 00, c2, 01, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, c7, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f3, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, 4b, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, 5A, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, FF, 03, 00, 00, 00, C2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 7f, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, a0, 41, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 3f, 03, 00, 00, 00, c2, 01, 00, 60, 54, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 3f, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 00, 00, 00, 00, 0F, 00, 00, 00, 77, 02, 00, 00, 00, C2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, 4b, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 00, 00, 00, 00, 0F, 00, 00, 00, 77, 03, 00, 00, 00, C2, 01, 00, 40, 83, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 60, 54, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, a0, 41, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 00, 00, 00, 00, 0F, 00, 00, 00, F7, 06, 00, 00, 00, C2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 01, 00, 00, 00, 0f, 00, 00, 00, 73, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 01, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, 37, 01, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, 37, 01, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, 37, 03, 00, 00, 00, 4b, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, 3f, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, 7f, 03, 00, 00, 00, c2, 01, 00, 40, 83, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, 7f, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 07, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0b, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0B, 00, 00, 00, B7, 07, 00, 00, 00, C2, 01, 00, 40, 83, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0b, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0d, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 10, 00, 00, 00, 00, 4b, 00, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, e1, 00, 00, a0, 41, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, f4, 01, 00, c0, 5d, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 3f, 03, 00, 00, 00, c2, 01, 00, 60, 54, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 40, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 73, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 76, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, 4b, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 00, fa, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 40, 83, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, 77, 03, 00, 00, 00, C2, 01, 00, 40, 83, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 60, 54, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, a0, 41, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, b0, 04, 00, 00, b0, 04, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 7f, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b0, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b7, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b7, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b7, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b7, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b7, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b7, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b7, 03, 00, 00, 00, e1, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b7, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, c0, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, c0, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, c0, 03, 00, 00, b0, 04, 00, 00, b0, 04, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f0, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f0, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f0, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f0, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f0, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, F3, 03, 00, 00, 00, C2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, 4b, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, F7, 03, 00, 00, 00, 84, 03, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, F7, 03, 00, 00, 00, C2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, F7, 03, 00, 00, 00, C2, 01, 00, 40, 83, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, F7, 03, 00, 00, 00, C2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, F7, 03, 00, 00, 00, C2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, C2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, a0, 41, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, E1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 80, 25, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 01, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, FF, 03, 00, 00, 00, 84, 03, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, 96, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, C2, 01, 00, 40, 83, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, c0, 5d, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, e1, 00, 00, 00, 4b, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, e1, 00, 00, a0, 41, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, FF, 07, 00, 00, 00, 4B, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, FF, 07, 00, 00, 00, C2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, 80, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, FF, 07, 00, 00, 00, E1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, b0, 01, 00, 00, 3a, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 7f, 03, 00, 00, 00, e1, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, 19, 00, 00, 00, fa, 05, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, 19, 00, 00, 00, fa, 05, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, 19, 00, 00, 00, fa, 05, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, e1, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, 39, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, 4f, 00, 00, 00, ff, 00, 00, 00, 01, 00, 00, 00, 0d, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, 64, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 37, 01, 00, 00, 00, c2, 01, 00, 00, fa, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, 78, 00, 00, 00, ff, 00, 00, 00, 01, 00, 00, 00, 0d, 00, 00, 00, f7, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, 0f, 00, 00, 00, 40, 07, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 01, 00, 00, 00, 0f, 00, 00, 00, c7, 07, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, c0, 03, 00, 00, 60, 09, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, c7, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 80, 25, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 7f, 03, 00, 00, 00, 96, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, 5a, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 7f, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, C0, 01, 00, 00, FF, 00, 00, 00, 5A, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, 7F, 03, 00, 00, 00, E1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 00, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 00, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 00, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 77, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, C0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, 7f, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, b7, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, C0, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, F7, 03, 00, 00, 00, C2, 01, 00, 40, 83, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, c2, 01, 00, c0, 5d, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, f7, 03, 00, 00, 00, e1, 00, 00, 80, 25, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, C0, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, FF, 03, 00, 00, 00, 84, 03, 00, 40, 83, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 40, 38, 00, 00
HKR,, Properties, 1, C0, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, FF, 03, 00, 00, 00, C2, 01, 00, 40, 83, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, c2, 01, 00, 80, 70, 00, 00
HKR,, Properties, 1, C0, 01, 00, 00, FF, 00, 00, 00, FF, 00, 00, 00, 07, 00, 00, 00, 0F, 00, 00, 00, FF, 03, 00, 00, 00, E1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 03, 00, 00, 80, 70, 00, 00, 00, 96, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 07, 00, 00, 00, 4b, 00, 00, 60, 09, 00, 00
HKR,, Properties, 1, c0, 01, 00, 00, ff, 00, 00, 00, ff, 00, 00, 00, 07, 00, 00, 00, 0f, 00, 00, 00, ff, 07, 00, 00, 00, e1, 00, 00, 40, 38, 00, 00
HKR,, Reset, , "AT &F<cr>"
HKR,, Reset, , "AT&F B0 &C0 &D2 <cr>"
HKR,, Reset, , "AT&F B0 &C1 &D2<cr>"
HKR,, Reset, , "AT&F V1 E0<cr>"
HKR,, Reset, , "AT&F&Q0<cr>"
HKR,, Reset, , "AT&F<cr>"
HKR,, Reset, , "AT&F1<cr>"
HKR,, Reset, , "AT&F2<cr>"
HKR,, Reset, , "AT&F5<cr>"
HKR,, Reset, , "AT&F9<cr>"
HKR,, Reset, , "AT&FE1V1S0=0<cr>"
HKR,, Reset, , "AT&FS0=0<cr>"
HKR,, Reset, , "AT&FS0=0S95=45<cr>"
HKR,, Reset, , "AT&FW0S0=0S95=47<cr>"
HKR,, Reset, , "AT&FX1<cr>"
HKR,, Reset, , "AT&Z<cr>"
HKR,, Reset, , "AT<cr>"
HKR,, Reset, , "ATE1<cr>"
HKR,, Reset, , "ATZ<cr>"
HKR,, RunOnce, , "grpconv /o"
HKR,, SpeakerPhoneSpecs, 1, 00, 00, 00, 00, 0f, 00, 00, 00, 03, 00, 00, 00, 00, 00, 00, 00
HKR,, SpeakerPhoneSpecs, 1, 89, 00, 00, 00, 53, 00, 00, 00, ff, 00, 00, 00, 01, 00, 00, 00
HKR,, TerminatePlay, , "<h10><h03>at<cr>"
HKR,, TerminateRecord, , "<h10>E<cr>at<cr>"
HKR,, TerminateRecord, , "<h1A><cr>at<cr>"
HKR,, TerminateRecord, , "at<cr>"
HKR,, VariableTerminator, , <cr><lf>
HKR,, VoiceManufacturerID, 1, 01, 00
HKR,, VoiceMixerLineID, 1, 00, 00, 05, 00
HKR,, VoiceMixerMid, 1, 02, 00
HKR,, VoiceMixerPid, 1, 99, 01
HKR,, VoiceProductIDHandsetWaveOut, 1, 82, 00
HKR,, VoiceProductIDHandsetWaveOut, 1, 83, 00
HKR,, VoiceProductIDWaveIn, 1, 80, 00
HKR,, VoiceProductIDWaveOut, 1, 81, 00
HKR,, VoiceProfile, 1, 21, 82, 00, 00
HKR,, VoiceProfile, 1, 23, 02, 08, 00
HKR,, VoiceProfile, 1, 23, 03, 08, 00
HKR,, VoiceProfile, 1, 23, 82, 00, 00
HKR,, VoiceProfile, 1, 25, 12, 00, 00
HKR,, VoiceProfile, 1, 27, 02, 48, 00
HKR,, VoiceProfile, 1, 27, 03, 00, 00
HKR,, VoiceProfile, 1, 27, 03, 08, 00
HKR,, VoiceProfile, 1, 63, 00, 20, 00
HKR,, VoiceProfile, 1, A1, 13, 09, 00
HKR,, VoiceProfile, 1, E3, 10, 20, 00
HKR,, VoiceView, 1, 01
HKR,Answer, 1, , ""
HKR,Answer, 1, , "AT A <cr>"
HKR,Answer, 1, , "AT A<cr>"
HKR,Answer, 1, , "ATA<cr>"
HKR,Answer, 1, , "CLIENTSERVER"
HKR,Answer, 1, , "None"
HKR,Answer, 2, , "NoResponse"
HKR,CloseHandset, 1, , "at#cls=0<cr>"
HKR,CloseHandset, 1, , "at#vcl=0<cr>"
HKR,EnableCallerID, 1, , "at#cid=1<cr>"
HKR,EnableDistinctiveRing, 1, , "at-sdr=7<cr>"
HKR,EnableDistinctiveRing, 1, , "ATS101=1<cr>"
HKR,Fax, AnswerMode, , "1"
HKR,Fax, AnswerMode, , "2"
HKR,Fax, BlindDial, , "2"
HKR,Fax, Cl1DontSync, , "1"
HKR,Fax, Cl1FCS, , "0"
HKR,Fax, Class1DTESpeed, , "19200"
HKR,Fax, Class1DTESpeed, , "AUTO"
HKR,Fax, Class1FlowHW, , "&K3"
HKR,Fax, Class1FlowHW, , "&K6"
HKR,Fax, Class1FlowHW, , "\Q3"
HKR,Fax, Class1FlowHW, , "+FLO=2"
HKR,Fax, Class1FlowOff, , "&K0"
HKR,Fax, Class1FlowOff, , "\Q0"
HKR,Fax, Class1FlowOff, , "+FLO=0"
HKR,Fax, Class1FlowSW, , "&K4"
HKR,Fax, Class1FlowSW, , "\Q1"
HKR,Fax, Class1FlowSW, , "+FLO=1"
HKR,Fax, Class2FlowHW, , "&H3"
HKR,Fax, Class2FlowHW, , "&K3"
HKR,Fax, Class2FlowHW, , "&K6"
HKR,Fax, Class2FlowHW, , "\Q3"
HKR,Fax, Class2FlowHW, , "+FLO=2"
HKR,Fax, Class2FlowOff, , "&H0"
HKR,Fax, Class2FlowOff, , "&K0"
HKR,Fax, Class2FlowOff, , "\Q0"
HKR,Fax, Class2FlowOff, , "+FLO=0"
HKR,Fax, Class2FlowSW, , "&H4"
HKR,Fax, Class2FlowSW, , "&K4"
HKR,Fax, Class2FlowSW, , "\Q1"
HKR,Fax, Class2FlowSW, , "+FLO=1"
HKR,Fax, CommaDelay, , "2"
HKR,Fax, CopyQualityCheckLevel, , "1"
HKR,Fax, DialToneWait, , "30"
HKR,Fax, DisableG3ECM, , "1"
HKR,Fax, DisableMRRecv, , "1"
HKR,Fax, DisableMRSend, , "1"
HKR,Fax, DontPurge, , "0"
HKR,Fax, EnableV17Recv, , "1"
HKR,Fax, EnableV17Send, , "1"
HKR,Fax, ExitCommand, , ""
HKR,Fax, ExitCommand, , "AT&FE0"
HKR,Fax, ExitCommand, , "AT&FE0&O0&L1"
HKR,Fax, ExitCommand, , "ATZ"
HKR,Fax, FixModemClass, , "1"
HKR,Fax, FixModemClass, , "2"
HKR,Fax, FixSerialSpeed, , "19200"
HKR,Fax, HangupDelay, , "60"
HKR,Fax, HighestSendSpeed, , "14400"
HKR,Fax, LowestSendSpeed, , "2400"
HKR,Fax, ModemFaxClasses, , "14"
HKR,Fax, ModemFaxClasses, , "4"
HKR,Fax, ModemIdCmd, , "ATI1"
HKR,Fax, NumRings, , "2"
HKR,Fax, PreAnswerCommand, , ""
HKR,Fax, PreDialCommand, , ""
HKR,Fax, ResetCommand, , "AT S111=2"
HKR,Fax, ResetCommand, , "AT&FE0&O0&L1+FCLASS=Z+FZF=1"
HKR,Fax, ResetCommand, , "AT&FE0&O0&L1+FCLASS=Z+FZF=5"
HKR,Fax, ResetCommand, , "AT&FE0+FCLASS=Z+FZF=5"
HKR,Fax, SetupCommand, , "AT E0 S0=0"
HKR,Fax, SetupCommand, , "ATS0=4&W0&FE0&O0&L1+FCLASS=2"
HKR,Fax, SetupCommand, , "ATS0=4&W0&FE0+FCLASS=2"
HKR,Fax, SetupCommand, , "ATS0=4S72=0S73.3=1S73.5=1S73.6=1&W0&FE0&O0&L1+FCLASS=1"
HKR,Fax, SetupCommand, , "ATS7=255&D3&O0&L1S57.4=1"
HKR,Fax, SetupCommand, , "ATS7=255&D3S34=1"
HKR,Fax, SetupCommand, , "ATS7=255&D3S57.4=1"
HKR,Fax, SpeakerMode, , "1"
HKR,Fax, Volume, , "2"
HKR,GenerateDigit, 1, , "at#vts=<Digit><cr>"
HKR,GenerateDigit, 1, , "atdt<Digit>;<cr>"
HKR,GenerateDigit, 1, , "atdt<Digit><cr>"
HKR,HandsetSetPlayFormat, 1, , "at#vsr=7200<cr>"
HKR,HandsetSetPlayFormat, 1, , "at#vsr=9600<cr>"
HKR,HandsetSetPlayFormat, 2, , "at#vbs=4<cr>"
HKR,HandsetSetPlayFormat, 2, , "at#vsm=AD4<cr>"
HKR,HandsetSetRecordFormat, 1, , "at#vsr=7200<cr>"
HKR,HandsetSetRecordFormat, 1, , "at#vsr=9600<cr>"
HKR,HandsetSetRecordFormat, 2, , "at#vbs=4<cr>"
HKR,HandsetSetRecordFormat, 2, , "at#vsm=AD4<cr>"
HKR,Hangup, 1, ,
HKR,Hangup, 1, , "AT H <cr>"
HKR,Hangup, 1, , "AT H<cr>"
HKR,Hangup, 1, , "AT<cr>"
HKR,Hangup, 1, , "ATH<cr>"
HKR,Hangup, 1, , "ATH0<cr>"
HKR,Init, 1, , "AT &F E0<cr>"
HKR,Init, 1, , "AT &F<cr>"
HKR,Init, 1, , "AT &FE0X7<cr>"
HKR,Init, 1, , "AT &O7<cr>"
HKR,Init, 1, , "AT%%A<cr>"
HKR,Init, 1, , "AT&FE0X7<cr>"
HKR,Init, 1, , "AT<cr>"
HKR,Init, 1, , "ATE0Q0V1<cr>"
HKR,Init, 1, , "None"
HKR,Init, 10, , "AT &O0<cr>"
HKR,Init, 10, , "AT S111=7<cr>"
HKR,Init, 11, , "AT S0=0 S95=45 \N3 %%C3<cr>"
HKR,Init, 12, , "AT &O0<cr>"
HKR,Init, 2, , "AT &F &C1 &D2 <cr>"
HKR,Init, 2, , "AT &F &C1&D2<cr>"
HKR,Init, 2, , "AT &F &D2 &C1 E0 \V1 V0 W2 S0=0<cr>"
HKR,Init, 2, , "AT &F &D2 &C1 E0 V1 \V3 S90=249<cr>"
HKR,Init, 2, , "AT &F &D2 &C1 E0 V1 <cr>"
HKR,Init, 2, , "AT &F &D2 &C1 E0 V1 S90=0<cr>"
HKR,Init, 2, , "AT &F &D2 &C1 E0 V1 W1 S0=0 S95=47<cr>"
HKR,Init, 2, , "AT &F &D2 &C1 E0 V1 W2<cr>"
HKR,Init, 2, , "AT &F &D2 &C1<cr>"
HKR,Init, 2, , "AT &F &D2 S0=0 E0 &C1 V1 \V0<cr>"
HKR,Init, 2, , "AT &F \N11 E0 V1 W1 S95=47<cr>"
HKR,Init, 2, , "AT &F \N6 -M0 Q0 V1 \V1<cr>"
HKR,Init, 2, , "AT &F \N6 <cr>"
HKR,Init, 2, , "AT &F \V2 <cr>"
HKR,Init, 2, , "AT &F \V8 <cr>"
HKR,Init, 2, , "AT &F <cr>"
HKR,Init, 2, , "AT &F B0 &C1 &D2 <cr>"
HKR,Init, 2, , "AT &F E0 &C1 &D2 V1 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 &C1 &D2 V1<cr>"
HKR,Init, 2, , "AT &F E0 &D2 &C1 B0 V1<cr>"
HKR,Init, 2, , "AT &F E0 &D2 &C1 S95=3 V1<cr>"
HKR,Init, 2, , "AT &F E0 &D2 &C1 V1 \V2<cr>"
HKR,Init, 2, , "AT &F E0 &D2 &C1 V1 S95=47 B0 <cr>"
HKR,Init, 2, , "AT &F E0 &D2 &C1 V1 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 &D2 &C1 V1<cr>"
HKR,Init, 2, , "AT &F E0 &D2 S0=0 S2=255<cr>"
HKR,Init, 2, , "AT &F E0 &D2 S7=50 \Q3 +Q1 S10=40<cr>"
HKR,Init, 2, , "AT &F E0 &R1 &D2 &C1 V1 W1 S0=0 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 \V1 W1<cr>"
HKR,Init, 2, , "AT &F E0 B0 &C1 &D2 <cr>"
HKR,Init, 2, , "AT &F E0 B0 &C1 &D2 V1<cr>"
HKR,Init, 2, , "AT &F E0 B0 &D2 &C1 V1<cr>"
HKR,Init, 2, , "AT &F E0 F0 V1 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 Q0 &C1 &D2 V1<cr>"
HKR,Init, 2, , "AT &F E0 Q0 V1 &B1 &C1 &D2 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 Q0 V1 &C1 &D2 &S0 S0=0 \Q10<cr>"
HKR,Init, 2, , "AT &F E0 Q0 V1 &C1 &D2 W2 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 Q0 W1 X4 V1 S95=45 &C1<cr>"
HKR,Init, 2, , "AT &F E0 S0=0 $BA0 S25=20<cr>"
HKR,Init, 2, , "AT &F E0 S0=0 &D2 &C1 V1 \V1<cr>"
HKR,Init, 2, , "AT &F E0 S0=0 S2=255<cr>"
HKR,Init, 2, , "AT &F E0 S0=0 S25=20<cr>"
HKR,Init, 2, , "AT &F E0 V1 &C1 &D2 \V3 *MM<cr>"
HKR,Init, 2, , "AT &F E0 V1 &C1 &D2 S0=0 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 V1 &C1 &D2 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 &C1 &D2 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 V1 &C1 &D2 W1<cr>"
HKR,Init, 2, , "AT &F E0 V1 &C1 &D2 W2 \V1<cr>"
HKR,Init, 2, , "AT &F E0 V1 &C1 &D2 W2 \V2<cr>"
HKR,Init, 2, , "AT &F E0 V1 &C1 &D2<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 \V1 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 \V1 W2<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 \V2 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 \V2<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 Q0 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 S0=0 \V1<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 S0=0 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 S95=47 \V1 W1 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 S95=47 Q0 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 S95=47 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 S95=47 S0=255<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 S95=47 W1 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 S95=47 W2 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 W1 \V1<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 W1 S0=0 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 W1 S95=47 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 W1 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 W2 \V1 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 W2 \V1<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 W2 S95=47 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1 W2 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 V1 &D2 &C1\V1W2S95=47S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 &I1<cr>"
HKR,Init, 2, , "AT &F E0 V1 *M2<cr>"
HKR,Init, 2, , "AT &F E0 V1 \V<cr>"
HKR,Init, 2, , "AT &F E0 V1 \V1 &D2 &C1 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 \V1 S0=0 &C1 &D2 W2<cr>"
HKR,Init, 2, , "AT &F E0 V1 \V1 S0=0 &C1 &D2<cr>"
HKR,Init, 2, , "AT &F E0 V1 \V1 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 \V1 W2 &D2 &C1 S95=47 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 \V1<cr>"
HKR,Init, 2, , "AT &F E0 V1 \V2<cr>"
HKR,Init, 2, , "AT &F E0 V1 Q0 &D2 &C1 S95=47 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 S0=0 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 V1 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 V1 W1 B1 &C1 &D2 S0=0 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 V1 W1 S0=0 S95=47 S36=7 S48=7<cr>"
HKR,Init, 2, , "AT &F E0 V1 W1 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 W1 S95=47 &C1 &D2 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 W1 S95=47 S0=0 &D2 &C1<cr>"
HKR,Init, 2, , "AT &F E0 V1 W1 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 V1 W1 X4 S95=47 &C1 &D2<cr>"
HKR,Init, 2, , "AT &F E0 V1 W1<cr>"
HKR,Init, 2, , "AT &F E0 V1 W2 &C1 &D2 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 V1 W2 &D2 &C1 \V2 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 W2 &D2 &C1 S0=0 \V1<cr>"
HKR,Init, 2, , "AT &F E0 V1 W2 &D2 &C1 S0=0 \V2<cr>"
HKR,Init, 2, , "AT &F E0 V1 W2 &D2 &C1 S0=0 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 V1 W2 &D2 &C1 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 V1 W2 \V1 &C1 &D2 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 W2 \V1 X4 &C1 &D2<cr>"
HKR,Init, 2, , "AT &F E0 V1 W2 \V2 &D2 &C1 S0=0<cr>"
HKR,Init, 2, , "AT &F E0 V1 W2 \V2 &D2 &C1 S95=47<cr>"
HKR,Init, 2, , "AT &F E0 V1 W2 S0=0 &D2 &C1 \V1<cr>"
HKR,Init, 2, , "AT &F E0 V1<cr>"
HKR,Init, 2, , "AT &F E0 W0 S95=249 <cr>"
HKR,Init, 2, , "AT &F E0<cr>"
HKR,Init, 2, , "AT &F E1 W0 S95=249<cr>"
HKR,Init, 2, , "AT &F S0=0 &D2 &C1 E0 V1 W2 \V1<cr>"
HKR,Init, 2, , "AT &F S0=0 &D2 &C1 E0 V1<cr>"
HKR,Init, 2, , "AT &F S0=0 &D2 E0 V1<cr>"
HKR,Init, 2, , "AT &F S0=0 <cr>"
HKR,Init, 2, , "AT &F S0=0 E0 V1 &D2 &C1 $X2<cr>"
HKR,Init, 2, , "AT &F S0=0 E0 V1 &D2 &C1 W1 S95=47<cr>"
HKR,Init, 2, , "AT &F S0=0 E0 V1 &D2 &C1 W2 \V1<cr>"
HKR,Init, 2, , "AT &F S0=0 E0 V1 &D2 &C1<cr>"
HKR,Init, 2, , "AT &F S0=0 S95=47<cr>"
HKR,Init, 2, , "AT &F S0=0<cr>"
HKR,Init, 2, , "AT &F S95=0 <cr>"
HKR,Init, 2, , "AT &F S95=249<cr>"
HKR,Init, 2, , "AT &F S95=44 <cr>"
HKR,Init, 2, , "AT &F V0 <cr>"
HKR,Init, 2, , "AT &F V1 &D2 &C1 E0 Q0 S0=0 S25=20 $BA0<cr>"
HKR,Init, 2, , "AT &F V1 &D2 &C1 E0 Q0 S0=0 S25=20<cr>"
HKR,Init, 2, , "AT &F V1 E0 S95=46<cr>"
HKR,Init, 2, , "AT &F V1 E0 S95=47<cr>"
HKR,Init, 2, , "AT &F V1 S0=0 S95=47<cr>"
HKR,Init, 2, , "AT &F V1<cr>"
HKR,Init, 2, , "AT &F W0 <cr>"
HKR,Init, 2, , "AT &F W0 S95=122 -J1 <cr>"
HKR,Init, 2, , "AT &F X1<cr>"
HKR,Init, 2, , "AT &F&C1&D2\V2<cr>"
HKR,Init, 2, , "AT &F<cr>"
HKR,Init, 2, , "AT &F0 &D2 &C1 E0 -K0 %E2<cr>"
HKR,Init, 2, , "AT &F0 <cr>"
HKR,Init, 2, , "AT &F0 L2<cr>"
HKR,Init, 2, , "AT &F0<cr>"
HKR,Init, 2, , "AT &F1 E0 V1 &C1 &D2 Q0 S0=0 &B1 &A3<cr>"
HKR,Init, 2, , "AT &F1 E0 V1 &D2 &C1 S95=47 S0=0<cr>"
HKR,Init, 2, , "AT &F1<cr>"
HKR,Init, 2, , "AT &F2 E V Q0 W1 &C1 &D2 S95=47 S0=0<cr>"
HKR,Init, 2, , "AT &F2 E0 &C1 &D2 V1 \V1 S0=0<cr>"
HKR,Init, 2, , "AT &F2 E0 V1 Q0 W1 S95=47 S0=0<cr>"
HKR,Init, 2, , "AT &F5 <cr>"
HKR,Init, 2, , "AT &F9 E0 V1 S59=7<cr>"
HKR,Init, 2, , "AT &F9<cr>"
HKR,Init, 2, , "AT &FE0&D2&C1<cr>"
HKR,Init, 2, , "AT &FE0Q0V1W1&C1&S0S0=0S70=64S95=47<cr>"
HKR,Init, 2, , "AT &FX4S7=60<cr>"
HKR,Init, 2, , "AT &O3<cr>"
HKR,Init, 2, , "AT &O6<cr>"
HKR,Init, 2, , "AT &Q0&C1&D1&K3Q0V1W0X4E1B0F0%%C2\N7<cr>"
HKR,Init, 2, , "AT E0 &F&D2&C1<cr>"
HKR,Init, 2, , "AT E0 S0=0 S95=45<cr>"
HKR,Init, 2, , "AT E0 V1 &C1 &D2 S0=0 \V2<cr>"
HKR,Init, 2, , "AT E0 V1 &C1 &D2 S0=0 W2 S95=47<cr>"
HKR,Init, 2, , "AT W0 S95=251<cr>"
HKR,Init, 2, , "AT Z <cr>"
HKR,Init, 2, , "AT Z<cr>"
HKR,Init, 2, , "AT&C1&D2 W0 S0=0 %A2=95 %A4=0  %A96=1<cr>"
HKR,Init, 2, , "AT&F E0 V1<cr>"
HKR,INIT, 2, , "AT&F S50=0 S38=1 &D2<cr>"
HKR,Init, 2, , "AT&F%%A2=1&Q0<cr>"
HKR,Init, 2, , "AT&F%%AE0V1&S0\N0<cr>"
HKR,Init, 2, , "AT&F%%AE0V1&S0\N1<cr>"
HKR,Init, 2, , "AT&F%%AE0V1&S0\N2<cr>"
HKR,Init, 2, , "AT&F%%AE0V1&S0\N3<cr>"
HKR,Init, 2, , "AT&F%%AE0V1&S0\N7<cr>"
HKR,Init, 2, , "AT&F%%F2\N3\Q3E0V0&C1&D2S0=0<cr>"
HKR,Init, 2, , "AT&F&B1&C1&D2&M4&K1E0Q0V1&A3<cr>"
HKR,Init, 2, , "AT&F&C1&D2 V1 X7 S0=0 S2=128 S7=55<cr>"
HKR,Init, 2, , "AT&F&C1&D2E0V1<cr>"
HKR,Init, 2, , "AT&F&C1&D2E0V1S0=0<cr>"
HKR,Init, 2, , "AT&F&C1&D2E0V1S95=47S0=0<cr>"
HKR,Init, 2, , "AT&F&C1E0&D2V1W2S95=47<cr>"
HKR,Init, 2, , "AT&F&D2&C1\V1S0=0E0V1<cr>"
HKR,Init, 2, , "AT&F&D2&C1\V1S0=0E0V1W2S90=249<cr>"
HKR,Init, 2, , "AT&F&D2&C1E0V1\V3S95=47S90=249<cr>"
HKR,Init, 2, , "AT&F&D2&C1S0=0E0V1*XC1*MM0*CM1<cr>"
HKR,Init, 2, , "AT&F&D2&C1S0=0E0V1*XC1*MM10<cr>"
HKR,Init, 2, , "AT&F&D2&C1S0=0E0V1*XC1<cr>"
HKR,Init, 2, , "AT&F&D2&K3&C1%%C0W0-J1S95=122<cr>"
HKR,Init, 2, , "AT&F&K3E0V1<cr>"
HKR,Init, 2, , "AT&F<cr>"
HKR,Init, 2, , "AT&F0E0V0W1&C1&D2\G0\J0\Q3\N7<cr>"
HKR,Init, 2, , "AT&F1&B1&C1&D2E0Q0V1&A3S0=0<cr>"
HKR,Init, 2, , "AT&F2&C1&D2V1\V1S0=0\N6%%C1\J0E0<cr>"
HKR,Init, 2, , "AT&F2&M0\N3E1\V4&C1&D2V1X4E0 S0=0  <cr>"
HKR,Init, 2, , "AT&F2E0S95=47<cr>"
HKR,Init, 2, , "AT&F2E0W2<cr>"
HKR,Init, 2, , "AT&F2EVQ0W1&C1&D2S95=47S0=0<cr>"
HKR,Init, 2, , "AT&FE0&D2&C1V0W1S0=0S95=47<cr>"
HKR,Init, 2, , "AT&FE0<cr>"
HKR,Init, 2, , "AT&FE0Q0V1W1&C1&S0S0=0S95=47<cr>"
HKR,Init, 2, , "AT&FE0V0&A3&B1&D2&S0<cr>"
HKR,Init, 2, , "AT&FE0V0&C1&D2<cr>"
HKR,Init, 2, , "AT&FE0V0&C1&D2S0=0<cr>"
HKR,Init, 2, , "AT&FE0V0&D2&C1<cr>"
HKR,Init, 2, , "AT&FE0V0&D2&C1S0=0<cr>"
HKR,Init, 2, , "AT&FE0V0Q0&C1&D2S0=0<cr>"
HKR,Init, 2, , "AT&FE0V0Q0&C1&D2S95=47S0=0<cr>"
HKR,Init, 2, , "AT&FE0V0Q0W1&C1&D2S95=47S0=0<cr>"
HKR,Init, 2, , "AT&FE0V0W1&C1&D2S95=47<cr>"
HKR,Init, 2, , "AT&FE0V0W1&Q5&S0S95=47<cr>"
HKR,Init, 2, , "AT&FE0V0W1S95=47<cr>"
HKR,Init, 2, , "AT&FE0V0W2&C1&D2<cr>"
HKR,Init, 2, , "AT&FE0V0W2&C1&D2S95=47<cr>"
HKR,Init, 2, , "AT&FE0V1&A3&B1&C1&D2&S0S0=0<cr>"
HKR,Init, 2, , "AT&FE0V1&A3&B1&D2&S0<cr>"
HKR,Init, 2, , "AT&FE0V1&C1&D2<cr>"
HKR,Init, 2, , "AT&FE0V1&D2&C1\V1W2S95=47S0=0<cr>"
HKR,Init, 2, , "AT&FE0V1&D2&C1\V2W1S0=0<cr>"
HKR,Init, 2, , "AT&FE0V1&D2&C1Q0S0=0<cr>"
HKR,Init, 2, , "AT&FE0V1&D2&C1S95=47S0=0&C1&D2<cr>"
HKR,Init, 2, , "AT&FE0V1&D2&C1W2 \V1 S95=47 !PSTN<cr>"
HKR,Init, 2, , "AT&FE0V1&D2&C1W2Q0S0=0<cr>"
HKR,Init, 2, , "AT&FE0V1&S0 W0S95=44<cr>"
HKR,Init, 2, , "AT&FE0V1\V2<cr>"
HKR,Init, 2, , "AT&FE0V1Q0&C1&D2<cr>"
HKR,Init, 2, , "AT&FE0V1S0=0S95=47<cr>"
HKR,Init, 2, , "AT&FE0V1S95=47&C1&D2<cr>"
HKR,Init, 2, , "AT&FE0V1S95=47<cr>"
HKR,Init, 2, , "AT&FE0V1W2&C1&D2\V1<cr>"
HKR,Init, 2, , "AT&FE0V1X4S95=47&C1&D2&S0<cr>"
HKR,Init, 2, , "AT&FE0W1V1S95=47<cr>"
HKR,Init, 2, , "AT&FE0W2V1X4S95=47&C1&D2&S0<cr>"
HKR,Init, 2, , "AT&FE1V1&A3&B1&D2&S0<cr>"
HKR,Init, 2, , "AT&FE1V1&A3&S0<cr>"
HKR,Init, 2, , "AT&FEW5&SS21=0S0=0<cr>"
HKR,Init, 2, , "AT&FF0E0Q0V0 <cr>"
HKR,Init, 2, , "AT&FF0E0Q0V0<cr>"
HKR,Init, 2, , "AT&FS0=0E0&C1&D2<cr>"
HKR,Init, 2, , "AT&FS0=0E0V1Q0&C1&D2<cr>"
HKR,Init, 2, , "AT&FV0E0&D2&S0<cr>"
HKR,Init, 2, , "AT&FV1&D2&C1E0Q0<cr>"
HKR,Init, 2, , "AT&FV1&D2&C1E0Q0W1S95=47<cr>"
HKR,Init, 2, , "AT&O0<cr>"
HKR,Init, 2, , "AT&O1<cr>"
HKR,Init, 2, , "AT&O2<cr>"
HKR,Init, 2, , "AT&O3<cr>"
HKR,Init, 2, , "AT&Q0&C1&D1Q0V1W1E0S95=47<cr>"
HKR,Init, 2, , "ATE0Q0V0X1S0=0<cr>"
HKR,Init, 2, , "ATE0V1&S0\N3%%S1<cr>"
HKR,Init, 2, , "ATE0V1<cr>"
HKR,Init, 2, , "ATE1V1<cr>"
HKR,Init, 2, , "ATS11=90S57.4=1<cr>"
HKR,Init, 2, , "ATS35.1=0S35.7=1<cr>"
HKR,Init, 2, , "ATX6=1X8=1S0=0S15=10<cr>"
HKR,Init, 2, , "ATZ<cr>"
HKR,INIT, 2, , "ATZ<cr>"
HKR,Init, 2, , "ATZ12<cr>"
HKR,Init, 2, , "NoResponse"
HKR,Init, 3, , "AT $E3 $F5<cr>"
HKR,INIT, 3, , "AT $X3 &D2<cr>"
HKR,Init, 3, , "AT &C1 &D2 S0=0 E0 V1 S95=47<cr>"
HKR,Init, 3, , "AT &D2 &S0 S0=0 \N3 %%C3<cr>"
HKR,Init, 3, , "AT &D2 S95=249<cr>"
HKR,Init, 3, , "AT &F &C1 &D2 E0 V1<cr>"
HKR,Init, 3, , "AT &F V1 W1<cr>"
HKR,Init, 3, , "AT &F W3 S66=68  <cr>"
HKR,Init, 3, , "AT &F<cr>"
HKR,Init, 3, , "AT &F9 E0 V1 S92=1 S59=3<cr>"
HKR,Init, 3, , "AT &O1<cr>"
HKR,Init, 3, , "AT \J0<cr>"
HKR,Init, 3, , "AT \V0 X2<cr>"
HKR,Init, 3, , "AT <cr>"
HKR,Init, 3, , "AT E0 %%U2 V0 S0=0<cr>"
HKR,Init, 3, , "AT E0 &D2 &C1 S0=0 V1 \V2<cr>"
HKR,Init, 3, , "AT E0 &D2 &C1 S0=0 V1<cr>"
HKR,Init, 3, , "AT E0 &D2 V1 \Q3 +M2 \N3<cr>"
HKR,Init, 3, , "AT E0 Q0 V0 W1 T L2 M1 &C1 <cr>"
HKR,Init, 3, , "AT E0 Q0 V0 W2 &C1<cr>"
HKR,Init, 3, , "AT E0 S0=0 S25=20<cr>"
HKR,Init, 3, , "AT E0 S0=0 S95=45<cr>"
HKR,Init, 3, , "AT E0 V0 &D2 &C1 V0 \V1<cr>"
HKR,Init, 3, , "AT E0 V0 <cr>"
HKR,Init, 3, , "AT E0 V1 &C1 &D2 S0=0 \V2<cr>"
HKR,Init, 3, , "AT E0 V1 &C1 &D2 W2 \V1 S95=47<cr>"
HKR,Init, 3, , "AT E0 V1 &C1 &D2 W2<cr>"
HKR,Init, 3, , "AT E0 V1 &D2 &C1 S0=0 S95=47<cr>"
HKR,Init, 3, , "AT E0 V1 &D2 &C1 W1 S95=47 S0=0<cr>"
HKR,Init, 3, , "AT E0 V1 <cr>"
HKR,Init, 3, , "AT E0 V1 C1 &D2 S0=0<cr>"
HKR,Init, 3, , "AT E0 V1 S59=7<cr>"
HKR,Init, 3, , "AT E0 V1 S95=45 S0=0 <cr>"
HKR,Init, 3, , "AT E0 V1 S95=47 \N3 %%C1 \J0<cr>"
HKR,Init, 3, , "AT E0 V1 S95=47 <cr>"
HKR,Init, 3, , "AT E0 V1 S95=47<cr>"
HKR,Init, 3, , "AT E0 V1 W1 B1<cr>"
HKR,Init, 3, , "AT E0 V1 W1 S0=0 S7=50<cr>"
HKR,Init, 3, , "AT E0 V1 W1<cr>"
HKR,Init, 3, , "AT E0 V1 W2 B1<cr>"
HKR,Init, 3, , "AT E0 V1 W2 S95=47<cr>"
HKR,Init, 3, , "AT E0 V1 W2<cr>"
HKR,Init, 3, , "AT E0 V1 X5 S0=0 <cr>"
HKR,Init, 3, , "AT E0 V1<cr>"
HKR,Init, 3, , "AT E0<cr>"
HKR,Init, 3, , "AT E1 &D2 &C1 W0 S0=0 S95=249<cr>"
HKR,Init, 3, , "AT E1 \V0 W1 &D2 S0=0 <cr>"
HKR,Init, 3, , "AT E1 \V0 W1 &D2 S0=0 S95=124 <cr>"
HKR,Init, 3, , "AT E1 Q0 V1 W1 \V1 \J1 S95=249 S10=5 &D2 &C1<cr>"
HKR,Init, 3, , "AT E1 V1 &D2 F70 \N6 X1 <cr>"
HKR,Init, 3, , "AT E1 V1 &D2 F70 \N8 X1 <cr>"
HKR,INIT, 3, , "AT S0=0 &D2 &I0<cr>"
HKR,Init, 3, , "AT S0=0 E0 V1 X3 S95=47<cr>"
HKR,Init, 3, , "AT S0=0<cr>"
HKR,Init, 3, , "AT S0=0T S95=45 \N3 %%C3 V1<cr>"
HKR,Init, 3, , "AT S0=2 V1<cr>"
HKR,Init, 3, , "AT S0=2<cr>"
HKR,Init, 3, , "AT S59=3<cr>"
HKR,Init, 3, , "AT S6=3 <cr>"
HKR,INIT, 3, , "AT S95=122<cr>"
HKR,Init, 3, , "AT S95=250 <cr>"
HKR,INIT, 3, , "AT S95=250<cr>"
HKR,Init, 3, , "AT S95=47 -J1 &Q5<cr>"
HKR,Init, 3, , "AT V1 \V1 X2 &D2 &B0 <cr>"
HKR,Init, 3, , "AT V1 \V1 X2 &D2<cr>"
HKR,Init, 3, , "AT V1 W1 S95=47<cr>"
HKR,Init, 3, , "AT W0 S95=249 S25=0 S38=0<cr>"
HKR,Init, 3, , "AT W1 \V0 &D2<cr>"
HKR,INIT, 3, , "AT W1 V1 &D2<cr>"
HKR,Init, 3, , "AT W1<cr>"
HKR,INIT, 3, , "AT W1<cr>"
HKR,Init, 3, , "AT X1 <cr>"
HKR,Init, 3, , "AT X4S7=60<cr>"
HKR,Init, 3, , "AT&C1&D2&S0<cr>"
HKR,Init, 3, , "AT&C1&D2E0V0W1S95=47<cr>"
HKR,Init, 3, , "AT&D2&C1<cr>"
HKR,Init, 3, , "AT&D2&C1E0Q0V0<cr>"
HKR,INIT, 3, , "AT&F \V0<cr>"
HKR,INIT, 3, , "AT&F S95=248 <cr>"
HKR,INIT, 3, , "AT&F W0 S95=251 <cr>"
HKR,INIT, 3, , "AT&F W1 <cr>"
HKR,INIT, 3, , "AT&F W1<cr>"
HKR,Init, 3, , "AT&F&K3S0=0<cr>"
HKR,Init, 3, , "AT&F&K3S95=47S0=0<cr>"
HKR,INIT, 3, , "AT&F2 W1<cr>"
HKR,Init, 3, , "AT&FV0S0=0S122=2<cr>"
HKR,Init, 3, , "AT&FV0S0=0S122=3<cr>"
HKR,Init, 3, , "AT&FV0S0=0S122=5<cr>"
HKR,Init, 3, , "AT&FV0S0=0S122=6<cr>"
HKR,Init, 3, , "AT&S0&R1-K0S0=0S6=3S7=60S95=47<cr>"
HKR,Init, 3, , "AT\N3\Q3\V1\J0%%C1<cr>"
HKR,Init, 3, , "AT+FCLASS=0<cr>"
HKR,Init, 3, , "AT<cr>"
HKR,Init, 3, , "ATB0<cr>"
HKR,Init, 3, , "ATB00S80.6=1<cr>"
HKR,Init, 3, , "ATB04CL125<cr>"
HKR,Init, 3, , "ATB17S119.4=0S80.6=1<cr>"
HKR,Init, 3, , "ATB18S119.4=1S80.6=1<cr>"
HKR,Init, 3, , "ATB19S80.6=1<cr>"
HKR,Init, 3, , "ATB20S80.6=1<cr>"
HKR,Init, 3, , "ATB40<cr>"
HKR,Init, 3, , "ATB41<cr>"
HKR,Init, 3, , "ATE0V1<cr>"
HKR,Init, 3, , "ATE0V1B1<cr>"
HKR,Init, 3, , "ATE0W1V1<cr>"
HKR,Init, 3, , "ATS48.2=1S11=90<cr>"
HKR,Init, 3, , "ATV1\V1<cr>"
HKR,Init, 3, , "ATW2 <cr>"
HKR,Init, 3, , "ATW2\Q3 <cr>"
HKR,Init, 3, , "ATX3\J0\N3\Q3%%C1"
HKR,Init, 3, , "ATY0L3&C1&D2&S1&R\Q3\V1S39=32S95=47V1E0 <cr>"
HKR,Init, 4, , "AT &C1 &D2 \V1<cr>"
HKR,Init, 4, , "AT &C1 &D2 <cr>"
HKR,Init, 4, , "AT &C1 &D2 S95=47<cr>"
HKR,Init, 4, , "AT &D2 &S0 \J0 \V1 S95=47<cr>"
HKR,Init, 4, , "AT &D2 &S0 X4 %%C1 \J0 \N7 \Q3 \V1 \T0 <cr>"
HKR,Init, 4, , "AT &O6<cr>"
HKR,Init, 4, , "AT &O7<cr>"
HKR,Init, 4, , "AT E0 S0=0 T V1 S95=45 \N3 %%C3<cr>"
HKR,Init, 4, , "AT E0 S0=0 T V1<cr>"
HKR,Init, 4, , "AT E0 V1 &C1 &D2 Q0 &B1 &A3<cr>"
HKR,Init, 4, , "AT E0 V1 Q0 T<cr>"
HKR,Init, 4, , "AT F0 &C1 &D2<cr>"
HKR,Init, 4, , "AT F0 N1 &C1 &D2 \N3<cr>"
HKR,Init, 4, , "AT S0=0 S7=50 +Q1<cr>"
HKR,Init, 4, , "AT S112=32<cr>"
HKR,Init, 4, , "AT S49.7=1<cr>"
HKR,Init, 4, , "AT S9=100 S10=200 <cr>"
HKR,Init, 4, , "AT W1 S7=50 X4<cr>"
HKR,Init, 4, , "AT W2 \V1<cr>"
HKR,Init, 4, , "AT&L1S43.3=1S48.2=1<cr>"
HKR,Init, 5, , "AT S0=0 S95=45<cr>"
HKR,Init, 5, , "ATS110.4=1<cr>"
HKR,Init, 5, , "ATS84.4=1S104=1S108=2<cr>"
HKR,Init, 6, , "AT &O1<cr>"
HKR,Init, 6, , "AT &O7<cr>"
HKR,Init, 6, , "AT&J3S100=0<cr>"
HKR,Init, 6, , "AT&J3S100=1<cr>"
HKR,Init, 6, , "AT&L0S118.5=1S111.0=1S118.6=0<cr>"
HKR,Init, 7, , "AT S0=0 S95=45<cr>"
HKR,Init, 7, , "AT S112=32<cr>"
HKR,Init, 8, , "AT &O1<cr>"
HKR,Init, 8, , "AT S0=0 S95=45<cr>"
HKR,Init, 8, , "AT S111=7<cr>"
HKR,Init, 9, , "AT S0=0 S95=45 \N3 %%C3<cr>"
HKR,Init, 9, , "AT S112=32<cr>"
HKR,LineSetPlayFormat, 1, , "at#vls=0<cr>"
HKR,LineSetPlayFormat, 1, , "at#vsr=9600<cr>"
HKR,LineSetPlayFormat, 1, , "None"
HKR,LineSetPlayFormat, 2, , "at#vsm=AD4<cr>"
HKR,LineSetPlayFormat, 2, , "NoResponse"
HKR,LineSetRecordFormat, 1, , "at#vsr=9600<cr>"
HKR,LineSetRecordFormat, 1, , "None"
HKR,LineSetRecordFormat, 2, , "at#vsm=AD4<cr>"
HKR,LineSetRecordFormat, 2, , "NoResponse"
HKR,Monitor, 1, , "ATS0=0 <cr>"
HKR,Monitor, 1, , "ATS0=0<cr>"
HKR,Monitor, 1, , "ATS0=1<cr>"
HKR,Monitor, 1, , "ATZ<cr>"
HKR,Monitor, 1, , "None"
HKR,Monitor, 2, , "None"
HKR,MonitorVoiceViewOff, 1, , "AT+FCLASS=0<cr>"
HKR,MonitorVoiceViewOff, 2, , "None"
HKR,MonitorVoiceViewOn, 1, , "AT+FCLASS=80<cr>"
HKR,MonitorVoiceViewOn, 2, , "None"
HKR,OpenHandset, 1, , "at#cls=8<cr>"
HKR,OpenHandset, 1, , "at#vcl=1<cr>"
HKR,OpenHandset, 2, , "at#vln=2<cr>"
HKR,OpenHandset, 2, , "at#vls=1<cr>"
HKR,OpenHandset, 2, , "at#vls=2<cr>"
HKR,Override, 0000, 1, 00, 04, 00, 00, 00, 00, 00, 00, \
HKR,Override, 0000, 1, 00, 04, 00, 00, 00, 20, 00, 00, \
HKR,Override, 0001, 1, 00, 04, 00, 00, 00, 00, 00, 00, \
HKR,Override, 0001, 1, 00, 04, 00, 00, 00, 20, 00, 00, \
HKR,Override, 0002, 1, 00, 04, 00, 00, 00, 00, 00, 00, \
HKR,Override, 0002, 1, 00, 04, 00, 00, 00, 20, 00, 00, \
HKR,Override, 0003, 1, 00, 04, 00, 00, 00, 00, 00, 00, \
HKR,Override, 0003, 1, 00, 04, 00, 00, 00, 20, 00, 00, \
HKR,Override, 0004, 1, 00, 04, 00, 00, 00, 00, 00, 00, \
HKR,Override, 0004, 1, 00, 04, 00, 00, 00, 20, 00, 00, \
HKR,Override, 0005, 1, 00, 04, 00, 00, 00, 00, 00, 00, \
HKR,Override, 0005, 1, 00, 04, 00, 00, 00, 20, 00, 00, \
HKR,Override, 0006, 1, 00, 04, 00, 00, 00, 00, 00, 00, \
HKR,Override, 0006, 1, 00, 04, 00, 00, 00, 20, 00, 00, \
HKR,Override, 0007, 1, 00, 04, 00, 00, 00, 00, 00, 00, \
HKR,Override, 0007, 1, 00, 04, 00, 00, 00, 20, 00, 00, \
HKR,Override, 0008, 1, 00, 04, 00, 00, 00, 50, 00, 00, \
HKR,Settings, Blind_Off, ,
HKR,Settings, Blind_Off, , ""
HKR,Settings, Blind_Off, , "*BD2S6=0"
HKR,Settings, Blind_Off, , "S41.4=0"
HKR,Settings, Blind_Off, , "X1"
HKR,Settings, Blind_Off, , "X2"
HKR,Settings, Blind_Off, , "X3"
HKR,Settings, Blind_Off, , "X4"
HKR,Settings, Blind_Off, , "X5"
HKR,Settings, Blind_Off, , "X7"
HKR,Settings, Blind_On, ,
HKR,Settings, Blind_On, , ""
HKR,Settings, Blind_On, , "S41.4=1"
HKR,Settings, Blind_On, , "X0"
HKR,Settings, Blind_On, , "X1"
HKR,Settings, Blind_On, , "X3"
HKR,Settings, Blind_On, , "X3S6=0"
HKR,Settings, CallSetupFailTimer, ,
HKR,Settings, CallSetupFailTimer, , " "
HKR,Settings, CallSetupFailTimer, , ""
HKR,Settings, CallSetupFailTimer, , "S10=<#>"
HKR,Settings, CallSetupFailTimer, , "S7=<#>"
HKR,Settings, CallSetupFailTimer, , "S7=30"
HKR,Settings, CallSetupFailTimer, , "S7=40"
HKR,Settings, CallSetupFailTimer, , "S7=60"
HKR,Settings, Cellular_Off, ,
HKR,Settings, Cellular_Off, , "-K0"
HKR,Settings, Cellular_Off, , "-K0)M0"
HKR,Settings, Cellular_Off, , "-K0)M1"
HKR,Settings, Cellular_Off, , ")M0"
HKR,Settings, Cellular_Off, , "S10=28\N3F0*V53=3&C1*V73=13"
HKR,Settings, Cellular_Off, , "S43.3=1"
HKR,Settings, Cellular_On, ,
HKR,Settings, Cellular_On, , "-K1"
HKR,Settings, Cellular_On, , "-K1)M1"
HKR,Settings, Cellular_On, , "-K1)M1*H0"
HKR,Settings, Cellular_On, , ")M1"
HKR,Settings, Cellular_On, , "S10=254\N5F3*V53=0&C3*V73=40"
HKR,Settings, Cellular_On, , "S43.3=0"
HKR,Settings, Compression_Off, , ""
HKR,Settings, Compression_Off, , """H0"
HKR,Settings, Compression_Off, , """H0%%C0"
HKR,Settings, Compression_Off, , "$C0"
HKR,Settings, Compression_Off, , "%%A2=1&U0"
HKR,Settings, Compression_Off, , "%%C"
HKR,Settings, Compression_Off, , "%%C0 S101=0"
HKR,Settings, Compression_Off, , "%%C0 S46=136"
HKR,Settings, Compression_Off, , "%%C0"
HKR,Settings, Compression_Off, , "%%C0""H0-J0"
HKR,Settings, Compression_Off, , "%%C0""H0"
HKR,Settings, Compression_Off, , "%%C0\N6"
HKR,Settings, Compression_Off, , "%%C0S46=0"
HKR,Settings, Compression_Off, , "%%C0S46=136"
HKR,Settings, Compression_Off, , "%%C1"
HKR,Settings, Compression_Off, , "%C0"
HKR,Settings, Compression_Off, , "&E14"
HKR,Settings, Compression_Off, , "&K0"
HKR,Settings, Compression_Off, , "&K3"
HKR,Settings, Compression_Off, , "&Q0"
HKR,Settings, Compression_Off, , "&Q6"
HKR,Settings, Compression_Off, , "&Q8S46=136"
HKR,Settings, Compression_Off, , "&U0"
HKR,Settings, Compression_Off, , "*DC0"
HKR,Settings, Compression_Off, , "*E0"
HKR,Settings, Compression_Off, , "*E5"
HKR,Settings, Compression_Off, , "\C0"
HKR,Settings, Compression_Off, , "\M1"
HKR,Settings, Compression_Off, , "\M1\C4"
HKR,Settings, Compression_Off, , "\N0"
HKR,Settings, Compression_Off, , "\P0"
HKR,Settings, Compression_Off, , "L0"
HKR,Settings, Compression_Off, , "S190=0"
HKR,Settings, Compression_Off, , "S198=0S96=0"
HKR,Settings, Compression_Off, , "S46=0"
HKR,Settings, Compression_Off, , "S46=136"
HKR,Settings, Compression_Off, , "S46=136%%C0"
HKR,Settings, Compression_Off, , "S98=0 S96=0"
HKR,Settings, Compression_On, , ""
HKR,Settings, Compression_On, , """H3"
HKR,Settings, Compression_On, , """H3%%C1"
HKR,Settings, Compression_On, , "$C1"
HKR,Settings, Compression_On, , "%%A2=2&U1"
HKR,Settings, Compression_On, , "%%C1 S101=35"
HKR,Settings, Compression_On, , "%%C1 S46=138"
HKR,Settings, Compression_On, , "%%C1"
HKR,Settings, Compression_On, , "%%C1""H3-J1"
HKR,Settings, Compression_On, , "%%C1""H3"
HKR,Settings, Compression_On, , "%%C1S46=138"
HKR,Settings, Compression_On, , "%%C1S46=2"
HKR,Settings, Compression_On, , "%%C2\N7"
HKR,Settings, Compression_On, , "%%C3 S46=138"
HKR,Settings, Compression_On, , "%%C3"
HKR,Settings, Compression_On, , "%%C3""H3"
HKR,Settings, Compression_On, , "%%C3S46=138"
HKR,Settings, Compression_On, , "%C3"
HKR,Settings, Compression_On, , "&E15"
HKR,Settings, Compression_On, , "&K1"
HKR,Settings, Compression_On, , "&K4"
HKR,Settings, Compression_On, , "&K4&K44"
HKR,Settings, Compression_On, , "&Q5"
HKR,Settings, Compression_On, , "&Q5S36=7S46=138S48=7"
HKR,Settings, Compression_On, , "&U1"
HKR,Settings, Compression_On, , "*DC1"
HKR,Settings, Compression_On, , "*E1"
HKR,Settings, Compression_On, , "*E9"
HKR,Settings, Compression_On, , "\C1"
HKR,Settings, Compression_On, , "\M0"
HKR,Settings, Compression_On, , "\N1"
HKR,Settings, Compression_On, , "\N7"
HKR,Settings, Compression_On, , "\N7%%C1"
HKR,Settings, Compression_On, , "\P2"
HKR,Settings, Compression_On, , "L5"
HKR,Settings, Compression_On, , "S190=1"
HKR,Settings, Compression_On, , "S198=0S96=1S110=1"
HKR,Settings, Compression_On, , "S46=138"
HKR,Settings, Compression_On, , "S46=138%%C3"
HKR,Settings, Compression_On, , "S46=2"
HKR,Settings, Compression_On, , "S98=0 S96=0"
HKR,Settings, DialPrefix, , "CLIENT"
HKR,Settings, DialPrefix, , "D"
HKR,Settings, DialPrefix, , "DT"
HKR,Settings, DialSuffix, ,
HKR,Settings, DialSuffix, , ""
HKR,Settings, DialSuffix, , "";""
HKR,Settings, DialSuffix, , ";"
HKR,Settings, ErrorControl_Cellular, , "-K1"
HKR,Settings, ErrorControl_Cellular, , "-K1)M1"
HKR,Settings, ErrorControl_Cellular, , "-K1)M1*H0"
HKR,Settings, ErrorControl_Cellular, , "&F1"
HKR,Settings, ErrorControl_Cellular, , "&F5 &I14"
HKR,Settings, ErrorControl_Cellular, , "&F6 \N5 S91=1"
HKR,Settings, ErrorControl_Cellular, , "&F6 \N5"
HKR,Settings, ErrorControl_Cellular, , "&F6 \N7"
HKR,Settings, ErrorControl_Cellular, , "&M4 &L2 S10=30"
HKR,Settings, ErrorControl_Cellular, , "&Q5S36=7S48=7)M1\N3"
HKR,Settings, ErrorControl_Cellular, , ")M1"
HKR,Settings, ErrorControl_Cellular, , "\N2)M1:E0@M18*H1"
HKR,Settings, ErrorControl_Cellular, , "\N3-K1S36=7S48=7"
HKR,Settings, ErrorControl_Cellular, , "\N3 -K1 )M *H2 :E0 S10=50"
HKR,Settings, ErrorControl_Cellular, , "\N3 -K1 )M1 -Q1 *H0 :E1"
HKR,Settings, ErrorControl_Cellular, , "\N3 -K1 )M1 -Q1 *H1 :E1"
HKR,Settings, ErrorControl_Cellular, , "\N3 -K1 )M1 -Q1 *H1"
HKR,Settings, ErrorControl_Cellular, , "\N3 -K1 )M1 -Q2 *H1 ""M1"
HKR,Settings, ErrorControl_Cellular, , "\N3 -K1 )M1 %%C3 -Q0 S46=138"
HKR,Settings, ErrorControl_Cellular, , "\N3 -K1 )M1 *H1"
HKR,Settings, ErrorControl_Cellular, , "\N3 -K1 )M1 *H2 %%C1 -Q2 S46=138"
HKR,Settings, ErrorControl_Cellular, , "\N3 -K1 )M1 *H2 %%C3 -Q1 S46=138"
HKR,Settings, ErrorControl_Cellular, , "\N3 -K1 )M1 *H2 %%C3 -Q1"
HKR,Settings, ErrorControl_Cellular, , "\N3 -K1 )M1"
HKR,Settings, ErrorControl_Cellular, , "\N3 -K2 )M1"
HKR,Settings, ErrorControl_Cellular, , "\N3 -SEC=1"
HKR,Settings, ErrorControl_Cellular, , "\N3 $M1 -K2 )M1"
HKR,Settings, ErrorControl_Cellular, , "\N3 &Q5 -K1 *H1 )M1 -C1 -Q0"
HKR,Settings, ErrorControl_Cellular, , "\N3 )M1 -K1 -Q1 *H1 :E0 &Q5"
HKR,Settings, ErrorControl_Cellular, , "\N3 )M1 -K1 -Q1 *H1 :E0"
HKR,Settings, ErrorControl_Cellular, , "\N3 )M1 -K1 :E0 @M18 *H1 S48=7 S36=7"
HKR,Settings, ErrorControl_Cellular, , "\N3 )M1 *H0 -K1 -Q1 :E1 @M0"
HKR,Settings, ErrorControl_Cellular, , "\N3 )M1 *H1 -K1 -Q1 @M0 :E1"
HKR,Settings, ErrorControl_Cellular, , "\N3 )M1 *H2 -K2 -Q1 @M18 :E0"
HKR,Settings, ErrorControl_Cellular, , "\N3 )M1"
HKR,Settings, ErrorControl_Cellular, , "\N3&Q5)M1-K1*H1"
HKR,Settings, ErrorControl_Cellular, , "\N3)M1"
HKR,Settings, ErrorControl_Cellular, , "\N3S48=7S36=7-K1"
HKR,Settings, ErrorControl_Cellular, , "\N3S48=7S36=7 -K1"
HKR,Settings, ErrorControl_Cellular, , "\N5)M1-K1-Q1:E0@M18*H1"
HKR,Settings, ErrorControl_Cellular, , "\N5)M1:E0@M18*H1"
HKR,Settings, ErrorControl_Cellular, , "\N7 -K1 -C0 -J1 -K1 -Q1 *H2"
HKR,Settings, ErrorControl_Cellular, , "\N7 -K1 )M1 -Q1 *H1"
HKR,Settings, ErrorControl_Cellular, , "\N7 &F6 S0=0 &D2 E0 V1"
HKR,Settings, ErrorControl_Cellular, , "\N7 )M1 *H1 -K1 -Q1"
HKR,Settings, ErrorControl_Cellular, , "\N7 )M1 *H1"
HKR,Settings, ErrorControl_Cellular, , "\N7&J2S7=90S10=60"
HKR,Settings, ErrorControl_Cellular, , "+MS=10, 1, 4800, 14400 S10=50"
HKR,Settings, ErrorControl_Cellular, , "F6 S10=50"
HKR,Settings, ErrorControl_Cellular, , "S43.3=0S57.5=1&K3*E0"
HKR,Settings, ErrorControl_Cellular, , "S48=7-K1)M1"
HKR,Settings, ErrorControl_Cellular, , "S48=7 S36=7 -K1"
HKR,Settings, ErrorControl_Cellular_Forced, , "-K0"
HKR,Settings, ErrorControl_Cellular_Forced, , "-K0)M0"
HKR,Settings, ErrorControl_Cellular_Forced, , "-K1)M1"
HKR,Settings, ErrorControl_Cellular_Forced, , "&F1\N2"
HKR,Settings, ErrorControl_Cellular_Forced, , "&F6 \N4 S91=1"
HKR,Settings, ErrorControl_Cellular_Forced, , "&F6 \N4"
HKR,Settings, ErrorControl_Cellular_Forced, , "&F6 \N6"
HKR,Settings, ErrorControl_Cellular_Forced, , "&M5 &L2 S10=30"
HKR,Settings, ErrorControl_Cellular_Forced, , "&Q5S36=4S48=7)M1\N2"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2-K1S36=0S48=7"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 -K1 )M *H2 :E0 S10=50"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 -K1 )M1 -Q1 *H0 :E1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 -K1 )M1 -Q1 *H1 :E1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 -K1 )M1 -Q1 *H1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 -K1 )M1 %%C3 -Q0 S46=138"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 -K1 )M1 *H1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 -K1 )M1 *H2 %%C1 -Q2 S46=138""
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 -K1 )M1 *H2 %%C3 -Q1 S46=138"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 -K1 )M1 *H2 %%C3 -Q1""
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 -K1 )M1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 -SEC=1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 )M1 -K1 -Q1 *H1 :E0 &Q5"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 )M1 -K1 -Q1 *H1 :E0"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 )M1 -K1 :E0 @M18 *H1 S48=7 S36=0"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 )M1 *H0 -K1 -Q1 :E1 @M0"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 )M1 *H1 -K1 -Q1 @M0 :E1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 )M1 *H2 -K2 -Q1 @M18 :E0"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2 )M1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2&Q5)M1-K1*H1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2)M1-K1-Q1:E0@M18*H1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2S48=128S36=4-K1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N2S48=128S36=4 -K1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N4-K1)M1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N4 -K1 )M1 -Q1 *H1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N4 -K1 )M1 -Q2 *H1 ""M1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N4 $M1 W1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N4 &Q5 -K1 *H1 )M1 -C1 -Q0"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N4 W1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N4)M1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N6 -K1 -C0 -J1 -K1 -Q1 *H2"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N6 -K1 )M1 -Q1 *H1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N6 &F6 S0=0 &D2 E0 V1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N6 )M1 *H1 -K1 -Q1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N6 )M1 *H1"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N6&J2S7=90S10=60"
HKR,Settings, ErrorControl_Cellular_Forced, , "\N6)M1:E0@M18*H1"
HKR,Settings, ErrorControl_Cellular_Forced, , "+MS=10, 1, 4800, 14400 S10=10"
HKR,Settings, ErrorControl_Cellular_Forced, , "F6 S10=10"
HKR,Settings, ErrorControl_Cellular_Forced, , "S43.3=0S57.5=1&K3*E1"
HKR,Settings, ErrorControl_Cellular_Forced, , "S48=0 \N4 &F5 &I14"
HKR,Settings, ErrorControl_Cellular_Forced, , "S48=128 S36=4 -K1"
HKR,Settings, ErrorControl_Cellular_Forced_ON, , "-K1"
HKR,Settings, ErrorControl_Cellular_Forced_ON, , "-K1)M1"
HKR,Settings, ErrorControl_Cellular_Forced_ON, , "-K1)M1*H0"
HKR,Settings, ErrorControl_Cellular_Forced_ON, , ")M1"
HKR,Settings, ErrorControl_Cellular_Off, , "-K0"
HKR,Settings, ErrorControl_Cellular_Off, , "-K0)M0"
HKR,Settings, ErrorControl_Cellular_Off, , "M0"
HKR,Settings, ErrorControl_Cellular_ON, , "-K1"
HKR,Settings, ErrorControl_Cellular_ON, , "-K1)M1"
HKR,Settings, ErrorControl_Cellular_ON, , "-K1)M1*H0"
HKR,Settings, ErrorControl_Cellular_ON, , ")M1"
HKR,Settings, ErrorControl_Forced, , ""
HKR,Settings, ErrorControl_Forced, , "$E4"
HKR,Settings, ErrorControl_Forced, , "&B49\N6"
HKR,Settings, ErrorControl_Forced, , "&E2"
HKR,Settings, ErrorControl_Forced, , "&E3"
HKR,Settings, ErrorControl_Forced, , "&K3*E1"
HKR,Settings, ErrorControl_Forced, , "&K4*E1"
HKR,Settings, ErrorControl_Forced, , "&M5"
HKR,Settings, ErrorControl_Forced, , "&Q0"
HKR,Settings, ErrorControl_Forced, , "&Q5 S36=4 S48=7"
HKR,Settings, ErrorControl_Forced, , "&Q5\N2"
HKR,Settings, ErrorControl_Forced, , "&Q5\N4"
HKR,Settings, ErrorControl_Forced, , "&Q5S36=4S48=128"
HKR,Settings, ErrorControl_Forced, , "&Q5S36=4S48=7"
HKR,Settings, ErrorControl_Forced, , "&Q5S36=4S48=7\N2"
HKR,Settings, ErrorControl_Forced, , "&Q6 S36=0"
HKR,Settings, ErrorControl_Forced, , "*E5"
HKR,Settings, ErrorControl_Forced, , "*E6"
HKR,Settings, ErrorControl_Forced, , "*SM2"
HKR,Settings, ErrorControl_Forced, , "\E1\P2\N2"
HKR,Settings, ErrorControl_Forced, , "\J0\N4"
HKR,Settings, ErrorControl_Forced, , "\N1"
HKR,Settings, ErrorControl_Forced, , "\N1\P2"
HKR,Settings, ErrorControl_Forced, , "\N10"
HKR,Settings, ErrorControl_Forced, , "\N11"
HKR,Settings, ErrorControl_Forced, , "\N2-J1"
HKR,Settings, ErrorControl_Forced, , "\N2-K0S36=4S48=7"
HKR,Settings, ErrorControl_Forced, , "\N2 S48=7 S36=4"
HKR,Settings, ErrorControl_Forced, , "\N2"
HKR,Settings, ErrorControl_Forced, , "\N2*Y0"
HKR,Settings, ErrorControl_Forced, , "\N2S48=128S36=4"
HKR,Settings, ErrorControl_Forced, , "\N3"
HKR,Settings, ErrorControl_Forced, , "\N4-J1"
HKR,Settings, ErrorControl_Forced, , "\N4"
HKR,Settings, ErrorControl_Forced, , "\N5"
HKR,Settings, ErrorControl_Forced, , "\N6"
HKR,Settings, ErrorControl_Forced, , "\N6S48=128S36=4"
HKR,Settings, ErrorControl_Forced, , "L4"
HKR,Settings, ErrorControl_Forced, , "S106=0S97=1S95=1S66=1"
HKR,Settings, ErrorControl_Forced, , "S180=1 S181=2"
HKR,Settings, ErrorControl_Forced, , "S180=2 S181=2"
HKR,Settings, ErrorControl_Forced, , "S180=2S181=2"
HKR,Settings, ErrorControl_Forced, , "S48=0 \N4"
HKR,Settings, ErrorControl_Forced, , "S48=128 S36=4"
HKR,Settings, ErrorControl_Forced, , "S95=1"
HKR,Settings, ErrorControl_Off, , ""
HKR,Settings, ErrorControl_Off, , "$E"
HKR,Settings, ErrorControl_Off, , "$E0"
HKR,Settings, ErrorControl_Off, , "%%A2=1"
HKR,Settings, ErrorControl_Off, , "&B34\N0"
HKR,Settings, ErrorControl_Off, , "&E0"
HKR,Settings, ErrorControl_Off, , "&K0"
HKR,Settings, ErrorControl_Off, , "&M0"
HKR,Settings, ErrorControl_Off, , "&Q0"
HKR,Settings, ErrorControl_Off, , "&Q0\N0"
HKR,Settings, ErrorControl_Off, , "&Q0\N1"
HKR,Settings, ErrorControl_Off, , "&Q5S36=3S48=7"
HKR,Settings, ErrorControl_Off, , "&Q5S46=136"
HKR,Settings, ErrorControl_Off, , "&Q5S48=128"
HKR,Settings, ErrorControl_Off, , "&Q6 S36=3 S48=128"
HKR,Settings, ErrorControl_Off, , "&Q6"
HKR,Settings, ErrorControl_Off, , "&Q6\N"
HKR,Settings, ErrorControl_Off, , "&Q6S36=3S48=128"
HKR,Settings, ErrorControl_Off, , "&Q6S36=3S48=128\N0"
HKR,Settings, ErrorControl_Off, , "*E0"
HKR,Settings, ErrorControl_Off, , "*SM0"
HKR,Settings, ErrorControl_Off, , "*SM1"
HKR,Settings, ErrorControl_Off, , "\J1\N1"
HKR,Settings, ErrorControl_Off, , "\N"
HKR,Settings, ErrorControl_Off, , "\N0-J0"
HKR,Settings, ErrorControl_Off, , "\N0-K0S36=3S48=128"
HKR,Settings, ErrorControl_Off, , "\N0 S48=128 S36=3"
HKR,Settings, ErrorControl_Off, , "\N0"
HKR,Settings, ErrorControl_Off, , "\N0S48=128"
HKR,Settings, ErrorControl_Off, , "\N0S48=128S36=3"
HKR,Settings, ErrorControl_Off, , "\N1"
HKR,Settings, ErrorControl_Off, , "\P0"
HKR,Settings, ErrorControl_Off, , "L0"
HKR,Settings, ErrorControl_Off, , "S106=0S97=0S95=0"
HKR,Settings, ErrorControl_Off, , "S180=0 S181=1"
HKR,Settings, ErrorControl_Off, , "S180=0"
HKR,Settings, ErrorControl_Off, , "S180=0S181=1"
HKR,Settings, ErrorControl_Off, , "S48=128 S36=3"
HKR,Settings, ErrorControl_Off, , "S95=0 S66=1 S97=0"
HKR,Settings, ErrorControl_On, , ""
HKR,Settings, ErrorControl_On, , "$E3"
HKR,Settings, ErrorControl_On, , "%%A2=2"
HKR,Settings, ErrorControl_On, , "&B49\N3"
HKR,Settings, ErrorControl_On, , "&E1"
HKR,Settings, ErrorControl_On, , "&K3*E0"
HKR,Settings, ErrorControl_On, , "&K4"
HKR,Settings, ErrorControl_On, , "&K5S36=7S46=136S48=138"
HKR,Settings, ErrorControl_On, , "&M4"
HKR,Settings, ErrorControl_On, , "&Q5 S36=7 S48=7"
HKR,Settings, ErrorControl_On, , "&Q5"
HKR,Settings, ErrorControl_On, , "&Q5\N3"
HKR,Settings, ErrorControl_On, , "&Q5S36=7S46=136S48=128"
HKR,Settings, ErrorControl_On, , "&Q5S36=7S48=7"
HKR,Settings, ErrorControl_On, , "&Q5S36=7S48=7\N3"
HKR,Settings, ErrorControl_On, , "&Q6"
HKR,Settings, ErrorControl_On, , "&Q9"
HKR,Settings, ErrorControl_On, , "*E5"
HKR,Settings, ErrorControl_On, , "*E9"
HKR,Settings, ErrorControl_On, , "*SM3"
HKR,Settings, ErrorControl_On, , "\E1\P2\N3"
HKR,Settings, ErrorControl_On, , "\J0\N3"
HKR,Settings, ErrorControl_On, , "\N0"
HKR,Settings, ErrorControl_On, , "\N11"
HKR,Settings, ErrorControl_On, , "\N2"
HKR,Settings, ErrorControl_On, , "\N3-J1"
HKR,Settings, ErrorControl_On, , "\N3-K0S36=7S48=7"
HKR,Settings, ErrorControl_On, , "\N3 -J1"
HKR,Settings, ErrorControl_On, , "\N3 S48=7 S36=7"
HKR,Settings, ErrorControl_On, , "\N3"
HKR,Settings, ErrorControl_On, , "\N3*Y0"
HKR,Settings, ErrorControl_On, , "\N3\P2"
HKR,Settings, ErrorControl_On, , "\N3S48=7S36=7"
HKR,Settings, ErrorControl_On, , "\N4"
HKR,Settings, ErrorControl_On, , "\N5"
HKR,Settings, ErrorControl_On, , "\N6"
HKR,Settings, ErrorControl_On, , "\N7"
HKR,Settings, ErrorControl_On, , "\N7S48=7S36=7"
HKR,Settings, ErrorControl_On, , "L4"
HKR,Settings, ErrorControl_On, , "S106=1 S97=1 S66=2 S95=2"
HKR,Settings, ErrorControl_On, , "S106=1S95=2S97=0S66=2"
HKR,Settings, ErrorControl_On, , "S180=1 S181=1"
HKR,Settings, ErrorControl_On, , "S180=2 S181=1"
HKR,Settings, ErrorControl_On, , "S180=2S181=1"
HKR,Settings, ErrorControl_On, , "S180=3S181=1"
HKR,Settings, ErrorControl_On, , "S48=7 S36=7"
HKR,Settings, ErrorControl_On, , "S48=7"
HKR,Settings, FlowControl_Hard, ,
HKR,Settings, FlowControl_Hard, , ""
HKR,Settings, FlowControl_Hard, , "$F4"
HKR,Settings, FlowControl_Hard, , "$F5"
HKR,Settings, FlowControl_Hard, , "&E4"
HKR,Settings, FlowControl_Hard, , "&E6"
HKR,Settings, FlowControl_Hard, , "&H1&I0&R2"
HKR,Settings, FlowControl_Hard, , "&H1&R2&B1&I0"
HKR,Settings, FlowControl_Hard, , "&H1&R2&I0"
HKR,Settings, FlowControl_Hard, , "&H3"
HKR,Settings, FlowControl_Hard, , "&K1"
HKR,Settings, FlowControl_Hard, , "&K3"
HKR,Settings, FlowControl_Hard, , "*F3"
HKR,Settings, FlowControl_Hard, , "*FL3"
HKR,Settings, FlowControl_Hard, , "\Q0"
HKR,Settings, FlowControl_Hard, , "\Q1"
HKR,Settings, FlowControl_Hard, , "\Q10"
HKR,Settings, FlowControl_Hard, , "\Q2"
HKR,Settings, FlowControl_Hard, , "\Q3"
HKR,Settings, FlowControl_Hard, , "\Q3\Q6"
HKR,Settings, FlowControl_Hard, , "S34=2"
HKR,Settings, FlowControl_Hard, , "S58=2 S68=255"
HKR,Settings, FlowControl_Hard, , "S58=2"
HKR,Settings, FlowControl_Off, ,
HKR,Settings, FlowControl_Off, , ""
HKR,Settings, FlowControl_Off, , "$F0"
HKR,Settings, FlowControl_Off, , "$F5"
HKR,Settings, FlowControl_Off, , "&E0"
HKR,Settings, FlowControl_Off, , "&E3"
HKR,Settings, FlowControl_Off, , "&E6"
HKR,Settings, FlowControl_Off, , "&H0"
HKR,Settings, FlowControl_Off, , "&H0&B0&R1"
HKR,Settings, FlowControl_Off, , "&H0&I0&R1"
HKR,Settings, FlowControl_Off, , "&H0&R1&I0"
HKR,Settings, FlowControl_Off, , "&K"
HKR,Settings, FlowControl_Off, , "&K0"
HKR,Settings, FlowControl_Off, , "&K2"
HKR,Settings, FlowControl_Off, , "*F0"
HKR,Settings, FlowControl_Off, , "*FL0"
HKR,Settings, FlowControl_Off, , "\Q"
HKR,Settings, FlowControl_Off, , "\Q0"
HKR,Settings, FlowControl_Off, , "S34=0"
HKR,Settings, FlowControl_Off, , "S58=0 S68=255"
HKR,Settings, FlowControl_Off, , "S58=0"
HKR,Settings, FlowControl_Soft, ,
HKR,Settings, FlowControl_Soft, , ""
HKR,Settings, FlowControl_Soft, , "$F"
HKR,Settings, FlowControl_Soft, , "$F0"
HKR,Settings, FlowControl_Soft, , "$F5"
HKR,Settings, FlowControl_Soft, , "&E4"
HKR,Settings, FlowControl_Soft, , "&E5"
HKR,Settings, FlowControl_Soft, , "&H2&B1&I2&R1"
HKR,Settings, FlowControl_Soft, , "&H2&I2&R1"
HKR,Settings, FlowControl_Soft, , "&H4"
HKR,Settings, FlowControl_Soft, , "&K1"
HKR,Settings, FlowControl_Soft, , "&K2"
HKR,Settings, FlowControl_Soft, , "&K4"
HKR,Settings, FlowControl_Soft, , "*F2"
HKR,Settings, FlowControl_Soft, , "*FL1"
HKR,Settings, FlowControl_Soft, , "\Q1"
HKR,Settings, FlowControl_Soft, , "\Q1\Q5"
HKR,Settings, FlowControl_Soft, , "\Q2"
HKR,Settings, FlowControl_Soft, , "\Q3"
HKR,Settings, FlowControl_Soft, , "\Q4"
HKR,Settings, FlowControl_Soft, , "\Q5"
HKR,Settings, FlowControl_Soft, , "S34=1"
HKR,Settings, FlowControl_Soft, , "S58=3 S68=255"
HKR,Settings, FlowControl_Soft, , "S58=3"
HKR,Settings, InactivityTimeout, ,
HKR,Settings, InactivityTimeout, , " "
HKR,Settings, InactivityTimeout, , ""
HKR,Settings, InactivityTimeout, , "*SI5S30=<#>"
HKR,Settings, InactivityTimeout, , "\t<#>"
HKR,Settings, InactivityTimeout, , "\T<#>"
HKR,Settings, InactivityTimeout, , "\T=<#>"
HKR,Settings, InactivityTimeout, , "+S8=<#>"
HKR,Settings, InactivityTimeout, , "S19=<#>"
HKR,Settings, InactivityTimeout, , "S30=<#>"
HKR,Settings, InactivityTimeout, , "S30=60"
HKR,Settings, InactivityTimeout, , "S36=<#>"
HKR,Settings, InactivityTimeout, , "S37=<#>"
HKR,Settings, InactivityTimeout, , "S40=<#>"
HKR,Settings, InactivityTimeout, , "S41=<#>"
HKR,Settings, InactivityTimeout, , "S50=<#>"
HKR,Settings, InactivityTimeout, , "S58=<#>"
HKR,Settings, InactivityTimeout, , "S9=<#>"
HKR,Settings, Modulation_Bell, ,
HKR,Settings, Modulation_Bell, , ""
HKR,Settings, Modulation_Bell, , "B0"
HKR,Settings, Modulation_Bell, , "B1 "
HKR,Settings, Modulation_Bell, , "B1 +MS=11, 1, 300, 28800"
HKR,Settings, Modulation_Bell, , "B1 B1"
HKR,Settings, Modulation_Bell, , "B1 B16"
HKR,Settings, Modulation_Bell, , "B1 F0"
HKR,Settings, Modulation_BELL, , "B1"
HKR,Settings, Modulation_Bell, , "B1"
HKR,Settings, Modulation_Bell, , "B1B16"
HKR,Settings, Modulation_Bell, , "B1F(i4)"
HKR,Settings, Modulation_Bell, , "B1F0"
HKR,Settings, Modulation_Bell, , "B1F1 B1F4"
HKR,Settings, Modulation_Bell, , "B1S37=5"
HKR,Settings, Modulation_Bell, , "B2"
HKR,Settings, Modulation_Bell, , "B90"
HKR,Settings, Modulation_CCITT, ,
HKR,Settings, Modulation_CCITT, , ""
HKR,Settings, Modulation_CCITT, , "B"
HKR,Settings, Modulation_CCITT, , "B0 "
HKR,Settings, Modulation_CCITT, , "B0 +MS=11, 1, 300, 28800"
HKR,Settings, Modulation_CCITT, , "B0 B0"
HKR,Settings, Modulation_CCITT, , "B0 B15"
HKR,Settings, Modulation_CCITT, , "B0 F0"
HKR,Settings, Modulation_CCITT, , "B0 S27=1"
HKR,Settings, Modulation_CCITT, , "B0"
HKR,Settings, Modulation_CCITT, , "B0B15"
HKR,Settings, Modulation_CCITT, , "B0F(I4)"
HKR,Settings, Modulation_CCITT, , "B0F0"
HKR,Settings, Modulation_CCITT, , "B99"
HKR,Settings, Modulation_CCITT, , "F0"
HKR,Settings, Modulation_CCITT, , "F1 F4"
HKR,Settings, Modulation_CCITT_V23, , "$MB75 "
HKR,Settings, Modulation_CCITT_V23, , "B0 +MS=3, 0, 1200, 1200"
HKR,Settings, Modulation_CCITT_V23, , "B0 B2 "
HKR,Settings, Modulation_CCITT_V23, , "B0 F3"
HKR,Settings, Modulation_CCITT_V23, , "B0"
HKR,Settings, Modulation_CCITT_V23, , "B18"
HKR,Settings, Modulation_CCITT_V23, , "F3"
HKR,Settings, Modulation_CCITT_V23, , "L2"
HKR,Settings, Modulation_CCITT_V23, , "S34=8"
HKR,Settings, Prefix, , "AT"
HKR,Settings, Pulse, ,
HKR,Settings, Pulse, , ""
HKR,Settings, Pulse, , "I"
HKR,Settings, Pulse, , "P"
HKR,Settings, Pulse, , "T"
HKR,Settings, SpeakerMode_Dial, ,
HKR,Settings, SpeakerMode_Dial, , "M1"
HKR,Settings, SpeakerMode_Off, ,
HKR,Settings, SpeakerMode_Off, , "M"
HKR,Settings, SpeakerMode_Off, , "M0"
HKR,Settings, SpeakerMode_On, ,
HKR,Settings, SpeakerMode_On, , "M2"
HKR,Settings, SpeakerMode_Setup, ,
HKR,Settings, SpeakerMode_Setup, , "M0"
HKR,Settings, SpeakerMode_Setup, , "M3"
HKR,Settings, SpeakerVolume_High, ,
HKR,Settings, SpeakerVolume_High, , ""
HKR,Settings, SpeakerVolume_High, , "L1"
HKR,Settings, SpeakerVolume_High, , "L2"
HKR,Settings, SpeakerVolume_High, , "L3"
HKR,Settings, SpeakerVolume_High, , "L7"
HKR,Settings, SpeakerVolume_High, , "S61=250"
HKR,Settings, SpeakerVolume_Low, ,
HKR,Settings, SpeakerVolume_Low, , ""
HKR,Settings, SpeakerVolume_Low, , "L"
HKR,Settings, SpeakerVolume_Low, , "L0"
HKR,Settings, SpeakerVolume_Low, , "L1"
HKR,Settings, SpeakerVolume_Low, , "S61=50"
HKR,Settings, SpeakerVolume_Med, ,
HKR,Settings, SpeakerVolume_Med, , ""
HKR,Settings, SpeakerVolume_Med, , "L1"
HKR,Settings, SpeakerVolume_Med, , "L2"
HKR,Settings, SpeakerVolume_Med, , "L4"
HKR,Settings, SpeakerVolume_Med, , "S61=150"
HKR,Settings, SpeedNegotiation_Off, ,
HKR,Settings, SpeedNegotiation_Off, , "-R1"
HKR,Settings, SpeedNegotiation_Off, , "!N0"
HKR,Settings, SpeedNegotiation_Off, , ""
HKR,Settings, SpeedNegotiation_Off, , "$M1"
HKR,Settings, SpeedNegotiation_Off, , "%%F0"
HKR,Settings, SpeedNegotiation_Off, , "%%N6"
HKR,Settings, SpeedNegotiation_Off, , "%%R"
HKR,Settings, SpeedNegotiation_Off, , "%G"
HKR,Settings, SpeedNegotiation_Off, , "&A0"
HKR,Settings, SpeedNegotiation_Off, , "&A1"
HKR,Settings, SpeedNegotiation_Off, , "&E0"
HKR,Settings, SpeedNegotiation_Off, , "&N1"
HKR,Settings, SpeedNegotiation_Off, , "*G0"
HKR,Settings, SpeedNegotiation_Off, , "*S0"
HKR,Settings, SpeedNegotiation_Off, , "\J0"
HKR,Settings, SpeedNegotiation_Off, , "+M0"
HKR,Settings, SpeedNegotiation_Off, , "+MS=11, 0, 300, 28800"
HKR,Settings, SpeedNegotiation_Off, , "+MS=74, 0, 300, 28800"
HKR,Settings, SpeedNegotiation_Off, , "B2"
HKR,Settings, SpeedNegotiation_Off, , "N"
HKR,Settings, SpeedNegotiation_Off, , "N0"
HKR,Settings, SpeedNegotiation_Off, , "N0S37=0"
HKR,Settings, SpeedNegotiation_Off, , "N1"
HKR,Settings, SpeedNegotiation_Off, , "S15=2"
HKR,Settings, SpeedNegotiation_Off, , "S50=254S94=0"
HKR,Settings, SpeedNegotiation_Off, , "S94=0"
HKR,Settings, SpeedNegotiation_On, ,
HKR,Settings, SpeedNegotiation_On, , "-R0"
HKR,Settings, SpeedNegotiation_On, , "!N2"
HKR,Settings, SpeedNegotiation_On, , ""
HKR,Settings, SpeedNegotiation_On, , "$M0"
HKR,Settings, SpeedNegotiation_On, , "%%F4%%R1"
HKR,Settings, SpeedNegotiation_On, , "%%N0"
HKR,Settings, SpeedNegotiation_On, , "%%R2"
HKR,Settings, SpeedNegotiation_On, , "%G1"
HKR,Settings, SpeedNegotiation_On, , "&A0"
HKR,Settings, SpeedNegotiation_On, , "&A1"
HKR,Settings, SpeedNegotiation_On, , "&E1"
HKR,Settings, SpeedNegotiation_On, , "&N0"
HKR,Settings, SpeedNegotiation_On, , "*G1"
HKR,Settings, SpeedNegotiation_On, , "*S1"
HKR,Settings, SpeedNegotiation_On, , "\J1"
HKR,Settings, SpeedNegotiation_On, , "+M2"
HKR,Settings, SpeedNegotiation_On, , "+M3"
HKR,Settings, SpeedNegotiation_On, , "+MS=11, 1, 300, 28800"
HKR,Settings, SpeedNegotiation_On, , "B0"
HKR,Settings, SpeedNegotiation_On, , "F0"
HKR,Settings, SpeedNegotiation_On, , "N0"
HKR,Settings, SpeedNegotiation_On, , "N1"
HKR,Settings, SpeedNegotiation_On, , "N1S37=0"
HKR,Settings, SpeedNegotiation_On, , "S15=0"
HKR,Settings, SpeedNegotiation_On, , "S35=7"
HKR,Settings, SpeedNegotiation_On, , "S50=0S94=1"
HKR,Settings, SpeedNegotiation_On, , "S50=6S94=1"
HKR,Settings, Terminator, , "<cr>"
HKR,Settings, Tone, ,
HKR,Settings, Tone, , ""
HKR,Settings, Tone, , "M"
HKR,Settings, Tone, , "T"
HKR,SpeakerPhoneDisable, 1, , "at#spk=0<cr>"
HKR,SpeakerPhoneDisable, 1, , "at#vls=0<cr>"
HKR,SpeakerPhoneDisable, 1, , "at#vls=6<cr>"
HKR,SpeakerPhoneDisable, 2, , "at#spk=0, 15, , <cr>"
HKR,SpeakerPhoneDisable, 3, , "at#vls=0<cr>"
HKR,SpeakerPhoneEnable, 1, , "at#spk=1<cr>"
HKR,SpeakerPhoneEnable, 1, , "at#vls=5<cr>"
HKR,SpeakerPhoneEnable, 1, , "at#vls=6<cr>"
HKR,SpeakerPhoneEnable, 2, , "ata<cr>"
HKR,SpeakerPhoneEnable, 3, , "at#vdx=0<cr>"
HKR,SpeakerPhoneMute, 1, , "at#vgm=1<cr>"
HKR,SpeakerPhoneMute, 1, , "at#vls=6<cr>"
HKR,SpeakerPhoneMute, 1, , "at<cr>"
HKR,SpeakerPhoneMute, 2, , "at#spk=0, , , <cr>"
HKR,SpeakerPhoneSetVolumeGain, 1, , "at#vgs=<Vol><cr>"
HKR,SpeakerPhoneSetVolumeGain, 1, , "at#vls=6<cr>"
HKR,SpeakerPhoneSetVolumeGain, 1, , "at<cr>"
HKR,SpeakerPhoneSetVolumeGain, 2, , "at#spk=, <Vol>, <Gain><cr>"
HKR,SpeakerPhoneUnMute, 1, , "at#vgm=128<cr>"
HKR,SpeakerPhoneUnMute, 1, , "at#vls=6<cr>"
HKR,SpeakerPhoneUnMute, 1, , "at<cr>"
HKR,SpeakerPhoneUnMute, 2, , "at#spk=1, , , <cr>"
HKR,StartPlay, 1, , "at#spk=0<cr>"
HKR,StartPlay, 1, , "at#vpy<cr>"
HKR,StartPlay, 1, , "at#vtx<cr>"
HKR,StartPlay, 2, , "ata<cr>"
HKR,StartPlay, 3, , "at+vgt=134<cr>"
HKR,StartPlay, 4, , "at#vtx<cr>"
HKR,StartRecord, 1, , "at#spk=0<cr>"
HKR,StartRecord, 1, , "at#vrd<cr>"
HKR,StartRecord, 1, , "at#vrx<cr>"
HKR,StartRecord, 2, , "ata<cr>"
HKR,StartRecord, 3, , "at+vgr=134<cr>"
HKR,StartRecord, 4, , "at#vrx<cr>"
HKR,StopPlay, 1, , "None"
HKR,StopPlay, 2, , "NoResponse"
HKR,StopRecord, 1, , "None"
HKR,StopRecord, 2, , "NoResponse"
HKR,VoiceAnswer, 1, , "at#cls=8<cr>"
HKR,VoiceAnswer, 1, , "at#vcl=1<cr>"
HKR,VoiceAnswer, 2, , "at#vln=1<cr>"
HKR,VoiceAnswer, 2, , "at#vls=0<cr>"
HKR,VoiceAnswer, 3, , "at#vbt=1<cr>"
HKR,VoiceAnswer, 3, , "at#vsr=7200<cr>"
HKR,VoiceAnswer, 4, , "at#vbs=4<cr>"
HKR,VoiceAnswer, 4, , "at#vsr=7200<cr>"
HKR,VoiceAnswer, 5, , "at#vbs=4<cr>"
HKR,VoiceAnswer, 5, , "ats30=60<cr>"
HKR,VoiceAnswer, 6, , "ata<cr>"
HKR,VoiceAnswer, 6, , "ats30=60<cr>"
HKR,VoiceAnswer, 7, , "ata<cr>"
HKR,VoiceDialNumberSetup, 1, , "at#cls=8<cr>"
HKR,VoiceDialNumberSetup, 1, , "at#vcl=1<cr>"
HKR,VoiceDialNumberSetup, 2, , "at#vln=17<cr>"
HKR,VoiceDialNumberSetup, 2, , "at#vls=0<cr>"
HKR,VoiceDialNumberSetup, 2, , "at#vls=4<cr>"
HKR,VoiceDialNumberSetup, 3, , "at#vrn=0<cr>"
HKR,VoiceDialNumberSetup, 3, , "atdt, ;<cr>"
HKR,VoiceDialNumberSetup, 4, , "at#vbt=1<cr>"
HKR,VoiceDialNumberSetup, 4, , "at#vsr=7200<cr>"
HKR,VoiceDialNumberSetup, 5, , "at#vbs=4<cr>"
HKR,VoiceDialNumberSetup, 5, , "at#vsr=7200<cr>"
HKR,VoiceDialNumberSetup, 6, , "at#vbs=4<cr>"
HKR,VoiceDialNumberSetup, 6, , "ats30=60<cr>"
HKR,VoiceDialNumberSetup, 7, , "ats30=60<cr>"
HKR,VoiceToDataAnswer, 1, , "at#cls=0<cr>"
HKR,VoiceToDataAnswer, 1, , "at#vcl=0<cr>"
HKR,VoiceToDataAnswer, 2, , "ata<cr>"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\inf\mdmplace.txt ===
# placefil.txt prototype for modem INF's
# Last update 10/20/98 JimSp
# Keep everything alphabetized for easy maintenance.
# Copy complete below and insert/replace the proper chunk in placefil.txt

#Drivers
# Verify placfil.txt has these entries in proper placement.

3cisaadi.sys	 retail
3cpxiadi.sys	 retail
3cwmcru.sys	 retail
hcf_msft.sys     retail
ltcpq5.sys	 retail
ltmdmnt.sys	 retail
ltmdmntt.sys	 retail
ltmodem5.sys	 retail
winacisa.sys	 retail
winmodem.sys	 retail

#INFs
# Copy complete below and insert/replace the proper chunk in placefil.txt

mdm3cisa.inf     retail
mdm3com.inf      retail
mdm3cpcm.inf     retail
mdm3cusb.inf     retail
mdm3x.inf        retail
mdm_rint.inf     retail ;JPN
mdmaceex.inf     retail
mdmadc.inf       retail
mdmairte.inf     retail
mdmaiwa.inf      retail ;JPN
mdmaiwa2.inf     retail ;JPN
mdmaiwa3.inf     retail ;JPN
mdmaiwat.inf     retail ;JPN
mdmalex.inf      retail ;JPN
mdmar1.inf       retail
mdmarch.inf      retail
mdmarcht.inf     retail
mdmarn.inf       retail
mdmati.inf       retail
mdmatkk.inf      retail ;JPN
mdmatt.inf       retail
mdmaus.inf       retail
mdmblatz.inf     retail
mdmboca.inf      retail
mdmbsb.inf       retail
mdmbsch.inf      retail
mdmbug.inf       retail ;JPN
mdmbug3.inf      retail ;JPN
mdmcm28.inf      retail
mdmcmcm.inf      retail
mdmcodex.inf     retail
mdmcom1.inf      retail
mdmcomm1.inf     retail
mdmcommu.inf     retail
mdmcomz.inf      retail ;JPN
mdmcpi.inf       retail
mdmcpq.inf       retail
mdmcpv.inf       retail
mdmcrtix.inf     retail
mdmctm1.inf      retail
mdmdcm2.inf      retail ;JPN
mdmdcm5.inf      retail ;JPN
mdmdefd.inf      retail
mdmdgitn.inf     retail
mdmdicom.inf     retail
mdmdigi.inf      retail
mdmdisco.inf     retail
mdmdp2.inf       retail ;JPN
mdmdsi.inf       retail
mdmdyna.inf      retail
mdmeiger.inf     retail
mdmelink.inf     retail
mdmelpro.inf     retail
mdmelsa.inf      retail
mdmeric.inf      retail
mdmeric2.inf     retail
mdmetech.inf     retail
mdmexp.inf       retail
mdmeyp.inf       retail
mdmfj.inf        retail ;JPN
mdmfj1.inf       retail ;JPN
mdmfj2.inf       retail ;JPN
mdmfjta1.inf     retail ;JPN
mdmgal.inf       retail
mdmgatew.inf     retail
mdmgcs.inf       retail
mdmgen.inf       retail
mdmgl001.inf     retail
mdmgl002.inf     retail
mdmgl003.inf     retail
mdmgl004.inf     retail
mdmgl005.inf     retail
mdmgl006.inf     retail
mdmgl007.inf     retail
mdmgl008.inf     retail
mdmgsm.inf       retail
mdmgv.inf        retail
mdmgvc.inf       retail
mdmhaeu.inf      retail
mdmhaeus.inf     retail
mdmhandy.inf     retail
mdmhay2.inf      retail
mdmhayes.inf     retail
mdmhcom1.inf     retail ;JPN
mdmhucom.inf     retail ;JPN
mdmibmj.inf      retail ;JPN
mdmico.inf       retail
mdminfot.inf     retail
mdminst.dll      retail
mdminsys.inf     retail
mdmintel.inf     retail
mdmintpc.inf     retail
mdmiodat.inf     retail ;JPN
mdmiodt2.inf     retail ;JPN
mdmisdn.inf      retail
mdmitex.inf      retail
mdmke.inf        retail
mdmkortx.inf     retail
mdmlasat.inf     retail
mdmlasno.inf     retail
mdmlce.inf       retail
mdmlight.inf     retail
mdmlngsh.inf     retail
mdmlt3.inf       retail
mdmmart.inf      retail
mdmmc144.inf     retail ;JPN
mdmmc24.inf      retail ;JPN
mdmmcom.inf      retail
mdmmega.inf      retail ;JPN
mdmmega2.inf     retail ;JPN
mdmmetri.inf     retail
mdmmhrtz.inf     retail
mdmmhza.inf      retail
mdmmhzel.inf     retail
mdmmhzk1.inf     retail
mdmmid.inf       retail ;JPN
mdmmix.inf       retail
mdmmn128.inf     retail ;JPN
mdmmod.inf       retail
mdmmoto.inf      retail
mdmmoto1.inf     retail
mdmmoton.inf     retail
mdmmotou.inf     retail
mdmmrit.inf      retail ;JPN
mdmmrl.inf       retail ;JPN
mdmmsint.inf     retail ;JPN
mdmmsoki.inf     retail ;JPN
mdmmspan.inf     retail ;JPN
mdmmtd.inf       retail
mdmmts.inf       retail
mdmmulog.inf     retail
mdmnec.inf       retail ;JPN
mdmnec98.inf     retail ;JPN
mdmnecom.inf     retail ;JPN
mdmnect2.inf     retail ;JPN
mdmnecta.inf     retail ;JPN
mdmneuhs.inf     retail
mdmnis.inf       retail ;JPN
mdmnj15.inf      retail ;JPN
mdmnj16.inf      retail ;JPN
mdmnokia.inf     retail
mdmnokno.inf     retail
mdmnova.inf      retail
mdmnovfx.inf     retail
mdmnttp.inf      retail ;JPN
mdmnttte.inf     retail ;JPN
mdmoki.inf       retail ;JPN
mdmoki2.inf      retail ;JPN
mdmokipl.inf     retail ;JPN
mdmokita.inf     retail ;JPN
mdmolic.inf      retail
mdmolive.inf     retail
mdmomrn2.inf     retail ;JPN
mdmomron.inf     retail ;JPN
mdmopt1.inf      retail
mdmoptn.inf      retail
mdmosi.inf       retail
mdmpace.inf      retail
mdmpana.inf      retail ;JPN
mdmpbit.inf      retail
mdmpenr.inf      retail
mdmphils.inf     retail
mdmpn1.inf       retail
mdmpnb.inf       retail
mdmpp.inf        retail
mdmprodm.inf     retail
mdmpsion.inf     retail
mdmracal.inf     retail
mdmrex.inf       retail ;JPN
mdmrfi.inf       retail
mdmrisa.inf      retail
mdmrock.inf      retail
mdmrock2.inf     retail
mdmrock3.inf     retail
mdmrock4.inf     retail
mdmrock5.inf     retail
mdmrpci.inf      retail
mdmsecdy.inf     retail
mdmsetup.inf     retail
mdmshrup.dll     winnt32\winntupg\ms\modemshr
mdmsier.inf      retail
mdmsimpl.inf     retail
mdmsmart.inf     retail
mdmsnit1.inf     retail
mdmsnitn.inf     retail
mdmsonix.inf     retail
mdmsony.inf      retail ;JPN
mdmsonyu.inf     retail ;JPN
mdmspec.inf      retail
mdmspq28.inf     retail
mdmsrt.inf       retail
mdmsun.inf       retail ;JPN
mdmsun1.inf      retail ;JPN
mdmsupr3.inf     retail
mdmsupra.inf     retail
mdmsuprv.inf     retail
mdmtaicm.inf     retail
mdmtdk.inf       retail
mdmtdkj.inf      retail ;JPN
mdmtdkj2.inf     retail ;JPN
mdmte2.inf       retail ;JPN
mdmtelbt.inf     retail
mdmtelin.inf     retail
mdmtelnk.inf     retail
mdmtexas.inf     retail
mdmtger.inf      retail
mdmti.inf        retail
mdmtkr.inf       retail
mdmtorn.inf      retail
mdmtosh.inf      retail
mdmtoshi.inf     retail ;JPN
mdmtripl.inf     retail
mdmtron.inf      retail
mdmtrust.inf     retail
mdmucom.inf      retail
mdmusrcr.inf     retail
mdmusrf.inf      retail
mdmusrg.inf      retail
mdmusrk1.inf     retail
mdmusrsp.inf     retail
mdmusrwp.inf     retail
mdmvayrs.inf     retail
mdmvdot.inf      retail
mdmvict.inf      retail
mdmvsa1.inf      retail
mdmvv.inf        retail
mdmwell.inf      retail
mdmwhql0.inf     retail
mdmwoer.inf      retail
mdmx5560.inf     retail
mdmyorik.inf     retail
mdmzoom.inf      retail
mdmzyp.inf       retail
mdmzyxel.inf     retail
mdmzyxld.inf     retail
mdmzyxlg.inf     retail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\modemui\notes.txt ===
10/25/1997 JosephJ
    Notes on the reorganization of modemui.

    The UI has been split into two: CPL and CFG.
    Files to do with CPL UI are named cpl*.*, and
    those to do with CFG UI are named cfg*.*.

    modemui.c still contains all the exported apis.



----------------------------------------
Settings (visible from control panel)

General: IDD_GENERAL
    Speaker Volume: IDC_VOLUME
    Maximum Port Speed: IDC_CB_SPEED
    Blind Dial: IDC_WAITFORDIALTONE

----------------------------------------

Diagnostics: IDD_DIAGNOSTICS
    IDC_MOREINFOV  -- commands
    IDC_MOREINFOV2 -- "static info"
    IDC_LOGGING
    IDC_VIEWLOG

----------------------------------------

Advanced: IDD_ADV_MODEM
    Extra Settings: IDC_AM_EXTRA_ED
    Default Properties: button that launches property pages to set
        IDC_BN_DEFAULTS
     Enable extensions checkbox:  IDC_CB_ENABLE_EXTENSIONS 

----------------------------------------

Properties: Called through lineConfigDialog or lineConfigDialogEdit ....
IDD_MDMSETTINGS
    IDC_CH_DIALTIMER; IDC_ED_DIALTIMER
    IDC_CH_IDLETIMER  IDC_ED_IDLETIMER
    IDC_TERMINAL_PRE  IDC_TERMINAL_POST
    IDC_MANUAL_DIAL 
    IDC_WAIT_SEC

----------------------------------------

IDD_DATAMODEM
    IDC_CB_EC
    IDC_CB_COMP
    IDC_CB_MOD
    IDC_CB_SPEED
    IDC_CB_FC
    IDC_CB_DATABITS
    IDC_CB_PARITY
    IDC_CB_STOPBITS

----------------------------------------
from util.c:
RegQueryModemSettings(
    HKEY hkey,
    LPMODEMSETTINGS pms,
    LPDWORD pdwSize)        // Size of modem settings struct
{

    // 10/26/1997 JosephJ:
    //      Only the following 4 contiguous fields of MODEMSETTINGS are saved
    //      in the registry:
    //        DWORD   dwCallSetupFailTimer;       // seconds
    //        DWORD   dwInactivityTimeout;        // seconds
    //        DWORD   dwSpeakerVolume;            // level
    //        DWORD   dwSpeakerMode;              // mode
    //        DWORD   dwPreferredModemOptions;    // bitmap
    //
    //      The following code reads in just those fields, and then
    //      munges the dwInactivityTimeout by multiplying by the
    //      separate InactivityScale registry entry.
    //
    //      On NT4.0 we just blindly read the above 4 fields
    //      Here we validate the size before reading.
----------------------------------------

4/29/1998 JosephJ
	cfgisdn.c
		in RegSetGlobalModemInfo(), call  ValidateISDNStaticConfig(),
		Implement all checks in ValidateISDNStaticConfig.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\tsp\notes.txt ===
ISSUES
* Must avoid lots of switch statements everywhere.
----------------------------------------------------
IMPORTANT OBJECTS

CTspDevice -- the object which handle all TSP calls for a particular device
CTspDeviceEnumerator - responsible for enumerating and creating device objects

CTspDeviceTable -- the object keeping the array of devices and mapping handles
	to device objects.
CTspTask -- generic TSP "irp" object. TSP functioncalls and MiniDriver
			function calls are the two primary subtypes.
----------------------------------------------------
IMPORTANT CONCEPTS
*Diagnostic annotations can be tacked on to a bunch of things -- eg. call
or device -- these things build up and get cleared periodically on a successful
call.
*TSP tasks are the IRPs of the TSP. They are allocated by each device, and
 context can be added to the IRP as it progresses along. The two main types of
 TSP  tasks are those representing TSPI function and those representing
 MiniDriver functions.
* TspTaskHandlers are the objects (pieces of code) that actually perform  
  TspTasks -- they may do some stuff and hand over the task to other handlers.
* TspTask-related resources, including handler-specific context,
  are managed by the device object. How? We'll see...
----------------------------------------------------
IMPORTANT SCALARS
TSPRETURN  -- Return code for all TSP-internal functions
TSPOBJID   -- Object type ID  
TSPSTATE   -- Object state -- object-specific state.
TSPTASKID  -- TSP Task ID
----------------------------------------------------
Common methods
Load/Unload -- lazy unload semantics
Lock/Unlock

-------------------------------------
class CTspDeviceEnumerator
{
	DeviceEnumerator(void);
	~DeviceEnumerator();

	TSPRETURN Load(...);
	HANDLE	  Unload();

	<way to notify DeviceTable of new/removed devices>
};

class CTspDevice
{
	Device(void);
	~Device();

	TSPRETURN Load(...);
	HANDLE	  Unload();

	TSPRETURN AllocTspMem(pTspTask);
	TSPRETURN DoTask(pTspTask);
};

class CTspTask
{
	GetID()
	GetCurrentHandler()
	GetCurrentState()
};

class CTspTaskHandler
{
	HandleTask(pTspTask);
};

class CTspDeviceTable
{
	TSPRETURN GetTSPDeviceFromHDRVCALL(HDRVCALL, pTSPDevice);
	TSPRETURN GetTSPDeviceFromHDRVLINE(HDRVLINE, pTSPDevice);
	TSPRETURN GetTSPDeviceFromHDRVPHONE(HDRVPHONE, pTSPDevice);
	TSPRETURN RegisterNewDevices(TSPDEVICE rgTspDev[], UINT cDevices);
			- resize internal table, making space for new ones.
			- fill out table, querying each for it's permanent ID, and its
			name. Make sure status is embryonic.
			- send up LINE_CREATE message for each, and wait for
			  lineCreate to be called on each.
			- when done, return.
	TSPRETURN RegisterPnPStatusChange(DWORD rgdwPermID, UINT cIDs, PNPSTATUS);
			- for each, look rgdwPermID, notify device of status change,
			  update local status and send up REMOVED/OUTOFSERVICE.
		    - when done, return.
};

TSPI_lineMakeCall(...)
{
 TSPPARAM_TSPI_lineMakeCall param;
 param.dwSize = sizeof(TSPPARAM_TSPI_lineMakeCall);
 param.flags = TSPIFLAGS;
 param.funccode = TASKID_TSPI_lineMakeCall;

 param.xxxx = xxx;
 ....

 return DoTSPCallForHDRVCALL(hdCall, pParam);
}

LONG DoTSPCallForHDRVCALL(HDRVCALL hdCall, pParam)
{
	tspRet = gDevTab.GetTSPDeviceFromHDRVCALL(hdCall, &pDevice);
	if (TSPSUCCESS(tspRet))
	{
		tspRet = pDevice->AcceptTSPCall(&param, &lRet);
		pDevice->Release();
	}

	if (TSPSUCCESS(tspRet))
	{
		return lRet;
	}
	else
	{
		return MapTSPRETURNtoTSPIRet(tspRet);
	}
}

TSPRETURN gDevTab.GetTSPDeviceFromHDRVCALL(hdCall, &pDevice)
{
	enter_crit;
	LOWORD(hdCall
	exit_crit;
}

TSPI_lineMakeCall(...)
{
	*Find associated device
		tspRet = pDevTab->GetTSPDeviceFromTapiCallHandle(hCall, &pDev);
	*Determine how much memory is required for task
		dwSize = (TASKPARAM_TSPI_lineMakeCall);
	*Create empty task
		pEmptyTask = pDev->GetTask(dwSize)
	*Fill in parameters
		xxx.hLine =
		xxx.hCall =
		xxx.hBlah.=Blah
	*SubmitTask
		dwRet = pDev->SubmitTask(pTask);
}

CTspTask::SubmitTask
{
	Handler->SubmitTask(pTask);
}



CTspTaskHandler:
type
---------------------------------------------------
CTspDev           cdev.h     cdev.cpp
CTspDevMgr    	  cmgr.h     cmgr.cpp
CTspDevFactory    cfact.h    cfact.cpp
CTspTask          ctask.h    ctask.cpp

tspi0.cpp   ProviderInit, etc....
tspi1.cpp   All the rest.
tspirec.h   TSPI func record..
mdrec.h     Mini-driver records.

tspcomm.h       common header file.


1/3/97 Changes from LINEDEV structure
* divided into static-info, settings, and device-state
* DEVCFG is created on the fly, not saved as-is. Instead, we keep
  
1/4/97
* I am *not* going to enumerate modems at the drop of the hat, in particular
  not going to do so just to find the driver key name (which we do only 
  because we want to pass it up to fax via the devspecific hack). So we have
  to figure out another way to get the driver key name.

1/4/97
  Thought of how to encode *both* RFR information and error codes in the DWORD
  return value of a function. Decided to enforce RFR LUIDS to have the LSB
  byte set to 0x00. RFR values can then be combined with a byte worth of error
  codes. Defined macros FL_GEN_RETVAL, FL_BYTERR_FROM_RETVAL, and
  FL_RFR_FROM_RETVAL to construct and break-apart these hybrid return values.
  To enforce having the RFR value LSB byte be 0x00, I did two things:
  (1) FL_SET_RFR now masks off the LSB byte, so the compiled-in value will
	  have the LSB byte zeroed -- this is important because otherwise it will
	  modify the byte error return value, which could cause undefined 
	  behaviour and may be hard to track down.
  (2) flhash.bat perl script will embed a "#error" macro in the generated
	  .cpp file when it processes a FL_SET_RFR with a non-zero LSB RFR:
	  #error "RFR LUID 0x833c923e (from globals.cpp): LSB byte should be 0"

  Now, if the function decides to return because of some error, it
  can have the following code:
		FL_SET_RFR(0x528e2a00, "Driver Key too large");
		tspRet = FL_GEN_RETVAL(IDERR_INTERNAL_OBJECT_TOO_SMALL);
		goto end:
  which translates to...
    	dwLUID_RFR = 0x528e2a00;
		tspRet = 0x528e2a08; // 8 is IDERR_INTERNAL_OBJECT_TOO_SMALL
		goto end;
  NOTE: we can't do away with the dwLUID_RFR variable altogother because
  stacklogging uses it independently. I want to keep the use of the return
  value in this way optional because it may
  not be possible or desirable to have this
  form of return value always (especially if retrofitting this logging scheme
  (FASTLOGGING) into existing code).
  The GREAT thing is that the compiler will strip out any
  reference to dwLUID_RFR if it is not actually used, so if  the function
  does not have stacklogging (no FL_LOG_EXIT(...)), the following macros
  will translate to
		tspRet = 0x528e2a08;
		goto end;
  CAN'T GET MUCH MORE EFFICIENT THAN THAT!!!!!!

1/4/97 JosephJ
    Modified fastlogs hashing algorithm by adding munging the luid as follows:
      luid ^= luid>>16
    This xors the hsb bits over to the lsb bits.
    This was done because the RFR luids have 00 as the lsb, screwing up the
    hashing distribution especially since the size of the hash table is
    a power of two!

1/4/97 JosephJ
    Putting in assert information into the stacklog:
    * need to define stacklogrec for assert
    * need to mark "fatal-error" flag in the stacklog main structure
	typedef struct
	{
		GENERIC_SMALL_OBJECT_HEADER hdr;
		DWORD dwLUID_ASSERT;

	} STACKLOGREC_ASSERT;

	FL_ASSERT(x>y)

	#define FL_ASSERT(_cond)\
		if (_cond) 
		{
			OutputDebutString(....);
			if (psl)
			{
				psl->LogAssert(dwLUID_CurrentLoc);
			}
		}

	FL_ASSERTEX(0x900000, cond, "this is bonkers");

	#define FL_ASSERTEX(_luid, _cond, _reason) \
		if (_cond)
		{
			OutputDebugString(....);
			if (psl)
			{
				psl->LogAssert(_luid);
			}
		}

    Sample output:
	*func1
	  |
	  | !!!! ASSERTFAIL !!!! (x>y) "this is bonkers" 0xf09900 (blah.cpp)
	  |
	  |


1/5/1997 JosephJ
	Created umdmrtl.cpp to keep functions that interact with external
	components. I decided for now to steal the UnimodemGetDefaultCommConfig
	code from modemui.dll -- a temporary solution -- basically I don't want to
	hassle with loading and unloading modemui.dll just for this measly api.
	See comments/todo's before the definition of UmRtlGetDefaultCommConfig
	in umdmrtl.cpp for detail.

1/7/1997 JosephJ
    * set up in place to implement open/close line.
		 - when does UmOpen/CloseModem get called?
			-- It could happen completely implicitly -- ppDev decides when
			   to open/close device? Nah -- will need to preserve state.
			-- It will be opened based by the relevant tasks on hand -- their
			   state diagrams can deal with the case that the modem is not
			   opened and hence open it.
		- What is llDev->Load() ? May as well be UmOpenModem, why have a 
			   different api? Can change this later if required.
		- What happens on lineOpen?
			-- nothing much, just set state to opened. Later, we may start the
			   async. thread on lineOpen -- else the whole async thread thing
			   could be completely on-demand.
	* Implement it properly in CDevMgr as well.
	* Get this to work with TB20 -- lineOpen(no privilidges)/Close should work.
	* Implement lineDial
		- Concept of a task with its own state
		- APC support
		- ASync callback
		- Open/Close modem 

1/8/1997 JosephJ
    * If passing a stacklog in function arguments is deemed to be too much
      of an overhead, another way of propogating it is to place a pointer
    to it in the current object soon after claiming that objects critical
   section. m_pslCurrent stores the pointer and is set to NULL just before
   releasing the crit sect. Member functions that assume that the crit.
  sect. is held can then use m_pslCurrent. This is useful in fairly
 common cases where one of the public methods of an object is called,
  which results in the crit. sect. being claimed and lots of activity
  happens while this crit. sect is claimed. Any time one of the private
  functions wants to log something, it can use m_pslCurrent. These functions
  can even log function entry and exit. I've used this concept in some
  places in CFact, just to demonstrate the idea.

1/8/1997 JosephJ
    UNICODE issues
    * To keep things simple, UNICODE is assumed. TCHAR is not used -- strings
      are either explicitly char or WCHAR. Most of the logging stuff is
      char.
1/8/1997 JosephJ Blatant Bug in NT4.0 TSP in lineGetAddressCaps
		(unimdm.c, line 3239)

    lpAddressCaps->dwUsedSize = sizeof(LINEADDRESSCAPS);
    lpAddressCaps->dwNeededSize = lpAddressCaps->dwUsedSize +
                                  sizeof(LINEADDRESSCAPS); <<<<<BUG

    if (lpAddressCaps->dwTotalSize >= lpAddressCaps->dwNeededSize)
    {
	....

	Above should be dwNeededSize = UsedSize+sizeof(g_szzClassList);

	Fixed in NT5.0.

1/9/1997 JosephJ: Following are the times for providerInit plus doing basic
        operations on 10,000 stubbed-out devices:
                [X:\NT\private\unimodem\nt50\tsp]ttsp
                
                tTSPI0: 20570 ms after providerEnumDevices.
                tTSPI0: 21080 ms after providerInit.
                
                tTSPI0: Testing 10000 devices.
                
                tTSPI0: SUCCESS!
                tTSPI0: 23694 ms after completion of test.
                tTSPI0: 23704 ms after process detach.

       The operations done per device (in ttspi.cpp) are:
            lineGetDevCaps
            lineOpen
            lineClose

       From the times above...
        21 seconds to to load the devices (basically read stuff from the
                registry). (2 ms per device).
        1  second to do providerInit (which causes the CDevMgr to ask
                CDevFactory for all the devices and to set up the internal
                array of devices. (0.1 ms per device).
        3  seconds to do the per-device tests (lineGetID,open,close).
                (0.3 ms per device).

        This timing was obtained with logging enabled but logging output        
        disabled (specifically, CStackLog::Dump and ConsolePrintf stubbed
        out).

1/9/1997 JosephJ UNICODE (again) I decided to do the traditional TCHAR so that
        the tsp can potentially be compiled with normal BYTE-sized chars -- it's
        easy enough to do and will ease the Pegasus team's job stealing the code
        for their product (assuming it doesn't do unicode). I wrote
        the ConsolePrintfW function to emulate UNICODE-enabled printf and things
        work dandy.

1/9/1997 JosephJ Thougts on adding diagnostics to the modem control panel
       - diagnostics/troubleshooter page of modem cpl should have:
            - examine and clean up registry
            - enhanced logging (Note: some amount of logging should always
              be enabled)
            - view log(default should include install history, plus components
               and their timestamps, versions) -- the viewing mechanism can
               be to generate and then view html, so you have a nice table
               of contents for the different sub-logs.
            - both of the above selectible on a per modem basis, or combined
              (all modems) basis.
            - Tests:
                -- test comm port: bring up little terminal to type stuff...
                -- test modem0: try the Init commands, etc, view result.
                -- test modem1: try checking for dial tone.
                -- test modem2: try dialing out.
                In all of the above, log copious details. The main log should
                include pointers to the test logs.
            - SendLogTo: be able to encapsulate and send the combined log 
              via (a) email (b) save to disk (c) print.

1/9/1997 JosephJ 1/9 plan of action:
        * finish up lineOpen/Close (comm config stuff).
            - comm. config strategy:
                - fAppRequestedChange
                - ccCurrentDefault
                - ccCall (kept in CDevCall)
        * implement lineConditionalMediaDetection (line open w/ owner)
            - open modem on demand
            - init modem
            - make modem wait for answer
            - handle callbacks
            * get above to work with stubbed out minidriver, with console app.
            * get above to work with stubbed out minidriver, with TB20.
            * test scaleibility with console app.
            * get above to work with real at minidriver, with console version of
              tsp.
            * get above to work with tb20.
        * implement lineMakeCall, lineDrop
            - maintain call state
            - orderly drop on lineClose
            - handle callstates
-------------------
1/11/1997 JosephJ Notes on task handling
	* We want to simulate a synchronous call tree asynchronously -- what can be
	  done by, say fibres, but I don't want to use fibers or any funky external
	  API.
	* The NT4.0 unimodem approach is to have a single large state machine in the
	  upper-level TSP -- we definitely don't want that. We want lots of little
	  state machines, each focused on some coherent thing, like dialing,
	  initing the device, making a call, etc.

	Properties of a task
	--------------------
	1. A task is tied to a particular device and uses the devices' critical
	   section for synchronization. Allocation is managed by the device, and
	   typically doesn't use any global resources -- so tasks can be allocated
	   and freed without touching any global resources.
	2. A task is similar to a windowless window, in that it has a message
	   handler function which is used to receive messages. All calls into
	   this message handle are serialized using the containing devices' critical
	   section.
	3. The task  when it is complete.
	4. Tasks may create subtasks, there is no special parent/child relationship
	   however (or should there be?).

	Task message handler
	--------------------
	TSPRETURN
	MsgProc(DWORD dwMsg, DWORD dwParam1, DWORD dwParam2)
	{
	}
	Sample:

	MsgProcMakeDataCall(....)
	{
		switch(dwMsg)
		{
		case START:
			if (!loaded) load;
			if (!inited) dwRet = llDev->InitModem(this, INIT_COMLETE);
			if (dwRet == pending)
				return;
			// fall through

		case INIT_COMPLETE:
			// handle error

			// start dial
			DoDial();

			// if (dwRet == pending)	
				return;

		case DIAL_COMPLETE:
			// handle errors
			// finish task, signal completion to upper-level task.

		case ABORT:
			if (pending op)
			abort pending opp
			goto end;
		}
	}

--------------------------
class CTask;


typedef TSPRETURN (CTspDev::*PFNTASKHANDLER) (
					CTask *pTask,
					DWORD dwMsg,
					DWORD dwParam1,
					DWORD dwParam2
					);

// Special messages:
START
ABORT
SUBTASK_COMPLETE

#define fLOADED 	(0x1<<0)
#define fCOMPLETED 	(0x1<<1)
#define fABORTING 	(0x1<<2)

// MAKE_SigAndSize(_size)

#define MAX_CONTEXT_SIZE 16

#define MSG_ABORT 0x1

class CTspTask
{

private:

	friend class CTspTaskMgr;

	BOOL is_loaded(void)
	{
		return m_hdr.dwFlags & fLOADED;
	}

	BOOL is_completed(void)
	{
		return m_hdr.dwFlags & fCOMPLETED;
	}

	void Alloc (
			CTspDev *pDevParent
		 	)
	{
		ZeroMemory(this, sizeof(this));
		m_hdr.dwSigAndSize = MAKE_SigAndSize(sizeof(this));
		m_pDevParent = pDevParent;
	}

	TSPRETURN
	Load(
		CTask *pParentTask,
		PFNTASKHANDLER pfnTaskHandler,
		DWORD dwCompletionID
		void *pvContext,
		UINT cbContext,
		)
	{
		ASSERT(!(m_hdr.dwFlags));

		if (cbContext>sizeof(m_rgbContext))
		{
			return IDERR_INTERNAL_OBJECT_TOO_SMALL;
		}
		m_pParentTask = pParentTask;
		m_pCurrentSubTask =  pCurrentSubTask;
		m_pfnTaskHandler = pfnTaskHandler;
		CopyMemory(m_rgbContext, pvContext, cbContext);
		m_hdr.dwFlags = fLOADED;
	}

	void Unload(void)
	{
		ASSERT(is_loaded());
		ASSERT(is_completed());
		ASSERT(!m_pCurrentSubTask);
		ZeroMemory(this, sizeof(*this));
	}

	void Abort(CTspDev *pDevParent)
	{
		ASSERT(is_loaded());
		m_hdr.dwFlags |= fABORTING;
		// TODO: Maybe don't do the following if we're already in aborting state
		(pDevParent->*m_pfnTaskHandler)(this, MSG_ABORT, 0, 0);
	}

	void Start(CTspDev *pDevParent)
	{
		ASSERT(is_loaded());
		// TODO: Maybe don't do the following if we're already in aborting state
		(pDevParent->*m_pfnTaskHandler)(this, MSG_START, 0, 0);
	}

	void Complete(CTspDev *pDevParent, HANDLE  hThreadAPC)
	{
		ASSERT(is_loaded());
		ASSERT(!is_completed());
		ASSERT(!m_pfnCurrentSubTask);

		// TODO handle hThreadAPC (deferred completion)

		// Notify parent we are comlete.
		(pDevParent->*m_pfnTaskHandler)(
				m_pParentTask,
				MSG_SUBTASK_COMPETE,
				m_dwContextID,
				(DWORD) m_pContext
				);

		// Nuke pointer to ourself in our parent.
		ASSERT(m_pParentTask->pCurrentSubTask==this);
		m_pParentTask->pCurrentSubTask=NULL;
		m_hdr.dwFlags |= fCOMPLETED;
	}

	
	GENERIC_SMALL_OBJECT_HEADER m_hdr;
	CTask *m_pParentTask;
	CTask *m_pCurrentSubTask;
	PFNTASKHANDLER m_pfnTaskHandler;
	BYTE m_rgbContext[MAX_CONTEXT_SIZE];
	UINT m_cbContext;
}


TSPRETURN 
CTspDev::TSPICompletionHandler (
		CTask *pTask,
		DWORD dwMsg,
		DWORD dwParam1,
		DWORD dwParam2
		)
{
	switch (dwMsg)
	{
	case TSPI_CALL_COMPLETE:
		pTask->GetState();
		m_pfnCompletionProc(dwID, dwParam1);
		pTask->Complete();
	}
}

TSPRETURN 
CTspDev::MakeCallHandler (
		CTask *pTask,
		DWORD dwMsg,
		DWORD dwParam1,
		DWORD dwParam2
		)
{
	switch (dwMsg)
	{
	case ABORT:
		pTask->AbortSubTask();
		goto end_pending;

	case START:
		if (!device-inited)
		{
			pTask->StartSubTask (
				&(CTspDev::InitModemHandler),
				INIT_COMPLETE
				);
			m_pTaskMgr->StartSubTask(
				hTask,
				&(CTspDev::InitModemHandler),
				INIT_COMPLETE
				);

			if (error)
			{
				handle_error;
			}
			else if (subtask_pending)
			{
				goto end_pending;
			}
			// Else sync. success, fall through
		}

		// FALL THROUGH

	case INIT_COMPLETE:

		// Verify state (modem should be inited/aborting)
		if (aborting)
		{
			handle aborting
		}
		pTask->StartSubTask(
				&(CTspDev::DialModemHandler),
				INIT_COMPLETE
				);
		// handle error/pending/sync-success

		// FALL_THROUGH	

	case DIAL_COMPLETE:

		// Verify state (modem should be connected/aborting)
		pTask->Complete(compete-params);
	}
}

tspRet = m_pTaskMgr->StartTask(
						&(CTspDev::TH_MakeCall),
						COMPLETIONCALLBACK,
						void *pvTaskContext,
						UINT cbTaskContext,
						&phTask
						);

m_pTaskMgr->StartSubTask(
	hTaskParent,
	&(CTspDev::InitModemHandler),
	void *pvTaskContext,
	UINT cbTaskContext,
	INIT_COMPLETE
	);
AbortSubTask
AbortSubTask

LLDev
  hCurrentTask
  

class CTspTaskMgr
{
	Load(
	);
};
------------------------------------
1/16/97 JosephJ
//
// Task Structure
//
// After partially implementing several schemes for tracking tasks and subtasks,
// I settled on a simple scheme allowing just one task (and it's stack of sub
// tasks) to exist per device at any one time. This allows us to keep the
// state in a simple array, the 1st element being the root task, and not
// maintain pointers to parents, children, and not maintain a freelist.
// If in the future we decide to impliment multiple independant tasks active
// at the same time, I recommend implementing them as an array of arrays,
// where each sub-array has the current scheme.
//
// hdr.dwFlags maintains task state:
//				fLOADED
//				fABORTING
//				fCOMPLETE
//				fHAS_SUBTASK
//				fROOT
//
// Note: it is important that the following structure contain no pointers
// to itself, so that it can be moved (rebased) and still be valid. This
// allows the space allocated for stack of tasks to be reallocated if required.
//
typedef struct _DEVTASKINFO
{
	GENERIC_SMALL_OBJECT_HEADER hdr;
	PFN_CTspDev_TASK_HANDLER pfnHandler;
	BYTE rgbContextData[MAX_CONTEXT_SIZE]; // contains a GENERIC_SMALL_OBJECT

} DEVTASKINFO;

------------------------------------
1/16/97 JosephJ

Generic allocater: starts with a buffer given to it, but uses larger buffers
	if it runs out of space.

Class CDynaBuf
{

public:

	CDynaBuf(BYTE rgbStartBuf[], UINT cbStartBuf)
	{
		m_hdr.dwSigAndSize = MAKE_SigAndSize(sizeof(this));
		m_hdr.dwFlags = 0;
		m_hdr.dwClassID = dwCLASSID_CDynaBuf;
		m_pbCurrentBuf = m_pbStartBuf = rgbStartBuf;
		m_cbCurrentBuf = m_cbStartBuf = cbStartBuf;
	}

	~CDynaBuf()
	{
		ASSERT(!m_pbCurrentBuf || m_pbCurrentBuf==m_pbStartBuf);

		m_hdr.dwSigAndSize = 0;
		m_pbCurrentBuf = NULL;
	}

	UINT ReAlloc(UINT cbNew, BOOL fCopy, BYTE **ppbNew) 
								// changes internal buf
								// size if it can.
	{
		BYTE *pbNew =  LocalAlloc(cbNew);
		ASSERT(pbNew);
		if (pbNew)
		{
			if (fCopy)
			{
				UINT cbCopy  = (cbNew>m_cbCurrentBuf) ? m_cbCurrentBuf : cbNew;
				CopyMemory(pbNew, m_pbCurrentBuf, cbCopy);
			}

			if (m_pbCurrentBuf != m_pbStartBuf)
			{
				LocalFree(m_pbCurrentBuf);
			}

			m_pbCurrentBuf = pbNew;
			m_cbCurrentBuf = cbNew;
		}

		*ppbNew = m_pbCurrentBuf;
		return m_pcCurrentBuf;
	}


	void Reset(void)
	{
		if (m_pbCurrentBuf!=m_pbStartBuf)
		{
			LocalFree(m_pbCurrentBuf);
		 	m_pbCurrentBuf=m_pbStartBuf;
		 	m_cbCurrentBuf=m_cbStartBuf;
		}
	}

private:

	GENERIC_SMALL_OBJECT_HEADER m_hdr;
	BYTE *m_pbStartBuf;
	BYTE *m_pbCurrentBuf;
	UINT m_cbCurrentSize;

};

---------------------------------------------------------------------------------------------
1/22/1997 JosephJ

Task states:
    PENDING
        SUBTASK_PENDING
    ABORTING
    
1/24/1997 JosephJ
Possible bug in NT4.0 TSP: function TSPI_lineGetCallStatus(...)
    unimdm.c line 2427 ASSERT(lpCallStatus->dwCallFeatures == 0);
    This shouldn't be an assert -- dwCallFeatures has not been set yet
    in this codepath, and should be set to 0 here. NT5.0 TSP does this.

1/24/1997 JosephJ
    Split cdev.cpp into cdev.cpp, cdevline.cpp, cdevtask.cpp and cdevcall.cpp

1/25/1997 JosephJ
    BUGBUG: We currently keep the registry key for the device open for as long
        as the modem is open -- which for the server is all the time.
        We don't really need to do this. On a 1000 server system, that's
        1000 open registry keys.

    Current behaviour is that mini driver takes open hKey and expects it
    to be open throught the session. It doesn't close the key itself -- the
    TSP is expected to close it.

1/25/1997 JosephJ
     Console window can display stacklogs from different sources in different
     colors. For example:
        white:    TSPI calls
        red:      APC calls
        yellow:   Minidriver Callbacks
        
1/27/1997 JosephJ
     Some notes on LINEINFO, CALLINFO and LLDEVINFO.
   These structures sit inside the CTspDev object and maintain state about 
   open lines, active calls and open modems, respectively. They are named
   CTspDev::m_Line, CTspDev::m_Call and CTspDev::m_LLDev respectively. Access
   to them is via pointers m_pLine, m_pCall and m_pLLDev respectively. They
   are accessed via pointers simply to make it very clear when they are
   and are not defined (in scope). They are in scope if and only if the pointer 
   is non-NULL (in which case the pointer points to the corresponding struct).
   mfn_LoadLine, mfn_LoadCall and mfn_LoadLLDevInfo bring them in scope and
   functions mfn_UnloadLine, mfn_UnloadCall and mfn_UnloadLLDev take them
   out of scope.
    
1/29/1997 JosephJ Proposed changes to task mechanism:
    - have a predefined "root" task, with a callback -- this root task's
      callback will be the one that calls the TAPI callback function, not
      the individual subtasks handlers, like TH_MakeCall, TH_DropCall, etc.
    - allow queueing of subtasks -- basically the parameters to 
      mfn_StartTask are saved in a structure and pushed in a queue. They
      will be executed when the current task is complete. This will allow,
      for example, a lineMakeCall to be processed while we are in the middle
      of monitoring after a previous call.

1/29/1997 JosephJ Proposed changes to routing of TSPI calls
    - Make the TASKPARAM structures GENERIC_SMALL_OBJECTS, with
      a few extra fields tacked on:
        - TaskID
        - DeviceID -- could be dwDeviceID, hdLine or hdCall based on the
          flags.
    - Get rid of the dwRoutingInfo parameter, move it to hdr.dwFlags.
    - Add "async call" as one of the flags -- these are TSPI calls which
      complete asynchronously.

1/29/1997 JosephJ More details on the changes to the tasking functionality.
    - Instead of a special "root" task, may as well create a TH_AsyncTAPICall
      task which takes as start parameters the dwRequestID and the actual
      handler function for that async call. The latter async call will take
      no parameters -- all relevant information will be available somewhere
      else in the CTspDev object.

      typedef struct
      {
        DWORD dwRequestID;

      } CONTEXT_ASYNCTAPICALL;

CTspDev::mfn_TH_AsyncTAPICall(
					HTSPTASK htspTask,
					void *pvContext,
					DWORD dwMsg,
					DWORD dwParam1,
					DWORD dwParam2,
					CStackLog *psl
					)

CTspDev::mfn_TH_AsyncTAPICall(
					HTSPTASK htspTask,
					DWORD dwMsg,
					DWORD dwParam1,
					DWORD dwParam2,
					CStackLog *psl
					)
GetPrivateContext(hTask, ppContext, cbContext);
GetParams(hTask, ppParams, cbParams);

StartTask(
    hParentTask,
    pvContext,
    cbContext,
    dwTaskID
    pParam1,
    pParam2
)

SUBTASK_COMPLETE:
    pParam1 = pvSubtaskContext;
    pParam2 = dwSubtaskID;
    pParam3 = dwAsyncResult;
);


typedef struct
{
    GENERIC_SMALL_OBJECT_HEADER hdr;
    DWORD dwDevice;
    DWORD dwTASKID;
    DWORD dwReqID;
    LONG  lRet;
}


p.hdr.


1/30/1997 JosephJ
    After much deliberation, have decided on the following:
    * Keep to current task scheme -- single root task active, no special
      root-context available to subtasks.
    * Only one TAPI Async call can be "current" at a time. By current, I
     mean that it is actively being processed by a task.
    * Since there is only one current TAPI async call, we can store its 
     request ID and result in the LINEINFO struct itself, and not some
    where in the task-specific memory.
    * There can be queued TAPI async calls -- these are async calls that
    are queued for execution after the currently executing task is complete.
    (this is as-yet unimplemented).
    * All TAPI async calls are handled as subtasks of a special task, called
    TH_AsyncTSPICall. TH_AsyncTSPICall is passed in a pointr to the handler
    function to actually process the tspi call, and is responsible for
    calling the TAPI callback function when done. In addition, it is also
    responsible for re-posting listen if required -- in fact, I've decided
    that it reposts listen BEFORE asynchronously completing the call --
    this is a CHANGE from previous unimodem behaviour. Win9x and NT4.0
    unimodem would complete, say, lineDrop as soon as the line was dropped,
    so had to deal with the case that a new lineMakeCall could come in
    while we were still posting a listen. With the new scheme, we only
    claim that lineDrop is complete AFTER we have posted the listen. This
    reduces the need to ever queue TSPI calls -- infact maybe we never need
    to queue TSPI calls.
 
1/30/1997 JosephJ
    Some wierd C++ behaviour: you can't cast a pointer to a member function
    to a DWORD -- to get around it, I cast a pointer to pointer to the
    member function to a DWORD. This is required for TH_AsyncTSPICall, which
    is passed in a pointer to a task handler as it's DWORD lParam2 on startup.

1/30/1997 JosephJ
    Validating pointers to task handlers. Given the fact that type info is
    lost when casting the handler function to DWORDS above, and in general
    in the interest of error checking, all handler functions must respond
    to the special message MSG_ARE_YOU_FOR_REAL. See notes on
    MSG_ARE_YOU_FOR_REAL in cdev.h for more info. This works quite well.



2/6/1997 JosephJ
    Pointers to member functions again.
    Because these pointers are larger than dwords they pose problems.
    Hence I define static pointers to these functions and pass pointers
    to these static pointers. These pointers to pointers are ordinary
    32-bit pointers.
    Later we should convert this scheme to a static table of handler functions,
    and all references to handler functions should simply be an index
    into this table. The actual function pointer is accessed only
    when actually calling into this function.

2/6/1997 JosephJ
    FYI: NT4.0 unimodem ignores lpLineCallParams->dwMin/MaxRate and
    ->dwAddressID/Mode. (It checks the latter for valid values on
    lineSetConditionalMediaDetection, but ignores them
    in the LINECALLPARAMS passed into lineMakeCall.


2/6/1997 JosephJ
    Another NT4.0 Bug:
    The DevConfig part of LPLINECALLPARAMS passed into lineMakeCall is
    effectively ignored.
    
    lineMakeCall passes on the devconfig part of lpCallParams to
    TSPI_lineSetCallParams with NULL as the szDeviceClass parameter of the
    latter function. The latter function simply fails because of this
    NULL param and the failure is ignored by lineMakeCall.
    
2/8/1997 JosephJ
    Some comments on the new-vs-old scheme for tsp state diagram.

    The NT4.0 scheme was doubly messed up -- firstly logically there was one
    huge state diagram; secondly this state diagram was implemented all over 
    the place.

    The NT5.0 scheme is hierarchical, and each sub-state diagram is implemented
    in one place.

2/8/1997 JosephJ
    Got to think of some way to eliminate the inter-ring timer. How?
    Can't eliminate it, but can use the SleepEx(xxx) of the APC thread
    to implement timer functionality without any additional resources, like
    events or timers -- basic idea is to control the wit of SleepEx. To wake it
    up earlier, simply submit an apc call which will recalc the sleep amount
    again. We will need to maintain a chain of timers as did NT4.0, but that's
    no problem at all and quite light weight.
    

2/11/1997
Tapitest is still running with 850 successful calls (zero bad) with the new
nt5.0 tsp and minidriver. This is with two real modems on my x86 machine.

We achieved this level of stability in one shot -- i.e., as soon as I got both
dial and answer to work with tapitest, it just kept on running.

This is a testament to our design, the quality of our implementation, and the
quality of the component tests which our test group have developed and have
been testing Brian's mini driver with for some time now.

This is in stark contrast to the pain and months  of effort that went into
getting NT4.0 unimodem to be stable, after send and receive was demonstrated.

Much remains to be done. Although I expect to get RAS, fax and Hyperterm to
work in short order, features such as pre/post terminal, call status, pnp and
of course integration with heather's wave driver are yet to be done.

Heather and I will work on wave integration. Brian is working on PnP and on
providing us with IOCTLS for ipc communication between wave driver/am filter
and the TSP.

I will have RAS and fax working by the end of the week, and we will have wave
and PnP by the end of the month.

The test group is developing their test architecture so that they can run voice
and data stress tests either on the whole system (tapi+tsp+minidriver+wave)
or directly on the minidriver, with most of the test code shared. I can't
emphasize enough how cool this is, both for efficient testing and for
efficient isolation of problems!!!



2/11/1997 JosephJ
    Example of why every bit in every structure matters. HyperTerm was
    watching for the LINEDEVSTATUSFLAGS_INSERVICE bit of
                lpLineDevStatus->dwDevStatusFlags set in the call to
    lineGetLineDevStatus(...), and I wasn't setting it (bug), so it put up a 
    line dialog box asking me to plug in the modem!

2/21/1997 JosephJ
    Fixed bug related to calling lineCloseCall when the call is in various
    stages. There were several problems:
    * simple typo, causing us to CloseHandle on an event twice, resulting in a
      fault.
    * UmInitModem was ignoring the Abort command and returning success, so
      TH_MakeCall would go on to dial even when we were trying to hangup.
      Strictly speaking UmInitModem should be fixed to return async failure
      in case, but anyway I changed TH_MakeCall so that if the call is
      in the aborting state it will force the async return of a subtask
      to be IDERR_OPERATION_ABORTED, so that it doesn't go on to do the next
      thing.
    * I also check if the call still exists on re-entering the Critical
      section after waiting for pending operations in lineCloseCall, because
      in principle anything could have happend while the the devices' critical
      section was not held.

    The TSP is now quite robust w.r.t. dropping calls at various stages
    of making them. I tested this via Dialer and Hyperterm.

2/21/1997 HeatherA
    Added the two new parameters to UmOpenModem (Modem ID and Comm handle).

2/22/1997 JosephJ
    Lightweight timer services.
    On further reflection, I decided to use the waitable timer, but only one.
    Using one waitable timer we can implement an arbitrary number of timers.
    After creating the apc thread, we create a waitable timer on that thread.
    We then maintain a list of light-weight timers, each of which can be 
    set and cleared independently. Each CTspDev creates a light-weight "ring"
    timer when it is Loaded and distroys this timer when it is unloaded.
    When a ring comes in, this timer is set to the inter-ring timeout. If
    the call is answered or dropped, the inter-ring timeout is cancelled.
    Setting and cancelling  timer is fairly lightweight operation. Although
    it does require grabbing the timer's global critical section in practise
    this action will never block because it's always done in a single
    thread's context (the APC thread).


    Light Weight Timer Services
    ---------------------------

    // CreateLWTimer creates a lightweight timer. The callback function
    // will be called with the specified token when the timeout expires.
    //
    HLWTIMER 
    CreateLWTimer(
        LWTIMERCALLBACK pfnCallback,
        DWORD           dwToken
        );

    // Distroy the specified lightweight timer. The handle becomes invalid.
    void
    DistroyLWTimer(
        HLWTIMER
        );


    // Set the timeout for the specified lightweight timer.
    // SetTimer can be called multiple times in succession -- the most
    // recent value is used to fire off the timer. WARNING: it's quite possible
    // that the timer has just fired and the callback is sitting in the apc
    // queue. In this case a 2nd callback will be  sent if and when the new
    // timeout expires.
    //
    // dwFlags indicates how to interpret the specifed dwDelay.
    // The following flags are supported
    //  fLWTIMER_RELATIVE_MS     - dwDelay specifes a relative time in ms from
    //                             the the current time.
    //
    BOOL
    SetLWTimer(
        HLWTIMER, 
        DWORD dwFlags,
        DWORD dwDelay
        );

    // Effectively sets the timeout value to infinite.
    void
    CancelLWTimer(
        HLWTIMER
        );
    

    Implementtion
        * Maintain two UNSORTED lists of timers: ACTIVE list and  INACTIVE list.
        * SetLWTimer moves lwtimer from inactive to active (if not already on 
          active).
        * CancelLWTimer moves lwtimer from inactive to active (if not already
          on inactive).
        * One lwtimer in the active list is selected to be the next timer to
          be activated. A pointer to this next-timer-to-be-activated is 
          maintained. Special action is taken by SetLWTimer and CancelLWTimer 
          they determine that this next-timer-to-be-activated needs to be
          changed.

2/23/1997 JosephJ 9am

    Note the code as checked in today ran for 4,600 calls on my machine, with
    zero failures, using Sorin's mdmtapi stress test on two USR modems.

2/23/1997 JosephJ
    Re-initing and re-monitoring after calls; recovering from hw failures, etc.

    Currently the tsp does not re-init and re-monitor after every call. It
    should.

2/25/1997 JosephJ
    TODO: Need lineGetID(CALLSELECT_LINE, "comm/properties") to return
    COMMPROP structure, instead of requiring app to open handle and go
    a GetCommProperties on the handle.

2/26/1997 JosephJ
    Adding voice.
    The guidline for doing so are examining the pieces of code in unimodem/v
    that are enclosed by _AT_V.

    Specific things I'm not considering for now are: forwarding, distinctive
    ringing and speakerphone related stuff. The latter will eventually go into
    NT5.0, but the former probably never will.

    1st step is to get the voice properties from the registry while creating
    the device. These go into m_StaticInfo.

    2nd step is to modify the key TSPI calls to be voice-aware, looking at
    unimodem/v code for guideance.

    3rd step is to try to make and answer a voice call with tb20,
    following the voice bvt instructions. The unimodem/v state diagram must
    be examined to make sure that there are no holes.

3/21/1997 JosephJ 3am
    Checked in some changes to cdevline.cpp and cdecall.cpp that cleaned up
    the loading/unloading of calls and the lldevice.
    
    Previously CTspDev::mfn_LoadCall and CTspDev::mfn_UnloadCall were
    asymetric in that mfn_LoadCall would not try to load the device but
    mfn_UnloadCall would unload the device IFF it was an outgoing call.
    Other places would unload the device on failure of the call, and there
    was a bug whereby the call would not get unloaded if lineMakeCall failed
    asynchronously (because the call would only get unloaded if lineCloseCall
    is called, and TAPI wasn't calling lineCloseCall if lineMakeCall failed
    asynchronously, probably by design). This was causing the call to never
    get unloaded if, for example, the modem was off and so init failed. There
    was also another possibility of the call not being unloaded -- if the 
    attempt to start the TH_MakeCall failed without invoking TH_MakeCall at
    all.
    The cleanup basically consists of moving the mfn_LoadLLDev from TH_MakeCall
    to mfn_LoadCall and moving mfn_UnloadLLDev from TH_DropCall or other places
    to mfn_UnloadCall (now mfn_UnloadCall ALWAYS calls mfn_UnloadLLDev). The
    cleanup also consists of making sure mfn_UnloadCall is called in all cases.


3/21/1997 JosephJ 6am 
    Checking in code to send LINE_CLOSE if there is a hw failure (either
    failure to init/monitor or an unsolicited hw failure notification sent
    up by the minidriver. Basic idea is to set a "fCALL_HW_FAILURE" bit
    in the call info (m_pLine->pCall) if there is a call or else send
    up a LINE_CLOSE message to TAPI if we are monitoring. When unloading
    the call, we send up a LINE_CLOSE message if the fCALL_HW_FAILURE bit
    is set.

    I found that I was not getting a response from the minidriver if
    I switched the modem off when the line was open with owner privs -- need
    to follow up with Brian re this.

3/21/1997 JosephJ 3pm
    Implementing passthrough...

    Examining NT4 tsp yielded the following observations:
    (a) The key functions are lineMakeCall and lineSetCallParams.
    (b) NT4 switch to/from passthrough was synchronous, and could potentially
        block in the sync call to Devioctl(passthrough on/off).
        On NT5 it is handled async, as it should, but this means
        a slight change in behavour for switching to/from passthrough on
        an already connected call using the synchronous lineSetCallParams:
            On NT4 CONNECTED was sent up in the context of the lineSetCallParams
            call itself, while for NT5 this will be sent later.
        The same thing is true for lineMakeCall, but atleast lineMakeCall is
        in general expected to be an async call, so apps would in general
        be expected to handle an async CONNECTED message.
    (c) Switching in/out of passthrough for an
        already connected call is supported, so we should make sure we don't
        break this functionality.
            

    For NT5, I decided to implement a passthrough call using a passthrough-
    specific task handler for making and dropping a call instead of TH_MakeCall,
    and TH_DropCall. This is very simple to do and allows us to isolate the
    two kinds of calls (changes to the passthrough versions can be done without
    in anyway risking a traditional call), and moreover is cool because it is
    something that would have been essentially impossible to do on NT4
     (i.e., it would not be possible to isolate the implementation of a
     passthrogh call in this way on NT4.0 tsp).

4/8/1997 JosephJ 2am
    All this config dlg stuff....

    I moved all code that runs in the apps context to files with "app" prefix.

    General note:
    TSPI_providerGenericDialogData and
    TUISPI_providerGenericDialogData and
    are used to ferry TSP-specific "blobs" of data back and forth between the
    TSP and the app.

    One issue is how to make this config dlg stuff all extensible. The sequence
    is that TAPI first calls the TSPI's getUIDLL function to get the name
    of the UI DLL. At this time we don't know which device it pertains to.
    Tapi then calls this DLL's entry point with for example
     TUISPI_lineConfigDialog, and specifies a deviceID. 

    One strategy is for TUISPI_lineConfigDialog to send a blob asking unimdm.tsp
    for the ui dll to use for this device and go from there.

4/20/1997 2pm JosephJ
    Extension DLL stuff....
    
    I created subdirectlry ex, which  contains a sample extension dll.
    The file ex.h contains the proposed extension APIs.

    Changes required in the TSP to support extension:
    1. TSP should dynamically load the mini-driver. Currently it is statically
       linked.
        - How is tsp going to determine the mini-driver to load?
          In device's registry key, TSP looks up the REG_BINARY GUID key
          MiniDriverGUID. If it finds, it, it  searches internally amongst its
          loaded mini-drivers for one with this GUID. If it finds it, it 
          increments the loaded mini-drivers' ref count. If it doesn't find it,
          it looks up the REG_STRING name
          Unimodem\MiniDriverSpecific\{<GUID>}\MiniDriverPath,
          whose value is the path of the mini driver. The TSP then loads this
          mini-driver (this includes validating it).

    2. TSP should filter all device-specific calls through the loaded
       mini-driver, if the mini-driver supports extensions.

    3. When the device is unloaded (currently only on exiting the TSP, the
       ref-count of its mini-driver should be decremented, and the mini-driver 
       unloaded if the ref-count goes to zero.


    
4/27/1997 JosephJ
    More tricks by the compiler (unimdmex.dll)
        69301721 FF 74 24 14      push        dword ptr [esp+14h]
        69301725 8B C8            mov         ecx,eax
        69301727 FF 74 24 14      push        dword ptr [esp+14h]
        6930172B FF 74 24 14      push        dword ptr [esp+14h]
        Here it is  in effect executing:
            func(a,b,c)
            {
                ...
                func1(a,b,c)
            }
        Each instance of "push dword ptr[esp+14h]" pushes a different argument
        because the stack itself is being decremented as a result of the push!
        -------------------------

    This time windbg gets confused (and so do I). This is code for
    CTspDevExt::OpenModem in ex\cext.cpp:

        
    The relevant part of the source for member function OpenModem is:
    HANDLE
    CTspDevExt::OpenModem(
        HKEY        ModemRegistry,
        HANDLE      CompletionPort,
        LPUMNOTIFICATIONPROC  AsyncNotificationProc,
        HANDLE      AsyncNotificationContext,
        DWORD       DebugDeviceId,
        HANDLE     *CommPortHandle
    )
    {
        HANDLE h = NULL;
    
        mfn_enter();
    
        if (m_fLoaded && !m_hModemHandle)
        {
    
            //
            // We substitute our own callbacks and context here!
            //
    
            m_hModemHandle = g.pfnUmOpenModem(
                                    g.hLowerLevelDriverHandle,
                                    NULL,
                                    ModemRegistry,
                                    CompletionPort,
                                    OurAsyncNotificationProc,
                                    (HANDLE) this,
                                    DebugDeviceId,
                                    CommPortHandle
                                    );

    The asm as displayed by windbg is:

        CTspDevExt::OpenModem:
        693019A4 55               push        ebp
        693019A5 8B EC            mov         ebp,esp
        693019A7 56               push        esi
        693019A8 8B F1            mov         esi,ecx
        693019AA 57               push        edi
        693019AB 56               push        esi
        693019AC 33 FF            xor         edi,edi
        693019AE FF 15 00 10 30 69 call        dword ptr [__imp__EnterCriti...
        693019B4 39 7E 18         cmp         dword ptr [DebugDeviceId],edi
                                                         ^^^^^^^^^^^^^
                                                        This is wrong!

                            It should be this->m_fLoaded, which happens to be
                            the 7th DWORD in the object (this pointer is ESI),
                            so it m_fLoaded should be [esi+18h].

                            The code itself appears
                            to work, so this looks like a problem with the
                            debugger display. I don't know how to get it
                            to display just raw instruction instead of
                                cmp dwprd ptr [DebugDeviceID],edi

                            The rest of the dump ...
        693019B7 74 39            je          CTspDevExt::OpenModem+4Eh
        693019B9 39 7E 28         cmp         dword ptr [esi+28h],edi
        693019BC 75 34            jne         CTspDevExt::OpenModem+4Eh
        693019BE FF 75 1C         push        dword ptr [CommPortHandle]
        693019C1 FF 75 18         push        dword ptr [DebugDeviceId]
        693019C4 56               push        esi
        693019C5 68 53 19 30 69   push        offset OurAsyncNotificationProc
        693019CA FF 75 0C         push        dword ptr [CompletionPort]
        693019CD FF 75 08         push        dword ptr [ModemRegistry]
        693019D0 57               push        edi
        693019D1 FF 35 44 30 30 69 push        dword ptr [?g@@3UGLOBAL@@A+24h]
        693019D7 FF 15 50 30 30 69 call        dword ptr [?g@@3UGLOBAL@@A+30h]

6/2/1997 JosephJ
    Incorporating ALL _AT_V-encapsulated changes from unimodem/v into the TSP.
    All phone-specific info is kept in PHONEINFO.
    * done unimdmv/cfgdlg.c
    * ignored forward.c (TSPI_lineForward) This feature is not a good match
      for POTS capabilities. According to brianl, all we were doing was to
      send some digits to the wire (which digits depends on the exchange).

6/3/1997 JosephJ Debugger extensions
    Created dbgext.cpp, which exports TSP debugger extensions. The idea
    is that for beta1, these extension apis are exported in the tsp itself,
    to make it easier to track changes, just like flhash.cpp, which contains
    the static fastlog hash table.

    Unfortunately, windbg doesn't like dlls which don't end with .dll, so
    to actually use the extensions, you have to copy unimdm.tsp into
    unimdm.dll.

    The plan is for each internal object to expose a varity of diagnostic-
    related entry points which can be accessed from windbg via a set
    of commands. These commands will be subset of the commands that 
    can also be executed from a remote process by using the mail-slot
    mechanism.  The latter mechanism allows various diagnostic commands to
    be executed in the process' context, so allows more flexibility.

    The basic command format is !tsp <cmd> <args>
    
    <cmd> is one of:
        help [<cmd>]    help

        dds <device> dump device state for line device <device>

        Example: !tsp dds 5

        dsl <address> Dump the stacklog at address <address>

        Example !tsp dsl 0x209890ab

    -*-


6/6/1997 JosephJ Documentation on LINE_REMOVE, taken from the TAPI2.0 design
        documenation (from http:tapi). (PHONE_REMOVE is equivalent).

6.3.6 LINE_REMOVE (new)

LINE_REMOVE 
----------
LINEEVENTPROC params:
    htLine = (DWORD) 0;
    htCall = (DWORD) 0;
    dwMsg = LINE_REMOVE;
    dwParam1 = (DWORD) dwDeviceID;
    dwParam2 = (DWORD) 0;
    dwParam3 = (DWORD) 0;

dwDeviceID
The device that has been removed.
A service provider sends a LINE_REMOVE message to TAPI when it desires to disable an existing line device. This can occur when the removal of the device from the system (in a permanent way) is detected by Plug and Play or through a control panel or other user interface. It should not be used when a device is temporarily disconnected, such as if the device is a PCMCIA card that is extracted (LINEDEVSTATE_DISCONNECTED or _OUTOFSERVICE should be used in this situation). 
When the message is received, TAPI.DLL will close the line device (if it is not already closed) by calling TSPI_lineClose, and send LINE_CLOSE to all applications that have the line open; if any calls are active, TSPI_lineCloseCall will be called on each of them prior to TSPI_lineClose. After processing of the message, TAPI will not call the service provider referencing the removed devices dwDeviceID. TAPI returns LINEERR_NODEVICE to any application that attempts to reference the removed dwDeviceID.
After TSPI_providerShutdown has been called, the service provider should renumber its devices to remove any numbering gaps left by the device removal, so that when TSPI_providerEnumDevices is subsequently called, installed devices are contiguously numbered. The service provider should not reuse the dwPermanentLineID that had been assigned to the device, for as long as possible.
The LINE_REMOVE mechanism is intended to be used only if devices are removed while the service provider is active (i.e., between TSPI_providerInit and TSPI_providerShutdown).
This message is sent to TAPIs LINEEVENT callback entry point. The service provider receives a pointer to this callback in the TSPI_providerEnumDevices function and in each TSPI_lineOpen function; the LINE_REMOVE message can be sent to the LINEEVENT callback function given to any open line or at startup.
Backward Compatibility
Older service providers would not be expected to send this message. If they do, the message will be treated in the same manner as described above for new service providers.

PHONE_REMOVE
-----------
PHONEEVENTPROC parameters:
    htPhone = (DWORD) 0;
    dwMsg = PHONE_REMOVE;
    dwParam1 = (DWORD) dwDeviceID;
    dwParam2 = (DWORD) 0;
    dwParam3 = (DWORD) 0;
    
    #if 0
    MASK
    PATTERN
    SUBMASK

6/11/1997 JosephJ

    More thoughts on the compact representation of state

        IsState    :  ((state&MASK)==PATTERN)
        SetState   :  state = (state & ~SUBMASK) | PATTERN
    
        #define P_ALLOCATED (0x1L<<0)
        #define M_ALLOCATED  P_ALLOCATED
        #define SM_ALLOCATED ((DWORD)-1)
    
        #define IS_ALLOCATED(_state) \
                ((_state & M_ALLOCATED)==P_ALLOCATED)
    
        #define SET_ALLOCATED(_state) \
                (((_state) = (((_state) & ~SM_ALLOCATED) | P_ALLOCATED)))
    
        #define P_LINE      (P_ALLOCATED | (0x1L<<1))
        #define M_LINE      (P_LINE)
        #define SM_LINE     (P_LINE)
    
        #define P_LINEOPEN  (P_LINE | (0x1L<<2))
        #define P_LINEOPEN  (P_LINE | (0x1L<<2))

    --------------------------

6/17/1997 JosephJ
    I am moving the AIPC start/stop from load/unload LLDev to
   dial/answer/hangup. AIPC is started as the final step of tasks
   TH_MakeCall and TH_AnswerCall, and AIPC is stopped as the 1st step
   of TH_DropCall. Introduced new tasks TH_Start/StopAIPCAction.

6/17/1997 JosephJ 
    Thoughts on "IPPSTN gateway APP."

    Interface to media handling DLL.

    Init:
    >>CallState: CONNECTED/DISCONNECTED/DTMF
    <<Action: Disconnect
    

7/13/1997   JosephJ Passthrough revisited...

    How do we get into passthrough mode?

        (a) When making a passthrough call:  by specifying
            the LINEBEARERMODE_PASSTHROUGH bit in
            LPLINECALLPARAMS.dwBearerMode in TSPI_lineMakeCall.

            IMPLEMENTATION: Special Th_MakePassthroughCall handles this...

        (b) Incoming calls: Switching into passthrough mode on
            an offering call:
              lRet = lineSetCallParams(CallHandle,
                                   LINEBEARERMODE_PASSTHROUGH,
                                   0,
                                   0xffffffff,
                                   NULL);

            IMPLEMENTATION: Special Th_SwitchToPassthrough handles this...


        For  (a), the app will wait for a LINECALLSTATE_CONNECTED
        before it tries to get the comm handle.

        For (b), the a LINECALLSTATE_CONNECTED message is sent only
        if the line is not already connected (BUGBUG: so how is the
        app to know that the passthrough operation is completed?)

    How do we get OUT of passthrough mode?

       (a) TAPI_lineDrop

       (b)  lRet = lineSetCallParams(
                           CallHandle,
                           dwBearerModes & ~LINEBEARERMODE_PASSTHROUGH,
                           0,
                           0xffffffff,
                           NULL
                           );

        For, case (b), the call remains in the connected state, and
        disconnect monitoring continues -- this is typicall done prior
        to handoff from fax to RAS.


        From cdevcall.c: (processing lineSetCallParams)
                //
                //  7/14/1997 JosephJ
                //      TODO/BUGBUG: Enable this once we've fleshed out the
                //      semantics
                //      of switching out of passthrough while there is
                //      actually an active data call...
                //


-------------------------------------------------------------------------------

7/15/1997 JosephJ

    Updating commconfig, deciding when to reinit modem (Bugs # 83917 and 81680)
    ---------------------------------------------------------------------------

    Track the DEFAULT commconfig setting closely, unless it has
    been updated programmatically while the line is open.

    The simple way to do this is to keep a fTrackDefaultCommConfig flag in
    LINEINFO (set on LOAD). If this flag is set, update the commconfig settings:
        (a) Just before it is requested via lineGetDevConfig
        (b) 


    
7/17/1997 JosephJ
    Checked in fixes for following bugs:
        88467: wave/in wave/out, tapi/phone class only reported if device
              supports them.
       
        76151: incoming passthrough (lineSetCallParams bearermode PASSTHROUGH)
               supported.

        Also fixed bug in lineGetID(comm\datamodem) where we were setting
            the 2nd dword to the size of the structure, not to the offset to
            the name of the string.

--------------------------------------------------------------------------------
7/22/1997 JosephJ
        Exposing diagnostics through TAPI until we have official APIs for them.

        Basic idea is to use lineDevSpecificFeature.

--------------------------------------------------------------------------------
7/22/1997 JosephJ
        Radical solution: lineGet/SetCommConfig maps
                    to Get/SetDefaultCommConfig.
        This is what I have done see notes below
-----------------------------------------------------------------------------
7/31/1997 JosephJ Checkin fixes for the following.....
76148       _This Milestone TSP 1   04/01/97    josephj +B1: UNIMODEM 5: TSP: Can't  generate DTMF tones.
    Sorin, I'd like to work with you on the1st pass testing this. Please test lineGenerateDigits. I do not currently support queuing, so you can't send back-to-back lineGenerateDigits and expect the 1st to be cancelled and the 2nd started -- instead the 1st will be cancelled and the 2nd call will fail. Also, the call will fail if the wave device was being start/stopped at that time. Please test various boundary conditions, including making sure that lineGenerateDigits returns failure (LINEERRINVAL_DIGITMOD
E) if asked to generate pulse tones.

81680       _This Milestone TSP 1   05/07/97    josephj +B1: UNIMODEM: Modem goes through extra (unnecessary)  initialization phase before answering.
    Please test (by looking at the log file) that the modem is only initialized as needed (including after a change in the modem config via the CPL or via lineSetDevConfig -- ras does the latter). Definitely test with RAS and HYPERTER and stress!

83917       _This Milestone TSP 1   05/21/97    josephj +B1: TSP doesn't refresh modem settings when changed in CPL
    Please verify behaviour under the following conditions:
(a) tapisrv not running
(b) tapisrv running, no lines open
(c) line is open for  incoming calls, but no call in progress
(d) call is in progress
Verify that things work with ras and hyperterm running when the changes are made in the CPL.
WARNING: this fix also changes the behavior of lineSetDevConfig from NT4 -- it now does a lineSetDefaultCommConfig. Why? Because lineSetDevConfig doesn't have a line or call handle, and early behaviour was flaky. We may have to get RAS to move from using this API to using the callparams, but we'll deal with that later. For now main thing to test is that we don't break common usage.

95720   S0725   _This Milestone TSP 1   07/25/97    josephj +Unimdm: Almost all tapi apis (27) that Unimodem not supported return OPERATIONFAILED not OPERATIONUNAVAIL
    All the apis listed in the bug should now return UNAVAIL

------------------------------------------------------------------------------
8/05/1997 JosephJ
    Changed
        cdev.cpp         41   41  out      
        cdev.h           40   40  out      
        cdevcall.cpp     35   35  out      
        cdevll.cpp       19   19  out      
        fastlog.cpp      21   21  out      
        flhash.cpp       31   31  out      
        notes.txt        36   36  out      

    This fixes the following bugs:
95778   *B1: BVT: UNIMODEM: Doesn't send disconnected message when
                 busy is reported
96599   *B1: UNIMODEM: lineSetAppSpecific unimplemented
97815   *B1: UNIMODEM 5: TSP: g3fax media type is declared as supported,
                 but call made with it fails

------------------------------------------------------------------------------

10/11/1997 JosephJ
    Supporting devices which could be either line devices, phone devices or
    both.

    TAPI needs to be told once, during providerEnum, howmany lines and
    phones are present at init time.

    It will then call providerInit with those same numbers, giving a
    base line-deviceid and phone-deviceid, providing an implicit range
    of tapi lineids and phoneids for the tsp to use.


    The unimodem tsp needs to support this mechanism over our concept
    of supporting devices, each of which could be a line device, a phone
    device, or both.

    How should we do this?


    One providerEnum, the mgr asks the fact for a list of pids, as well as
    the number of line-devices and phone-devices. The mgr caches the list
    of pids. So at this point it has a snapshot of: list of pids (length==
    total number of devices), and the number of lines and phones. Note that
    max(lines, phones) <= number-of-devices.

    On providerInit, we actually ask the factory to create the devices
    corresponding to the list of pids it saved away during providerEnum.
    The factory will try create all of them, but if there some have
    gone away it will only create a subset of them.

    We then go through and actually create the devices, allocating each
    a lineID and phoneID from the pool allocated to us.

    Note that this assumes that every providerInit will be preceded by
    a providerEnum (during which we have a sideaffect of caching the
    specific list of PIDs to use). In practise this is was TAPI does.
    Tf in the future we need to be able to work with two successive
    provdierInits without an intervening providerEnum we can deal with
    then. For now we can assert on this situation.
    
10/13/1997 JosephJ   Dealing with line and phone device creation.
------------------

    When we want to create a new device, we notify TAPI by LINE_CREATE and
    PHONE_CREATE. Tapi calls us back with CreateLineDevice
    and CreatePhoneDevice. We call down the device object's
     "RegisterProviderInfo" when we get the 1st of these notifications, and
    follow it with an DeferredActivateTapiDevice(dwDeviceID, fLine);

10/16/1997 JosephJ Modem Configuration Issues
------------------

    Each TUISPI_providerGenericDialog is expected to not return until
    the diaglog is complate. Our implementation in cdevdlg.cpp
    simply sits in a message loop and return from the function only
    after exiting.


10/16/1997 JosephJ Phone Device Support
------------------

    The voice modem is abstracted as follows:

                                 +--------------+
                       /=========|    LINE      | -> to phone line
   audio stream <=====X(1)       +--------------+
     to PC             \     /===|   HANDSET    | -> to external phone
                        \===X(2) +--------------+
                             \===| SPEAKERPHONE | -> to mike and speaker*
                                 +--------------+

    * The mike and speaker are often the system mike and speaker, and a 
      separate wire is run from the modem (internal card) to the system
      audio card -- a big pain. Someone, I think from Lucent, said that some
      OEMS are skipping voice support because of this wire.
        External modems that support speakerphone have their own jack for mic
      and speakerphone.

    If a call is in progress, the device routes the audio between the 
    line and the terminal endpoints (handset and/or speakerphone).
 
    X(1) represents the switch that decides whether audio that actually goes
    to the PC (via the serial port) comes from the line or the phone
    endpoints. I'm not sure if modems allow switching the stream to 
    the terminal endpoins if a call is in progress. Unimodem/V would not
    allow such functionality.

    X(2) represents which of the various terminal endpoints are enabled
    (off hook) or disabled (on hook) at any point in time. Speakerphone
    endpoints "hookswitch state" can be controlled by AT commands. Handset
    "hookswitch state" tracks the physical handset state (as far as the
    modem can detected it by monitoring the electrical state of the wire
    between the modem and attached handset). The modem sends notification
    of changes to handset state through DLE characters.

    The tricky thing with phone-device support for voice modems is deciding when
    to enable playback/record to handset/speakerphone (in this
    mode the line can't be used and we're using the voice-modem as an isolated
    handset device).

    The semantics of the phone device are different depending on whether
    or not a call is in progress.

    phoneSetHookSwitch  is used to change the off/on-hook states of the various
    terminal devices associated with the modem.

    When a call is in progress, changing these determine whether-or-not
    the audio from the call is routed to/from the various terminals
    (the TSP and app is not involved with the actual routing -- this is crucial
    point).

    When there is no call in progress, it determines which terminals get
    the audio stream to/from the PC (today, via the wave devices that unimodem
    exports).

    Unimodem/V required the line device to be open before it allows the
    phone device to be opened -- this is artificial, especially in the case
    of using the phone device in isolation, and I plan on not requiring this.

    The challenge then is how multiplex use of the line and phone abstractions
    given the implicit linkages when the call is active.

    Apps need to  call phoneOpen to get lineGetID(wave/in/out) -- we shouldn't
    simply open the device and actually start monitoring handset activity
    at that point -- or maybe that OK? One optimization is to only actually
    start monitoring under the following conditions:
            * App specifically requests a specific terminal-state to go
              off-hook (via phoneSetHookSwitch)...)
            * App requests, via lineSetStatusMessages, hook-state notifications.

    When do we slip out of the "terminal actually open" state?
            * phoneClose
            * phoneSetHookSwitch indicates to turn off all status reporting
            * AND phoneSetStatusMessages indicates to put terminals on
              hook (it can only control on-hook/off-hook status for
              speakerphone and headset, NOT handset (this is a unimodem/v
              specific restriction -- clearly our intecom phones
              can be physicall off-hook but be logically-on hook -- when
              the user presses the SPKR button).

    How do we deal with random activity on the tapi line device?

    This is a tricky one. This is best handled by treating the lines
    and phones as independend entities that must multiplex use of
    a single resource -- the actual device.

    Logically, we maintain three structures: LINEINFO, PHONEINFO and
    LLDEVINFO. line state is maintained in LINEINFO; phone state in
    PHONEINFO and the device state in LLDEVINFO
    (LLDEV == "Low-Level Device").

    To keep things clean, line-related and phone-related code
    should not snoop into each other structures, but interact only with
    LLDEVINFO. So, for example, when processing lineMakeCall when
    audio to speakerphone is in progress, the code should fail at the time
    the init or dial is requested, based on the fact that the LLDEVINFO is
    being used for some other activity, not by initial checking of the
    PHONEINFO state.

    One tricky problem is to determine when requests need to be queued. Queuing
    adds complexity and should be avoided unless absolutely necessary. But
    some amount of queuing is necessary, such as when dealing with a phoneClose
    in the middle of an ongoing call!


    I discussed this issue with Brian. MSPhone-Unimodem/V had an ad-hoc and
    broken way of using the phone device -- they required the line device
    to be opened first, and they didn't support monitoring of handset activity
    unless there was an actual call in progress! MSPhone, when doing audio
    to/from handset, would simply open the phone' device, the open
    and start using the phone's wave devices -- it wouldn't bother with
    hookswitch monitoring or setting hookswitch!

    Brian did think it would be a good idea to monitor for hookswitch activity
    as part of the phone device, but recommended that the application be
    able to use the line device as long as there was no actual wave audio
    going on.

    In light of all this, here is the plan for multiplexd use of the device
    as both line and phone devices:
        * AIPC monitoring is enabled for as long as the phone device is
          opened, in addition to when it is currently enabled (which is
          when a voice call is in the connected state).
        * We switch the device into "voice monitor" if phoneSetStatusMessages
          is called to turn on hookswitch status monitoring.
        * We also switch into "voice init" mode if we're asked to make
          one of the terminals go off hook.
        * We switch out of voice-init/voice-monitor when the corresponding
          state happen.
        * If we get a HANDSET_WAVE_ACTION APIC message, we will init the
          modem if required and do the action, provided there's no call
          in progress.
        * The right thing's happen if, for example, the line is open for
          owner and the phone is open form initoring hookswitch activity,
          and a ring comes in.


    Phone-Related Tasks
    -------------------

        EnablePhoneForAudio
            -- open and initialize the device for voice if required
            -- startup AIPC server.
            -- (only allow this if there is no call in progress).
            -- when enabled, disallow any calls to be made or answered.

        DisablePhoneForAudio
            -- close down AIPC server.
            -- de-initialize and close device if required.

        StartPhoneAudio
            -- actually switch device to play/record mode
        StopPhoneAudio
            -- get device out of play/record mode

    Information to be maintained in LLDEVINFO:
        dwReInitFlags: stuff to do when re-initing after some activity:
                -- initialize-for-data/voice/...
                -- monitor-for-?


-------------------------------------------------------------------------------
11/02/1997 JosephJ Enhancements to the tasking model:

    Instead of supporting a single queued task, queing is now the
    responsibility of the clients of the task service.

    At the COMPLETION of a root task, we check if there is a need for
    another ask to run, and if so will start another root task. This is only
    done if the completion is asynchronous -- on synch completion, there
    can NEVER be another pending task, otherwise the task would not even
    have been allowed to start (pending task implies there is some task
    actually executing -- note that we claim the critical section before
    trying to add tasks, so we'll never have the case that on entry
    to StartRootTasks we have no tasks pending but on sync return we
    have a task pending.

    Places which currently expect queuing of tasks...
        CTspDev::mfn_monitor
	    TASKID_TSPI_lineMakeCall:
        TH_lineDrop

-------------------------------------------------------------------------------
11/05/1997 JosephJ

    Basic primitives on CTspDev sub-objects LINEINFO, PHONEINFO and LLDEVINFO,
      CALLINFO (subobject of LINEINFO) and AIPC2 (subobject of LLDEVINFO):
            LoadLine UnloadLine
            LoadCall UnloadCall
            LoadLLDev UnloadLLDev   << Refcounted
            AIPC_Load AIPC_Unload   << Refcounted

      All operations are synchronous although under normal circumstances
      they will not block. Specific  cases under which they block are:
        > UnloadLine or UnloadCall called when call is in progress.
        > UnloadLLDev called with AIPC  or voice streaming in progress.

     Since CALLINFO is contained in LINEINFO, calling UnloadLine will
     call UnloadCall if there is a call active. UnloadCall will call
     TH_DropLine if the call is active and will block until it's completed.

-------------------------------------------------------------------------------
11/08/1997 JosephJ

    Thinking about keeping state information in LLDEV:
        
        dwMonitorFlags
        dwDeferredTasks
        dwInitFlags
        dwHookSwitchDevsState
        dwLineState: off-hook, initiating, connecting, conne

----------

    TH_LLDevGoIdle

        if (HandsetOpen)
        {
            TH_WaveAction(CLOSE_HANDSET);
        }
        else if (OFF_HOOK)
        {
            TH_HangupModem
        }

        // Init

        // If monitor, monitor...

-------

    NEW TASKING MECHANISM, to allow eliminating sleeps...

    * Pending tasks can be synchronously aborted, leaving the top-level pending
      task but replacing the lower-level tasks by a dummy TH_AbortedTask.

    * Allow tasks to have "stages" -- which can be asynchronously completed.
      This allows the top level to go through several asynchronous stage
      completions, allowing for more flexibility.

    * When the async state completes with the task in the ABORTING state,
      the task can then switch to cleanup mode.


    All of the above will allow, for example, a lineCloseCall to be
    processed with no blocks even if, say, a TSPI_lineDrop is in progress.

    The goal is NO BLOCKING in any of the CTspDev code.
--------------------------------------------------------------------------------

11/12/1997 JosephJ Aborting continued....

   Decided to can the "stages" concept -- may as well use subtasks for each 
   stage.
   
   Each task should be responsible for handling the MSG_ABORT message. It
   can do what it choses. dwParam1 contains the abort param, and dwParam2
   contains the ID of the subtask that's currently being executed.

    start:
        Start AIPC
    aipc_complete:
        Start WaveAction
    normal_end:

    abort_start:
    abort_stop_waveaction:
    abort_stop_aipc:

    if (fAborting)
    {
        switch(dwTaskID)
        {
        aipc_complete: goto  abort_stop_aipc;
        wave_complete: goto  abort_stop_waveaction:
        wave_complete: goto  abort_stop_waveaction:
        goto c:
        }
    }
    

The sorts of things that need to be deffered in the lldev:
TH_LLDevOpen/Close          (dwMonitorFlags, fAPC)
TH_LLDevReInit              (no flags)
TH_LLDevGoIdle              (?)
TH_LLDevHybridWaveAction    (dwWaveAction, fHandset)

Open(fAIPC)      <- voice call
Open(fMon)       <- line
Open(fAIPC)      <- phone
Open()           <- data call

Algorithm:
Maintain current instanteneous state:
     monitoring,
     faipc-listening
OnOpen, increment ref-count for fMonitoring and fAipcListen
If required queue or defer TH_LLDevOpen, which will, when it executes,
    monitor if it's not monitoring, and start aipc listen if it's not
    started.
OnClose, decrement ref-count for fMonitoring and fAipcListen
If required queue or defer TH_LLDevClose, which will, if required stop
aipc listening.

Actually Addrefing/releasing is NOT done in the context of a task, but on
completion of a task, if the refcount is zero, it will unload the corresponding
resources.

--------------------------------------------------------------------------
11/18/1997
Stuff that doesn't work:
Hyperterm: configure UI
Hyperterm: connection 

On removing a modem when a phone device was open, hung on phoneshutdown -- had
to kill tapisrv.

Tests:
    * Diagnostics reporting.
    * Closing line when...
        - lineGenerateDigits in effect
        - wave play/record in effect
        - phoneSetXXX in effect
        - lineDrop in effect
    * Closing phone when...
        - all conditions above.
        - phone wave play/record in effect
    * Verify Modem is reinited when config is changed
    * Verify proper reporting of TAPI LINE events

----------------------------------------------------------------------------
11/22/1997 JosephJ Structured Exception Handling

    Implemented and then removed using structured exception handling to
    implement pending tasks. I used try, catch and trow. Things worked
    as expected, except that here and there code depends on getting
    back "pending" from subtasks, for example to set state or to
    send some message to tapi.

    I created a type, "PENDING_EXCEPTION" which was thrown by all async
    mini-driver function wrapper tasks, as well as the UtilTH_NOOP tasks.
    These exceptions were caught in the StartRootTask, StartSubTask and
    AsyncCompleteTask. The documentation in the sdk is adequate. One sticking
    point is strictuly speaking, one should enable the /GX option so
    that distructors are called for objects on the stack. I tried placing
    /GX in the sources file but got a message saying /GX was overridden by
    /GX-, which disables this extra cleanup code by default.
    


----------------------------------------------------------------------------
11/22/1997 JosephJ

Stuff to do:
    * document all TH_ tasks, including parameter handling.
    * make use of context consistant (use pointers).
    * code review all cdev*.* files.
    * step through all codepaths in cdev*.*
    * try out the various scenarios above (11/18/1997).

1/25/1998 JosephJ

12-04-97  JosephJ
    * MAJOR rewrite, support phone devices.
      Main change: the LLDEV state exists on its own, and
      LINE and PHONE are clients of it. This allows the
      phone to be operated independantly of the LINE.
      Refcounting is used. Also moved/rewrote many tasks
      to be more clean and partinioned into line-specific,
      call-specific and lldev-specific tasks (see cdev.h,
      under the TH_* definitions).

01-23-98  JosephJ
    * 129683 -- ISDN init/protoc
      This is is hacky -- the dynamic init is maintained as 
      CTspDev::m_Settings.szPreDialCommand. It is updated
      by CTspDev::ConstructNewPreDialCommand based on the
      protocol bits in MODEMSETTINGS.dwPreferredModemOptions.
      See changes to mcx and unimodem.h
      The static Init is written directly to the registry
      by modemui.DLL
      TODO: move all this into the mini driver some day.

01-25-98  JosephJ
    * Added functionality to logging:
        - interlocked-increment sync counter so we can see the
          true order of different stacklogs
        - associated a device-id with each stack log (device id
           may not be known when the stacklog is created, but
           it can be specified during the call tree.
        - allow external program (umcfg) to enable/disable
          the log (this is possible even in retail!)
        - allow external program to dump cmgr and individual
          state
        [above two by using the tspNotif mailslot-based
         interface]
          
    * Cleaned up handling of DEVCFG/COMMCONFIG changes...

      There are 3 ways for these to be changed:
        1.  From CPL (default, except for spkrvolume &
            blind-dial and max.
        2.  From lineSetDevConfig (dynamic changes)
        3.  Indirectly, bi lineConfigDialog, which gets to us
            via TSPI_providerGenericDialogData.
    
      Apps often DO NOT have the line open when they
      do lineSetDevConfig or lineConfigDialog (I checked
      Hyperterm and Dialer).

      Current  behavior is to do a SetDefaultCommConfig
      if the app calls lineSetDevConfig/lineConfigDialog, becase
      afterall there is no hline associated with this. However,
      now that the modem properties are split into static and 
      dynamic, we can switch back to the old (NT4) behavior...
      New behavior: lineGet/SetDevConfig only effect the
         in-memory versions.

      Currently the tsp doesn't immediately re-init the modem
      on updating its devconfig -- only on the next answer/
      dial -- the most important negative ramification of this
      is that DCB settings (in particarl, port speed) are not
      uptated, so for null modems, this breaks answering, because
      the port needs to be set to the proper settings to
      detect the RING! (NT4 tsp didn't re-init the modem, but it
      DID call SetCommConfig right-away).
      New behavior: if line open for monitoring, will re-init
      the modem if the config settings are changed.

      Currently, if the default properties of the cpl were changed, when
      the tsp is notified it will simply take the new defaults, overriding
      anything set perhaps by a previous lineSetDevConfig. So if
      the user sets the speaker volume from the cpl, it will cause
      us to pick up all the default devconfig info! -- this is
      a bit extreme. With the split of modem properties into
      it makes sense to be more selective.
      New behavior: on getting a cpl-config changed notification, the
      tsp will only pick up the new speaker volume, max port speed (
      unused) and blind-dial setting and apply them immediately.

      One unresolved issue is when/if-at-all to pick changes to
       the default commconfig when the user changes them
       by the "change defaults" under the advanced section....

      New Algorithm:
        We keep just the default commconfig in memory.
        We only make a copy if someone does a SetDevConfig/ConfigDialog.
        As long as we don't have a copy, we pick up changes to
        the default comm config (via the cpl).
        After we have a copy, we pickup spkr-vol, max speed and
        blind-dial settings from the cpl, and also other settings but
        only if they've changed from the previous default value.
        In all cases, if there is a change we schedule a re-init of
        the modem.

        Note: this way, if the user *changes* the default properties
        from the advanced->change-defaults, we pick them up right away.
        If the user wants to pick up the current-defaults right away,
        he/she'll have to change them once and change them back--
        anyway changing the advanced defaults is not a recommended
        procedure.

     This seems a good compromise.

     1/28/1998 -- implemeted above, except we don't implement the last para
     -- defaults are not picked up again once the config settings are
    changed by the app. CTspDev::m_Settings.fConfigUpdatedByApp is set 
    when this happens.

    Note: according to SDK documentation, apps should only call
     lineGet/SetDevConfig after the line is open, and should not expect
    the settings to stick after the line is closed, but the fact is that
    dialer and hyperterm don't bother.


1/28/1998 JosephJ
    Note -- had to deal with the race condition that we're in the
    process of initing the modem in response to
    TSPI_lineSetDefaultMediaDetection when the app calls lineSetDevConfig --
    see comments under  CTspDev::mfn_TH_LLDevUmInitModem in cdevll.cpp
    for details. Things work peachy now....

2/3/1998 JosephJ
    Cleaned phone-device behavior (NT5 bug 135605).
    There are two new tasks:
        CTspDev::mfn_TH_PhoneSetSpeakerPhoneState
	    CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneState
    that replace the following:
        CTspDev::mfn_TH_PhoneAsyncTSPICall
        CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneVolGain
        CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneMode
    Also enhanced stacklogging to dump a list of pending tasks, using
    the MSG_DUMPSTATE task message.

2/11/1998 JosephJ
    Dealing with pre/post-connect terminal problems.
    * The central problem is that the tsp currently can not bring down
      the terminal window -- this is unimplemented.
    * To fix we must (infrastructure is in place) send
      the DLG_CMD_DESTROY command from TSP to app's dialog.
      This should be done when lineDrop or lineCloseCall or LINECALLSTATE
      disconnected.
    * We must make sure that there are no race conditions.

2/12/1998 JosephJ
    Fixed all outstanding problems -- now bring down terminal on lineDrop
    or lineCloseCall.
    Lot of the code in appterm.cpp is poorly written.
    Had to fix a hard problem caused by the fact that SetCommMask
    would fail (once line is disconnected) and cause the terminal thread
    which was waiting on WaitCommEvent to never get out of the wait.
    The main change I made to solve this deadlock is to change the
    blocking call to WaitCommEvent to an overlapped call, then
    WaitForMultipleObjects with the overlapped event and the stop-event --
    so if either is signalled I get out of the wait. If it's the stop-event
    then I exit the thread (all this in function TerminalThread ();

2/12/1998 JosephJ
    Fixed bug in TH_LLDevHybridWaveDevice where it was calling close_handset
    when streaming-voice, instead of first calling stop_streaming (bug#138635).

2/15/1998 JosephJ

    Terminal/Manual-dialog-related changes.

    In the process of implementing manual dialog, I am modifying the 
    terminal-dialog handling code in the following way:
    * The following fields of the TerminalWindowState structure are
      removed:
        dwState field (and it's TRMST_ constants)
            -- this field was never used. The terminal window state is
               maintained within the terminal task.
        dwType -- this field is now maintained as part of internal
               context of the TH_CallPutUpTerminalWindow task.
        ^^^^ SORRY I had to put back dwType because the app dialog
            call's back to determine what type of call it is.

    * The Terminal-related code really deals with manual dial as well
      (as well as talk-drop, should we decide to implement it) --
      so all Terminal-related calls need to be renamed to, say
      CallDialog (this hasn't been done yet). TH_CallPutUpTerminalWindow,
      will switch in/out of passthrough and re-init the modem only if
      it's the right kind of terminal.

    * Manual dialog is a stage of TH_CallMakeCall JUST before dialing.
      If manual-dial is in effect, we still dial, but with an empty
      dial string and with fBLIND -- see comments in TH_CallMakeCall.


2/23/1998 JosephJ -- more possibly relavant t3 stuff from tspi.h:
    #define MSPCALLINFOREASON_MSPSETUPCALL          1L
    #define MSPCALLINFOREASON_INFO                  2L
    
    #define PRIVATEOBJECT_NONE                      0x00000001
    #define PRIVATEOBJECT_CALLID                    0x00000002
    #define PRIVATEOBJECT_LINE                      0x00000003
    #define PRIVATEOBJECT_CALL                      0x00000004
    #define PRIVATEOBJECT_PHONE                     0x00000005
    #define PRIVATEOBJECT_ADDRESS                   0x00000006
    
    LONG
    TSPIAPI
    TSPI_lineAnswerMSP(
        DRV_REQUESTID       dwRequestID,
        HDRVCALL            hdCall,
        LPCSTR              lpsUserUserInfo,
        DWORD               dwSize,
        LPLINEMSPCALLINFO   lpMSPCallInfo
        );
    
2/28/1998 JosephJ Tapi3 stuff...

    In previous days, I added support for TSPI_lineAnswerMSP as well -- similar
    handling to TSPI_lineMakeCallMSP -- basically save the msp context and
    and callback and callback when we get to the connected state.

    I also had to set a few new tapi3-specific fields in LINEDEVCAPS:
    #if (TAPI3)
           //
           // If this is a duplex device, say we support MSP stuff...
           //
           if (m_StaticInfo.Voice.dwProperties & fVOICEPROP_DUPLEX)
           {
                lpLineDevCaps->dwDevCapFlags      |=  LINEDEVCAPFLAGS_MSP;
                lpLineDevCaps->dwAddressTypes =  LINEADDRESSTYPE_PHONENUMBER;
                lpLineDevCaps->ProtocolGuid =  TAPIPROTOCOL_PSTN;
                lpLineDevCaps->dwAvailableTracking = 0;
           }
    #endif // TAPI3

    And in mfn_GetCallInfo ....

    #if (TAPI3)
        lpCallInfo->dwAddressType =  LINEADDRESSTYPE_PHONENUMBER;
    #endif // TAPI3


2/28/1998 JosephJ Outstanding ISDN work items...

    * Remove NvRestore key.
      NVSave key has all the required commands to save and restore nvram,
      and will be only done on demand (will be issued when the modem is opened
      for dialing, but only if the settings have changed and on initial
      install). It will have 5 second timeout for geting a response back to
      these NVSave commands.
    
    * Make protocol specification into keys with multiline commands.
      This also allows us to incorporate authentication.
      Read and present protocols from both GSM and isdn.
      Prefix string with "GSM" or "ISDN".
    
    * Add support from RAS configuration: RAS currently doesn't support this --
      they'll need to do that and indicated that it would be easy.
    
    * Allow ISDN protocols to be specified even if switch-type/spid keys are
      not present. Don't put up ISDN page if those keys are not present
      (obviously) -- this is to allow 3rd parties to provide their own
      spid/switch-type wizard -- or put a text message indicating user needs to
      use vendor-provided spid detection and saving program. We decided not to
      put a "browse button" because we do not want to endorse the
      vendor-provided code -- we can revisit this post nt5 beta2.

    * Finalize definition of the protocol bits.

    -----------------------------
3/2/1998 JosephJ

    PROTOCOL DEFINITION: CAPABILITIES AND SETTINGS
    4 Bearermode: ISDN GSM Analog Reserved: 2 bits
    4 dwSingleChannelRate: 4 bits
    4 dwProtocol: 4 bits
    4 dwProtocolSpecificBits:
    //
    //  b - bearer mode (4bits)
    //  p - protocol    (4bits)
    //  s - single-channel-speed (4bits)
    //  d - protocol data (4bits)
    //
    //      dddd ssss pppp bbbb  
    // fedc ba98 7654 3210 fedc ba98 7654 3210
    // ^bit_31                          bit_0^

    Next steps:
    1. Define updated list of protocol key-names, including GSM
    2. Install ISDN modem with this key names
    3. Modify modemui and structures to reflect the fact that protocol
       specification has become a key.
    4. Add code for parsing and displaying ISDN-vs-GSM protocol settings.
    5. TEST modemui

    6. Modify TSP code so that it creates and issues a multisz predial command.
    7. TEST TSP for dialing

    8. Define lineGetDevConfig/lineGetDevCaps structure for protocol caps.
    9. Perhaps pass in this protocol caps in to processing of lineConfigDialog.
    10. TEST

    11. Cleanup structures and code.

    12. TEST.

    13. Try to build RAS ui code, and modify modem ui window.

    From LSteen:
    1. Issue DN before switch type in US switch setting sequences.
    2. NI-1, AT&T Point to MultiPoint (both have one directory number).
    4. Disable speakerphone when non-analog protocol is selected (GSM/ISDN) --
       claim that disabling speaker settings in the INF property line has no
       effect and they remain active.
    
    GSM protocols....
    HKR, Protocol\GSM, AnalogRLP,,                      AT<cr>  
    //Call Analog Radio Link Protocol on  this is the default for a inf
    // supporting a GSM only card.
    //Normal Analog is the default for an Analog/GSM card.
    HKR, Protocol\GSM, AnalogNRLP,,                   AT<cr> 
    //Call Analog  Radio Link Protocol off  - better  performance under  good
    // radio conditions.
    HKR, Protocol\GSM, V120_56K ,,                       "AT<cr>"  
    //Not yet available drafted in latest ETSI  documentation.
    HKR, Protocol\GSM, V110_1DOT2K,,              "AT<cr>"
    HKR, Protocol\GSM, V110_2DOT4K,,              "AT<cr>"
    HKR, Protocol\GSM, V110_4DOT8K,,              "AT<cr>"
    HKR, Protocol\GSM, V110_9DOT6K,,              "AT<cr>"
    //Speeds 1200 ->9600 V110 already available in Portugal, France, Germany,
    // UK, Sweden, Finland, Belgium etc.
    HKR, Protocol\GSM, V110_14DOT4K,,            "AT<cr>"
    //Supported on latest Nokia/Ericsson cards/phones
    HKR, Protocol\GSM, V110_19DOT2K,,            "AT<cr>"
    HKR, Protocol\GSM, V110_28DOT8K,,            "AT<cr>"
    HKR, Protocol\GSM, V110_38DOT4K,,            "AT<cr>"
    HKR, Protocol\GSM, HDLC_PPP_56K,,           "AT<cr>
    HKR, Protocol\GSM, HDLC_PPP_64K,,           "AT<cr>"
    //Future protocols specified in latest ETSI documentation.
    
    Examples of Inits: 
    -----------------
    
    
    HKR, Protocol\GSM, V120_56K ,,                     "AT+CBST=51,,1<cr>"
    HKR, Protocol\GSM, V110_1DOT2K,,             "AT+CBST=66,,1<cr>"
    HKR, Protocol\GSM, V110_2DOT4K,,             "AT+CBST=68,,1<cr>"
    HKR, Protocol\GSM, V110_4DOT8K,,             "AT+CBST=70,,1<cr>"
    HKR, Protocol\GSM, V110_9DOT6K,,             "AT+CBST=71,,1<cr>"
    HKR, Protocol\GSM, V110_14DOT4K,,           "AT+CBST=75,,1<cr>"
    HKR, Protocol\GSM, V110_19DOT2K,,           "AT+CBST=79,,1<cr>"
    HKR, Protocol\GSM, V110_28DOT8K,,           "AT+CBST=80,,1<cr>"
    HKR, Protocol\GSM, V110_38DOT4K,,           "AT+CBST=81,,1<cr>"
    HKR, Protocol\GSM, HDLC_PPP_56K,,          "AT+CBST=115 , ,1<cr>
    HKR, Protocol\GSM, HDLC_PPP_64K,,          "AT+CBST=116, , 1<cr>"
    
    Protocol names need to be changed.
    ----------------------------------
    Remove:
    HKR, Protocol\ISDN, X75_CEPT,,              "AT\N9<cr>"
    HKR, Protocol\ISDN, X75_VT100,,            "AT\N8<cr>"
    Add:
    
    HKR, Protocol\ISDN, X.75_T_70 ,,                              @64K
    HKR, Protocol\ISDN, X.75_BTX.,,                               @64K
    Add: 
    HKR, Protocol\ISDN, AUTO_128K,, 



3/3/1998 JosephJ NVRAM behavior.
--------------------------------
    If the modem has an NVRam key under ISDN static information, we
    create the static-init keys under "NVRamInit" instead of "OptionalInit".
    Furthermore, we clear the volatile value "NVRamInited" each time the
    settings are changed.
    
    The TSP, on providerInit, will look for the NVRamInited field -- if
    it's not there, it will make a note in the CTspDev. On the 1st Init, it
    will issue the commands in NVRamInit (with a 10 second timeout for each
    command) and create the NVRamInited volatile value.
    
    So we will do a nvram init on the 1st init after reboot and also the 1st
    init after the static settings have been changed.

3/8/1998 JosephJ NVRamInit in tsp...
--------------------------------
    If the modem has an NVRam key under ISDN static information, we
    There are two places where TH_LLDevUmInitModem is called:
        (1) from mfn_TH_LLDevNormalize and
        (2) from mfn_TH_CallStartTerminal -- after the pre-connect terminal.

    I decided to put the issuing of the nvram init stage in TH_LLDevNormalize:
    after the call to mfn_TH_LLDevUmInitModem. This means that if
    the ISDN static config is changed during the pre-connect terminal phase
    we will not issue the nvram init commands until after the current call --
    which is perfectly fine.

    I'll create a new task:
        mfn_TH_LLDevIssueMultipleCommands
            dwParam1 == multisz ASCII string containing already-translated
                command strings (which means that the NULL character can't be
                used as a command character -- we can deal with this).
                The string is guaranteed to be available for as long as the
                task is running (the task is not responsible for freeing the
                string).
            dwParam2 == Per-command timeout.
            It will fail on the 1st command that timesout or fails.

    
    mfn_TH_LLDevNormalize will call the above task after it calls
    mfn_TH_LLDevUmInit mode, but only if it needs to: based on the
            fDoNVRamInit flag in CTspDev.

    Note that the protocol command will also use
    mfn_TH_LLDevIssueMultipleCommands.

    Aborting mini-driver async task behavior: set fAborted bit so that
    we don't issue any further commands on aborting.

3/20/1998 JosephJ This concerns  VOICEPROF_MODEM_OVERRIDES_HANDSET and cirrus
                  modems:

    From:   Brian Lieuallen 
    Sent:   Thursday, March 19, 1998 5:30 PM
    To: Costel Radu; Joseph Joy
    Cc: Jim Hood (Volt Computer); Jim Spoltman
    Subject:    RE: Cirrus modem: generate digits


    The reason for this code, was that if we made a class 8 call on a cirrus
    voice modem the handset would be disconnected
    from the line. So if you used dialer to dial a call you could not use
    the handset until the modem was hung up, since
    this is a voice modem, we did not put up the talk drop dialog so the user
    would not know to drop the call in order to talk.

    So for cirrus modems, dialing interactive voice calls we basically use
    the same behavior as dialing a interactive voice call
    with a data modem. When we do this we dial in class 0 and can not send
    the generate digit commands.

    I think that the code for lineGenerateDigits() should be changed to check
    if  dwVoiceProfile & VOICEPROF_MODEM_OVERRIDES_HANDSET is set and if the
    call is an automated voice call then it should allow the call to proceed.
    If it is interactive voice and VOICEPROF_MODEM_OVERRIDES_HANDSET then the
    call should fail.

3/24/1998 JosephJ
    Bug#132798 Race condition when PCMCIA modem is removed.
    One of the manifestations of this problem is if re-enumeration happens
    when the call is in the connected state with no pending tasks --
    re-enum marks the device for removal and sends up a LINE_CLOSE.
    TAPI calls TSPI_lineCloseCall and TSPI_lineClose, both of which 
    return immediately after starting a LLDevNormalize task. On return
    from TSPI_lineClose, the ctspdevmgr unloads and deletes the device,
    because it is marked for removal. However there is still a normalize
    session going.
    A secondary problem is that in the case we debugged, there was also
    a pending TSPI_lineGetCallStatus on another thread -- it was av'ing 
    when it tried to claim the crit-sect of the now-deleted device object.

3/28/1998 JosephJ
    Periodically, run perl script to check for typos, for example:
        T:\SRC\unimodem\nt50\tsp\cdev.cpp (1642):   ASSERT(m_pLine = NULL);
        T:\SRC\unimodem\:qnt50\tsp\cdev.cpp (1648): ASSERT(m_pPhone = NULL);
        T:\SRC\unimodem\nt50\tsp\cdevcall.cpp (2362):   dwCallFeatures == 0;

    Run the typo.pl perl script, which can be found at
         <file://\\itg1\contrib\JohnnyL\typo> 

    Explanations of the flagged lines can be found here and in the typo.pl file:
    
    #   Following potential programming errors are flagged:
    #     I   - semicolon appended to an if statement
    #     II  - use of "==" instead of "=" in assignment statements
    #     III - assignment of a number in an if statement, probably meant
    #           a comparison
    #     IV  - assignment within an Assert
    #     V   - increment/decrement of dereferenced ptr statement
    #     VI  - logical AND with a number
    #     VII - logical OR with a number
    #     VIII- bitwise-AND/OR/XOR of number compared to another value
    #           may have undesired result due to C precedence rules
    #           since bitwise-AND/OR/XOR has lower precedence than
    #           the comparison operators.
    #     IX  - referencing Release/AddRef instead of invoking them
    #     X   - whitespace following a line-continuation character
    #     XI  - shift operator ( <<, >> ) followed by +,-,*,/ may 
    #           have undesired result due to C precedence rules.
    #           The shift operator has lower precedence.

3/28/1998 JosephJ
    Procedure for fixing bug#132798 (3/24 note above).
    * If device being removed, notify CTspDev that device is to be removed,
      so that it will not initiate any new minidriver calls, even hangup.
    * Respect reference count -- NEVER delete until reference count is zero.
    * Make sure that any pending tsp calls, such as lineGetCallStatus above,
      will not cause an assert.
    * Do something about cleaning up pending wave activity.

3/28/1998 JosephJ
    ISDN protocol info
    Q: How to specify protocol caps to application?
    A: Add a new device class: "comm/extendedcaps"
        Doing a lineGetDevConfig on this will get capabilities in an
        extensible format: the LINEDIAGNOSTICSOBJECTHEADER format, which
        should be renamed to be something more general, perhaps.

4/4/98 JosephJ
    Should make sure the a COPY of  szPreDialString is used to actually issue
    the command, because it is now going to be multisz, and therefore,
    it's possible that lineSetDevConfig is called while it's actively
    being used.

4/5/1998 JosephJ
    Migrated the diagnostics parsing and callerid from the extension dll
    to the TSP in about two hours.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\tsp\tspi20_r.txt ===
@name: TSPI_lineAccept
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCSTR lpsUserUserInfo,
		DWORD dwSize
)
;
@name: TSPI_lineAddToConference
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdConfCall,
		HDRVCALL hdConsultCall
)
;
@name: TSPI_lineAnswer
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCSTR lpsUserUserInfo,
		DWORD dwSize
)
;
@name: TSPI_lineBlindTransfer
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCWSTR lpszDestAddress,
		DWORD dwCountryCode
)
;
@name: TSPI_lineCloseCall
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall
)
;
@name: TSPI_lineCompleteCall
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPDWORD lpdwCompletionID,
		DWORD dwCompletionMode,
		DWORD dwMessageID
)
;
@name: TSPI_lineCompleteTransfer
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		HDRVCALL hdConsultCall,
		HTAPICALL htConfCall,
		LPHDRVCALL lphdConfCall,
		DWORD dwTransferMode
)
;
@name: TSPI_lineConditionalMediaDetection
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		DWORD dwMediaModes,
		LPLINECALLPARAMS const lpCallParams
)
;
@name: TSPI_lineDevSpecific
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HDRVCALL hdCall,
		LPVOID lpParams,
		DWORD dwSize
)
;
@name: TSPI_lineDevSpecificFeature
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwFeature,
		LPVOID lpParams,
		DWORD dwSize
)
;
@name: TSPI_lineDial
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCWSTR lpszDestAddress,
		DWORD dwCountryCode
)
;
@name: TSPI_lineDrop
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCSTR lpsUserUserInfo,
		DWORD dwSize
)
;
@name: TSPI_lineDropOnClose
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall
)
;
@name: TSPI_lineDropNoOwner
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall
)
;
@name: TSPI_lineForward
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD bAllAddresses,
		DWORD dwAddressID,
		LPLINEFORWARDLIST const lpForwardList,
		DWORD dwNumRingsNoAnswer,
		HTAPICALL htConsultCall,
		LPHDRVCALL lphdConsultCall,
		LPLINECALLPARAMS const lpCallParams
)
;
@name: TSPI_lineGatherDigits
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwEndToEndID,
		DWORD dwDigitModes,
		LPWSTR lpsDigits,
		DWORD dwNumDigits,
		LPCWSTR lpszTerminationDigits,
		DWORD dwFirstDigitTimeout,
		DWORD dwInterDigitTimeout
)
;
@name: TSPI_lineGenerateDigits
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwEndToEndID,
		DWORD dwDigitMode,
		LPCWSTR lpszDigits,
		DWORD dwDuration
)
;
@name: TSPI_lineGenerateTone
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwEndToEndID,
		DWORD dwToneMode,
		DWORD dwDuration,
		DWORD dwNumTones,
		LPLINEGENERATETONE const lpTones
)
;
@name: TSPI_lineGetAddressCaps
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwAddressID,
		DWORD dwTSPIVersion,
		DWORD dwExtVersion,
		LPLINEADDRESSCAPS lpAddressCaps
)
;
@name: TSPI_lineGetAddressID
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		LPDWORD lpdwAddressID,
		DWORD dwAddressMode,
		LPCWSTR lpsAddress,
		DWORD dwSize
)
;
@name: TSPI_lineGetAddressStatus
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		DWORD dwAddressID,
		LPLINEADDRESSSTATUS lpAddressStatus
)
;
@name: TSPI_lineGetCallAddressID
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		LPDWORD lpdwAddressID
)
;
@name: TSPI_lineGetCallInfo
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		LPLINECALLINFO lpCallInfo
)
;
@name: TSPI_lineGetCallStatus
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		LPLINECALLSTATUS lpCallStatus
)
;
@name: TSPI_lineGetDevCaps
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		DWORD dwExtVersion,
		LPLINEDEVCAPS lpLineDevCaps
)
;
@name: TSPI_lineGetDevConfig
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		LPVARSTRING lpDeviceConfig,
		LPCWSTR lpszDeviceClass
)
;
@name: TSPI_lineGetExtensionID
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		LPLINEEXTENSIONID lpExtensionID
)
;
@name: TSPI_lineGetIcon
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		LPCWSTR lpszDeviceClass,
		LPHICON lphIcon
)
;
@name: TSPI_lineGetID
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HDRVCALL hdCall,
		DWORD dwSelect,
		LPVARSTRING lpDeviceID,
		LPCWSTR lpszDeviceClass,
		HANDLE hTargetProcess
)
;
@name: TSPI_lineGetLineDevStatus
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		LPLINEDEVSTATUS lpLineDevStatus
)
;
@name: TSPI_lineGetNumAddressIDs
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		LPDWORD lpdwNumAddressIDs
)
;
@name: TSPI_lineHold
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
;
@name: TSPI_lineMakeCall
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		HTAPICALL htCall,
		LPHDRVCALL lphdCall,
		LPCWSTR lpszDestAddress,
		DWORD dwCountryCode,
		LPLINECALLPARAMS const lpCallParams
)
;
@name: TSPI_lineMonitorDigits
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwDigitModes
)
;
@name: TSPI_lineMonitorMedia
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwMediaModes
)
;
@name: TSPI_lineMonitorTones
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwToneListID,
		LPLINEMONITORTONE const lpToneList,
		DWORD dwNumEntries
)
;
@name: TSPI_lineNegotiateExtVersion
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		DWORD dwLowVersion,
		DWORD dwHighVersion,
		LPDWORD lpdwExtVersion
)
;
@name: TSPI_linePark
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		DWORD dwParkMode,
		LPCWSTR lpszDirAddress,
		LPVARSTRING lpNonDirAddress
)
;
@name: TSPI_linePickup
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HTAPICALL htCall,
		LPHDRVCALL lphdCall,
		LPCWSTR lpszDestAddress,
		LPCWSTR lpszGroupID
)
;
@name: TSPI_linePrepareAddToConference
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdConfCall,
		HTAPICALL htConsultCall,
		LPHDRVCALL lphdConsultCall,
		LPLINECALLPARAMS const lpCallParams
)
;
@name: TSPI_lineRedirect
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCWSTR lpszDestAddress,
		DWORD dwCountryCode
)
;
@name: TSPI_lineReleaseUserUserInfo
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
;
@name: TSPI_lineRemoveFromConference
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
;
@name: TSPI_lineSecureCall
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
;
@name: TSPI_lineSelectExtVersion
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		DWORD dwExtVersion
)
;
@name: TSPI_lineSendUserUserInfo
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCSTR lpsUserUserInfo,
		DWORD dwSize
)
;
@name: TSPI_lineSetAppSpecific
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwAppSpecific
)
;
@name: TSPI_lineSetCallData
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPVOID lpCallData,
		DWORD dwSize
)
;
@name: TSPI_lineSetCallParams
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		DWORD dwBearerMode,
		DWORD dwMinRate,
		DWORD dwMaxRate,
		LPLINEDIALPARAMS const lpDialParams
)
;
@name: TSPI_lineSetCallQualityOfService
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPVOID lpSendingFlowspec,
		DWORD dwSendingFlowspecSize,
		LPVOID lpReceivingFlowspec,
		DWORD dwReceivingFlowspecSize
)
;
@name: TSPI_lineSetCallTreatment
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		DWORD dwTreatment
)
;
@name: TSPI_lineSetDefaultMediaDetection
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		DWORD dwMediaModes
)
;
@name: TSPI_lineSetDevConfig
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		LPVOID const lpDeviceConfig,
		DWORD dwSize,
		LPCWSTR lpszDeviceClass
)
;
@name: TSPI_lineSetLineDevStatus
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwStatusToChange,
		DWORD fStatus
)
;
@name: TSPI_lineSetMediaControl
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HDRVCALL hdCall,
		DWORD dwSelect,
		LPLINEMEDIACONTROLDIGIT const lpDigitList,
		DWORD dwDigitNumEntries,
		LPLINEMEDIACONTROLMEDIA const lpMediaList,
		DWORD dwMediaNumEntries,
		LPLINEMEDIACONTROLTONE const lpToneList,
		DWORD dwToneNumEntries,
		LPLINEMEDIACONTROLCALLSTATE const lpCallStateList,
		DWORD dwCallStateNumEntries
)
;
@name: TSPI_lineSetMediaMode
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVCALL hdCall,
		DWORD dwMediaMode
)
;
@name: TSPI_lineSetStatusMessages
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVLINE hdLine,
		DWORD dwLineStates,
		DWORD dwAddressStates
)
;
@name: TSPI_lineSetTerminal
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HDRVCALL hdCall,
		DWORD dwSelect,
		DWORD dwTerminalModes,
		DWORD dwTerminalID,
		DWORD bEnable
)
;
@name: TSPI_lineSetupConference
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		HDRVLINE hdLine,
		HTAPICALL htConfCall,
		LPHDRVCALL lphdConfCall,
		HTAPICALL htConsultCall,
		LPHDRVCALL lphdConsultCall,
		DWORD dwNumParties,
		LPLINECALLPARAMS const lpCallParams
)
;
@name: TSPI_lineSetupTransfer
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		HTAPICALL htConsultCall,
		LPHDRVCALL lphdConsultCall,
		LPLINECALLPARAMS const lpCallParams
)
;
@name: TSPI_lineSwapHold
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdActiveCall,
		HDRVCALL hdHeldCall
)
;
@name: TSPI_lineUncompleteCall
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwCompletionID
)
;
@name: TSPI_lineUnhold
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
;
@name: TSPI_lineUnpark
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HTAPICALL htCall,
		LPHDRVCALL lphdCall,
		LPCWSTR lpszDestAddress
)
;
@name: TSPI_phoneDevSpecific
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		LPVOID lpParams,
		DWORD dwSize
)
;
@name: TSPI_phoneGetButtonInfo
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		DWORD dwButtonLampID,
		LPPHONEBUTTONINFO lpButtonInfo
)
;
@name: TSPI_phoneGetData
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		DWORD dwDataID,
		LPVOID lpData,
		DWORD dwSize
)
;
@name: TSPI_phoneGetDevCaps
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		DWORD dwExtVersion,
		LPPHONECAPS lpPhoneCaps
)
;
@name: TSPI_phoneGetDisplay
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		LPVARSTRING lpDisplay
)
;
@name: TSPI_phoneGetExtensionID
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		LPPHONEEXTENSIONID lpExtensionID
)
;
@name: TSPI_phoneGetGain
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDev,
		LPDWORD lpdwGain
)
;
@name: TSPI_phoneGetHookSwitch
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		LPDWORD lpdwHookSwitchDevs
)
;
@name: TSPI_phoneGetIcon
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		LPCWSTR lpszDeviceClass,
		LPHICON lphIcon
)
;
@name: TSPI_phoneGetID
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		LPVARSTRING lpDeviceID,
		LPCWSTR lpszDeviceClass,
		HANDLE hTargetProcess
)
;
@name: TSPI_phoneGetLamp
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		DWORD dwButtonLampID,
		LPDWORD lpdwLampMode
)
;
@name: TSPI_phoneGetRing
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		LPDWORD lpdwRingMode,
		LPDWORD lpdwVolume
)
;
@name: TSPI_phoneGetStatus
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		LPPHONESTATUS lpPhoneStatus
)
;
@name: TSPI_phoneGetVolume
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDev,
		LPDWORD lpdwVolume
)
;
@name: TSPI_phoneNegotiateExtVersion
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		DWORD dwLowVersion,
		DWORD dwHighVersion,
		LPDWORD lpdwExtVersion
)
;
@name: TSPI_phoneNegotiateTSPIVersion
 @ret: LONG
@qual: TSPIAPI
@args: (
		DWORD dwDeviceID,
		DWORD dwLowVersion,
		DWORD dwHighVersion,
		LPDWORD lpdwTSPIVersion
)
;
@name: TSPI_phoneSelectExtVersion
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		DWORD dwExtVersion
)
;
@name: TSPI_phoneSetButtonInfo
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwButtonLampID,
		LPPHONEBUTTONINFO const lpButtonInfo
)
;
@name: TSPI_phoneSetData
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwDataID,
		LPVOID const lpData,
		DWORD dwSize
)
;
@name: TSPI_phoneSetDisplay
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwRow,
		DWORD dwColumn,
		LPCWSTR lpsDisplay,
		DWORD dwSize
)
;
@name: TSPI_phoneSetGain
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDev,
		DWORD dwGain
)
;
@name: TSPI_phoneSetHookSwitch
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDevs,
		DWORD dwHookSwitchMode
)
;
@name: TSPI_phoneSetLamp
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwButtonLampID,
		DWORD dwLampMode
)
;
@name: TSPI_phoneSetRing
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwRingMode,
		DWORD dwVolume
)
;
@name: TSPI_phoneSetStatusMessages
 @ret: LONG
@qual: TSPIAPI
@args: (
		HDRVPHONE hdPhone,
		DWORD dwPhoneStates,
		DWORD dwButtonModes,
		DWORD dwButtonStates
)
;
@name: TSPI_phoneSetVolume
 @ret: LONG
@qual: TSPIAPI
@args: (
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDev,
		DWORD dwVolume
)
;
@name: TUISPI_lineConfigDialog
 @ret: LONG
@qual: TSPIAPI
@args: (
		TUISPIDLLCALLBACK lpfnUIDLLCallback,
		DWORD dwDeviceID,
		HWND hwndOwner,
		LPCWSTR lpszDeviceClass
)
;
@name: TUISPI_lineConfigDialogEdit
 @ret: LONG
@qual: TSPIAPI
@args: (
		TUISPIDLLCALLBACK lpfnUIDLLCallback,
		DWORD dwDeviceID,
		HWND hwndOwner,
		LPCWSTR lpszDeviceClass,
		LPVOID const lpDeviceConfigIn,
		DWORD dwSize,
		LPVARSTRING lpDeviceConfigOut
)
;
@name: TUISPI_phoneConfigDialog
 @ret: LONG
@qual: TSPIAPI
@args: (
		TUISPIDLLCALLBACK lpfnUIDLLCallback,
		DWORD dwDeviceID,
		HWND hwndOwner,
		LPCWSTR lpszDeviceClass
)
;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\tsp\tspi20_p.txt ===
// TAPI 2.0 TSPI function prototypes
// Created from NT4.0 TSPI.H
// 
// 11/08/1996 JosephJ Created
//

LONG
TSPIAPI
TSPI_lineAccept(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineAddToConference(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdConfCall,
    HDRVCALL            hdConsultCall
    );

LONG
TSPIAPI
TSPI_lineAnswer(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineBlindTransfer(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode);

LONG
TSPIAPI
TSPI_lineClose(
    HDRVLINE            hdLine
    );

LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineCompleteCall(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPDWORD             lpdwCompletionID,
    DWORD               dwCompletionMode,
    DWORD               dwMessageID
    );

LONG
TSPIAPI
TSPI_lineCompleteTransfer(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    HDRVCALL            hdConsultCall,
    HTAPICALL           htConfCall,
    LPHDRVCALL          lphdConfCall,
    DWORD               dwTransferMode
    );

LONG
TSPIAPI
TSPI_lineConditionalMediaDetection(
    HDRVLINE            hdLine,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
TSPIAPI
TSPI_lineDevSpecific(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    HDRVCALL            hdCall,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineDevSpecificFeature(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwFeature,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineDial(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode
    );

LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineDropOnClose(                                           // TSPI v1.4
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineDropNoOwner(                                           // TSPI v1.4
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineForward(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
TSPIAPI
TSPI_lineGatherDigits(
    HDRVCALL            hdCall,
    DWORD               dwEndToEndID,
    DWORD               dwDigitModes,
    LPWSTR              lpsDigits,
    DWORD               dwNumDigits,
    LPCWSTR             lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    );

LONG
TSPIAPI
TSPI_lineGenerateDigits(
    HDRVCALL            hdCall,
    DWORD               dwEndToEndID,
    DWORD               dwDigitMode,
    LPCWSTR             lpszDigits,
    DWORD               dwDuration
    );

LONG
TSPIAPI
TSPI_lineGenerateTone(
    HDRVCALL            hdCall,
    DWORD               dwEndToEndID,
    DWORD               dwToneMode,
    DWORD               dwDuration,
    DWORD               dwNumTones,
    LPLINEGENERATETONE  const lpTones
    );

LONG
TSPIAPI
TSPI_lineGetAddressCaps(
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwTSPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    );

LONG
TSPIAPI
TSPI_lineGetAddressID(
    HDRVLINE            hdLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCWSTR             lpsAddress,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineGetAddressStatus(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    );

LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL            hdCall,
    LPDWORD             lpdwAddressID
    );

LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL            hdCall,
    LPLINECALLINFO      lpCallInfo
    );

LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL            hdCall,
    LPLINECALLSTATUS    lpCallStatus
    );

LONG
TSPIAPI
TSPI_lineGetDevCaps(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

LONG
TSPIAPI
TSPI_lineGetDevConfig(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCWSTR             lpszDeviceClass
    );

LONG
TSPIAPI
TSPI_lineGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    );

LONG
TSPIAPI
TSPI_lineGetIcon(
    DWORD               dwDeviceID,
    LPCWSTR             lpszDeviceClass,
    LPHICON             lphIcon
    );

LONG
TSPIAPI
TSPI_lineGetID(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    HDRVCALL            hdCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCWSTR             lpszDeviceClass,
    HANDLE              hTargetProcess                          // TSPI v2.0
    );


LONG
TSPIAPI
TSPI_lineGetLineDevStatus(
    HDRVLINE            hdLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    );

LONG
TSPIAPI
TSPI_lineGetNumAddressIDs(
    HDRVLINE            hdLine,
    LPDWORD             lpdwNumAddressIDs
    );

LONG
TSPIAPI
TSPI_lineHold(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          lphdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
TSPIAPI
TSPI_lineMonitorDigits(
    HDRVCALL            hdCall,
    DWORD               dwDigitModes
    );

LONG
TSPIAPI
TSPI_lineMonitorMedia(
    HDRVCALL            hdCall,
    DWORD               dwMediaModes
    );

LONG
TSPIAPI
TSPI_lineMonitorTones(
    HDRVCALL            hdCall,
    DWORD               dwToneListID,
    LPLINEMONITORTONE   const lpToneList,
    DWORD               dwNumEntries
    );

LONG
TSPIAPI
TSPI_lineNegotiateExtVersion(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    DWORD               dwLowVersion,
    DWORD               dwHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD               dwDeviceID,
    DWORD               dwLowVersion,
    DWORD               dwHighVersion,
    LPDWORD             lpdwTSPIVersion
    );

LONG
TSPIAPI
TSPI_lineOpen(
    DWORD               dwDeviceID,
    HTAPILINE           htLine,
    LPHDRVLINE          lphdLine,
    DWORD               dwTSPIVersion,
    LINEEVENT           lpfnEventProc
    );

LONG
TSPIAPI
TSPI_linePark(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    DWORD               dwParkMode,
    LPCWSTR             lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    );

LONG
TSPIAPI
TSPI_linePickup(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    HTAPICALL           htCall,
    LPHDRVCALL          lphdCall,
    LPCWSTR             lpszDestAddress,
    LPCWSTR             lpszGroupID
    );

LONG
TSPIAPI
TSPI_linePrepareAddToConference(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdConfCall,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
TSPIAPI
TSPI_lineRedirect(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode
    );

LONG
TSPIAPI
TSPI_lineReleaseUserUserInfo(                                   // TSPI v1.4
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineRemoveFromConference(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineSecureCall(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineSelectExtVersion(
    HDRVLINE            hdLine,
    DWORD               dwExtVersion
    );

LONG
TSPIAPI
TSPI_lineSendUserUserInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineSetAppSpecific(
    HDRVCALL            hdCall,
    DWORD               dwAppSpecific
    );

LONG
TSPIAPI
TSPI_lineSetCallData(                                           // TSPI v2.0
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPVOID              lpCallData,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_lineSetCallParams(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    );

LONG
TSPIAPI
TSPI_lineSetCallQualityOfService(                               // TSPI v2.0
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPVOID              lpSendingFlowspec,
    DWORD               dwSendingFlowspecSize,
    LPVOID              lpReceivingFlowspec,
    DWORD               dwReceivingFlowspecSize
    );

LONG
TSPIAPI
TSPI_lineSetCallTreatment(                                      // TSPI v2.0
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    DWORD               dwTreatment
    );

LONG
TSPIAPI
TSPI_lineSetCurrentLocation(                                    // TSPI v1.4
    DWORD               dwLocation
    );

LONG
TSPIAPI
TSPI_lineSetDefaultMediaDetection(
    HDRVLINE            hdLine,
    DWORD               dwMediaModes
    );

LONG
TSPIAPI
TSPI_lineSetDevConfig(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCWSTR             lpszDeviceClass
    );

LONG
TSPIAPI
TSPI_lineSetLineDevStatus(                                      // TSPI v2.0
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwStatusToChange,
    DWORD               fStatus
    );

LONG
TSPIAPI
TSPI_lineSetMediaControl(
    HDRVLINE                    hdLine,
    DWORD                       dwAddressID,
    HDRVCALL                    hdCall,
    DWORD                       dwSelect,
    LPLINEMEDIACONTROLDIGIT     const lpDigitList,
    DWORD                       dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA     const lpMediaList,
    DWORD                       dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE      const lpToneList,
    DWORD                       dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList,
    DWORD                       dwCallStateNumEntries
    );

LONG
TSPIAPI
TSPI_lineSetMediaMode(
    HDRVCALL            hdCall,
    DWORD               dwMediaMode
    );

LONG
TSPIAPI
TSPI_lineSetStatusMessages(
    HDRVLINE            hdLine,
    DWORD               dwLineStates,
    DWORD               dwAddressStates
    );

LONG
TSPIAPI
TSPI_lineSetTerminal(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    HDRVCALL            hdCall,
    DWORD               dwSelect,
    DWORD               dwTerminalModes,
    DWORD               dwTerminalID,
    DWORD               bEnable
    );

LONG
TSPIAPI
TSPI_lineSetupConference(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    HDRVLINE            hdLine,
    HTAPICALL           htConfCall,
    LPHDRVCALL          lphdConfCall,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
TSPIAPI
TSPI_lineSetupTransfer(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    HTAPICALL           htConsultCall,
    LPHDRVCALL          lphdConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
TSPIAPI
TSPI_lineSwapHold(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdActiveCall,
    HDRVCALL            hdHeldCall
    );

LONG
TSPIAPI
TSPI_lineUncompleteCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwCompletionID
    );

LONG
TSPIAPI
TSPI_lineUnhold(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineUnpark(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    HTAPICALL           htCall,
    LPHDRVCALL          lphdCall,
    LPCWSTR             lpszDestAddress
    );

LONG
TSPIAPI
TSPI_phoneClose(
    HDRVPHONE           hdPhone
    );

LONG
TSPIAPI
TSPI_phoneDevSpecific(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_phoneGetButtonInfo(
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    );

LONG
TSPIAPI
TSPI_phoneGetData(
    HDRVPHONE           hdPhone,
    DWORD               dwDataID,
    LPVOID              lpData,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_phoneGetDevCaps(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

LONG
TSPIAPI
TSPI_phoneGetDisplay(
    HDRVPHONE           hdPhone,
    LPVARSTRING         lpDisplay
    );

LONG
TSPIAPI
TSPI_phoneGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    );

LONG
TSPIAPI
TSPI_phoneGetGain(
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwGain
    );

LONG
TSPIAPI
TSPI_phoneGetHookSwitch(
    HDRVPHONE           hdPhone,
    LPDWORD             lpdwHookSwitchDevs
    );

LONG
TSPIAPI
TSPI_phoneGetIcon(
    DWORD               dwDeviceID,
    LPCWSTR             lpszDeviceClass,
    LPHICON             lphIcon
    );

LONG
TSPIAPI
TSPI_phoneGetID(
    HDRVPHONE           hdPhone,
    LPVARSTRING         lpDeviceID,
    LPCWSTR             lpszDeviceClass,
    HANDLE              hTargetProcess                          // TSPI v2.0
    );

LONG
TSPIAPI
TSPI_phoneGetLamp(
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPDWORD             lpdwLampMode
    );

LONG
TSPIAPI
TSPI_phoneGetRing(
    HDRVPHONE           hdPhone,
    LPDWORD             lpdwRingMode,
    LPDWORD             lpdwVolume
    );

LONG
TSPIAPI
TSPI_phoneGetStatus(
    HDRVPHONE           hdPhone,
    LPPHONESTATUS       lpPhoneStatus
    );

LONG
TSPIAPI
TSPI_phoneGetVolume(
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwVolume
    );

LONG
TSPIAPI
TSPI_phoneNegotiateExtVersion(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    DWORD               dwLowVersion,
    DWORD               dwHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
TSPIAPI
TSPI_phoneNegotiateTSPIVersion(
    DWORD               dwDeviceID,
    DWORD               dwLowVersion,
    DWORD               dwHighVersion,
    LPDWORD             lpdwTSPIVersion
    );

LONG
TSPIAPI
TSPI_phoneOpen(
    DWORD               dwDeviceID,
    HTAPIPHONE          htPhone,
    LPHDRVPHONE         lphdPhone,
    DWORD               dwTSPIVersion,
    PHONEEVENT          lpfnEventProc
    );

LONG
TSPIAPI
TSPI_phoneSelectExtVersion(
    HDRVPHONE           hdPhone,
    DWORD               dwExtVersion
    );

LONG
TSPIAPI
TSPI_phoneSetButtonInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    );

LONG
TSPIAPI
TSPI_phoneSetData(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwDataID,
    LPVOID              const lpData,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_phoneSetDisplay(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwRow,
    DWORD               dwColumn,
    LPCWSTR             lpsDisplay,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_phoneSetGain(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwGain
    );

LONG
TSPIAPI
TSPI_phoneSetHookSwitch(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDevs,
    DWORD               dwHookSwitchMode
    );

LONG
TSPIAPI
TSPI_phoneSetLamp(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    DWORD               dwLampMode
    );

LONG
TSPIAPI
TSPI_phoneSetRing(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwRingMode,
    DWORD               dwVolume
    );

LONG
TSPIAPI
TSPI_phoneSetStatusMessages(
    HDRVPHONE           hdPhone,
    DWORD               dwPhoneStates,
    DWORD               dwButtonModes,
    DWORD               dwButtonStates
    );

LONG
TSPIAPI
TSPI_phoneSetVolume(
    DRV_REQUESTID       dwRequestID,
    HDRVPHONE           hdPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwVolume
    );



LONG
TSPIAPI
TSPI_providerCreateLineDevice(                                  // TSPI v1.4
    DWORD               dwTempID,
    DWORD               dwDeviceID
    );

LONG
TSPIAPI
TSPI_providerCreatePhoneDevice(                                 // TSPI v1.4
    DWORD               dwTempID,
    DWORD               dwDeviceID
    );

LONG
TSPIAPI
TSPI_providerEnumDevices(                                       // TSPI v1.4
    DWORD               dwPermanentProviderID,
    LPDWORD             lpdwNumLines,
    LPDWORD             lpdwNumPhones,
    HPROVIDER           hProvider,
    LINEEVENT           lpfnLineCreateProc,
    PHONEEVENT          lpfnPhoneCreateProc
    );

LONG
TSPIAPI
TSPI_providerFreeDialogInstance(                                // TSPI v2.0
    HDRVDIALOGINSTANCE  hdDlgInst
    );

LONG
TSPIAPI
TSPI_providerGenericDialogData(                                 // TSPI v2.0
    DWORD               dwObjectID,
    DWORD               dwObjectType,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
TSPIAPI
TSPI_providerInit(
    DWORD               dwTSPIVersion,
    DWORD               dwPermanentProviderID,
    DWORD               dwLineDeviceIDBase,
    DWORD               dwPhoneDeviceIDBase,
    DWORD               dwNumLines,
    DWORD               dwNumPhones,
    ASYNC_COMPLETION    lpfnCompletionProc
    ,
    LPDWORD             lpdwTSPIOptions                         // TSPI v2.0
    );

LONG
TSPIAPI
TSPI_providerInstall(
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );

LONG
TSPIAPI
TSPI_providerRemove(
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );

LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD               dwTSPIVersion
    ,
    DWORD               dwPermanentProviderID                   // TSPI v2.0
    );

LONG
TSPIAPI
TSPI_providerUIIdentify(                                        // TSPI v2.0
    LPWSTR              lpszUIDLLName
    );



//
// The following function prototypes pertain
// to a service provider's UI module
//

LONG
TSPIAPI
TUISPI_lineConfigDialog(                                        // TSPI v2.0
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    );

LONG
TSPIAPI
TUISPI_lineConfigDialogEdit(                                    // TSPI v2.0
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    );

LONG
TSPIAPI
TUISPI_phoneConfigDialog(                                       // TSPI v2.0
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    );

LONG
TSPIAPI
TUISPI_providerConfig(                                          // TSPI v2.0
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );

LONG
TSPIAPI
TUISPI_providerGenericDialog(                                   // TSPI v2.0
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HTAPIDIALOGINSTANCE htDlgInst,
    LPVOID              lpParams,
    DWORD               dwSize,
    HANDLE              hEvent
    );

LONG
TSPIAPI
TUISPI_providerGenericDialogData(                               // TSPI v2.0
    HTAPIDIALOGINSTANCE htDlgInst,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
TSPIAPI
TUISPI_providerInstall(                                         // TSPI v2.0
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );

LONG
TSPIAPI
TUISPI_providerRemove(                                          // TSPI v2.0
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\umcfg\notes.txt ===
Utility functions:

1. Enable TAPI debugging.
        > set debug <module> <level>
    examples:
        > set debug tapi32.dll 50
2. Open comm port and test it.
        > open port <name>
        > open line <lineid> /[om][diau]
    examples:
        > open port
        <1
3. Dump TAPI line info
        > dump line * /v
        > dump phone
        > dump port
        > dump modem
4. call <deviceid> <phonenumber> /dai
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\w95migr\placefil.txt ===
migrate.dll  win9xmig\modems
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\tools\src\idlog.txt ===
Sunday, June 28, 1998 12:08:05 PM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>56000
ATI0<cr> = <cr><lf>56000
ATI1<cr> = <cr><lf>185
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>ERROR
ATI2<cr> = <cr><lf>ERROR
ATI3<cr> = <cr><lf>V0.106-K56_ACF_DS2
ATI3<cr> = <cr><lf>-__DS
ATI4<cr> = <cr><lf>Motorola ModemSURFR 56K External
ATI4<cr> = <cr><lf>MotorolaModemSURFRExternal
ATI5<cr> = <cr><lf>022
ATI5<cr> = <cr><lf>
ATI6<cr> = <cr><lf>RC56DPF Rev 47BA
ATI6<cr> = <cr><lf>RCDPFRev
ATI7<cr> = <cr><lf>255
ATI7<cr> = <cr><lf>
ATI8<cr> = <cr><lf>ERROR
ATI8<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEMF14AA730.

 Sunday, June 28, 1998 12:13:13 PM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>56000
ATI0<cr> = <cr><lf>56000
ATI1<cr> = <cr><lf>185
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>ERROR
ATI2<cr> = <cr><lf>ERROR
ATI3<cr> = <cr><lf>V0.106-K56_ACF_DS2
ATI3<cr> = <cr><lf>-__DS
ATI4<cr> = <cr><lf>Motorola ModemSURFR 56K External
ATI4<cr> = <cr><lf>MotorolaModemSURFRExternal
ATI5<cr> = <cr><lf>022
ATI5<cr> = <cr><lf>
ATI6<cr> = <cr><lf>RC56DPF Rev 47BA
ATI6<cr> = <cr><lf>RCDPFRev
ATI7<cr> = <cr><lf>255
ATI7<cr> = <cr><lf>
ATI8<cr> = <cr><lf>ERROR
ATI8<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEMF14AA730.

 Sunday, June 28, 1998 12:15:48 PM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>56000
ATI0<cr> = <cr><lf>56000
ATI1<cr> = <cr><lf>185
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>ERROR
ATI2<cr> = <cr><lf>ERROR
ATI3<cr> = <cr><lf>V0.106-K56_ACF_DS2
ATI3<cr> = <cr><lf>-__DS
ATI4<cr> = <cr><lf>Motorola ModemSURFR 56K External
ATI4<cr> = <cr><lf>MotorolaModemSURFRExternal
ATI5<cr> = <cr><lf>022
ATI5<cr> = <cr><lf>
ATI6<cr> = <cr><lf>RC56DPF Rev 47BA
ATI6<cr> = <cr><lf>RCDPFRev
ATI7<cr> = <cr><lf>255
ATI7<cr> = <cr><lf>
ATI8<cr> = <cr><lf>ERROR
ATI8<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEMF14AA730.

 Sunday, June 28, 1998 12:17:41 PM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>56000
ATI0<cr> = <cr><lf>56000
ATI1<cr> = <cr><lf>185
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>ERROR
ATI2<cr> = <cr><lf>ERROR
ATI3<cr> = <cr><lf>V0.106-K56_ACF_DS2
ATI3<cr> = <cr><lf>-__DS
ATI4<cr> = <cr><lf>Motorola ModemSURFR 56K External
ATI4<cr> = <cr><lf>MotorolaModemSURFRExternal
ATI5<cr> = <cr><lf>022
ATI5<cr> = <cr><lf>
ATI6<cr> = <cr><lf>RC56DPF Rev 47BA
ATI6<cr> = <cr><lf>RCDPFRev
ATI7<cr> = <cr><lf>255
ATI7<cr> = <cr><lf>
ATI8<cr> = <cr><lf>ERROR
ATI8<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEMF14AA730.

 Sunday, June 28, 1998 12:20:20 PM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>56000
ATI0<cr> = <cr><lf>56000
ATI1<cr> = <cr><lf>185
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>ERROR
ATI2<cr> = <cr><lf>ERROR
ATI3<cr> = <cr><lf>V0.106-K56_ACF_DS2
ATI3<cr> = <cr><lf>-__DS
ATI4<cr> = <cr><lf>Motorola ModemSURFR 56K External
ATI4<cr> = <cr><lf>MotorolaModemSURFRExternal
ATI5<cr> = <cr><lf>022
ATI5<cr> = <cr><lf>
ATI6<cr> = <cr><lf>RC56DPF Rev 47BA
ATI6<cr> = <cr><lf>RCDPFRev
ATI7<cr> = <cr><lf>255
ATI7<cr> = <cr><lf>
ATI8<cr> = <cr><lf>ERROR
ATI8<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEMF14AA730.

 Sunday, June 28, 1998 12:20:59 PM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>56000
ATI0<cr> = <cr><lf>56000
ATI1<cr> = <cr><lf>185
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>ERROR
ATI2<cr> = <cr><lf>ERROR
ATI3<cr> = <cr><lf>V0.106-K56_ACF_DS2
ATI3<cr> = <cr><lf>-__DS
ATI4<cr> = <cr><lf>Motorola ModemSURFR 56K External
ATI4<cr> = <cr><lf>MotorolaModemSURFRExternal
ATI5<cr> = <cr><lf>022
ATI5<cr> = <cr><lf>
ATI6<cr> = <cr><lf>RC56DPF Rev 47BA
ATI6<cr> = <cr><lf>RCDPFRev
ATI7<cr> = <cr><lf>255
ATI7<cr> = <cr><lf>
ATI8<cr> = <cr><lf>ERROR
ATI8<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEMF14AA730.

 Sunday, June 28, 1998 12:23:44 PM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>56000
ATI0<cr> = <cr><lf>56000
ATI1<cr> = <cr><lf>185
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>ERROR
ATI2<cr> = <cr><lf>ERROR
ATI3<cr> = <cr><lf>V0.106-K56_ACF_DS2
ATI3<cr> = <cr><lf>-__DS
ATI4<cr> = <cr><lf>Motorola ModemSURFR 56K External
ATI4<cr> = <cr><lf>MotorolaModemSURFRExternal
ATI5<cr> = <cr><lf>022
ATI5<cr> = <cr><lf>
ATI6<cr> = <cr><lf>RC56DPF Rev 47BA
ATI6<cr> = <cr><lf>RCDPFRev
ATI7<cr> = <cr><lf>255
ATI7<cr> = <cr><lf>
ATI8<cr> = <cr><lf>ERROR
ATI8<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI9<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEMF14AA730.

 Sunday, June 28, 1998 12:23:55 PM 
 
 Sunday, June 28, 1998 12:24:41 PM 
 Com1 was in use by another program.

 Sunday, June 28, 1998 12:24:46 PM 
 Com1 was in use by another program.

 Sunday, June 28, 1998 12:25:10 PM 
 Com1 was in use by another program.

 Sunday, June 28, 1998 12:25:13 PM 
 Com4 couldn't be opened.

 Sunday, June 28, 1998 12:25:16 PM 
 Com1 was in use by another program.

 Wednesday, August 12, 1998 11:55:29 AM 
 A modem was found on Com1:
ATI0<cr> = <cr><lf>5601
ATI0<cr> = <cr><lf>5601
ATI1<cr> = <cr><lf>71F2
ATI1<cr> = <cr><lf>
ATI2<cr> = <cr><lf>OK
ATI2<cr> = <cr><lf>OK
ATI3<cr> = <cr><lf>U.S. Robotics 56K FAX EXT V4.9.1
ATI3<cr> = <cr><lf>RoboticsFAXEXT
ATI4<cr> = <cr><lf>U.S. Robotics 56K FAX EXT Settings...
ATI4<cr> = <cr><lf>RoboticsFAXEXTSettings
ATI5<cr> = <cr><lf>U.S. Robotics 56K FAX EXT NVRAM Settings...
ATI5<cr> = <cr><lf>RoboticsFAXEXTNVRAMSettings
ATI6<cr> = <cr><lf>U.S. Robotics 56K FAX EXT Link Diagnostics...
ATI6<cr> = <cr><lf>RoboticsFAXEXTLinkDiagnostics
ATI7<cr> = <cr><lf>Configuration Profile...
ATI7<cr> = <cr><lf>ConfigurationProfile
ATI8<cr> = <cr><lf>OK
ATI8<cr> = <cr><lf>OK
ATI9<cr> = <cr><lf>(1.0USR3040\\Modem\PNPC107\U.S. Robotics 56K FAX EXT)FF
ATI9<cr> = <cr><lf>(USR\\Modem\PNPC\RoboticsFAXEXT)
ATI10<cr> = <cr><lf>ERROR
ATI10<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
AT%V<cr> = <cr><lf>ERROR
Modem ID = UNIMODEM8A4F5943.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\tools\src\frmvoice.log ===
Line 37: Class TabDlg.SSTab of control SSTab1 was not a loaded control class.
Line 87: Class ComctlLib.StatusBar of control StatusBar1 was not a loaded control class.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\tools\src\simple.ini ===
[Quick]
ATDT
AT 
ATH
ATI0
ATI1
ATI2
ATI3

[Voice]
ATI4
ATI5
ATI6
ATI7
ATI8
ATI9
ATI10
AT+FCLASS=?
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\tools\src\simple1.ini ===
[Quick]
Command1 = ATDT
Command2 = AT 
Command3 = ATH
Command4 = ATI0
Command5 = ATI1
Command6 = ATI2
Command7 = ATI3

[Voice]
Command8 = ATI4
Command9 = ATI5
Command10 = ATI6
Command11 = ATI7
Command12 = ATI8
Command13 = ATI9
Command14 = ATI10
Command15 = AT+FCLASS=?
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\tools\src\uquery11.ini ===
' 12/19/97  a-jimho: created, added rockwell and global sections
' 12/21/97  a-jimho: added installation sections to manage chipset and global sections

'------------------ Test Setup Commands ----------------------------------

[InitialSetup] ' send six commands in a row, looking for response from modem of either OK or error
Key1 = AT&FE1  ' factory init and echo on 
Key2 = ATE1    ' echo on
Key3 = AT
Key4 = ATZE1
Key5 = ATE1
Key6 = AT

[Setup.1]
Key7 = AT&F   'factory init, begins test

[Reset.1]
Key8 = AT&FE1  ' factory init and echo on

[Reset.2]
Key9 = ATZE1  ' nvram init and echo on

[UnimodemID.Scan]
Key10 = AT&FE1
Key11 = AT
Key12 = ATI0
Key13 = ATI1
Key14 = ATI2
Key15 = ATI3
Key16 = ATI4
Key17 = ATI5
Key18 = ATI6
Key19 = ATI7
Key20 = ATI8
Key21 = ATI9
Key22 = ATI10
Key23 = AT&V
Key24 = AT+FCLASS=?

' -------------Rockwell Installation -----------------------------------

[Rockwell.Data]  ' all of these sections get run in order 
Key25 = Run=RockwellStaticInit,Rockwell.FlowHard,Rockwell.FlowSoft,Rockwell.FlowOff,Rockwell.ECMOn,Rockwell.ECMForced,Rockwell.ECMOff,Rockwell.CompressionOn,Rockwell.CompressionOff,Rockwell.ErrorControl.Cellular,Rockwell.ErrorControl.CellularForced,Rockwell.InactivityTimeout,Global.Reset,Global.CallSetupFailTimer,Global.BlindOff,Global.BlindOn,Global.Pulse,Global.Tone,Global.CCITT,Global.Bell,Global.Monitor,Global.Hangup,Global.Answer,Global.Prefix,Global.DialPrefix,Global.DialSuffix,Global.SpeakerVolumeLow,Global.SpeakerVolumeMed,Global.SpeakerVolumeHigh,Global.SpeakerModeOff,Global.SpeakerModeDial,Global.SpeakerModeOn,Global.SpeakerModeSetup,Global.InactivityTimeoutTimer,


' [Rockwell.Voice]  	' future voice section
' Run = foo.bar, foo.bar2, etc


'[Rockwell.Fax]  	' future fax section
'Run = foo.bar, foo.bar2, etc

' -------------Cirrus Installation -----------------------------------



[Cirrus.Data]  ' all of these sections get run in order ' note: the cirrus keys dont exist yet...under construction
Key26 = Run=CirrusStaticInit,Cirrus.FlowHard,Cirrus.FlowSoft,Cirrus.FlowOff,Cirrus.ECMOn,Cirrus.ECMForced,Cirrus.ECMOff,Cirrus.CompressionOn,Cirrus.CompressionOff,Cirrus.ErrorControl.Cellular,Cirrus.ErrorControl.CellularForced,Cirrus.InactivityTimeout,Global.Reset,Global.CallSetupFailTimer,Global.BlindOff,Global.BlindOn,Global.Pulse,Global.Tone,Global.CCITT,Global.Bell,Global.Monitor,Global.Hangup,Global.Answer,Global.Prefix,Global.DialPrefix,Global.DialSuffix,Global.SpeakerVolumeLow,Global.SpeakerVolumeMed,Global.SpeakerVolumeHigh,Global.SpeakerModeOff,Global.SpeakerModeDial,Global.SpeakerModeOn,Global.SpeakerModeSetup,Global.CallSetupFailTimer,

'------------------ Rockwell Commands --------------------------------

[Rockwell.StaticInit] ' try each command, use first that works
Key27 = HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 W2 S95=47 S0=0<cr>"
Key28 = HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 S95=47 S0=0<cr>"
Key29 = HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 S95=45 S0=0<cr>"
Key30 = HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 S0=0<cr>"
Key31 = HKR, Init, 2,, "AT Z E0 V1 &D2 &C1 S0=0<cr>"

[Rockwell.FlowHard]
Key32 = HKR, Settings, FlowControl_Hard,, "&K3"
Key33 = HKR, Settings, FlowControl_Hard,, "\Q3"

[Rockwell.FlowSoft]
Key34 = HKR, Settings, FlowControl_Soft,, "&K4"
Key35 = HKR, Settings, FlowControl_Soft,, "\Q1"

[Rockwell.FlowOff]
Key36 = HKR, Settings, FlowControl_Off,, "&K0"
Key37 = HKR, Settings, FlowControl_Off,, "\Q0"

[Rockwell.ECMOn]
Key38 = HKR, Settings, ErrorControl_On,, "\N7"  ' if \N7 try \N6 for forced
Key39 = HKR, Settings, ErrorControl_On,, "\N3"  ' if \N3 try both \N4 and \N2

[Rockwell.ECMForced]
Key40 = HKR, Settings, ErrorControl_Forced,, "\N6"
Key41 = HKR, Settings, ErrorControl_Forced,, "\N4"
Key42 = HKR, Settings, ErrorControl_Forced,, "\N2"

[Rockwell.ECMOff]
Key43 = HKR, Settings, ErrorControl_Off,, "\N0"
Key44 = HKR, Settings, ErrorControl_Off,, "\N"

[Rockwell.CompressionOn]
Key45 = HKR, Settings, Compression_On,, "%%C1"
Key46 = HKR, Settings, Compression_On,, "%%C3"

[Rockwell.CompressionOff]
Key47 = HKR, Settings, Compression_Off,, "%%C0"
Key48 = HKR, Settings, Compression_Off,, "%%C"


[Rockwell.ErrorControl.Cellular]  	' exception processing - prefix with the ecm cmd already found
Key49 = HKR, Settings, ErrorControl_Cellular,, "-K1 )M1 -Q1 *H1 :E1"
Key50 = HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1 :E1"
Key51 = HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1"
Key52 = HKR, Settings, ErrorControl_Cellular,, "-K1 *H1"
Key53 = HKR, Settings, ErrorControl_Cellular,, "-K1"


[Rockwell.ErrorControl.CellularForced]	' exception processing - prefix with the FORCED ecm cmd already found
Key54 = HKR, Settings, ErrorControl_Cellular,, "-K1 )M1 -Q1 *H1 :E1"
Key55 = HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1 :E1"
Key56 = HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1"
Key57 = HKR, Settings, ErrorControl_Cellular,, "-K1 *H1"
Key58 = HKR, Settings, ErrorControl_Cellular,, "-K1"

[Rockwell.InactivityTimeout]' note except macro processing' for this try feeding the command values like ' ATS30=1, ATS30=10, or AT\T1, AT\T30, AT\T60, AT\T90
Key59 = HKR, Settings, InactivityTimeout,, "S30=<#>"   ' first choice
Key60 = HKR, Settings, InactivityTimeout,, "\T<#>"      ' second choice

'------------------ Cirrus Commands ------------------------------------
' not ready



'------------------ USR Commands ------------------------------------
' not ready


'------------------ Global Commands  ------------------------------------

[Global.Reset]
Key61 = HKR,, Reset,, "AT&F<cr>"
Key62 = HKR,, Reset,, "ATZ<cr>"

[Global.CallSetupFailTimer]  ' note except macro processing' for this try feeding S7 registry: ATS7=1, ATS7=10, ATS7=60' all should pass which indicates the command below is the one to use
Key63 = HKR, Settings, CallSetupFailTimer,, "S7="

[Global.BlindOff]   ' these are globals, used regardless of chipset
Key64 = HKR, Settings, Blind_Off,, "X4"

[Global.BlindOn]
Key65 = HKR, Settings, Blind_On,, "X3"

[Global.Pulse]
Key66 = HKR, Settings, Pulse,, "P"   ' exception, you'll have to prefix a D

[Global.Tone]
Key67 = HKR, Settings, Tone,, "T"  ' exception, you'll have to prefix a D

[Global.CCITT]
Key68 = HKR, Settings, Modulation_CCITT,, "B0"

[Global.Bell]
Key69 = HKR, Settings, Modulation_Bell,, "B1"

[Global.Monitor]
Key70 = HKR, Monitor, 1,, "ATS0=0<cr>"   ' exception  - test first cmd but write both
' HKR, Monitor, 2,, "None"

[Global.Hangup]
Key71 = HKR, Hangup, 1,, "ATH<cr>"

[Global.Answer]
Key72 = HKR, Answer, 1,, "ATA<cr>"

[Global.Prefix]
Key73 = HKR, Settings, Prefix,, "AT"   ' exception...this is the AT cmd itself

[Global.DialPrefix]
Key74 = HKR, Settings, DialPrefix,, "D"

[Global.DialSuffix]
Key75 = HKR, Settings, DialSuffix,, ";"
Key76 = HKR, Settings, DialSuffix,, ""

[Global.SpeakerVolumeLow]
Key77 = HKR, Settings, SpeakerVolume_Low,, "L0"

[Global.SpeakerVolumeMed]
Key78 = HKR, Settings, SpeakerVolume_Med,, "L2"

[Global.SpeakerVolumeHigh]
Key79 = HKR, Settings, SpeakerVolume_High,, "L3"

[Global.SpeakerModeOff]
Key80 = HKR, Settings, SpeakerMode_Off,, "M0"

[Global.SpeakerModeDial]
Key81 = HKR, Settings, SpeakerMode_Dial,, "M1"

[Global.SpeakerModeOn]
Key82 = HKR, Settings, SpeakerMode_On,, "M2"

[Global.SpeakerModeSetup]
Key83 = HKR, Settings, SpeakerMode_Setup,, "M3"

[Global.InactivityTimeoutTimer]  ' note macro exception handling
Key84 = HKR, Settings, InactivityTimeout,, "S30=<#>"
Key85 = HKR, Settings, InactivityTimeout,, "\T<#>"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\tools\src\uquery1.ini ===
' 12/19/97  a-jimho: created, added rockwell and global sections
' 12/21/97  a-jimho: added installation sections to manage chipset and global sections

'------------------ Test Setup Commands ----------------------------------

[InitialSetup] ' send six commands in a row, looking for response from modem of either OK or error
AT&FE1  ' factory init and echo on 
ATE1    ' echo on
AT
ATZE1
ATE1
AT

[Setup.1]
AT&F   'factory init, begins test

[Reset.1]
AT&FE1  ' factory init and echo on

[Reset.2]
ATZE1  ' nvram init and echo on

[UnimodemID.Scan]
AT&FE1
AT
ATI0
ATI1
ATI2
ATI3
ATI4
ATI5
ATI6
ATI7
ATI8
ATI9
ATI10
AT&V
AT+FCLASS=?

' -------------Rockwell Installation -----------------------------------

[Rockwell.Data]  ' all of these sections get run in order 
Run=RockwellStaticInit,Rockwell.FlowHard,Rockwell.FlowSoft,Rockwell.FlowOff,Rockwell.ECMOn,Rockwell.ECMForced,Rockwell.ECMOff,Rockwell.CompressionOn,Rockwell.CompressionOff,Rockwell.ErrorControl.Cellular,Rockwell.ErrorControl.CellularForced,Rockwell.InactivityTimeout,Global.Reset,Global.CallSetupFailTimer,Global.BlindOff,Global.BlindOn,Global.Pulse,Global.Tone,Global.CCITT,Global.Bell,Global.Monitor,Global.Hangup,Global.Answer,Global.Prefix,Global.DialPrefix,Global.DialSuffix,Global.SpeakerVolumeLow,Global.SpeakerVolumeMed,Global.SpeakerVolumeHigh,Global.SpeakerModeOff,Global.SpeakerModeDial,Global.SpeakerModeOn,Global.SpeakerModeSetup,Global.InactivityTimeoutTimer,


' [Rockwell.Voice]  	' future voice section
' Run = foo.bar, foo.bar2, etc


'[Rockwell.Fax]  	' future fax section
'Run = foo.bar, foo.bar2, etc

' -------------Cirrus Installation -----------------------------------



[Cirrus.Data]  ' all of these sections get run in order ' note: the cirrus keys dont exist yet...under construction
Run=CirrusStaticInit,Cirrus.FlowHard,Cirrus.FlowSoft,Cirrus.FlowOff,Cirrus.ECMOn,Cirrus.ECMForced,Cirrus.ECMOff,Cirrus.CompressionOn,Cirrus.CompressionOff,Cirrus.ErrorControl.Cellular,Cirrus.ErrorControl.CellularForced,Cirrus.InactivityTimeout,Global.Reset,Global.CallSetupFailTimer,Global.BlindOff,Global.BlindOn,Global.Pulse,Global.Tone,Global.CCITT,Global.Bell,Global.Monitor,Global.Hangup,Global.Answer,Global.Prefix,Global.DialPrefix,Global.DialSuffix,Global.SpeakerVolumeLow,Global.SpeakerVolumeMed,Global.SpeakerVolumeHigh,Global.SpeakerModeOff,Global.SpeakerModeDial,Global.SpeakerModeOn,Global.SpeakerModeSetup,Global.CallSetupFailTimer,

'------------------ Rockwell Commands --------------------------------

[Rockwell.StaticInit] ' try each command, use first that works
HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 W2 S95=47 S0=0<cr>"
HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 S95=47 S0=0<cr>"
HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 S95=45 S0=0<cr>"
HKR, Init, 2,, "AT &F E0 V1 &D2 &C1 S0=0<cr>"
HKR, Init, 2,, "AT Z E0 V1 &D2 &C1 S0=0<cr>"

[Rockwell.FlowHard]
HKR, Settings, FlowControl_Hard,, "&K3"
HKR, Settings, FlowControl_Hard,, "\Q3"

[Rockwell.FlowSoft]
HKR, Settings, FlowControl_Soft,, "&K4"
HKR, Settings, FlowControl_Soft,, "\Q1"

[Rockwell.FlowOff]
HKR, Settings, FlowControl_Off,, "&K0"
HKR, Settings, FlowControl_Off,, "\Q0"

[Rockwell.ECMOn]
HKR, Settings, ErrorControl_On,, "\N7"  ' if \N7 try \N6 for forced
HKR, Settings, ErrorControl_On,, "\N3"  ' if \N3 try both \N4 and \N2

[Rockwell.ECMForced]
HKR, Settings, ErrorControl_Forced,, "\N6"
HKR, Settings, ErrorControl_Forced,, "\N4"
HKR, Settings, ErrorControl_Forced,, "\N2"

[Rockwell.ECMOff]
HKR, Settings, ErrorControl_Off,, "\N0"
HKR, Settings, ErrorControl_Off,, "\N"

[Rockwell.CompressionOn]
HKR, Settings, Compression_On,, "%%C1"
HKR, Settings, Compression_On,, "%%C3"

[Rockwell.CompressionOff]
HKR, Settings, Compression_Off,, "%%C0"
HKR, Settings, Compression_Off,, "%%C"


[Rockwell.ErrorControl.Cellular]  	' exception processing - prefix with the ecm cmd already found
HKR, Settings, ErrorControl_Cellular,, "-K1 )M1 -Q1 *H1 :E1"
HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1 :E1"
HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1"
HKR, Settings, ErrorControl_Cellular,, "-K1 *H1"
HKR, Settings, ErrorControl_Cellular,, "-K1"


[Rockwell.ErrorControl.CellularForced]	' exception processing - prefix with the FORCED ecm cmd already found
HKR, Settings, ErrorControl_Cellular,, "-K1 )M1 -Q1 *H1 :E1"
HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1 :E1"
HKR, Settings, ErrorControl_Cellular,, "-K1 -Q1 *H1"
HKR, Settings, ErrorControl_Cellular,, "-K1 *H1"
HKR, Settings, ErrorControl_Cellular,, "-K1"

[Rockwell.InactivityTimeout]' note except macro processing' for this try feeding the command values like ' ATS30=1, ATS30=10, or AT\T1, AT\T30, AT\T60, AT\T90
HKR, Settings, InactivityTimeout,, "S30=<#>"   ' first choice
HKR, Settings, InactivityTimeout,, "\T<#>"      ' second choice

'------------------ Cirrus Commands ------------------------------------
' not ready



'------------------ USR Commands ------------------------------------
' not ready


'------------------ Global Commands  ------------------------------------

[Global.Reset]
HKR,, Reset,, "AT&F<cr>"
HKR,, Reset,, "ATZ<cr>"

[Global.CallSetupFailTimer]  ' note except macro processing' for this try feeding S7 registry: ATS7=1, ATS7=10, ATS7=60' all should pass which indicates the command below is the one to use
HKR, Settings, CallSetupFailTimer,, "S7="

[Global.BlindOff]   ' these are globals, used regardless of chipset
HKR, Settings, Blind_Off,, "X4"

[Global.BlindOn]
HKR, Settings, Blind_On,, "X3"

[Global.Pulse]
HKR, Settings, Pulse,, "P"   ' exception, you'll have to prefix a D

[Global.Tone]
HKR, Settings, Tone,, "T"  ' exception, you'll have to prefix a D

[Global.CCITT]
HKR, Settings, Modulation_CCITT,, "B0"

[Global.Bell]
HKR, Settings, Modulation_Bell,, "B1"

[Global.Monitor]
HKR, Monitor, 1,, "ATS0=0<cr>"   ' exception  - test first cmd but write both
' HKR, Monitor, 2,, "None"

[Global.Hangup]
HKR, Hangup, 1,, "ATH<cr>"

[Global.Answer]
HKR, Answer, 1,, "ATA<cr>"

[Global.Prefix]
HKR, Settings, Prefix,, "AT"   ' exception...this is the AT cmd itself

[Global.DialPrefix]
HKR, Settings, DialPrefix,, "D"

[Global.DialSuffix]
HKR, Settings, DialSuffix,, ";"
HKR, Settings, DialSuffix,, ""

[Global.SpeakerVolumeLow]
HKR, Settings, SpeakerVolume_Low,, "L0"

[Global.SpeakerVolumeMed]
HKR, Settings, SpeakerVolume_Med,, "L2"

[Global.SpeakerVolumeHigh]
HKR, Settings, SpeakerVolume_High,, "L3"

[Global.SpeakerModeOff]
HKR, Settings, SpeakerMode_Off,, "M0"

[Global.SpeakerModeDial]
HKR, Settings, SpeakerMode_Dial,, "M1"

[Global.SpeakerModeOn]
HKR, Settings, SpeakerMode_On,, "M2"

[Global.SpeakerModeSetup]
HKR, Settings, SpeakerMode_Setup,, "M3"

[Global.InactivityTimeoutTimer]  ' note macro exception handling
HKR, Settings, InactivityTimeout,, "S30=<#>"
HKR, Settings, InactivityTimeout,, "\T<#>"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\tools\src\readme.rtf ===
{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;} {\f16\froman\fcharset238\fprq2 Times New Roman CE;}{\f17\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f19\froman\fcharset161\fprq2 Times New Roman Greek;}{\f20\froman\fcharset162\fprq2 Times New Roman Tur;} {\f21\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f28\fmodern\fcharset238\fprq1 Courier New CE;}{\f29\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f31\fmodern\fcharset161\fprq1 Courier New Greek;}{\f32\fmodern\fcharset162\fprq1 Courier New Tur;} {\f33\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255; \red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}{\* \cs10 \additive Default Paragraph Font;}{\s15\widctlpar\adjustright \f2\fs20\cgrid \sbasedon0 \snext15 Plain Text;}}{\info{\title Overview: Profile Calculator}{\author Ken Reed}{\operator Ken Reed}{\creatim\yr1998\mo9\dy7\hr19\min47} {\revtim\yr1998\mo9\dy7\hr19\min53}{\version3}{\edmins2}{\nofpages1}{\nofwords0}{\nofchars0}{\*\company Microsoft}{\nofcharsws0}{\vern89}}\margl1319\margr1319 \widowctrl\ftnbj\aenddoc\hyphcaps0\formshade\viewkind4\viewscale86\pgbrdrhead\pgbrdrfoot \fet0 \sectd \linex0\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4 \pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (} {\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \widctlpar\adjustright \fs20\cgrid {Overview: Profile Calculator \par  \par Use Profile calculator to create, edit or translate properties lines within Windows 95 and Windows NT modem INF files. Modem INF properties lines contain device properties settings that are transferred from an INF file to the Windows  Registry at the time a device is installed. Profile calculator is bi-directional: it can translate text values into an INF properties line or translate existing properties lines into text. \par  \par The following are examples of typical properties lines found in a modem INF: \par  \par HKR,, VoiceProfile,    1, 27,03,00,00 \par HKR,, Properties, 1, 80,01,00,00, ff,00,00,00, 00,00,00,00, 07,00,00,00, 07,00,00,00, 77,03,00,00, 00,c2,01,00, 40,38,00,00 \par  \par Notes \par  \par \'b7\tab A properties line is a single line in an INF file without text wrapping. \par  \par }\pard\plain \s15\widctlpar\adjustright \f2\fs20\cgrid {\'b7\tab When Profile Calculator first starts, a list of values the large lower window. The calculated INF properties line is visible in the long upper window. Checking or unchecking  specific values in the lower window toggles the value on or off while reflecting the changes to the properties line in the long upper window. \par }}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\tools\src\uqueryr.ini ===
[Rock.336K.Responses]
HKR, Responses, "0<cr>", 1, 00, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "1<cr>", 1, 02, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "2<cr>", 1, 08, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "3<cr>", 1, 04, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "4<cr>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "5<cr>", 1, 02, 00, B0,04,00,00, 00,00,00,00 
HKR, Responses, "6<cr>", 1, 05, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "7<cr>", 1, 06, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "8<cr>", 1, 07, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "9<cr>", 1, 02, 00, 58,02,00,00, 00,00,00,00 
HKR, Responses, "10<cr>", 1, 02, 00, 60,09,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>OK<cr><lf>", 1, 00, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>ERROR<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>RING<cr><lf>", 1, 08, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>NO CARRIER<cr><lf>", 1, 04, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>NO DIALTONE<cr><lf>", 1, 05, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>BUSY<cr><lf>", 1, 06, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>NO ANSWER<cr><lf>", 1, 07, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT<cr><lf>", 1, 02, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>FAX<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>DATA<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>VOICE<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>+FCON<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>+F4<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 1200/ARQ<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400/ARQ<cr><lf>", 1, 02, 02, 60,09,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 4800/ARQ<cr><lf>", 1, 02, 02, C0,12,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 9600/ARQ<cr><lf>", 1, 02, 02, 80,25,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 7200/ARQ<cr><lf>", 1, 02, 02, 20,1C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 12000/ARQ<cr><lf>", 1, 02, 02, E0,2E,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 14400/ARQ<cr><lf>", 1, 02, 02, 40,38,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 19200/ARQ<cr><lf>", 1, 02, 02, 00,4B,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 32000/ARQ<cr><lf>", 1, 02, 02, 00,7D,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 34000/ARQ<cr><lf>", 1, 02, 02, D0,84,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 36000/ARQ<cr><lf> ", 1, 02, 02, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000/ARQ<cr><lf>", 1, 02, 02, 70,94,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 40000/ARQ<cr><lf>", 1, 02, 02, 40,9C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 42000/ARQ<cr><lf>", 1, 02, 02, 10,A4,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 44000/ARQ<cr><lf>", 1, 02, 02, E0,AB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 46000/ARQ<cr><lf>", 1, 02, 02, B0,B3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 48000/ARQ<cr><lf>", 1, 02, 02, 80,BB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 50000/ARQ<cr><lf>", 1, 02, 02, 50,C3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 52000/ARQ<cr><lf>", 1, 02, 02, 20,CB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 54000/ARQ<cr><lf>", 1, 02, 02, F0,D2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 56000/ARQ<cr><lf>", 1, 02, 02, C0,DA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 58000/ARQ<cr><lf>", 1, 02, 02, 90,E2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 60000/ARQ<cr><lf>", 1, 02, 02, 60,EA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 31200/ARQ<cr><lf>", 1, 02, 02, E0,79,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 33600/ARQ<cr><lf>", 1, 02, 02, 40,83,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 38400/ARQ<cr><lf>", 1, 02, 02, 00,96,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 57600/ARQ<cr><lf>", 1, 02, 02, 00,E1,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 115200/ARQ<cr><lf>", 1, 02, 02, 00,C2,01,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 75TX/1200RX<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 1200TX/75RX<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 16800/ARQ<cr><lf>", 1, 02, 02, A0,41,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 21600/ARQ<cr><lf>", 1, 02, 02, 60,54,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 24000/ARQ<cr><lf>", 1, 02, 02, C0,5D,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 26400/ARQ<cr><lf>", 1, 02, 02, 20,67,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 28800/ARQ<cr><lf>", 1, 02, 02, 80,70,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>DELAYED<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>BLACKLISTED<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 300<cr><lf>", 1, 01, 00, 2C,01,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 1200/75<cr><lf>", 1, 01, 00, B0,04,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 75/1200<cr><lf>", 1, 01, 00, B0,04,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 1200<cr><lf>", 1, 01, 00, B0,04,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 2400<cr><lf>", 1, 01, 00, 60,09,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 4800<cr><lf>", 1, 01, 00, C0,12,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 7200<cr><lf>", 1, 01, 00, 20,1C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 9600<cr><lf>", 1, 01, 00, 80,25,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 12000<cr><lf>", 1, 01, 00, E0,2E,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 14400<cr><lf>", 1, 01, 00, 40,38,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 16800<cr><lf>", 1, 01, 00, A0,41,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 19200<cr><lf>", 1, 01, 00, 00,4B,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 32000<cr><lf>", 1, 01, 00, 00,7D,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 34000<cr><lf>", 1, 01, 00, D0,84,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 36000<cr><lf> ", 1, 01, 00, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CARRIER 38000<cr><lf>", 1, 01, 00, 70,94,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 40000<cr><lf>", 1, 01, 00, 40,9C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 42000<cr><lf>", 1, 01, 00, 10,A4,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 44000<cr><lf>", 1, 01, 00, E0,AB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 46000<cr><lf>", 1, 01, 00, B0,B3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 48000<cr><lf>", 1, 01, 00, 80,BB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 50000<cr><lf>", 1, 01, 00, 50,C3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 52000<cr><lf>", 1, 01, 00, 20,CB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 54000<cr><lf>", 1, 01, 00, F0,D2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 56000<cr><lf>", 1, 01, 00, C0,DA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 58000<cr><lf>", 1, 01, 00, 90,E2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 60000<cr><lf>", 1, 01, 00, 60,EA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 21600<cr><lf>", 1, 01, 00, 60,54,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 24000<cr><lf>", 1, 01, 00, C0,5D,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 26400<cr><lf>", 1, 01, 00, 20,67,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 28800<cr><lf>", 1, 01, 00, 80,70,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 31200<cr><lf>", 1, 01, 00, E0,79,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 33600<cr><lf>", 1, 01, 00, 40,83,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 14400/VFC<cr><lf>", 1, 01, 00, 40,38,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 16800/VFC<cr><lf>", 1, 01, 00, a0,41,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 19200/VFC<cr><lf>", 1, 01, 00, 00,4b,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 21600/VFC<cr><lf>", 1, 01, 00, 60,54,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 24000/VFC<cr><lf>", 1, 01, 00, c0,5d,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 26400/VFC<cr><lf>", 1, 01, 00, 20,67,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 28800/VFC<cr><lf>", 1, 01, 00, 80,70,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 33600/VFC<cr><lf>", 1, 01, 00, 40,83,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 32000/VFC<cr><lf>", 1, 01, 00, 00,7D,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 34000/VFC<cr><lf>", 1, 01, 00, D0,84,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 36000/VFC<cr><lf> ", 1, 01, 00, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CARRIER 38000/VFC<cr><lf>", 1, 01, 00, 70,94,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 40000/VFC<cr><lf>", 1, 01, 00, 40,9C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 42000/VFC<cr><lf>", 1, 01, 00, 10,A4,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 44000/VFC<cr><lf>", 1, 01, 00, E0,AB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 46000/VFC<cr><lf>", 1, 01, 00, B0,B3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 48000/VFC<cr><lf>", 1, 01, 00, 80,BB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 50000/VFC<cr><lf>", 1, 01, 00, 50,C3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 52000/VFC<cr><lf>", 1, 01, 00, 20,CB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 54000/VFC<cr><lf>", 1, 01, 00, F0,D2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 56000/VFC<cr><lf>", 1, 01, 00, C0,DA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 58000/VFC<cr><lf>", 1, 01, 00, 90,E2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CARRIER 60000/VFC<cr><lf>", 1, 01, 00, 60,EA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 1200<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 0600<cr><lf>", 1, 02, 00, 58,02,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 2400<cr><lf>", 1, 02, 00, 60,09,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 4800<cr><lf>", 1, 02, 00, C0,12,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 9600<cr><lf>", 1, 02, 00, 80,25,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 7200<cr><lf>", 1, 02, 00, 20,1C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 12000<cr><lf>", 1, 02, 00, E0,2E,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400<cr><lf>", 1, 02, 00, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200<cr><lf>", 1, 02, 00, 00,4B,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400<cr><lf>", 1, 02, 00, 00,96,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 57600<cr><lf>", 1, 02, 00, 00,E1,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 115200<cr><lf>", 1, 02, 00, 00,C2,01,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 16800<cr><lf>", 1, 02, 00, A0,41,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 21600<cr><lf>", 1, 02, 00, 60,54,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 24000<cr><lf>", 1, 02, 00, C0,5D,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 26400<cr><lf>", 1, 02, 00, 20,67,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 28800<cr><lf>", 1, 02, 00, 80,70,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 31200<cr><lf>", 1, 02, 00, E0,79,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 33600<cr><lf>", 1, 02, 00, 40,83,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 32000<cr><lf>", 1, 02, 00, 00,7D,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 34000<cr><lf>", 1, 02, 00, D0,84,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 36000<cr><lf> ", 1, 02, 00, A0,8C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 38000<cr><lf>", 1, 02, 00, 70,94,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 40000<cr><lf>", 1, 02, 00, 40,9C,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 42000<cr><lf>", 1, 02, 00, 10,A4,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 44000<cr><lf>", 1, 02, 00, E0,AB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 46000<cr><lf>", 1, 02, 00, B0,B3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 48000<cr><lf>", 1, 02, 00, 80,BB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 50000<cr><lf>", 1, 02, 00, 50,C3,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 52000<cr><lf>", 1, 02, 00, 20,CB,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 54000<cr><lf>", 1, 02, 00, F0,D2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 56000<cr><lf>", 1, 02, 00, C0,DA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 58000<cr><lf>", 1, 02, 00, 90,E2,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 60000<cr><lf>", 1, 02, 00, 60,EA,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>COMPRESSION: CLASS 5<cr><lf>", 1, 01, 01, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>COMPRESSION: V.42bis<cr><lf>", 1, 01, 01, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>COMPRESSION: NONE<cr><lf>", 1, 01, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>PROTOCOL: NONE<cr><lf>", 1, 01, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>PROTOCOL: LAP-M<cr><lf>", 1, 01, 02, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>PROTOCOL: ALT<cr><lf>", 1, 01, 02, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>PROTOCOL: ALT - CELLULAR<cr><lf>", 1, 01, 0a, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>+FCERROR<cr><lf>", 1, 03, 00, 00,00,00,00, 00,00,00,00 
HKR, Responses, "<cr><lf>CONNECT 230400<cr><lf>", 1, 02, 00, 00,84,03,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 300/ARQ<cr><lf>", 1, 02, 02, 2c,01,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 0600/ARQ<cr><lf>", 1, 02, 02, 58,02,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 230400/ARQ<cr><lf>", 1, 02, 02, 00,84,03,00, 00,00,00,00
HKR, Responses, "<cr><lf>CARRIER 0600<cr><lf>", 1, 01, 00, 58,02,00,00, 00,00,00,00


[Rock.56K.Responses]
HKR, Responses, "<cr><lf>NO DIAL TONE<cr><lf>", 1, 05, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>RINGING<cr><lf>", 1, 08, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 300<cr><lf>", 1, 02, 00, 2c,01,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 300 NoEC<cr><lf>", 1, 02, 00, 2c,01,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 300 MNP4<cr><lf>", 1, 02, 02, 2c,01,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 300 MNP5<cr><lf>", 1, 02, 03, 2c,01,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 300 V42<cr><lf>", 1, 02, 02, 2c,01,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 300 V42bis<cr><lf>", 1, 02, 03, 2c,01,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 600<cr><lf>", 1, 02, 00, 58,02,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 600 NoEC<cr><lf>", 1, 02, 00, 58,02,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 600 MNP4<cr><lf>", 1, 02, 02, 58,02,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 600 MNP5<cr><lf>", 1, 02, 03, 58,02,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 600 V42<cr><lf>", 1, 02, 02, 58,02,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 600 V42bis<cr><lf>", 1, 02, 03, 58,02,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200 NoEC<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200 MNP4<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200 MNP5<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200 V42<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200 V42bis<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200/75<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200/75 NoEC<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200/75 MNP4<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200/75 MNP5<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200/75 V42<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200/75 V42bis<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200TX/75RX NoEC<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200TX/75RX MNP4<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200TX/75RX MNP5<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200TX/75RX V42<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 1200TX/75RX V42bis<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75/1200<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75/1200 NoEC<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75/1200 MNP4<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75/1200 MNP5<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75/1200 V42<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75/1200 V42bis<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75TX/1200RX NoEC<cr><lf>", 1, 02, 00, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75TX/1200RX MNP4<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75TX/1200RX MNP5<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75TX/1200RX V42<cr><lf>", 1, 02, 02, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 75TX/1200RX V42bis<cr><lf>", 1, 02, 03, B0,04,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400 NoEC<cr><lf>", 1, 02, 00, 60,09,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400 MNP4<cr><lf>", 1, 02, 02, 60,09,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400 MNP5<cr><lf>", 1, 02, 03, 60,09,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400 V42<cr><lf>", 1, 02, 02, 60,09,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400 V42bis<cr><lf>", 1, 02, 03, 60,09,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 60,09,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 2400 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 60,09,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 NoEC<cr><lf>", 1, 02, 00, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 MNP4<cr><lf>", 1, 02, 02, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 MNP5<cr><lf>", 1, 02, 03, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 V42<cr><lf>", 1, 02, 02, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 V42bis<cr><lf>", 1, 02, 03, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 V42 DSVD<cr><lf>", 1, 02, 02, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 4800 V42bis DSVD<cr><lf>", 1, 02, 03, C0,12,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 NoEC<cr><lf>", 1, 02, 00, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 MNP4<cr><lf>", 1, 02, 02, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 MNP5<cr><lf>", 1, 02, 03, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 V42<cr><lf>", 1, 02, 02, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 V42bis<cr><lf>", 1, 02, 03, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 V42 DSVD<cr><lf>", 1, 02, 02, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 7200 V42bis DSVD<cr><lf>", 1, 02, 03, 20,1c,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 NoEC<cr><lf>", 1, 02, 00, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 MNP4<cr><lf>", 1, 02, 02, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 MNP5<cr><lf>", 1, 02, 03, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 V42<cr><lf>", 1, 02, 02, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 V42bis<cr><lf>", 1, 02, 03, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 V42 DSVD<cr><lf>", 1, 02, 02, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 9600 V42bis DSVD<cr><lf>", 1, 02, 03, 80,25,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 NoEC<cr><lf>", 1, 02, 00, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 MNP4<cr><lf>", 1, 02, 02, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 MNP5<cr><lf>", 1, 02, 03, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 V42<cr><lf>", 1, 02, 02, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 V42bis<cr><lf>", 1, 02, 03, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 V42 DSVD<cr><lf>", 1, 02, 02, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 12000 V42bis DSVD<cr><lf>", 1, 02, 03, e0,2e,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 NoEC<cr><lf>", 1, 02, 00, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 MNP4<cr><lf>", 1, 02, 02, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 MNP5<cr><lf>", 1, 02, 03, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 V42<cr><lf>", 1, 02, 02, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 V42bis<cr><lf>", 1, 02, 03, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 V42 DSVD<cr><lf>", 1, 02, 02, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 14400 V42bis DSVD<cr><lf>", 1, 02, 03, 40,38,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 NoEC<cr><lf>", 1, 02, 00, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 MNP4<cr><lf>", 1, 02, 02, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 MNP5<cr><lf>", 1, 02, 03, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 V42<cr><lf>", 1, 02, 02, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 V42bis<cr><lf>", 1, 02, 03, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 V42 DSVD<cr><lf>", 1, 02, 02, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 16800 V42bis DSVD<cr><lf>", 1, 02, 03, a0,41,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 NoEC<cr><lf>", 1, 02, 00, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 MNP4<cr><lf>", 1, 02, 02, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 MNP5<cr><lf>", 1, 02, 03, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 V42<cr><lf>", 1, 02, 02, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 V42bis<cr><lf>", 1, 02, 03, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 V42 DSVD<cr><lf>", 1, 02, 02, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 19200 V42bis DSVD<cr><lf>", 1, 02, 03, 00,4b,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 NoEC<cr><lf>", 1, 02, 00, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 MNP4<cr><lf>", 1, 02, 02, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 MNP5<cr><lf>", 1, 02, 03, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 V42<cr><lf>", 1, 02, 02, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 V42bis<cr><lf>", 1, 02, 03, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 V42 DSVD<cr><lf>", 1, 02, 02, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 21600 V42bis DSVD<cr><lf>", 1, 02, 03, 60,54,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 NoEC<cr><lf>", 1, 02, 00, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 MNP4<cr><lf>", 1, 02, 02, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 MNP5<cr><lf>", 1, 02, 03, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 V42<cr><lf>", 1, 02, 02, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 V42bis<cr><lf>", 1, 02, 03, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 V42 DSVD<cr><lf>", 1, 02, 02, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 24000 V42bis DSVD<cr><lf>", 1, 02, 03, c0,5d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 NoEC<cr><lf>", 1, 02, 00, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 MNP4<cr><lf>", 1, 02, 02, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 MNP5<cr><lf>", 1, 02, 03, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 V42<cr><lf>", 1, 02, 02, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 V42bis<cr><lf>", 1, 02, 03, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 V42 DSVD<cr><lf>", 1, 02, 02, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 26400 V42bis DSVD<cr><lf>", 1, 02, 03, 20,67,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 NoEC<cr><lf>", 1, 02, 00, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 MNP4<cr><lf>", 1, 02, 02, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 MNP5<cr><lf>", 1, 02, 03, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 V42<cr><lf>", 1, 02, 02, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 V42bis<cr><lf>", 1, 02, 03, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 V42 DSVD<cr><lf>", 1, 02, 02, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 28800 V42bis DSVD<cr><lf>", 1, 02, 03, 80,70,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 NoEC<cr><lf>", 1, 02, 00, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 MNP4<cr><lf>", 1, 02, 02, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 MNP5<cr><lf>", 1, 02, 03, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 V42<cr><lf>", 1, 02, 02, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 V42bis<cr><lf>", 1, 02, 03, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 V42 DSVD<cr><lf>", 1, 02, 02, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 31200 V42bis DSVD<cr><lf>", 1, 02, 03, E0,79,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 NoEC<cr><lf>", 1, 02, 00, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 MNP4<cr><lf>", 1, 02, 02, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 MNP5<cr><lf>", 1, 02, 03, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 V42<cr><lf>", 1, 02, 02, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 V42bis<cr><lf>", 1, 02, 03, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 V42 Cellular Protocol<cr><lf>", 1, 02, 0a, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 V42bis Cellular Protocol<cr><lf>", 1, 02, 0b, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 V42 DSVD<cr><lf>", 1, 02, 02, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 33600 V42bis DSVD<cr><lf>", 1, 02, 03, 40,83,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400 NoEC<cr><lf>", 1, 02, 00, 00,96,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400 MNP4<cr><lf>", 1, 02, 02, 00,96,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400 MNP5<cr><lf>", 1, 02, 03, 00,96,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400 V42<cr><lf>", 1, 02, 02, 00,96,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400 V42bis<cr><lf>", 1, 02, 03, 00,96,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400 V42 DSVD<cr><lf>", 1, 02, 02, 00,96,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38400 V42bis DSVD<cr><lf>", 1, 02, 03, 00,96,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 57600 NoEC<cr><lf>", 1, 02, 00, 00,E1,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 57600 MNP4<cr><lf>", 1, 02, 02, 00,E1,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 57600 MNP5<cr><lf>", 1, 02, 03, 00,E1,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 57600 V42<cr><lf>", 1, 02, 02, 00,E1,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 57600 V42bis<cr><lf>", 1, 02, 03, 00,E1,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 57600 V42 DSVD<cr><lf>", 1, 02, 02, 00,E1,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 57600 V42bis DSVD<cr><lf>", 1, 02, 03, 00,E1,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 115200 NoEC<cr><lf>", 1, 02, 00, 00,C2,01,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 115200 MNP4<cr><lf>", 1, 02, 02, 00,C2,01,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 115200 MNP5<cr><lf>", 1, 02, 03, 00,C2,01,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 115200 V42<cr><lf>", 1, 02, 02, 00,C2,01,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 115200 V42bis<cr><lf>", 1, 02, 03, 00,C2,01,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 115200 V42 DSVD<cr><lf>", 1, 02, 02, 00,C2,01,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 115200 V42bis DSVD<cr><lf>", 1, 02, 03, 00,C2,01,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 32000 NoEC<cr><lf>", 1, 02, 00, 00,7d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 32000 MNP4<cr><lf>", 1, 02, 02, 00,7d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 32000 MNP5<cr><lf>", 1, 02, 03, 00,7d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 32000 V42<cr><lf>", 1, 02, 02, 00,7d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 32000 V42bis<cr><lf>", 1, 02, 03, 00,7d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 32000 V42 DSVD<cr><lf>", 1, 02, 02, 00,7d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 32000 V42bis DSVD<cr><lf>", 1, 02, 03, 00,7d,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 34000 NoEC<cr><lf>", 1, 02, 00, D0,84,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 34000 MNP4<cr><lf>", 1, 02, 02, D0,84,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 34000 MNP5<cr><lf>", 1, 02, 03, D0,84,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 34000 V42<cr><lf>", 1, 02, 02, D0,84,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 34000 V42bis<cr><lf>", 1, 02, 03, D0,84,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 34000 V42 DSVD<cr><lf>", 1, 02, 02, D0,84,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 34000 V42bis DSVD<cr><lf>", 1, 02, 03, D0,84,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 36000 NoEC<cr><lf>", 1, 02, 00, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 36000 MNP4<cr><lf>", 1, 02, 02, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 36000 MNP5<cr><lf>", 1, 02, 03, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 36000 V42<cr><lf>", 1, 02, 02, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 36000 V42bis<cr><lf>", 1, 02, 03, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 36000 V42 DSVD<cr><lf>", 1, 02, 02, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 36000 V42bis DSVD<cr><lf>", 1, 02, 03, A0,8C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000 NoEC<cr><lf>", 1, 02, 00, 70,94,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000 MNP4<cr><lf>", 1, 02, 02, 70,94,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000 MNP5<cr><lf>", 1, 02, 03, 70,94,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000 V42<cr><lf>", 1, 02, 02, 70,94,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000 V42bis<cr><lf>", 1, 02, 03, 70,94,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000 V42 DSVD<cr><lf>", 1, 02, 02, 70,94,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 38000 V42bis DSVD<cr><lf>", 1, 02, 03, 70,94,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 40000 NoEC<cr><lf>", 1, 02, 00, 40,9C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 40000 MNP4<cr><lf>", 1, 02, 02, 40,9C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 40000 MNP5<cr><lf>", 1, 02, 03, 40,9C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 40000 V42<cr><lf>", 1, 02, 02, 40,9C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 40000 V42bis<cr><lf>", 1, 02, 03, 40,9C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 40000 V42 DSVD<cr><lf>", 1, 02, 02, 40,9C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 40000 V42bis DSVD<cr><lf>", 1, 02, 03, 40,9C,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 42000 NoEC<cr><lf>", 1, 02, 00, 10,A4,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 42000 MNP4<cr><lf>", 1, 02, 02, 10,A4,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 42000 MNP5<cr><lf>", 1, 02, 03, 10,A4,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 42000 V42<cr><lf>", 1, 02, 02, 10,A4,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 42000 V42bis<cr><lf>", 1, 02, 03, 10,A4,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 42000 V42 DSVD<cr><lf>", 1, 02, 02, 10,A4,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 42000 V42bis DSVD<cr><lf>", 1, 02, 03, 10,A4,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 44000 NoEC<cr><lf>", 1, 02, 00, E0,AB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 44000 MNP4<cr><lf>", 1, 02, 02, E0,AB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 44000 MNP5<cr><lf>", 1, 02, 03, E0,AB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 44000 V42<cr><lf>", 1, 02, 02, E0,AB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 44000 V42bis<cr><lf>", 1, 02, 03, E0,AB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 44000 V42 DSVD<cr><lf>", 1, 02, 02, E0,AB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 44000 V42bis DSVD<cr><lf>", 1, 02, 03, E0,AB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 46000 NoEC<cr><lf>", 1, 02, 00, B0,B3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 46000 MNP4<cr><lf>", 1, 02, 02, B0,B3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 46000 MNP5<cr><lf>", 1, 02, 03, B0,B3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 46000 V42<cr><lf>", 1, 02, 02, B0,B3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 46000 V42bis<cr><lf>", 1, 02, 03, B0,B3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 46000 V42 DSVD<cr><lf>", 1, 02, 02, B0,B3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 46000 V42bis DSVD<cr><lf>", 1, 02, 03, B0,B3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 48000 NoEC<cr><lf>", 1, 02, 00, 80,BB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 48000 MNP4<cr><lf>", 1, 02, 02, 80,BB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 48000 MNP5<cr><lf>", 1, 02, 03, 80,BB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 48000 V42<cr><lf>", 1, 02, 02, 80,BB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 48000 V42bis<cr><lf>", 1, 02, 03, 80,BB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 48000 V42 DSVD<cr><lf>", 1, 02, 02, 80,BB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 48000 V42bis DSVD<cr><lf>", 1, 02, 03, 80,BB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 50000 NoEC<cr><lf>", 1, 02, 00, 50,C3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 50000 MNP4<cr><lf>", 1, 02, 02, 50,C3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 50000 MNP5<cr><lf>", 1, 02, 03, 50,C3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 50000 V42<cr><lf>", 1, 02, 02, 50,C3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 50000 V42bis<cr><lf>", 1, 02, 03, 50,C3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 50000 V42 DSVD<cr><lf>", 1, 02, 02, 50,C3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 50000 V42bis DSVD<cr><lf>", 1, 02, 03, 50,C3,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 52000 NoEC<cr><lf>", 1, 02, 00, 20,CB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 52000 MNP4<cr><lf>", 1, 02, 02, 20,CB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 52000 MNP5<cr><lf>", 1, 02, 03, 20,CB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 52000 V42<cr><lf>", 1, 02, 02, 20,CB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 52000 V42bis<cr><lf>", 1, 02, 03, 20,CB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 52000 V42 DSVD<cr><lf>", 1, 02, 02, 20,CB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 52000 V42bis DSVD<cr><lf>", 1, 02, 03, 20,CB,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 54000 NoEC<cr><lf>", 1, 02, 00, F0,D2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 54000 MNP4<cr><lf>", 1, 02, 02, F0,D2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 54000 MNP5<cr><lf>", 1, 02, 03, F0,D2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 54000 V42<cr><lf>", 1, 02, 02, F0,D2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 54000 V42bis<cr><lf>", 1, 02, 03, F0,D2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 54000 V42 DSVD<cr><lf>", 1, 02, 02, F0,D2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 54000 V42bis DSVD<cr><lf>", 1, 02, 03, F0,D2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 56000 NoEC<cr><lf>", 1, 02, 00, C0,DA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 56000 MNP4<cr><lf>", 1, 02, 02, C0,DA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 56000 MNP5<cr><lf>", 1, 02, 03, C0,DA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 56000 V42<cr><lf>", 1, 02, 02, C0,DA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 56000 V42bis<cr><lf>", 1, 02, 03, C0,DA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 56000 V42 DSVD<cr><lf>", 1, 02, 02, C0,DA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 56000 V42bis DSVD<cr><lf>", 1, 02, 03, C0,DA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 58000 NoEC<cr><lf>", 1, 02, 00, 00,00,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 58000 MNP4<cr><lf>", 1, 02, 02, 90,E2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 58000 MNP5<cr><lf>", 1, 02, 03, 90,E2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 58000 V42<cr><lf>", 1, 02, 02, 90,E2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 58000 V42bis<cr><lf>", 1, 02, 03, 90,E2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 58000 V42 DSVD<cr><lf>", 1, 02, 02, 90,E2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 58000 V42bis DSVD<cr><lf>", 1, 02, 03, 90,E2,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 60000 NoEC<cr><lf>", 1, 02, 00, 60,EA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 60000 MNP4<cr><lf>", 1, 02, 02, 60,EA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 60000 MNP5<cr><lf>", 1, 02, 03, 60,EA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 60000 V42<cr><lf>", 1, 02, 02, 60,EA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 60000 V42bis<cr><lf>", 1, 02, 03, 60,EA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 60000 V42 DSVD<cr><lf>", 1, 02, 02, 60,EA,00,00, 00,00,00,00
HKR, Responses, "<cr><lf>CONNECT 60000 V42bis DSVD<cr><lf>", 1, 02, 03, 60,EA,00,00, 00,00,00,00
' responses
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\perfctrs\winsctrs.ini ===
[info]
drivername=Wins
symbolfile=winsctrs.h

[languages]
009=English

[text]
WINSCTRS_COUNTER_OBJECT_009_NAME=WINS Server
WINSCTRS_COUNTER_OBJECT_009_HELP=The WINS Server object type includes counters specific to the WINS Server service.

WINSCTRS_UNIQUE_REGISTRATIONS_009_NAME=Unique Registrations/sec
WINSCTRS_UNIQUE_REGISTRATIONS_009_HELP=Unique Registrations/sec is the rate at which unique registration are received by the WINS server.

WINSCTRS_GROUP_REGISTRATIONS_009_NAME=Group Registrations/sec
WINSCTRS_GROUP_REGISTRATIONS_009_HELP=Group Registrations/sec is the rate at which group registration are received by the WINS server.

WINSCTRS_TOTAL_REGISTRATIONS_009_NAME=Total Number of Registrations/sec
WINSCTRS_TOTAL_REGISTRATIONS_009_HELP=Total Number of Registrations/sec is the sum of the Unique and Group registrations per sec.  This is the total rate at which registration are received by the WINS server.

WINSCTRS_UNIQUE_REFRESHES_009_NAME=Unique Refreshes/sec
WINSCTRS_UNIQUE_REFRESHES_009_HELP=Unique Refreshes/sec is the rate at which unique registration are received by the WINS server.

WINSCTRS_GROUP_REFRESHES_009_NAME=Group Refreshes/sec
WINSCTRS_GROUP_REFRESHES_009_HELP=Group Refreshes/sec is the rate at which group registration are received by the WINS server.

WINSCTRS_TOTAL_REFRESHES_009_NAME=Total Number of Refreshes/sec
WINSCTRS_TOTAL_REFRESHES_009_HELP=Total Number of Refreshes/sec is the sum of the Unique and Group registrations per sec.  This is the total rate at which refreshes are received by the WINS server.

WINSCTRS_RELEASES_009_NAME=Releases/sec
WINSCTRS_RELEASES_009_HELP=Total Number of Releases/sec is the rate at which releases are received by the WINS server.

WINSCTRS_QUERIES_009_NAME=Queries/sec
WINSCTRS_QUERIES_009_HELP=Total Number of Queries/sec is the rate at which queries are received by the WINS server.

WINSCTRS_UNIQUE_CONFLICTS_009_NAME=Unique Conflicts/sec
WINSCTRS_UNIQUE_CONFLICTS_009_HELP=Unique Conflicts/sec is the rate at which unique registrations/refreshes received by the WINS server resulted in conflicts with records in the database.

WINSCTRS_GROUP_CONFLICTS_009_NAME=Group Conflicts/sec
WINSCTRS_GROUP_CONFLICTS_009_HELP=Group Conflicts/sec is the rate at which group registration received by the WINS server resulted in conflicts with records in the database.

WINSCTRS_TOTAL_CONFLICTS_009_NAME=Total Number of Conflicts/sec
WINSCTRS_TOTAL_CONFLICTS_009_HELP=Total Number of Conflicts/sec is the sum of the Unique and Group conflicts per sec.  This is the total rate at which conflicts were seen by the WINS server.

WINSCTRS_SUCC_RELEASES_009_NAME=Successful Releases/sec
WINSCTRS_SUCC_RELEASES_009_HELP=Total Number of Successful Releases/sec

WINSCTRS_FAIL_RELEASES_009_NAME=Failed Releases/sec
WINSCTRS_FAIL_RELEASES_009_HELP=Total Number of Failed Releases/sec

WINSCTRS_SUCC_QUERIES_009_NAME=Successful Queries/sec
WINSCTRS_SUCC_QUERIES_009_HELP=Total Number of Successful Queries/sec

WINSCTRS_FAIL_QUERIES_009_NAME=Failed Queries/sec
WINSCTRS_FAIL_QUERIES_009_HELP=Total Number of Failed Queries/sec
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\rpc\readme.txt ===
winscl.exe is a non-gui administration tool for WINS. It can be used
for monitoring a WINS's activity and for examining its database.
It can also be used for sending commands to WINS to initiate an activity 
such as  replication,  scavenging, registering a record, etc. 
 
Note: Unlike WINS Manager, winscl can not be used to configure a WINS.


The following commands are supported by winscl


 RN - Register Name

 You can register a unique/multihomed/normal group/internet group names.

 QN - Query Name

 You can query any name in the wins db.


 DN  - Delete Name

 Deletes a name.  This action permanently gets rid of the name from the
 WINS db.

 GV  - Get Version Counter Value

 Gets the current value of the version counter used to stamp records with
 version numbers

 GM  - Get Mappings

 Gets the configuration intervals being used by WINS.  These intervals
 are in secs.  It also retrieves the priority class and the number of
 query threads in WINS.  The owner id to address to version number mappings 
 used by the replicator to determine how up-to-date the WINS db is relative
 to other WINSs is also retrieved.  This command works only with an 
 NT 3.51 WINS.  Note: Owner Id is a number corresponding to a WINS address
 that is stored with a record in the WINS db. It indicates who the owner
 of the record is.

 
 GMO  - Get Mappings (to be used with NT 3.5 WINS)

 Same as above except that this command should be used when connected to an
 NT 3.5 WINS.


 GST - Get Statistics

 Gets the various timestamps and statistics maintained by WINS.  This command
 works only with an NT 3.51 WINS

 GSTO - Get Statistics (to be used with NT 3.5 WINS)

 Same as above except that this command should be used when going to an
 NT 3.5 WINS.

 PUSHT - Push Trigger
  
 Used to instruct the connected WINS to send a push trigger to another WINS.  
 The local WINS will send a push trigger to the remote WINS only if either the 
 remote WINS is listed under the Wins\Parameters\Push key in the registry or 
 if RplOnlyWCnfPnrs value of the Wins\Parameters key in the registry is 
 either non-existent or is set to 0.  Likewise, the remote WINS will accept 
 this trigger only of the local WINS is either listed listed under the 
 Wins\Parameters\Pull key in its registry or if  RplOnlyWCnfPnrs value of the 
 Wins\Parameters key in its registry is either  non-existent or is set to 0.  

 Once the trigger is sent and accepted, the remote WINS, depending upon 
 whether or not its db is out of sync with the connected WINS's db may or 
 may not pull records from the local WINS.

 PULLT - Pull Trigger

 Used to instruct the connected WINS to send a pull trigger to another WINS.  
 The local WINS will send a pull trigger to the remote WINS only if its db
 is out of sync with it and if and only if the remote WINS is either listed 
 under  the Wins\Parameters\Pull key or if RplOnlyWCnfPnrs value of the 
 Wins\Parameters key either non-existent or is set to 0.  Likewise,
 the remote WINS will accept this trigger only of the local WINS is either
 listed listed under the Wins\Parameters\Push key in its registry or if 
 RplOnlyWCnfPnrs value of the Wins\Parameters key in its registry is either 
 non-existent or is set to 0.  

 
 SI - Statically Initialize WINS

 Used to statically initialize WINS from a file which has records in
 the format used in an lmhosts file.

 CC - Use this command to initiate Consistency Checking on WINS. Consistency
      checking results in WINS communicating with other WINSs to check the
      consistency of its database.  THIS OPERATION RESULTS IN HIGH OVERHEAD
      ON THE WINS AND ALSO CAN HOG UP NETWORK BW (A FULL REPLICATION IS DONE).
      If you have a large database, you should probably do this at times when
      there is less network traffic. 
 
 SC - Scavenge  records
 
 Used to instruct WINS to scavenge records. This means that records that
 are old enough to be released will be released. Those that need to be
 made extinct will be made so.  Extinct records that need to be deleted
 will be deleted.  replica records that need to be verified will be verified.

 DRR - Delete all or a range of records 

 Used to deleted records by giving the range of version numbers.  You can
 delete all records of a WINS too.  Only the records owned by the WINS
 selected (when prompted) will be deleted.  Other information regarding
 the WINS, such as highest version number pulled, will not be deleted.

 PRR - Pull all or a range of records


 Used to pull a range of records from another WINS.  The range is given
 in terms of version numbers. If the range being pulled overlaps records
 of the remote WINS already there in the WINS db, they will first be 
 deleted before the new records are pulled.  This command is used to pull
 record(s) that somehow never got replicated and have no chance of
 replicating unless their version number becomes more than the highest the
 local WINS has for the remote WINS. 

 Again, like the PULLT command, the replication will happen only after the
 appropriate registry check (refer: PULLT command)


 GRBN - Get record by Name 

 Retreives one or more records starting with a string.  The names of
 records are lexicographically sorted in the WINS db (Exception:
 Names with 0x1B in the 16th byte are stored with the 1st and 16th byte
 transposed - they are displayed correctly). You are given a choice to
 search the db from the beginning or the end.  So, if you want to retrieve
 lets say 100 names starting with Z, it is a good idea to specify that
 WINS should search the names from the end of the db.  This will cause
 less overhead on WINS.

 
 GRBV  - Get records by version numbers

 Retrieve records from the local WINS db by specifying the range of 
 version numbers.

 BK  - Backup the WINS db.

 Backup the WINS db to a directory on the same machine as WINS.

 RSO  - Restore the WINS db (db created by WINS prior to SUR)

 Restores the WINS db to the directory it was backed up from.  NOTE: WINS
 SHOULD NOT BE RUNNING WHEN YOU RUN THIS COMMAND. 

 RS  - Restore the WINS db (db created by WINS in SUR or beyond)

 Restores the WINS db to the directory it was backed up from.  NOTE: WINS
 SHOULD NOT BE RUNNING WHEN YOU RUN THIS COMMAND. 

 RC  - Reset WINS counters

 Resets the WINS counters displayed via GST (or GSTO for NT 3.5 WINS) to
 0.

 CR  - Count records in the db.

 Counts the number of records for an owner in the WINS db.  The owner 
 is identified by the address.  You can either count all or a range of
 records.   NOTE: this can be a high overhead operation when the records
 being counted are a lot.


 SDB  - Search the db

 Search the database for records for a record with a particular name or
 address.  NOTE: When the db contains a lot of records, this can be 
 a time-consuming and "consistent overhead" operation on WINS.


 GD  - Get domain names
  
 Gets the list of domain names registered in the WINS db.  These are the
 1B names (0x1B in the 16th byte) registered by PDCs of the domains.


 DW  - Delete Wins

 This deletes all the information relevant to a WINS (identified by its
 address) from the db of the connected WINS.  This includes all records
 belonging to the WINS as well as administrative information kept for the
 WINS.  When the connected WINS is specified for deletion, all its records
 are deleted. Other information such as highest version number of records
 in db. is not removed.


 CW - Connect to Wins


 MENU - Show MENU

 NOMENU - Don't show MENU (helpful if you don't want to clutter up the output
          from a script driving the tool).
 Used to connect to another WINS

 EX - Exit the tool



 Points to Note:

  1) Addresses of WINS should be given in dotted decimal notation
  2) A version number is 64 bits long.  When prompted for it, it should be 
     given in decimal with the high word first followed by the low word 
     The two words should be seperated by a space.
  3) Many commands such as PULLT, PUSHT, SI, PRR, etc are executed
     in the background. A return status of SUCCESS indicates that the
     command has been queued to WINS for execution. It does not mean that
     WINS has successfully executed the command. 
  4) winscl is case sensitive.  So, BOB is  different from bob or Bob (when
     input to RN, QN, DN, etc).
  5) Scope if given should be in domain name form  - explained in 
     rfc 883.  Example: netbios.com. 
  6) Whenever a pull (or a push) replication is done, the local WINS will 
     send a request for it to the remote WINS only if the remote WINS is 
     either listed under the Wins\Parameters\Pull (or Push) key or 
     if RplOnlyWCnfPnrs value of the Wins\Parameters key is either 
     non-existent or is set to 0.  Likewise, the remote WINS will accept 
     the above request only if the WINS making the request is either 
     listed under the Wins\Parameters\Push (or Pull) key or if 
     the RplOnlyWCnfPnrs value of the  Wins\Parameters key is either 
      non-existent or is set to 0.  

     The two WINSs look up the above keys/values in their local registries. 
  7) When prompted for Version Number, give it in the following form
       <high word> <long word>. Example  0 9567.  The numbers are in decimal.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\private-changes.txt ===
/*
 * This file is a log of the changes to the NLB private branch, wlbs.
 * This includes all check-ins, integrates and other relevant notes
 * that affect the current state of the private tree.
 */

*** Date, user: Detailed list of changes (operations)

*** 04.27.01, shouse: Checking in private.changes - initial checkin.

*** 05.02.01, josephj:  Bugfixes for

    330799  SLD:  Improper file resource "netcfgx.dll" ...
    317200  SLD:  Need to autofix ...
    372527  the term "Virtual IP Address" in the Port Rules page ...

*** 05.15.01, shouse: Two small IPSec/PPTP session support fixes and bug fixes for

    252258 Misconfigured hosts respond to remote queries.
    391877 PREFIX:net: \nt\net\wlbs\driver\main.c: Main_recv_indicate: using uninitialized memory 'sig'
    391878 PREFIX:net: \nt\net\wlbs\driver\main.c: Main_recv: using uninitialized memory 'sig'
    391881 PREFIX:net: \nt\net\wlbs\nlbkd\print.c: PrintResp: using uninitialized memory 'pMPReserved'
    391883 PREFIX:net: \nt\net\wlbs\nlbkd\print.c: PrintResp: using uninitialized memory 'pIMReserved'
    392999 NLB: Need to back out current behavior (both converged) if one host is unicast and the other is multicast

*** 05.15.01, josephj: prefix bugs to nlbmgr code

    391879  josephj PREFIX:net: \nt\net\wlbs\nlbmgr\inetcfg...
    391880  josephj PREFIX:net: \nt\net\wlbs\nlbmgr\exe\...

*** 05.15.01, josephj: Fixes to the following netcfgx.dll bugs:
    396770  josephj Wrong error message displayed when entering...
    372527  josephj the term "Virtual IP Address" in the Port Rules...

*** 05.15.01, josephj: Fixes to the following nlbmgr.dll bugs:
    396172  josephj NLB:nlbmgr:remove test menu option from the cluster menu

*** 05.21.01, shouse: Bug fixes and groudwork for diagnostics
    338555 NLB:Event Logging:Generate an event log that says which host initiated convergence and why.

*** 05.21.01, shouse: Integrate from Net VBL and reverse-integrate private branch into Net VBL.

*** 05.29.01, chrisdar: Modify nt\net\wlbs\nlbmgr\provider\cfgutils.cpp to work around timing problems associated with adding IPs to an adapter.
              Suspect recent code changes in ntwk adapter code require this.

*** 05.31.01, shouse: Integreate from VBL 03.

*** 06.04.01, chrisdar: Added harness (\nt\net\config\netcfg\wlbscfg\tests) for testing VIP support in port rules for answer files.
    392774  chrisdar NLB:Virtual cluster support is not in the answer file

*** 06,04,01, shouse: Bug fix for IP address conflicts in multicast (or IGMP multicast) mode.
    402659 Cannot bind NLB to more than one NIC in multicast mode.

*** 06.04.01, shouse: Reverse-integrate from VBL 03.

*** 06.04.01, shouse: Obliterate net\wlbs\wmi2\.

*** 06.05.01, josephj: Partial support for 237073 ... need the mechanism to
    display pending opertions. Enabled the static methods in nlbmprov.dll
    (previously these methods used to return NOT_SUPPORTED).

*** 06.06.01, shouse: Bug fixes
    403305 16 NIC - 2 host cluster - from unicast to multicast, one host is disconnected while other converged by itself
    397828 NLB:remove or change the default behavior of netmonalvemsg from the registry to allow heart beats up
    400118 NLB: All IOCTLs should use a common header to avoid duplicated code.
    198331 NLB: Add  to diagnostic driver IOCTL support.

*** 06.06.01, shouse: Change to prevent NLB driver from being reloaded twice when CommitChanges is called - api/cluster.cpp

*** 06.11.01, shouse: Reverse integrate to VBL 03.

*** 06.14.01, chrisdar: Fix to trpov.exe testing utility for NLB Manager. Bug was overwriting local host machine name placekeeper (".") with NULL info.

*** 06.14.01, karthicn: Bug Fixes
    397421 When IP2MACenable is set to false in the registry, data loss occurs
    399778 WMI: report host's machine and domain name for all hosts in the cluster.
    336943 NLB: Add WMI support for querying the port rule state

*** 06.14.01, shouse: Bug fixes, plus IPSec and PPTP session support is now turned ON by default.
    13413  WLBS: Event log information  messages should contain more useful information
    385665 Machine bug checks when bind unbind and start stop are done at the same time
    405719 NLB:eventlog:remote control messages are misleading by showing the source udp port.
    198191 wlbs query <VIP> reports does not report the local host  when you start network monitor on the NLB bound interface

*** 06.14.01, karthicn: Bug Fixes
    396792 Listbox focus is not snapped  when new port rule is added, to keep rule in sight

*** 06.15.01, chrisdar: Fixes to tprov.exe testing harness.

*** 06.18.01, shouse: Fix for IA64 compile error in load.c and fix to remove call to NdisEqualUnicodeString in Main_adapter_get, which cannot be called at DISPATCH_LEVEL.

*** 06.19.01, karthicn: Bug Fix 
    357547 : The hosting model for the WLBS (wlbsprov.dll) provider needs to be set to "NetworkService"

*** 06.19.01, shouse: Bug fix
    418918 NLB: Driver should allow case-insensitive device name comparison.

*** 06.26.01, chrisdar: implement tracing
    424588   API: Implement tracing

*** 06.27.01, karthicn: Reverse integrate to VBL 03.

*** 06.29.01, josephj:  BUG: 237073 josephj NLBManager:(usability p1) need ...
    Specifically, this is to add a new WLBS entrypoint WlbsDeleteAllPortRules.
    to wlbsctrl.dll, plus some changes in nlbmprov.dll to support port rules.

*** 06.29.01  chrisdar: Bug fixes
    276224 NLB:setup:log errors to setup error log if there are any errors during setup
    422946 Netcfgx.dll: Change use of clusapi to load calls via DLL

*** 06.29.01, shouse: Changes to XML parser.
    NOTE: xml directory has been added to net\wlbs\dirs, so xml will now be compiled as part of the build!!!

*** 07.03.01, shouse: Tons of miscellaneous XML parser changes.
    NOTE: writing out an XML file is now fully implemented.

*** 07.05.01, chrisdar
    427669 NLB:Virtual cluster unattend setup failed

*** 07.05.01, karthicn
    429899 NLB:wlbsctrl.dll some registry keys were not being closed and that lead to the handles being open to cause winprvse crash during WMI BVT

*** 07.06.01, chrisdar
    424587 Driver: Implement tracing -- first pass for debugging bind/unbind issues seen in lab

*** 07.10.01, chrisdar: Reverse integrate to VBL 03.
----------------------------------------------------------------------

*** 07.11.01, josephj: Fixes for the following.
428348  josephj PREFIX:net: \nt\net\wlbs\nlbmgr\exe\commonnlb.cpp:
428349  josephj PREFIX:net: \nt\net\wlbs\nlbmgr\exe\rightbottomview.cpp:

*** 07.11.01, josephj: RI to VBL 03.
----------------------------------------------------------------------

*** 07.12.01, karthicn
    357547 : The hosting model for the WLBS (wlbsprov.dll) provider needs to be set to "NetworkService"

*** 07.12.01, josephj Created new directory "exe2" under nlbmgr, which is
    starts out as a copy of nlbmgr\exe. Exe2 will contain the changes 
    required to use the new nlb update config support.

*** 07.13.01, chrisdar: RI to VBL 03.
----------------------------------------------------------------------

*** 07.13.01, josephj: 
    357547 : The hosting model for the WLBS (wlbsprov.dll) provider needs to be set to "NetworkService"
    (Karthic's above change was not complete).

*** 07.23.01, chrisdar: 
    424587 Driver: Implement tracing

*** 07.23.01 , josephj:
    435839  nlbmgr:tprov connection fails when /u option used....
    This actually got fixed by making a fix to the above fix (357547).
    Verified by GJack.

*** 07.24.01, chrisdar: found bug in tracing added driver\main.c. IA64 won't compile.
    424587 Driver: Implement tracing

*** 07.25.01, chrisdar
    439029 netcfgx.dll: reading strings from answer file assumed the destination buffer is 2x larger than it is
    425543 netcfgx.dll: Ensure default values and range checking are done on properties read by answer file

*** 07.25.01, karthicn
    437743  Add tracing to WMI Provider

*** 07.25.01, shouse
    Updates to the XML support.

*** 07.28.01 josephj
    Lab03 RI
    Change 21301 on 2001/07/28 21:34:52 by NTDEV\josephj@JOSEPHJ1C-1
----------------------------------------------------------------------

*** 08.01.01, shouse
    353752 NLB: Add a third initial host state to the registry
    305096 disabling/enabling adapter during config causes a variety of problems

*** 08.02.01, shouse
    Lab03 RI
    Change 21498 on 2001/08/02 13:31:06 by NTDEV\shouse@SHOUSE-DEV1
----------------------------------------------------------------------

*** 08.08.01, josephj
    449910 NLB:tprov: tprov is ... (nlbmprov.dll)
    Change 21596

*** 08.08.01, karthicn
    437854  Regression: Sorting of Port Rules in netcfg UI is acting oddly

*** 08.08.01 chrisdar
    353134 Remote wlbs commands to the VIP do not display results until the timeout for the UDP call has expired

*** 08.08.01 chrisdar; removed LOTS of tracing
    424587 Driver: Implement tracing

*** 08.10.01 chrisdar
    408332 WLBS.EXE returns -1 when it is executed with no parameters

----------------------------------------------------------------------
*** 08.14.01, karthicn
    Lab03 RI
    Change 22006 by NTDEV\karthicn@KARTHICNMAIN-1 on 2001/08/14 13:20:49
----------------------------------------------------------------------

*** 08.15.01, karthicn
    432091 NLB should not require reboots to reconfigure
    436272 NLB:wlbsprov: remove the dead code from the core provider wlbsctrl.dll

----------------------------------------------------------------------
*** 08.16.01, karthicn
    Lab03 RI
    Change 22130 by NTDEV\karthicn@KARTHICNMAIN-1 on 2001/08/16 11:44:13
----------------------------------------------------------------------

*** 08.20.01 chrisdar
    457468 nlb:unattend install should not require PersistedStates

*** 09.10.01 chrisdar
    457468 nlb:unattend install should not require PersistedStates
    458354 nlb:upgrade fails to add PersistedStates to the registry causing cluster traffic to pass through
    462868 WLBS: After upgrading host2, then host1 in NLB cluster, host1 cannot reach anything on the network.

*** 09.10.01 karthicn
    466150 add support to delete instance using full path

*** 09.10.01, shouse
    Miscellaneous changes to XML, including instituting boolean types and enforcing
    that NLB XML documents contain a reference to the MicrosoftNLB XML schema. Added
    a sub-dir named wlbs\cluster\ which contains the XML-independent implementation
    of the data structures used by the parser, which can be utilized by any NLB com-
    ponent that links with nlbcluster.lib.

*** 09.14.01, karthicn
    449910 NLB:tprov: tprov is failing to update setting with 0x8004100a WBEM_E_CRITICAL_ERROR
    463598 NlbManager: Swithc nlbmprov.dll to use lower-level wlbsctrl.dll apis and dynamically load wlbsctrl.

----------------------------------------------------------------------
*** 09.14.01, karthicn
    Lab03 RI
    Change 23226 on 2001/09/14 14:11:09 by NTDEV\karthicn@KARTHICNMAIN
----------------------------------------------------------------------

*** 09.17.01, shouse
    455705 NLB: Miniport timer cancellation race condition causes NDIS to bugcheck
    426270 NLB: TRACKING: Connection descriptors are destroyed before TCP connections are fully terminated
    293118 NLB: client is getting connections refused.
    364677 WLBS: Clustered RRAS servers drop vpn calls when new hosts added or  WLBS Drain or WLBS Drainstop command given.
    426239 NLB: If outbound traffic uses a non-NLB NIC, connection tracking information is incorrecly maintained

----------------------------------------------------------------------
*** 09.17.01, shouse
    Lab02 RI ** NOTE different VBL (Net VBL) **
----------------------------------------------------------------------

*** 09.17.01, JosephJ Many changes under wlbs\nlbmgr
    Most of it is not built. However some minor changes are in 
    wlbs\nlbmgr\cfgutillib (and wlbs\nlbmgr\inc), which are used
    in building nlbmprov.dll. These changes have been verified and
    it's ok to check this in the vbl03.

*** 09.19.01, shouse
    #ifdef out the IPSec-dependent code in netcfg so we can build
    netcfg while we wait for lab03 to integrate the changes made
    to IPSec in lab02. DO NOT REVERSE-INTEGRATE THE PRIVATE BRANCH
    BEFORE THIS CODE IS RE-ADDED TO NETCFG AND THE CORRESPONDING
    IPSEC CHANGES HAVE MADE IT INTO LAB03!!!

*** 09.19.01, shouse
    Integrate from Lab03 to pick up fixes for the following bugs
    that were checked directly into Lab03 for the RI with main.
    435839 nlbmgr:tprov connection fails when /u option used ( ERROR 0x80070005 )
    463094 NLB:the 12K stack gets used up because we recursive handle several queued up remote control request packets

*** 09.21.01, shouse
    Integrate from Lab03 to pick up the VPN related fixes checked
    into Lab02 on monday.  We are now in sync with Lab02 and have
    picked up the required IPSec fixes, so the ban on reverse-
    integrations is hereby lifted.  The change made to netcfg on
    09.19.01 has been reverted.

*** 09.21.01, shouse
    Checked in changes for 468094 and 469443 including all support 
    except the WMI.  The bugs have been re-assigned to karthicn to 
    add WMI support.

*** 09.25.01, shouse
    Checked in NLB manager UI support for per-VIP port rules and the
    third initial host state (and persisted suspends).  Also cleaned
    up many of the UIs and added context sensitive help to all NLB
    Manager dialogs.

*** 09.25.01, karthicn
    209110 NLBManager: Need File Save/Open option

*** 09.26.01, shouse
    472493 Machine soft-hangs when NLB is bound and you attempt to disable any adapter

*** 09.26.01, karthicn
    449910 NLB:tprov: tprov is failing to update setting with 0x8004100a WBEM_E_CRITICAL_ERROR

*** 09.26.01, shouse
    279316 NLBManager - New context sensitive help
    377507 NLB: Port rule description in NLB netcfg UI / NLB manager does not reflect the additional VIP information for port rules.

*** 09.28.01, shouse
    Make sure DbgPrint (and UNIV_PRINT) statements are not using unicode
    if running at an IRQ level > PASSIVE_LEVEL.

----------------------------------------------------------------------
*** 10.02.01, josephj
    Lab03 RI
----------------------------------------------------------------------

*** 10.03.01, karthicn
 NLB provider related changes to the following bugs
 468094 NLB: Allow connection descriptor timeouts to be configurable via the registry
 469443 NLB: remote control "disable" is not completely functional

*** 10.08.01, josephj
    478029 - NLBManager: Checkin the new NLB Manager to replace the old one

----------------------------------------------------------------------
*** 10.08.01, josephj
    Lab03 RI
----------------------------------------------------------------------

*** 10.12.01, karthicn
 NLB Manager provider related changes to the following bugs
 466005 NLBManager: implement cluster and port control operations

----------------------------------------------------------------------
*** 10.12.01, karthicn
    Lab03 RI
    Change 24896 on 2001/10/12 18:39:35 by NTDEV\karthicn@KARTHICNMAIN-1
----------------------------------------------------------------------
*** 10.17.01, josephj
    Fixes for the following
    479845  chrisdar IA64 bugcheck when adding rule through WMI PortRuleEx 
    469815  josephj  NLB: configuration is lost and or diver loses binding..
    480120  josephj  nlb:nlbmgr registry key installdate is not initalized
    466005  karthicn NLBManager: implement cluster control operations..
    439987  shouse  NLB: driver does not respond to remote control packets..

----------------------------------------------------------------------
*** 10.18.01, josephj
    Lab03 RI
----------------------------------------------------------------------
*** 11.01.01, josephj
    Numerous changes to nlbmgr.exe and nlbmprov.dll -- all under
    wlbs\nlbmgr. Changes are by KarthicN to support control port
    and report host state, as well as by JosephJ for per speedup of provider,
    click-on-log-for-details, rudimentary reporting of misconfigured clusters,
    F5 (refresh), etc. These map to the following bugs:
    207015 NLBManager: Have to come to an idea how to show the...
    484761 NLBManager:UI: Need to populate the right view pane...
    484842 NLBManager: For localization compatibility, replace all %xx fields...
    484957 NLBManager: Add support for enable/disable/drain of port rules...
    488976 NlbManager: Perf improvements
    
*** 11.07.01, chrisdar
    nlbkd.dll changes
    No bug number for these changes
    Implemented 3 methods (nlbpkt, nlbether, nlbip) to print the contents of a packet
    given a pointer to a packet of the appropriate type
*** 11.13.01, josephj
    Update to nlbmgr -- fixes related to bugs listed above under 11.01.01.

----------------------------------------------------------------------
*** 11.15.01, josephj
    Lab03 RI
----------------------------------------------------------------------

*** 11.28.01, shouse
    399581 pss req: add ability for nlb to track its own perf as in how much traffic each host is handling
    400257 NLB: Modularize NLB Load module filtering functions
    486047 NLB: NLB UI sends an adapter property change notification for ALL parameter changes
    488169 NLB: IPSec notifications that NLB is bound fail on answer file installs( Tested )

*** 11.29.01, shouse
    Fixed a bugcheck in load.c pertaining to cloning and changes to the IPSec
    notification scheme in netcfg, based on code-review feedback.

*** 12.05.01, chrisdar
    BUG 482284 NLB: stores its private state in wrong Ndis packet causes break during standby

*** 12.05.01, chrisdar
    BUG 499552 NLB: Ensure that adapter bouncing decision is consistent in wlbsctrl.dll and netcfgx.dll

*** 12.07.01, josephj
    NLBMGR: Minor change to add title text to property page
     (nlbmgr\exe2\leftview.cpp). Good to checkin whenever.

----------------------------------------------------------------------
*** 12.10.01, shouse
    Lab03 RI
----------------------------------------------------------------------

*** 12.10.01, shouse
    490906 (12/7)nlbs:bugcheck  while changing op mode to multicast from unicast
    Also removed the NLB_SESSION_SUPPORT conditional compilation #ifdefs from the
    driver and APIs.

*** 12.12.01 chrisdar
    502534 wlbsctrl.dll: errors found by PREfast
    502555 (12/7) netcfgx.dll: PREfast defects found in wlbscfg code
    505124 wlbsprov.dll: errors found by PREfast

*** 12.12.01, shouse
    Checked in a fix for the load module clock that was exposed by the cloning
    mechanism.  This fix stops the clock from being reset every time the load
    module is "started" - it now continues to linearly increase the entire time
    NLB is bound to that interface.  The clock should roll-over in the same time
    as time_t.

*** 12.12.01 karthicn
    372527 the term "Virtual IP Address" in the Port Rules page needs to change to "Cluster IP Address"
    493098 NLB: UI: Invalid IPs are allowed to be entered as CIP/DIP/VIP
    501379 NLB: Missing Port Rule descriptions in netcfg UI

----------------------------------------------------------------------
*** 12.14.01 chrisdar
    Lab03 RI
----------------------------------------------------------------------

*** 12.17.01 chrisdar
    457437 NLBManager: Add NT event logging to the wmi provider

*** 12.17.01 karthicn
    459133 NLBManager Provider: Use of static strings in updatecfg.cpp will break in localized (GER, ITN, SPA,...( systems  

*** 12.17.01 karthicn
    488444 nlb:nlbmgr:host list should open file so that users can open and red file while nlbmgr has the file open
    499040 NLB: nlbmgr: Query option in host control


----------------------------------------------------------------------
*** 12.18.01 josephj
    Lab03 RI
----------------------------------------------------------------------

*** 12.18.01, shouse
    497710 (12/21)NLB needs to provide a hook to address Stingray/ISA scenarios

*** 12.18.01, karthicn 
    466672 (12/10) NLB : NLB does not proprely report status change events to WMI clients -- needed for BDA

*** 12.19.01 chrisdar
    493106 NLB: NLB.EXE: 'Help' is cut off in German builds
    506329 wlbs.sys: PREfast defects in driver
    492201 TRACKING: NLB KD Extensions

*** 12.19.01 josephj

    506822 port control window unresponsive
    207015 Reporting Cluster Misconfiguations
    499068 save host list includes clusters or hosts that were removed
    503027 Connect dialog: duplicate hotkey (N)
    503031 duplicate hotkey (N)
    503046 Log Settings: duplicate hotkey (E)
    504165 "Host\Delete" menu item is disabled when host is selected.
    209117 UI to manage cluster VIPS
    502585 Update details view

    All files changed are under wlbs\nlbmgr

*** 12.19.01, shouse
    497710 (12/21)NLB needs to provide a hook to address  Stingray/ISA scenarios

----------------------------------------------------------------------
*** 12.20.01 josephj
    Lab03 RI
----------------------------------------------------------------------

*** 12.20.01, shouse
    Added a new debugger extension, !nlbhooks, to print out the configuration
    and state of all NLB kernel-mode hooks.

*** 12.26.01, josephj
    nt\net\inc\wlbsconfig.h: Added function pointer prototype
     WlbsSetRemotePassword_FUNC. Required for
    bug# 326514 Modify remote-control pwd, report differences in pwd.

*** 12.26.01, josephj
    All under wlbs\nlbmgr...
     203647  NLBManager should wrap the WMI error...
     326514 Modify remote-control pwd, report differences in pwd:
     509397  error check: when inital state conflicts a warning is given...
     509400  error check: add check for conflicting port rule where affinit

*** 12.28.01, josephj
    Fixes for ...
        484842 For localization compatibility, replace all %xx fields by %num
    All files changed under nlbmgr.

*** 1.4.02, shouse
    Fixed a typo in hook reference counting (Main_send).

*** 1.7.02, josephj fixes for the following
    [All under wlbs\nlbmgr]
    203647  NLBManager should wrap the WMI error...
    326514 Modify remote-control pwd, report differences in pwd:
    509397  error check: when inital state conflicts a warning is given...
    509400  error check: add check for conflicting port rule where affinity..
    484842 For localization compatibility, replace all %xx fields by %num
    202129 Make equal/unequal property of port rules a host-specific property.
    203634 Nlb Manager should report useful error when netcfgs..
    485541 Provide valid defaults for host-priorities to single-host port rule
    288769 error check: Verify that Primary IP, DIP and additional VIPs' ..
    360469 Warn user if whole cluster will come down because of operation.

----------------------------------------------------------------------
*** 01.07.02 josephj
    Lab03 RI
----------------------------------------------------------------------

*** 01.08.02 chrisdar
    512232 wlbsctrl: NotifyAdapterPropertyChange calls SetupDiDestroyDeviceInfoList twice when exiting on no error

*** 01.08.02 karthicn
    505568 : wlbsprov.dll uses 65K of stack space for local storage

----------------------------------------------------------------------
*** 01.08.02 karthicn
    Lab03 RI
----------------------------------------------------------------------

*** 01.11.02 josephj, shouse
    Misc files checked in under wlbs\nlbmgr by SHouse and myself for
    fixes/partial-fixes to:
    [not-fixed fully] 476216  automatically add hoats to view when  "Connect to existing..."
    505467  nlbmgr:teamed nics are not recognized as a valid interface
    
*** 01.17.02 karthicn
    513807 NLB: Move WMI event classes to MicrosoftNLB namespace, remove from WMI namespace
    459885 WLBS.EXE: Static strings in control.cpp will not be localized

*** 01.21.02 chrisdar
    512459 wlbsctrl: PREfast defects

*** 01.22.02, shouse
    505253 nlbmgr:The right pane is wider than it needs to be when viewed at the host level
    505467 nlbmgr:teamed nics are not recognized as a valid interface

    Also added 5 new nlbkd debugger extensions.

*** 01.23.02 chrisdar
    517186 PREFAST:net: \nt\net\wlbs\wmi\clusterwrapper.cpp: CWlbsClusterWrapper::Commit: Incorrect operator:  mutual exclusion over || is always TRUE.  Was && intended ?

----------------------------------------------------------------------
*** 01.24.02 josephj
    Lab03 RI
----------------------------------------------------------------------

*** 01.28.02 chrisdar
    517185 PREFAST:net: \nt\net\wlbs\control\control.cpp: Display: Buffer overrun due to number of characters/number of bytes mismatch in call to 'ReadEventLogW'.  Parameter 4 should be '(sizeof recp)/(sizeof recp[0])'.

*** 01.28.02, shouse
    501365 NLB: Remove necessity for multiple hashes on processing SYN packets
    501374 NLB: Consider moving protocol specific information necessary to properly load-balance into the load module

*** 01.29.02, shouse
    525063 nlbmgr:cluster IP address tab should resemble advanced IP prop
    526710 NLB: If two masters are configured for a BDA team, NLB should resolve the conflict by demoting one to a slave

*** 01.29.02 chrisdar
    476216 NLBManager:automatically add hosts to view when  "Connect to existing..." is executed
    527453 NLBManager: Log file validation doesn't allow file name 'c:\nlbdemo.log' when c: is a valid local drive

*** 01.29.02 josephj
    All changes under wlbs\nlbmgr

    484025  When using alt-F4 to close nlbmgr.exe, the process stays in memory.
    513056  add host failed because nlbmgr ended up pinging for "13:36:48".
    502793  warn user when attempting to remove / change DIP
    512303  Block user from merging 2 clusters that are in the nlbmgr context
    512370  update sometims fails when IP is zero (0.0.0.0)
    478932  ipconflict when changing modes of operation ( unicast to multicast )
    505153  NlbConfigurationUpdate::DoUpdate returns WBEM_E_ALREADY_EXISTS
    509346  delete host adds a homenet IP when it should keep the DIP
    509355  replace or remove home net ip functions like IP with the real home
    519111  nlbmgr:VERIFIER STOP 00000008: pid 0xF68: corrupted heap pointer
    
*** 01.30.02 chrisdar
    Back out one prefast defect fix made when working on:
    517185 PREFAST:net: \nt\net\wlbs\control\control.cpp: Display: Buffer overrun due to number of characters/number of bytes mismatch in call to 'ReadEventLogW'.  Parameter 4 should be '(sizeof recp)/(sizeof recp[0])'.
    Fix breaks redirecting stdio to file.

*** 01.30.02 chrisdar
    Corrected error introduced in wlbsctrl.dll for remote WlbsQuery.

----------------------------------------------------------------------
*** 01.24.02 chrisdar
    Lab03 RI (posthumously)
----------------------------------------------------------------------

*** 02.01.02 chrisdar
    530302 nlb:wlbs.exe control commands do not print appropriate messages

*** 02.04.02 karthicn
    501782  nlbs: NET/SMB connections fail when using \\clustername
    515544  nlb:Globalization issues with wlbs query, display, params

*** 02.05.02, shouse
    530341 NLB:  Prematurely 'completed' NDIS requests may cause NLB to bugcheck.

*** 02.12.02 josephj
    Remove dead (uncompiled code) under  wlbs\nlbmgr. Reviewed by KarthicN.
    Also diffed precompiled output to verify no changes.

*** 02.12.02 karthic
    #ifdef BUGFIX_515544 and BUGFIX_501782 to temporarily disable these fixes.

----------------------------------------------------------------------
*** 02.12.02, shouse
    Lab03 RI
----------------------------------------------------------------------

*** 02.13.02 chrisdar
        DOTW: uncomment C_DEFINES for BUG_539747 in \nt\net\wlbs\api\sources for building privates
    539747 NLB:wlbs remote commands fail with socket error if executed from a cluster host to that cluster when the cluster ip is not in tcp stack.

*** 02.16.02 josephj
    Checked in some DISABLED code under nlbmgr\exe2 for bugs
     334243 and 476216
    OK to RI this in as it's currently DISABLED.

*** 02.19.02, shouse
    Removed #if defined (BUG_506329) and (BUG_501365) macros to remove dead code.  Both
    of these bug fixes have already been approved and the macros have been defined in the 
    build for many weeks.  OK to RI, as only DEAD code was removed.

*** 03.07.02, karthicn
    569758  SECURITY: wlbsctrl.dll : Replace calls to "unsafe" string operation apis with the ones in strsafe.h
    569762  SECURITY: wlbsprov.dll : Replace calls to "unsafe" string operation apis with the ones in strsafe.h
    543936  SECURITY: Shoud NULL terminate the string field before referencing it. net\wlbs\api\control.cpp::WlbsRemoteControl()

*** 03.08.02, karthicn
    Removed the #ifdef BUGFIX_515544 and BUGFIX_501782 to enable these fixes

----------------------------------------------------------------------
*** 03.08.02, karthicn
    Lab03_Dev RI
----------------------------------------------------------------------

*** 03.18.02, karthicn
    577749  SECURITY:  Fix unsafe buffer copy issues in the wmi event functions in wlbs.sys
    Check-in disabled 577752  Fire Startup & Shutdown wmi events from NLB driver

*** 03.19.02, shouse
    Checked in a fix for 559178.  These changes affect ONLY debug and tracing spew, and are
    therefore safe to RI.

*** 03.20.02, chrisdar
    552218 SECURITY: Configuration/UI: Buffer overrun candidates in \nt\net\config\netcfg\wlbscfg\netcfgconfig.cpp
    552260 SECURITY: Configuration/UI: Remove dead code
    552276 SECURITY: Configuration/UI: Buffer overrun candidates in \nt\net\config\netcfg\wlbscfg\debug.cpp
    552287 SECURITY: Configuration/UI: Buffer overrun candidates in \nt\net\config\netcfg\wlbscfg\ports.cpp
    552296 SECURITY: Configuration/UI: Buffer overrun candidates in \nt\net\config\netcfg\wlbscfg\host.cpp
    552298 SECURITY: Configuration/UI: Buffer overrun candidates in \nt\net\config\netcfg\wlbscfg\ClusterDlg.cpp
    552303 SECURITY: Configuration/UI: Buffer overrun candidates in \nt\net\config\netcfg\wlbscfg\utils.cpp
    552335 SECURITY: wlbsutil.lib: Buffer overrun candidates in \nt\net\wlbs\util\debugimpl.cpp
    552345 SECURITY: wlbsutil.lib: Buffer overrun candidates in \nt\net\wlbs\util\utils.cpp
    552665 SECURITY: wlbsutil.lib: Remove dead code
    552370 SECURITY: wlbs.exe: ipconfig.exe launched without using full path to system directory
    552377 SECURITY: wlbs.exe: Buffer overrun candidates in \nt\net\wlbs\control\control.cpp
    552384 SECURITY: wlbs.exe: hh.exe launched without using full path to system directory
    552402 SECURITY: nlb.exe: wlbs.exe launched using hard-coded full path to system directory
    579992 SECURITY: wlbs.exe Remove dead code

*** 03.20.02, josephj

    Fixes for the following, all under nlbmgr\provider.
    Code reviews by SHouse. Stress tested by GJack
    540195  SECURITY:nlbmprov.dll:update fails with error WBEM_E_CRITICAL_ERROR with avrf
    543406  SECURITY:VERIFIER:nlbmprov.dll:return WBEM_E_ALREADY_EXISTS when avrf enabled on
    543455  SECURITY:AVRF:nlbmprov.dll: 00000210: 5f4e10cc 00000000 00000000 00000000 
    558888  SECURITY:NlbManager: nlbmprov.dll Registry handle leak in 

----------------------------------------------------------------------
*** 03.21.02, karthicn
    Lab03_Dev RI
----------------------------------------------------------------------

*** 03.27.02 chrisdar
        DOTW: uncomment the following C_DEFINES for building privates
            BUG_546870 in \nt\net\wlbs\api\sources
            BUG_549240 in \nt\net\wlbs\control\nlb\sources
            BUG_549240 in \nt\net\wlbs\control\wlbs\sources
            BUG_535113 in \nt\net\wlbs\nlbmgr\exe2\sources
            BUG_532722 in \nt\net\wlbs\wmi\sources
    532722 NLB:wmi:Uint32 is converted from decimal to hex before it is handed over to the provider
    535113 NLBMgr:log settings are saved under HKLM when they should be in HKCU
    546870 wlbsctrl.dll: assert hit on cleanup when closing socket in GetRemoteControlSocket
    549240 wlbs.exe: 'wlbs display' doesn't display text for wlbs events logged by netcfgx.dll and nlbprov.dll
    582902 nlb.exe - arguments cannot contain blank space, &, <, > ...

*** 03.28.02, karthicn
    577985 NLB: IOCTLs should only be allowed if initiated by an Administrator

*** 03.28.02, shouse
    543892 SECURITY: NLB: packet parsing on the receive path needs to be much more sensitive to untrusted data

*** 04.02.02, karthicn
    Refix 577985 NLB: IOCTLs should only be allowed if initiated by an Administrator

*** 04.02.02, shouse
    Modified driver to use StrSafe.h APIs.  Still need to use StringCchLength instead of wcslen, but that
    will be a subsequent check-in.

*** 04.02.02, karthicn
    Enable fix for 577752  Fire Startup & Shutdown wmi events from NLB driver

*** 04.02.02, chrisdar
    Enable fixes for:
    532722 NLB:wmi:Uint32 is converted from decimal to hex before it is handed over to the provider
    535113 NLBMgr:log settings are saved under HKLM when they should be in HKCU
    546870 wlbsctrl.dll: assert hit on cleanup when closing socket in GetRemoteControlSocket
    549240 wlbs.exe: 'wlbs display' doesn't display text for wlbs events logged by netcfgx.dll and nlbprov.dll
    539747 NLB:wlbs remote commands fail with socket error if executed from a cluster host to that cluster when the cluster ip is not in tcp stack.
----------------------------------------------------------------------
*** 04.05.02, ChrisDar
    Lab03_Dev RI
----------------------------------------------------------------------
*** 04.08.02, JosephJ
    Fixes for (all under wlbs\nlbmgr):
    334243  NLB manager should perform extended operations in the background;
    476216  automatically add hosts to view when  "Connect to existing..."...
    535859  SECURITY:nlbmgr: avrf /enable nlbmgr.exe /stacks /debug will cause..
    All tested (by GJack) and code reviewed (by KarthicN) and good to RI.
----------------------------------------------------------------------
*** 04.08.02, JosephJ
    Lab03_Dev RI
----------------------------------------------------------------------

*** 04.09.02, shouse
    598194 NLBS UI: IP address size is changed from three digites to two digites per octet.
    Also checked-in a fix to some string safe APIs in the driver.  Turns out they're only
    safe if they're used properly.  Ooops.

*** 04.10.02 chrisdar
    527447 nlb: wlbs commands break into ntsd with avrf /enable wlbs.exe

----------------------------------------------------------------------
*** 04.11.02, JosephJ
    Lab03_Dev RI
----------------------------------------------------------------------

*** 04.10.02, shouse
    More UI changes related to 598194.

*** 04.15.02, josephj fixes (all under wlbs\nlbmgr) for the following:
    489012  If ICMP is disabled by customer for security reasons, they ...
    538191  user's password saved in user-mode memory
    540917  Duplicate shortcut character "P" are there.
    566671  NLBS:NET3:nlbmgr.exe:Typo:Cluster configuration
    540636  password is not updated locally

*** 04.15.02, karthicn
    449910 : NLB:NLB Manager provider should use "NetworkServiceHost" as its hosting model

*** 04.15.02, shouse
    574426 NLB: Hook interface should utilize a single reference count, not one per "hook"
    574433 NLB: Should add a registry key to allow users to filter ICMP traffic if desired
    562066 NLB: Deregister callback of filter hook is called at the DISPATCH level in the scenario of last unbind
    535050 NLB: IOCTL operations are permitted before the binding operation is complete
    549216 NLB: Control operations (stop, start, etc.) should be serialized in the driver
    574439 NLB: Remove the GRETimeout registry key, which is useless
    585771 SECURITY: NLB: Change the meaning of "disabled" remote control (chrisdar fix, shouse unit-test)
    591401 NLB: Memory to store the fully qualified name of a host is not sufficiently large (chrisdar fix, shouse unit-test)

    
*** 04.15.02, josephj fixes (all under wlbs\nlbmgr) for the following:
    597554  josephj NLB manager: About dialog is mis-formatted

*** 04.16.02, shouse
    Fix for "." appended to hostnames when Domain registry key is present, but empty.

----------------------------------------------------------------------
*** 04.16.02, KarthicN
    Lab03_Dev RI
----------------------------------------------------------------------
*** 04.19.02, JosephJ Fix for the following (all under wlbs\nlbmgr)
    535969  too much memory allocated for event logs
    568198  remove from view should not remember cluster properties
    565697  delete host when host is unreachable
    
----------------------------------------------------------------------
*** 04.19.02, KarthicN
    Lab03_Dev RI
----------------------------------------------------------------------

*** 04.20.02, KarthicN
    Checked-in disabled 522605 SECURITY:UDP packets lost due to specific handling of IP fragemnets by NLB

*** 04.22.02, ChrisDar
    604365 ACCESSIBILITY:nlbmgr:In the Cluster Properties windows, the IP Addresses needs a hot key to get to the list box.

*** 04.23.02, ChrisDar
    WORKAROUND FOR:
        607322 NLB:Event log messages do not have correct values for host ids/ips

*** 04.23.02, shouse
    585888 NLB: Move Main_parse_ipsec from Main_ip_recv_filter to Main_recv_frame_parse
    526784 NLB: Filter hook implementation needs to expose a third hook function to query a "fictional" packet.
    562086 NLB: After being unloaded, NLB driver should fail IOCTL requests made by the filter hook using the old handle
    562131 NLB: In the ReceiveFilterHook() we need a flag indicating whether the cluster state is stopped.
    569209 NLB: In the DeregisterCallback of the filter hook, we need additional parameters
    601978 wlbs.exe : should retrieve active connections and no. of descriptors for monitoring purposes

*** 04.24.02, josephj
    (This code is not (yet) part of the build)
    wlbs\driver\diplist.c, diplist.h, and test code under driver\test.
    This is code to check if an ip address is in a list of "other DIPS".

*** 04.24.02, josephj
    Fixes for (all under wlbs\nlbmgr):
    599266 If the interface is DHCP enabled the NLBmgr should...
    599248 prevent user from binding nlb when MSCS is installed...

----------------------------------------------------------------------
*** 04.24.02 ChrisDar
    Lab03_Dev RI
----------------------------------------------------------------------

*** 04.24.02, KarthicN
    Enabled fix for 522605 SECURITY:UDP packets lost due to specific handling of IP fragemnets by NLB

----------------------------------------------------------------------
*** 04.24.02 KarthicN
    Lab03_Dev RI
----------------------------------------------------------------------
*** 04.25.02 JosephJ
    (This code is not in the build) Changed internal constants in
    diplist.h to reflect "production values" -- see wlbs\driver\notes.txt
    for details.

*** 05.03.02, ChrisDar
    585771 SECURITY: NLB: Change the meaning of "disabled" remote control

----------------------------------------------------------------------
*** 05.03.02 ChrisDar
    Lab03_Dev RI
----------------------------------------------------------------------

*** 05.06.02, KarthicN
    610666 new MAC address is taking longer to be associated with NIC after setting up NLB (blocking AC SP2 IDS)

----------------------------------------------------------------------
*** 05.06.02 KarthicN
    Lab03_Dev RI
----------------------------------------------------------------------

*** 05.07.02, ChrisDar
    585771 SECURITY: NLB: Change the meaning of "disabled" remote control

*** 05.08.02, JosephJ
    611517  Spelling error in  IDS_PARM_VIP_CONFLICT_DIP in nlbmgr.exe

*** 05.08.02 KarthicN
    Enabling & Checking privileges to fix 449910 (12/10) NLB:NLB Manager provider should use "NetworkServiceHost" as its hosting model

*** 05.08.02, shouse
    585838 NLB: State lookup in the load module should be independent of reverse/forward hashing
    574441 NLB: Reverse-hashing should be de-coupled from the BDA feature
    608042 SECURITY: DCR: NLB should use exposed connection notification callbacks to mitigate SYN attack in NLB
    610471 Change NLB/IPSec integration from using the Initial Contact notify to using a Vendor ID

----------------------------------------------------------------------
*** 05.08.02, shouse
    Lab03_Dev RI
----------------------------------------------------------------------

*** 05.09.02 KarthicN
    616972 WMI: MicrosoftNLB_Node and MicrosoftNLB_Cluster both show 0 instances when remote control is disabled

----------------------------------------------------------------------
*** 05.09.02, KarthicN
    Lab03_Dev RI
----------------------------------------------------------------------

*** 05.09.02, shouse
    571762 NLB: NLB does not properly filter dedicated IP address traffic

*** 05.10.02 chrisdar
    603411 nlbmgr:ACCESSIBILITY:can not tab between window panes

*** 05.10.02 chrisdar
    619504 NLB: wlbs control passw coding error
    619942 NLB: Copyright information in wlbs.exe

----------------------------------------------------------------------
*** 05.10.02, ChrisDar, JosephJ
    Lab03_Dev RI
----------------------------------------------------------------------

*** 05.13.02, JosephJ
    Add (currently unused) CfgUtilRegWriteParam function to cfgutillib.
    OK to ri whenever needed.

*** 05.16.02 chrisdar (entry is ex post facto)
    624122 User mode support for reporting hosts in a cluster via Identity heartbeats

*** 06.14.02 chrisdar
    643443 NLB: Reg key disabling TCP notifications mechanism is deleted each time a NIC is bound to NLB for the first time.
----------------------------------------------------------------------
*** 05.21.02, KarthicN
    Lab03_Dev Integrate (NOT RI)
----------------------------------------------------------------------

*** 05.21.02, shouse
    From Lab02_N -> Main -> Lab03_N -> Lab03_DEV -> Private branch integrate.
    608042 SECURITY: DCR: NLB should use exposed connection notification callbacks to mitigate SYN attack in NLB

----------------------------------------------------------------------
*** 05.24.02, KarthicN
    Lab03_Dev Integrate (NOT RI)

    Picked up following bug fixes:
    625334  NLB:  Unable to start NLB in IA64 machines due to big value in install date reg key
    624195  HostingModel for NLB WMI Events should be changed from "NetworkServiceHost" to "LocalSystemHost"
----------------------------------------------------------------------

*** 06.03.02, KarthicN
    266964  NLB Apply PnP change returns prematurely, causing reboot , after IP Addr Cahnge on WLBS enabled interfaces

----------------------------------------------------------------------
*** 06.05.02 ChrisDar
    Lab03_Dev Integrate (NOT RI)

    Picked up the following bug fixes:
    *** 05.29.02 chrisdar
        585792 NLB: NLBManager needs a way to get cluster membership from a single node, WITHOUT using remote control
        629065 NLB Driver: missing pragma pack() -- causes internal structure corruption
----------------------------------------------------------------------

----------------------------------------------------------------------
*** 06.05.02 ChrisDar
    Lab03_Dev RI
----------------------------------------------------------------------

*** 06.11.02, shouse
    633140 MSG_ERROR_PRODUCT event

*** 06.11.02 chrisdar
    604522 NLB: Notify object should ensure device presence before applying cross-adapter checks

----------------------------------------------------------------------
*** 06.12.02, shouse
    Lab03_Dev RI
----------------------------------------------------------------------

*** 06.11.02 chrisdar
    636697 NLB: Document the queryport and params options in the wlbs.exe command line usage help

----------------------------------------------------------------------
*** 06.13.02 chrisdar
    Lab03_Dev RI
----------------------------------------------------------------------

*** 06.14.02 josephJ
    639780  josephj  :nlbmg:host can not be removed fron list view when nlb is
    639879  josephj  nlbmgr:sometimes when connecting to host / existing cluster
    Plus some changes in tprov (not built)

----------------------------------------------------------------------
*** 06.14.02 josephj
    Lab03_Dev RI
----------------------------------------------------------------------

----------------------------------------------------------------------
*** 06.18.02, shouse
    Lab03_Dev Integrate (NOT RI)

    Picked up the following bug fixes:
    06.14.02 chrisdar
    643443 NLB: Reg key disabling TCP notifications mechanism is deleted each time a NIC is bound to NLB for the first time.
----------------------------------------------------------------------

*** 06.20.02 chrisdar
    645228 Reduce/modify tracing output in retail NLB so that problem diagnosis in stress and real deployments become effective

----------------------------------------------------------------------
*** 06.20.02 chrisdar
    Lab03_Dev RI
----------------------------------------------------------------------
*** 06.26.02 josephj
     645958 josephj NLBMgr: Label truncated on Connect page
    (changed file is wlbs\nlbmgr\exe2\resource.rc)
    Good to RI to lab03_dev for RC2
----------------------------------------------------------------------
*** 06.26.02 josephj
    Lab03_Dev RI
----------------------------------------------------------------------
RC2        650366  josephj  NlbManager: regression: Left view host status is not updated
RC2        650463  josephj  NlbManager:  default is YES for  "delete cluster"  and "delete node" 

----------------------------------------------------------------------
*** 06.26.02 josephj 9:56PM
    Lab03_Dev RI
----------------------------------------------------------------------

*** 06.27.02 chrisdar
    643216 WLBS: unable to display on-line help

----------------------------------------------------------------------
*** 06.27.02 chrisdar
    Lab03_Dev RI
----------------------------------------------------------------------

*** 06.28.02 chrisdar
    647598 wlbs.exe: disable command verb reports registry error when the port rule doesn't exist

----------------------------------------------------------------------
*** 06.28.02 chrisdar
    Lab03_Dev RI
----------------------------------------------------------------------

*** 07.03.02 chrisdar
    649452 NLBMGR: Events are not saved to the event log file

----------------------------------------------------------------------
*** 07.03.02 chrisdar
    Lab03_Dev RI
----------------------------------------------------------------------

*** 07.10.02 chrisdar
    656566 PREFIX:net: \nt\net\wlbs\installpack\uninstall.cpp: wmain: return value ignored of call to 'GetWindowsDirectoryW'

----------------------------------------------------------------------
*** 07.10.02 chrisdar
    Lab03_Dev RI
----------------------------------------------------------------------

*** 07.16.02 chrisdar
    661992 PREFIX: nlbmprov.dll: handle leak in DllMain

----------------------------------------------------------------------
*** 07.16.02 chrisdar
    Lab03_Dev RI
----------------------------------------------------------------------

*** 07.17.02 karthicn
    650803 MUI: Start Menu: Network Load Balancing Manager link is not MUI enabled.

----------------------------------------------------------------------
*** 07.17.02 karthicn
    Lab03_Dev RI
----------------------------------------------------------------------

*** 07.18.02 karthicn
    663358 wmi:core provider needs to use ID_HB to get MicrosoftNLB_Node.ComputerName

----------------------------------------------------------------------
*** 07.18.02 karthicn
    Lab03_Dev RI
----------------------------------------------------------------------

*** 07.22.02 karthicn
    618347 wmi:generic failure is returned when enumerating PortruleEx when NLB is bound but not configured

----------------------------------------------------------------------
*** 07.22.02 karthicn
    Lab03_Dev RI
----------------------------------------------------------------------

*** 08.01.02 karthicn
    678822 nlbmgr:misconfigured host is not reported when connec to existing ( no verification )

*** 08.01.02 chrisdar
    667251 NLBMGR: Date & time format in Event panel does not match with build language format

*** 08.01.02, shouse
    649598 NLB: IPSec/L2TP clients behind a NAT break NLB VPN support
    637925 RC1RelNote:  ITGRC1: JDPRC1BLCK: NLB: Connection state maintenance using notifications from TCP/IP stack is broken when IP NAT editor is present
    668248 NLB must not have removed the descriptor so one descriptor to one connection principle violated, this conducts to a point of break

----------------------------------------------------------------------
*** 08.05.02 chrisdar
    Lab03_Dev RI
----------------------------------------------------------------------

*** 08.08.02 karthicn
    682872  NLBMGR: Potential IP Address Conflict not detected when creating a new cluster the first time

----------------------------------------------------------------------
*** 08.13.02 chrisdar
    Lab03_Dev Integrate -- picked up a build fix in wlbscfg needed for compiler change.
----------------------------------------------------------------------

*** 08.14.02 chrisdar
    682660 [ETA 8.13.02] Event ID's mismatch between Win2K and .NET server

----------------------------------------------------------------------
*** 08.14.02 chrisdar
    Lab03_Dev RI
----------------------------------------------------------------------
*** 08.15.02 josephj
    684406 - nlbmgr:host icon is not removed from the right list view
             when host is removed from cluster
    Good to ri-- code reviewed by karthicn
    Files changed: nlbmgr\leftview.cpp

----------------------------------------------------------------------
*** 08.15.02 josephj
    Lab03_Dev RI
----------------------------------------------------------------------

*** 08.16.02, shouse
    678173 NLBS hearbeat packet trickes broadcom nic into thinking it is a Wake-on-lan packet on Compaq DL-360-G2


----------------------------------------------------------------------
*** 08.??.02 ???
    Lab03_Dev RI
----------------------------------------------------------------------
*** 08.26.02 chrisdar
    669678 [ETA 8.19.02] (LOCALIZATION)CMD: WLBS: localized string missing if output is redirected after changing the user local
    665044 [ETA 8.19.02] (LOCALIZATION)CMD: WLBS: Garbage is displayed after changing code page
    665426 [ETA 8.19.02] (LOCALIZATION)CMD: WLBS: Garbage is displayed after changing system local

*** 08.26.02 josephj
    696605 NLB Manager: User is allowed to wrongly install NLB on a DHCP NIC that is also the connection NIC to track this.
    Files under nlbmgr\exe2; Code reviewed by KarthicN; Tested by GJack

----------------------------------------------------------------------
*** 08.26.02 josephj
    Lab03_Dev RI
----------------------------------------------------------------------

*** 08.28.02, shouse
    Fixes and enhancements to NLBKD.

*** 08.28.02, shouse
    696895 NLB: (LOCALIZATION) String for wlbs filter help may be too long.

*** 08.29.02, josephj
    696524 josephj NLBMGR - Wrong startup error message "Unable to run NLB..."

----------------------------------------------------------------------------
*** 08.30.02, josephj
    DIRECT CHECKIN of the above fixes to LAB03_N
    (not an integrate). So at this point of time, both
    LAB03_N and the private branch have the same copy,
    BUT LAB03_DEV is not synched up yet -- that should happen at the 
    next RI between LAB03_N and LAB03_DEV
----------------------------------------------------------------------------

----------------------------------------------------------------------------
*** 09.11.02 chrisdar
699613 STRESS: 3676 VBL4.020829-2210:Critical Section Timeout
649452 (LOCALIZATION) NLBMGR: Events are not saved to the event log file

    DIRECT CHECKIN to lab03_n. Already checked into the private branch.
----------------------------------------------------------------------------

*** 09.11.02, shouse
    637925 RC1RelNote: ITGRC1: JDPRC1BLCK: ISA: NLB: Connection state maintenance using notifications from TCP/IP stack is broken when IP NAT editor is present

----------------------------------------------------------------------
*** 09.12.02, shouse
    Lab03_N RI
----------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\notes.txt ===
12.05.01 chrisdar
    BUG 499552 NLB: Ensure that adapter bouncing decision is consistent in wlbsctrl.dll and netcfgx.dll

    Added check in ParamWriteConfig to determine whether VIP changed. If so, need to bounce the adapter.
    Flag that controlled whether or not to bounce adapter was called *_mac_addr_change. Since changing
    VIP could trigger this, changed name of flag to *_notify_adapter_required.

07.19.02 chrisdar
    661678 NLB: May need to start cancelling NotifyAddrChange requests in api\notification.cpp

    While testing fix, I wrote a test program to randomly execute notifcation api calls simultaneously
    in multiple threads. The APIs invoked are those exposed by wlbsctrl.dll that are used by the ipsec
    team to tell NLB of session up/down. This test app runs without failure in a steady state
    environment in which no changes are being made to the IP addresses. (See
    %SDXROOT%\nt\net\wlbs\api\test\notify\MThread)

    While testing the API calls and doing add/remove to the Tcp/ip address table I frequently see one
    error per IP address change. No errors were seen while updating an existing entry in the Tcp/ip
    address table.

    Two classes of error have been seen thus far, though this may be limited by coincidental timing of
    the invoked API with the change to Tcp/ip:
    1. BuildIPToGUIDMap map fails with ERROR_BUFFER_OVERFLOW. This function uses
       GetAdaptersInfo to determine the IP addresses configured on the host. An initial call is made
       with this API to determine the size of the buffer needed to hold this information. Then a
       second call is made after allocating a buffer of the needed size. The problem is that a network
       property change between the first and second calls could change the memory allocation
       requirements. This is where and how we failed.

    2. A call to CancelIPChangeNotify fails with ERROR_INVALID_PARAMETER. At this point I don't know
       why this call would be failing. Previously, this error was seen if we cancel a notification
       that was never registered, but that has been mitigated:

       The notification APIs in wlbsctrl.dll (including the one that cancels notifications) are
       written such that an initialize API function is not needed. The "notify" calls will take care
       of initialization if needed and set an "initialized" flag to prevent initialization on the
       next notify
       call. Thus when the flag is FALSE it indicates that no notification has yet been made. The
       cancel API call unwinds the initialization (setting the flag to false) and early
       exits if the initialized flag is not TRUE. This avoids doing an unnecessary cancel under normal
       conditions even if the caller doesn't keep track of whether it is needed. This behavior was
       initially added so I could invoke the notifify APIs in random order without inducing this
       error when canceling a notificatin that was never set. Once we started mucking with the IP
       address list, I began seeing this error again.The flag tracking initialization is protected
       by a critical section.

    ADDEDNDUM to 1.: I also see that for certain failures (such as this one) we don't call HeapFree
       for the memory we allocated. While looking into fixing this, we are apparently making more sdk
       calls than needed. The code first gets a list of adapters (GetAdaptersInfo) then a list of
       IPs (GetIpAddrTable). It traverses the IP table and uses an index in each entry that maps into
       an entry in the adapter table. From the adapter entry it gets the GUID and caches the IP, GUID
       combo. BUT, the output of GetAdaptersInfo has a linked list of IPs that it owns already, so
       the call to GetIpAddrTable isn't needed. Talk to Sean about this. Maybe this information isn't
       populated or it may be unreliable.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\tracewpp.ini ===
FUNC TRACE_CRIT{LEVEL=Critical}(MSG,...);
FUNC TRACE_INFO{LEVEL=Informational}(MSG,...);
FUNC TRACE_VERB{LEVEL=Verbose}(MSG,...);
FUNC TRACE_FULL{LEVEL=Full}(MSG,...);
FUNC TRACE_HB{LEVEL=Heartbeats}(MSG,...);
FUNC TRACE_TCPCTRL{LEVEL=TcpControl}(MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\notes.txt ===
12/11/00 JosephJ Fix for #23727
    23727   wlbs drain all command should return an error message
    if no port rules exist.

    The problem (if you can call it that) is that if there are NO user-specified
    port rules, we treat port-specific operations directed to "ALL" ports as
    successful. These commands are start,stop, drain and set (adjust weights).
    Fix is for Load_port_change to return IOCTL_CVY_NOT_FOUND in this case.
    Note that  Load_port_change does some special casing for
    IOCTL_CVY_CLUSTER_DRAIN and IOCTL_CVY_CLUSTER_PLUG -- it includes
    the default port rule.

07.17.01 shouse
    Due to a change in user-space where we no longer disable and re-enable the
    adapter when the MAC address changes, the ded_mac_addr will now ALWAYS be
    the burnt-in MAC address of the adapter, whereas it has been the NLB 02-bf
    MAC address because by the time NLB bound to the adapter, it had already
    picked up the new MAC address.  Now, that is no longer the case, which 
    should not be a problem because all indications are that this was the way
    that it was in win2k until we started disabling/enabling the adapters in 
    SP 1.  However, an alignment issue resulted in a bug fix that appears to
    rely on the fact that in unicast mode, the ded_mac_addr is the cl_mac_addr.
    This fix was a hack, and doesn't seem to have really been thought out
    anyway, because the code added was guaranteed to always be a no-op; it
    amounted to "if (foo == 2) { foo = 2; }.  Anyway, this "fix" was also
    only applied in one of three places the exact same code resisded, so the
    fixed "fix" has also been propagated to all three places.  The fix involves
    spoofing source MAC addresses in unicast mode to prevent network switches
    from learning the cluster MAC address.  Rather than simply casting a 
    pointer to a PULONG and dereferencing it to set a ULONG, which may cause
    an alignment fault, we set each byte of the ULONG individually to avoid 
    the alignment issue.

10.21.01 shouse
    Amendment to the above statement concerning the dedicated MAC address.  It 
    appears that since sending a property change notification to the NIC results
    in NDIS tearing down and rebuilding all bindings, by the time the adapter
    is back up and running and NLB queries for the dedicated MAC address, the 
    adapter will have already picked up the 02-bf MAC address, so the statement
    that the dedicated MAC address would now be the burnt-in MAC is not entirely
    accurate.

10.21.01 shouse
    Some lingering issues and their resolutions from a conversation with Bill Bain:

    Dirty connections:  The real question has been, "Why the seemingly arbitrary
    five minute timeout?"  Well, it turns out that the value is not arbitrary, 
    but rather was measured and based on empirical evidence.  If a large number
    of connections were left dagling by NLB when a "stop" was performed, this
    would result in a reset "storm" if the host was quickly added back into the
    cluster.  It was observed that if NLB could block this traffic to the host
    with the stale data, NLB could _significantly_ reduce the reset problems.  So,
    while its true that this five minutes is no silver bullet, it was based on 
    real measurable data available and solved the problem for a significant 
    number of the stale connections.

    PPTP:  Of course, PPTP was supposed to be supported in Windows 2000, but a 
    cursory look at the source code shows that tracking the calls, which are 
    GRE packets, did NOT work in Windows 2000.  GRE packets were supposed to be
    treated like TCP data packets on the PPTP tunnel (TCP connection), and since
    no port numbers from the PPTP tunnel are recoverable in a GRE packet, NLB 
    hard-coded the source and destination ports to zero and 1723, respectively.
    the 1723 corresponds to the server port number of the PPTP tunnel and the zero
    is arbitrary and as good a choice for a source port as any.  So, GRE packets
    would be hashed the same as the TCP tunnel in single affinity, sticking the 
    GRE traffic to the correct host.  However, when ambiguity arose (unoptimized
    mode), GRE packets were looking for a descriptor with a source port of zero
    and a destination port of 1723.  Because the tunnel was established with the
    ephemoral port assigned by TCP on the client machine, no descriptor would 
    EVER be found, and the packets were discarded.  What was _intended_ was to 
    create the descriptor for the PPTP tunnel using the same hard-coded source
    port of zero.  In that case, GRE packets would find a matching descriptor 
    when necessary.  This was the small piece of logic missing in Windows 2000, 
    which will be added in an upcoming service pack.  However, this fix eliminates 
    any method by which NLB could distinguish multiple PPTP tunnels from the same 
    client IP address (since the client ports are masked).  So, a limitation of
    this implementation is that clients may NOT establish multiple tunnels (which
    they won't by default) and clients from behind a NAT are not supported, as 
    multiple clients from behind a NAT would look like the same client to NLB,
    differentiated only by source port, which NLB cannot distinguish.

    Fragmentation:  NLB has had an "optimized" fragmentation mode in it that 
    didn't seem to make sense.  The problem is that subsequent packets in a 
    fragmented segment will not have the TCP/UDP ports, which NLB needs in order
    to properly filter them.  The "unoptimized" mode said that if the packet in
    question was the first packet of a fragment, then NLB can get to the port 
    numbers, so it will be treated normally and passed up only on the correct host.
    Subsequent packets in the fragmented segment will not have the port numbers,
    so NLB would pass them up on _all_ hosts in the cluster.  The IP layer would 
    simply drop the fragments on the hosts that did not pass up the first packet
    in the fragmented segment.  So, other than a bit of extra stress on the IP
    layer in the stack, this method should be guaranteed to work.  The "optimized"
    mode was a method by which to let NLB do the filtering in the limited cases
    that it could.  Basically, this mode asserted that if you have a single port
    rule that covers all ports (0-65535), then the server port is essentially 
    irrelevent - you'd lookup the same port rule regardless of what the port
    actually was.  Further, if that port rule was configured in single affinity,
    then the client port was also irrelevent - its not used in the hashing 
    algorithm.  If the cluster is configured as such (which happens to be the 
    default), then NLB need not know the actual source ports to pass the packet
    up ONLY on the correct host.  Well, that is almost correct.  It is true that
    the client and server ports then become irrelevent insofar as port rule 
    lookup and hashing, but they ARE needed for descriptor lookup - if we're 
    hoping to find a matching connection descriptor in order to know which host
    owns a particular connection, we need to know the _actual_ client and server
    ports to match a descriptor.  So, this "optimized" mode doesn't really work
    after all.  However, as it turns out, in Windows 2000, where it was introduced,
    it DID actually work.  That's assuming that you discount TCP, through which
    fragmentation is _highly_ discouraged by setting maximum segment sizes 
    appropriately, then for UDP/GRE/IPSEC it DID work because those protocols did
    not utilize descriptors at all - their ownership was based solely on who 
    currently owned the bucket to which the packet mapped.  So, its a bit muddled,
    but did "work" in Windows 2000.  In .Net server however, this "optimized" mode
    has been removed because it no longer works.  This is because some UDP traffic,
    namely IPSec (port 500) is now tracked through the use of descriptors.  This
    failure was actually found through IPSec testing in which the initial fragment
    went up on the correct server, but the subsequent fragment went up on the 
    _wrong_ server (not all servers, as it would have in "unoptimized" mode).  GRE
    and IPSec protocol traffic use hard-coded ports in connection tracking, so they
    continue to be ambivolent to fragments.

12.05.01 chrisdar
    BUG 482284 NLB: stores its private state in wrong Ndis packet causes break
    during standby

    When there is no packet stack available in an NDIS packet for NLB to store
    information, NLB needs to allocate an NDIS packet for its own use, copy the
    information from the original packet into it, then deallocate it when we are
    finished using it. One place where this happens is in a rarely executed code
    path of Prot_recv_indicate. The bug was that in this code path, we subsequently
    used the original packet and tried to access packet stack that wasn't available.
    The packet we allocated to get packet stack wasn't used. The fix is to use the
    allocated packet instead of the original.

    While testing a private fix in the lab, I also made temporary changes to force
    Prot_recv_indicate to use this code path for every received non-remote control
    packet.

1.21.02, shouse
    Note: Due to recent changes in the GRE virtual descriptor tracking mechanism in
    the driver, SINGLE affinity is now REQUIRED for PPTP.  In general, single affinity
    has always be "required" for VPN, but until this change was made, no affinity 
    would still have basically worked for PPTP.  No affinity WILL STILL WORK for IPsec,
    but only helps in the case that clients come from behind a NAT device; if they do 
    not come from behind a NAT, the source and destination ports are ALWAYS UDP 500 
    anyway, which defeats any advantage no affinity might provide.

    Why did no affinity previously work for PPTP?

    When a PPTP tunnel is created, NLB hashes the TCP control tunnel just like any 
    other TCP connection.  If the affinity is set to none, then it uses the TCP port 
    numbers during the hashing process.  If the host owns the bucket to which the 
    TCP SYN hashes, it accepts the connection and creates state to track the PPTP
    tunnel.  When a PPTP tunnel is accepted, it is also necessary to create a virtual
    GRE descriptor to track the GRE call data for this tunnel.  When this descriptor 
    is created, since no ports exist in the GRE protocol, it used the hard-coded ports
    of 0 (source) and 1723 (destination).  Since GRE is treated like TCP for the 
    purposes of port rule lookup and state maintenance, the GRE state creation in the
    load module would certainly find the same port rule that the PPTP tunnel did; TCP 
    1723.  However, if no affinity is set, it will NOT derive the same hashing result 
    that the PPTP tunnel did because the source (client) ports are different; an 
    arbitrary port number in the PPTP SYN packet and a hardcoded port number of 0 in 
    the GRE "virtual connection".  Therefore, the load module would end up "injecting" 
    a descriptor into a port rule and "bucket" that it MIGHT NOT EVEN OWN (because bucket
    ownership is not considered when creating these virtual descriptors that correspond
    to a real connection being serviced by a host.  In general, that's fine and by
    the next heartbeat, the host that DOES own that bucket will notice and stop blindly
    accepting traffic that hashes to that bucket (it moves in non-optimized mode).  So, 
    while it SHOULD work in no affinity, this runs the risk of unnecessarily shifting 
    the cluster into non-optimized mode because hosts that are not the bucket owners 
    may handle connections on those buckets.

    Why won't no affinity work any more?

    Basically, because the second hash performed on the GRE "connection" has been removed.
    Up-going PPTP tunnels used to require at least 3, and as many as 4, calls to the NLB
    hash function.  Because the hash function is a LARGE portion of the NLB overhead, this
    is non-optimal, and, as it happens, unnecessary.  By moving the virtual descriptor
    and descriptor cleanup intelligence from main.c to load.c, these multiple calls to the
    hash function were eliminated.  A single hash is now performed on all packets.  However,
    when GRE virtual descriptors are created now, they use the hash value already computed
    as part of the PPTP TCP SYN processing.  This is a better solution, as it ensures that
    both the PPTP TCP tunnel and the GRE virtual "connection" both belong to the same bucket,
    and therefore the same host.  This prevents us from unnecessarily putting the cluster
    into a non-optimized state.  However, when GRE data packets do arrive and need to hash
    and perform a state lookup, there is no way that it can regenerate the same hash value
    that was computed by the PPTP TCP tunnel setup if the affinity is set to none.  That,
    of course, is because the TCP source port of the PPTP tunnel is not recoverable from the
    GRE packets.  Therefore, to ensure that GRE packet lookup can re-calculate the necessary
    hash value, single affinity is REQUIRED.

02/14/2002 JosephJ Location of fake ndis usermode code...
\\winsefre\nt5src\private\ntos\tdi\tcpipmerge\1394\arp1394\tests

04/15/2002 JosephJ To temporarily build the um ndis stuff (needs cleaning up)
    #ifdef TESTPROGRAM
    #include "rmtest.h"
    #define KERNEL_MODE
    #else
    #include <ndis.h>
    /* For querying TCP about the state of a TCP connection. */
    #include "ntddtcp.h"
    #include "ntddip.h"
    #endif // !TESTPROGRAM 

04/24/2002 JosephJ diplist: Added skeleton diplist code
    diplist.c, diplist.h
    Also added code under .\test to component test the diplist code.

04/24/2002 JosephJ diplist: Added the fast lookup functionality.

04/25/2002 JosephJ diplist: Changed internal constants to "production" values.
    #define MAX_ITEMS  32   // TODO: replace by appropriate CVY constant.
    #define HASH1_SIZE 257  // size (in bits) of bit-vector (make it a prime)
    #define HASH2_SIZE 59   // size of hashtable            (make it a prime) 

08.16.02, shouse
    The driver no longer fills in the pg_rsvd array in the heartbeat because it was 
    discovered that it routinely produces a Wake On LAN pattern in the heartbeat that 
    causes BroadCom NICs to panic.  Although this is NOT an NLB issue, but rather a 
    firmware issue in BroadCom NICs, it was decided to remove the information from the 
    heartbeat to alleviate the problem for customers with BroadCom NICs upgrading to 
    .NET.  This array is UNUSED by NLB, so there is no harm in not filling it in; it 
    was added a long time ago for debugging purposes as part of the now-defunct FIN-
    counting fix that was part of Win2k SP1.
    
    For future reference, should we need to use this space in the heartbeat at some
    future point in time, it appears that we will need to be careful to avoid potential
    WOL patterns in our heartbeats where we can avoid it.  A WOL pattern is:
    
    6 bytes of 0xFF, followed by 16 idential instances of a "MAC address" that can
    appear ANYWHERE in ANY frame type, including our very own NLB heartbeats.  E.g.:
    
    FF FF FF FF FF FF 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06
    01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06
    01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06
    01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06
    01 02 03 04 05 06
    
    The MAC address need not be valid, however.  In NLB heartbeats, the "MAC address"
    in the mistaken WOL pattern is "00 00 00 00 00 00".  NLB routinely fills heartbeats
    with FF and 00 bytes, but it seems that by "luck" no other place in the heartbeat
    seems this vulnerable.  For instance, in the load_amt array, each entry has a 
    maximum value of 100 (decimal), so there is no possibility of generating the initial
    6 bytes of FF to start the WOL pattern.  All of the "map" arrays seem to be saved
    by two strokes of fortune; (i) little endian and (ii) the bin distribution algorithm.
     
    (i) Since we don't use the 4 most significant bits of the ULONGLONGs used to store 
    each map, the most significant bit is NEVER FF.  Because Intel is little endian, the
    most significant byte appears last.  For example:
     
    0F FF FF FF FF FF FF FF appears in the packet as FF FF FF FF FF FF 0F
     
    This breaks the FF sequence in many scenarios.
    
    (ii) The way the bin distribution algorithm distributes buckets to hosts seems to 
    discourage other possibilities.  For instance, a current map of:
     
    00 FF FF FF FF FF FF 00 
     
    just isn't likely.  However, it IS STILL POSSIBLE!  So, it is important to note that:
     
    REMOVING THIS LINE OF CODE DOES NOT, IN ANY WAY, GUARANTEE THAT AN NLB HEARTBEAT
    CANNOT STILL CONTAIN A VALID WAKE ON LAN PATTERN SOMEWHERE ELSE IN THE FRAME!!!
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\tracewpp.ini ===
FUNC TRACE_CRIT{LEVEL=Critical}(MSG,...);
FUNC TRACE_INFO{LEVEL=Informational}(MSG,...);
FUNC TRACE_VERB{LEVEL=Verbose}(MSG,...);
FUNC TRACE_FULL{LEVEL=Full}(MSG,...);
FUNC TRACE_HB{LEVEL=Heartbeats}(MSG,...);
FUNC TRACE_PACKET{LEVEL=AllPackets}(MSG,...);
FUNC TRACE_FILTER{LEVEL=Filtering}(MSG,...);
FUNC TRACE_CONVERGENCE{LEVEL=Convergence}(MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\installpack\dlg.txt ===
"NLB Install Pack"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\installpack\list.txt ===
NLBWizard.exe,Network Load Balancing Install Pack,http://www.microsoft.com
NLBUninst.exe,Network Load Balancing Uninstall Pack,http://www.microsoft.com
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\installpack\readme.txt ===
This install pack is for NLB installation on Windows 2000 Server only.
The NLB bits are expected to be previously installed on the machine,
via either SP1 + the NLB hotfix or SP2 - this install pack does not
place them there.

Two executables are generated; NLBWizard.exe (which is to be used in the
Install Pack) and uninstall.exe (for uninstalling NLB and removing the
netwlbs.inf file).

In case of changes to the install pack, first generate the NLBWizard.exe
and uninstall.exe and get them signed by prslab code signing tool as a
generic Microsoft Windows Component.

http://prslab/codesign

Create a new request and follow the on-line instructions.

Job Description: Generic Microsoft Windows Component
Virus Checker: Probably Innoculan
Macro Virus Check: No
Operating System: 32-Bit Windows
Language: English
Certificate Type: Microsoft External Code Distribution
Virus Checker Engine Version: Probably 19.00
Encryption: Not High Crypto
Product Version: 1.0

List.txt must be copied into the directory containing the binaries to 
be signed.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\cfgutillib\tracewpp.ini ===
FUNC TRACE_CRIT{LEVEL=Critical}(MSG,...);
FUNC TRACE_INFO{LEVEL=Informational}(MSG,...);
FUNC TRACE_VERB{LEVEL=Verbose}(MSG,...);
FUNC TRACE_FULL{LEVEL=Full}(MSG,...);
FUNC TRACE_HB{LEVEL=Heartbeats}(MSG,...);
FUNC TRACE_TCPCTRL{LEVEL=TcpControl}(MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\notes.txt ===
3/17/01 JosephJ Stuff to do
    1. Define interfaces for async error reporting.

0. Make ConfigureAndBind take an out parameter which is a generation number.

Sequence of steps:
1. Check for connectivity using ping
2. Do WMI operation
3. Verify result


1 hour: review code, make notes.
Operation: Connect To Existing
    LeftView::OnWorldConnect 
         ClusterConnectPage::ClusterConnectPage
            CommonNLB::connectToClusterIndirect
                MNLBMachine::getClusterProperties
                    MwmiObject::getSpecificInstance
                        WMI core APIs


List of classes

LeftView.h (exe):class LeftView : public CTreeView, public DataSinkI
LeftView.cpp (exe):LeftView::LeftView()
LeftView.cpp (exe):LeftView::~LeftView()
LeftView.cpp (exe):LeftView::GetDocument()
LeftView.cpp (exe):LeftView::OnInitialUpdate()
LeftView.cpp (exe):LeftView::OnRButtonDown( UINT nFlags, CPoint point )
LeftView.cpp (exe):LeftView::OnWorldConnect()
LeftView.cpp (exe):LeftView::OnWorldNewCluster()
LeftView.cpp (exe):LeftView::OnClusterProperties()
LeftView.cpp (exe):LeftView::OnClusterManageVIPS()
LeftView.cpp (exe):LeftView::OnHostProperties()
LeftView.cpp (exe):LeftView::OnClusterRemove()
LeftView.cpp (exe):LeftView::OnClusterUnmanage()
LeftView.cpp (exe):LeftView::OnClusterAddHost()
LeftView.cpp (exe):LeftView::OnHostRemove()
LeftView.cpp (exe):LeftView::OnClusterControl( UINT nID )
LeftView.cpp (exe):LeftView::OnClusterPortControl( UINT nID )
LeftView.cpp (exe):LeftView::OnHostControl( UINT nID )
LeftView.cpp (exe):LeftView::OnHostPortControl( UINT nID )
LeftView.cpp (exe):LeftView::dataSink( _bstr_t data )
LeftView.cpp (exe):LeftView::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
LeftView.cpp (exe):LeftView::doesClusterExistInView( const _bstr_t& clusterToCheck )




JosephJ 3/21/01
Search MSDN for "Idle Loop Processing" -- there is code there for
adding MFC-compatible message processing while doing blocking operations.

JosephJ 3/24/01  using namespace std, vectors.

To use the <vector> template as is you need the statement:
        using namespace std;

JosephJ 5/19/01 Code paths for main operations

1. Create New Cluster
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\cfgutillib\notes.txt ===
08/07/2001  JosephJ ToDo
0. Switch to using lower-level wlbsctrl calls.
1. Load-library the necessary wlbsctrl calls -- get rid from link to wlbsctrl.


08/08/2001  JosephJ Current list of calls to wlbs...
    // CWlbsControl            *m_pWlbsControl;
    // CWlbsCluster **ppCluster

09/10/2001  JosephJ Include wlbsutil.lib (wlbs\inc\wlbsutil.h)
    This is JUST (what a shame) to include the IpAddressAbcdFromWsz function.
    And this is JUST to allow us to get/set from WLBS_REG_PARAM when
    wlbsctrl.dll can't be dynamically loaded (typically because it's not
    present). Consider cleanup of this.

01/28/2002 JosephJ implementing CfgUtilSetDHCP

    No input parameters.
    Returnvalue of 0  implies success.
{
    // do basic verification.
    //
    // ensure that machine specified exists.
    vector<MWmiInstance>      nicInstance;
    checkStatus( &nicInstance );

    bool dhcpEnabled;
    isDHCPEnabled( dhcpEnabled );
    if( dhcpEnabled == true )
    {
        // dhcp is already enabled.
        return MIPAddressAdmin_SUCCESS;
    }

    // set input parameters.
    // no input parameters.
    vector<MWmiParameter *> inputParameters;

    // set output parameters
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );

    nicInstance[0].runMethod(L"EnableDHCP",
                             inputParameters,
                             outputParameters );

    if( long ( returnValue.getValue() ) == 0 )
    {
        return MIPAddressAdmin_SUCCESS;
    }
    else
    {
        cout << "enablestatic has return " << long( returnValue.getValue() ) << endl;
        return COM_FAILURE;
    }
}

05/08/2002 JosephJ Location of source code that implements 
             Win32_NetworkAdapterConfiguration  (IPAddress, EnableStatic, etc)
    admin\wmi\WBEM\Providers\Win32Provider\Providers\netadaptercfg.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\nlbmgr.ini ===
bp nlbmgr!FakeNlbHostConnect
bp nlbmgr!CNlbEngine::UnmanageHost
bd 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\nlbmgrissues.doc ===
Microsoft Word Document MSWordDoc Word.Document.8Microsoft Corporation TitleJoseph M. Joy Normal Joseph M. Joy Microsoft Word 10.0urn:schemas-microsoft-com:office:smarttags Minute Z|@X} 0J(57NLB Manager Issues JosephJ General comments on code organization Lots of instances of cut pasted duplicate code   for example the creation of cluster node in the treeview. References to details of cluster configurations (like port rules) scattered around the code. Massive use of non-trivial operations in constructors or implicitly in calls to dialog functions like DoModal. For example: LeftView::OnWorldConnectIndirect() ClusterData* p_clusterData = new ClusterData; ClusterConnectIndirectPage clusterConnect( p_clusterData, this ); _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING CPropertySheet tabbedDlg( tabbedDlgCaption ); tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW;  tabbedDlg.AddPage( &clusterConnect ); int rc = tabbedDlg.DoModal(); The DoModal above ends up attempting to connect to all the hosts in the cluster! Cluster view left pane pane displays unnecessary details: subnet-mask; MAC address; mode; Remote  We should get rid of these columns and instead  Left view: naming clusters: Change name from ip to domain-name(ip): eg: cluster.microsoft.com(10.0.0.1) Connect to host Current state: You get here through connect to existing, in which case you have to specify the cluster vip first. Add host to cluster  m getting an AV here. To do: fix AV Only choice in the connect-to-host dialog: machine IP. Can t cut paste ip address! To do: Allow arbitrary bind string. If you specify an incorrect IP, you wait and wait and wait! To do: Resolve machine first. Then ping machine, and allow user to retry ping. If you connect to a machine, but the cluster members  ip addresses are not reachable, you wait and wait To do: keep a database of hosts and the ip addresses they own. Each time you see a new dedicated/connection IP address, if you don t know the bind-string associated with that address, put up a ui. If you have a connection problem (resolve and ping first), also put up UI. The connection status window is hokey. I ve see that I press ok, see the following displayed in the dialog window: Connecting 157.59.142.143 Done  Finding host  But the dialog doesn t go away   probably because it encountered some error. To do: Get rid of connection-status window   Just make status display what we re currently doing, and also report to the log pane below (prefixed by HH:MM:SS eg: 04:45:05 Connecting to host xxxx of cluster xxxx 04:45:06  Could not ping host xxx Logging support Global log class, Has a method: Log(ID, display-flags, message, params) Display-type: Level: 1, 2, 3 (translate to indent and emphasis); Disposition: error, warning, informational (translate to color: red for errors, black-with yellow background for warnings, normal for informational). Optionally logs to a specified file. Managing Operations on Hosts We need a single and unique object for each physical host. We need to route all operations on that host to this object. This is for the following reasons: We keep connectivity information regarding a host in one place, regardless of how we get to that host (from multiple clusters, say) We don t attempt multiple operations to that host concurrently   say trying to connect to that host in the context of one cluster while we re attempting to manage it in the context of another cluster. Features: For simplicity, we don t allow concurrent operations on the same host, even if its for different clusters on that host. We keep connectivity information, and persist it. Supporting Ghost Clusters and Hosts A new cluster is a template (husk or ghost) until it s actually realized with one or more hosts. Likewise, a host node can also be a ghost until we ve connected to it successfully. So we need the concept of placeholders for both clusters and hosts in the cluster. The UI should handle this and we should be able to persist this. MipAddressAdmin AV  in MipAddressAdmin. MIPAddressAdmin::getIPAddresses. The code blindly assumes the result is an array, and access-violates if if s VT_NULL. Hit this AV. Todo: add error checking to this function.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\tracewpp.ini ===
FUNC TRACE_CRIT{LEVEL=Critical}(MSG,...);
FUNC TRACE_INFO{LEVEL=Informational}(MSG,...);
FUNC TRACE_VERB{LEVEL=Verbose}(MSG,...);
FUNC TRACE_FULL{LEVEL=Full}(MSG,...);
FUNC TRACE_HB{LEVEL=Heartbeats}(MSG,...);
FUNC TRACE_TCPCTRL{LEVEL=TcpControl}(MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\nlbclientlib\tracewpp.ini ===
FUNC TRACE_CRIT{LEVEL=Critical}(MSG,...);
FUNC TRACE_INFO{LEVEL=Informational}(MSG,...);
FUNC TRACE_VERB{LEVEL=Verbose}(MSG,...);
FUNC TRACE_FULL{LEVEL=Full}(MSG,...);
FUNC TRACE_HB{LEVEL=Heartbeats}(MSG,...);
FUNC TRACE_TCPCTRL{LEVEL=TcpControl}(MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\nlbclientlib\notes.txt ===
TODO

FakeNlbHostPing -- should fail appropriately if the connection string
doesn't resolve to a machine.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\tracewpp.ini ===
FUNC TRACE_CRIT{LEVEL=Critical}(MSG,...);
FUNC TRACE_INFO{LEVEL=Informational}(MSG,...);
FUNC TRACE_VERB{LEVEL=Verbose}(MSG,...);
FUNC TRACE_FULL{LEVEL=Full}(MSG,...);
FUNC TRACE_HB{LEVEL=Heartbeats}(MSG,...);
FUNC TRACE_TCPCTRL{LEVEL=TcpControl}(MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\sqlwmisample.txt ===
FROM: nt\base\cluster\mgmt\cluscfg\server\cenumcluscfgipaddresses.cpp

HRESULT
CEnumClusCfgIPAddresses::HrGetAdapterConfiguration(
    IWbemClassObject * pNetworkAdapterIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    BSTR                    bstrQuery = NULL;
    BSTR                    bstrWQL = NULL;
    VARIANT                 var;
    WCHAR                   sz[ 256 ];
    IEnumWbemClassObject *  pConfigurations = NULL;
    ULONG                   ulReturned;
    IWbemClassObject *      pConfiguration = NULL;
    int                     cFound = 0;
    BSTR                    bstrAdapterName = NULL;
    int                     idx;

    VariantInit( &var );

    bstrWQL = TraceSysAllocString( L"WQL" );
    if ( bstrWQL == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"DeviceID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    _snwprintf( sz, ARRAYSIZE( sz ), L"Associators of {Win32_NetworkAdapter.DeviceID='%s'} where AssocClass=Win32_NetworkAdapterSetting", var.bstrVal );

    bstrQuery = TraceSysAllocString( sz );
    if ( bstrQuery == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantClear( &var );

    hr = THR( HrGetWMIProperty( pNetworkAdapterIn, L"NetConnectionID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    bstrAdapterName = TraceSysAllocString( var.bstrVal );
    if ( bstrAdapterName == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( m_pIWbemServices->ExecQuery( bstrWQL, bstrQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &pConfigurations ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_STRING(
                TASKID_Major_Find_Devices,
                TASKID_Minor_WMI_NetworkAdapterSetting_Qry_Failed,
                IDS_ERROR_WMI_NETWORKADAPTERSETTINGS_QRY_FAILED,
                bstrAdapterName,
                hr
                );
        goto Cleanup;
    } // if:

    for ( idx = 0; ; idx++ )
    {
        hr = pConfigurations->Next( WBEM_INFINITE, 1, &pConfiguration, &ulReturned );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            //
            //  KB: 25-AUG-2000 GalenB
            //
            //  WMI only supports one configuration per adapter!
            //
            Assert( idx < 1 );

            VariantClear( &var );

            hr = THR( HrGetWMIProperty( pConfiguration, L"IPEnabled", VT_BOOL, &var ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  If this configuration is not for TCP/IP then skip it.
            //
            if ( ( var.vt != VT_BOOL ) || ( var.boolVal != VARIANT_TRUE ) )
            {
                hr = S_FALSE;
                STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_Non_Tcp_Config, IDS_WARNING__NON_TCP_CONFIG, bstrAdapterName, hr );
                continue;
            } // if:

            hr = STHR( HrSaveIPAddresses( bstrAdapterName, pConfiguration ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  KB: 24-AUG-2000 GalenB
            //
            //  If any configuration returns S_FALSE then we skip.
            //
            if ( hr == S_FALSE )
            {
                pConfiguration->Release();
                pConfiguration = NULL;
                continue;
            } // if:

            cFound++;
            pConfiguration->Release();
            pConfiguration = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_WQL_Qry_Next_Failed, IDS_ERROR_WQL_QRY_NEXT_FAILED, bstrQuery, hr );
            goto Cleanup;
        } // else:
    } // for:

    //
    //  If we didn't find any valid configurations then we should return S_FALSE
    //  to tell the caller to ingore that adpater.
    //
    if ( cFound == 0 )
    {
        hr = S_FALSE;
        STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_No_Valid_TCP_Configs, IDS_WARNING_NO_VALID_TCP_CONFIGS, bstrAdapterName, hr );
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetAdapterConfiguration, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    VariantClear( &var );

    TraceSysFreeString( bstrQuery );
    TraceSysFreeString( bstrWQL );
    TraceSysFreeString( bstrAdapterName );

    if ( pConfiguration != NULL )
    {
        pConfiguration->Release();
    } // if:

    if ( pConfigurations != NULL )
    {
        pConfigurations->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumClusCfgIPAddresses::HrGetAdapterConfiguration
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\tests\tracewpp.ini ===
FUNC TRACE_CRIT{LEVEL=Critical}(MSG,...);
FUNC TRACE_INFO{LEVEL=Informational}(MSG,...);
FUNC TRACE_VERB{LEVEL=Verbose}(MSG,...);
FUNC TRACE_FULL{LEVEL=Full}(MSG,...);
FUNC TRACE_HB{LEVEL=Heartbeats}(MSG,...);
FUNC TRACE_TCPCTRL{LEVEL=TcpControl}(MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\notes.txt ===
TODO LIST

    1. Get code to compile with strsafe macros.
    2. Run buffy and do any needed cleanup.
    3. Proper return values on not-found case.


09/09/01 JosephJ LoadLibrary failed because CNlbsNic was initialized as static.
    ERROR_NOACCESS, etc, etc...
    
    Turns out that CNlbsNic is a static ("CNlbsNic MyNlbsNicSet ...", in 
    nlbsnic.cpp). So we were calling .

    Plan:
    0. Remove non-trivial stuff from constructors of static objects.
    1. Identify stuff that *CAN* be run in the context of DLL_PROCESS_ATTACH,
       and call them.
    2. Create DynamicInitialize, DynamicDeinitialize methods, that
       contain non-trivial initializations

    CfgUtilsInitialize is non-trivial -- *must* be called in the
    context of DynamicInitialize.

    UpdateConfiguration::Initialize currently has InitializeCriticalSection --
     so should be part of static-init (PROCESS ATTACH) but it currently
    also calls CfgUtilsInitialize -- this should be removed.

    WPP_INIT -- can be called in the context of DLL_PROCESS_ATTACH?

09/23/2001 JosephJ Managing remote control passwords.

    Bug: 326514
    NlbManager: Allow user to modify remote control password; report password
    mismatches across hosts
    We can not provide a way to read the remote control password in plain text
     -- because the password is not saved in a recoverable manner
     -- it is hashed to a dword before saving to the registry.
    See WlbsSetRemotePassword implementation:
        reg_data -> i_rct_password = License_wstring_encode ((WCHAR*)password);
    
    NLBMPROV.DLL can support setting this hashed version of the password.
    From a security perspective, Wlbsdisplay displays it, afterall, and one can
    easily find the has value that corresponds to a plain-text version by
    setting up a bogus cluster and looking in the registry).
    
    We can then report to the nlbmgr user when the passwords do not match.
    When adding a new host we simply set the hashed-version in the properties.
    
    To avoid having to have the nlbmgr code include the plain-to-hashing
    functionality (currently it lives in wlbs\api\license.c), NLBMPROV will
    also support a plain text password. This field is set when the nlbmgr user
    changes the password.

09/23/2001  JosephJ New WMI Methods!

    RegisterManagementApplication(
        IN  szGUID,         // globally and uniquely identifies the application
        IN  szApplication,  // "Application Center", "ISA", etc.
        IN  szCompany,      // "Microsoft Corp.", etc.
        OUT dwRet           // ok, error-existing, other error
        OUT szExistingApplication,
        OUT szExistingCompany,
        );

        If the function fails because of error-existing, the out params will
        be filled out with the existing application name and company.
     
    UnregisterManagementApplication(
        IN  szGUID, // Application GUID
        OUT dwRet // -- ok, not-found
        );

    ControlCluster(
        IN   szAdapterGuid,         // GUID of adapter on which op is performed
        IN   szClusterIpAddress,    // OPTIONAL clustered IP address
        IN   szPort,                // OPTIONAL port
        IN   dwOperation,           // Operation: NOOP, START, STOP, etc.
        OUT  dwResult,              // success, fail, etc.
        OUT  dwCurrentState,        // State *after* initiating operation.
        OUT  dwHostMap              // Current host map.
        );
    
        ControlCluster is used to perform LOCAL operations on a specific
        adapter (specified by szAdapterGuid).

        ControlCluster can be used to query the current local operational state
        of the cluster -- this is done by specifying NOOP as the operation.

        The operation can be targeted at a specific cluster IP (relevant for
        per-port-rule cluster IPs) and at a specific port rule.

09/28/2001  JosephJ  HostingModel = "NetworkServiceHost" hassles.
    
    Gary and I have spent the last few hours getting to the bottom of
    this problem, with debug ndis, netcfg, ndis and netcfg tracing and whatnot.
    
    It finally turns out that this problem is a problem of nlbmprov run in
    NetworkServiceHost as opposed to LocalHost! It was failing further on than
    before (before Karthics  SetThreadToken fix), but failing nevertherless.
    
    So we went back to using LocalHost (and not calling ImpersonateClient) and
    things work perfectly  we tried with both tprov and nlbmgr2.exe.

    To enable the NetworkService code ...
    - Uncomment the following line in nlbmprov.mof:
      // HostingModel = "NetworkServiceHost"; 
    - Uncomment the following line in private.h
      // #define NLB_USE_NETWORK_HOST 1

    TODO: take our time and fix this once and for all (and test thoroughly,
    using tprov.exe), and if there are probles, back out of it and instead
    get out provider audited by the security folks.

    10/02/01 JosephJ update ...

    Even with properly signed netcfgx.dll, setupapi.log reports the following
    with networkservicehost enabled:
        #E358 An unsigned or incorrectly signed file
         "E:\WINDOWS\System32\NetCfgx.dll" for driver
         "Network Load Balancing Filter Device" blocked (server install).
         Error 5: Access is denied.
        Windows could not load the installer for Net. Contact your hardware
        vendor for a ssistance. Error 5: Access is denied.

    Traceformat output for the same showed:
        [0]0CE0.04F0::10/02/2001-16:26:40.425 [api]->WlbsOpen
        [0]0CE0.04F0::10/02/2001-16:26:40.425 [api]WlbsOpen creating handle
                    to the device object failed with 2

    So it looks like the bind was improperly completing due to the above
    setupapi error, resulting in wlbs.sys not being loaded, so the
    subsequent call to WlbsOpen filed.

    params.cpp:wlbsctrl!WlbsSetRemotePassword
        does work with NULL password -- sets to default.

netcfgconfig.cpp:
    CNetcfgCluster::InitializeWithDefault
        time_t cur_time;
        m_CurrentConfig.install_date = time(& cur_time);


10/15/2001  JosephJ Changes of this checkin:
    - Got rid of obsolete code for handling instances (mof change)
    - Add support for AddDedicatedIp, AddClusterIps
    - Implemented support for Read/Write HashedRemoteControlPassword
    - fix for bug  480120 nlb:cluster converged when duplicate host ID exist
    - If there are no ip addresses we put in an "autonet like" address.
    - Cluster is set in the suspended state, not stopped state, before
      major operations.
    - Moved "analyze" functionality to cfgutillib
    - Re-implemented analyze functionality default behaviour to keep old
      Ip addresses if possible.
    - If there is a mode change we do NOT add back the cluster IP addresses
      (so there's less chance of an ip address conflict).

12/7/2001 ChrisDar
	457437 NLBManager: Add NT event logging to the wmi provider
	To add event logging do the following:
	- Create a log_msgs.mc file which will contain the text for the events.
	  Reserve some message ID space since many components use the 'WLBS' source
	  for logging. Tdit the comments in each of these files to update the
	  range of IDs reserved for this binary.
	- Create a .rc resource file if you don't have one (e,g,. nlbmprov.rc). Every
	  component has a version.rc already. Build will freak out if you add more
	  than one .rc file to the list of sources. So, the new .rc is a container
	  for other resource files. Add lines to #include version.rc and log_msgs.rc,
	  and any other .rc files you have. Note that log_msgs.rc will be built
	  automatically from log_msgs.mc.
  	- Edit the sources file, adding log_msgs.mc and the .rc to the SOURCES list.
	  Remove all other .rc files from the SOURCES list.
	- Edit nt\net\config\netcfg\inf\netwlbsm.inx and add the name of the binary
	  that will contain these event messages (nlbmprov.dll in this case) to
	  'EventMessageFile' in the section [WLBSMP.AddEventLog.AddReg]
	- API calls for writing NT events
        * RegisterEventSource opens the event log and returns a handle for
		  writing to the log.
        * ReportEvent logs and event to the log. This requires the handle to the
		  event.
        * DeregisterEventSource closes the event log. Pass the handle from the
		  RegisterEventSource call.

template to flag code-review TODOs:
    2/13/02 JosephJ SECURITY BUGBUG:

02/27/2002 JosephJ: Cleaning up properly on exit...
    Currently nlbmprov.dll doesn't cleanup properly -- it tries to clean up
    on dll-detach and on execution of the destructor of static object
    NlbConfigurationUpdate. This causes the global crit section
    NlbConfigurationUpdate::s_Crit to be entered
    (in the context of  CNlbsNic::~CNlbsNic) AFTER it is deleted
    (in the context of DllMain). The following call trees illustrates
    this:
    
        DllMain
            PROCESS_DETATCH: NlbConfigurationUpdate::StaticDeinitialize
                DeleteCriticalSection
    
        (happens later)... 
        CNlbsNic::~CNlbsNic
            CNlbsNic::mfn_DelayedDeinitialize();
                NlbConfigurationUpdate::PrepareForDeinitialization();
                NlbConfigurationUpdate::sfn_Lock
                    EnterCriticalSection (AVs, because it's been deinitialized).

    Fix:
        Do non-trivial cleanup in the context of DlLCanUnloadNow.
        Move static init/deinit to one place -- probabaly to
        CNlbsNic's contsructor/distructor -- only thing it does should
        be to Delete critical sections, really.

    DllCanUnloadNow -- should check if there are pending operations, and fail
    if there are any. If there are NO pending operations, it should
    block new ones.

    Note: turns out we can get called to exec methods even after returning
    true to DllCanUnloadNow, so we don't block new ones. We rely on WMI 
    making sure that it doesn't call us to exec methods between the last
    call to DllCanUnloadNow and actually unloading the DLL.

03/25/2002  Checked in fixes for ...
    1. Fix registry handle leak.
    2. Fix deinitialization problem that avrf catches -- fold in
        the CanUnloadNow mechanism.
        Now the static denitialization functions are called from 
        the CNlbsNic destructor. The "delayed-deinitialize" function
        is called from DLL-detach notifier, which is called BEFORE
        the static destructor.


strcpy: StringCbCopy(LPTSTR pszDest, size_t cbDest, LPCTSTR pszSrc);
        StringCchCopy(LPTSTR pszDest, size_t cchDest, LPCTSTR pszSrc);

strcat: StringCchCat(LPTSTR pszDest, size_t cchDest, LPCTSTR pszSrc);
        StringCbCat(LPTSTR pszDest, size_t cbDest, LPCTSTR pszSrc);

wsprintf:
    StringCbPrintf(LPTSTR pszDest, size_t cbDest, LPCTSTR pszFormat, ...);

04/09/2002 JosephJ Code review results
updatecfg.cpp: CfgUtilsValidateNicGuid -- we check
    SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\"
    is there a better way? Could we be excluding NICS that are not yet
    bound to TCP.

04/09/2002 JosephJ  Code review notes
    Replace %08p by %p
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\tests\wbemcli.txt ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for wbemcli.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wbemcli_h__
#define __wbemcli_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef interface IWbemObjectAccess IWbemObjectAccess;
#endif 	/* __IWbemObjectAccess_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef interface IUnsecuredApartment IUnsecuredApartment;
#endif 	/* __IUnsecuredApartment_FWD_DEFINED__ */


#ifndef __IWbemStatusCodeText_FWD_DEFINED__
#define __IWbemStatusCodeText_FWD_DEFINED__
typedef interface IWbemStatusCodeText IWbemStatusCodeText;
#endif 	/* __IWbemStatusCodeText_FWD_DEFINED__ */


#ifndef __IWbemBackupRestore_FWD_DEFINED__
#define __IWbemBackupRestore_FWD_DEFINED__
typedef interface IWbemBackupRestore IWbemBackupRestore;
#endif 	/* __IWbemBackupRestore_FWD_DEFINED__ */


#ifndef __IWbemBackupRestoreEx_FWD_DEFINED__
#define __IWbemBackupRestoreEx_FWD_DEFINED__
typedef interface IWbemBackupRestoreEx IWbemBackupRestoreEx;
#endif 	/* __IWbemBackupRestoreEx_FWD_DEFINED__ */


#ifndef __IWbemRefresher_FWD_DEFINED__
#define __IWbemRefresher_FWD_DEFINED__
typedef interface IWbemRefresher IWbemRefresher;
#endif 	/* __IWbemRefresher_FWD_DEFINED__ */


#ifndef __IWbemHiPerfEnum_FWD_DEFINED__
#define __IWbemHiPerfEnum_FWD_DEFINED__
typedef interface IWbemHiPerfEnum IWbemHiPerfEnum;
#endif 	/* __IWbemHiPerfEnum_FWD_DEFINED__ */


#ifndef __IWbemConfigureRefresher_FWD_DEFINED__
#define __IWbemConfigureRefresher_FWD_DEFINED__
typedef interface IWbemConfigureRefresher IWbemConfigureRefresher;
#endif 	/* __IWbemConfigureRefresher_FWD_DEFINED__ */


#ifndef __WbemLocator_FWD_DEFINED__
#define __WbemLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemLocator WbemLocator;
#else
typedef struct WbemLocator WbemLocator;
#endif /* __cplusplus */

#endif 	/* __WbemLocator_FWD_DEFINED__ */


#ifndef __WbemContext_FWD_DEFINED__
#define __WbemContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemContext WbemContext;
#else
typedef struct WbemContext WbemContext;
#endif /* __cplusplus */

#endif 	/* __WbemContext_FWD_DEFINED__ */


#ifndef __UnsecuredApartment_FWD_DEFINED__
#define __UnsecuredApartment_FWD_DEFINED__

#ifdef __cplusplus
typedef class UnsecuredApartment UnsecuredApartment;
#else
typedef struct UnsecuredApartment UnsecuredApartment;
#endif /* __cplusplus */

#endif 	/* __UnsecuredApartment_FWD_DEFINED__ */


#ifndef __WbemClassObject_FWD_DEFINED__
#define __WbemClassObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemClassObject WbemClassObject;
#else
typedef struct WbemClassObject WbemClassObject;
#endif /* __cplusplus */

#endif 	/* __WbemClassObject_FWD_DEFINED__ */


#ifndef __MofCompiler_FWD_DEFINED__
#define __MofCompiler_FWD_DEFINED__

#ifdef __cplusplus
typedef class MofCompiler MofCompiler;
#else
typedef struct MofCompiler MofCompiler;
#endif /* __cplusplus */

#endif 	/* __MofCompiler_FWD_DEFINED__ */


#ifndef __WbemStatusCodeText_FWD_DEFINED__
#define __WbemStatusCodeText_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemStatusCodeText WbemStatusCodeText;
#else
typedef struct WbemStatusCodeText WbemStatusCodeText;
#endif /* __cplusplus */

#endif 	/* __WbemStatusCodeText_FWD_DEFINED__ */


#ifndef __WbemBackupRestore_FWD_DEFINED__
#define __WbemBackupRestore_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemBackupRestore WbemBackupRestore;
#else
typedef struct WbemBackupRestore WbemBackupRestore;
#endif /* __cplusplus */

#endif 	/* __WbemBackupRestore_FWD_DEFINED__ */


#ifndef __WbemRefresher_FWD_DEFINED__
#define __WbemRefresher_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemRefresher WbemRefresher;
#else
typedef struct WbemRefresher WbemRefresher;
#endif /* __cplusplus */

#endif 	/* __WbemRefresher_FWD_DEFINED__ */


#ifndef __WbemObjectTextSrc_FWD_DEFINED__
#define __WbemObjectTextSrc_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemObjectTextSrc WbemObjectTextSrc;
#else
typedef struct WbemObjectTextSrc WbemObjectTextSrc;
#endif /* __cplusplus */

#endif 	/* __WbemObjectTextSrc_FWD_DEFINED__ */


#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemRawSdAccessor_FWD_DEFINED__
#define __IWbemRawSdAccessor_FWD_DEFINED__
typedef interface IWbemRawSdAccessor IWbemRawSdAccessor;
#endif 	/* __IWbemRawSdAccessor_FWD_DEFINED__ */


#ifndef __IWbemShutdown_FWD_DEFINED__
#define __IWbemShutdown_FWD_DEFINED__
typedef interface IWbemShutdown IWbemShutdown;
#endif 	/* __IWbemShutdown_FWD_DEFINED__ */


#ifndef __IWbemCallStatus_FWD_DEFINED__
#define __IWbemCallStatus_FWD_DEFINED__
typedef interface IWbemCallStatus IWbemCallStatus;
#endif 	/* __IWbemCallStatus_FWD_DEFINED__ */


#ifndef __IWbemObjectTextSrc_FWD_DEFINED__
#define __IWbemObjectTextSrc_FWD_DEFINED__
typedef interface IWbemObjectTextSrc IWbemObjectTextSrc;
#endif 	/* __IWbemObjectTextSrc_FWD_DEFINED__ */


#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef interface IWbemObjectAccess IWbemObjectAccess;
#endif 	/* __IWbemObjectAccess_FWD_DEFINED__ */


#ifndef __IMofCompiler_FWD_DEFINED__
#define __IMofCompiler_FWD_DEFINED__
typedef interface IMofCompiler IMofCompiler;
#endif 	/* __IMofCompiler_FWD_DEFINED__ */


#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef interface IUnsecuredApartment IUnsecuredApartment;
#endif 	/* __IUnsecuredApartment_FWD_DEFINED__ */


#ifndef __IWbemStatusCodeText_FWD_DEFINED__
#define __IWbemStatusCodeText_FWD_DEFINED__
typedef interface IWbemStatusCodeText IWbemStatusCodeText;
#endif 	/* __IWbemStatusCodeText_FWD_DEFINED__ */


#ifndef __IWbemBackupRestore_FWD_DEFINED__
#define __IWbemBackupRestore_FWD_DEFINED__
typedef interface IWbemBackupRestore IWbemBackupRestore;
#endif 	/* __IWbemBackupRestore_FWD_DEFINED__ */


#ifndef __IWbemBackupRestoreEx_FWD_DEFINED__
#define __IWbemBackupRestoreEx_FWD_DEFINED__
typedef interface IWbemBackupRestoreEx IWbemBackupRestoreEx;
#endif 	/* __IWbemBackupRestoreEx_FWD_DEFINED__ */


#ifndef __IWbemRefresher_FWD_DEFINED__
#define __IWbemRefresher_FWD_DEFINED__
typedef interface IWbemRefresher IWbemRefresher;
#endif 	/* __IWbemRefresher_FWD_DEFINED__ */


#ifndef __IWbemHiPerfEnum_FWD_DEFINED__
#define __IWbemHiPerfEnum_FWD_DEFINED__
typedef interface IWbemHiPerfEnum IWbemHiPerfEnum;
#endif 	/* __IWbemHiPerfEnum_FWD_DEFINED__ */


#ifndef __IWbemConfigureRefresher_FWD_DEFINED__
#define __IWbemConfigureRefresher_FWD_DEFINED__
typedef interface IWbemConfigureRefresher IWbemConfigureRefresher;
#endif 	/* __IWbemConfigureRefresher_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __WbemClient_v1_LIBRARY_DEFINED__
#define __WbemClient_v1_LIBRARY_DEFINED__

/* library WbemClient_v1 */
/* [uuid] */ 




















typedef /* [v1_enum] */ 
enum tag_WBEM_GENUS_TYPE
    {	WBEM_GENUS_CLASS	= 1,
	WBEM_GENUS_INSTANCE	= 2
    } 	WBEM_GENUS_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CHANGE_FLAG_TYPE
    {	WBEM_FLAG_CREATE_OR_UPDATE	= 0,
	WBEM_FLAG_UPDATE_ONLY	= 0x1,
	WBEM_FLAG_CREATE_ONLY	= 0x2,
	WBEM_FLAG_UPDATE_COMPATIBLE	= 0,
	WBEM_FLAG_UPDATE_SAFE_MODE	= 0x20,
	WBEM_FLAG_UPDATE_FORCE_MODE	= 0x40,
	WBEM_MASK_UPDATE_MODE	= 0x60,
	WBEM_FLAG_ADVISORY	= 0x10000
    } 	WBEM_CHANGE_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_GENERIC_FLAG_TYPE
    {	WBEM_FLAG_RETURN_IMMEDIATELY	= 0x10,
	WBEM_FLAG_RETURN_WBEM_COMPLETE	= 0,
	WBEM_FLAG_BIDIRECTIONAL	= 0,
	WBEM_FLAG_FORWARD_ONLY	= 0x20,
	WBEM_FLAG_NO_ERROR_OBJECT	= 0x40,
	WBEM_FLAG_RETURN_ERROR_OBJECT	= 0,
	WBEM_FLAG_SEND_STATUS	= 0x80,
	WBEM_FLAG_DONT_SEND_STATUS	= 0,
	WBEM_FLAG_ENSURE_LOCATABLE	= 0x100,
	WBEM_FLAG_DIRECT_READ	= 0x200,
	WBEM_FLAG_SEND_ONLY_SELECTED	= 0,
	WBEM_RETURN_WHEN_COMPLETE	= 0,
	WBEM_RETURN_IMMEDIATELY	= 0x10,
	WBEM_MASK_RESERVED_FLAGS	= 0x1f000,
	WBEM_FLAG_USE_AMENDED_QUALIFIERS	= 0x20000,
	WBEM_FLAG_STRONG_VALIDATION	= 0x100000
    } 	WBEM_GENERIC_FLAG_TYPE;

typedef 
enum tag_WBEM_STATUS_TYPE
    {	WBEM_STATUS_COMPLETE	= 0,
	WBEM_STATUS_REQUIREMENTS	= 1,
	WBEM_STATUS_PROGRESS	= 2
    } 	WBEM_STATUS_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_TIMEOUT_TYPE
    {	WBEM_NO_WAIT	= 0,
	WBEM_INFINITE	= 0xffffffff
    } 	WBEM_TIMEOUT_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CONDITION_FLAG_TYPE
    {	WBEM_FLAG_ALWAYS	= 0,
	WBEM_FLAG_ONLY_IF_TRUE	= 0x1,
	WBEM_FLAG_ONLY_IF_FALSE	= 0x2,
	WBEM_FLAG_ONLY_IF_IDENTICAL	= 0x3,
	WBEM_MASK_PRIMARY_CONDITION	= 0x3,
	WBEM_FLAG_KEYS_ONLY	= 0x4,
	WBEM_FLAG_REFS_ONLY	= 0x8,
	WBEM_FLAG_LOCAL_ONLY	= 0x10,
	WBEM_FLAG_PROPAGATED_ONLY	= 0x20,
	WBEM_FLAG_SYSTEM_ONLY	= 0x30,
	WBEM_FLAG_NONSYSTEM_ONLY	= 0x40,
	WBEM_MASK_CONDITION_ORIGIN	= 0x70,
	WBEM_FLAG_CLASS_OVERRIDES_ONLY	= 0x100,
	WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES	= 0x200,
	WBEM_MASK_CLASS_CONDITION	= 0x300
    } 	WBEM_CONDITION_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_FLAVOR_TYPE
    {	WBEM_FLAVOR_DONT_PROPAGATE	= 0,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE	= 0x1,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS	= 0x2,
	WBEM_FLAVOR_MASK_PROPAGATION	= 0xf,
	WBEM_FLAVOR_OVERRIDABLE	= 0,
	WBEM_FLAVOR_NOT_OVERRIDABLE	= 0x10,
	WBEM_FLAVOR_MASK_PERMISSIONS	= 0x10,
	WBEM_FLAVOR_ORIGIN_LOCAL	= 0,
	WBEM_FLAVOR_ORIGIN_PROPAGATED	= 0x20,
	WBEM_FLAVOR_ORIGIN_SYSTEM	= 0x40,
	WBEM_FLAVOR_MASK_ORIGIN	= 0x60,
	WBEM_FLAVOR_NOT_AMENDED	= 0,
	WBEM_FLAVOR_AMENDED	= 0x80,
	WBEM_FLAVOR_MASK_AMENDED	= 0x80
    } 	WBEM_FLAVOR_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_QUERY_FLAG_TYPE
    {	WBEM_FLAG_DEEP	= 0,
	WBEM_FLAG_SHALLOW	= 1,
	WBEM_FLAG_PROTOTYPE	= 2
    } 	WBEM_QUERY_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_SECURITY_FLAGS
    {	WBEM_ENABLE	= 1,
	WBEM_METHOD_EXECUTE	= 2,
	WBEM_FULL_WRITE_REP	= 4,
	WBEM_PARTIAL_WRITE_REP	= 8,
	WBEM_WRITE_PROVIDER	= 0x10,
	WBEM_REMOTE_ACCESS	= 0x20,
	WBEM_RIGHT_SUBSCRIBE	= 0x1,
	WBEM_RIGHT_PUBLISH	= 0x1
    } 	WBEM_SECURITY_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_LIMITATION_FLAG_TYPE
    {	WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS	= 0x10,
	WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS	= 0x20
    } 	WBEM_LIMITATION_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_TEXT_FLAG_TYPE
    {	WBEM_FLAG_NO_FLAVORS	= 0x1
    } 	WBEM_TEXT_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_COMPARISON_FLAG
    {	WBEM_COMPARISON_INCLUDE_ALL	= 0,
	WBEM_FLAG_IGNORE_QUALIFIERS	= 0x1,
	WBEM_FLAG_IGNORE_OBJECT_SOURCE	= 0x2,
	WBEM_FLAG_IGNORE_DEFAULT_VALUES	= 0x4,
	WBEM_FLAG_IGNORE_CLASS	= 0x8,
	WBEM_FLAG_IGNORE_CASE	= 0x10,
	WBEM_FLAG_IGNORE_FLAVOR	= 0x20
    } 	WBEM_COMPARISON_FLAG;

typedef /* [v1_enum] */ 
enum tag_WBEM_LOCKING
    {	WBEM_FLAG_ALLOW_READ	= 0x1
    } 	WBEM_LOCKING_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_CIMTYPE_ENUMERATION
    {	CIM_ILLEGAL	= 0xfff,
	CIM_EMPTY	= 0,
	CIM_SINT8	= 16,
	CIM_UINT8	= 17,
	CIM_SINT16	= 2,
	CIM_UINT16	= 18,
	CIM_SINT32	= 3,
	CIM_UINT32	= 19,
	CIM_SINT64	= 20,
	CIM_UINT64	= 21,
	CIM_REAL32	= 4,
	CIM_REAL64	= 5,
	CIM_BOOLEAN	= 11,
	CIM_STRING	= 8,
	CIM_DATETIME	= 101,
	CIM_REFERENCE	= 102,
	CIM_CHAR16	= 103,
	CIM_OBJECT	= 13,
	CIM_FLAG_ARRAY	= 0x2000
    } 	CIMTYPE_ENUMERATION;

typedef /* [v1_enum] */ 
enum tag_WBEM_BACKUP_RESTORE_FLAGS
    {	WBEM_FLAG_BACKUP_RESTORE_DEFAULT	= 0,
	WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN	= 1
    } 	WBEM_BACKUP_RESTORE_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_REFRESHER_FLAGS
    {	WBEM_FLAG_REFRESH_AUTO_RECONNECT	= 0,
	WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT	= 1
    } 	WBEM_REFRESHER_FLAGS;

typedef 
enum tag_WBEM_SHUTDOWN_FLAGS
    {	WBEM_SHUTDOWN_UNLOAD_COMPONENT	= 1,
	WBEM_SHUTDOWN_WMI	= 2,
	WBEM_SHUTDOWN_OS	= 3
    } 	WBEM_SHUTDOWN_FLAGS;

typedef long CIMTYPE;

typedef /* [v1_enum] */ 
enum tag_WBEMSTATUS_FORMAT
    {	WBEMSTATUS_FORMAT_NEWLINE	= 0,
	WBEMSTATUS_FORMAT_NO_NEWLINE	= 1
    } 	WBEMSTATUS_FORMAT;

typedef /* [v1_enum] */ 
enum tag_WBEMSTATUS
    {	WBEM_NO_ERROR	= 0,
	WBEM_S_NO_ERROR	= 0,
	WBEM_S_SAME	= 0,
	WBEM_S_FALSE	= 1,
	WBEM_S_ALREADY_EXISTS	= 0x40001,
	WBEM_S_RESET_TO_DEFAULT	= 0x40002,
	WBEM_S_DIFFERENT	= 0x40003,
	WBEM_S_TIMEDOUT	= 0x40004,
	WBEM_S_NO_MORE_DATA	= 0x40005,
	WBEM_S_OPERATION_CANCELLED	= 0x40006,
	WBEM_S_PENDING	= 0x40007,
	WBEM_S_DUPLICATE_OBJECTS	= 0x40008,
	WBEM_S_ACCESS_DENIED	= 0x40009,
	WBEM_S_PARTIAL_RESULTS	= 0x40010,
	WBEM_S_NO_POSTHOOK	= 0x40011,
	WBEM_S_POSTHOOK_WITH_BOTH	= 0x40012,
	WBEM_S_POSTHOOK_WITH_NEW	= 0x40013,
	WBEM_S_POSTHOOK_WITH_STATUS	= 0x40014,
	WBEM_S_POSTHOOK_WITH_OLD	= 0x40015,
	WBEM_S_REDO_PREHOOK_WITH_ORIGINAL_OBJECT	= 0x40016,
	WBEM_S_SOURCE_NOT_AVAILABLE	= 0x40017,
	WBEM_E_FAILED	= 0x80041001,
	WBEM_E_NOT_FOUND	= 0x80041002,
	WBEM_E_ACCESS_DENIED	= 0x80041003,
	WBEM_E_PROVIDER_FAILURE	= 0x80041004,
	WBEM_E_TYPE_MISMATCH	= 0x80041005,
	WBEM_E_OUT_OF_MEMORY	= 0x80041006,
	WBEM_E_INVALID_CONTEXT	= 0x80041007,
	WBEM_E_INVALID_PARAMETER	= 0x80041008,
	WBEM_E_NOT_AVAILABLE	= 0x80041009,
	WBEM_E_CRITICAL_ERROR	= 0x8004100a,
	WBEM_E_INVALID_STREAM	= 0x8004100b,
	WBEM_E_NOT_SUPPORTED	= 0x8004100c,
	WBEM_E_INVALID_SUPERCLASS	= 0x8004100d,
	WBEM_E_INVALID_NAMESPACE	= 0x8004100e,
	WBEM_E_INVALID_OBJECT	= 0x8004100f,
	WBEM_E_INVALID_CLASS	= 0x80041010,
	WBEM_E_PROVIDER_NOT_FOUND	= 0x80041011,
	WBEM_E_INVALID_PROVIDER_REGISTRATION	= 0x80041012,
	WBEM_E_PROVIDER_LOAD_FAILURE	= 0x80041013,
	WBEM_E_INITIALIZATION_FAILURE	= 0x80041014,
	WBEM_E_TRANSPORT_FAILURE	= 0x80041015,
	WBEM_E_INVALID_OPERATION	= 0x80041016,
	WBEM_E_INVALID_QUERY	= 0x80041017,
	WBEM_E_INVALID_QUERY_TYPE	= 0x80041018,
	WBEM_E_ALREADY_EXISTS	= 0x80041019,
	WBEM_E_OVERRIDE_NOT_ALLOWED	= 0x8004101a,
	WBEM_E_PROPAGATED_QUALIFIER	= 0x8004101b,
	WBEM_E_PROPAGATED_PROPERTY	= 0x8004101c,
	WBEM_E_UNEXPECTED	= 0x8004101d,
	WBEM_E_ILLEGAL_OPERATION	= 0x8004101e,
	WBEM_E_CANNOT_BE_KEY	= 0x8004101f,
	WBEM_E_INCOMPLETE_CLASS	= 0x80041020,
	WBEM_E_INVALID_SYNTAX	= 0x80041021,
	WBEM_E_NONDECORATED_OBJECT	= 0x80041022,
	WBEM_E_READ_ONLY	= 0x80041023,
	WBEM_E_PROVIDER_NOT_CAPABLE	= 0x80041024,
	WBEM_E_CLASS_HAS_CHILDREN	= 0x80041025,
	WBEM_E_CLASS_HAS_INSTANCES	= 0x80041026,
	WBEM_E_QUERY_NOT_IMPLEMENTED	= 0x80041027,
	WBEM_E_ILLEGAL_NULL	= 0x80041028,
	WBEM_E_INVALID_QUALIFIER_TYPE	= 0x80041029,
	WBEM_E_INVALID_PROPERTY_TYPE	= 0x8004102a,
	WBEM_E_VALUE_OUT_OF_RANGE	= 0x8004102b,
	WBEM_E_CANNOT_BE_SINGLETON	= 0x8004102c,
	WBEM_E_INVALID_CIM_TYPE	= 0x8004102d,
	WBEM_E_INVALID_METHOD	= 0x8004102e,
	WBEM_E_INVALID_METHOD_PARAMETERS	= 0x8004102f,
	WBEM_E_SYSTEM_PROPERTY	= 0x80041030,
	WBEM_E_INVALID_PROPERTY	= 0x80041031,
	WBEM_E_CALL_CANCELLED	= 0x80041032,
	WBEM_E_SHUTTING_DOWN	= 0x80041033,
	WBEM_E_PROPAGATED_METHOD	= 0x80041034,
	WBEM_E_UNSUPPORTED_PARAMETER	= 0x80041035,
	WBEM_E_MISSING_PARAMETER_ID	= 0x80041036,
	WBEM_E_INVALID_PARAMETER_ID	= 0x80041037,
	WBEM_E_NONCONSECUTIVE_PARAMETER_IDS	= 0x80041038,
	WBEM_E_PARAMETER_ID_ON_RETVAL	= 0x80041039,
	WBEM_E_INVALID_OBJECT_PATH	= 0x8004103a,
	WBEM_E_OUT_OF_DISK_SPACE	= 0x8004103b,
	WBEM_E_BUFFER_TOO_SMALL	= 0x8004103c,
	WBEM_E_UNSUPPORTED_PUT_EXTENSION	= 0x8004103d,
	WBEM_E_UNKNOWN_OBJECT_TYPE	= 0x8004103e,
	WBEM_E_UNKNOWN_PACKET_TYPE	= 0x8004103f,
	WBEM_E_MARSHAL_VERSION_MISMATCH	= 0x80041040,
	WBEM_E_MARSHAL_INVALID_SIGNATURE	= 0x80041041,
	WBEM_E_INVALID_QUALIFIER	= 0x80041042,
	WBEM_E_INVALID_DUPLICATE_PARAMETER	= 0x80041043,
	WBEM_E_TOO_MUCH_DATA	= 0x80041044,
	WBEM_E_SERVER_TOO_BUSY	= 0x80041045,
	WBEM_E_INVALID_FLAVOR	= 0x80041046,
	WBEM_E_CIRCULAR_REFERENCE	= 0x80041047,
	WBEM_E_UNSUPPORTED_CLASS_UPDATE	= 0x80041048,
	WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE	= 0x80041049,
	WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE	= 0x80041050,
	WBEM_E_TOO_MANY_PROPERTIES	= 0x80041051,
	WBEM_E_UPDATE_TYPE_MISMATCH	= 0x80041052,
	WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED	= 0x80041053,
	WBEM_E_UPDATE_PROPAGATED_METHOD	= 0x80041054,
	WBEM_E_METHOD_NOT_IMPLEMENTED	= 0x80041055,
	WBEM_E_METHOD_DISABLED	= 0x80041056,
	WBEM_E_REFRESHER_BUSY	= 0x80041057,
	WBEM_E_UNPARSABLE_QUERY	= 0x80041058,
	WBEM_E_NOT_EVENT_CLASS	= 0x80041059,
	WBEM_E_MISSING_GROUP_WITHIN	= 0x8004105a,
	WBEM_E_MISSING_AGGREGATION_LIST	= 0x8004105b,
	WBEM_E_PROPERTY_NOT_AN_OBJECT	= 0x8004105c,
	WBEM_E_AGGREGATING_BY_OBJECT	= 0x8004105d,
	WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY	= 0x8004105f,
	WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING	= 0x80041060,
	WBEM_E_QUEUE_OVERFLOW	= 0x80041061,
	WBEM_E_PRIVILEGE_NOT_HELD	= 0x80041062,
	WBEM_E_INVALID_OPERATOR	= 0x80041063,
	WBEM_E_LOCAL_CREDENTIALS	= 0x80041064,
	WBEM_E_CANNOT_BE_ABSTRACT	= 0x80041065,
	WBEM_E_AMENDED_OBJECT	= 0x80041066,
	WBEM_E_CLIENT_TOO_SLOW	= 0x80041067,
	WBEM_E_NULL_SECURITY_DESCRIPTOR	= 0x80041068,
	WBEM_E_TIMED_OUT	= 0x80041069,
	WBEM_E_INVALID_ASSOCIATION	= 0x8004106a,
	WBEM_E_AMBIGUOUS_OPERATION	= 0x8004106b,
	WBEM_E_QUOTA_VIOLATION	= 0x8004106c,
	WBEM_E_RESERVED_001	= 0x8004106d,
	WBEM_E_RESERVED_002	= 0x8004106e,
	WBEM_E_UNSUPPORTED_LOCALE	= 0x8004106f,
	WBEM_E_HANDLE_OUT_OF_DATE	= 0x80041070,
	WBEM_E_CONNECTION_FAILED	= 0x80041071,
	WBEM_E_INVALID_HANDLE_REQUEST	= 0x80041072,
	WBEM_E_PROPERTY_NAME_TOO_WIDE	= 0x80041073,
	WBEM_E_CLASS_NAME_TOO_WIDE	= 0x80041074,
	WBEM_E_METHOD_NAME_TOO_WIDE	= 0x80041075,
	WBEM_E_QUALIFIER_NAME_TOO_WIDE	= 0x80041076,
	WBEM_E_RERUN_COMMAND	= 0x80041077,
	WBEM_E_DATABASE_VER_MISMATCH	= 0x80041078,
	WBEM_E_VETO_DELETE	= 0x80041079,
	WBEM_E_VETO_PUT	= 0x8004107a,
	WBEM_E_INVALID_LOCALE	= 0x80041080,
	WBEM_E_PROVIDER_SUSPENDED	= 0x80041081,
	WBEM_E_SYNCHRONIZATION_REQUIRED	= 0x80041082,
	WBEM_E_NO_SCHEMA	= 0x80041083,
	WBEM_E_PROVIDER_ALREADY_REGISTERED	= 0x80041084,
	WBEM_E_PROVIDER_NOT_REGISTERED	= 0x80041085,
	WBEM_E_FATAL_TRANSPORT_ERROR	= 0x80041086,
	WBEM_E_ENCRYPTED_CONNECTION_REQUIRED	= 0x80041087,
	WBEM_E_PROVIDER_TIMED_OUT	= 0x80041088,
	WBEM_E_NO_KEY	= 0x80041089,
	WBEMESS_E_REGISTRATION_TOO_BROAD	= 0x80042001,
	WBEMESS_E_REGISTRATION_TOO_PRECISE	= 0x80042002,
	WBEMMOF_E_EXPECTED_QUALIFIER_NAME	= 0x80044001,
	WBEMMOF_E_EXPECTED_SEMI	= 0x80044002,
	WBEMMOF_E_EXPECTED_OPEN_BRACE	= 0x80044003,
	WBEMMOF_E_EXPECTED_CLOSE_BRACE	= 0x80044004,
	WBEMMOF_E_EXPECTED_CLOSE_BRACKET	= 0x80044005,
	WBEMMOF_E_EXPECTED_CLOSE_PAREN	= 0x80044006,
	WBEMMOF_E_ILLEGAL_CONSTANT_VALUE	= 0x80044007,
	WBEMMOF_E_EXPECTED_TYPE_IDENTIFIER	= 0x80044008,
	WBEMMOF_E_EXPECTED_OPEN_PAREN	= 0x80044009,
	WBEMMOF_E_UNRECOGNIZED_TOKEN	= 0x8004400a,
	WBEMMOF_E_UNRECOGNIZED_TYPE	= 0x8004400b,
	WBEMMOF_E_EXPECTED_PROPERTY_NAME	= 0x8004400c,
	WBEMMOF_E_TYPEDEF_NOT_SUPPORTED	= 0x8004400d,
	WBEMMOF_E_UNEXPECTED_ALIAS	= 0x8004400e,
	WBEMMOF_E_UNEXPECTED_ARRAY_INIT	= 0x8004400f,
	WBEMMOF_E_INVALID_AMENDMENT_SYNTAX	= 0x80044010,
	WBEMMOF_E_INVALID_DUPLICATE_AMENDMENT	= 0x80044011,
	WBEMMOF_E_INVALID_PRAGMA	= 0x80044012,
	WBEMMOF_E_INVALID_NAMESPACE_SYNTAX	= 0x80044013,
	WBEMMOF_E_EXPECTED_CLASS_NAME	= 0x80044014,
	WBEMMOF_E_TYPE_MISMATCH	= 0x80044015,
	WBEMMOF_E_EXPECTED_ALIAS_NAME	= 0x80044016,
	WBEMMOF_E_INVALID_CLASS_DECLARATION	= 0x80044017,
	WBEMMOF_E_INVALID_INSTANCE_DECLARATION	= 0x80044018,
	WBEMMOF_E_EXPECTED_DOLLAR	= 0x80044019,
	WBEMMOF_E_CIMTYPE_QUALIFIER	= 0x8004401a,
	WBEMMOF_E_DUPLICATE_PROPERTY	= 0x8004401b,
	WBEMMOF_E_INVALID_NAMESPACE_SPECIFICATION	= 0x8004401c,
	WBEMMOF_E_OUT_OF_RANGE	= 0x8004401d,
	WBEMMOF_E_INVALID_FILE	= 0x8004401e,
	WBEMMOF_E_ALIASES_IN_EMBEDDED	= 0x8004401f,
	WBEMMOF_E_NULL_ARRAY_ELEM	= 0x80044020,
	WBEMMOF_E_DUPLICATE_QUALIFIER	= 0x80044021,
	WBEMMOF_E_EXPECTED_FLAVOR_TYPE	= 0x80044022,
	WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES	= 0x80044023,
	WBEMMOF_E_MULTIPLE_ALIASES	= 0x80044024,
	WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2	= 0x80044025,
	WBEMMOF_E_NO_ARRAYS_RETURNED	= 0x80044026,
	WBEMMOF_E_MUST_BE_IN_OR_OUT	= 0x80044027,
	WBEMMOF_E_INVALID_FLAGS_SYNTAX	= 0x80044028,
	WBEMMOF_E_EXPECTED_BRACE_OR_BAD_TYPE	= 0x80044029,
	WBEMMOF_E_UNSUPPORTED_CIMV22_QUAL_VALUE	= 0x8004402a,
	WBEMMOF_E_UNSUPPORTED_CIMV22_DATA_TYPE	= 0x8004402b,
	WBEMMOF_E_INVALID_DELETEINSTANCE_SYNTAX	= 0x8004402c,
	WBEMMOF_E_INVALID_QUALIFIER_SYNTAX	= 0x8004402d,
	WBEMMOF_E_QUALIFIER_USED_OUTSIDE_SCOPE	= 0x8004402e,
	WBEMMOF_E_ERROR_CREATING_TEMP_FILE	= 0x8004402f,
	WBEMMOF_E_ERROR_INVALID_INCLUDE_FILE	= 0x80044030,
	WBEMMOF_E_INVALID_DELETECLASS_SYNTAX	= 0x80044031
    } 	WBEMSTATUS;


EXTERN_C const IID LIBID_WbemClient_v1;

#ifndef __IWbemClassObject_INTERFACE_DEFINED__
#define __IWbemClassObject_INTERFACE_DEFINED__

/* interface IWbemClassObject */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a681-737f-11cf-884d-00aa004b2e24")
    IWbemClassObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetQualifierSet( 
            /* [out] */ IWbemQualifierSet **ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pVal,
            /* [in] */ CIMTYPE Type) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pQualifierVal,
            /* [out] */ SAFEARRAY * *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *strName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyQualifierSet( 
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet **ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemClassObject **ppCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectText( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrObjectText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpawnDerivedClass( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpawnInstance( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewInstance) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareTo( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pCompareTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyOrigin( 
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR *pstrClassName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InheritsFrom( 
            /* [in] */ LPCWSTR strAncestor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethod( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppInSignature,
            /* [out] */ IWbemClassObject **ppOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutMethod( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pInSignature,
            /* [in] */ IWbemClassObject *pOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMethod( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginMethodEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextMethod( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ IWbemClassObject **ppInSignature,
            /* [unique][in][out] */ IWbemClassObject **ppOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndMethodEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodQualifierSet( 
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet **ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodOrigin( 
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR *pstrClassName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemClassObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemClassObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetQualifierSet )( 
            IWbemClassObject * This,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pVal,
            /* [in] */ CIMTYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pQualifierVal,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemClassObject * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *strName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyQualifierSet )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWbemClassObject * This,
            /* [out] */ IWbemClassObject **ppCopy);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectText )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrObjectText);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnDerivedClass )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewClass);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnInstance )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewInstance);
        
        HRESULT ( STDMETHODCALLTYPE *CompareTo )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pCompareTo);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyOrigin )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE *InheritsFrom )( 
            IWbemClassObject * This,
            /* [in] */ LPCWSTR strAncestor);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethod )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppInSignature,
            /* [out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *PutMethod )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pInSignature,
            /* [in] */ IWbemClassObject *pOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMethod )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *BeginMethodEnumeration )( 
            IWbemClassObject * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *NextMethod )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ IWbemClassObject **ppInSignature,
            /* [unique][in][out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *EndMethodEnumeration )( 
            IWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodQualifierSet )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodOrigin )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR *pstrClassName);
        
        END_INTERFACE
    } IWbemClassObjectVtbl;

    interface IWbemClassObject
    {
        CONST_VTBL struct IWbemClassObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemClassObject_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemClassObject_Get(This,wszName,lFlags,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,pType,plFlavor)

#define IWbemClassObject_Put(This,wszName,lFlags,pVal,Type)	\
    (This)->lpVtbl -> Put(This,wszName,lFlags,pVal,Type)

#define IWbemClassObject_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemClassObject_GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)

#define IWbemClassObject_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemClassObject_Next(This,lFlags,strName,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,strName,pVal,pType,plFlavor)

#define IWbemClassObject_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemClassObject_GetPropertyQualifierSet(This,wszProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,wszProperty,ppQualSet)

#define IWbemClassObject_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemClassObject_GetObjectText(This,lFlags,pstrObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pstrObjectText)

#define IWbemClassObject_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemClassObject_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemClassObject_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemClassObject_GetPropertyOrigin(This,wszName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,wszName,pstrClassName)

#define IWbemClassObject_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#define IWbemClassObject_GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)

#define IWbemClassObject_PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)

#define IWbemClassObject_DeleteMethod(This,wszName)	\
    (This)->lpVtbl -> DeleteMethod(This,wszName)

#define IWbemClassObject_BeginMethodEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginMethodEnumeration(This,lEnumFlags)

#define IWbemClassObject_NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)

#define IWbemClassObject_EndMethodEnumeration(This)	\
    (This)->lpVtbl -> EndMethodEnumeration(This)

#define IWbemClassObject_GetMethodQualifierSet(This,wszMethod,ppQualSet)	\
    (This)->lpVtbl -> GetMethodQualifierSet(This,wszMethod,ppQualSet)

#define IWbemClassObject_GetMethodOrigin(This,wszMethodName,pstrClassName)	\
    (This)->lpVtbl -> GetMethodOrigin(This,wszMethodName,pstrClassName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemClassObject_GetQualifierSet_Proxy( 
    IWbemClassObject * This,
    /* [out] */ IWbemQualifierSet **ppQualSet);


void __RPC_STUB IWbemClassObject_GetQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Get_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ CIMTYPE *pType,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemClassObject_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Put_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pVal,
    /* [in] */ CIMTYPE Type);


void __RPC_STUB IWbemClassObject_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Delete_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemClassObject_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetNames_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszQualifierName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pQualifierVal,
    /* [out] */ SAFEARRAY * *pNames);


void __RPC_STUB IWbemClassObject_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginEnumeration_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Next_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR *strName,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ CIMTYPE *pType,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_EndEnumeration_Proxy( 
    IWbemClassObject * This);


void __RPC_STUB IWbemClassObject_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyQualifierSet_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszProperty,
    /* [out] */ IWbemQualifierSet **ppQualSet);


void __RPC_STUB IWbemClassObject_GetPropertyQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Clone_Proxy( 
    IWbemClassObject * This,
    /* [out] */ IWbemClassObject **ppCopy);


void __RPC_STUB IWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetObjectText_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *pstrObjectText);


void __RPC_STUB IWbemClassObject_GetObjectText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnDerivedClass_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject **ppNewClass);


void __RPC_STUB IWbemClassObject_SpawnDerivedClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnInstance_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject **ppNewInstance);


void __RPC_STUB IWbemClassObject_SpawnInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_CompareTo_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject *pCompareTo);


void __RPC_STUB IWbemClassObject_CompareTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyOrigin_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [out] */ BSTR *pstrClassName);


void __RPC_STUB IWbemClassObject_GetPropertyOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_InheritsFrom_Proxy( 
    IWbemClassObject * This,
    /* [in] */ LPCWSTR strAncestor);


void __RPC_STUB IWbemClassObject_InheritsFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethod_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject **ppInSignature,
    /* [out] */ IWbemClassObject **ppOutSignature);


void __RPC_STUB IWbemClassObject_GetMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_PutMethod_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject *pInSignature,
    /* [in] */ IWbemClassObject *pOutSignature);


void __RPC_STUB IWbemClassObject_PutMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_DeleteMethod_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemClassObject_DeleteMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginMethodEnumeration_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginMethodEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_NextMethod_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR *pstrName,
    /* [unique][in][out] */ IWbemClassObject **ppInSignature,
    /* [unique][in][out] */ IWbemClassObject **ppOutSignature);


void __RPC_STUB IWbemClassObject_NextMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_EndMethodEnumeration_Proxy( 
    IWbemClassObject * This);


void __RPC_STUB IWbemClassObject_EndMethodEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethodQualifierSet_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszMethod,
    /* [out] */ IWbemQualifierSet **ppQualSet);


void __RPC_STUB IWbemClassObject_GetMethodQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethodOrigin_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszMethodName,
    /* [out] */ BSTR *pstrClassName);


void __RPC_STUB IWbemClassObject_GetMethodOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectAccess_INTERFACE_DEFINED__
#define __IWbemObjectAccess_INTERFACE_DEFINED__

/* interface IWbemObjectAccess */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemObjectAccess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c9a-516b-11d1-aea6-00c04fb68820")
    IWbemObjectAccess : public IWbemClassObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyHandle( 
            /* [string][in] */ LPCWSTR wszPropertyName,
            /* [out] */ CIMTYPE *pType,
            /* [out] */ long *plHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyValue( 
            /* [in] */ long lHandle,
            /* [in] */ long lNumBytes,
            /* [size_is][in] */ const byte *aData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyValue( 
            /* [in] */ long lHandle,
            /* [in] */ long lBufferSize,
            /* [out] */ long *plNumBytes,
            /* [length_is][size_is][out] */ byte *aData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadDWORD( 
            /* [in] */ long lHandle,
            /* [out] */ DWORD *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteDWORD( 
            /* [in] */ long lHandle,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadQWORD( 
            /* [in] */ long lHandle,
            /* [out] */ unsigned __int64 *pqw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteQWORD( 
            /* [in] */ long lHandle,
            /* [in] */ unsigned __int64 pw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyInfoByHandle( 
            /* [in] */ long lHandle,
            /* [out] */ BSTR *pstrName,
            /* [out] */ CIMTYPE *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lock( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unlock( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectAccessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemObjectAccess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemObjectAccess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemObjectAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetQualifierSet )( 
            IWbemObjectAccess * This,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pVal,
            /* [in] */ CIMTYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pQualifierVal,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemObjectAccess * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *strName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemObjectAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyQualifierSet )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWbemObjectAccess * This,
            /* [out] */ IWbemClassObject **ppCopy);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectText )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrObjectText);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnDerivedClass )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewClass);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnInstance )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewInstance);
        
        HRESULT ( STDMETHODCALLTYPE *CompareTo )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pCompareTo);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyOrigin )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE *InheritsFrom )( 
            IWbemObjectAccess * This,
            /* [in] */ LPCWSTR strAncestor);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethod )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppInSignature,
            /* [out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *PutMethod )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pInSignature,
            /* [in] */ IWbemClassObject *pOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMethod )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *BeginMethodEnumeration )( 
            IWbemObjectAccess * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *NextMethod )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ IWbemClassObject **ppInSignature,
            /* [unique][in][out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *EndMethodEnumeration )( 
            IWbemObjectAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodQualifierSet )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodOrigin )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyHandle )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszPropertyName,
            /* [out] */ CIMTYPE *pType,
            /* [out] */ long *plHandle);
        
        HRESULT ( STDMETHODCALLTYPE *WritePropertyValue )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ long lNumBytes,
            /* [size_is][in] */ const byte *aData);
        
        HRESULT ( STDMETHODCALLTYPE *ReadPropertyValue )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ long lBufferSize,
            /* [out] */ long *plNumBytes,
            /* [length_is][size_is][out] */ byte *aData);
        
        HRESULT ( STDMETHODCALLTYPE *ReadDWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [out] */ DWORD *pdw);
        
        HRESULT ( STDMETHODCALLTYPE *WriteDWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE *ReadQWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [out] */ unsigned __int64 *pqw);
        
        HRESULT ( STDMETHODCALLTYPE *WriteQWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ unsigned __int64 pw);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyInfoByHandle )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [out] */ BSTR *pstrName,
            /* [out] */ CIMTYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *Lock )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Unlock )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemObjectAccessVtbl;

    interface IWbemObjectAccess
    {
        CONST_VTBL struct IWbemObjectAccessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectAccess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectAccess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectAccess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectAccess_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemObjectAccess_Get(This,wszName,lFlags,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,pType,plFlavor)

#define IWbemObjectAccess_Put(This,wszName,lFlags,pVal,Type)	\
    (This)->lpVtbl -> Put(This,wszName,lFlags,pVal,Type)

#define IWbemObjectAccess_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemObjectAccess_GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)

#define IWbemObjectAccess_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemObjectAccess_Next(This,lFlags,strName,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,strName,pVal,pType,plFlavor)

#define IWbemObjectAccess_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemObjectAccess_GetPropertyQualifierSet(This,wszProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,wszProperty,ppQualSet)

#define IWbemObjectAccess_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemObjectAccess_GetObjectText(This,lFlags,pstrObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pstrObjectText)

#define IWbemObjectAccess_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemObjectAccess_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemObjectAccess_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemObjectAccess_GetPropertyOrigin(This,wszName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,wszName,pstrClassName)

#define IWbemObjectAccess_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#define IWbemObjectAccess_GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)

#define IWbemObjectAccess_PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)

#define IWbemObjectAccess_DeleteMethod(This,wszName)	\
    (This)->lpVtbl -> DeleteMethod(This,wszName)

#define IWbemObjectAccess_BeginMethodEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginMethodEnumeration(This,lEnumFlags)

#define IWbemObjectAccess_NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)

#define IWbemObjectAccess_EndMethodEnumeration(This)	\
    (This)->lpVtbl -> EndMethodEnumeration(This)

#define IWbemObjectAccess_GetMethodQualifierSet(This,wszMethod,ppQualSet)	\
    (This)->lpVtbl -> GetMethodQualifierSet(This,wszMethod,ppQualSet)

#define IWbemObjectAccess_GetMethodOrigin(This,wszMethodName,pstrClassName)	\
    (This)->lpVtbl -> GetMethodOrigin(This,wszMethodName,pstrClassName)


#define IWbemObjectAccess_GetPropertyHandle(This,wszPropertyName,pType,plHandle)	\
    (This)->lpVtbl -> GetPropertyHandle(This,wszPropertyName,pType,plHandle)

#define IWbemObjectAccess_WritePropertyValue(This,lHandle,lNumBytes,aData)	\
    (This)->lpVtbl -> WritePropertyValue(This,lHandle,lNumBytes,aData)

#define IWbemObjectAccess_ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,aData)	\
    (This)->lpVtbl -> ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,aData)

#define IWbemObjectAccess_ReadDWORD(This,lHandle,pdw)	\
    (This)->lpVtbl -> ReadDWORD(This,lHandle,pdw)

#define IWbemObjectAccess_WriteDWORD(This,lHandle,dw)	\
    (This)->lpVtbl -> WriteDWORD(This,lHandle,dw)

#define IWbemObjectAccess_ReadQWORD(This,lHandle,pqw)	\
    (This)->lpVtbl -> ReadQWORD(This,lHandle,pqw)

#define IWbemObjectAccess_WriteQWORD(This,lHandle,pw)	\
    (This)->lpVtbl -> WriteQWORD(This,lHandle,pw)

#define IWbemObjectAccess_GetPropertyInfoByHandle(This,lHandle,pstrName,pType)	\
    (This)->lpVtbl -> GetPropertyInfoByHandle(This,lHandle,pstrName,pType)

#define IWbemObjectAccess_Lock(This,lFlags)	\
    (This)->lpVtbl -> Lock(This,lFlags)

#define IWbemObjectAccess_Unlock(This,lFlags)	\
    (This)->lpVtbl -> Unlock(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectAccess_GetPropertyHandle_Proxy( 
    IWbemObjectAccess * This,
    /* [string][in] */ LPCWSTR wszPropertyName,
    /* [out] */ CIMTYPE *pType,
    /* [out] */ long *plHandle);


void __RPC_STUB IWbemObjectAccess_GetPropertyHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WritePropertyValue_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ long lNumBytes,
    /* [size_is][in] */ const byte *aData);


void __RPC_STUB IWbemObjectAccess_WritePropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadPropertyValue_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ long lBufferSize,
    /* [out] */ long *plNumBytes,
    /* [length_is][size_is][out] */ byte *aData);


void __RPC_STUB IWbemObjectAccess_ReadPropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadDWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [out] */ DWORD *pdw);


void __RPC_STUB IWbemObjectAccess_ReadDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WriteDWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ DWORD dw);


void __RPC_STUB IWbemObjectAccess_WriteDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadQWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [out] */ unsigned __int64 *pqw);


void __RPC_STUB IWbemObjectAccess_ReadQWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WriteQWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ unsigned __int64 pw);


void __RPC_STUB IWbemObjectAccess_WriteQWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_GetPropertyInfoByHandle_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [out] */ BSTR *pstrName,
    /* [out] */ CIMTYPE *pType);


void __RPC_STUB IWbemObjectAccess_GetPropertyInfoByHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_Lock_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemObjectAccess_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_Unlock_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemObjectAccess_Unlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectAccess_INTERFACE_DEFINED__ */


#ifndef __IWbemQualifierSet_INTERFACE_DEFINED__
#define __IWbemQualifierSet_INTERFACE_DEFINED__

/* interface IWbemQualifierSet */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemQualifierSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a680-737f-11cf-884d-00aa004b2e24")
    IWbemQualifierSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ VARIANT *pVal,
            /* [in] */ long lFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemQualifierSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemQualifierSet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemQualifierSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemQualifierSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemQualifierSet * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemQualifierSet * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ VARIANT *pVal,
            /* [in] */ long lFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IWbemQualifierSet * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemQualifierSet * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemQualifierSet * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemQualifierSet * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemQualifierSet * This);
        
        END_INTERFACE
    } IWbemQualifierSetVtbl;

    interface IWbemQualifierSet
    {
        CONST_VTBL struct IWbemQualifierSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemQualifierSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemQualifierSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemQualifierSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemQualifierSet_Get(This,wszName,lFlags,pVal,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,plFlavor)

#define IWbemQualifierSet_Put(This,wszName,pVal,lFlavor)	\
    (This)->lpVtbl -> Put(This,wszName,pVal,lFlavor)

#define IWbemQualifierSet_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemQualifierSet_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemQualifierSet_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemQualifierSet_Next(This,lFlags,pstrName,pVal,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,pstrName,pVal,plFlavor)

#define IWbemQualifierSet_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Get_Proxy( 
    IWbemQualifierSet * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemQualifierSet_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Put_Proxy( 
    IWbemQualifierSet * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ VARIANT *pVal,
    /* [in] */ long lFlavor);


void __RPC_STUB IWbemQualifierSet_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Delete_Proxy( 
    IWbemQualifierSet * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemQualifierSet_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_GetNames_Proxy( 
    IWbemQualifierSet * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY * *pNames);


void __RPC_STUB IWbemQualifierSet_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_BeginEnumeration_Proxy( 
    IWbemQualifierSet * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemQualifierSet_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Next_Proxy( 
    IWbemQualifierSet * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR *pstrName,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemQualifierSet_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_EndEnumeration_Proxy( 
    IWbemQualifierSet * This);


void __RPC_STUB IWbemQualifierSet_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemQualifierSet_INTERFACE_DEFINED__ */


#ifndef __IWbemServices_INTERFACE_DEFINED__
#define __IWbemServices_INTERFACE_DEFINED__

/* interface IWbemServices */
/* [unique][uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9556dc99-828c-11cf-a37e-00aa003240c7")
    IWbemServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemServices **ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink **ppResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemClassObject **ppObject,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject **ppOutParams,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenNamespace )( 
            IWbemServices * This,
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemServices **ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *CancelAsyncCall )( 
            IWbemServices * This,
            /* [in] */ IWbemObjectSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *QueryObjectSink )( 
            IWbemServices * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink **ppResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemClassObject **ppObject,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *PutClass )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *PutClassAsync )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteClass )( 
            IWbemServices * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteClassAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClassEnum )( 
            IWbemServices * This,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClassEnumAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *PutInstance )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *PutInstanceAsync )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteInstance )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteInstanceAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceEnum )( 
            IWbemServices * This,
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceEnumAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecQuery )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *ExecQueryAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecNotificationQuery )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *ExecNotificationQueryAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecMethod )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject **ppOutParams,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *ExecMethodAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        END_INTERFACE
    } IWbemServicesVtbl;

    interface IWbemServices
    {
        CONST_VTBL struct IWbemServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemServices_OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)	\
    (This)->lpVtbl -> OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)

#define IWbemServices_CancelAsyncCall(This,pSink)	\
    (This)->lpVtbl -> CancelAsyncCall(This,pSink)

#define IWbemServices_QueryObjectSink(This,lFlags,ppResponseHandler)	\
    (This)->lpVtbl -> QueryObjectSink(This,lFlags,ppResponseHandler)

#define IWbemServices_GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)	\
    (This)->lpVtbl -> GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)

#define IWbemServices_GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutClass(This,pObject,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutClass(This,pObject,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutInstance(This,pInst,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutInstance(This,pInst,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateInstanceEnum(This,strFilter,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateInstanceEnum(This,strFilter,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateInstanceEnumAsync(This,strFilter,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateInstanceEnumAsync(This,strFilter,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)	\
    (This)->lpVtbl -> ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)

#define IWbemServices_ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)	\
    (This)->lpVtbl -> ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemServices_OpenNamespace_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemServices **ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult **ppResult);


void __RPC_STUB IWbemServices_OpenNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CancelAsyncCall_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemObjectSink *pSink);


void __RPC_STUB IWbemServices_CancelAsyncCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_QueryObjectSink_Proxy( 
    IWbemServices * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink **ppResponseHandler);


void __RPC_STUB IWbemServices_QueryObjectSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_GetObject_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemClassObject **ppObject,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_GetObjectAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_GetObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutClass_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_PutClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutClassAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_PutClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClass_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_DeleteClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClassAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnum_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_CreateClassEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnumAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_CreateClassEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutInstance_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_PutInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutInstanceAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_PutInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstance_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_DeleteInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstanceAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnum_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strFilter,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_CreateInstanceEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnumAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strFilter,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_CreateInstanceEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecQuery_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecQueryAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_ExecQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQuery_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_ExecNotificationQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQueryAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_ExecNotificationQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethod_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemClassObject *pInParams,
    /* [unique][in][out] */ IWbemClassObject **ppOutParams,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_ExecMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethodAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemClassObject *pInParams,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_ExecMethodAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemServices_INTERFACE_DEFINED__ */


#ifndef __IWbemLocator_INTERFACE_DEFINED__
#define __IWbemLocator_INTERFACE_DEFINED__

/* interface IWbemLocator */
/* [unique][uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a687-737f-11cf-884d-00aa004b2e24")
    IWbemLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectServer( 
            /* [in] */ const BSTR strNetworkResource,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ const BSTR strAuthority,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemServices **ppNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectServer )( 
            IWbemLocator * This,
            /* [in] */ const BSTR strNetworkResource,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ const BSTR strAuthority,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemServices **ppNamespace);
        
        END_INTERFACE
    } IWbemLocatorVtbl;

    interface IWbemLocator
    {
        CONST_VTBL struct IWbemLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemLocator_ConnectServer(This,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)	\
    (This)->lpVtbl -> ConnectServer(This,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemLocator_ConnectServer_Proxy( 
    IWbemLocator * This,
    /* [in] */ const BSTR strNetworkResource,
    /* [in] */ const BSTR strUser,
    /* [in] */ const BSTR strPassword,
    /* [in] */ const BSTR strLocale,
    /* [in] */ long lSecurityFlags,
    /* [in] */ const BSTR strAuthority,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IWbemServices **ppNamespace);


void __RPC_STUB IWbemLocator_ConnectServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemLocator_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectSink_INTERFACE_DEFINED__
#define __IWbemObjectSink_INTERFACE_DEFINED__

/* interface IWbemObjectSink */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c857801-7381-11cf-884d-00aa004b2e24")
    IWbemObjectSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject **apObjArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject *pObjParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemObjectSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemObjectSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemObjectSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Indicate )( 
            IWbemObjectSink * This,
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject **apObjArray);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IWbemObjectSink * This,
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject *pObjParam);
        
        END_INTERFACE
    } IWbemObjectSinkVtbl;

    interface IWbemObjectSink
    {
        CONST_VTBL struct IWbemObjectSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectSink_Indicate(This,lObjectCount,apObjArray)	\
    (This)->lpVtbl -> Indicate(This,lObjectCount,apObjArray)

#define IWbemObjectSink_SetStatus(This,lFlags,hResult,strParam,pObjParam)	\
    (This)->lpVtbl -> SetStatus(This,lFlags,hResult,strParam,pObjParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectSink_Indicate_Proxy( 
    IWbemObjectSink * This,
    /* [in] */ long lObjectCount,
    /* [size_is][in] */ IWbemClassObject **apObjArray);


void __RPC_STUB IWbemObjectSink_Indicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectSink_SetStatus_Proxy( 
    IWbemObjectSink * This,
    /* [in] */ long lFlags,
    /* [in] */ HRESULT hResult,
    /* [in] */ BSTR strParam,
    /* [in] */ IWbemClassObject *pObjParam);


void __RPC_STUB IWbemObjectSink_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectSink_INTERFACE_DEFINED__ */


#ifndef __IEnumWbemClassObject_INTERFACE_DEFINED__
#define __IEnumWbemClassObject_INTERFACE_DEFINED__

/* interface IEnumWbemClassObject */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IEnumWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("027947e1-d731-11ce-a357-000000000001")
    IEnumWbemClassObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject **apObjects,
            /* [out] */ ULONG *puReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextAsync( 
            /* [in] */ ULONG uCount,
            /* [in] */ IWbemObjectSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG nCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumWbemClassObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumWbemClassObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWbemClassObject * This,
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject **apObjects,
            /* [out] */ ULONG *puReturned);
        
        HRESULT ( STDMETHODCALLTYPE *NextAsync )( 
            IEnumWbemClassObject * This,
            /* [in] */ ULONG uCount,
            /* [in] */ IWbemObjectSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumWbemClassObject * This,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumWbemClassObject * This,
            /* [in] */ long lTimeout,
            /* [in] */ ULONG nCount);
        
        END_INTERFACE
    } IEnumWbemClassObjectVtbl;

    interface IEnumWbemClassObject
    {
        CONST_VTBL struct IEnumWbemClassObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumWbemClassObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumWbemClassObject_Next(This,lTimeout,uCount,apObjects,puReturned)	\
    (This)->lpVtbl -> Next(This,lTimeout,uCount,apObjects,puReturned)

#define IEnumWbemClassObject_NextAsync(This,uCount,pSink)	\
    (This)->lpVtbl -> NextAsync(This,uCount,pSink)

#define IEnumWbemClassObject_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumWbemClassObject_Skip(This,lTimeout,nCount)	\
    (This)->lpVtbl -> Skip(This,lTimeout,nCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Reset_Proxy( 
    IEnumWbemClassObject * This);


void __RPC_STUB IEnumWbemClassObject_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Next_Proxy( 
    IEnumWbemClassObject * This,
    /* [in] */ long lTimeout,
    /* [in] */ ULONG uCount,
    /* [length_is][size_is][out] */ IWbemClassObject **apObjects,
    /* [out] */ ULONG *puReturned);


void __RPC_STUB IEnumWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_NextAsync_Proxy( 
    IEnumWbemClassObject * This,
    /* [in] */ ULONG uCount,
    /* [in] */ IWbemObjectSink *pSink);


void __RPC_STUB IEnumWbemClassObject_NextAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Clone_Proxy( 
    IEnumWbemClassObject * This,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IEnumWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Skip_Proxy( 
    IEnumWbemClassObject * This,
    /* [in] */ long lTimeout,
    /* [in] */ ULONG nCount);


void __RPC_STUB IEnumWbemClassObject_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemCallResult_INTERFACE_DEFINED__
#define __IWbemCallResult_INTERFACE_DEFINED__

/* interface IWbemCallResult */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemCallResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44aca675-e8fc-11d0-a07c-00c04fb68820")
    IWbemCallResult : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResultObject( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject **ppResultObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultString( 
            /* [in] */ long lTimeout,
            /* [out] */ BSTR *pstrResultString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultServices( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices **ppServices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallStatus( 
            /* [in] */ long lTimeout,
            /* [out] */ long *plStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemCallResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemCallResult * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemCallResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemCallResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultObject )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject **ppResultObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultString )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ BSTR *pstrResultString);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultServices )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices **ppServices);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallStatus )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ long *plStatus);
        
        END_INTERFACE
    } IWbemCallResultVtbl;

    interface IWbemCallResult
    {
        CONST_VTBL struct IWbemCallResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemCallResult_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemCallResult_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemCallResult_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemCallResult_GetResultObject(This,lTimeout,ppResultObject)	\
    (This)->lpVtbl -> GetResultObject(This,lTimeout,ppResultObject)

#define IWbemCallResult_GetResultString(This,lTimeout,pstrResultString)	\
    (This)->lpVtbl -> GetResultString(This,lTimeout,pstrResultString)

#define IWbemCallResult_GetResultServices(This,lTimeout,ppServices)	\
    (This)->lpVtbl -> GetResultServices(This,lTimeout,ppServices)

#define IWbemCallResult_GetCallStatus(This,lTimeout,plStatus)	\
    (This)->lpVtbl -> GetCallStatus(This,lTimeout,plStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultObject_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemClassObject **ppResultObject);


void __RPC_STUB IWbemCallResult_GetResultObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultString_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ BSTR *pstrResultString);


void __RPC_STUB IWbemCallResult_GetResultString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultServices_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemServices **ppServices);


void __RPC_STUB IWbemCallResult_GetResultServices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetCallStatus_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ long *plStatus);


void __RPC_STUB IWbemCallResult_GetCallStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemCallResult_INTERFACE_DEFINED__ */


#ifndef __IWbemContext_INTERFACE_DEFINED__
#define __IWbemContext_INTERFACE_DEFINED__

/* interface IWbemContext */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44aca674-e8fc-11d0-a07c-00c04fb68820")
    IWbemContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemContext **ppNewCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrName,
            /* [out] */ VARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWbemContext * This,
            /* [out] */ IWbemContext **ppNewCopy);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemContext * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemContext * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemContext * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrName,
            /* [out] */ VARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IWbemContext * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IWbemContext * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteValue )( 
            IWbemContext * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAll )( 
            IWbemContext * This);
        
        END_INTERFACE
    } IWbemContextVtbl;

    interface IWbemContext
    {
        CONST_VTBL struct IWbemContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemContext_Clone(This,ppNewCopy)	\
    (This)->lpVtbl -> Clone(This,ppNewCopy)

#define IWbemContext_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemContext_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemContext_Next(This,lFlags,pstrName,pValue)	\
    (This)->lpVtbl -> Next(This,lFlags,pstrName,pValue)

#define IWbemContext_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemContext_SetValue(This,wszName,lFlags,pValue)	\
    (This)->lpVtbl -> SetValue(This,wszName,lFlags,pValue)

#define IWbemContext_GetValue(This,wszName,lFlags,pValue)	\
    (This)->lpVtbl -> GetValue(This,wszName,lFlags,pValue)

#define IWbemContext_DeleteValue(This,wszName,lFlags)	\
    (This)->lpVtbl -> DeleteValue(This,wszName,lFlags)

#define IWbemContext_DeleteAll(This)	\
    (This)->lpVtbl -> DeleteAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemContext_Clone_Proxy( 
    IWbemContext * This,
    /* [out] */ IWbemContext **ppNewCopy);


void __RPC_STUB IWbemContext_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_GetNames_Proxy( 
    IWbemContext * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY * *pNames);


void __RPC_STUB IWbemContext_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_BeginEnumeration_Proxy( 
    IWbemContext * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_Next_Proxy( 
    IWbemContext * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *pstrName,
    /* [out] */ VARIANT *pValue);


void __RPC_STUB IWbemContext_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_EndEnumeration_Proxy( 
    IWbemContext * This);


void __RPC_STUB IWbemContext_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_SetValue_Proxy( 
    IWbemContext * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pValue);


void __RPC_STUB IWbemContext_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_GetValue_Proxy( 
    IWbemContext * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [out] */ VARIANT *pValue);


void __RPC_STUB IWbemContext_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_DeleteValue_Proxy( 
    IWbemContext * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_DeleteValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_DeleteAll_Proxy( 
    IWbemContext * This);


void __RPC_STUB IWbemContext_DeleteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemContext_INTERFACE_DEFINED__ */


#ifndef __IUnsecuredApartment_INTERFACE_DEFINED__
#define __IUnsecuredApartment_INTERFACE_DEFINED__

/* interface IUnsecuredApartment */
/* [object][uuid][restricted] */ 


EXTERN_C const IID IID_IUnsecuredApartment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1cfaba8c-1523-11d1-ad79-00c04fd8fdff")
    IUnsecuredApartment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateObjectStub( 
            /* [in] */ IUnknown *pObject,
            /* [out] */ IUnknown **ppStub) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUnsecuredApartmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUnsecuredApartment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUnsecuredApartment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUnsecuredApartment * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateObjectStub )( 
            IUnsecuredApartment * This,
            /* [in] */ IUnknown *pObject,
            /* [out] */ IUnknown **ppStub);
        
        END_INTERFACE
    } IUnsecuredApartmentVtbl;

    interface IUnsecuredApartment
    {
        CONST_VTBL struct IUnsecuredApartmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUnsecuredApartment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUnsecuredApartment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUnsecuredApartment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUnsecuredApartment_CreateObjectStub(This,pObject,ppStub)	\
    (This)->lpVtbl -> CreateObjectStub(This,pObject,ppStub)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUnsecuredApartment_CreateObjectStub_Proxy( 
    IUnsecuredApartment * This,
    /* [in] */ IUnknown *pObject,
    /* [out] */ IUnknown **ppStub);


void __RPC_STUB IUnsecuredApartment_CreateObjectStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUnsecuredApartment_INTERFACE_DEFINED__ */


#ifndef __IWbemStatusCodeText_INTERFACE_DEFINED__
#define __IWbemStatusCodeText_INTERFACE_DEFINED__

/* interface IWbemStatusCodeText */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IWbemStatusCodeText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eb87e1bc-3233-11d2-aec9-00c04fb68820")
    IWbemStatusCodeText : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetErrorCodeText( 
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFacilityCodeText( 
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemStatusCodeTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemStatusCodeText * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemStatusCodeText * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemStatusCodeText * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorCodeText )( 
            IWbemStatusCodeText * This,
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText);
        
        HRESULT ( STDMETHODCALLTYPE *GetFacilityCodeText )( 
            IWbemStatusCodeText * This,
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText);
        
        END_INTERFACE
    } IWbemStatusCodeTextVtbl;

    interface IWbemStatusCodeText
    {
        CONST_VTBL struct IWbemStatusCodeTextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemStatusCodeText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemStatusCodeText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemStatusCodeText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemStatusCodeText_GetErrorCodeText(This,hRes,LocaleId,lFlags,MessageText)	\
    (This)->lpVtbl -> GetErrorCodeText(This,hRes,LocaleId,lFlags,MessageText)

#define IWbemStatusCodeText_GetFacilityCodeText(This,hRes,LocaleId,lFlags,MessageText)	\
    (This)->lpVtbl -> GetFacilityCodeText(This,hRes,LocaleId,lFlags,MessageText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemStatusCodeText_GetErrorCodeText_Proxy( 
    IWbemStatusCodeText * This,
    /* [in] */ HRESULT hRes,
    /* [in] */ LCID LocaleId,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *MessageText);


void __RPC_STUB IWbemStatusCodeText_GetErrorCodeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemStatusCodeText_GetFacilityCodeText_Proxy( 
    IWbemStatusCodeText * This,
    /* [in] */ HRESULT hRes,
    /* [in] */ LCID LocaleId,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *MessageText);


void __RPC_STUB IWbemStatusCodeText_GetFacilityCodeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemStatusCodeText_INTERFACE_DEFINED__ */


#ifndef __IWbemBackupRestore_INTERFACE_DEFINED__
#define __IWbemBackupRestore_INTERFACE_DEFINED__

/* interface IWbemBackupRestore */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemBackupRestore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C49E32C7-BC8B-11d2-85D4-00105A1F8304")
    IWbemBackupRestore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Backup( 
            /* [string][in] */ LPCWSTR strBackupToFile,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Restore( 
            /* [string][in] */ LPCWSTR strRestoreFromFile,
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemBackupRestoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemBackupRestore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemBackupRestore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemBackupRestore * This);
        
        HRESULT ( STDMETHODCALLTYPE *Backup )( 
            IWbemBackupRestore * This,
            /* [string][in] */ LPCWSTR strBackupToFile,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Restore )( 
            IWbemBackupRestore * This,
            /* [string][in] */ LPCWSTR strRestoreFromFile,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemBackupRestoreVtbl;

    interface IWbemBackupRestore
    {
        CONST_VTBL struct IWbemBackupRestoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemBackupRestore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemBackupRestore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemBackupRestore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemBackupRestore_Backup(This,strBackupToFile,lFlags)	\
    (This)->lpVtbl -> Backup(This,strBackupToFile,lFlags)

#define IWbemBackupRestore_Restore(This,strRestoreFromFile,lFlags)	\
    (This)->lpVtbl -> Restore(This,strRestoreFromFile,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemBackupRestore_Backup_Proxy( 
    IWbemBackupRestore * This,
    /* [string][in] */ LPCWSTR strBackupToFile,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemBackupRestore_Backup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemBackupRestore_Restore_Proxy( 
    IWbemBackupRestore * This,
    /* [string][in] */ LPCWSTR strRestoreFromFile,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemBackupRestore_Restore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemBackupRestore_INTERFACE_DEFINED__ */


#ifndef __IWbemBackupRestoreEx_INTERFACE_DEFINED__
#define __IWbemBackupRestoreEx_INTERFACE_DEFINED__

/* interface IWbemBackupRestoreEx */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemBackupRestoreEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A359DEC5-E813-4834-8A2A-BA7F1D777D76")
    IWbemBackupRestoreEx : public IWbemBackupRestore
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemBackupRestoreExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemBackupRestoreEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemBackupRestoreEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemBackupRestoreEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Backup )( 
            IWbemBackupRestoreEx * This,
            /* [string][in] */ LPCWSTR strBackupToFile,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Restore )( 
            IWbemBackupRestoreEx * This,
            /* [string][in] */ LPCWSTR strRestoreFromFile,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IWbemBackupRestoreEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IWbemBackupRestoreEx * This);
        
        END_INTERFACE
    } IWbemBackupRestoreExVtbl;

    interface IWbemBackupRestoreEx
    {
        CONST_VTBL struct IWbemBackupRestoreExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemBackupRestoreEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemBackupRestoreEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemBackupRestoreEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemBackupRestoreEx_Backup(This,strBackupToFile,lFlags)	\
    (This)->lpVtbl -> Backup(This,strBackupToFile,lFlags)

#define IWbemBackupRestoreEx_Restore(This,strRestoreFromFile,lFlags)	\
    (This)->lpVtbl -> Restore(This,strRestoreFromFile,lFlags)


#define IWbemBackupRestoreEx_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IWbemBackupRestoreEx_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemBackupRestoreEx_Pause_Proxy( 
    IWbemBackupRestoreEx * This);


void __RPC_STUB IWbemBackupRestoreEx_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemBackupRestoreEx_Resume_Proxy( 
    IWbemBackupRestoreEx * This);


void __RPC_STUB IWbemBackupRestoreEx_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemBackupRestoreEx_INTERFACE_DEFINED__ */


#ifndef __IWbemRefresher_INTERFACE_DEFINED__
#define __IWbemRefresher_INTERFACE_DEFINED__

/* interface IWbemRefresher */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemRefresher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c99-516b-11d1-aea6-00c04fb68820")
    IWbemRefresher : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemRefresherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemRefresher * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemRefresher * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemRefresher * This);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IWbemRefresher * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemRefresherVtbl;

    interface IWbemRefresher
    {
        CONST_VTBL struct IWbemRefresherVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemRefresher_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemRefresher_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemRefresher_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemRefresher_Refresh(This,lFlags)	\
    (This)->lpVtbl -> Refresh(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemRefresher_Refresh_Proxy( 
    IWbemRefresher * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemRefresher_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemRefresher_INTERFACE_DEFINED__ */


#ifndef __IWbemHiPerfEnum_INTERFACE_DEFINED__
#define __IWbemHiPerfEnum_INTERFACE_DEFINED__

/* interface IWbemHiPerfEnum */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemHiPerfEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2705C288-79AE-11d2-B348-00105A1F8177")
    IWbemHiPerfEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds,
            /* [size_is][in] */ IWbemObjectAccess **apObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [length_is][size_is][out] */ IWbemObjectAccess **apObj,
            /* [out] */ ULONG *puReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAll( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemHiPerfEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemHiPerfEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemHiPerfEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemHiPerfEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddObjects )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds,
            /* [size_is][in] */ IWbemObjectAccess **apObj);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveObjects )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjects )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [length_is][size_is][out] */ IWbemObjectAccess **apObj,
            /* [out] */ ULONG *puReturned);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemHiPerfEnumVtbl;

    interface IWbemHiPerfEnum
    {
        CONST_VTBL struct IWbemHiPerfEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemHiPerfEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemHiPerfEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemHiPerfEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemHiPerfEnum_AddObjects(This,lFlags,uNumObjects,apIds,apObj)	\
    (This)->lpVtbl -> AddObjects(This,lFlags,uNumObjects,apIds,apObj)

#define IWbemHiPerfEnum_RemoveObjects(This,lFlags,uNumObjects,apIds)	\
    (This)->lpVtbl -> RemoveObjects(This,lFlags,uNumObjects,apIds)

#define IWbemHiPerfEnum_GetObjects(This,lFlags,uNumObjects,apObj,puReturned)	\
    (This)->lpVtbl -> GetObjects(This,lFlags,uNumObjects,apObj,puReturned)

#define IWbemHiPerfEnum_RemoveAll(This,lFlags)	\
    (This)->lpVtbl -> RemoveAll(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_AddObjects_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [size_is][in] */ long *apIds,
    /* [size_is][in] */ IWbemObjectAccess **apObj);


void __RPC_STUB IWbemHiPerfEnum_AddObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_RemoveObjects_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [size_is][in] */ long *apIds);


void __RPC_STUB IWbemHiPerfEnum_RemoveObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_GetObjects_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [length_is][size_is][out] */ IWbemObjectAccess **apObj,
    /* [out] */ ULONG *puReturned);


void __RPC_STUB IWbemHiPerfEnum_GetObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_RemoveAll_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemHiPerfEnum_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemHiPerfEnum_INTERFACE_DEFINED__ */


#ifndef __IWbemConfigureRefresher_INTERFACE_DEFINED__
#define __IWbemConfigureRefresher_INTERFACE_DEFINED__

/* interface IWbemConfigureRefresher */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemConfigureRefresher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c92-516b-11d1-aea6-00c04fb68820")
    IWbemConfigureRefresher : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddObjectByPath( 
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddObjectByTemplate( 
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ IWbemClassObject *pTemplate,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRefresher( 
            /* [in] */ IWbemRefresher *pRefresher,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lId,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEnum( 
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszClassName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemHiPerfEnum **ppEnum,
            /* [unique][in][out] */ long *plId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemConfigureRefresherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemConfigureRefresher * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemConfigureRefresher * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemConfigureRefresher * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddObjectByPath )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *AddObjectByTemplate )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ IWbemClassObject *pTemplate,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *AddRefresher )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemRefresher *pRefresher,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWbemConfigureRefresher * This,
            /* [in] */ long lId,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AddEnum )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszClassName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemHiPerfEnum **ppEnum,
            /* [unique][in][out] */ long *plId);
        
        END_INTERFACE
    } IWbemConfigureRefresherVtbl;

    interface IWbemConfigureRefresher
    {
        CONST_VTBL struct IWbemConfigureRefresherVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemConfigureRefresher_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemConfigureRefresher_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemConfigureRefresher_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemConfigureRefresher_AddObjectByPath(This,pNamespace,wszPath,lFlags,pContext,ppRefreshable,plId)	\
    (This)->lpVtbl -> AddObjectByPath(This,pNamespace,wszPath,lFlags,pContext,ppRefreshable,plId)

#define IWbemConfigureRefresher_AddObjectByTemplate(This,pNamespace,pTemplate,lFlags,pContext,ppRefreshable,plId)	\
    (This)->lpVtbl -> AddObjectByTemplate(This,pNamespace,pTemplate,lFlags,pContext,ppRefreshable,plId)

#define IWbemConfigureRefresher_AddRefresher(This,pRefresher,lFlags,plId)	\
    (This)->lpVtbl -> AddRefresher(This,pRefresher,lFlags,plId)

#define IWbemConfigureRefresher_Remove(This,lId,lFlags)	\
    (This)->lpVtbl -> Remove(This,lId,lFlags)

#define IWbemConfigureRefresher_AddEnum(This,pNamespace,wszClassName,lFlags,pContext,ppEnum,plId)	\
    (This)->lpVtbl -> AddEnum(This,pNamespace,wszClassName,lFlags,pContext,ppEnum,plId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddObjectByPath_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [string][in] */ LPCWSTR wszPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext,
    /* [out] */ IWbemClassObject **ppRefreshable,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddObjectByPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddObjectByTemplate_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [in] */ IWbemClassObject *pTemplate,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext,
    /* [out] */ IWbemClassObject **ppRefreshable,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddObjectByTemplate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddRefresher_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemRefresher *pRefresher,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddRefresher_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_Remove_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ long lId,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemConfigureRefresher_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddEnum_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [string][in] */ LPCWSTR wszClassName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext,
    /* [out] */ IWbemHiPerfEnum **ppEnum,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemConfigureRefresher_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WbemLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("4590f811-1d3a-11d0-891f-00aa004b2e24")
WbemLocator;
#endif

EXTERN_C const CLSID CLSID_WbemContext;

#ifdef __cplusplus

class DECLSPEC_UUID("674B6698-EE92-11d0-AD71-00C04FD8FDFF")
WbemContext;
#endif

EXTERN_C const CLSID CLSID_UnsecuredApartment;

#ifdef __cplusplus

class DECLSPEC_UUID("49bd2028-1523-11d1-ad79-00c04fd8fdff")
UnsecuredApartment;
#endif

EXTERN_C const CLSID CLSID_WbemClassObject;

#ifdef __cplusplus

class DECLSPEC_UUID("9A653086-174F-11d2-B5F9-00104B703EFD")
WbemClassObject;
#endif

EXTERN_C const CLSID CLSID_MofCompiler;

#ifdef __cplusplus

class DECLSPEC_UUID("6daf9757-2e37-11d2-aec9-00c04fb68820")
MofCompiler;
#endif

EXTERN_C const CLSID CLSID_WbemStatusCodeText;

#ifdef __cplusplus

class DECLSPEC_UUID("eb87e1bd-3233-11d2-aec9-00c04fb68820")
WbemStatusCodeText;
#endif

EXTERN_C const CLSID CLSID_WbemBackupRestore;

#ifdef __cplusplus

class DECLSPEC_UUID("C49E32C6-BC8B-11d2-85D4-00105A1F8304")
WbemBackupRestore;
#endif

EXTERN_C const CLSID CLSID_WbemRefresher;

#ifdef __cplusplus

class DECLSPEC_UUID("c71566f2-561e-11d1-ad87-00c04fd8fdff")
WbemRefresher;
#endif

EXTERN_C const CLSID CLSID_WbemObjectTextSrc;

#ifdef __cplusplus

class DECLSPEC_UUID("8D1C559D-84F0-4bb3-A7D5-56A7435A9BA6")
WbemObjectTextSrc;
#endif
#endif /* __WbemClient_v1_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_wbemcli_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0000_v0_0_s_ifspec;

/* interface __MIDL_itf_wbemcli_0109 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0109_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0109_v0_0_s_ifspec;

#ifndef __IWbemRawSdAccessor_INTERFACE_DEFINED__
#define __IWbemRawSdAccessor_INTERFACE_DEFINED__

/* interface IWbemRawSdAccessor */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemRawSdAccessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1e2d759-cabd-11d3-a11b-00105a1f515a")
    IWbemRawSdAccessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [out] */ ULONG *puSDSize,
            /* [length_is][size_is][out][in] */ byte *pSD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [size_is][in] */ byte *pSD) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemRawSdAccessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemRawSdAccessor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemRawSdAccessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemRawSdAccessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemRawSdAccessor * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [out] */ ULONG *puSDSize,
            /* [length_is][size_is][out][in] */ byte *pSD);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemRawSdAccessor * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [size_is][in] */ byte *pSD);
        
        END_INTERFACE
    } IWbemRawSdAccessorVtbl;

    interface IWbemRawSdAccessor
    {
        CONST_VTBL struct IWbemRawSdAccessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemRawSdAccessor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemRawSdAccessor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemRawSdAccessor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemRawSdAccessor_Get(This,lFlags,uBufSize,puSDSize,pSD)	\
    (This)->lpVtbl -> Get(This,lFlags,uBufSize,puSDSize,pSD)

#define IWbemRawSdAccessor_Put(This,lFlags,uBufSize,pSD)	\
    (This)->lpVtbl -> Put(This,lFlags,uBufSize,pSD)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemRawSdAccessor_Get_Proxy( 
    IWbemRawSdAccessor * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uBufSize,
    /* [out] */ ULONG *puSDSize,
    /* [length_is][size_is][out][in] */ byte *pSD);


void __RPC_STUB IWbemRawSdAccessor_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemRawSdAccessor_Put_Proxy( 
    IWbemRawSdAccessor * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uBufSize,
    /* [size_is][in] */ byte *pSD);


void __RPC_STUB IWbemRawSdAccessor_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemRawSdAccessor_INTERFACE_DEFINED__ */


#ifndef __IWbemShutdown_INTERFACE_DEFINED__
#define __IWbemShutdown_INTERFACE_DEFINED__

/* interface IWbemShutdown */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWbemShutdown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b7b31df9-d515-11d3-a11c-00105a1f515a")
    IWbemShutdown : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Shutdown( 
            /* [in] */ LONG uReason,
            /* [in] */ ULONG uMaxMilliseconds,
            /* [in] */ IWbemContext *pCtx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemShutdownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemShutdown * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemShutdown * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemShutdown * This);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IWbemShutdown * This,
            /* [in] */ LONG uReason,
            /* [in] */ ULONG uMaxMilliseconds,
            /* [in] */ IWbemContext *pCtx);
        
        END_INTERFACE
    } IWbemShutdownVtbl;

    interface IWbemShutdown
    {
        CONST_VTBL struct IWbemShutdownVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemShutdown_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemShutdown_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemShutdown_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemShutdown_Shutdown(This,uReason,uMaxMilliseconds,pCtx)	\
    (This)->lpVtbl -> Shutdown(This,uReason,uMaxMilliseconds,pCtx)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemShutdown_Shutdown_Proxy( 
    IWbemShutdown * This,
    /* [in] */ LONG uReason,
    /* [in] */ ULONG uMaxMilliseconds,
    /* [in] */ IWbemContext *pCtx);


void __RPC_STUB IWbemShutdown_Shutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemShutdown_INTERFACE_DEFINED__ */


#ifndef __IWbemCallStatus_INTERFACE_DEFINED__
#define __IWbemCallStatus_INTERFACE_DEFINED__

/* interface IWbemCallStatus */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IWbemCallStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4212dc47-142e-4c6c-bc49-6ca232dd0959")
    IWbemCallStatus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCallStatus( 
            /* [in] */ ULONG uFlags,
            /* [in] */ LCID lLocale,
            /* [out] */ HRESULT *phRes,
            /* [out] */ BSTR *pszMsg,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *pObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemCallStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemCallStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemCallStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemCallStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallStatus )( 
            IWbemCallStatus * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ LCID lLocale,
            /* [out] */ HRESULT *phRes,
            /* [out] */ BSTR *pszMsg,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *pObj);
        
        END_INTERFACE
    } IWbemCallStatusVtbl;

    interface IWbemCallStatus
    {
        CONST_VTBL struct IWbemCallStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemCallStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemCallStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemCallStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemCallStatus_GetCallStatus(This,uFlags,lLocale,phRes,pszMsg,riid,pObj)	\
    (This)->lpVtbl -> GetCallStatus(This,uFlags,lLocale,phRes,pszMsg,riid,pObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemCallStatus_GetCallStatus_Proxy( 
    IWbemCallStatus * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ LCID lLocale,
    /* [out] */ HRESULT *phRes,
    /* [out] */ BSTR *pszMsg,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID *pObj);


void __RPC_STUB IWbemCallStatus_GetCallStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemCallStatus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0118 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tag_WMI_OBJ_TEXT
    {	WMI_OBJ_TEXT_CIM_DTD_2_0	= 1,
	WMI_OBJ_TEXT_WMI_DTD_2_0	= 2,
	WMI_OBJ_TEXT_WMI_EXT1	= 3,
	WMI_OBJ_TEXT_WMI_EXT2	= 4,
	WMI_OBJ_TEXT_WMI_EXT3	= 5,
	WMI_OBJ_TEXT_WMI_EXT4	= 6,
	WMI_OBJ_TEXT_WMI_EXT5	= 7,
	WMI_OBJ_TEXT_WMI_EXT6	= 8,
	WMI_OBJ_TEXT_WMI_EXT7	= 9,
	WMI_OBJ_TEXT_WMI_EXT8	= 10,
	WMI_OBJ_TEXT_WMI_EXT9	= 11,
	WMI_OBJ_TEXT_WMI_EXT10	= 12,
	WMI_OBJ_TEXT_LAST	= 13
    } 	WMI_OBJ_TEXT;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0118_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0118_v0_0_s_ifspec;

#ifndef __IWbemObjectTextSrc_INTERFACE_DEFINED__
#define __IWbemObjectTextSrc_INTERFACE_DEFINED__

/* interface IWbemObjectTextSrc */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemObjectTextSrc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bfbf883a-cad7-11d3-a11b-00105a1f515a")
    IWbemObjectTextSrc : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ BSTR *strText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFromText( 
            /* [in] */ long lFlags,
            /* [in] */ BSTR strText,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemClassObject **pNewObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectTextSrcVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemObjectTextSrc * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemObjectTextSrc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemObjectTextSrc * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            IWbemObjectTextSrc * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ BSTR *strText);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFromText )( 
            IWbemObjectTextSrc * This,
            /* [in] */ long lFlags,
            /* [in] */ BSTR strText,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemClassObject **pNewObj);
        
        END_INTERFACE
    } IWbemObjectTextSrcVtbl;

    interface IWbemObjectTextSrc
    {
        CONST_VTBL struct IWbemObjectTextSrcVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectTextSrc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectTextSrc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectTextSrc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectTextSrc_GetText(This,lFlags,pObj,uObjTextFormat,pCtx,strText)	\
    (This)->lpVtbl -> GetText(This,lFlags,pObj,uObjTextFormat,pCtx,strText)

#define IWbemObjectTextSrc_CreateFromText(This,lFlags,strText,uObjTextFormat,pCtx,pNewObj)	\
    (This)->lpVtbl -> CreateFromText(This,lFlags,strText,uObjTextFormat,pCtx,pNewObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectTextSrc_GetText_Proxy( 
    IWbemObjectTextSrc * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject *pObj,
    /* [in] */ ULONG uObjTextFormat,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ BSTR *strText);


void __RPC_STUB IWbemObjectTextSrc_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectTextSrc_CreateFromText_Proxy( 
    IWbemObjectTextSrc * This,
    /* [in] */ long lFlags,
    /* [in] */ BSTR strText,
    /* [in] */ ULONG uObjTextFormat,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IWbemClassObject **pNewObj);


void __RPC_STUB IWbemObjectTextSrc_CreateFromText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectTextSrc_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0120 */
/* [local] */ 

typedef struct tag_CompileStatusInfo
    {
    long lPhaseError;
    HRESULT hRes;
    long ObjectNum;
    long FirstLine;
    long LastLine;
    DWORD dwOutFlags;
    } 	WBEM_COMPILE_STATUS_INFO;

typedef /* [v1_enum] */ 
enum tag_WBEM_COMPILER_OPTIONS
    {	WBEM_FLAG_CHECK_ONLY	= 0x1,
	WBEM_FLAG_AUTORECOVER	= 0x2,
	WBEM_FLAG_WMI_CHECK	= 0x4,
	WBEM_FLAG_CONSOLE_PRINT	= 0x8,
	WBEM_FLAG_DONT_ADD_TO_LIST	= 0x10,
	WBEM_FLAG_SPLIT_FILES	= 0x20,
	WBEM_FLAG_CONNECT_REPOSITORY_ONLY	= 0x40
    } 	WBEM_COMPILER_OPTIONS;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0120_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0120_v0_0_s_ifspec;

#ifndef __IMofCompiler_INTERFACE_DEFINED__
#define __IMofCompiler_INTERFACE_DEFINED__

/* interface IMofCompiler */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IMofCompiler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6daf974e-2e37-11d2-aec9-00c04fb68820")
    IMofCompiler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CompileFile( 
            /* [string][in] */ LPWSTR FileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompileBuffer( 
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE *pBuffer,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBMOF( 
            /* [string][in] */ LPWSTR TextFileName,
            /* [string][in] */ LPWSTR BMOFFileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMofCompilerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMofCompiler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMofCompiler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMofCompiler * This);
        
        HRESULT ( STDMETHODCALLTYPE *CompileFile )( 
            IMofCompiler * This,
            /* [string][in] */ LPWSTR FileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CompileBuffer )( 
            IMofCompiler * This,
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE *pBuffer,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBMOF )( 
            IMofCompiler * This,
            /* [string][in] */ LPWSTR TextFileName,
            /* [string][in] */ LPWSTR BMOFFileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);
        
        END_INTERFACE
    } IMofCompilerVtbl;

    interface IMofCompiler
    {
        CONST_VTBL struct IMofCompilerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMofCompiler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMofCompiler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMofCompiler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMofCompiler_CompileFile(This,FileName,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CompileFile(This,FileName,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#define IMofCompiler_CompileBuffer(This,BuffSize,pBuffer,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CompileBuffer(This,BuffSize,pBuffer,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#define IMofCompiler_CreateBMOF(This,TextFileName,BMOFFileName,ServerAndNamespace,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CreateBMOF(This,TextFileName,BMOFFileName,ServerAndNamespace,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMofCompiler_CompileFile_Proxy( 
    IMofCompiler * This,
    /* [string][in] */ LPWSTR FileName,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [string][in] */ LPWSTR User,
    /* [string][in] */ LPWSTR Authority,
    /* [string][in] */ LPWSTR Password,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);


void __RPC_STUB IMofCompiler_CompileFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMofCompiler_CompileBuffer_Proxy( 
    IMofCompiler * This,
    /* [in] */ long BuffSize,
    /* [size_is][in] */ BYTE *pBuffer,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [string][in] */ LPWSTR User,
    /* [string][in] */ LPWSTR Authority,
    /* [string][in] */ LPWSTR Password,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);


void __RPC_STUB IMofCompiler_CompileBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMofCompiler_CreateBMOF_Proxy( 
    IMofCompiler * This,
    /* [string][in] */ LPWSTR TextFileName,
    /* [string][in] */ LPWSTR BMOFFileName,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);


void __RPC_STUB IMofCompiler_CreateBMOF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMofCompiler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0122 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tag_WBEM_INFORMATION_FLAG_TYPE
    {	WBEM_FLAG_SHORT_NAME	= 0x1,
	WBEM_FLAG_LONG_NAME	= 0x2
    } 	WBEM_INFORMATION_FLAG_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0122_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0122_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\tests\wlbsconfig.txt ===
//+----------------------------------------------------------------------------
//
// File:	 wlbsconfig.h
//
// Module:	 Network Load Balancing 
//
// Description: Internal APIs for cluster configuration.  Thes APIs are internal 
//              to WLBS team only, and no plan backward compatability.
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:	 fengsun Created    3/2/00
//
//+----------------------------------------------------------------------------



#ifndef _WLBSCONFIG_H
#define _WLBSCONFIG_H

#ifdef __cplusplus
extern "C" {
#endif

#include "wlbsctrl.h"

/* Maximum lengths of parameter strings. */

#define WLBS_MAX_VIRTUAL_NIC     256
#define WLBS_MAX_CLUSTER_NIC     256
#define WLBS_MAX_NETWORK_ADDR    17
#define WLBS_MAX_CL_IP_ADDR      17
#define WLBS_MAX_CL_NET_MASK     17
#define WLBS_MAX_DED_IP_ADDR     17 
#define WLBS_MAX_DED_NET_MASK    17
#define WLBS_MAX_NETWORK_ADDR    17
#define WLBS_MAX_LICENSE_KEY     20
#define WLBS_MAX_DOMAIN_NAME     100
#define WLBS_MAX_BDA_TEAM_ID     40

/* Port group rule - used in registry parameters.
   NOTE! do not access value marked with I. These are for internal use only. */

#pragma pack(1)

typedef struct
{
    DWORD       start_port,             /* Starting port number. */
                end_port;               /* Ending port number. */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       code;                 /* I: Unique rule code. */
#else
    DWORD       Private1;               // Do not change these field directly
#endif

    DWORD       mode;                   /* Filtering mode. */
    DWORD       protocol;               /* WLBS_TCP, WLBS_UDP or WLBS_TCP_UDP */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       valid;                /* I: For rule management in user mode. */
#else
    DWORD       Private2;               // Do not change these field directly
#endif

    union
    {
        struct
        {
            DWORD       priority;       /* Mastership priority: 1..32 or 0 for
                                           not-specified. */
        }           single;             /* Data for single server mode. */
        struct
        {
            WORD        equal_load;     /* TRUE - Even load distribution. */
            WORD        affinity;       /* WLBS_AFFINITY_... */
            DWORD       load;           /* Percentage of load to handle
                                           locally 0..100. */
        }           multi;              /* Data for multi-server mode. */
    }           mode_data;              /* Data for appropriate port group mode. */
}
WLBS_OLD_PORT_RULE, * PWLBS_OLD_PORT_RULE;

/* Structure to hold the bi-directional affinity registry settings. */
typedef struct _CVY_BDA {
    WCHAR       team_id[WLBS_MAX_BDA_TEAM_ID + 1];  /* The team ID - MUST be a GUID. */
    ULONG       active;                             /* On write, this flag determines whether to create BDATeaming key - BDA on/off switch. */
    ULONG       master;                             /* Boolean indication of master status. */
    ULONG       reverse_hash;                       /* Sets direction of hashing - forward (normal) or reverse. */
} WLBS_BDA, PWLBS_BDA;

typedef struct
{
    TCHAR       virtual_ip_addr [WLBS_MAX_CL_IP_ADDR + 1]; /* Virtual IP Address */
    DWORD       start_port,             /* Starting port number. */
                end_port;               /* Ending port number. */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       code;                 /* I: Unique rule code. */
#else
    DWORD       Private1;               // Do not change these field directly
#endif

    DWORD       mode;                   /* Filtering mode. */
    DWORD       protocol;               /* WLBS_TCP, WLBS_UDP or WLBS_TCP_UDP */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       valid;                /* I: For rule management in user mode. */
#else
    DWORD       Private2;               // Do not change these field directly
#endif

    union
    {
        struct
        {
            DWORD       priority;       /* Mastership priority: 1..32 or 0 for
                                           not-specified. */
        }           single;             /* Data for single server mode. */
        struct
        {
            WORD        equal_load;     /* TRUE - Even load distribution. */
            WORD        affinity;       /* WLBS_AFFINITY_... */
            DWORD       load;           /* Percentage of load to handle
                                           locally 0..100. */
        }           multi;              /* Data for multi-server mode. */
    }           mode_data;              /* Data for appropriate port group mode. */
}
WLBS_PORT_RULE, * PWLBS_PORT_RULE;

#pragma pack()


#ifdef __cplusplus
typedef struct __declspec(dllexport)
#else
typedef struct 
#endif
{
    /* public - can be modified by clients of this API */
    DWORD       host_priority;          /* Host priority ID. */
    DWORD       alive_period;           /* Period for sending "I am alive" messages
                                           in milliseconds. */
    DWORD       alive_tolerance;        /* How many "I am alive" messages can be
                                           missed from other servers before assuming
                                           that the host is dead. */
    DWORD       num_actions;            /* Number of actions per allocation. */
    DWORD       num_packets;            /* number of packets per allocation. */
    DWORD       num_send_msgs;          /* Number of heartbeats per allocation. */
    DWORD       install_date;           /* Install time stamp, used to create a unique code for the host. */
    DWORD       rct_port;               /* Remote control UDP port. */
    DWORD       rct_enabled;            /* TRUE - remote control enabled. */
    DWORD       cluster_mode;           /* TRUE - join cluster on boot. */
    DWORD       dscr_per_alloc;         /* Number of connection tracking
                                           descriptor per allocation. */
    DWORD       max_dscr_allocs;        /* Maximum number of connection tracking
                                           descriptor allocations. */
    DWORD       mcast_support;          /* TRUE - multicast mode,
                                           FALSE - unicast mode */
    DWORD       mask_src_mac;           /* TRUE - Mangle source MAC address to
                                           prevent switch learning. FALSE -
                                           cluster is on a hub, optimizes switch
                                           performance by re-enabling learning. */

    TCHAR       cl_mac_addr [WLBS_MAX_NETWORK_ADDR + 1];
                                        /* Cluster MAC address. */
    TCHAR       cl_ip_addr [WLBS_MAX_CL_IP_ADDR + 1];
                                        /* Cluster IP address. */
    TCHAR       cl_net_mask [WLBS_MAX_CL_NET_MASK + 1];
                                        /* Netmask for cluster IP. */
    TCHAR       ded_ip_addr [WLBS_MAX_DED_IP_ADDR + 1];
                                        /* Dedicated IP address or "" for none. */
    TCHAR       ded_net_mask [WLBS_MAX_DED_NET_MASK + 1];
                                        /* Netmask for dedicated IP address
                                           or "" for none */
    TCHAR       domain_name [WLBS_MAX_DOMAIN_NAME + 1];
                                        /* FQDN of the cluster. */

    //
    // IGMP support
    //
    BOOL        fIGMPSupport; // whether to send IGMP join periodically
    WCHAR       szMCastIpAddress[WLBS_MAX_CL_IP_ADDR + 1]; // multicast IP
    BOOL        fIpToMCastIp; // whether to generate multicast IP from cluster IP
    
    WLBS_BDA    bda_teaming;

#ifdef __cplusplus
#ifndef WLBSAPI_INTERNAL_ONLY

    //
    // private - should be treated as opaque 
    //
    // Do not change these field directly
    //
    private:

#endif
#endif


    /* obtained from the registry */

    DWORD       i_parms_ver;            /* I: Parameter structure version. */
    DWORD       i_verify_date;          /* I: Encoded install time stamp. */
    DWORD       i_rmt_password;         /* I: Remote maintenance password. */
    DWORD       i_rct_password;         /* I: Remote control password (use
                                            WlbsSetRemotePassword to set this
                                            value). */
    DWORD       i_num_rules;            /* I: # active port group rules (changed
                                            through WlbsAddPortRule and
                                            WlbsDelPortRule routines). */
    DWORD       i_cleanup_delay;        /* I: Dirty connection cleanup delay in
                                            milliseconds, 0 - delay. */
    DWORD       i_scale_client;         /* I: Legacy parameter. */
    DWORD       i_mcast_spoof;          /* I: TRUE - Provide ARP resolution in
                                            multicast mode. FALSE - clients
                                            will rely on static ARP entries. */
    DWORD       i_convert_mac;          /* I: TRUE - automatically generate MAC
                                            address based on cluster IP
                                            address in UI. */
    DWORD       i_ip_chg_delay;         /* I: Delay in milliseconds to block
                                            outgoing ARPs while IP address
                                            change is in process. */
    DWORD       i_nbt_support;          /* I: TRUE - NBT cluster name support
                                            enabled. */
    DWORD       i_netmon_alive;         /* I: TRUE - pass heartbeat messages
                                            to the protocols (netmon). */
    DWORD       i_effective_version;    /* I: Effective version of NLB */

    /* strings */

    TCHAR       i_virtual_nic_name [WLBS_MAX_VIRTUAL_NIC + 1];
                                        /* I: Virtual NIC name or GUID. */
//    TCHAR       cluster_nic_name [WLBS_MAX_CLUSTER_NIC + 1];
                                        /* I: Cluster NIC name or GUID. */
    TCHAR       i_license_key [WLBS_MAX_LICENSE_KEY + 1];
                                      /* I: Legacy parameter. */

    WLBS_PORT_RULE  i_port_rules [WLBS_MAX_RULES];
                                        /* I: Port rules (changed
                                              through WlbsAddPortRule and
                                              WlbsDelPortRule routines). */
    /* computed */

    DWORD       i_max_hosts;            /* Legacy parameter. */
    DWORD       i_max_rules;            /* Legacy parameter. */
//    DWORD       i_expiration;           /* Legacy parameter. */
//    DWORD       i_ft_rules_enabled;     /* Legacy parameter. */
//    DWORD       version;              /* Legacy parameter. */

    DWORD i_dwReserved;
}
WLBS_REG_PARAMS, * PWLBS_REG_PARAMS;



/* API commands for WlbsFormatMessage */
typedef enum
{
    CmdWlbsAddPortRule,
    CmdWlbsAddressToName,
    CmdWlbsAddressToString,
    CmdWlbsAdjust,
    CmdWlbsCommitChanges,
    CmdWlbsDeletePortRule,
    CmdWlbsDestinationSet,
    CmdWlbsDisable,
    CmdWlbsDrain,
    CmdWlbsDrainStop,
    CmdWlbsEnable,
    CmdWlbsFormatMessage,
    CmdWlbsGetEffectiveVersion,
    CmdWlbsGetNumPortRules,
    CmdWlbsEnumPortRules,
    CmdWlbsGetPortRule,
    CmdWlbsInit,
    CmdWlbsPasswordSet,
    CmdWlbsPortSet,
    CmdWlbsQuery,
    CmdWlbsReadReg,
    CmdWlbsResolve,
    CmdWlbsResume,
    CmdWlbsSetDefaults,
    CmdWlbsSetRemotePassword,
    CmdWlbsStart,
    CmdWlbsStop,
    CmdWlbsSuspend,
    CmdWlbsTimeoutSet,
    CmdWlbsWriteReg
}
WLBS_COMMAND;

extern BOOL WINAPI WlbsFormatMessage
(
    DWORD           error,      /* IN  - WLBS_... or WSA... return value. */
    WLBS_COMMAND    command,    /* IN  - Which routine returned the value. */
    BOOL            cluster,    /* IN  - TRUE - command was issued on entire
                                         cluster, FALSE - single host. */
    WCHAR*          messagep,   /* IN  - Pointer to user-allocated buffer. */
    PDWORD          lenp        /* IN  - Buffer size.
                                   OUT - The required buffer size if the current
                                         size is insufficient */
);
/*
    Return character string describing specified WLBS API return code. Note that
    message will depend on the command which returned the code and if it was
    issued in cluster-wide or single-host mode.

    returns:
        TRUE  => Message formatted successfully.
        FALSE => Bad error code (lenp will contain 0 on exit) or buffer is not
                 big enough to contain entire string (lenp will contain required
                 buffer size on exit).
*/

/* Support routines: */


extern DWORD WINAPI WlbsResolve
(
    const WCHAR*           address     /* IN  - Internet host name or IP address in
                                         dotted notation. */
);
/*
    Resolve Internet host name to its IP address. This routine can also be
    used to convert a string containing an IP address in dotted notation to a
    value that can be passed to cluster control routines.

    returns:
        0               => failed to resolve host name.
        <address>       => IP address corresponding to the specified address.
                           This value can be used in subsequent calls to
                           cluster control routines.
*/


extern BOOL WINAPI WlbsAddressToString
(
    DWORD           address,    /* IN  - IP address. */
    WCHAR*           buf,        /* OUT - Character buffer for resulting
                                         string. */
    PDWORD          lenp        /* IN  - Buffer size in characters.
                                   OUT - Characters written or required buffer
                                         size. */
);
/*
    Convert IP address to a string in dotted notation.

    returns:
        TRUE            => Successfully converted. lenp contains number of
                           character written.
        FALSE           => Buffer too small. lenp contains required buffer size
                           including terminating NULL character.
*/


extern BOOL WINAPI WlbsAddressToName
(
    DWORD    address,    /* IN  - IP address. */
    WCHAR*          buf,        /* OUT - Character buffer for resulting
                                         string. */
    PDWORD          lenp        /* IN  - Buffer size in characters.
                                   OUT - Characters written or required buffer
                                         size. */
);
/*
    Resolve IP address to Internet host name.

    returns:
        TRUE            => Successfully converted. lenp contains number of
                           character written.
        FALSE           => Buffer too small. lenp contains required buffer size
                           including terminating NULL character.
*/


/******************************************************************************
    Cluster host configuration routines. Note that in current implementation,
    cluster and host parameters need to be set to WLBS_LOCAL_CLUSTER and
    WLBS_LOCAL_HOST.
 ******************************************************************************/


extern DWORD WINAPI WlbsReadReg
(
    DWORD           cluster,    /* IN  - WLBS_LOCAL_CLUSTER */
    PWLBS_REG_PARAMS reg_data   /* OUT - Registry parameters */
);
/*
    Read WLBS registry data.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => reg_data is NULL
    WLBS_REG_ERROR   => Error reading from the registry

    Local:

    WLBS_OK          => Registry parameters successfully read.

    Remote:

    WLBS_LOCAL_ONLY  => This call is implemented for local only operation.
*/


extern DWORD WINAPI WlbsWriteReg
(
    DWORD           cluster,    /* IN  - WLBS_LOCAL_CLUSTER */
    const PWLBS_REG_PARAMS reg_data   /* IN  - Registry parameters. */
);
/*
    Write WLBS registry data.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.
    WLBS_REG_ERROR   => Error accessing the registry.

    Local:

    WLBS_OK          => Registry parameters successfully written.

    Remote:

    WLBS_LOCAL_ONLY  => This call is implemented for local only operation.
*/


extern DWORD WINAPI WlbsCommitChanges
(
    DWORD           cluster    /* IN  - WLBS_LOCAL_CLUSTER */
);
/*
    Write WLBS registry data.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.

    Local:

    WLBS_OK          => Changes have been successfully applied.
    WLBS_BAD_PARAMS  => Registry parameters were not accepted by the driver.
                        Reload was not performed
    WLBS_REBOOT      => Reboot required in order for config changes to
                        take effect.
    WLBS_IO_ERROR    => Error while writing to the driver.
    WLBS_REG_ERROR   => Error while trying to write MAC address changes to the
                        registry

    Remote:

    WLBS_LOCAL_ONLY  => This call is implemented for local only operation.
*/


extern DWORD WINAPI WlbsSetDefaults
(
    PWLBS_REG_PARAMS       reg_data     /* OUT - Default values    */
);
/*
    Fills in the reg_data structure with default values

    returns:

    WLBS_INIT_ERROR    => Error initializing control module. Cannot perform
                          control operations.

    WLBS_BAD_PARAMS    => Invalid structure

    Local:

    WLBS_OK            => Structure was filled in with the default values.

    Remote:

    WLBS_LOCAL_ONLY    => This call is implemented for local only operation.

*/

/******************************************************************************
    Registry parameter manipulation routines. Note that these routines operate
    WLBS_REG_PARAMS structure filled out by calling WlbsReadReg. Some parameters
    can be manipulated directly. Please make sure to use manipulation routines
    for the ones that they are provided for.
 ******************************************************************************/

extern DWORD WINAPI WlbsGetEffectiveVersion
(
    const PWLBS_REG_PARAMS reg_data   /* IN  - Registry parameters. */
);
/*
    Returns the effective version of cluster 

    returns:

    CVY_VERSION_FULL  => There is atleast one port rule that has a specific 
                         vip associated with it 
                        
    CVY_VERSION_LOWEST_CLIENT_FULL  => All port rules have the "All vip" associated with them

*/


extern DWORD WINAPI WlbsGetNumPortRules
(
    const PWLBS_REG_PARAMS reg_data   /* IN  - Registry parameters. */
);
/*
    Returns number of port rules currently in the parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.

    1...WLBS_MAX_RULES

*/


extern DWORD WINAPI WlbsEnumPortRules
(
    const PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    PWLBS_PORT_RULE rules,      /* OUT - Array of port rules. */
    PDWORD          num_rules   /* IN  - Size of rules array.
                                   OUT - Number of rules retrieved. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few rules that fit
                                         in the array are returned. */
);
/*
    Enumerate all port rules in the list of port rules in parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.
    WLBS_TRUNCATED   => All port rules did not fit into specified array.
    WLBS_OK          => Rule has been successfully retrieved.

*/


extern DWORD WINAPI WlbsGetPortRule
(
    const PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    DWORD           vip,        /* IN  - Virtual IP Address of the port rule to retreive */
    DWORD           port,       /* IN  - Port, which rule to retrieve. */
    PWLBS_PORT_RULE rule        /* OUT - Port rule. */
);
/*
    Retrieve port rule containing specified port from the list of port rules
    in parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.

    WLBS_OK          => Rule has been successfully retrieved.
    WLBS_NOT_FOUND   => Port not found among port rules.

*/


extern DWORD WINAPI WlbsAddPortRule
(
    PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    const PWLBS_PORT_RULE rule        /* IN  - Port rule to add. */
);
/*
    Add port to list of port rules in parameter structure.

    returns:

    WLBS_INIT_ERROR     => Error initializing control module. Cannot perform
                           control operations.
    WLBS_BAD_PARAMS     => Registry parameter structure is invalid.
    WLBS_OK             => Rule has been successfully added.
    WLBS_PORT_OVERLAP   => Port rule overlaps with existing port rule.
    WLBS_BAD_PORT_PARAMS=> Invalid port rule parameters.
    WLBS_MAX_PORT_RULES => Maximum number of port rules already reached.
*/


extern DWORD WINAPI WlbsDeletePortRule
(
    PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    DWORD           vip,        /* IN  - Virtual IP Address of the port rule to retreive */
    DWORD           port        /* IN  - Port, which rule to delete. */
);
/*
    Remove port rule containing specified port from the list of port rules
    in parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.
    WLBS_NOT_FOUND   => Port not found among port rules.

    WLBS_OK          => Rule has been successfully deleted.

*/


extern DWORD WINAPI WlbsSetRemotePassword
(
    PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    const WCHAR*           password   /* IN  - Password or NULL for no password. */
);
/*
    Set remote password code to encrypted value of the specified password.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.

    WLBS_OK          => Password has been successfully set.

*/

DWORD WINAPI WlbsNotifyConfigChange(DWORD cluster);


#ifdef __cplusplus
} /* extern "C" */
#endif


#endif _WLBSCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\provider\tests\notes.txt ===
TO DO LIST
----------
0. Change ip address to bind string in connect-dialog, first ping for the 
   address, etc...
1. Switch from events to using two mutexes
2. Explicitly report the following errors
    - other update pending
    - netcfg write lock held
3. Report true client description, not "unspecified WMI client."
4. Use resource strings
6. Use internal constants for error codes and literal strings
7. Remove client-side dependency on wlbsctrl.dll.

4. Hook into nlb manager

4. Add "partial-update" semantics 
    New parameter:  BOOL PartialUpdate
    OPTIONAL parameter Generation -- if specified, we'll verify that the
    Generation matches the current generation.
    parameter value NULL === don't change
    port rules: require the following property on each PR for partial-updates:
        action=[ADD|DELETE|UPDATE]
    IP addresses: require the ip address to be prefixed by
        "add:" "delete:" or "update:" (latter for changing subnet masks)
        
        UI:
        add:{10.1.1.3}
        delete:{10.1.1.3, 255.0.0}
        update:{10.1.1.3, 255.0.0}

    EXAMPLE 1:
        PartialUpdate=TRUE
        PortRules="action=update ip=10.1.1.3 start=80 end=288 weight=20 ...."

    EXAMPLE 2:
        PartialUpdate=TRUE
        IpAddresses="add:10.0.0.1/255.255.0.0", "delete:10.0.0.2"
        Generation=8
9. Follow up on WMI SDK errors -- DaveIce
    WBEM_E_SERVER_NOT_FOUND -- where is this defined.
    0x800706bf -- no definition in any header (and I checked in
            index2a with interesting results), recoverable error.
    0x80070767 -- no defn
    0x80070005 -- no defn

control ip=x port=y start/stop/enable/disable/nop
------------------------------------                

"Persistant" state for a particular NIC is mainained as a (for now)
volatile key under  SYSTEM\CurrentControlSet\Services\WLBS\ConfigurationHistory\{GUID}
Under this GUID, there is are a set of reg-binary values (which are lighter weight than keys). They value-name is the generation number, and the value is a struct concatenated with a log. The struct has the format:
typedef struct {
    UINT Version;
    UINT HeaderSize;
    UINT Generation;
    UINT CompletionCode;
    UINT OffsetToLog;       // from start of this structure
    UINT LogSize;           // 0 == no log
    UINT Reserved1;
    UINT Reserved2;
};


    swprintf (reg_path, L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\
\Interface\\%s",
            szAdapterGuid);

    RegOpenKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L,
                           fReadOnly? KEY_READ : KEY_WRITE, & hKey);

    return hKey;
       status = RegOpenKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L,
                          KEY_QUERY_VALUE, & key);
HKEY hKey;

    status = RegCreateKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L, L"",
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS, NULL, & key, & disp);


[HLKM\SYSTEM\CurrentControlSet\Services\WLBS\ConfigurationHistory]
       [{EBE09517-07B4-4E88-AAF1-E06F5540608B}]
            Generation (DWORD)
            [PendingOperation]
                Generation (DWORD)
                ThreadId (String)
            [Completions]
                1   Binary
                2   Binary

Mutex Name
NLB_D6901862{EBE09517-07B4-4E88-AAF1-E06F5540608B}
HANDLE CreateMutex(
  LPSECURITY_ATTRIBUTES lpMutexAttributes,
                       // pointer to security attributes
  BOOL bInitialOwner,  // flag for initial ownership
  LPCTSTR lpName       // pointer to mutex-object name
);



04/10/2001  JosephJ Mutex vs Event vs Registry
    Finally settled on a named event because:
    1. Needs to recover from a process crash (so can't use registry)
    2. Needs to be cross process -- so must used named object
    3. Need to "acquire" in one thread and "release" in another -- so can't
        use mutex.
    
    The auto-reset event is normally signalled. It is non-signalled whenever
    an operation is pending. It is manually set back to signalled whenever
    the operation is completed.
bp tprov!NlbConfigurationUpdate__DoUpdate 
bp tprov!NlbConfigurationUpdate__s_AsyncUpdateThreadProc 
-------
Sean, you can do this semi-automatically by creating a new and temporary tree just for the merging process.

So for example, create a new directory driver2 in the private tree (or your scratch depot) and checkin the latest netvbl2  checked-in sources..
From one enlistment, open the files for edit, and copy over your BDA privates (but dont checkin).
From a second enlistment, open the files for edit, and copy over the latest privates from the private tree (this has virtual cluster support), and check this in.
Go back to the first enlistment and resolve.
-------

04/15/2001  JosephJ lightweight wmi wrapper.

    Connect-to-machine
    Get-object

04/15/2001  JosephJ Consider using IWbemServices::ExecQuery

04/25/2001 JosephJ Adding/removing IP addresses.
    Binding/Re-binding NLB:
        we require the explicit list of IP addresses to be specified.
        We'll check that
        (a) dedicated ip address, if specified, is first.
        (b) cluster_vip and subnet mask match are present.
        (c) vips for any per-ip port rules are present.
    We honor the specified order of ip addresses.
    
    Unbinding NLB:
        We set the specified list of ip addresses.
        If NULL, we'll switch the adapter to DHCP, which could take a while.

z:\nt\net\wlbs\api\obj\i386;Z:\nt\net\wlbs\nlbmgr\provider\tests\obj\i386;symsrv*symsrv.dll*\\symbols\symbols

10.1.x.x {A25EF21A-4634-4B15-AE7F-6825DFAD9FA6}
10.0.x.x {AD4DA14D-CAAE-42DD-97E3-5355E55247C2}

Utility function wrappers for exec method

CfgUtilGetWmiObjectInstance(szRoot, szPropertyName, szPropertyValue)
CfgUtilGetWmiRelPath(szRoot, szPropertyName, szPropertyValue)
CfgUtilGetWmiInputInstance(
    IN szRoot,
    IN szPropertyName,   "NlbsNic"
    IN szPropertyValue,  "guid"
    IN szMethod          "EnableStatic"
    OUT IInputInstance,
    OUT szRelPath,

GetMethodInstanceByProperty
SetupInParams --> 
ExecMethod
GetOutParams

bp tprov!CfgUtilGetWmiInputInstanceAndRelPath


WBEMSTATUS
IWbemSvc *pSvc

WBEMSTATUS
ConnectToWMi(
    MACHINE-NAME, // NULL == Don't us WMI, "" == local, 
    szAdminPassword, // OPTIONAL
    szAdminDomain, // OPTIONAL
    szNicGuid,
    info
);

WBEMSTATUS
GetClusterConfig(
    MACHINE-NAME, // NULL == Don't us WMI, "" == local, 
    szAdminPassword, // OPTIONAL
    szAdminDomain, // OPTIONAL
    szNicGuid,
    info
    );


05/12/2001  JosephJ
To do:
1. Remove NlbState property, add BOOL NlbBound property
2. Get rid of SubnetMask string array -- Instead place subnet mask
   after ip address: "10.1.1.1/255.255.255.255"
3. Demonstrate fundamental plumbing is working:
     x Modify existing test to optionally go through WMI
        -- get rid of nlbhost class (nlbhost.cpp)
     x Verify we can get partial input and output parameters for GetConfig
     x Implement and test GetClusterConfig with partial params
     x Re-test local (non-wmi) functionality, including bind/unbind, change IPs
     x Implement QueryUpdate and UpdateConfig
     x test UpdateConfig with partial params
     - Implement and test getting port rules information
     - Implement and test settings port rule information
     - Implement and test getting full information 
     - Implement and test setting full information 
4. Hook into nlb manager

4. Add "partial-update" semantics 
    New parameter:  BOOL PartialUpdate
    OPTIONAL parameter Generation -- if specified, we'll verify that the
    Generation matches the current generation.
    parameter value NULL === don't change
    port rules: require the following property on each PR for partial-updates:
        action=[ADD|DELETE|UPDATE]
    IP addresses: require the ip address to be prefixed by
        "add:" "delete:" or "update:" (latter for changing subnet masks)
        
        UI:
        add:{10.1.1.3}
        delete:{10.1.1.3, 255.0.0}
        update:{10.1.1.3, 255.0.0}

    EXAMPLE 1:
        PartialUpdate=TRUE
        PortRules="action=update ip=10.1.1.3 start=80 end=288 weight=20 ...."

    EXAMPLE 2:
        PartialUpdate=TRUE
        IpAddresses="add:10.0.0.1/255.255.0.0", "delete:10.0.0.2"
        Generation=8
5. Switch from events to using two mutexes
6. Explicitly report the following errors
    - other update pending
    - netcfg write lock held
7. Use resource strings
8. Use internal constants for error codes and literal strings
9. Follow up on WMI SDK errors -- DaveIce
    WBEM_E_SERVER_NOT_FOUND -- where is this defined.
    0x800706bf -- no definition in any header (and I checked in
            index2a with interesting results), recoverable error.
    0x80070767 -- no defn
    0x80070005 -- no defn
                
!sympath .\obj\i386;symsrv*symsrv.dll*\\symbols\symbols
bp tprov!CfgUtilGetWmiInputInstanceAndRelPath
bp tprov!NlbHostGetConfiguration

05/17/2001  JosephJ more on partial updates

        // Determine if this is a partial or full update.
        // If partial update, we allow a subset of cluster configuration
        // parameters to be specified, but allow only a restricted set
        // of update operations.
        //
        // Disallowed partial update operations:
        //  - Transitions between bound and !bound 
        //  - Currently bound  but nlb parameters are invalid
        //
        // Some allowed partial updates:
        //  - Modifying IP address lists
        //  - Modifying cluster / dedicated addresses/subnets
        //  - Modifying existing portrules
        //  - Adding/deleting port rules
        //
Successfully connected to NLB on JOSEPHJ4E...

Going call QueryConfigurationUpdateStatus...

QueryConfigurationUpdateStatus returns successfully

Connecting to NLB on JOSEPHJ4E ...

Successfully connected to NLB on JOSEPHJ4E...
Going call QueryConfigurationUpdateStatus...
QueryConfigurationUpdateStatus returns successfully
Connecting to NLB on JOSEPHJ4E ...

Sample framework provier...
C:\Microsoft Platform SDK\Samples\SysMgmt\WMI\VC\FrameworkProv
http://msdn.microsoft.com/library/default.asp?URL=/library/psdk/wmisdk/framework_1h0l.htm
Static methods -- implementation
    Declaring static: add "static" in mof ... [Implemented, static, ...]
    Them in the ExecMethod class, simply ignore the Instance parameter.

Static methods -- calling
A method may or may not be static. Static methods are designated by the presence of the Static qualifier on their definition. Static methods are executed against a class, not a particular instance of that class. The path specified to a method execution API for a static method must, therefore, be a class name. Non-static methods are executed against a particular instance of a class. The path specified to a method execution for a non-static method must, therefore, be an instance path

Nadir Ahmed
Nadir Ahmed
PortRules= {
ip=1.1.1.1 protocol=TCP start=80 end=288 mode=SINGLE,
ip=1.1.1.1 protocol=TCP start=80 end=288 mode=SINGLE,
ip=1.1.1.1 protocol=TCP start=80 end=288 mode=SINGLE
}
NA = {
    1.1.1.1/255.255.0.0,
}

read_string_array(out ppStrings,):
    look for { [xxx,]* }
wmiupdate
nlbcfg wmiupdate>AdapterGuid={....}

nlbcfg \\asdasdfasdfsadf /u:ntdev\josephj *
enter password: *****
nlbcfg> wmiupdate {asdfasdfasdfsdf}
nlbcfg wmiupdate> niclist 
   blah
   blah
   blah
niclist> wmiupdate {guid}
   blah 
   blah 
   blah
nlbcfg wmiupdate> NLBBound=true
nlbcfg wmiupdate> PortRules = {
ip=1.1.1.1 protocol=TCP start=80 end=288 mode=SINGLE
}
nlbcfg wmiupdate>


while(1)
{
    Parse();
}

if (!scanf("%ws")==1)
{
    if (!strncmpi(...., wmiupdate))
    return ParseWmiUpdate());
}

SPECIFICATION --- COMMAND LINE
nlbcfg [machinename|-|.] [command_and_parameters] [options]
machinemame                 machine name
                        OR IP address
                        OR fully-qualified machine name
-                       Indicates not to use WMI -- call lower-level functions
                        directly
.                       Connect to local machine using wmi
command_and_parameters      AdapterList
                        OR  Update [adapter_guid]
                        OR  Help

options                 /u domain\user [password | *]

Examples:
nlbcfg . AdapterList
nlbcfg . al
nlbcfg - Update
nlbcfg josephj4c /u:ntdev\josephj *

SPECIFICATION --- SHELL
AdapterList             al
Update                  u
Quit                    q
Help                    h, ?


AdapterGuid             ag
PartialUpdate           pu
NetworkAddresses        na
NLBBound                nb
ClusterNetworkAddress   cna
ClusterName             cn
TrafficMode             tm
PortRules               pr
HostPriority            hp
DedicatedNetworkAddress dna
ClusterModeOnStart      cmos
RemoteControlEnabled    rce
Password                p


                [IN] String  ClientDescription,
                [IN] String  AdapterGuid,
                [IN] uint32  Generation,
                [IN] Boolean PartialUpdate,
                [IN] String  NetworkAddresses[], // "10.1.1.1/255.255.255.255"
                [IN] Boolean NLBBound,
                [IN] String  ClusterNetworkAddress, // "10.1.1.1/255.0.0.0"
                [IN] String  ClusterName,
                [IN] String  TrafficMode, // UNICAST MULTICAST IGMPMULTICAST
                [IN] String  PortRules[],
                [IN] uint32  HostPriority,
                [IN] String  DedicatedNetworkAddress, // "10.1.1.1/255.0.0.0"
                [IN] Boolean ClusterModeOnStart,
                [IN] Boolean RemoteControlEnabled,
                [IN] String  Password,
                [OUT] uint32 NewGeneration,
                [OUT] String Log


nlbcfg> update {guid}
Enter Adapter GUID: {guid}
NLB Configuration for Adapter xxxx xxxx:
Enter updated configuration, or type help for more information.
nlbcfg update> cna=10.0.0.1/255.255.255.0
nlbcfg update> cna=10.0.0.1/255.255.255.0
nlbcfg update> cna=10.0.0.1/255.255.255.0
nlbcfg update> .
Proposed new configuration:
.....
Enter y to confirm:
nlbcfg update> y
Going to perform update
...

....
complete
Reading configuration:
.......
Enter updated configuration or other command.
nlbcfg update>q


----------------
07/22/2001  JosephJ Reorganization
--------
Identifying dependencies on wlbsctrl.dll
    
    CfgUtilInitialize(VOID);
    CfgUtilDeitialize(VOID);
    
    CfgUtilGetNlbConfig <- touches registry
    CfgUtilSetNlbConfig <- touches registry
    
    CfgUtilControlCluster <- touches driver
    
    Following have no side effects....
    
    CfgUtilInitializeParams
    CfgUtilsAnalyzeNlbUpdate
    CfgUtilGetPortRules
    CfgUtilSetPortRules

To Do:
-----
Create two libs:
    1. CfgUtil -- current CfgUtil* functionality
        Used by: NlbClient (below) and nlbmprov.dll (wmi provider)
        - Dynamically loads wlbsctrl.dll
        - Works with W2K wlbsctrl.dll too!
        - Unlike current version, it does NOT use the 
          wlbsctrl!CWlbsControl class.
    2. NlbClient -- current NlbHost functionality (client side wmi wrappers)
        Used by: tprov.exe, nlbmprov.dll

tprov.exe -- continues to live where it is -- because it directly compiles
        the update functionality. Update functionality lives where it
        is (in nlbmprov.dll) because we want to use it on w2k as-is (i.e.
        xp nlbmprov.dll can be used as-is on W2K.


cfgutil.h   cfgutil.lib
nlbclient.h nlbclient.lib

08/08/2001  JosephJ got this error from tracing. Turned out to because I'd
 defined  USE_MSVCRT=1  building cfgutil.lib but NOT when building tprov.exe.
    Linking Executable - obj\i386\tprov.exe for i386
    cfgutil.lib(cfgutil.obj) : warning LNK4217: locally defined symbol _wcslen
    imported in function "void __stdcall WPP_SF_S(unsigned __int64,unsigned
    short,struct _GUID const *,unsigned short const *)"
    (?WPP_SF_S@@YGX_KGPBU_GUID@@PBG@Z)
    link() : error LNK1218: warning treated as error; no output file generated

09/10/2001  JosephJ added  ..\..\..\util\$(O)\wlbsutil.lib \
    This is because cfgutil.lib needs it
    and the latter needs it for a trivial
    reason (see nlbmgr\cfgutillib\notes.txt) which we should consider
    cleaning up so we don't need to do this.

09/27/2001  JosephJ tprov in demo mode:
    dot cheese-a u back1
    nb=t
    na={10.0.0.1/255.0.0.0, 10.0.0.11/255.0.0.0}
    dna=10.0.0.1/255.0.0.0
    cna=10.0.0.11/255.0.0.0

09/27/2001  THings to change for multi-value initial state, and persist state.
o
    add new cmos state "suspend" or "s"
    parse_cluster_mode_on_start:
             parse new initial state
             PersistSuspend = true/false
    display_config2: display new stuff
    
    You can test by commenting out the // NlbHostFake line in tprov.cpp
    To test
        dot cheese-x u nic1
    TO update, type a final "." character, followed by y to actually do
    the update.

10/09/2001  JosephJ Support for control cluster.

    Added support for control cluster. To use, use the "update" command.

    The sub command is "control".

    Format:
        control [start|stop|drain|query]  <- adapter wide
        control port=xxx [ip=yyy] [enable|disable|drain|query] <- port specific

    Samples:
        control start
        control ip=10.0.0.1 port=80 enable
        control query
        control port=80 query
        control ip=10.0.0.1 port=80 query

    At this point, to actually enable this, #define NEWSTUFF in function
    tprov.cpp: parse_control.

01/01/2002  JosephJ Changes to make TPROV.EXE  build again
    sources: added a line ..\log_msgs.mc
    tprov.cpp: added a global ghModule (referred to by ..\updatecfg.cpp)

04/15/2002 JosephJ
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\utilities\tracing\readme.txt ===
Sample batch files for generating and viewing wmi event tracing logs

For information on WMI event tracing, goto  http://coreos/tech/tracing/

dolog.cmd           Enables a real-time log called "mylog" for the guids in
                    wlbs.ctl
dofmt.cmd           Monitors the above log in real time
wlbs.ctl            Lists the provider guids to log

Note: the underlying utilities, tracelog.exe and tracefmt.exe, and tracepdb.exe
are available
under the idw directory (eg \\winbuilds\release\main\usa\latest.idw\x86fre\bin\idw).
The sources for these utilities are under nt\sdktools\trace
You need to copy trace*.*, which includes a supporting dll.



I've created two trace GUIDs, one for regular (for configuration related info
and errors) and one for packets (for packets, including heartbeats).
We can add/modify this list as required, but I think this should suffice.

I've defined macros TRACE_CRIT (for critical, including most errors),
TRACE_INFO, TRACE_VERB and TRACE_ALL (max verbosity), as well as TRACE_HB
(for heartbeat) and TRACE_TCPCTRL (for tcp control packets).

The Guids are defined in \net\inc\wlbsparm.h. The macros are defined
in the tracewpp.ini file under each component directory.
 

I've added one or two trace statements to each instrumented component
you can now add more trace statements we should trace all key entry points,
errors, etc. I've deliberately not mapped existing debugprintfs to trace
statements as I want these trace statements to be enabled in retail builds
so we should take the time to decide what we want to trace.

 

Real output by console app tracefmt.exe:

[0]0000.0000::04/02/2001-06:17:21.537 [driver]Recv HB from host 0
     << this is a trace of an actual heart beat message from the specified
     <<  host. I'll add more info to this msg later.

[0]0000.0000::04/02/2001-06:17:22.537 [driver]Recv HB from host 0

[0]0670.06C4::04/02/2001-06:17:22.944 [api]->WlbsInit(product=<null>,version=51,reserved=00000000)

[0]0670.06C4::04/02/2001-06:17:23.131 [api]<-WlbsInit returns 1010

[0]0000.0000::04/02/2001-06:17:23.537 [driver]Recv HB from host 0

[0]0000.0000::04/02/2001-06:17:24.537 [driver]Recv HB from host 0

 

The above output has nicely merged the output from the driver and a user-mode
dll [api].

 

The wmi event tracing support added by means of the WPP macros are some
of the most bizarre and brilliant use of pre-processing I've ever seen!
You can see the final result for each source file by defining adding
USER_C_FLAGS=$(USER_C_FLAGS) -P to your sources file, resulting the
preprocessed files being created with an .i extension. It's amazing to see how
multiple trace flags spanning multiple GUIDs are handled.


NOTE: For tracing to nlb stuff in NETCFGX.DLL you need to specially build
    NETCFGX.DLL
Do the following
    cd  net\config\netcfg\dll
    sd edit sources
    add the following line to the end of the sources file:
    RUN_WPP= -dll
    build netcfgx.dll


There's been problems with tracefmt recognizing the auto-generated tmf files.
Until that's resolved, use tracepdb to generate these files from the
pdb files.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\nlbmgr\exe2\notes.txt ===
To Do:
    1. Resolve vi problem.
    551410  NLB:nlbmgr: Can't create new cluster via nlbmgr uitility
    571762  NLB does not properly filter dedicated IP address traffic
    585280  NLBMgr fails when cluster instance has nlb was bound but not cfg

    5. See if we can call RegWriteParams BEFORE binding.
    2. 535616  memory leak running remove from view
    587508  Wmiprvse.exe is using too much memory cause exception
    599165  nlbmgr:remember host properties when update is pending
    591265  VERIFIER STOP 0000000A: unexpected exception raised in DLL entry



    3. HostID analysis -- look for duplicates, missing ones and partitions
    1. Queue calls to handle-engine-event and handle them in the main proc.
        - checkin, but make it disabled...
        - remove ALL (or almost ALL) calls to ProcesMsgQueue.
    Remove most occurrances of calls to ProcessMsgQueue in engine.cpp --
    replace by calls in document.cpp for log and handleengineevent.
    4. Make GetConfig, UpdateCfg, etc, properly fill out the WBEM_NOT_FOUND
       value on error.
    5. Fake: Implement fHidden flag  in NIC, set it in debugger in between
         operations, and make sure mgr behaves propertly when guids disappear
         (kerry problem). Make sure not-found interfaces are DELETED.
    7. Make sure error is logged if operation doesn't succeed properly.
       -- on operation timeout, do a final read of properties and report any
          misconfig.
    11. Change MsgBox to a Dlg -- in reporting problems, changes, etc.
    12. Error messages -- make them more actionable.
    13. Add list of changes to log.
    14. Investigate nlbmgr's resource usage.

-------------------
- Error checking:
    CfgUtilAnalyze is failing because ded-ip matches cluster-ip -- but the
    UI simply reports invalid cluster specification.
    We need to do our own checks (in the UI) and report all discrepencies to
    the UI itself.

- Cluster properties:
    -- define the right primitivies for analysis
    -- always show a specific host's properties
    -- if update failed, cluster properties will pick up the 1st
       host's properties that match.

- Implement DetailsView.UpdateInterfaceInCluster

- Cleanup log (including details lparam)
- Host-properties:
        good defaults and preserve existing for host-port-rule-priorities.
- Add support for multiple VIPSs:
    See "10/02/2001  JosephJ managing multiple VIPs"
    Some outstanding issues:
    - Create 10.0.0.11 cluster on cheese-x, try to add cheese-y to it --
        fails because it complains of invalid cluster spec.
    - In badcluster case, we don't populate the dedicated ip, then complain?

- IP Address database (IP_INFO)
- More corner cases
  DeleteInterface: if host is in an unreachable state, then prompt user and
        remove.
- Handle keeping track of pending operations
- Update:
    - display partial log output
- Add to FakeNlbHostXxx apis -- update should return async.
- Update phase 2:
    - Send proper status updates and log entries.
    - Do update in background thread.
    (Look for "Pending" under   09/19/2001 JosephJ Notes to self)
- Deal with refreshes *while* there is pending activity.
- Log: add critical section to document class -- protect changes
  to log and credentials.
- Fix waitcuror in AddHost ??
- Do basic checking -- same host can't be twice in same cluster,
   same cluster IP can't be in two clusters, etc.
    keep a global map of cluster IPs to interface IDs (see 09/14/2001
    log entry for details).
    - Put up message box warning the user that they are adding a NIC that has
         a  different cluster IP -- for all versions, especially Add host.
-  Port Rules: track available port-rule-priorities, put correct defaults
         in apply_cluster_configuration and in the UI.
    - Preserve host-specific information as far as possible.
    - Report to log on error.
- Implement rudimentary analyze functionality -- at least cluster IPs.
- Encrypt passwords
- Fix localization problems.
--------
- Add automatically querying for other cluster members.
- Get rid of netcfg stuff in application.cpp -- use cfgutil stuff instead.
Later:
- Deal with HOST NAME change while running NLB manager.
- Deal with Adapters coming and going while running NLB manager.
- Deal with upgrades and/or re-installs of adapters -- GUIDs change but
  friendly name can be the same.
- Track update generation -- warn if there's been a change.

RELEASE NOTES:
    Port rules:
        Mode == Single -- priorities aren't created right.
        If you change a start/end ports, host-specific settings are lost.
        Mode = multiple -- if you hit "OK" in host-portrule-edit, then
            "equal" gets changed to 50.

- documentation -- see "Documentation" below.
- figure out how to de-initialize cleanly -- not clear how to do this with
  MFC apps -- use destructor
    


------------
JosephJ 5/19/01 Code paths for main operations

1. Create New Cluster, add a host
2. Connect to existing cluster
3. Modify existing cluster's properties.

05/19/2001  JosephJ
Cluster node in treview is created in several places --
    LeftView::OnWorldNewCluster.
LeftView::OnWorldConnect
LeftView::OnWorldConnectIndirect
The name is set there (currently the cluster ip address)

Application Initialization
---------------------------

05/20/2001  JosephJ
When implementing the disclaimer dialog box, which has a checkbox...
DDX macros don't work in the context of the Application::InitInstance
function. So I had to use the CWnd::IsDlgButtonChecked macro.
This works. HOWEVER the DDX macros now work too -- so I changed something
and now it works.

JosephJ 07/20/2001  Main aspects of new code
--------------------------------------------
INTERFACE (keys: GUID, friendly-name)
HOST (keys: machine-name (if known), connection ip)
CLUSTER (Keys: cluster name, cluster ip, internally-generated name)

INTERFACE operations:
   Add/remove/refresh/update-props
HOST operations:
    Add/remove/refresh/update-props
CLUSTER operations:
    Validate/Add-host/remove-host/update-props


Reorganization operations
-------------------------
Goals:
1. nlbmprov.dll can run on both w2k and xp
2. nlbmgr.exe can ron on w2k and xp and a client
3. tprov and nlbmgr share code in a common lib

List of existing functionality:
1. Utilities that wrap wlbsctrl functionality
2. WMI client utilities
3. WMI server utilities
4. Self-contained utilities

NLB manager considers a cluster to consist of a list of interfaces. An interface is idenified by (Machine, Adapter-GUID). The adapter's friendly name is used to
resolve the adapter if the GUID doesn't exist (as can happen on a clean install). The friendly name is also used to identify the adapter in the UI.

NLB manager does NOT index a cluster by the cluster IP address. NLB Manager supports having individual interfaces in the same cluster  be configured with different cluster IP addresses. Likewise, the same cluster IP can occur on interfaces from different clusters. Of course these are cases of mis-configured clusters and NLB manager will report them as such and provides the user with UI to bring the clusters into a consistant state.


NLB manager keeps track of the list of hosts it is managing. These hosts can
be in an unavailable state (either due to connectivity problems or because the host has been shut down or re-purposed into some different configuration).

The authoratitative state of NLB configuration data resides on the hosts. NLB manager's version of the cluster configuration is purely a cache.

NLB manager persists the following information:
1. List of machines to manage, and how to get to them (connectivity information)
2. List of clusters managed (since cluster is defined as a list of interfaces, the list of interfaces associated with a cluster is persisted).
When NLB manager is launched, it will retrieve this list of machines and
clusters and attempt to connect to these machines and enumerate the adapters
looking for the persisted list of interfaces. It will suitably display any
missing hosts or interfaces (with appropriate icons). If it discovers hosts
have been ADDED it will automically add them to the view. If it discovers
that interfaces have
been removed it will still list those interfaves, but with an appropriate
icon to indicate that that interface apperas to be no longer part of the
cluster. The user has the option of removing (from view) such interfaces.


Initialization: From scratch, manage existing cluster.
1. User selects "Connect to Existing"
2. UI: bring up the connect/select-interface dialog.
3. Engine: connect to host, suck up information on ALL adapters in the
   specified host and enter the info into the engine's data structures.
   Issue: may need to do some resolving if info already exists.
4. UI: allow user to select the interface (only allow user to select interfaces
   which are bound to NLB.
5. Engine: Create a cluster with the specified host. Query the host for other
   cluster members. Get their machine-names (XP), host IDs and dedicated IPs.
   Create PLACEHOLDERS for those in the cluster data structure. Attempt to
   connect to each of these remote hosts. If we can't (either because we can't
   ping their machinenames (if specified) or dedicated-ip (if specified) or
   neither is specified we call back to UI to get a connection-string or to
   retry. For hosts that we DO connect to, we follow process #3 and add
   the interfaces to the cluster.
6. UI: creates cluster node in tree view, updates status
   (callbacks from Engine), bring up connect-to-host page for any additional
   hosts discovered.

   
Initialization: From scratch, create new cluster.
1. UI: User selects "Configure New Cluster"
2. UI: #2 above, but modified to indicate we're creating a new cluster.
3. Engine: #3 above
4. UI: allow user to select interface (only allow user to select interfaces
   which are NOT bound to existing NLB manager clusters that NLB Manager
   already knows about). Bring up the cluster and host pages and let the user
   enter all the relevant information.
5. Engine: Configure the cluster on the specified host. If NLB HAS been bound
    (even if the rest failed), create a cluster node. Call back to UI for
   onging status.
6. UI: creates cluster node in tree view, update status.

Add host to existing cluster
1. UI: let user select cluster-add host.
2. UI: #2 above, but modified to indicate "select interface to add to cluster".
3. Engine: #3 above
4. UI: Allow user to select any interface except ones that NLB manager already
   knows as being part of another cluster. Bring up warning dialog if
   NLB is already bound to the specified interface with different cluster-ip
   address.
5. Engine: #5 above.
6. UI: Add node to tree view.

Refresh:
1. Go through host list, refreshing everything, updateing status and
   picking up new hosts.


Retreiving persisted state on startup:
1. Create shell host and cluster data structures and tree view.
2. Do a refresh.


Fixing up broken cluster:
1. Engine: maintains a fMisconfigured flag for the cluster and each interface.
2. UI: reflects this by icon state
3. UI: has "Analyze" menu option -- will re-do analysis
4. Engine: Analyze -- runs through existing cache, spitting out problems it
   finds to the log.
5. UI: Fixing cluster -- same as changing cluster properties.
--------------------------------------------------

08/03/2001  JosephJ Gutting of NLBMGR.EXE -- Phase I (DONE)
    - Removed references to externall nlbmgr
      libraries (wmibase etc) and "reaching-over" includes, copying over
      files as required.
    - Removed calls to wmi-client side code.
    - Ensures that the resultant exe builds and comes up ok.

08/03/2001  JosephJ Differences between NLBMGR UI and NETCFGUI
    Cluster Properties Page -- OK
    Port Rules page (from cluster and host)
        - VIP missing
        - Port rule description missing
        - Note that load and priority are displayed differently by design
    Host Properties
       - MGR has a NIC combobox -- replace by static text FriendlyName
       - "Unique Host ID" change to "Unique host identifier"
       - New initial-host-state and persist-suspend UI.
    That's it!

08/03/2001  JosephJ Where do we store the "cluster" version of config info?
    Engine will keep a "cluster" version of the config info, along with which
    host it obtained it from and when, and whether/not it is modified but not
    committed.

08/03/2001  JosephJ Gutting of NLBMGR.EXE -- Phase II
    - Replacd different flavors of port rules by a single flavor. (DONE)
    - Get rid of tiny classes and their files -- consolidate. (DONE)

08/03/2001  JosephJ Moving to new infrastructure Phase I
    - define update methods to the LeftView and RightView
    - replace all places where these views are updated directly by calls
      to the engine (and migrate the code that updates the views to
      the update methods in LaftView and RightView) and callback handlers in
      the document.
      
08/04/2001  JosephJ Partial xml schema
Its just hit me what a big bang for the buck it is to add a Load Template support to NLB to load a partial description of the configuration properties.
This template will contain NO host-specific information (no priorities, load weights, dedicated IPs). It will optionally contain the cluster-ips, cluster-mode, and port-rules. For vip-specific portrules, the vip for each port rule is optional.
What this lets us do (because theres no host-specific information, and things like cluster IP addresses are optional) is that we or others can publish template descriptions for things like load balance FTP traffic, etc  and that xml file can be loaded AS IS into the UI! 

08/04/2001  JosephJ New save/restore semantics...
NLB Manager will let you load a list of hosts  this is a simple text file listing hosts (ip addresses or machine names or FQDNs) one per line. This can be done via the command line or from the application menu. 
NLB Manager will attempt to connect to each of these hosts, reporting to the user if it cannot connect (thus reporting #1 in the list above).
It will suck up information about ALL clusters installed on these hosts, and add them to the cluster tree view based on their IP address (there will be a special placeholder for 0.0.0.0 ip addresses, which can happen).
 It will report any inconsistencies in configuration or in the list of hosts visible from each node (this addresses #2). Note that if a botched update operation results in incorrect IP address assignments we will not detect this  well just report the hosts under multiple clusters. However, read on 
[Well do this if we have time to spare, the prospect is unlikely, but schedules can change] NLB Manager will support a validate against snapshot command  this command will take an xml file which has the information structured as I indicate below, and validates the current view against it.
The Validate operation simply reports any discrepancies against the current view.
There will be a save snapshot command to save the snapshot. 

08/04/2001  JosephJ Add to server-side: ping ip addresses
    We should have an fNew flag, which if set, server-side will
    (a) check that the ip address is not already on any other nic in the
        machine
    (b) ping all the cluster ip addresses to make sure that they do not
        exist.

08/05/2001  Josephj Documentation: things to document
    - top level classes: application, document, engine, leftview, logview, etc.
    - flow of control for typical operations: 
        - program initialization
        - adding new cluster
        - reading filelist
        - etc.
    - list of dialogs.
    - how to add a dialog.
    - how columns are added to the log and details list views.
    - how to add/remove those little "+"es in the tree view.
    - how to edit icons, issues with editing icons.
    - dialog operation -- DDX, message map, etc.
    - wait cursors: CCmdTarged::BeginWaitCursor/EndWaitCursor/RestoreWaitCursor
    - Menu operation -- dropdown and pop up -- how to enable/disable them,
        how to add items.
        See: 12/15/2001  How to add a menu item
    - ENGINEHANDLE -- its properties, design motivations.
    - Tab order -- see  09/17/2001 tab order entry.
    - Cool listctrl functions FindItem and GetNextItem
    - use of type-specific context-sensitive map:
        ConnectDialog::OnHelpInfo
    - Splitter windows and the organization of views -- see
        10/27/2001  JosephJ Note on the layout of the views
    - Choosing good host-specific default properties when adding
      a new host to an existing cluster -- see
        10/25/2001  JosephJ Host and Port priorities.
    - Managing virtual IP addresses, preserving order of ip addresses
        on individual hosts as far as possible -- see
        10/07/2001  JosephJ managing multiple VIPs
    - Hooking TreeView double-click and key strokes -- see
        11/13/2001  JosephJ Hooking TreeView double-click and key strokes

08/05/2001  JosephJ Location of msvc sample icons...
C:\Program Files\Microsoft Visual Studio\Common\Graphics\Icons

08/05/2001  JosephJ setting the background on the icons
    The icons I 

08/06/2001  JosephJ feedback from team at today's NLB meeting
    1. Change "not bound to NLB" to be "NLB not bound to adapter"
    2. Make Host Parameters go before Port Rules, to conform to cfgui.
    3. Don't bother with restricting users from moving from page-to-page --
       just gray out the OK button until all parameters are filled in and put
       up an informational message box when focus is removed from the pane
_snwprintf

       while leaving incomplete information specified.
    4. Rename or get rid of "Event ID" -- Maybe change it to "Event No."
    5. If we implement "check for duplicate IP in the network", then do this 
       AFTER the dedicated IP has been set up.

d:\nt\net\wlbs\nlbmgr\exe2\obj\i386;symsrv*symsrv.dll*\\symbols\symbols
nlbmgr2!LeftView__OnWorldNewCluster

ChildEBP RetAddr  Args to Child              
0006e57c 77d47797 00000040 40010444 010369e8 ntdll!KiUserExceptionDispatcher+0x4 (FPO: [2,0,0]) [D:\xpclient\base\ntos\rtl\i386\userdisp.asm @ 206]
0006e7d8 77357f04 010369e8 0006e7fc 00000000 USER32!RealDefWindowProcWorker+0x119 (FPO: [Non-Fpo])
0006e818 77357edb 0009d030 0009d2d8 00130958 COMCTL32!_CreatePageDialog+0x1e (FPO: [Non-Fpo]) [d:\xpclient\shell\comctl32\v5\prpage.c @ 575]
0006e838 77357d20 0009d030 0009d2d8 00130958 COMCTL32!_CreatePage+0x3d (FPO: [Non-Fpo]) [d:\xpclient\shell\comctl32\v5\prpage.c @ 708]
0006ea4c 77358f10 00130958 00000001 77d45944 COMCTL32!PageChange+0x99 (FPO: [2,124,3]) [d:\xpclient\shell\comctl32\v5\prsht.c @ 1909]
0006ee00 77358f2e 00130958 00000143 0009d030 COMCTL32!InitPropSheetDlg+0x9a2 (FPO: [2,230,3]) [d:\xpclient\shell\comctl32\v5\prsht.c @ 1562]
0006ea4c 77358f10 00130958 00000001 77d45944 COMCTL32!PropSheetDlgProc+0x463 (FPO: [Non-Fpo]) [d:\xpclient\shell\comctl32\v5\prsht.c @ 3461]
0006ee30 5ad94828 00000110 5adbd7b8 00000006 COMCTL32!InitPropSheetDlg+0x9a2 (FPO: [2,230,3]) [d:\xpclient\shell\comctl32\v5\prsht.c @ 1562]
0006ee44 5ad93c89 00aea3b8 00aea3a8 77357445 uxtheme!FindDdpHandler+0x18 (FPO: [3,0,0]) [d:\xpclient\shell\themes\uxtheme\handlers.cpp @ 561]
0006ee64 77d43a50 00130958 00000110 000b09c6 uxtheme!CThemeWnd__Release+0xe (FPO: [0,0,2]) [d:\xpclient\shell\themes\uxtheme\nctheme.cpp @ 1460]
0006eda8 77d43ee7 00aea3a8 00000000 0000000a USER32!_InternalCallWinProc+0x1b [D:\xpclient\windows\core\ntuser\client\i386\callproc.asm @ 102]
ffffffec 00000000 00000000 00000000 00000000 USER32!GetWindowLongW+0x49 (FPO: [Non-Fpo]) [d:\xpclient\windows\core\ntuser\client\cltxt.h @ 430]


:w
\\netvbl2\sources\shell\comctl32\v5\prpage.c

EditPropSheetTemplate:
        ...
        pdwStyle = &pDlgTemplate->style;
        ...
        *pdwStyle = dwNewStyle;

    It looks like this pDlgTemplate->style is not WRITEABLE, even though
    it appears readable...
        0:000> dd 010369e8 l 1
        010369e8  80c800c0
        0:000> ed 010369e8 0
                           ^ Memory access error in 'ed 010369e8 0'

    Looks like it's pointing into read-only resource data...
        0:000> dc 010369e8 
        010369e8  80c800c0 00000000 00000013 00f00000  ................
        010369f8  000000d7 00430000 0075006c 00740073  ......C.l.u.s.t.
        01036a08  00720065 00500020 00720061 006d0061  e.r. .P.a.r.a.m.
        01036a18  00740065 00720065 00000073 004d0008  e.t.e.r.s.....M.
        01036a28  00200053 00680053 006c0065 0020006c  S. .S.h.e.l.l. .
        01036a38  006c0044 00000067 50000007 00000000  D.l.g......P....
        01036a48  00070007 005400e2 ffff03e8 00430080  ......T.......C.
        01036a58  0075006c 00740073 00720065 00260020  l.u.s.t.e.r. .&.
        0:000> dc
        01036a68  00500049 00430020 006e006f 00690066  I.P. .C.o.n.f.i.
        01036a78  00750067 00610072 00690074 006e006f  g.u.r.a.t.i.o.n.
        01036a88  00000000 50020100 00000000 0015000f  .......P........
        
        
08/09/2001  JosephJ problems with msdn
tried searching for random -- very poor showing. Online help is vague,
sync to toc doesn't work.

also look for info on how to define string literals in visual basic.

08/09/2001  JosephJ The "copy operator" for vectors.
    Looks like vectors copy the dimensions, but their content's don't get copied
    if they're pointers -- this is reasonable, but it means that when
    crating  a copy of, say CHostSpec, the vector of interface IDs will not be
    copied.

    
08/09/2001  JosephJ TODO: when copying NlbCfg we need to copy addresses
    appropriately.

08/09/2001  JosephJ determing the selection of a list ctrl:
    POSITION pos = m_portList.GetFirstSelectedItemPosition();
    if( pos == NULL ) return;
    int index = m_portList.GetNextSelectedItem( pos );
    m_portList.DeleteItem( index );

08/09/2001  JosephJ Allowing a full row of a multicol list view to be selected..
    m_portList.SetExtendedStyle( m_portList.GetExtendedStyle() | LVS_EX_FULLROWSELECT );


08/10/2001 JosephJ wlbsctrl.dll functions used in cfgutil.lib:
    CWlbsControl::Initialize
    CWlbsControl::CWlbsControl
    CWlbsControl::~CWlbsControl
    CWlbsControl::GetClusterFromAdapter
    CWlbsControl::ReInitialize
    CWlbsCluster::ReadConfig
    CWlbsCluster::CommitChanges
    CWlbsCluster::WriteConfig
    CWlbsControl::ValidateParam
    CWlbsControl::LocalClusterControl
    WlbsSetDefaults
    WlbsEnumPortRules
    WlbsAddPortRule
    WlbsDeleteAllPortRules

08/10/2001 JosephJ CPropertySheet  -- has stuff about wizards in it!

08/10/2001  JosephJ ClusterPage directly handles OnNotify, so our
    virtual OnSetActive method doesn't get called.
    So I call OnSetActive from  ClusterPage::OnNotify

08/12/2001  JosephJ Code that gets notified when focus is set on a control..
Check out the following in hostpage.cpp ...
    ON_EN_SETFOCUS( IDC_EDIT_DED_MASK, OnGainFocusDedicatedMask )
    It fills out the control with defaults.

08/13/2001  JosephJ WlbsToNetcfgConfig (in netcfg\wlbscfg)


08/13/2001  JosephJ somehow m_pCommonClusterPage->Update() 
    is not working when called after the do-modal is done. 
    Also it looks like ClusterPage->OnOk is not called for wizard.
    Temporary workaround: added the following

        case PSN_WIZFINISH:
        void External_UpdateInfo(void) {UpdateInfo();}
    
            *pResult = m_pCommonClusterPage->OnKillActive(idCtrl, pNmhdr, *(BOOL*)pResult);
            this->mfn_SaveToNlbCfg();
            return TRUE;


        TODO: look for mfn_SaveToNlbCfg() -- clean up.

08/14/2001  JosephJ Wizards ....
    Override  CPropertyPage::OnWizardFinish() (eg CHostPage)
    OR, if you're directly processing OnNotify (eg CClusterPage),
    you intercept the  PSN_WIZFINISH (see 8/13/2001 log entry).


08/14/2001  JosephJ Trying to make the "Connect" button in ConnectDialog
    the default button.
    The API is CDialog::SetDefID( UINT nID );
    However it's tricky to figure out where to call this from.
    I was able to call it when the connect-to-host edit control gets 
    called, and from SetActive, but neither gets called when the
    connect dialog is first put up. Calling DetDefID from OnInitDialog
    doesn't work either.
    Tried calling from ConnectDialog::OnActivate -- didn't work.
    ON_WM_ACTIVATE()
    ...
    void ConnectDialog::OnActivate( UINT nState, CWnd* pWndOther, BOOL bMinimized )
    {
        this->SetDefID(IDC_BUTTON_CONNECT);
    }

    Actually the above were getting called in special circumstances, like
    if the windows is being redrawn, or we move back to to this page
    once there is already something else to focus on.

    Final solution: Hook the  ON_EN_UPDATE messages!
    Works like a charm. I check the text length, and if it 0 or
    the string is all whitespace, I disable the button. It remains the
    default button, but I think that's ok.


08/14/2001  JosephJ engine notifying the ui about cluster/host arrival....
    New cluster:
        The moment the user clicks "Finish" in the new cluster wizard,
        we populate the tree view with the cluster and the
        first host -- they should both have the pending icons.
        We spit something out to the log.
    On successful completion, we change the icons.
        We spit something out to the log.
    On failed status it depends on what failed -- if nlb is bound, we
    show the cluster and host appropriately -- if things look ok we 
    show it ok, otherwise with appropriate icons.
        We spit something out to the log.


08/15/2001  JosephJ Properly sizing the list columns.
    GeorgeJ suggested using  GetClientRect to get the size of the list box,
    then partitioning that space appropriately.

08/15/2001  Displaying pending status0
    engine.cpp: implemented process_msgqueue() (got from msdn)
    and also CWaitCursor. Works like a charm!

09/12/2001  JosephJ 

    Types of operations involving wizards/properties:
        NewCluster        wizard
        ExistingCluster   wizard
        AddHost           wizard
        HostProperties    propertysheet
        ClusterProperties propertysheet

    ClusterPage
        -- can be brought up in several modes:
        1: NewCluster           first page in wizard, all fields enabled
        2: ClusterProperties    all fields enabled
        3: HostProperties       all fields DISABLED

    Connect page:
        1: NewCluster           middle page in wizard
        2: ExistingCluster      first page in wizard
        3: AddHost              first page in wizard

    Hosts Properties:
        1: NewCluster           last page in wizard, all fields enabled
        2. AddHost              last page in wizard, all fields enabled
        3: HostProperties       all fields enabled

    PortRules:
        1: NewCluster           middle page in wizard, all fields enabled
        2. AddHost              middle page in wizard, only load weight enabled
        3: HostProperties       only load weight enabled
        4: ClusterProperties    all fields enabled, except load weight


    So we'll add an enum:
    OP_NEWCLUSTER
    OP_EXISTINGCLUSTER
    OP_ADDHOST
    OP_HOSTPROPERTIES
    OP_CLUSTERPROPERTIES
    That's passed into the constructor for each of the dialog pages.




    
DOC bug _snprintf, _snwprintf -- mix up byte- and char- counts

09/14/2001  JosephJ Dealing with exlusive resources -- priorities, IPs, etc
    - CEngine: Define a private class CEngineCluster which encapsulates a
      CClusterSpec and also keeps a bitmap of taken host priorities,
      and a 32-bit array per-port-rule priorities. Also a ref count.
      The ehClusterSpec maps to this structure. Add access functions.
    - Pass in the cluster handle to the constructor for host properties.
      Host properties then gets access to the bitmap of taken properties.
      (Engine is responsible for maintaining the bitmap).
    

    IP addresses:
    Global map of ip addresses to it's properties.
    IP Properties: IsVip, IsDip, ehCluster, ehInterface

    Need to implement:
         HostPage::mfn_Load/SaveToNlbCfg()
        PortsPage::mfn_Load/SaveToNlbCfg()
    and call them for both property-sheet and wizard mode.

    Following still unacounted for...

LOAD:
    NETCFG_WLBS_PORT_RULE port_rules[CVY_MAX_RULES];

    TODO: These fields are set if the user has changed the password -- in this
    case we need to send this to the host.
    bool fChangePassword;
    TCHAR szPassword[CVY_MAX_RCT_CODE + 1];

SAVE:

    NETCFG_WLBS_PORT_RULE port_rules[CVY_MAX_RULES];

    TODO: These fields are set if the user has changed the password -- in this
    case we need to send this to the host.
    bool fChangePassword;
    TCHAR szPassword[CVY_MAX_RCT_CODE + 1];

09/14/2001  JosephJ GJack suggestions.
    1. Make "create new cluster" -- adapter list can potentially show
       all nics. checkbox can restrict. If nic has a nlb cluster ip
        which matches the cluster ip, select it as the default,
    otherwise try to select the interface that appears to be on the 
    same subnet as other interfaces already in the cluster.

09/15/2001  JosephJ Keeping nlbmgr's view upto date.
    1. Everytime we present data to the viewer, it's always after
       refreshing it from the host. This is true even for cluster
       properties.

    So 
    1. Viewing/changing cluster properties:
        We refresh the cluster properties using the 1st host, then
            present it.
    2. Viewing/changing host properties
        We get the latest view of the host's properties.


09/16/2001  JosephJ WLBS_PORT_RULE structure and constants

    typedef struct
    {
        TCHAR       virtual_ip_addr [WLBS_MAX_CL_IP_ADDR + 1];
        DWORD       start_port;
        DWORD       end_port;
        DWORD       mode; CVY_SINGLE CVY_MULTI CVY_NEVER
        DWORD       protocol; CVY_TCP CVY_UDP CVY_TCP_UDP
        union
        {
            struct
            {
                DWORD       priority;
    
            } single;
    
            struct
            {
                WORD        equal_load; // 0/1
                WORD        affinity;
                      CVY_AFFINITY_NONE CVY_AFFINITY_SINGLE CVY_AFFINITY_CLASSC
                DWORD       load; // 0...100
            }           multi;
    
        }           mode_data;
    }
    WLBS_PORT_RULE, * PWLBS_PORT_RULE;

09/16/2001  JosephJ Supplying unique host priorities and port-rule priorities
    CEngine should have two functions
        NLBERR GetAvailableHostPriorities(IN ehCluster,  OUT ULONG &bitmap);
        NLBERR GetAvailablePortRulePriorities(
                IN ehCluster,
                IN LPCWSTR szVip,
                IN UINT start_port,
                OUT ULONG bitmap);
    These functions go through the list of interfaces/port-rules, and
    compile a bitmap of available priorities.

09/16/2001  JosephJ Merging cluster portrules into host's portrules
    For each rule in cluster
        if (find rule in host && makes sense)
        {
            copy priority or load
        }
        else
        {
            priority = host id
            load = 50
        }
    TODO: if you edit the start port, you will loose the interface-specific
        information. To fix this is not trivial -- need some kind of
        a key which is common between the cluster-specific version and
        the port-specific version.
IDC_RADIO_EQUAL IDC_RADIO_UNEQUAL
09/17/2001  JosephJ Tab orders are important for radio buttons!
    I changed the tab order and radio buttons become uncoordinated --
    turns out that radio buttions must be in sequential tab order
    to have the toggle effect.
09/17/2001  JosephJ OnWizardFinish is NOT called unless the page is the
    last page. So for middle pages you need to do stuff in KillActive.

09/17/2001  JosephJ regexp searh for "if (x=y)" error
    if.*[^=!<>]=[^=]

09/17/2001  Connect dialog
    if (!existing)
    Show:

    "Interface Name|Interface IP   |Cluster IP"
                    111.111.111.111|111.111.111.111
                    111.111.111.111|


    mfn_LookupClusterByIPLk(..., REF pECluster...)
    pECluster->m_cSpec.m_ehInterfaceIdList.push_back(ehIfId);

09/19/2001 JosephJ Notes to self
    NLBMGR.EXE
    Context sensitive help, UI-Ids match those in netcfgx.dll, help linkages.
    VIP (port rule) support
    Suspend-state and start-suspended support.
    Save log: use application event log
    Analyze cluster functionality  see below
    Demo switch : put up message box.
    
    Add fLog field to connect host.
    LoadHost: connect (fLog=TRUE); then for each ehIF for bound Ifs, lookup
    clusterip, if new update cluster properties; then AddInterfaceToCluster.
    Add ehCluster to CInterfaceSpec.
    Analyze functionality:
    CNlbEngine::AnalyzeInterfaceClusterPropsLk(pISpec, pCSpec);
    CNlbEngine::AnalyzeIntefaceHostProps(pISpec, pOtherISpec);  -- these also
     set/clear misconfig flag.
    CNlbEngine::GetIpInfo(szIp, pIP_INFO)  (IP_INFO: ehCluster; ehConnectionIp;
    ehDedicatedIp; Call above from UI (in validate-data kill-active, etc.)
    
    ControlCluster:
    New methods: ControlCluster(szNIC, operation); ControlPort(szNIC, szVIP,
         szStartPort); But we'll need also to do query
    
    
    Pending operations
     [Also see  11/18/2001  JosephJ Pending operations -- take 2]
    1. Don't keep any pointers to global dyamic data structures in the
       background thread.
    2. Only one pending operation per interface. fPending flag tracks this.
       --Add a common superclass "CSpec" to CInterfaceSpec, CClusterSpec,
         and CHostSpec. CSpec has the following members:
            type,fPending,fDeinitializing,fCancelOperation,
            bstrOperationDescription (
                eg "Modifying cluster properties"
                   "Modifying host properties"
        Engine method:  mfn_Begin/EndOperation(ehObj)
            Each of these:
                Check global fDeinitializing flag is set
                Check if this object's fDeinitializing flag is set
                Check if this object's fPending flag is set
                Set the pending-flag and update the UI appropriately
                Bump up global head count
                On decrement, if unloading and zero
       - Get rid of CEngineCluster
       - Re-write validate cluster to use the type

       - Special checks:
            - If a cluster operation is pending, don't allow interface-level
              operations to start unless it's in the context of a cluster-wide
              operation.
            - If an interface operation is pending, don't allow a cluster-level
              operation to start.

    5. UI: message box if attempt is made to change config while pending
       operation in progress.
    6. For now: Always create thread for the update sequence: 
       get-config,update, sleep,ping,get-result. Later use thread pool.
    7. Log updates: pszLog maintained in pISpec  log new data
         (like tprov does)
    8. Cancel operation: will stop the sleep-get-result loop in background
       thread.
    
    FAKE support:
    Update: Pending: fpending, hthread; Dummy log entries created;
    Per host delay + random failure
    Ping: per-host delay/ramdom variation (max is what ping arg specifies);
        ping host: return connection IP; ping ip  any ip on interfaces that are
        marked as management capable
    All operations: per host connectivity delay (could be never i.e., host not
         reachable).
    
    Change BRIE, etc. to CHEESE1
    
    Schedule meeting/design review; show demo, docs, code, handout.

    
09/20/2001  JosephJ map wierdness.
    [see also 11/10/2001 JosephJ Redesign of the format of ENGINEHANDLE]
    When iterating through a map using "iterator", you can get entries
    which have never been set! The second value of these will be NULL.
    so if 
        mymap[1] = p1;
        mymap[3] = p3;
    and you iterate, you'll get an iteration whose first is 2 and 2nd is NULL --
    even if you never explicitly inserted that. Pretty  creepy.
    I wonder if you were to insert
        mymap[100000] = p100 and you iterate you'll get all values
     from 1 to 100000!
    
    GOT It: if you *ever* refer to the map in an expression -- like
        if (mymap[45] != NULL) {}
    then a map entry for that value is created.
    We do this in ValidateHandle. Todo: need to change validate handle so
    that it doesn't call the map functions.

09/20/2001  JosephJ plan for LoadHosts:
    LoadHost is implemented *outside* CNlbEngine

    pseudo code:
    
    LoadHost(pConnInfo)
    {
        
        gEngine.ConnectToHost(pConnInfo, REF ehHost);
        for (each interface ehIF in ehHost)
        {
            CInterfaceSpec *pISpec=NULL;
            gEngine.GetInterfaceSpec(ehIF, REF pISpec);

            if (pISpec->ehCluster == NULL)
            {
                // interface is not part of a cluster...
                szClusterIp = (extract cluster ip from pISpec.m_NlbConfig);
                gEngine.LookupClusterByIp(szClusterIp, TRUE, REF ehCluster, REF fIsNew);
                gEngine.AddInterfeToCluster(ehCluster, ehIF);
                if (fNew) {
                    gEngine.UpdateCluster(ehCluster, pISpec.m_NlbConfig);
                }
                // TODO: call gEngine.AnalyzeXXX functions to report
                // misconfigured host:  or conflicts with other
                // hosts and/or mismatches with cluster.
            }
            
        }
        
    }
09/20/2001  JosephJ -- used real NlbHostXXX functions for the first time
    -- simply commented out the call to NlbHostFake in CNlbEngine::Initialize
    -- worked like a charm, first time!!!!!!!!!
    -- now need to implement update config.

09/21/2001  JosephJ command line processing
    Created subclass CNlbMgrCommandLineInfo of CCommandLineInfo.
    This subclass overrides the ParseParam virtual function.
    Then from Application::InitInstance, call  CWinApp::ParseCommandLine.
    I additinally overrode the function ProcessShellCommand. Turns out
    that you NEED to call CWinApp::ProcessShellCommand or else the
    application doesn't start. So I call CWinAPP::ProcessShellCommand from
    Application::ProcessShellCommand.

09/21/2001  JosephJ implemented command line processing
    
    There is a global instance of a new class (defined in document.h),
    called gCmdLineInfo. This class is filled in by the Application class.
    It includes the hostlist option.
    
    If you type nlbmgr2.exe /help, you'll get a little popup showing the
    command line options. They are:
    /demo             run in demo mode
    /hostlist <file>  load the hosts specified in <file>
    /help             display this message
    
    If the /hostlist option is specified (along with <file>), then 
    gCmdLine.m_bHostList is TRUE, and gCmdLine.m_bstrHostListFile contains
    the file name.
    
    So given that we'll need to load hosts both from LeftView and on
     initialization, the place to implement the loadhosts functionality is
    In the Document class. So add a public method
     Document::LoadHosts(szFileName)  and a private method
     Document::mfn_LoadHost(szHostConnectiString).
    Call these methods from Document::Document (the last thing done).
    
    In both cases, LoadHostList may need to do stuff in a background
    thread -- as you suggested.

09/21/2001  JosephJ NewCluster: JosephJ show error if new cluste ip matches
    any ip on some other nic in host.

09/22/2001  JosephJ Making code organization of the host properties UI
    The host-specific properties are implemented in class HostPage,
    which is in hostpage.cpp and hostpage.h.

    Class HostPage is derived from CPropertyPage. It's resource ID
    is IDD_HOST_PAGE, defined in resource.h and resource.rc.

    The various controls are members of this class, for example:
        CIPAddressCtrl ipAddress;
        CIPAddressCtrl subnetMask;
        CButton        initialState;
    The mapping between the UI and these controls is "automagically"
    done in overridden virtual functino DoDataExchange:
        HostPage::DoDataExchange( CDataExchange* pDX )
        {
            DDX_Control( pDX, IDC_EDIT_PRI, priority );    
            DDX_Control( pDX, IDC_CHECK_ACTIVE, initialState );
            DDX_Control( pDX, IDC_EDIT_DED_IP, ipAddress );    
            DDX_Control( pDX, IDC_EDIT_DED_MASK, subnetMask );    
        }
    The initial state of these controls is set in the function
    mfn_LoadFromNlbCfg. On losing focus or the ok button being pressed,
    the state of the controls are validated using mfn_ValidateData
    (which is partially disabled because it had some old code),
    and saved using mfn_SaveToNlbCfg.

    mfn_LoadFromNlbCfg and mfn_SaveToNlbCfg load from/save to a
    class of type NLB_EXTENDED_CLUSTER_CONFIGURATION,
    which is defined in nlbmgr\inc\cfgutil.h, and implemented in
    nlbmgr\cfgutillib\extcfg.cpp (goes into static library cfgutil.lib).

    Now NLB_EXTENDED_CLUSTER_CONFIGURATION as not particularly elegant.
    It includes as it's members the list of IP addresses bound to the NIC,
    as well as NlbParams, which is of type  WLBS_REG_PARAMS.
    The class is messy, it's get/set functions ugly, and it's use
    of WLBS_REG_PARAMS unfortunate, because we don't use many of the
    arcane fields of WLBS_REG_PARAMS, and we are forced to use the
    WlbsEnumPortRules, etc functions.

    Anyway, there are access methods in the class for various members,
    although since the members are not private, I sometimes access
    members directly, for example (from hostpage.cpp):
    _bstr_t bstrDedIp =  (LPCWSTR) m_pNlbCfg->NlbParams.ded_ip_addr;

    It definately would be good to cleanup this class, but it's used
    pretty extensively across all nlbmgr code (including the provider
    and the console app), so it's nontrivial to change.

    Getting back to HostPage, the load/save functions (mfn_Load/Save...)
    access member m_pNlbCfg of type NLB_EXTENDED_CLUSTER_CONFIGURATION.
    This pointer is initialized in the constructor of class NlbHost.


09/22/2001  JosephJ Making code organization of the ports-related UI
    [Read note above for reference to location of resource ids,
     and NLB_EXTENDED_CLUSTER_CONFIGURATION, DoDataExchange,
    and semantics of mfn_LoadFrom/SaveToNlbCfg.]

    There are 3 ports-related property-pages/dialogs. These are
        - PortsPage: public CPropertyPage -- list of ports
        - ClusterPortsDlg: public CDialog -- cluster-ver of edit port dlg
        - HostPortsDlg: public CDialog -- host-ver of edit port dlg.

        Details ...

        PortsPage: public CPropertyPage -- this contains the list
            of ports with the add/edit/remove buttons.
            This class can be invoked in "cluster mode" or in "host
            mode" -- the  fIsClusterLevel argument passed into
            its constructor indicates which.

            The resource ID is IDD_DIALOG_PORTS.
            Depending on fIsClusterLeve, the class selectively enables/
            disables certain elements.
        
            As with HostPage, the controls are members, which interfact
            "automagically" with the UI, using DoDataExchange, and these
            controls are loaded/saved using mfn_LoadFrom/SaveToNlbCfg.

        ClusterPortsDlg: public CDialog -- launched to edit a portrule
            from a cluster perspective -- only cluster wide changes are
            allowed.
            Resource ID: IDD_DIALOG_PORT_RULE_PROP_CLUSTER

            UNLIKE PortsPage, this class doesn't use dde to
            map ui to member controls -- instead it uses win32 apis,
            for example:
            :SendDlgItemMessage(m_hWnd, IDC_EDIT_MULTI, ....);
            Also it loads/saves UI state to/from member
            m_portData, which is passed by REFERENCE to its
            constructor. The parent window (expected to be of type
            PortsPage) is also passed into the constructor.
            Stuff is loaded from m_portData by method SetControlData, 
            and saved to m_portData by method OnOk.

            m_portData is of type PortsPage::PortData,
            which is simply:
                struct PortData
                {
                    PortData();
            
                    DWORD key;
            
                    _bstr_t start_port;
                    _bstr_t end_port;
                    _bstr_t protocol;
                    _bstr_t mode;
                    _bstr_t priority;
                    _bstr_t load;
                    _bstr_t affinity;
                };
            Historical note: this code has been modified from the
            original version, not re-written. In the original version
            there were subclasses for each type of port rule, a bunch
            of methods for handling each type and so forth.

            Also it's unfortunate that this is "yet another" data
            structure for port rule info.

        HostPortsDlg: public CDialog -- launched to edit a portrule
            from a host perspective -- only host-specific properties can
            be changed.
            Resource ID: IDD_DIALOG_PORT_RULE_PROP_HOSTS
            Its orginaziation is very similar to ClusterPortsDlg above.

09/22/2001  JosephJ details on the "LogView"
    The lower region of nlbmgr is maintained by an instance of
    class LogView : public CListView. The class is implemented in
    logview.h and logview.cpp.

    It's constructor gets called (probably) in the context of
    Application::InitInstance, as does it's initialization function,
    LogView::OnInitialUpdate. In OnInitialUpdate, LogView
    inserts a bunch of columns into it's list control, and
    adds a starting entry (which needs to be localized!)
    "NLB Manager session started".

    Thereafter, the only interesting thing it does, is to get
    calls to it's LogString function from the document instance.
    The LogString prototype is:
    
        void
        LogString(
            IN IUICallbacks::LogEntryType Type,
            IN const wchar_t    *szCluster, OPTIONAL
            IN const wchar_t    *szHost, OPTIONAL
            IN const wchar_t    *szText
            );

    LogString adds an entry to the log, with an icon determined by
    the value of "Type".

    TODO: how do we save logs -- by symultaneously logging to
    the application event log or by adding a "save log" feature
    (the menu item "save log" is already present, and does nothing
    currently). If we decide to save the log, we need to decide
    on a format: plain text or simple xml like:
    <NLBMGRLOG>
        <EVENT
           id=xxx LEVEL=INFO
           year=xxx month=xxx day=xxx hour=xxx minute=xxx second=xxx>
            <TITLE>NLB Manager session started</TITLE>
        </EVENT>
    </NLBMGRLOG>

    Of course we want to avoid creating ad hoc formats!

     paramp -> i_convert_mac = TRUE; // TODO

09/15/01, shouse
    Context sensitive help has been attached to all known dialogs.
    For the three NLB netcfg UI clones, all help appears to work
    except for the "Cluster IP address" group box on the Add/Edit
    port rule (properties) page - this is also missing in the 
    netcfg UI.

    To add the hook for context sensitive help on other dialogs,
    you need to add a help handler to the class - see hostpage.cpp
    and hostpage.h for an example (OnHelpInfo and OnContextMenu).
    Further, you need to create a table of mappings from UI IDs
    to help IDs - in NLB we always use the UI ID as the host ID
    to simplify things.  See hostpage.h for an example table.
    Then, have the UI text people (Joe Holliday) write the help
    for the needed components and give him the UI ID to hook into.
    Joe will send a private wlbs.hlp to test with (place this 
    file in %WINDIR%\help\.  Be sure to review and edit the help -
    Joe is VERY open to our suggestions on wording and content.

    Support for the new initial host state, persisted states and
    per-VIP port rules has been added to the appropriate dialogs.
    Most dialogs were reviewed for layout and text and were mod-
    ified - several new dialogs, or some legacy dialogs that may
    not be used any more were not updated yet.

    Also, the equal checkbox has been added to the cluster-level
    port rule properties dialog.  At this time, the host-level 
    can not change this setting - if the rule is equal, the host
    can not make it unequal and set a load weight (the rule must
    be changed to unequal at the cluster-level first), so if we
    want hosts to be able to change this, changes will be necess-
    ary in at least clusterportsdlg.cpp.

09/25/01 karthicn : Notes to self
    The FinalInitialize function (in document.cpp) is called in a background
    thread from Document::registerLeftView. The only thing that FinalInitialize
    does is : If a file name is provided in the command line, it reads host
    names from the file connects to them. May want to check if the file name is
    specified in the command line before spawning off the thread.

09/26/2001  Credentials UI -- the proper way of managing utilities.
    From Mike Lai of the secure windows initiative team (http://swiweb, 
    email: switeam): "Please use Cred UI, Cred Mgr in LSA makes sure the
    sensitive data is protected via LsaProtectMemory/LsaEncryptMemory  which
    is encrypting the data while the data is memory."

    John Franco in MSCS (Dave Potter's) team pointed me to http://benhutzdev,
    which contains API documentation for the Credentials API.  From those
    docs, it appears that the APIs I nead to call are:
        - CredUIPromptForCredentials with the CREDUI_FLAGS_GENERIC_CREDENTIALS
        - CredWrite specifying CRED_TYPE_DOMAIN_VISIBLE_PASSWORD.
        - CredRead

    Additinally, it appears that I don't need to call CredWrite if I specify
    the CREDUI_FLAGS_PERSIST flag in CredUIPromptForCredentials.

    I've asked John Franco for sample code.
    
    From: Cliff Van Dyke 
    Sent: Wednesday, September 26, 2001 10:17 AM
    Subject: RE: Question on how to safely cache user credentials
         in a user-mode program.
    
    OK.  Here's my recommendation.
     
    You should you credui to prompt for the credential since we want to have
    that as the only UI being used. You shouldn't use credman to store the cred
    since credman creds are used by all processes and not just yours.

    If NLB manager isn't the process doing the prompting, you should encrypt the
    password using RtlEncryptMemory with the RTL_ENCRYPT_OPTION_CROSS_PROCESS
    flag as you pass the password between processes.

    In the NLB manager, while the password isn't actively being used, you should
    encrypt the password using RtlEncryptMemory with no special flags.

    Any buffer that temporarily contains the password should be zeroes as soon
    as you're done with it.  SwiTeam should be able to point you to a web page
    with more detailed related info.

    In a future release, the "password" returned to you from credui will be a
    "handle" to data stored more securely.  That handle will be accepted as the
    password parameter to any API that uses NTLM or Kerberos.  


9/27/01 ChrisDar
Things that still need to be fixed with logging:

1. Macro var names MAXFILEPATHLEN and MAXSTRINGLEN are hokey and should be changed. Also value should be reviewed.

2. Currently logging class is called even when logging is not enabled because internal to method is where enabled flag is checked. Need to move the check into LogView::LogString for efficiency.

3. Related to 2., LogView gets back LOG_RESULT enum for some calls to document class to tell it what error to report in error message dialog. I realize now that this can be done in the document class itslef. This should changed so that the LogView class just knows an error occurred and can react as needed. The dialog should be popped in the document class.

4. When reading log file name from registry, we don't truncate but give an error if file name is too long. Need to figure out how to read N bytes even if there is more available.

10/07/2001  Got the following error in setupapi.log during an install...
    Build 3563.Lab03_N.011003-1919

    [2001/10/05 15:40:37 1740.157 Driver Install]
    #-019 Searching for hardware ID(s): ms_wlbsmp
    #-198 Command line processed: D:\WHISTLER\System32\wbem\wmiprvse.exe
    #I022 Found "ms_wlbsmp" in D:\WHISTLER\inf\netwlbsm.inf;
     Device: "Network Load Balancing Filter Device";
     Driver: "Network Load Balancing Filter Device";
     Provider: "Microsoft"; Mfg: "Microsoft"; Section name: "WLBSMP.ndi".
    #I023 Actual install section: [WLBSMP.ndi]. Rank: 0x00000000.
     Effective driver date: 07/01/2001.
    #I063 Selected driver installs from section [WLBSMP.ndi] in
     "d:\whistler\inf\netwlbsm.inf".
    #I320 Class GUID of device remains: {4D36E972-E325-11CE-BFC1-08002BE10318}.
    #I060 Set selected driver.
    #I058 Selected best compatible driver.
    #-166 Device install function: DIF_INSTALLDEVICEFILES.
    #I124 Doing copy-only install of "ROOT\MS_WLBSMP\0000".
    #-166 Device install function: DIF_REGISTER_COINSTALLERS.
    #I056 Coinstallers registered.
    #-166 Device install function: DIF_INSTALLINTERFACES.
    #-011 Installing section [WLBSMP.ndi.Interfaces] from
     "d:\whistler\inf\netwlbsm.inf".
    #I054 Interfaces installed.
    #-166 Device install function: DIF_INSTALLDEVICE.
    #I123 Doing full install of "ROOT\MS_WLBSMP\0000".
    #-035 Processing service Add/Delete section [WLBSMP.ndi.Services].
    #E279 Add Service: Failed to create service "WLBS".
     Error 1021: Cannot create a stable subkey under a volatile parent key.
    #E033 Error 1021: Cannot create a stable subkey under a volatile parent key.
    #E275 Error while installing services.
     Error 1021: Cannot create a stable subkey under a volatile parent key.
    #E122 Device install failed.
     Error 1021: Cannot create a stable subkey under a volatile parent key.
    #E154 Class installer failed.
     Error 1021: Cannot create a stable subkey under a volatile parent key.
    #-166 Device install function: DIF_REMOVE.
    #I289 Removing device "ROOT\MS_WLBSMP\0000".
    #I048 Device removed.


    
10/07/2001  JosephJ managing multiple VIPs
    - New cluster:
        NlbCfg list includes only primary vip.
    - Existing cluster:
        NlbCfg list includes all ips in tcpip except dip, if present.
    - Per-host cluster info:
        NlbCfg list includes all ips in tcpip except dip, if present.

    So to simply the vipslist code, it'll alwaws exclude the dip from the
    list, if it sees a non-null dip.

    Todo:
    1. vipspage: reload on set-active, save on kill active.
        reload:
            Clear and re-build list view
        save:
            if list view modified:
            re-populate addresses, adding dip and then vip at head of the
            list.
    2. vipspage: add:
            call gEngine.ValidateAddress(
                    szAddress, ehCluster, ehHost, cip/pprvip/dip, out szErr);
    3. Apply-to-per-host:
        - for each ip in old list
            if found in new list add to tmp list
            (this preserves the order of old addresses)
        - for each ip in new list
            if found in tmp list
                set cursor to this location in tmp list
            else
                insert after cursor,
                set cursor to this location in tmp list

    Add new host/connect to existing:
    -   The trick here is that we need to preserve the existing
        host-specific settings as far as possible (ONLY if the NIC already
        has the *save* cluster IP). The user can select
        an arbitrary NIC -- we need to use that's NIC's host-specific settings.
        If the user goes back to the connect page and selects a different NIC,
        we need to switch to the new NIC's settings.
    - On startup, if a NIC has the same IP address, we make that the default
      selection.
    - So each time the NIC selection changes
        - Make a copy of of the NIC's current settings
        - If bound to NLB 
            - if it has a different IP address: put warning msg
            - We apply the cluster-wide properties in the current m_pNlbCfg
             (which is the cluster's version) to the copy of the NIC's current
              settings.
            - We copy the result back to m_pNlbCfg.

10/25/2001  JosephJ Host and Port priorities.

    Because NLB manager allows multiple hosts to have pending activity
    at the same time, we need to keep a list of pending
    host priorities and port-priorities. The UNION of current and pending
    host priorities and port-priorities is used to get the list of currently
    taken priorities -- the inverse consists of available priorities.
    This inverse set *could* be empty -- tough luck.

    So each cluster in the engine needs to keep:
    (a) bitmap of pending host ids
    (b) map[start-port] of bitmaps of pending port-rule ids

NewCluster
AddHost
HostProperties

    ConnectDialog:

        Constructor:        
            AddHost: set the host priority in m_pNlbCfg to a good default,
                    taking into account available hosts in the cluster (ask
                     engine). Likewise, set the single-host port priorities
                    appropriately (ask engine).
            NewCluster: may as well do the same as above, so we don't
                differentiate.

            NONONO: instead, changed this so that where add host is CALLED
                (in leftview) we set up the defaults appropriately.


        OnButtonConnect:
            NewCluster:
            AddHost:
             if (IF already bound to cluster with same IP)
             {
               apply cluster properties to existing interface props, save
               the config to m_pNlbCfg. 
             }

        OnSelChange:
            (we don't allow changing if there exists an IF which is already
             bound to the clsuter (i.e. cluster IP matches).
            NewCluster:
            AddHost:
                don't need to modify m_pNlbCfg.


    HostPage:

        Constructor:
            if (!new cluster)
            {
                -- initialize host prority bitmap  with
                    currently available priorities (ask engine)
                -- initialize array of port-rule-priorities bitmap.
            }

        On mfn_LoadFromNlbCfg:
            populate the host priorities listbox with list of available
            host priorities + m_pNlbCfg->host-priority, select the
            current value of the latter.

        On mfn_SaveToNlbCfg:
            save the selected host priority to m_pNlbCfg->host-priority.

    HostPortsDialog:
        SetControlData:
            if (single-host)
            {
                Get list of available priorities for this port rule (ask
                engine).
            }
            Fill out list box accordingly.
            
    Q: What if on new-cluster, user specifies port rules, connect, select an
       IF,  go back to the port rules and change them around?
    A: Since its a new cluster, all port priorities are available at this point.

10/27/2001  JosephJ Note on the layout of the views

    This is done in MainForm.CPP -- in class MainForm.
    The class has two splitter windows (CSplitterWnd)  splitterWindow,
    and splitterWindow2. The individual views are refered by a
    coordinate system -- 

    splitterWindow.CreateStatic( this, 2, 1 );
         <-- creates a static splitter window with two rows and one column.

    splitterWindow2.CreateStatic( &splitterWindow, 1, 2,
                                  WS_CHILD | WS_VISIBLE | WS_BORDER,
                                  splitterWindow.IdFromRowCol( 0, 0 )
                                  );

        <-- creates a CHILD splitter window, with one row and two columns
            (the 1,2 as second and third args)
            The location of the child in the PARENT splitter window
            is (0,0) -- the call to splitterWindow.IdFromRowCol(0, 0);


    splitterWindow2.CreateView( 0, 
                                0, 
                                RUNTIME_CLASS( LeftView ),
                                CSize( 0, 0 ),
                                pContext );

        <--- says to create an instance of LeftView at coordinate
        (0,0) of the CHILD splitter window.

    Etc...

10/27/2001  JosephJ Note on handling menu controls
    Moved handling of menu controls from LeftView to MainForm, 
    because left view wasn't getting the control messages (naturally)
    when the focus was not on the left view.

    Currently MainForm calls left view's public methods for control
    operations -- strictly speaking these methods also need to migrate
    over to MainForm -- left view should just be consulted on the 
    currently selected item. However, in the interest of minimizing
    code changes, the implementation of the controls remains in LeftView.

    So with this change the menu items work even if the focus is not
    on the left view.

10/30/2001  JosephJ
    Cases to test:
    1. Connect to existing:
            a: 0 nics are bound to cluster OK
            b: 1 nics is bound to cluster OK
            c: 2 nics are bound to clusters OK if no change in sel
            e: switch NIC selections and verify things work. BUG
            f: switch host names and verify things work. OK (recheck)
    
    2. New cluster:
            a: 0 nics are bound to cluster
            b: 1 nic is bound to cluster (a different cluster)
            c: 1 nics are bound to cluster (same cluster)
            d: 2 nics are bound to cluster (one same one different)
            e: switch NIC selections and verify things work.
            f: switch host names and verify things work.
    
        If same: check that all host-specific properties are preserved.
                (including null ded-ip if specified)
        If not same: check that dedicated IP address is filled in:
             - with 1st IP address on NIC
    
    3. Add Host:
            a: 0 nics are bound to cluster
            b: 1 nic is bound to cluster (a different cluster)
                    BUG -- priority clashes with existing
            c: 1 nics are bound to cluster (same cluster)
            d: 2 nics are bound to cluster (one same one different)
            e: switch NIC selections and verify things work.
            f: switch host names and verify things work.
    
    BUGS that were fixed recently:
    x AV when connecting (via new cluster) to an existing cluster, then
        moving back and forth between pages. Via add host also, I think.
        - Seems to be fixed by taking out a reference to uninitialized memory.
    x In connect-to-existing, if 2 nics are bound, on selecting
        a nic we get the "next" button, not finished button.
    x In new-cluster UI, got some host-priorities blanked out -- should
        be all available? Once cluster was created, didn't see this problem.
    x In add host the host priority was 1 -- clashes with the first host.

10/30/2001 JosephJ Handling the "F5" key
    The CWnd method is OnKeyDown, need to check that the
    first arg (nChar) is  equal to  VK_F5.

    I tried getting mainform to take the F5, but its OnKeyDown afx handler
    was not getting called. I then added the handler to LeftView instead and
    it works -- need to add the afx handler as well as mention it in
    the message map  -- search for OnKeyDown in leftview.cpp.

10/31/2001  JosephJ handling the double clicking of list view items (logview)
    Add the following message handler to the listview:
        ON_NOTIFY_REFLECT(NM_DBLCLK,  OnDoubleClick)
    In OnDoubleClick, cast the first arg to  LPNMLISTVIEW.
    LPNMLISTVIEW.iItem is the list view item index (zero based).

    See LogView::OnDoubleClick for details.
    
11/05/2001  JosephJ trying to get the right (details) view to have a caption:
    Setting the WS_CAPTION windows style didn't work -- produced a large blue
    caption with rounded borders, and allowed resizing within the application.
    I tried other combinations of the WBL_STYLE property -- no luck.

    I then tried putting an additional splitter window above the existing one
    -- this produced a movable border between the two windows -- I didn't want
    any border -- couldn't figure out how to get rid of the border.

    Finally tried using a CFormView -- this appears to be the way to go.
    Need to specify the dilog ID in the RC file, and this dialog should have
    only WS_CHILD as it's window properties.

    11/05/01 update:
    The details view comes up with the valid dialog template.
    HOWEVER it was not being filled out -- inserting columns and items etc
    into the list control wasn't being updated in the uI.
    Fix: Call UpdateData(FALSE); in OnInitialUpdate -- this is mentioned
    in Chapter fifteen (Separating the Document from Its View),
    step #8 (Edit the file Ex15aView.cpp, pp 356), in the book
    Inside Visual C++ 4th ed (MS Press).

    Apparantly unlike true Dialogs, the CFormView class doesn't call
    UpdateData automatically, so we have to call it ourselves. Go Figure
    (took me a while to figure this out).
    
11/05/2001 JosephJ Details view: selectively displaying the icons:
    If you don't want to display the icons next to each item,
    call SetImageList(NULL,...). Otherwise the first icon of the previously
    used image list is used whether you want it or not. For example,
    when listing the port rules, the image list for the cluster view was
    being used.

11/10/2001 JosephJ Redesign of the format of ENGINEHANDLE
    See "09/20/2001  JosephJ map wierdness."
    1. Keep separate counters for each kind of handle.
    2. First 2 bits of ENGINEHANDLE define type of handle.
        0 -- invalid
        1 -- interface
        2 -- host
        3 -- cluster

    Implemented the above, except that I keep a single counter for
    simplicity, through we'll run out of handles after 1billion creations
    vs 4 billion.

11/13/2001  JosephJ more things to test: picking username and pwd in connect
    Connecting to machine -- we look up the connection string -- if we find
    a match, we'll use that machine's username and password, rather than
    the default.

11/13/2001  JosephJ Hooking TreeView double-click and key strokes
    DoubleClick:
        Message map: ON_WM_LBUTTONDBLCLK()
        afx function: OnLButtonDblClk( UINT nFlags, CPoint point )
    Keystrokes:
        Message map: ON_WM_KEYDOWN()
        afx function: LeftView::OnKeyDown( UINT nChar, UINT nRepCnt, ...);

11/18/2001  JosephJ Pending operations -- take 2
    [See 09/19/2001 JosephJ Notes to self]

    - Engine has private method: mfn_BeginOperationLk(ENGINEHANDLE ehObj,
                                        bstrOperation, OUT bstrPendingOp).
      if ehObj is type cluster:
        - we'll first check if there's any pending operation on this cluster, if
            not we mark cluster started
        - we'll then try to start this operation on all the member interfaces.
        - if failure, we stop all we tried to start above and return failure,
          filling bstrPendingOp with the description of any pending op that
          caused the failure.

      if ehObj is type interface:
        - we'll first check if there's any pending operation on this interface,
            if not we mark interface op started.
        - we'll then try to start this operation on the host
        - if failure, we stop all we tried to start above and return failure,
          filling bstrPendingOp with the description of any pending op that
          caused the failure.

      if ehObj is type host:
        - we'll first check if there's any pending operation on this host,
            if not we mark host op started.
        - on failure, we'll bstrPendingOp with the description of any pending
          op that caused the failure.

      EXCEPTION: if the operation we're asked to start is already started,
        we won't fail -- instead we bump up an internal repeat count.
        This is so that we can start a cluster-wide operation and as part of
        that operation start a host or interface operation without the latter
        failing claiming that an operation is already pending.

      CAUTION: need to make sure that interfaces aren't added to or removed
        from clusters
        or hosts while a cluster-wide operation or a host-wide operation is
        pending. This is so that the correct list of interfaces are stopped
        when the cluster/host operation is stopped.

    mfn_EndOperationLk is the inverse of mfn_BeginOperationLk.
    Helper class Operation below will help with the implementation.
    
    EXTRA:
        need way to (a) cancel pending operations and
        (b) disallow new pending operations and
        (c) enumerate pending operations --
        This is mainly to handle proper cleanup on existing the program.
    class Operation
    {
        ...
    public:
        static OPERATIONHANDLE NewOperationHandle();
        static void ReleaseOperationHandle(OPERATIONHANDLE);

        NLBERR
        Start(OPERATIONHANDLE oh, _bstr_t bstrDescription, OUT pendingDescr);

        void
        Stop(OPERATIONHANDLE oh);

    private:

        static UINT next_handle;

        _bstr_t         m_bstrDescritpion;
        OPERATIONHANDLE m_ohCurrent;
        UINT            m_uRepeatCount;
    }

12/12/2001 KarthicN Redundant calls from ClusterPage.cpp & HostPage.cpp

ClusterPage.cpp :

    During cluster creation, ie. wizard mode 
    ClusterPage::OnNotify is called with PSN_KILLACTIVE. 
    The calls made are
    1. CCommonClusterPage::OnKillActive to read data from UI
    2. CCommonClusterPage::OnApply to validate the data 
    3. If validation is successful, ClusterPage::mfn_SaveToNlbCfg : This function calls CCommonClusterPage::OnKillActive. This call seems to be redundant

    During modification of cluster properties, ie. non-wizard mode 
    1. ClusterPage::OnNotify is called with PSN_KILLACTIVE. The calls listed above are made
    2. ClusterPage::OnNotify is called with PSN_APPLY. 
       The following calls are made in this step
       2.1 : CCommonClusterPage::OnApply to validate the data : This call is redundant since it was called in #1.
       2.2 : CPropertyPage::OnNotify : This leads to a call to ClusterPage::OnOK(). ClusterPage::OnOK() calls ClusterPage::mfn_SaveToNlbCfg. This call is redundant since ClusterPage::mfn_SaveToNlbCfg was called in step #1.

    Summarizing, the actions to be taken are :
    1. In ClusterPage::mfn_SaveToNlbCfg, remove the call to CCommonClusterPage::OnKillActive
    2. In ClusterPage::OnNotify for PSN_APPLY, remove call to CCommonClusterPage::OnApply
    3. In ClusterPage::OnOK(), remove call to ClusterPage::mfn_SaveToNlbCfg

HostPage.cpp :
    During host addition, ie. wizard mode 
    HostPage::OnWizardFinish() is called
    The calls made are
    1. mfn_ValidateData to validate the data 
    2. If validation is successful, mfn_SaveToNlbCfg

    During modification of host properties, ie. non-wizard mode 
    1. HostPage::OnKillActive() is called. 
       The following calls are made in this step
       1.1 : mfn_ValidateData to validate data
       1.2 : If validation is successful, mfn_SaveToNlbCfg
    2. HostPage::OnOK() is called. mfn_SaveToNlbCfg is called here. This call is redundant since it was just made in #1.2.

    Summarizing, the actions to be taken are :
    1. In HostPage::OnOK(), remove call to mfn_SaveToNlbCfg


12/15/2001  JosephJ How to add a menu item
    There are two kinds of menus -- the application menu and the ctxt-sensitive
    menu. Most functionality is available in both, so when adding a menu item
    they probably need to go to both places.
   
    1. Add to RC file:
        -- [Main menu] Add under IDR_MAINFRAME MENU DISCARDABLE
        this adds items to the main menu.
        -- [Ctxt sensitive menu] Add under IDR_POPUP MENU DISCARDABLE 
        -- add the constants to resource.h

    2. Add OnXXX menu item handler to MainForm (mainform.h, .cpp)
        follow the form of the existing menu item handlers -- you'll
        see that it just calls the LeftView handler by the same name
        (see note 10/27/2001  JosephJ Note on handling menu controls)

    3. Add OnXXX menu item handlers to LeftView (leftview.h, .cpp)
        this handler will actually do the action of the item.

    4. Control whether you want the menu item to be enabled or disabled
        depending on what item is selected in the leftview --
        add items to  LeftView::mfn_EnableHostMenuItems
        and LeftView::mfn_EnableClusterMenuItems
        (or create a NEW mfn_EnableXXXMenuItems if it's a whole new catigory).

12/15/2001  JosephJ misconfiguration UI

    Implemented the following:
        1. 207015 Reporting Cluster Misconfiguations
            - Add "View Status" menu item to ctxt-sensitive and main manu.
            - Bring up status dialog when user selects this.
            - Maintain status -- misconfiguration adds the status caption and
              details string. It's a bstr, so should be ok.

12/15/2001  JosephJ Logview: LVS_NOSORTHEADER
    Added LVS_NOSORTHEADER to logview style because
    we don't need to sort columns.

12/15/2001  JosephJ Fixed unresponsive dialogs spawned by ctxt-sensitive mnu
    I noticed that the dialogs are responsive to keystrokes  just not
    responsive to the mouse (well, until you force a re-draw of the window by
    temporarily overlapping it with another window).

    So I figured that its a mouse-specific thing  that somehow the processing
    of the r-button click was not proper  so on a hunch I called the base class
    function FIRST: i.e, moved the call CTreeView::OnRButtonDown(nFlags, point)
    to the START of the function LeftView::OnRButtonDown.

    That did the trick!


12/16/2001  JosephJ Dealing with remote control password
    1. Add new fields to EXTCFG:
            BOOL fSetPassword;
            DWORD dwNewHashedPassword;

    2. Add related methods to EXTCFG:
            SetNewRemoteControlPassword(szPwd)
            SetNewHashedRemoteControlPassword(dwPwd)
            ClearNewRemoteControlPassword(void)

    3. In nlbclientlib, it will ONLY set the szPassword or the hashed pwd
        if the fSetPassword field is set.

    4. EXTCFG::Update does not copy over the newpwd field -- instead
       it clears it.

    5. In analyze-interface, an error is reported if:
         - rct-enabled is different in cluster vs IF props 
         - rct-enabled in both cluster and IF props, but dwHash value is
           different. 
       In the misconfig report, the user is asked to fix this by re-entering
       the rct password.

    6. ONLY place where new Hashed rct pwd is specified is when adding a
       node to a cluster.

       
       
    

clusocm.dll copies files and handles upgrade scenarios, etc.
On a fresh install, it puts cluster admin to the adminstrative tools thing.

12/26/2001 JosephJ done the following a week ago:
    506822 Port control window unresponsive
    207015 Reporting Cluster Misconfiguations
    499068 save host list includes clusters or hosts that were removed
    503027 Connect dialog: duplicate hotkey (N)
    503031 Duplicate hotkey (N)
    503046 Log Settings: duplicate hotkey (E)
    504165 "Host\Delete" menu item is disabled when host is selected.
    209117 UI to manage cluster VIPS: troubleshoot and fix any issues
    502585 Update details view 
    
12/27/2001 JosephJ fixed the following ...
    203647  NLBManager should wrap the WMI error...
    326514 Modify remote-control pwd, report differences in pwd:
    509397  error check: when inital state conflicts a warning is given...
    509400  error check: add check for conflicting port rule where affinity..
    
12/27/2001  JosephJ Getting rid of literal strings in Nlbmgr.exe
    484842 For localization compatibility, replace all %xx fields by %num

    This was a pretty big effort -- there were literal strings all over the
    place. I grepped for " (dquote), made a list of each one, went through
    each and tested each case.
    I added the Log method to CLocalLogger and used it in numerous places.
    Another effort was to move to the %1,%2 etc FormatMessage format for a
    bunch of strings, mainly port-rule-descriptions.

12/29/2001  JosephJ Making "equal/unequal" port rule state host-specific
    202129 Make equal/unequal property of port rules a host-specific property.

    Look for  BUGFIX202129 conditionally compiled code.
    Summary of changes:
        clusterportsdlg: hide the equal/unequal checkbox and don't try to
            read/write it. Change the load description from equal/unequal to
            "empty" (i.e. "--").
        hostportsdlg: enable the equal/unequal checkbox, and read it's value.
            Add a handler for the checkbox events, and in the handler
            enable/disable the load-weight controls appropriately.
        portspage.cpp: change logic for handling equal/unequal when in
            cluster vs host mode.
        engine.cpp: ignore cluster equal/unequal and load weight when
            applying cluster wide properties to an individual host.


12/29/2001  JosephJ Reporting provider-side update results log.
    Relevant bug: 203634 Nlb Manager should report useful error when netcfgs..

    To do:
    1. Nlb Manager should report the results of the log.
        -- In GetUpdateResult, pick up the log and set the host status field
            with that info. YES!!!
        -- On update completion, fill in the log with the result.
    2. NLBMPROV.DLL -- if fAsync, should do a check if it can get the netcfg
        write lock, and fail if it cant (with appropriate log message).

    [Addendum] Implemented both of the above.

01/01/2002 JosephJ  Tracking available single-host port rule priorities
    Implemented gNlbEngine::GetAvailablePortRulePriorities, and
    use it in hostportsdlg.cpp and engine.cpp to choose proper host priorities.

    Relevant bug: 485541 Provide valid defaults for host-priorities to
    single-host port rule

01/01/2002 JosephJ  Full reporting of misconfigurations and config difs

    Relevant bugs:
        360469 Warn user if whole cluster will come down because of operation.
        502793 warn user when attempting to remove / change DIP
        288769 error check: Verify that Primary IP, DIP and additional VIPs' ..

    The plan is to write a utility function with the following prototype:
    
    NLBERROR
    AnalyzeConfigurationPair(
        IN const EXTCFG    &Cfg,
        IN const EXTCFG     *pOtherCfg,
        IN BOOL             fOtherIsCluster,
        IN BOOL             fCheckOtherForConsistancy,
        OUT BOOL            fConnectivityChange,
        IN OUT CLocalLogger &logErrors,
        IN OUT CLocalLogger &logDifferences
        );
    //
    // logErrors - a log of config errors
    // logDifferences - a log of differences between
    //      Cfg and UpOtherCfg.
    // fCheckOtherForConsistancy -- if true, we will check Cfg 
    //      against pOtherCfg. If fOtherIsCluster, we expect
    //      cluster wide properties to match, else we expect
    //      cluster-wide properties to match as well as host-specific
    //      properteis to not conflict.
    //
    
    Also a new related function for analyzing a SINGLE configuration for
    validity with itself (eg CIP should be in the IP address list):
        NLBERROR
        AnalyzeNlbConfiguration(
            IN const NLB_EXTENDED_CLUSTER_CONFIGURATION &Cfg,
            IN OUT CLocalLogger &logErrors
            );
        
    These two functions are a superset of  the existing functions 
    analyze_nlbcfg(in engine.cpp) and EXTCFG::AnalyzeUpdate and
    CfgUtilsAnalyzeNlbUpdate.

    So we'll stop using those functions and use these functions instead.

    
Traffic mode change:
    From unicast to multicast
    WARNING: asda asdfasdf asdfasdf 

IP addresses to be added:
    10.0.0.1/255.255.255.0
    10.0.0.1/255.255.255.0
    10.0.0.1/255.255.255.0
    10.0.0.1/255.255.255.0

IP addresses to be removed:
    10.0.0.1/255.255.255.0
    10.0.0.1/255.255.255.0

IP addresses to have subnet mask changed:
    10.0.0.1: From 255.255.255.0 to 255.255.0.0

Cluster name change:
    From "" to ""

Remote Control:
    From enabled to disabled
    New password specified

Some port rules were added, removed or modified.

Cluster-wide-control: stops and suspends.

    502793 warn user when attempting to remove / change DIP

01/04/2002  JosephJ Bug in  CNlbEngine::mfn_ReallyUpdateInterface -- keep copy
    of a internal bstr pointer without lock held.
    ConnInfo.szUserName = (LPCWSTR) pHSpec->m_UserName;
    (and related bstrs) -- should replace by keeping keeping bstr local
    variables. Check for other places where this can occur.

01/04/2002  JosephJ -- wierd "/" ip addresses showing up (gjack)

01/08/2002 JosephJ checked in to LAB03 fixes for the following
    203647  NLBManager should wrap the WMI error...
    326514 Modify remote-control pwd, report differences in pwd:
    509397  error check: when inital state conflicts a warning is given...
    509400  error check: add check for conflicting port rule where affinity..
    484842 For localization compatibility, replace all %xx fields by %num

    202129 Make equal/unequal property of port rules a host-specific property.
    203634 Nlb Manager should report useful error when netcfgs..
    485541 Provide valid defaults for host-priorities to single-host port rule
    288769 error check: Verify that Primary IP, DIP and additional VIPs' ..
    360469 Warn user if whole cluster will come down because of operation.

01/08/2002  JosephJ Checks for preventing attempt to remove/change DIP
    502793  warn user when attempting to remove / change DIP
    (Also, check if new dip is already used elsewhere)

    1. Place to add check:  HostPage::mfn_ValidateDip
    2. What to check for?
            LookupIfByIP, see if IF matches
            LookupHostByConnIP -- see if we find one.
            LookupClusterByIp -- fail if we find one.


01/10/2002  More IP address checks
    If adding a new host or creating a new cluster, and the cip matches
    the IF already on that cluster, we end up having the same dip and VIP.
    Need to fix this case.

    Still problems:
        If you pick an IF with first IF matching cip, we now put blank.
        However, if you go back to cluster page, make a change, then
        back again to host page, we don't appear to re-do this change.

   We should LOCK DOWN the if if we find that the cip matches that IF. 

01/11/2002  JosephJ Steps to add support for query cluster members
    1. Implement SKELETON  CfgUtilGetClusterMembers -- just return failure
        Prototype is already defined in nlbmgr\inc\cfgutil.h
        Implementation goes in nlbmgr\cfgutillib\cfgutil.cpp,
        below function CfgUtilControlCluster.
    2. Implement test harness in nlbmgr\provider\tests\tprov.cpp
         Implement function parse_query (see parse_control for sample code)
         Suggestded output format:

                HosdID      DedicatedIP     HostName
                ----------------------------------------------------
                1           0.0.0.0         "nlb-x.cheesegalaxy.com"
                2           0.0.0.0         "nlb-y.cheesegalaxy.com"
                ... etc
    3. Test test harness itself...
         Compile tprov.exe with the line
            "// NlbHostFake();" in tprov.cpp UNcommented.
         Using this version, type:
             tprov.exe nlb-x u nic1
             query                          ; to call function parse_query
             q                              ; to quit
         The above  exercises the WMI version. Since it's useing the fake (demo)
         version, it  connects to fake host "nlb-x" and loads the configuration
         for NIC "nic1". The "query" command applies to that nic.
         NlbHostGetClusterMembers (running in fake mode) will return info
         for a single member -- so you can test your parse_query() code to
         make sure it is displaying the output correctly (see sample format
         above).

         Now using the same tprov.exe, type:
             tprov.exe - al
         This will list a list of REAL NICs and guids on your test machine.
         Then pick a NIC xxx and type
            tprov - u xxx
            query
            q
         This will again call parse_query, but this time it should call
         CfgUtilGetClusterMembers (which you have implemented a skeleton
         version in sstep 1).

         NOTE: the Real function is called for this, not any fake stuff (the
         fake stuff applies only to WMI).

     4.  Implement CfgUtilGetClusterMembers fully
        (By now your test harness has been implemented and tested)
         Test using:
                 tprov.exe - u xxx          (where xxx is the adapter name)
                 query
                 q

     5.  Implement NlbHostGetClusterMembers
          Prototype is already defined in nlbmgr\inc\nlbclient.h
          Skeletion implementation exists in nlbmgr\nlbclientlib\nlbclient.cpp
          Look at NlbHostGetCompatibleNics for an example of dealing with
          arrays of strings.

     6.  Implement SKELETON ProvGetClusterMembers in nlbmgr\provider\nlbsnic.cpp
            The prototype is already defined in nlbsnic.cpp.
            Implement it below existing function ProvControlCluster
            
            Call it from ProvExecStaticMethod (just below the call to
            ProvControlCluster, if bstrMethodName matches "GetClusterMembers").

            The skeleton implementation can just populate the 3 string
            arrays with fake data, just so you can make sure that all
            the wmi gook (both client and server) are working before you
            plug in the real call to CfgUtilGetClusterMembers

     7. Test the above skeleton implementation using (locally, using WMI):
            tprov  . u xxx      (where xxx is the adapter name)
            query
            q

            The query output should list the fake info you added in Step 6.

     8.  Implement and test ProvGetClusterMembers fully
            Make it call CfgUtilGetClusterMembers.
            Refer to ProvControlCluster, and ProvGetCompatibleAdapterGuids
            for sample code.
        
        Test using procedure in Step 7.
        Additionally test remote operation by using:
            tprov  mmm u xxx    (where mmm is machine name and xxx is the adapter name)
            query
            q

01/15/2002 JosephJ Plan for Mode Change

    1. If mode change, bring up a message box explaining the steps...
    2. Save away a copy of the cluster params IP address list.
    3. Do the update operation once.
    4. When it completes, check that all IFs have the same mode and
        that they match the cluster-specific version.
       If NO, list the IPaddresses and subnets in the log entry and mention what
       happened.
       If YES, re-enter the cluster IP addresses and try again.

    Issue: once we make update parallel, what will we do?
        
        UpdateInterface


01/21/2002  JosephJ Latest thoughts on RefreseshInterface, RefreshCluster, etc..
    New policy on when the cluster-wide copy of properties is updated.

    Cluster-props are ONLY updated on a refresh-cluster. In this case,
    the properties are updated only for the FIRST host that has NLB
    bound to the specified IP address.

    They are NOT updated when:
        add host
        refresh host
        update cluster props
        update host props


    The above behavior is different than what is implemented currently, when
    the cluster is refreshed more aggressively, for example, when updating
    a host's properties.

    However it is an improvement, as it has simpler semantics and makes it
    more clear (via misconfig reporting) when there are discrepancies between
    the cluster-wide version and host versions.

    So there will be two RefreshInterface versions:

    RefreshInterface(BOOL fClusterRefresh)  has the following semantics:
        if (!fClusterRefresh)
        {
            Verify that there is no cluster-wide operation ongoing.
        }

        Start interface operation (bail if we can't start)
        call mfn_RefreshInterface(TRUE); // TRUE == report misconfig.
        Remove interface if not in cluster
        Remove cluster if no more interfaces in cluster

    mfn_RefreshInterface(BOOL fReportMisconfig)
    {
        really refresh interface
        
        if (fReportMisconfig)
        {
            Check against cluster props and all non-misconfig hosts upto
            this one, and report misconfigurations if any
        }
    }


    RefreshCluster (or rather UpdateInter with NULL pConfig)
    {
        start-cluster-opearation (bail if can't start)

        BOOL fClusterPropsUpdated = FALSE;

        for each interface
        {
            fRet = RefreshInterface(TRUE); // TRUE == cluster refresh
            if (    fRet
                 && !fClusterPropsUpdated
                 && props bound to NLB
                 && cluster-ip matches )
            {
                Update cluster props for 
                 fClusterPropsUpdated = TRUE;
            }
        }
    }


01/22/2002  shouse
    Features added:
    * F5 refreshes only the cluster or interface selected in the tree view. CTRL+F5
      refreshes ALL clusters in the tree view.
    * A new command line option, /autorefresh [interval], will instruct NLB manager
      to automatically refresh its view every <interval> seconds.  By default, this
      is not turned on and must be specified on the command line to activate it.  The
      default <interval> is 60 seconds and the minimal allowable <interval> is 15
      seconds.
    * Cluster IPs dialog is now a listview with IP address control popups to edit
      and add virtual IP addresses to a cluster.
    * Added columns in the host and port rule detail views to contain statistics and
      state, such as the state of a port rule and approximate load being handled, and
      some convergence information, such as the total number of convergences by a 
      particular host and the time of the last convergence.  Along with auto-refresh, 
      these should give a user a nice way to monitor some information about a live
      cluster, rather than just using NLB manager for configuration.  Note the the
      WMI support for retrieving this information is not yet available, so the columns
      are empty - they will be supported soon.
    * Lots of UI cleanup was done - hopefully this is the last round.

    Notes:
    To eliminate the selected text in an edit box, which seems to select everything
    by default, subscribe to the WM_ACTIVE notification and SetSel(0, 0, FALSE).
    This does not work when executed from OnInitDialog for some unknown reason.

    To decipher multiple key combinations such as CTRL+F5, subscribe to the WM_KEYDOWN
    notification and ignore all keys other than the one(s) you're filtering for, 
    including modifiers (CTRL, ALT, Shift, etc.).  When the key you're interested in
    is pressed, use GetKeyState(VK_WHATEVER) to retrieve the up/down state of any
    modifiers you're interested in.  GetKeyState returns a SHORT.  If the most signif-
    icant bit it set, the key is pressed down; otherwise, it is not.  For example:

    void OnKeyDown (UINT nChar, UINT nRepCnt, UINT nFlags) {
        if (nChar == VK_F5) {
            if (GetKeyState(VK_CONTROL) & 0x8000)
		::MessageBox(NULL, L"The CTRL is pressed!!!\n", L"Notice", MB_ICONINFORMATION | MB_OK);
            else
      		::MessageBox(NULL, L"The CTRL is NOT pressed!!!\n", L"Notice", MB_ICONINFORMATION | MB_OK);
        }
    }

    To re-size a control within a window or frame, subscribe to the WM_SIZE noti-
    fication of the window or frame.  In the handler for this notification, use
    GetClientRect to get the window coordinates of the window or any controls within
    it.  Use MoveWindow to resize the control you wish to modify.  For example,
    suppose you wanted to resize an edit control to be the size of the window around
    it, but with a border of 15 pixels on each side.  To do this:

    void OnSize (UINT nType, int cx, int cy) {
        RECT WindowRect;
        RECT MyRect;
        
        /* Get a pointer to the edit box. */
        CWnd * pEdit = GetDlgItem(IDC_EDIT_WHATEVER);

        /* Get the client rectangle of the window. */
        GetClientRect(&WindowRect);
        
	MyRect.top = WindowRect.top + 15;
        MyRect.left = WindowRect.left + 15;
        MyRect.bottom = WindowRect.bottom - 15;
        MyRect.right = WindowRect.right - 15;

        pEdit->MoveWindow(&MyRect, TRUE); 
    }

01/23/2002 JosephJ DEADLOCK in Leftview::mfn_Lock
    
    Background (thread pool) thread aquires LeftView lock, then gets stuck in 
    CTreeCtrl::SetItem, which does a SendMessage and blocks, I guess waiting for
    the main application windows message loop to process the message.

        USER32!SendMessageW+0x44
        CTreeCtrl::SetItem+0x1f
        LeftView::mfn_InsertInterface+0x258
        LeftView::HandleEngineEvent+0x344
        Document::HandleEngineEvent+0x72
        CNlbEngine::ControlClusterOnInterface+0x1
        CNlbEngine::RefreshInterfaceNew+0x4fe
        CNlbEngine::mfn_ReallyUpdateInterface+0x4
        CNlbEngine::UpdateInterfaceWorkItem+0x205
        UpdateInterfaceWorkItemRoutine+0x11


    Unfortunately, the main (winmsg) thread, cant process messages because it's
    stuck trying to acquire the LeftView lock!
        LeftView::mfn_Lock+0x22
        LeftView::mfn_InsertCluster+0x11f
        LeftView::HandleEngineEvent+0x13c
        Document::HandleEngineEvent+0x72
        CNlbEngine::UpdateCluster+0x22b (FPO: [No
        LeftView::OnRefresh+0x150
        LeftView::OnKeyDown+0x37


    RESOLUTION:

        Changed the implementation of CLeftView::mfn_Lock from

            EnterCriticalSection(&m_crit)

        to

            while (!TryEnterCriticalSection(&m_crit))
            {
                ProcessMsgQueue();
                Sleep(100);
            }


    I verified this by deliberatly producing the deadlock by introducing
    sleeps, then verifying that the deadlock doesn't happen if the above
    version of mfn_Lock is used.

01/24/2002  JosephJ How to hook the "CLOSE" message
   1. To MainForm add:
        afx_msg void OnClose( );

   2. Implement OnClose  ...

        void MainForm::OnClose( )
        {
            int sel = MessageBox(
                      L"OK to close?",
                      L"OK to close?",
                      MB_OKCANCEL | MB_ICONEXCLAMATION
                      );
        
            if ( sel == IDOK )
            {
                CFrameWnd::OnClose( );
            }
        }

   3. Make sure it gets called ...

    BEGIN_MESSAGE_MAP( MainForm, CFrameWnd )
        ...
        ON_WM_CLOSE()
        ...
    END_MESSAGE_MAP()

01/24/2002  JosephJ Dealing with app closing

    On wm close, put up msgbox/dlg:

        Title: Close NLB Manager
        Text:
            OK to close NLB Manager while the following operation(s)
            are in progress?

            <list of operations>

            OK CANCEL


    On OK -- call Document->PrepareToClose() .... 

    VOID
    Document::PrepareToClose(void)
    {
        //
        // Cancel any pending operations in the engine, and prevent any
        // new operations to be launched. During this time, we want the
        // views and the log to be updated, so we don't PrepareToDeinitialize
        // for ourselves or the views yet...
        //
        {
            CWaitCursor wait;
            gEngine.PrepareToDeinitialize();
            // After the Engine's PrepareToDeinitialize function is called, it
            // fails attempts to create new handles and new operations.
            gEngine.CancelAllPendingOperations(TRUE); // TRUE == block
        }
    
        //
        // At this time there should be no more pending activity. Block
        // any further updates to the views...
        //
    
        m_fPrepareToDeinitialize = TRUE;
    
        if (m_pLeftView != NULL)
        {
            m_pLeftView->PrepareToDeinitialize();
        } 
        if (m_pDetailsView != NULL)
        {
            m_pDetailsView->PrepareToDeinitialize();
        } 
        if (m_pLogView != NULL)
        {
            m_pLogView->PrepareToDeinitialize();
        } 
    }
    (See also entry right below ...)

01/24/2002  JosephJ Dealing with work items on app closing.

    The classic problem here is that the moment the work item signals
    that it's done, it can trigger the deinitialization of the app,
    before the work item completes.

    So to avoid this, I keep a CNlbEngine::m_WorkItemCount, which
    is maintained by InterlockedIncrement/Decrement.

    CNlbEngine::CancelAllPendingOperations will block until this count
    goes to zoro (as well as until the operations go to zero). The
    logic is quite subtle -- see this function for details.

01/24/2002  JosephJ Creating our own extended MessageBox:

    Uses:
        Report misconfigs -- OK
        Report pending operations on close -- OK CANCEL
        Report proposed cluster changes  -- YES NO

    Format:
    
        text
    
        <listbox>
    
        text
    
        <buttons>
    
    
01/29/2002 JosephJ problems with updating UI in the background thread.
    Backing out of doing updates in a work items for now, because of misc
    AVs and deadlocks during the update process.


01/29/2002 JosephJ problems with re-entrancy of Application::ProcessMsgQueue
    ProcessMsgQueue was getting reentered and we got a deadlock
    in handling WM_CLOSE (which ends up calling Document::PrepareToClose,
    which calls  CNlbEngine::CancelAllPendingOperations which deadlocks
    waiting for all operations to go to zero because the WM_CLOSE msg was
    handled in the context of waiting to retry to get an update completion
    status.

    Temporary fix:
    - Keep a reentrancy count in Application:  m_lMsgProcReentrancyCount.
    - Application::ProcessMsgQueue will do an interlocked increment on this,
      and if the result is > 1, it simply does a decrement and returns.
    - Various UI-initiated functions don't do anything if called in
      the context of ProcessMsgQueue (i.e, called when m_lMsgProcReentrancyCount
      is > 0. The function Application::IsProcessMsgQueueExecuting checks
      for this case.

01/30/2002 JosephJ  checked in the following
    334243  perform extended operations in the background; allow a cancel
    484025  When using alt-F4 to close nlbmgr.exe, the process stays in memory.
    513056  add host failed because nlbmgr ended up pinging for "13:36:48".
    502793  warn user when attempting to remove / change DIP
    512303  Block user from merging 2 clusters that are in the nlbmgr context
    512370  update sometims fails when IP is zero (0.0.0.0)
    478932  ipconflict when changing modes of operation ( unicast to multicast )
    505153  NlbConfigurationUpdate::DoUpdate returns WBEM_E_ALREADY_EXISTS
    509346  delete host adds a homenet IP when it should keep the DIP
    509355  replace or remove home net ip functions like IP with the real home

02/08/2002 JosephJ suspicious imported functions
    FormatMessageW
    lstrcpyW
    WideCharToMultiByte
    lstrlenW
    GetFileAttributesW
    LockResource
    LoadResource
    FindResourceW
    GetCurrentProcess
    InitializeCriticalSection
    GetComputerNameExW
    MultiByteToWideChar
    GetStartupInfoW
    LoadLibraryW
    VirtualQuery
    _XcptFilter
    _wspawnlp
    _wgetenv
    _ftol
    _wfsopen
    RegCreateKeyExW
    TraceEvent
    RegQueryValueExW
    RegSetValueExW
    LoadStringW
    WinHelpW
    wsprintfW
    GetClientRect
    LoadIconW
    LoadMenuW
    CoCreateInstance
    CLSIDFromString
    CoSetProxyBlanket
    
    CredUIPromptForCredentialsW
    IcmpCreateFile
    IcmpSendEcho2

Code review tool:
http://shell/Development/Danger/Dangerous%20APIs.htm
http://massweb/security/Lists/Announcements/DispForm.htm?ID=8&Source=http%3a%2f%2fmassweb%2fsecurity%2f

// 2/12/02 JosephJ SECURITY BUGBUG:

02/14/2002 JosephJ Processing UI updates in the foreground
    This is completing the fix to:
        334243  perform extended operations in the background; allow a cancel

    Changes:

    Added a application-specific message: MYWM_DEFER_UI_MSG 
    Added class CUIWorkItem in document.h -- this data class encapsulates
        the parameters for (a) log messages and (b) HandleEngineEvent
        notifications.

    Added Document::mfn_DeferUIOperation(CUIWorkItem *pWorkItem) --
        it posts a MYWM_DEFER_UI_MSG message to the MainForm's window's queue
        (the pointer to the mainform object is saved in global g_pMainFormWnd --
         a bit of a hack).
    Added Document::HandleDeferedUIWorkItem(pWorkItem) --
        will actually call the Log or HandleEngineEvent encapsulated in
        a work item.

    Added virtual function MainForm::WindowProc that overrides the default
        window handling proc, and on getting a MYWM_DEFER_UI_MSG, will
        extract the work item (lParam) and call
        pDocument->HandleDeferedUIWorkItem.

04/09/2002 JosephJ Bugs at this point:

P1's
    489012  If ICMP is disabled by customer for security reasons, they cannot
    538191  user's password saved in user-mode memory
    540636  password is not updated locally
    535616  memory leak running remove from view
    535969  too much memory allocated for event logs
    568198  remove from view should not remember cluster properties
    
P2's:
    540917  Duplicate shortcut character "P" are there.
    565697  delete host when host is unreachalbe
    563150  PREFIX:net: \nt\net\wlbs\nlbmgr\provider\updatecfg.cpp:
    566671  NLBS:NET3:nlbmgr.exe:Typo:Cluster configuration
    585280  NLBMgr fails to look up a cluster instance where nlb was bound

    552641  autorefresh require valid input as int and is in a reasonable
    528007  Error message pops up stating "invalid cluster IP" when viewing
    532302  invalid user credentials:If machine is not on a domain anything is
    535561  mgr says that ping failed but ping.exe succeeds


Done:
    1. Remove demo mode in retail build -- remove it from the help message too
    2. 489012  If ICMP is disabled by customer for security reasons, they ...
        x Add NoPing option (remember to add it to cmdline help)
        x Add fNoPing and fNlbMgr flag to CfgUtilsInitialize
    3. 538191  user's password saved in user-mode memory
    7. 540917  Duplicate shortcut character "P" are there.
    9. 566671  NLBS:NET3:nlbmgr.exe:Typo:Cluster configuration
    3. 540636  password is not updated locally
    7. Make nlbmgr.exe NOT load wlbsctrl.dll -- even if it's not there
        (so make CfgUtilInitialize take a "nlbmgr.exe" flag).

04/15/2002  JosephJ details of fix to:  538191  user's password saved in
                                                user-mode memory
    The password is stored internally in an encrypted form. It is
    decrypted only when
     (a) bringing up UI to modify the password -- this is done
         in  PromptForEncryptedCreds; and
     (b) when connecting to a host -- this is done in 
         nlbclient.lib!connect_to_server
         (in wlbs\nlbmgr\nlbclientlib\nlbclient.cpp).

    Encryption scheme: We call RtlEncrypt/DecryptMemory with "0" as flags.
    Additional, we "encode" the binary encrypted form into a printable
    version (which is also guaranteed to not have any 0 characters, so
    it can be stored and processed as any other string). This was done because
    the password is stored and processed in several places where it is assumed
    to be a string, or bstr etc. The encrypt/decrypt and encode/decode is
    done in cfgutillib!CfgUtilEncrypt/DecryptPassword
    (in wlbs\nlbmgr\cfgutillib\cfgutil.cpp). Test program
    nlbmgr\provider\tprov.cpp has function  test_encrypt_memory() which
    does rudimentary functional tests on CfgUtilEncrypt/DecryptMemory.

04/15/2002 JosephJ details of fix for 540636  password is not updated locally
    Problem is that on setting a new remote control password (a cluster level
    change), the cluster's NLB properties hashed password value is not
    updated, so after each host is updated, it reports an config error because
    its hash value doesn't match the cluster's (obsolete) value.

    Fix is to:
        1. Mark the cluster's hash value as being stale -- this is done
           by a new flag  CClusterSpec::m_fNewRctPassword
           which is set to true IFF the user has just specifed a new
           passord, and the hosts are in the process of carrying out the
           update. It is set in  CNlbEngine::UpdateCluster (look
           for m_fNewRctPassword).
        2. When analyzing an interface for config errors, when checking
           the interface's config against the cluster config, the
           check of remote control hash is NOT made if the cluster's
           m_fNewRctPassword flag is set. This is done in 
           CNlbEngine::mfn_AnalyzeInterfaceLk which calls
           analyze_nlbcfg with a parameter "ignore rct password" set 
           appropriately. analyze_nlbcfg will ignore the rct password check
           if this flag is set.
        3. Once an interface update is complete, AND if a new password has
           been set, AND the update completed successfully, AND
           the cluster's m_fNewRctPassword flag is TRUE, THEN
           we update the clusters's remote control hash value and clear
           the cluster's m_fNewRctPassword flag. This is all done in
           CNlbEngine::mfn_ReallyUpdateInterface, which actually performs
           the interface update and synchronously waits for the update to
           complete.

04/15/2002 JosephJ details of fix for  568198  remove from view should not
                                               remember cluster properties

    Problem is that we remember all configs on all hosts we have ever
    connected to. So even if we've unmanaged a cluster, we report a conflict
    if some config conflicts with this removed cluster.

    Fix is to (gulp) delete hosts from nlbmgr once the last managed
    cluster goes away. One side effect will be that the credentials used
    to connect to that host are lost -- we can keep a separate datastructure
    just for that if needed.

    New function CNlbEngine::mfn_DeleteHostIfNotManagedLk
           deletes the host and  its interfaces if the interfaces
           are not part of any cluster (and have no ongoing operation on them,
           although the latter should never happen if the interface is not part
           of a cluster). Need to watch for the case of pruning hosts wile
           they are in the process of being added in the context of 
           hostlist (we don't check -- could be a potential problem).

           CNlbEngine::DeleteCluster calls mfn_DeleteHostIfNotManagedLk
           for each of its interfaces.

           CNlbEngine::UpdateInterfaceWorkItem calls 
           mfn_DeleteHostIfNotManagedLk if once done updating, the interface is
           now unbound.

    New function CNlbEngine::PurgeUnmanagedHosts:
        This function effectively calls mfn_DeleteHostIfNotManagedLk for
        all hosts.

        This function is called from leftview.cpp from all the places that
        bring up the ConnectDialog UI, after it is done with processing the UI.
        It is called here because the ConnectDialog UI can create several
        unmanaged hosts -- either if the user keeps connecting to different
        computers or because the user cancels from the dialog. We could have
        cleaned this up in the ConnectDialog itself, but it's a bit tricky.

        We also call this function at the end of LeftView::OnRefresh.

        This need to call this purge function from several places is not
        very clean.



04/17/2002 JosephJ Not overwriting the user-entered connection string
                   with the FQDN obtained from the hosts via connect-to-existing

    This was causing a subsequent attempt to connect to the same host to fail
    because the user didn't specify the fqdn.

    Added a boolean paramater "fOverwriteConnectionInfo" to
    CNlbEngine::ConnectToHost. If this is true, it will overwrite any
     previously-existing connection info (connection string, username pwd)
     with those specified in pConnectionInfo.
    The UI (ConnectDialog::OnButtonConnect) calls  ConnectToHost specifying
    TRUE (override), while CNlbEngine::LoadHost calls ConnectToHost specifying
    false (don't override). LoadHost is called in the context of 
    Connect-to-existing, so with this fix, it doesn't overwrite the
    info intered via the UI.

    Also needed to added this same flag to CNlbEngine::mfn_RefreshHost.

04/17/2002 Preventing the cluster from being unmanaged if there are pending ops
    CNlbEngine::DeleteCluster now calls a newly written function
       CNlbEngine::mfn_ClusterOrInterfaceOperationsPendingLk,
       which reports whether there are any pending operations on a cluster or
        on its interfaces. If this is the case, the DeleteCluster
        (which is what "unmanages" the cluster) fails.
    


04/17/2002  Details of fix for  535969  too much memory allocated for
                                 event logs -- also limit growth of log file...

    Logfile:

        On file open, seek to the end (but don't check for file size) -- we
        don't check so that a message gets logged in the case of
        starting nlbmgr with a size already too large.

        In Document::logStatus , check (using ftell) if the position exceeds
        the max size (tentatively 10MB) -- if so it logs an event and closes
        the log file.

        In the context of  Document::logStatus,  I log a message saying that
        the file-size has exceeded. This gets logged even on starting
        up nlbmgr with a file that is too large -- so the user is
        notified of this.

    Pruning in-memory log:
        In log-string, if in-memory count of lines is exceeded by 100, it
        will delete the earliest 100 and then add a warning log msg about
        deletinon.

        This is done in  LogView::LogString.

04/18/2002 JosephJ Details of fix to  565697  delete host when host is
                                              unreachalbe.

        In LeftView::OnHostRemove, if the host state is unreachable,
        bring up UI asking if we should simply stop managing this host.

        We also need to properly track the reachable/unreachable state of
        the host -- we now do this in mfn_Refresh

05/10/2002 JosephJ Details of fix to 603411 nlbmgr:ACCESSIBILITY:can not tab
                   between window panes
    1. Need to catch VK_TAB and VK_F6 in each of the views --
        this was simple to do on the left and log views, but a pain on
        the details-view (and in fact we could not figure out out to capture
        TAB in the detail's view (which is a form view)).

      -- for left and log view:
         Add a OnKeyDown handler (including add a  ON_WM_KEYDOWN() entry
         in the message map.
         Check the OnKeyDown functions for LeftView and LogView, under
         VK_TAB and VK_F6 -- check also how we check for the SHIFT key
         being pressed (because if it is we go anticlockwise around the
         views).
       -- for DetailsView:
          Add to message map:
            ON_NOTIFY(LVN_KEYDOWN,  IDC_LIST_DETAILS, OnNotifyKeyDown)
          See DetailsView::OnNotifyKeyDown for more details...
    2. Need to decide which view to shift focus to -- this is done
        in Document::SetFocusNextView and  SetFocusPrevView.
    3. For setting the focus on DetailsView, we can't simply call
        SetFocus on that view's CWnd -- instead we need to call
        SetFocus on the detail view's list control -- (we got very flaky
        behavior calling SetFocus in DetailsView's CWnd).
        Also we need to select an item in the list control if none is selected
        so the user can get some visual cue.
        All this is implemented in DetailsView::SetFocus.
    4. Because we can't hook the TAB key in the details view, we
        just toggle between leftview and log view when the user presses TAB,
        but cycle between all three when F6 is pressed.

05/13/2002 ChriDar
    Need to check code for memory allocation failures. One example noted is
    in the Document class constructor. A CImageList is constructed and dereferenced,
    but the memory alloc wasn't verifed.

08/22/2002 JosephJ

    Fix for:
 
        CyndaR:
        So, if you connect to the to be NLB host with the DHCP assigned ip
         address of the nic to be bound to NLB, the wizard will show the DIP
         and subnet mask as blank. If you try to specify anything it produces
         the error that Frank referenced. The wizard allows you to continue
         even if the DIP is left blank and will result in only the cluster ip
         address being bound to the nic. The dip is now blank in NLB properties
         of network connections and NLBMgr can no longer connect to the host to
         get status update. NLBMgr will indicate that NLB is not bound to the
         NLB host and if you refresh it will tell you that the host is
        unreachable.
        
    Fix is to add the check in ConnectDialog::mfn_ValidateData() (connect.cpp):

        ...
        if (ehConnectionIF == *m_pehSelectedInterfaceId)
        {
           if (iSpec.m_NlbCfg.fDHCP)
           {
                put up a message box and return error.
           }
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\wmi\tracewpp.ini ===
FUNC TRACE_CRIT{LEVEL=Critical}(MSG,...);
FUNC TRACE_INFO{LEVEL=Informational}(MSG,...);
FUNC TRACE_VERB{LEVEL=Verbose}(MSG,...);
FUNC TRACE_FULL{LEVEL=Full}(MSG,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\xml\microsoftnlb.xml ===
<?xml version="1.0"?>
<Schema name="MicrosoftNLB" xmlns="urn:schemas-microsoft-com:xml-data" xmlns:dt="urn:schemas-microsoft-com:datatypes">
  <ElementType name="GUID" content="textOnly" dt:type="string"/>
  <ElementType name="Name" content="textOnly" dt:type="string"/>
  <ElementType name="Adapter" order="one" content="eltOnly" model="closed">
    <element type="GUID"/>
    <element type="Name"/>
  </ElementType>
  <ElementType name="Address" content="textOnly" dt:type="string"/>
  <ElementType name="SubnetMask" content="textOnly" dt:type="string"/>
  <ElementType name="IPAddress" order="seq" content="eltOnly" model="closed">
    <element type="Address" minOccurs="1" maxOccurs="1"/>
    <element type="SubnetMask" minOccurs="0" maxOccurs="1"/>
  </ElementType>
  <ElementType name="PrimaryIPAddress" order="seq" content="eltOnly" model="closed">
    <element type="IPAddress" minOccurs="1" maxOccurs="1"/>
  </ElementType>
  <ElementType name="SecondaryIPAddress" order="seq" content="eltOnly" model="closed">
    <element type="IPAddress" minOccurs="1" maxOccurs="*"/>
  </ElementType>
  <ElementType name="IGMPMulticastIPAddress" order="seq" content="eltOnly" model="closed">
    <element type="IPAddress" minOccurs="1" maxOccurs="1"/>
  </ElementType>
  <ElementType name="DedicatedIPAddress" order="seq" content="eltOnly" model="closed">
    <element type="IPAddress" minOccurs="1" maxOccurs="1"/>
    <element type="Adapter" minOccurs="0" maxOccurs="1"/>
  </ElementType>
  <ElementType name="ConnectionIPAddress" order="seq" content="eltOnly" model="closed">
    <element type="IPAddress" minOccurs="1" maxOccurs="1"/>
  </ElementType>
  <ElementType name="VirtualIPAddress" order="seq" content="eltOnly" model="closed">
    <element type="IPAddress" minOccurs="1" maxOccurs="1"/>
  </ElementType>
  <ElementType name="Mode" content="textOnly" dt:type="enumeration" dt:values="Unicast Multicast IGMP"/>
  <ElementType name="NetworkAddress" content="textOnly" dt:type="string"/>
  <ElementType name="DomainName" content="textOnly" dt:type="string"/>
  <ElementType name="RemoteControl" order="seq" content="empty" model="closed">
    <AttributeType name="Enabled" dt:type="boolean" required="yes"/>
    <AttributeType name="Password" dt:type="string" required="no"/>
    <attribute type="Enabled"/>
    <attribute type="Password"/>
  </ElementType>
  <ElementType name="TeamID" content="textOnly" dt:type="string"/>
  <ElementType name="Hashing" order="seq" content="empty" model="closed">
    <AttributeType name="Reverse" dt:type="boolean" required="yes"/>
    <attribute type="Reverse"/>
  </ElementType>
  <ElementType name="BDA" order="seq" content="eltOnly" model="closed">
    <AttributeType name="Master" dt:type="boolean" required="yes"/>
    <attribute type="Master"/>
    <element type="TeamID" minOccurs="1" maxOccurs="1"/>
    <element type="Hashing" minOccurs="1" maxOccurs="1"/>
  </ElementType>
  <ElementType name="Properties" order="seq" content="eltOnly" model="closed">
    <element type="PrimaryIPAddress" minOccurs="1" maxOccurs="1"/>
    <element type="SecondaryIPAddress" minOccurs="0" maxOccurs="1"/>
    <element type="IGMPMulticastIPAddress" minOccurs="0" maxOccurs="1"/>
    <element type="DomainName" minOccurs="0" maxOccurs="1"/>
    <element type="Mode" minOccurs="0" maxOccurs="1"/>
    <element type="NetworkAddress" minOccurs="0" maxOccurs="1"/>
    <element type="RemoteControl" minOccurs="0" maxOccurs="1"/>
    <element type="BDA" minOccurs="0" maxOccurs="1"/>
  </ElementType>
  <ElementType name="InitialState" order="seq" content="empty" model="closed">
    <AttributeType name="Default" dt:type="enumeration" required="no" dt:values="Started Stopped Suspended"/>
    <AttributeType name="PersistSuspended" dt:type="boolean" required="no"/>
    <attribute type="Default" default="Started"/>
    <attribute type="PersistSuspended" default="0"/>
  </ElementType>
  <ElementType name="HostName" content="textOnly" dt:type="string"/>
  <ElementType name="Host" order="seq" content="eltOnly" model="closed">
    <AttributeType name="Name" dt:type="id" required="yes"/>
    <AttributeType name="Text" dt:type="string" required="no"/>
    <AttributeType name="HostID" dt:type="int" required="yes"/>
    <attribute type="Name"/>	
    <attribute type="Text"/>
    <attribute type="HostID"/>
    <element type="HostName" minOccurs="0" maxOccurs="1"/>
    <element type="Adapter" minOccurs="0" maxOccurs="1"/>
    <element type="InitialState" minOccurs="0" maxOccurs="1"/>
    <element type="DedicatedIPAddress" minOccurs="0" maxOccurs="1"/>
    <element type="ConnectionIPAddress" minOccurs="0" maxOccurs="1"/>
  </ElementType>
  <ElementType name="Hosts" order="seq" content="eltOnly" model="closed">
    <element type="Host" minOccurs="1" maxOccurs="*"/>
  </ElementType>
  <ElementType name="Node" order="seq" content="empty" model="closed">
    <AttributeType name="Name" dt:type="idref" required="yes"/>
    <AttributeType name="Priority" dt:type="int" required="no"/>
    <AttributeType name="Weight" dt:type="int" required="no"/>
    <attribute type="Name"/>
    <attribute type="Priority" default="1"/>
    <attribute type="Weight" default="50"/>
  </ElementType>
  <ElementType name="Priority" order="seq" content="eltOnly" model="closed">
    <element type="Node" minOccurs="1" maxOccurs="*"/>
  </ElementType>
  <ElementType name="Load" order="seq" content="eltOnly" model="closed">
    <element type="Node" minOccurs="1" maxOccurs="*"/>
  </ElementType>
  <ElementType name="Filtering" order="seq" content="eltOnly" model="closed">
    <AttributeType name="Mode" dt:type="enumeration" required="yes" dt:values="Single Multiple Disabled"/>
    <AttributeType name="Affinity" dt:type="enumeration" required="no" dt:values="None Single ClassC"/>
    <attribute type="Mode"/>
    <attribute type="Affinity" default="Single"/>
    <group order="one" minOccurs="0" maxOccurs="1">
      <element type="Priority"/>
      <element type="Load"/>
    </group>
  </ElementType>
  <ElementType name="PortRule" order="seq" content="eltOnly" model="closed">
    <AttributeType name="Name" dt:type="id" required="yes"/>
    <AttributeType name="Text" dt:type="string" required="no"/>
    <AttributeType name="Start" dt:type="int" required="yes"/>
    <AttributeType name="End" dt:type="int" required="yes"/>
    <AttributeType name="Protocol" dt:type="enumeration" required="no" dt:values="TCP UDP Both"/>
    <AttributeType name="State" dt:type="enumeration" required="no" dt:values="Enabled Disabled Draining"/>
    <attribute type="Name"/>
    <attribute type="Text"/>
    <attribute type="Start"/>
    <attribute type="End"/>
    <attribute type="Protocol" default="Both"/>
    <attribute type="State" default="Enabled"/>
    <element type="VirtualIPAddress" minOccurs="0" maxOccurs="1"/>
    <element type="Filtering" minOccurs="1" maxOccurs="1"/>
  </ElementType>
  <ElementType name="PortRules" order="seq" content="eltOnly" model="closed">
    <element type="PortRule" minOccurs="1" maxOccurs="*"/>
  </ElementType>
  <ElementType name="Cluster" order="seq" content="eltOnly" model="closed">
    <AttributeType name="Name" dt:type="id" required="yes"/>
    <AttributeType name="Text" dt:type="string" required="no"/>
    <attribute type="Name"/>
    <attribute type="Text"/>
    <element type="Properties" minOccurs="1" maxOccurs="1"/>
    <element type="Hosts" minOccurs="0" maxOccurs="1"/>
    <element type="PortRules" minOccurs="0" maxOccurs="1"/>
  </ElementType>
  <ElementType name="NLB" content="eltOnly" model="closed">
    <element type="Cluster" minOccurs="1" maxOccurs="*"/>
  </ElementType>
</Schema>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\xml\test\nlb-example.xml ===
<NLB xmlns="x-schema:MicrosoftNLB.xml">
  <Cluster Name="Microsoft.com" Text="My Favorite NLB Cluster">
    <Properties>
      <PrimaryIPAddress>
        <IPAddress>
          <Address>11.11.1.1</Address>
          <SubnetMask>255.0.0.0</SubnetMask>
        </IPAddress>
      </PrimaryIPAddress>
      <SecondaryIPAddress>
        <IPAddress>
          <Address>11.11.1.4</Address>
          <SubnetMask>255.255.255.0</SubnetMask>
        </IPAddress>
        <IPAddress>
          <Address>11.11.1.5</Address>
          <SubnetMask>255.255.0.0</SubnetMask>
        </IPAddress>
      </SecondaryIPAddress>
      <IGMPMulticastIPAddress>
        <IPAddress>
          <Address>239.255.202.134</Address>
        </IPAddress>
      </IGMPMulticastIPAddress>
      <DomainName>www.microsoft.com</DomainName>
      <Mode>IGMP</Mode>
      <NetworkAddress>01-00-5e-7f-ca-86</NetworkAddress>
      <RemoteControl Enabled="1" Password="PEZHead"/>
      <BDA Master="0">
        <TeamID>{c803f23f-b129-4002-958a-4d2f20c9cd61}</TeamID>
        <Hashing Reverse="1"/>
      </BDA>
    </Properties>
    <Hosts>
      <Host Name="Test1" HostID="3" Text="The little host that could">
        <InitialState Default="Started" PersistSuspended="1"/>
        <DedicatedIPAddress>
          <IPAddress>
            <Address>192.12.32.112</Address>
            <SubnetMask>255.255.248.0</SubnetMask>
          </IPAddress>
          <Adapter>
            <GUID>f5460169-2e75-4e03-b9af-eef89bff1cca</GUID>
          </Adapter>
        </DedicatedIPAddress>
        <ConnectionIPAddress>
          <IPAddress>
            <Address>192.2.18.115</Address>
            <SubnetMask>255.255.255.0</SubnetMask>
          </IPAddress>
        </ConnectionIPAddress>
      </Host>
      <Host Name="Test2" HostID="21" Text="Bench 3, Seat 4">
        <HostName>shouse-test2.corp.microsoft.com</HostName>
        <Adapter>
          <Name>Intel 10/100 Pro Server Adapter #2</Name>
        </Adapter>
        <InitialState Default="Stopped"/>
        <DedicatedIPAddress>
          <IPAddress>
            <Address>192.12.32.238</Address>
            <SubnetMask>255.255.248.0</SubnetMask>
          </IPAddress>
        </DedicatedIPAddress>
      </Host>
    </Hosts>
    <PortRules>
      <PortRule Name="HTTP" Text="Dubble-ya Dubble-ya Dubble-ya" Start="80" End="80" Protocol="TCP" State="Draining">
        <VirtualIPAddress>
          <IPAddress>
            <Address>11.11.1.4</Address>
          </IPAddress>
        </VirtualIPAddress>
        <Filtering Mode="Single">
          <Priority>
            <Node Name="Test1" Priority="2"/>
            <Node Name="Test2" Priority="7"/>
          </Priority>
        </Filtering>
      </PortRule>
      <PortRule Name="SSL" Start="443" End="443">
        <Filtering Mode="Multiple" Affinity="ClassC">
          <Load>
            <Node Name="Test1"/>
            <Node Name="Test2" Weight="65"/>
          </Load>
        </Filtering>
      </PortRule>
      <PortRule Name="Telnet" Text="Obsolete" Start="23" End="23" State="Disabled">
        <Filtering Mode="Disabled"/>
      </PortRule>
    </PortRules>
  </Cluster>
  <Cluster Name="www.msn.com">
    <Properties>
      <PrimaryIPAddress>
        <IPAddress>
          <Address>192.138.99.12</Address>
        </IPAddress>
      </PrimaryIPAddress>
    </Properties>
  </Cluster>
</NLB>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ddk\ddk_printscan.ini ===
; FORMAT : SourceDir, SourceFile, DestDir, DestFile, OPERATION
; All fields are required
; [subname]* is allowed for source, in which case * required for destination

print\drivers\usermode\ddk\bin                                    , makentf.exe , tools\print\x86                                   , *           , COPY
print\drivers\usermode\ddk\bin                                    , pgremlin.msi, tools\print\x86                                   , *           , COPY
print\drivers\usermode\ddk\mdt                                    , mdt.htm     , tools\print\x86                                   , mdt.htm     , HSPLIT
print\drivers\usermode\ddk\mdt                                    , minidev.cnt , tools\print\x86                                   , minidev.cnt , HSPLIT
print\drivers\usermode\ddk\mdt                                    , minidev.hlp , tools\print\x86                                   , minidev.hlp , COPY
print\drivers\usermode\ddk\mdt                                    , minidev.exe , tools\print\x86                                   , minidev.exe , COPY
print\drivers\usermode\ddk\mdt                                    , stdnames.gpd, tools\print\x86                                   , stdnames.gpd, HSPLIT
print\drivers\usermode\ddk\mdt                                    , tips.txt    , tools\print\x86                                   , tips.txt    , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL                         , *           , src\print\oemdll                                  , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\NT4                     , *           , src\print\oemdll\NT4                              , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\NT4\INC                 , *           , src\print\oemdll\NT4\INC                          , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\OEMPS                   , *           , src\print\oemdll\oemps                            , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\OEMPS\KMODE             , *           , src\print\oemdll\oemps\kmode                      , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\OEMPS\UMODE             , *           , src\print\oemdll\oemps\umode                      , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\OEMUI                   , *           , src\print\oemdll\oemui                            , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\OEMUNI                  , *           , src\print\oemdll\oemuni                           , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\OEMUNI\KMODE            , *           , src\print\oemdll\oemuni\kmode                     , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\OEMUNI\UMODE            , *           , src\print\oemdll\oemuni\umode                     , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\WATERMARK               , *           , src\print\oemdll\watermark                        , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\WATERMARK\COMMON        , *           , src\print\oemdll\watermark\common                 , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\WATERMARK\wmarkps       , *           , src\print\oemdll\watermark\wmarkps                , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\WATERMARK\wmarkps\umode , *           , src\print\oemdll\watermark\wmarkps\umode          , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\watermark\wmarkui       , *           , src\print\oemdll\watermark\wmarkui                , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\custhlp                 , *           , src\print\oemdll\custhlp                          , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\custhlp\customhelp      , *           , src\print\oemdll\custhlp\customhelp               , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\SyncSet                 , *           , src\print\oemdll\SyncSet                          , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\ThemeUI                 , *           , src\print\oemdll\ThemeUI                          , *           , HSPLIT
print\drivers\usermode\ddk\samples\OEMDLL\PSUIRep                 , *           , src\print\oemdll\PSUIRep                          , *           , HSPLIT
print\drivers\usermode\ddk\samples\infs\driver5                   , *           , src\print\infs\driver5                            , *           , HSPLIT
print\drivers\usermode\ddk\samples\infs\mfp                       , *           , src\print\infs\mfp                                , *           , HSPLIT
print\drivers\usermode\ddk\samples\infs\multios     		  , *           , src\print\infs\multios                            , *           , HSPLIT
print\drivers\usermode\ddk\samples\mini                           , readme.htm  , src\print\mini                                    , *           , COPY
print\drivers\usermode\ddk\samples\mini\mdw                       , *           , src\print\mini\mdw                                , *           , HSPLIT

;
; Mini samples
;
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres         ,pcl5ems.MDW   ,src\print\mini\MDW\pcl5eres         , pcl5ems.MDW   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres         ,pcl5eres.htm  ,src\print\mini\MDW\pcl5eres         , pcl5eres.htm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,hp1600c.GPD   ,src\print\mini\MDW\pcl5eres\w2k     , hp1600c.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,hp4simx.GPD   ,src\print\mini\MDW\pcl5eres\w2k     , hp4simx.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,hpclj.GPD     ,src\print\mini\MDW\pcl5eres\w2k     , hpclj.GPD     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,hplj4.GPD     ,src\print\mini\MDW\pcl5eres\w2k     , hplj4.GPD     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,hplj5.GPD     ,src\print\mini\MDW\pcl5eres\w2k     , hplj5.GPD     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,makefile      ,src\print\mini\MDW\pcl5eres\w2k     , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,OEMPRINT.INF  ,src\print\mini\MDW\pcl5eres\w2k     , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,pcl5ems.RC    ,src\print\mini\MDW\pcl5eres\w2k     , pcl5ems.RC    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,pcl5eres.def  ,src\print\mini\MDW\pcl5eres\w2k     , pcl5eres.def  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,sources       ,src\print\mini\MDW\pcl5eres\w2k     , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,stdnames.gpd  ,src\print\mini\MDW\pcl5eres\w2k     , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k     ,ttfsub.gpd    ,src\print\mini\MDW\pcl5eres\w2k     , ttfsub.gpd    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ALBERTR.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , ALBERTR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ALBERTX.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , ALBERTX.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ALBRVILR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , ALBRVILR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ALBRVILX.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , ALBRVILX.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,AOAKLANB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , AOAKLANB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,AOAKLANI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , AOAKLANI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,AOAKLANR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , AOAKLANR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,AOLIVEB.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , AOLIVEB.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,AOLIVECB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , AOLIVECB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,AOLIVEI.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , AOLIVEI.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,AOLIVER.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , AOLIVER.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ARIALB.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , ARIALB.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ARIALI.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , ARIALI.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ARIALJ.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , ARIALJ.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,ARIALR.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , ARIALR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BENGUATB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BENGUATB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BENGUATI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BENGUATI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BENGUATJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BENGUATJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BENGUATR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BENGUATR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BODONIB.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , BODONIB.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BODONII.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , BODONII.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BODONIJ.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , BODONIJ.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BODONIR.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , BODONIR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BOOKMANB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BOOKMANB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BOOKMANI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BOOKMANI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BOOKMANJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BOOKMANJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BOOKMANR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BOOKMANR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR01TB.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR01TB.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR01TI.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR01TI.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR01TJ.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR01TJ.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR01TR.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR01TR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR05BB.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR05BB.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR05BI.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR05BI.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR05BJ.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR05BJ.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR05BR.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR05BR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR10I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR10I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR10X.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR10X.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR11UB.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR11UB.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR11UI.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR11UI.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR11UJ.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR11UJ.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR11UR.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR11UR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR12I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR12I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BR12X.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , BR12X.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROGHAMB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROGHAMB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROGHAMI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROGHAMI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROGHAMJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROGHAMJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROGHAMR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROGHAMR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROLG16B.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROLG16B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROLG16I.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROLG16I.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROLG16R.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROLG16R.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BROLG16X.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BROLG16X.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BRSYMBOL.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BRSYMBOL.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BRUSSELB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BRUSSELB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BRUSSELI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BRUSSELI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BRUSSELJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BRUSSELJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,BRUSSELR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , BRUSSELR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CENTURYB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CENTURYB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CENTURYI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CENTURYI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CENTURYJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CENTURYJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CENTURYR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CENTURYR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG06R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG06R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG08B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG08B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG08I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG08I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG08R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG08R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12Bb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12Bb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG11B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG11B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG11I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG11I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG11R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG11R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG12I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG12I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG14B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG14B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG14I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG14I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG14R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG14R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG18B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG18B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG24B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG24B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGOMEGAB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGOMEGAB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGOMEGAI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGOMEGAI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGOMEGAJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGOMEGAJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGOMEGAR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGOMEGAR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGTIMESB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGTIMESB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGTIMESI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGTIMESI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGTIMESJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGTIMESJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CGTIMESR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CGTIMESR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CLARCD.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CLARCD.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CLEVECD.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , CLEVECD.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12Ib.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12Ib.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12Rc.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12Rc.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG16Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG16Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CONNETIC.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CONNETIC.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,COOPERBK.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , COOPERBK.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CORONETR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , CORONETR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,COURIERB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , COURIERB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,COURIERI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , COURIERI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,COURIERJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , COURIERJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,COURIERR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , COURIERR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CS08R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CS08R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CS10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CS10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CS10I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CS10I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CS10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CS10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CT10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CT10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CT14B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , CT14B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,DINGBAT1.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , DINGBAT1.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,DINGBAT2.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , DINGBAT2.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,DINGBAT3.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , DINGBAT3.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,DINGBATS.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , DINGBATS.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,DINGBATV.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , DINGBATV.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GARMONDB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , GARMONDB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GARMONDI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , GARMONDI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GARMONDJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , GARMONDJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GARMONDR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , GARMONDR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GUATEMB.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , GUATEMB.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GUATEMI.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , GUATEMI.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GUATEMJ.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , GUATEMJ.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,GUATEMR.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , GUATEMR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HC24R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HC24R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HELSNKIB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , HELSNKIB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HELSNKII.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , HELSNKII.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HELSNKIJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , HELSNKIJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HELSNKIR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , HELSNKIR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HO24B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HO24B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV08R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV08R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV10I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV10I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV12I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV12I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV14B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV14B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG27Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG27Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LD121UMU.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , LD121UMU.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LETGOTHB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , LETGOTHB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LETGOTHI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , LETGOTHI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LETGOTHR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , LETGOTHR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG27Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG27Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP10Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP10Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP12Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP12Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP16Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP16Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG16R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG16R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG18R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG18R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG27R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG27R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP16Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP16Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP04R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP04R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP08R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP08R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LP16R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , LP16R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,MARGOLDR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , MARGOLDR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,MARYLNDR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , MARYLNDR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,OA10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , OA10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,OB10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , OB10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,OKLAHOMB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , OKLAHOMB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,OKLAHOMI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , OKLAHOMI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,OKLAHOMJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , OKLAHOMJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,OKLAHOMR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , OKLAHOMR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PALACIOB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , PALACIOB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PALACIOI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , PALACIOI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PALACIOJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , PALACIOJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PALACIOR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , PALACIOR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PCTENNB.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , PCTENNB.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PCTENNI.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , PCTENNI.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PCTENNJ.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , PCTENNJ.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PCTENNR.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , PCTENNR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE16R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE16R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR05B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR05B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR06B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR06B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR08B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR08B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,REVUER.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , REVUER.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SE24B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , SE24B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SHANNONB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SHANNONB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SHANNONI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SHANNONI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SHANNONR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SHANNONR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SHANNONX.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SHANNONX.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SOUVNIRB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SOUVNIRB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SOUVNIRI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SOUVNIRI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SOUVNIRJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SOUVNIRJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SOUVNIRR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , SOUVNIRR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,STYMIEB.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , STYMIEB.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,STYMIEI.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , STYMIEI.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,STYMIEJ.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , STYMIEJ.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,STYMIER.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , STYMIER.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SYMBOL.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , SYMBOL.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TENNB.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TENNB.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TENNI.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TENNI.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TENNJ.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TENNJ.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TENNR.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TENNR.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TIMESNRB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , TIMESNRB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TIMESNRI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , TIMESNRI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TIMESNRJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , TIMESNRJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TIMESNRR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , TIMESNRR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR08R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR08R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12I.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12I.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR14B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR14B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN06R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN06R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN08B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN08B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN08R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN08R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN10B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN10B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN12B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN12B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN14B.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN14B.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN14R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN14R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN18R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN18R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UN24R.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UN24R.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERCB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERCB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERCI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERCI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERCJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERCJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERCR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERCR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERSB.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERSB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERSI.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERSI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERSJ.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERSJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UNIVERSR.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , UNIVERSR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHB.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHB.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHCDB.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHCDB.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHCDI.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHCDI.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHCDJ.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHCDJ.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHCDR.UFM   ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHCDR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHI.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHI.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHJ.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHJ.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,UTAHR.UFM     ,src\print\mini\MDW\pcl5eres\w2k\ufm , UTAHR.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,WDINGBAT.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , WDINGBAT.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,WINGDING.UFM  ,src\print\mini\MDW\pcl5eres\w2k\ufm , WINGDING.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG08Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG08Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG08Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG08Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10Rc.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10Rc.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CG10Rd.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CG10Rd.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10Bb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10Bb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10Ib.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10Ib.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO10Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO10Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12Bb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12Bb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12Ib.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12Ib.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,CO12Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , CO12Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HO24Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HO24Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV08Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV08Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV10Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV10Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV10Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV10Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV10Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV10Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV12Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV12Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV12Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV12Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV12Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV12Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV14Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV14Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,HV14Bb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , HV14Bb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG10Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG10Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,LG10Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , LG10Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Bb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Bb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Bc.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Bc.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Ib.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Ib.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Ic.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Ic.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Rc.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Rc.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Rd.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Rd.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Re.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Re.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE12Rf.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE12Rf.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE16Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE16Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE16Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE16Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE16Rc.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE16Rc.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PE16Rd.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PE16Rd.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR05Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR05Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR06Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR06Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR08Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR08Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,PR10Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , PR10Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,SE24Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , SE24Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR08Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR08Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR08Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR08Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10Bb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10Bb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10Ib.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10Ib.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR10Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR10Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12Ba.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12Ba.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12Bb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12Bb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12Ia.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12Ia.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12Ib.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12Ib.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12Ra.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12Ra.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\ufm ,TR12Rb.UFM    ,src\print\mini\MDW\pcl5eres\w2k\ufm , TR12Rb.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,DINGBAT1.GTT  ,src\print\mini\MDW\pcl5eres\w2k\gtt , DINGBAT1.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,DINGBAT2.GTT  ,src\print\mini\MDW\pcl5eres\w2k\gtt , DINGBAT2.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,ECMA94.GTT    ,src\print\mini\MDW\pcl5eres\w2k\gtt , ECMA94.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,GENERIC7.GTT  ,src\print\mini\MDW\pcl5eres\w2k\gtt , GENERIC7.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,MATH8.GTT     ,src\print\mini\MDW\pcl5eres\w2k\gtt , MATH8.GTT     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,ROMAN8.GTT    ,src\print\mini\MDW\pcl5eres\w2k\gtt , ROMAN8.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,USASCII.GTT   ,src\print\mini\MDW\pcl5eres\w2k\gtt , USASCII.GTT   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,WIN31.GTT     ,src\print\mini\MDW\pcl5eres\w2k\gtt , WIN31.GTT     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,WIN31A.GTT    ,src\print\mini\MDW\pcl5eres\w2k\gtt , WIN31A.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,WP.GTT        ,src\print\mini\MDW\pcl5eres\w2k\gtt , WP.GTT        ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcl5eres\w2k\gtt ,Z1A.GTT       ,src\print\mini\MDW\pcl5eres\w2k\gtt , Z1A.GTT       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl             ,makefile     ,src\print\mini\MDW\pclxl            , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl             ,pclxl.def    ,src\print\mini\MDW\pclxl            , pclxl.def     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl             ,pclxl.rc     ,src\print\mini\MDW\pclxl            , pclxl.rc      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl             ,sources      ,src\print\mini\MDW\pclxl            , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,DINGBAT1.GTT ,src\print\mini\MDW\pclxl\gtt        , DINGBAT1.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,DINGBAT2.GTT ,src\print\mini\MDW\pclxl\gtt        , DINGBAT2.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,ECMA94.GTT   ,src\print\mini\MDW\pclxl\gtt        , ECMA94.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,GENERIC7.GTT ,src\print\mini\MDW\pclxl\gtt        , GENERIC7.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,MATH8.GTT    ,src\print\mini\MDW\pclxl\gtt        , MATH8.GTT     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,ROMAN8.GTT   ,src\print\mini\MDW\pclxl\gtt        , ROMAN8.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,USASCII.GTT  ,src\print\mini\MDW\pclxl\gtt        , USASCII.GTT   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,WIN31.GTT    ,src\print\mini\MDW\pclxl\gtt        , WIN31.GTT     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,WIN31A.GTT   ,src\print\mini\MDW\pclxl\gtt        , WIN31A.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,WP.GTT       ,src\print\mini\MDW\pclxl\gtt        , WP.GTT        ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\gtt         ,Z1A.GTT      ,src\print\mini\MDW\pclxl\gtt        , Z1A.GTT       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,ALBERTR.UFM  ,src\print\mini\MDW\pclxl\ufm        , ALBERTR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,ALBERTX.UFM  ,src\print\mini\MDW\pclxl\ufm        , ALBERTX.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,AOLIVEB.UFM  ,src\print\mini\MDW\pclxl\ufm        , AOLIVEB.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,AOLIVEI.UFM  ,src\print\mini\MDW\pclxl\ufm        , AOLIVEI.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,AOLIVER.UFM  ,src\print\mini\MDW\pclxl\ufm        , AOLIVER.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,ARIALB.UFM   ,src\print\mini\MDW\pclxl\ufm        , ARIALB.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,ARIALI.UFM   ,src\print\mini\MDW\pclxl\ufm        , ARIALI.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,ARIALJ.UFM   ,src\print\mini\MDW\pclxl\ufm        , ARIALJ.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,ARIALR.UFM   ,src\print\mini\MDW\pclxl\ufm        , ARIALR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BENGUATB.UFM ,src\print\mini\MDW\pclxl\ufm        , BENGUATB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BENGUATI.UFM ,src\print\mini\MDW\pclxl\ufm        , BENGUATI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BENGUATJ.UFM ,src\print\mini\MDW\pclxl\ufm        , BENGUATJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BENGUATR.UFM ,src\print\mini\MDW\pclxl\ufm        , BENGUATR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BOOKMANB.UFM ,src\print\mini\MDW\pclxl\ufm        , BOOKMANB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BOOKMANI.UFM ,src\print\mini\MDW\pclxl\ufm        , BOOKMANI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BOOKMANJ.UFM ,src\print\mini\MDW\pclxl\ufm        , BOOKMANJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BOOKMANR.UFM ,src\print\mini\MDW\pclxl\ufm        , BOOKMANR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BROGHAMB.UFM ,src\print\mini\MDW\pclxl\ufm        , BROGHAMB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BROGHAMI.UFM ,src\print\mini\MDW\pclxl\ufm        , BROGHAMI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BROGHAMJ.UFM ,src\print\mini\MDW\pclxl\ufm        , BROGHAMJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,BROGHAMR.UFM ,src\print\mini\MDW\pclxl\ufm        , BROGHAMR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGOMEGAB.UFM ,src\print\mini\MDW\pclxl\ufm        , CGOMEGAB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGOMEGAI.UFM ,src\print\mini\MDW\pclxl\ufm        , CGOMEGAI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGOMEGAJ.UFM ,src\print\mini\MDW\pclxl\ufm        , CGOMEGAJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGOMEGAR.UFM ,src\print\mini\MDW\pclxl\ufm        , CGOMEGAR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGTIMESB.UFM ,src\print\mini\MDW\pclxl\ufm        , CGTIMESB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGTIMESI.UFM ,src\print\mini\MDW\pclxl\ufm        , CGTIMESI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGTIMESJ.UFM ,src\print\mini\MDW\pclxl\ufm        , CGTIMESJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CGTIMESR.UFM ,src\print\mini\MDW\pclxl\ufm        , CGTIMESR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CLARCD.UFM   ,src\print\mini\MDW\pclxl\ufm        , CLARCD.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,CORONETR.UFM, src\print\mini\MDW\pclxl\ufm        , CORONETR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,COURIERB.UFM, src\print\mini\MDW\pclxl\ufm        , COURIERB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,COURIERI.UFM, src\print\mini\MDW\pclxl\ufm        , COURIERI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,COURIERJ.UFM, src\print\mini\MDW\pclxl\ufm        , COURIERJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,COURIERR.UFM, src\print\mini\MDW\pclxl\ufm        , COURIERR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,GARMONDB.UFM, src\print\mini\MDW\pclxl\ufm        , GARMONDB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,GARMONDI.UFM, src\print\mini\MDW\pclxl\ufm        , GARMONDI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,GARMONDJ.UFM, src\print\mini\MDW\pclxl\ufm        , GARMONDJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,GARMONDR.UFM, src\print\mini\MDW\pclxl\ufm        , GARMONDR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,LETGOTHB.UFM, src\print\mini\MDW\pclxl\ufm        , LETGOTHB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,LETGOTHI.UFM, src\print\mini\MDW\pclxl\ufm        , LETGOTHI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,LETGOTHR.UFM, src\print\mini\MDW\pclxl\ufm        , LETGOTHR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,MARGOLDR.UFM, src\print\mini\MDW\pclxl\ufm        , MARGOLDR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,SYMBOL.UFM  , src\print\mini\MDW\pclxl\ufm        , SYMBOL.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,TIMESNRB.UFM, src\print\mini\MDW\pclxl\ufm        , TIMESNRB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,TIMESNRI.UFM, src\print\mini\MDW\pclxl\ufm        , TIMESNRI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,TIMESNRJ.UFM, src\print\mini\MDW\pclxl\ufm        , TIMESNRJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,TIMESNRR.UFM, src\print\mini\MDW\pclxl\ufm        , TIMESNRR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERCB.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERCB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERCI.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERCI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERCJ.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERCJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERCR.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERCR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSA.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSA.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSB.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSC.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSC.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSD.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSD.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSE.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSE.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSI.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSI.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSJ.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSJ.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,UNIVERSR.UFM, src\print\mini\MDW\pclxl\ufm        , UNIVERSR.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,WDINGBAT.UFM, src\print\mini\MDW\pclxl\ufm        , WDINGBAT.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pclxl\ufm         ,WINGDING.UFM, src\print\mini\MDW\pclxl\ufm        , WINGDING.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres          ,hpdjres.htm   ,src\print\mini\MDW\hpdjres          , hpdjres.htm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres          ,hpdjres.MDW   ,src\print\mini\MDW\hpdjres          , hpdjres.MDW   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,hpdj400.GPD   ,src\print\mini\MDW\hpdjres\w2k      , hpdj400.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,hpdj400m.GPD  ,src\print\mini\MDW\hpdjres\w2k      , hpdj400m.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,HPDJ600.GPD   ,src\print\mini\MDW\hpdjres\w2k      , HPDJ600.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,HPDJ600M.GPD  ,src\print\mini\MDW\hpdjres\w2k      , HPDJ600M.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,hpdjres.def   ,src\print\mini\MDW\hpdjres\w2k      , hpdjres.def   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,hpdskjet.RC   ,src\print\mini\MDW\hpdjres\w2k      , hpdskjet.RC   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,hpoffjet.GPD  ,src\print\mini\MDW\hpdjres\w2k      , hpoffjet.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,makefile      ,src\print\mini\MDW\hpdjres\w2k      , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,OEMPRINT.INF  ,src\print\mini\MDW\hpdjres\w2k      , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,sources       ,src\print\mini\MDW\hpdjres\w2k      , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k      ,stdnames.gpd  ,src\print\mini\MDW\hpdjres\w2k      , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA10.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA10.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA10I.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA10I.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA12.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA12.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA12I.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA12I.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA14.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA14.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA14I.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA14I.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA5.ufm     ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA5.ufm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA5I.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA5I.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA6.ufm     ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA6.ufm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA6I.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA6I.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA7.ufm     ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA7.ufm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA7I.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA7I.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA8.ufm     ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA8.ufm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BFTEA8I.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , BFTEA8I.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BR120RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , BR120RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BR180RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , BR180RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,BR240RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , BR240RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTM128.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTM128.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTM128I.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTM128I.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTM32.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTM32.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTM32I.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTM32I.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTM80.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTM80.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTM80I.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTM80I.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms10.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms10i.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms10i.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTMS12.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTMS12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms14.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms14.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms14i.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms14i.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms5.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms5.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms5i.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms5i.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTMS6.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTMS6.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTMS6I.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTMS6I.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms8.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms8.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,cgtms8i.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , cgtms8i.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CO120IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , CO120IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COUR10.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , COUR10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCH12.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCH12.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCH1B.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCH1B.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCH6.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCH6.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCH6B.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCH6B.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCM12.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCM12.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCM1B.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCM1B.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCM6.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCM6.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCM6B.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCM6B.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCV12.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCV12.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCV1B.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCV1B.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCV6.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCV6.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COURCV6B.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , COURCV6B.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CS080RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , CS080RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CS100BMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , CS100BMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CS100IMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , CS100IMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CS100RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , CS100RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,DC120RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , DC120RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,DC140RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , DC140RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,DC180RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , DC180RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,DC240RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , DC240RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA080RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA080RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA100IMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA100IMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA100RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA100RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA120BMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA120BMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA120IMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA120IMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA120RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA120RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA140BMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA140BMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA50IMP.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA50IMP.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA50RMP.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA50RMP.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA60BMP.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA60BMP.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA60IMP.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA60IMP.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA60RMP.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA60RMP.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,GA70BMP.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , GA70BMP.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV080IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV080IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV080IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV080IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV080RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV080RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV080RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV080RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV080RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV080RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV100IMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV100IMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV100IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV100IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV100IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV100IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV100RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV100RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV100RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV100RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV100RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV100RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV120IMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV120IMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV120IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV120IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV120IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV120IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV120RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV120RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV120RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV120RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV120RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV120RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV140IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV140IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV140IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV140IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV140RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV140RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV140RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV140RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV140RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV140RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,HV300RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , HV300RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,LG095RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , LG095RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,LG100RPP.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , LG100RPP.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,LG120IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , LG120IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,LG120RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , LG120RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,LG140RPN.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , LG140RPN.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PE070RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PE070RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PE100IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PE100IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PE100RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PE100RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR03_18B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR03_18B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR04_08B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR04_08B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR04_16B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR04_16B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR06_09B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR06_09B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR08_08B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR08_08B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR13_09B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR13_09B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR13_18B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR13_18B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR140RPB.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR140RPB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR160RPB.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR160RPB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR16_08B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR16_08B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR16_16B.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR16_16B.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR180RPB.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR180RPB.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,tcourc12.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , tcourc12.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,tcourc6.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , tcourc6.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TM100RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TM100RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TM140RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TM140RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TN120IVP.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TN120IVP.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TN120RVP.ufm   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TN120RVP.ufm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR080IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR080IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR080IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR080IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR080RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR080RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR080RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR080RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR080RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR080RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR100IMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR100IMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR100IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR100IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR100IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR100IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR100RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR100RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR100RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR100RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR100RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR100RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR120IMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR120IMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR120IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR120IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR120IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR120IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR120RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR120RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR120RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR120RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR120RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR120RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR140IPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR140IPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR140IVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR140IVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR140RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR140RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR140RPP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR140RPP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR140RVP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR140RVP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,TR300RMP.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , TR300RMP.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIV128.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIV128.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIV128I.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIV128I.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIV32.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIV32.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIV32I.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIV32I.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIV80.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIV80.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIV80I.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIV80I.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr10.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr10i.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr10i.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr12.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr12i.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr12i.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr14.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr14.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr5.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr5.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr5i.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr5i.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIVR6.ufm     ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIVR6.ufm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIVR6I.ufm    ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIVR6I.ufm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,UNIVR7.ufm     ,src\print\mini\MDW\hpdjres\w2k\ufm  , UNIVR7.ufm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,univr8.UFM     ,src\print\mini\MDW\hpdjres\w2k\ufm  , univr8.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,CGTMS12i.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , CGTMS12i.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,COUR10i.UFM    ,src\print\mini\MDW\hpdjres\w2k\ufm  , COUR10i.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\ufm ,PR16_16a.UFM   ,src\print\mini\MDW\hpdjres\w2k\ufm  , PR16_16a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\gtt ,ECMA94.GTT     ,src\print\mini\MDW\hpdjres\w2k\gtt  , ECMA94.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\gtt ,GENERIC7.GTT   ,src\print\mini\MDW\hpdjres\w2k\gtt  , GENERIC7.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\gtt ,MATH8.GTT      ,src\print\mini\MDW\hpdjres\w2k\gtt  , MATH8.GTT     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\gtt ,ROMAN8.GTT     ,src\print\mini\MDW\hpdjres\w2k\gtt  , ROMAN8.GTT    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\hpdjres\w2k\gtt ,USASCII.GTT    ,src\print\mini\MDW\hpdjres\w2k\gtt  , USASCII.GTT   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res        ,escp2ms.MDW    ,src\print\mini\MDW\escp2res         , escp2ms.MDW   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res        ,escp2res.htm   ,src\print\mini\MDW\escp2res         , escp2res.htm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,epdq3000.GPD   ,src\print\mini\MDW\escp2res\w2k     , epdq3000.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,epdq3xxx.gpd   ,src\print\mini\MDW\escp2res\w2k     , epdq3xxx.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,eplq1170.GPD   ,src\print\mini\MDW\escp2res\w2k     , eplq1170.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,eplq2170.GPD   ,src\print\mini\MDW\escp2res\w2k     , eplq2170.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,eplq300.GPD    ,src\print\mini\MDW\escp2res\w2k     , eplq300.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,eplq670.gpd    ,src\print\mini\MDW\escp2res\w2k     , eplq670.gpd   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,escp2ms.RC     ,src\print\mini\MDW\escp2res\w2k     , escp2ms.RC    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,makefile       ,src\print\mini\MDW\escp2res\w2k     , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,OEMPRINT.INF   ,src\print\mini\MDW\escp2res\w2k     , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,sources        ,src\print\mini\MDW\escp2res\w2k     , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,stdnames.gpd   ,src\print\mini\MDW\escp2res\w2k     , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp2res\w2k    ,escp2eres.def  ,src\print\mini\MDW\escp2res\w2k     , escp2eres.def ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res          ,ep9res.htm     ,src\print\mini\MDW\ep9res           , ep9res.htm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res          ,epson9.MDW     ,src\print\mini\MDW\ep9res           , epson9.MDW    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,ep9res.def     ,src\print\mini\MDW\ep9res\w2k       , ep9res.def    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,epcomp9.GPD    ,src\print\mini\MDW\ep9res\w2k       , epcomp9.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,epd8000.GPD    ,src\print\mini\MDW\ep9res\w2k       , epd8000.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,epfx2170.GPD   ,src\print\mini\MDW\ep9res\w2k       , epfx2170.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,eplx300.GPD    ,src\print\mini\MDW\ep9res\w2k       , eplx300.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,epson9.RC      ,src\print\mini\MDW\ep9res\w2k       , epson9.RC     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,epx1050p.GPD   ,src\print\mini\MDW\ep9res\w2k       , epx1050p.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,makefile       ,src\print\mini\MDW\ep9res\w2k       , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,OEMPRINT.INF   ,src\print\mini\MDW\ep9res\w2k       , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,sources        ,src\print\mini\MDW\ep9res\w2k       , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k      ,stdnames.gpd   ,src\print\mini\MDW\ep9res\w2k       , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT05.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT05.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT06.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT06.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT10.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT12.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT15.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT15.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT17.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT17.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT17L.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT17L.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT20.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT20.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,DRAFT20L.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , DRAFT20L.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPS.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPS7.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPS7.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPSa.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPSa.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPSDH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPSDH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPX.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPX.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPX7.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPX7.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPX7a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPX7a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN05.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN057.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN057.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPXa.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPXa.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN05DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN05DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN06.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN067.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN067.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS10a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS10a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN06DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN06DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN10.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN107.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN107.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS12a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS12a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN10DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN10DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN12.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN127.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN127.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS17a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS17a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN12DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN12DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN15.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN17.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN177.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN177.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS20a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS20a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN20.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN207.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN207.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPS.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPS7.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPS7.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPSDH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPSDH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPX.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPX.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPX7.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPX7.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANIPS.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANIPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANIPSDH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , SANIPSDH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANIPX.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANIPX.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS05.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS05DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS05DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS06.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS06DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS06DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS10.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS10DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS10DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS12.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS12DH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS12DH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS15.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS17.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANS20.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANS20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANSPS.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANSPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANSPSDH.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , SANSPSDH.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,SANSPX.UFM     ,src\print\mini\MDW\ep9res\w2k\ufm   , SANSPX.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPS7a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPS7a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPSa.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPSa.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPX7a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPX7a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMIPXa.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMIPXa.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN057a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN057a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN057b.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN057b.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN05a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN05a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN067a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN067a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN067b.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN067b.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN06a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN06a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN107a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN107a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN107b.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN107b.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN10a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN10a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN127a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN127a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN127b.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN127b.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN12a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN12a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN177a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN177a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN177b.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN177b.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN17a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN17a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMN20a.UFM    ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMN20a.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\ufm  ,ROMNPS7a.UFM   ,src\print\mini\MDW\ep9res\w2k\ufm   , ROMNPS7a.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\gtt  ,epn_intl.GTT   ,src\print\mini\MDW\ep9res\w2k\gtt   , epn_intl.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\gtt  ,EPSONXTA.GTT   ,src\print\mini\MDW\ep9res\w2k\gtt   , EPSONXTA.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep9res\w2k\gtt  ,no_intl.GTT    ,src\print\mini\MDW\ep9res\w2k\gtt   , no_intl.GTT   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res         ,ep24res.htm    ,src\print\mini\MDW\ep24res          , ep24res.htm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res         ,epson24.MDW    ,src\print\mini\MDW\ep24res          , epson24.MDW   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,ep1060p.GPD    ,src\print\mini\MDW\ep24res\w2k      , ep1060p.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,ep106x.gpd     ,src\print\mini\MDW\ep24res\w2k      , ep106x.gpd    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,ep2000.GPD     ,src\print\mini\MDW\ep24res\w2k      , ep2000.GPD    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,ep9res.def     ,src\print\mini\MDW\ep24res\w2k      , ep9res.def    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,epcomp24.GPD   ,src\print\mini\MDW\ep24res\w2k      , epcomp24.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,epl1050p.GPD   ,src\print\mini\MDW\ep24res\w2k      , epl1050p.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,epl105x.gpd    ,src\print\mini\MDW\ep24res\w2k      , epl105x.gpd   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,eplq560.GPD    ,src\print\mini\MDW\ep24res\w2k      , eplq560.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,EPSON24.RC     ,src\print\mini\MDW\ep24res\w2k      , EPSON24.RC    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,OEMPRINT.INF   ,src\print\mini\MDW\ep24res\w2k      , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,makefile       ,src\print\mini\MDW\ep24res\w2k      , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,sources        ,src\print\mini\MDW\ep24res\w2k      , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k     ,stdnames.gpd   ,src\print\mini\MDW\ep24res\w2k      , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,COUR05.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , COUR05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,COUR06.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , COUR06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,COUR10.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , COUR10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,COUR12.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , COUR12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,COUR15.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , COUR15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,COUR17.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , COUR17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,COUR20.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , COUR20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,OCRA.UFM       ,src\print\mini\MDW\ep24res\w2k\ufm  , OCRA.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,OCRB.UFM       ,src\print\mini\MDW\ep24res\w2k\ufm  , OCRB.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ORATOR.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , ORATOR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ORATORS.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ORATORS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,PREST05.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , PREST05.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,PREST06.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , PREST06.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,PREST10.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , PREST10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,PREST12.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , PREST12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,PREST15.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , PREST15.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,PREST17.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , PREST17.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,PREST20.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , PREST20.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMAN05.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMAN05.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMAN06.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMAN06.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMAN10.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMAN10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMAN12.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMAN12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMAN15.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMAN15.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMAN17.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMAN17.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMAN20.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMAN20.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,ROMANPS.UFM    ,src\print\mini\MDW\ep24res\w2k\ufm  , ROMANPS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANS05.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANS05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANS06.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANS06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANS10.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANS10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANS12.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANS12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANS15.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANS15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANS17.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANS17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANS20.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANS20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SANSPS.UFM     ,src\print\mini\MDW\ep24res\w2k\ufm  , SANSPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SCRIPT05.UFM   ,src\print\mini\MDW\ep24res\w2k\ufm  , SCRIPT05.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SCRIPT06.UFM   ,src\print\mini\MDW\ep24res\w2k\ufm  , SCRIPT06.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SCRIPT10.UFM   ,src\print\mini\MDW\ep24res\w2k\ufm  , SCRIPT10.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SCRIPT12.UFM   ,src\print\mini\MDW\ep24res\w2k\ufm  , SCRIPT12.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SCRIPT15.UFM   ,src\print\mini\MDW\ep24res\w2k\ufm  , SCRIPT15.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SCRIPT17.UFM   ,src\print\mini\MDW\ep24res\w2k\ufm  , SCRIPT17.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\ufm ,SCRIPT20.UFM   ,src\print\mini\MDW\ep24res\w2k\ufm  , SCRIPT20.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\gtt ,EPSONXTA.GTT   ,src\print\mini\MDW\ep24res\w2k\gtt  , EPSONXTA.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ep24res\w2k\gtt ,EPSONXTB.GTT   ,src\print\mini\MDW\ep24res\w2k\gtt  , EPSONXTB.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres        ,ecp2eres.htm   ,src\print\mini\MDW\ecp2eres         , ecp2eres.htm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres        ,escp2e.MDW     ,src\print\mini\MDW\ecp2eres         , escp2e.MDW    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,ecp2eres.def   ,src\print\mini\MDW\ecp2eres\w2k     , ecp2eres.def  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,ep100sf.GPD    ,src\print\mini\MDW\ecp2eres\w2k     , ep100sf.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,ep1070sf.GPD   ,src\print\mini\MDW\ecp2eres\w2k     , ep1070sf.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,ep1170sf.GPD   ,src\print\mini\MDW\ecp2eres\w2k     , ep1170sf.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,ep570sf.GPD    ,src\print\mini\MDW\ecp2eres\w2k     , ep570sf.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,eps1170s.GPD   ,src\print\mini\MDW\ecp2eres\w2k     , eps1170s.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,escp2e.RC      ,src\print\mini\MDW\ecp2eres\w2k     , escp2e.RC     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,makefile       ,src\print\mini\MDW\ecp2eres\w2k     , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,OEMPRINT.INF   ,src\print\mini\MDW\ecp2eres\w2k     , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,sources        ,src\print\mini\MDW\ecp2eres\w2k     , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k    ,stdnames.gpd   ,src\print\mini\MDW\ecp2eres\w2k     , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,COUR05.UFM    ,src\print\mini\MDW\ecp2eres\w2k\ufm , COUR05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,COUR06.UFM    ,src\print\mini\MDW\ecp2eres\w2k\ufm , COUR06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,COUR10.UFM    ,src\print\mini\MDW\ecp2eres\w2k\ufm , COUR10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,COUR12.UFM    ,src\print\mini\MDW\ecp2eres\w2k\ufm , COUR12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,COUR15.UFM    ,src\print\mini\MDW\ecp2eres\w2k\ufm , COUR15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,COUR17.UFM    ,src\print\mini\MDW\ecp2eres\w2k\ufm , COUR17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,COUR20.UFM    ,src\print\mini\MDW\ecp2eres\w2k\ufm , COUR20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro08ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro08ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro10ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro10ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro12ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro12ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro14ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro14ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro16ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro16ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro18ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro18ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro20ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro20ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro22ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro22ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro24ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro24ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro26ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro26ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro28ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro28ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro30ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro30ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpro32ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpro32ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss08ps.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm , mpss08ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss10ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss10ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss12ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss12ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss14ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss14ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss16ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss16ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss18ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss18ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss20ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss20ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss22ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss22ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss24ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss24ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss26ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss26ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss28ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss28ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss30ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss30ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,mpss32ps.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , mpss32ps.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,OCRB10.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , OCRB10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ORAS10.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ORAS10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ORAT10.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ORAT10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,PREST05.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm  , PREST05.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,PREST06.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm  , PREST06.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,PREST10.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm  , PREST10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,PREST12.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm  , PREST12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,PREST17.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm  , PREST17.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,PREST20.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm  , PREST20.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMANPS.UFM  ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMANPS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMN05.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMN05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMN06.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMN06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMN10.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMN10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMN12.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMN12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMN15.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMN15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMN17.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMN17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,ROMN20.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , ROMN20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANS05.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANS05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANS06.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANS06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANS10.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANS10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANS12.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANS12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANS15.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANS15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANS17.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANS17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANS20.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANS20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SANSPS.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SANSPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SCRC10PS.UFM ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SCRC10PS.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SCRI05.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SCRI05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SCRI06.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SCRI06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SCRI10.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SCRI10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SCRI12.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SCRI12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SCRI17.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SCRI17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\ufm ,SCRI20.UFM   ,src\print\mini\MDW\ecp2eres\w2k\ufm  , SCRI20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\ecp2eres\w2k\gtt ,CP850EX.GTT  ,src\print\mini\MDW\ecp2eres\w2k\gtt  , CP850EX.GTT   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v         ,canon10v.MDW ,src\print\mini\MDW\canon10v          , canon10v.MDW  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v         ,canon10v.htm ,src\print\mini\MDW\canon10v          , canon10v.htm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,canon10v.def ,src\print\mini\MDW\canon10v\w2k      , canon10v.def  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,CANON10V.RC  ,src\print\mini\MDW\canon10v\w2k      , CANON10V.RC   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,CN10VCJ.GPD  ,src\print\mini\MDW\canon10v\w2k      , CN10VCJ.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,CN10VJ.GPD   ,src\print\mini\MDW\canon10v\w2k      , CN10VJ.GPD    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,CN10VLJ.GPD  ,src\print\mini\MDW\canon10v\w2k      , CN10VLJ.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,CN10VSJ.GPD  ,src\print\mini\MDW\canon10v\w2k      , CN10VSJ.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,CN15VJ.GPD   ,src\print\mini\MDW\canon10v\w2k      , CN15VJ.GPD    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,CN15VPJ.GPD  ,src\print\mini\MDW\canon10v\w2k      , CN15VPJ.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,makefile     ,src\print\mini\MDW\canon10v\w2k      , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,OEMPRINT.INF ,src\print\mini\MDW\canon10v\w2k      , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,sources      ,src\print\mini\MDW\canon10v\w2k      , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k     ,stdnames.gpd ,src\print\mini\MDW\canon10v\w2k      , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,COUR05.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , COUR05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,COUR06.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , COUR06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,COUR10.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , COUR10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,COUR12.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , COUR12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,COUR15.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , COUR15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,COURPS.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , COURPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,goth05.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , goth05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,goth06.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , goth06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,goth10.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , goth10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,goth12.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , goth12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,goth15.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , goth15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,GOTHIC.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , GOTHIC.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,GOTHIC2.UFM  ,src\print\mini\MDW\canon10v\w2k\ufm  , GOTHIC2.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,gothps.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , gothps.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,gyosho.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , gyosho.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,gyosho2.UFM  ,src\print\mini\MDW\canon10v\w2k\ufm  , gyosho2.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,kaisho.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , kaisho.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,kaisho2.UFM  ,src\print\mini\MDW\canon10v\w2k\ufm  , kaisho2.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,MINCHO.UFM   ,src\print\mini\MDW\canon10v\w2k\ufm  , MINCHO.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,MINCHO2.UFM  ,src\print\mini\MDW\canon10v\w2k\ufm  , MINCHO2.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,MOHITSU.UFM  ,src\print\mini\MDW\canon10v\w2k\ufm  , MOHITSU.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\canon10v\w2k\ufm ,MOHITSU2.UFM ,src\print\mini\MDW\canon10v\w2k\ufm  , MOHITSU2.UFM  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc         ,escp24sc.MDW ,src\print\mini\MDW\escp24sc          , escp24sc.MDW  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc         ,escp24sc.htm ,src\print\mini\MDW\escp24sc          , escp24sc.htm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k     ,EPLQ16KC.GPD ,src\print\mini\MDW\escp24sc\w2k      , EPLQ16KC.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k     ,escp24sc.def ,src\print\mini\MDW\escp24sc\w2k      , escp24sc.def  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k     ,ESCP24SC.RC  ,src\print\mini\MDW\escp24sc\w2k      , ESCP24SC.RC   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k     ,makefile     ,src\print\mini\MDW\escp24sc\w2k      , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k     ,OEMPRINT.INF ,src\print\mini\MDW\escp24sc\w2k      , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k     ,sources      ,src\print\mini\MDW\escp24sc\w2k      , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k     ,stdnames.gpd ,src\print\mini\MDW\escp24sc\w2k      , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,ROMAN05.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , ROMAN05.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,ROMAN06.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , ROMAN06.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,ROMAN10.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , ROMAN10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,ROMAN12.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , ROMAN12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,ROMAN17.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , ROMAN17.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,ROMAN20.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , ROMAN20.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,ROMANPS.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , ROMANPS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,rotate.UFM   ,src\print\mini\MDW\escp24sc\w2k\ufm  , rotate.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,sng1nh.UFM   ,src\print\mini\MDW\escp24sc\w2k\ufm  , sng1nh.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,sng2nh.UFM   ,src\print\mini\MDW\escp24sc\w2k\ufm  , sng2nh.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,sng3d.ufm    ,src\print\mini\MDW\escp24sc\w2k\ufm  , sng3d.ufm     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,sngkong.UFM  ,src\print\mini\MDW\escp24sc\w2k\ufm  , sngkong.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\ufm ,sngyin.ufm   ,src\print\mini\MDW\escp24sc\w2k\ufm  , sngyin.ufm    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24sc\w2k\gtt ,EPSONXTA.GTT ,src\print\mini\MDW\escp24sc\w2k\gtt  , EPSONXTA.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc         ,ESCP24TC.MDW ,src\print\mini\MDW\escp24tc          , ESCP24TC.MDW  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc         ,escp24tc.htm ,src\print\mini\MDW\escp24tc          , escp24tc.htm  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,EPLQ207T.GPD ,src\print\mini\MDW\escp24tc\w2k      , EPLQ207T.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,EPLQ217T.GPD ,src\print\mini\MDW\escp24tc\w2k      , EPLQ217T.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,EPLQ67T.GPD  ,src\print\mini\MDW\escp24tc\w2k      , EPLQ67T.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,escp24tc.def ,src\print\mini\MDW\escp24tc\w2k      , escp24tc.def  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,escp24tc.RC  ,src\print\mini\MDW\escp24tc\w2k      , escp24tc.RC   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,makefile     ,src\print\mini\MDW\escp24tc\w2k      , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,OEMPRINT.INF ,src\print\mini\MDW\escp24tc\w2k      , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,sources      ,src\print\mini\MDW\escp24tc\w2k      , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k     ,stdnames.gpd ,src\print\mini\MDW\escp24tc\w2k      , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEI1NC.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEI1NC.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEI1NH.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEI1NH.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEI1NM.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEI1NM.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEI1NN.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEI1NN.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEI1NR.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEI1NR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEI1NS.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEI1NS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEIV1NC.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEIV1NC.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEIV1NH.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEIV1NH.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEIV1NM.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEIV1NM.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEIV1NN.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEIV1NN.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEIV1NR.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEIV1NR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,HEIV1NS.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , HEIV1NS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAI1NC.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAI1NC.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAI1NH.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAI1NH.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAI1NM.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAI1NM.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAI1NN.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAI1NN.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAI1NR.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAI1NR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAI1NS.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAI1NS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAIV1NC.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAIV1NC.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAIV1NH.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAIV1NH.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAIV1NM.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAIV1NM.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAIV1NN.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAIV1NN.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAIV1NR.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAIV1NR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,KAIV1NS.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , KAIV1NS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LII1NC.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , LII1NC.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LII1NH.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , LII1NH.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LII1NM.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , LII1NM.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LII1NN.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , LII1NN.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LII1NR.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , LII1NR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LII1NS.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , LII1NS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LIIV1NC.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , LIIV1NC.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LIIV1NH.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , LIIV1NH.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LIIV1NM.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , LIIV1NM.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LIIV1NN.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , LIIV1NN.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LIIV1NR.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , LIIV1NR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,LIIV1NS.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , LIIV1NS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,OCRA.UFM     ,src\print\mini\MDW\escp24tc\w2k\ufm  , OCRA.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,OCRB.UFM     ,src\print\mini\MDW\escp24tc\w2k\ufm  , OCRB.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ORATOR.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , ORATOR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ORATORS.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ORATORS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMAN05.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMAN05.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMAN06.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMAN06.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMAN10.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMAN10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMAN12.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMAN12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMAN15.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMAN15.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMAN17.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMAN17.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMAN20.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMAN20.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,ROMANPS.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , ROMANPS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANS05.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANS05.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANS06.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANS06.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANS10.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANS10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANS12.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANS12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANS15.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANS15.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANS17.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANS17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANS20.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANS20.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SANSPS.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SANSPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNG1NC.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNG1NC.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNG1NH.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNG1NH.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNG1NM.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNG1NM.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNG1NN.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNG1NN.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNG1NR.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNG1NR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNG1NS.UFM   ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNG1NS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNGV1NC.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNGV1NC.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNGV1NH.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNGV1NH.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNGV1NM.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNGV1NM.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNGV1NN.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNGV1NN.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNGV1NR.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNGV1NR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\ufm ,SNGV1NS.UFM  ,src\print\mini\MDW\escp24tc\w2k\ufm  , SNGV1NS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\escp24tc\w2k\gtt ,EPSONXTA.GTT ,src\print\mini\MDW\escp24tc\w2k\gtt  , EPSONXTA.GTT  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201          ,pcpr201.MDW  ,src\print\mini\MDW\pcpr201           , pcpr201.MDW   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201          ,pcpr201.htm  ,src\print\mini\MDW\pcpr201           , pcpr201.htm   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k      ,makefile     ,src\print\mini\MDW\pcpr201\w2k       , makefile      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k      ,NC2180AJ.GPD ,src\print\mini\MDW\pcpr201\w2k       , NC2180AJ.GPD  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k      ,pcpr201.def  ,src\print\mini\MDW\pcpr201\w2k       , pcpr201.def   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k      ,PCPR201.RC   ,src\print\mini\MDW\pcpr201\w2k       , PCPR201.RC    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k      ,OEMPRINT.INF ,src\print\mini\MDW\pcpr201\w2k       , OEMPRINT.INF  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k      ,sources      ,src\print\mini\MDW\pcpr201\w2k       , sources       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k      ,stdnames.gpd ,src\print\mini\MDW\pcpr201\w2k       , stdnames.gpd  ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,CO10.UFM     ,src\print\mini\MDW\pcpr201\w2k\ufm   , CO10.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,CO12.UFM     ,src\print\mini\MDW\pcpr201\w2k\ufm   , CO12.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,CO17.UFM     ,src\print\mini\MDW\pcpr201\w2k\ufm   , CO17.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,CO5.UFM      ,src\print\mini\MDW\pcpr201\w2k\ufm   , CO5.UFM       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,CO6.UFM      ,src\print\mini\MDW\pcpr201\w2k\ufm   , CO6.UFM       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,CO8.UFM      ,src\print\mini\MDW\pcpr201\w2k\ufm   , CO8.UFM       ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,go_oR.UFM    ,src\print\mini\MDW\pcpr201\w2k\ufm   , go_oR.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,go_R.UFM     ,src\print\mini\MDW\pcpr201\w2k\ufm   , go_R.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,mi.UFM       ,src\print\mini\MDW\pcpr201\w2k\ufm   , mi.UFM        ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,mi_o.UFM     ,src\print\mini\MDW\pcpr201\w2k\ufm   , mi_o.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,mi_R.UFM     ,src\print\mini\MDW\pcpr201\w2k\ufm   , mi_R.UFM      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,ROMAN10.UFM  ,src\print\mini\MDW\pcpr201\w2k\ufm   , ROMAN10.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,ROMAN12.UFM  ,src\print\mini\MDW\pcpr201\w2k\ufm   , ROMAN12.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,ROMAN17.UFM  ,src\print\mini\MDW\pcpr201\w2k\ufm   , ROMAN17.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,ROMAN5.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , ROMAN5.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,ROMAN6.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , ROMAN6.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,ROMAN8.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , ROMAN8.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,ROMANPS.UFM  ,src\print\mini\MDW\pcpr201\w2k\ufm   , ROMANPS.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,SANS10.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , SANS10.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,SANS12.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , SANS12.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,SANS17.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , SANS17.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,SANS5.UFM    ,src\print\mini\MDW\pcpr201\w2k\ufm   , SANS5.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,SANS6.UFM    ,src\print\mini\MDW\pcpr201\w2k\ufm   , SANS6.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,SANS8.UFM    ,src\print\mini\MDW\pcpr201\w2k\ufm   , SANS8.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,SANSPS.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , SANSPS.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,Vgo_boR.UFM  ,src\print\mini\MDW\pcpr201\w2k\ufm   , Vgo_boR.UFM   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,Vgo_bR.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , Vgo_bR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,Vmi_b.UFM    ,src\print\mini\MDW\pcpr201\w2k\ufm   , Vmi_b.UFM     ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,Vmi_bo.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , Vmi_bo.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\ufm  ,Vmi_bR.UFM   ,src\print\mini\MDW\pcpr201\w2k\ufm   , Vmi_bR.UFM    ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\pcpr201\w2k\gtt  ,necxta.gtt   ,src\print\mini\MDW\pcpr201\w2k\gtt   , necxta.gtt    ,COPY
print\drivers\usermode\msplot                         , *           , src\print\msplot                                  , *           , HSPLIT
print\drivers\usermode\msplot\hlp                     , plotui.hlp  , src\print\msplot                                  , plotui.hlp  , COPY
print\drivers\usermode\msplot\inc                     , *.h         , src\print\msplot\inc                              , *           , HSPLIT
print\drivers\usermode\msplot\inf                     , plotter.inf , src\print\msplot                                  , plotter.inf , COPY
print\drivers\usermode\msplot\lib                     , *           , src\print\msplot\lib                              , *           , HSPLIT
print\drivers\usermode\msplot\lib\km                  , *           , src\print\msplot\lib\km                           , *           , HSPLIT
print\drivers\usermode\msplot\lib\um                  , *           , src\print\msplot\lib\um                           , *           , HSPLIT
print\drivers\usermode\msplot\mini                    , *           , src\print\msplot\mini                             , *           , HSPLIT
print\drivers\usermode\msplot\mini\hp20022                        , hp20022.pcd , src\print\msplot\mini\hp20022                     , hp20022.pcd , COPY
print\drivers\usermode\msplot\mini\hp20022                        , hp20022.txt , src\print\msplot\mini\hp20022                     , hp20022.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp20036                        , hp20036.pcd , src\print\msplot\mini\hp20036                     , hp20036.pcd , COPY
print\drivers\usermode\msplot\mini\hp20036                        , hp20036.txt , src\print\msplot\mini\hp20036                     , hp20036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp22024                        , hp22024.pcd , src\print\msplot\mini\hp22024                     , hp22024.pcd , COPY
print\drivers\usermode\msplot\mini\hp22024                        , hp22024.txt , src\print\msplot\mini\hp22024                     , hp22024.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp22036                        , hp22036.pcd , src\print\msplot\mini\hp22036                     , hp22036.pcd , COPY
print\drivers\usermode\msplot\mini\hp22036                        , hp22036.txt , src\print\msplot\mini\hp22036                     , hp22036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp23024                        , hp23024.pcd , src\print\msplot\mini\hp23024                     , hp23024.pcd , COPY
print\drivers\usermode\msplot\mini\hp23024                        , hp23024.txt , src\print\msplot\mini\hp23024                     , hp23024.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp23036                        , hp23036.pcd , src\print\msplot\mini\hp23036                     , hp23036.pcd , COPY
print\drivers\usermode\msplot\mini\hp23036                        , hp23036.txt , src\print\msplot\mini\hp23036                     , hp23036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp25024                        , hp25024.pcd , src\print\msplot\mini\hp25024                     , hp25024.pcd , COPY
print\drivers\usermode\msplot\mini\hp25024                        , hp25024.txt , src\print\msplot\mini\hp25024                     , hp25024.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp25036                        , hp25036.pcd , src\print\msplot\mini\hp25036                     , hp25036.pcd , COPY
print\drivers\usermode\msplot\mini\hp25036                        , hp25036.txt , src\print\msplot\mini\hp25036                     , hp25036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp33024                        , hp33024.pcd , src\print\msplot\mini\hp33024                     , hp33024.pcd , COPY
print\drivers\usermode\msplot\mini\hp33024                        , hp33024.txt , src\print\msplot\mini\hp33024                     , hp33024.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp33036                        , hp33036.pcd , src\print\msplot\mini\hp33036                     , hp33036.pcd , COPY
print\drivers\usermode\msplot\mini\hp33036                        , hp33036.txt , src\print\msplot\mini\hp33036                     , hp33036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp35024                        , hp35024.pcd , src\print\msplot\mini\hp35024                     , hp35024.pcd , COPY
print\drivers\usermode\msplot\mini\hp35024                        , hp35024.txt , src\print\msplot\mini\hp35024                     , hp35024.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp35036                        , hp35036.pcd , src\print\msplot\mini\hp35036                     , hp35036.pcd , COPY
print\drivers\usermode\msplot\mini\hp35036                        , hp35036.txt , src\print\msplot\mini\hp35036                     , hp35036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp60022                        , hp60022.pcd , src\print\msplot\mini\hp60022                     , hp60022.pcd , COPY
print\drivers\usermode\msplot\mini\hp60022                        , hp60022.txt , src\print\msplot\mini\hp60022                     , hp60022.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp60036                        , hp60036.pcd , src\print\msplot\mini\hp60036                     , hp60036.pcd , COPY
print\drivers\usermode\msplot\mini\hp60036                        , hp60036.txt , src\print\msplot\mini\hp60036                     , hp60036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp650c22                       , hp650c22.pcd, src\print\msplot\mini\hp650c22                    , hp650c22.pcd, COPY
print\drivers\usermode\msplot\mini\hp650c22                       , hp650c22.txt, src\print\msplot\mini\hp650c22                    , hp650c22.txt, HSPLIT
print\drivers\usermode\msplot\mini\hp650c36                       , hp650c36.pcd, src\print\msplot\mini\hp650c36                    , hp650c36.pcd, COPY
print\drivers\usermode\msplot\mini\hp650c36                       , hp650c36.txt, src\print\msplot\mini\hp650c36                    , hp650c36.txt, HSPLIT
print\drivers\usermode\msplot\mini\hp75024                        , hp75024.pcd , src\print\msplot\mini\hp75024                     , hp75024.pcd , COPY
print\drivers\usermode\msplot\mini\hp75024                        , hp75024.txt , src\print\msplot\mini\hp75024                     , hp75024.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp75036                        , hp75036.pcd , src\print\msplot\mini\hp75036                     , hp75036.pcd , COPY
print\drivers\usermode\msplot\mini\hp75036                        , hp75036.txt , src\print\msplot\mini\hp75036                     , hp75036.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp750m24                       , hp750m24.pcd, src\print\msplot\mini\hp750m24                    , hp750m24.pcd, COPY
print\drivers\usermode\msplot\mini\hp750m24                       , hp750m24.txt, src\print\msplot\mini\hp750m24                    , hp750m24.txt, HSPLIT
print\drivers\usermode\msplot\mini\hp750m36                       , hp750m36.pcd, src\print\msplot\mini\hp750m36                    , hp750m36.pcd, COPY
print\drivers\usermode\msplot\mini\hp750m36                       , hp750m36.txt, src\print\msplot\mini\hp750m36                    , hp750m36.txt, HSPLIT
print\drivers\usermode\msplot\mini\hp7550pl                       , hp7550pl.pcd, src\print\msplot\mini\hp7550pl                    , hp7550pl.pcd, COPY
print\drivers\usermode\msplot\mini\hp7550pl                       , hp7550pl.txt, src\print\msplot\mini\hp7550pl                    , hp7550pl.txt, HSPLIT
print\drivers\usermode\msplot\mini\hp755cm                        , hp755cm.pcd , src\print\msplot\mini\hp755cm                     , hp755cm.pcd , COPY
print\drivers\usermode\msplot\mini\hp755cm                        , hp755cm.txt , src\print\msplot\mini\hp755cm                     , hp755cm.txt , HSPLIT
print\drivers\usermode\msplot\mini\hp755cmm                       , hp755cmm.pcd, src\print\msplot\mini\hp755cmm                    , hp755cmm.pcd, COPY
print\drivers\usermode\msplot\mini\hp755cmm                       , hp755cmm.txt, src\print\msplot\mini\hp755cmm                    , hp755cmm.txt, HSPLIT
print\drivers\usermode\msplot\mini\hpdesign                       , hpdesign.pcd, src\print\msplot\mini\hpdesign                    , hpdesign.pcd, COPY
print\drivers\usermode\msplot\mini\hpdesign                       , hpdesign.txt, src\print\msplot\mini\hpdesign                    , hpdesign.txt, HSPLIT
print\drivers\usermode\msplot\mini\hpdmrxmx                       , hpdmrxmx.pcd, src\print\msplot\mini\hpdmrxmx                    , hpdmrxmx.pcd, COPY
print\drivers\usermode\msplot\mini\hpdmrxmx                       , hpdmrxmx.txt, src\print\msplot\mini\hpdmrxmx                    , hpdmrxmx.txt, HSPLIT
print\drivers\usermode\msplot\mini\hpdmsx                         , hpdmsx.pcd  , src\print\msplot\mini\hpdmsx                      , hpdmsx.pcd  , COPY
print\drivers\usermode\msplot\mini\hpdmsx                         , hpdmsx.txt  , src\print\msplot\mini\hpdmsx                      , hpdmsx.txt  , HSPLIT
print\drivers\usermode\msplot\mini\hpdpp22                        , hpdpp22.pcd , src\print\msplot\mini\hpdpp22                     , hpdpp22.pcd , COPY
print\drivers\usermode\msplot\mini\hpdpp22                        , hpdpp22.txt , src\print\msplot\mini\hpdpp22                     , hpdpp22.txt , HSPLIT
print\drivers\usermode\msplot\mini\hpdpp36                        , hpdpp36.pcd , src\print\msplot\mini\hpdpp36                     , hpdpp36.pcd , COPY
print\drivers\usermode\msplot\mini\hpdpp36                        , hpdpp36.txt , src\print\msplot\mini\hpdpp36                     , hpdpp36.txt , HSPLIT
print\drivers\usermode\msplot\mini\hpgl2pen                       , hpgl2pen.pcd, src\print\msplot\mini\hpgl2pen                    , hpgl2pen.pcd, COPY
print\drivers\usermode\msplot\mini\hpgl2pen                       , hpgl2pen.txt, src\print\msplot\mini\hpgl2pen                    , hpgl2pen.txt, HSPLIT
print\drivers\usermode\msplot\plotter                             , *           , src\print\msplot\plotter                          , *           , HSPLIT
print\drivers\usermode\msplot\plotui                              , *           , src\print\msplot\plotui                           , *           , HSPLIT
print\drivers\usermode\msplot\plotui\icons                        , *           , src\print\msplot\plotui\icons                     , *           , HSPLIT
print\drivers\usermode\msplot\tools                               , *           , src\print\msplot\tools                            , *           , HSPLIT
print\drivers\usermode\msplot\tools\ntres                         , *           , src\print\msplot\tools\ntres                      , *           , HSPLIT
print\drivers\usermode\tools\ps\makentf\cjkafm                    , psfamily.dat, tools\print                                       , *           , COPY
print\drivers\usermode\tools\ps\makentf\cjkafm                    , *.map, tools\print                                              , *           , COPY
print\drivers\usermode\tools\ps\makentf\cjkafm                    , *.ps, tools\print                                               , *           , COPY
ui\compstui\sample                                                , *           , src\print\cpsuisam                                , *           , HSPLIT
ui\compstui\sample\icons                                          , apple.ico   , src\print\cpsuisam\icons                          , apple.ico   , COPY
ui\compstui\sample\icons                                          , cpsuisam.ico, src\print\cpsuisam\icons                          , cpsuisam.ico, COPY
print\spooler\monitors\local                                      , *           , src\print\monitors\localmon                       , *           , HSPLIT
print\spooler\monitors\localui                                    , *           , src\print\monitors\localui                        , *           , HSPLIT
print\spooler\monitors\pjlmon                                     , *           , src\print\monitors\pjlmon                         , *           , HSPLIT
print\spooler\prtprocs\winprint                                   , emf.c       , src\print\genprint                                , emf.c       , HSPLIT
print\spooler\prtprocs\winprint                                   , genprint.htm, src\print\genprint                                , genprint.htm, HSPLIT
print\spooler\prtprocs\winprint                                   , local.c     , src\print\genprint                                , local.c     , HSPLIT
print\spooler\prtprocs\winprint                                   , local.h     , src\print\genprint                                , local.h     , HSPLIT
print\spooler\prtprocs\winprint                                   , makefile    , src\print\genprint                                , makefile    , HSPLIT
print\spooler\prtprocs\winprint                                   , parsparm.c  , src\print\genprint                                , parsparm.c  , HSPLIT
print\spooler\prtprocs\winprint                                   , raw.c       , src\print\genprint                                , raw.c       , HSPLIT
print\spooler\prtprocs\winprint                                   , sources     , src\print\genprint                                , sources     , HSPLIT
print\spooler\prtprocs\winprint                                   , support.c   , src\print\genprint                                , support.c   , HSPLIT
print\spooler\prtprocs\winprint                                   , text.c      , src\print\genprint                                , text.c      , HSPLIT
print\spooler\prtprocs\winprint                                   , util.c      , src\print\genprint                                , util.c      , HSPLIT
print\spooler\prtprocs\winprint                                   , winprint.c  , src\print\genprint                                , winprint.c  , HSPLIT
print\spooler\prtprocs\winprint                                   , winprint.def, src\print\genprint                                , winprint.def, HSPLIT
print\spooler\prtprocs\winprint                                   , winprint.h  , src\print\genprint                                , winprint.h  , HSPLIT
print\spooler\prtprocs\winprint                                   , winprint.prf, src\print\genprint                                , winprint.prf, HSPLIT
print\spooler\prtprocs\winprint                                   , winprint.rc , src\print\genprint                                , winprint.rc , HSPLIT
print\spooler\test\inet\qview                                     , *           , src\print\queueASP                                , *           , HSPLIT
print\spooler\test\pp                                             , makefile    , src\print\pp                                      , makefile    , HSPLIT
print\spooler\test\pp                                             , port.c      , src\print\pp                                      , port.c      , HSPLIT
print\spooler\test\pp                                             , pp.c        , src\print\pp                                      , pp.c        , HSPLIT
print\spooler\test\pp                                             , pp.def      , src\print\pp                                      , pp.def      , HSPLIT
print\spooler\test\pp                                             , pp.h        , src\print\pp                                      , pp.h        , HSPLIT
print\spooler\test\pp                                             , pp.htm      , src\print\pp                                      , pp.htm      , HSPLIT
print\spooler\test\pp                                             , sources     , src\print\pp                                      , sources     , HSPLIT

; TTY Samples

print\drivers\usermode\oemdrv\tty  ,tty.htm     ,src\print\tty  , tty.htm    ,COPY
print\drivers\usermode\oemdrv\tty  ,tty.gpd     ,src\print\tty  , tty.gpd    ,COPY
print\drivers\usermode\oemdrv\tty  ,tty.inf     ,src\print\tty  , tty.inf    ,COPY
print\drivers\usermode\oemdrv\tty  ,tty.ini     ,src\print\tty  , tty.ini    ,COPY
print\drivers\usermode\oemdrv\tty  ,ttyui.hlp   ,src\print\tty  , ttyui.hlp    ,COPY

print\drivers\usermode\oemdrv\tty\ufm  ,10cpib.UFM   ,src\print\tty\ufm  , 10cpib.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,12cpib.UFM   ,src\print\tty\ufm  , 12cpib.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,17cpib.UFM   ,src\print\tty\ufm  , 17cpib.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_437.UFM   ,src\print\tty\ufm  , df10_437.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_437.UFM   ,src\print\tty\ufm  , df12_437.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_437.UFM   ,src\print\tty\ufm  , df17_437.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_850.UFM   ,src\print\tty\ufm  , df10_850.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_850.UFM   ,src\print\tty\ufm  , df12_850.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_850.UFM   ,src\print\tty\ufm  , df17_850.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_852.UFM   ,src\print\tty\ufm  , df10_852.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_852.UFM   ,src\print\tty\ufm  , df12_852.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_852.UFM   ,src\print\tty\ufm  , df17_852.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_857.UFM   ,src\print\tty\ufm  , df10_857.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_857.UFM   ,src\print\tty\ufm  , df12_857.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_857.UFM   ,src\print\tty\ufm  , df17_857.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_863.UFM   ,src\print\tty\ufm  , df10_863.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_863.UFM   ,src\print\tty\ufm  , df12_863.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_863.UFM   ,src\print\tty\ufm  , df17_863.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_932.UFM   ,src\print\tty\ufm  , df10_932.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_932.UFM   ,src\print\tty\ufm  , df12_932.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_932.UFM   ,src\print\tty\ufm  , df17_932.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_936.UFM   ,src\print\tty\ufm  , df10_936.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_936.UFM   ,src\print\tty\ufm  , df12_936.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_936.UFM   ,src\print\tty\ufm  , df17_936.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_949.UFM   ,src\print\tty\ufm  , df10_949.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_949.UFM   ,src\print\tty\ufm  , df12_949.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_949.UFM   ,src\print\tty\ufm  , df17_949.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_950.UFM   ,src\print\tty\ufm  , df10_950.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_950.UFM   ,src\print\tty\ufm  , df12_950.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_950.UFM   ,src\print\tty\ufm  , df17_950.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_1250.UFM   ,src\print\tty\ufm  , df10_1250.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_1250.UFM   ,src\print\tty\ufm  , df12_1250.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_1250.UFM   ,src\print\tty\ufm  , df17_1250.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_1251.UFM   ,src\print\tty\ufm  , df10_1251.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_1251.UFM   ,src\print\tty\ufm  , df12_1251.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_1251.UFM   ,src\print\tty\ufm  , df17_1251.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_1252.UFM   ,src\print\tty\ufm  , df10_1252.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_1252.UFM   ,src\print\tty\ufm  , df12_1252.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_1252.UFM   ,src\print\tty\ufm  , df17_1252.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_1253.UFM   ,src\print\tty\ufm  , df10_1253.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_1253.UFM   ,src\print\tty\ufm  , df12_1253.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_1253.UFM   ,src\print\tty\ufm  , df17_1253.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df10_1254.UFM   ,src\print\tty\ufm  , df10_1254.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df12_1254.UFM   ,src\print\tty\ufm  , df12_1254.UFM    ,COPY
print\drivers\usermode\oemdrv\tty\ufm  ,df17_1254.UFM   ,src\print\tty\ufm  , df17_1254.UFM    ,COPY

print\drivers\usermode\oemdrv\tty\gtt  ,850.GTT    ,src\print\tty\gtt  , 850.GTT     ,COPY
print\drivers\usermode\oemdrv\tty\gtt  ,852.GTT    ,src\print\tty\gtt  , 852.GTT     ,COPY
print\drivers\usermode\oemdrv\tty\gtt  ,857.GTT    ,src\print\tty\gtt  , 857.GTT     ,COPY
print\drivers\usermode\oemdrv\tty\gtt  ,1250.GTT   ,src\print\tty\gtt  , 1250.GTT    ,COPY
print\drivers\usermode\oemdrv\tty\gtt  ,1251.GTT   ,src\print\tty\gtt  , 1251.GTT    ,COPY
print\drivers\usermode\oemdrv\tty\gtt  ,1252.GTT   ,src\print\tty\gtt  , 1252.GTT    ,COPY
print\drivers\usermode\oemdrv\tty\gtt  ,1253.GTT   ,src\print\tty\gtt  , 1253.GTT    ,COPY
print\drivers\usermode\oemdrv\tty\gtt  ,1254.GTT   ,src\print\tty\gtt  , 1254.GTT    ,COPY

print\drivers\usermode\oemdrv\tty\render  ,debug.cpp    ,src\print\tty\render  , debug.cpp    ,COPY
print\drivers\usermode\oemdrv\tty\render  ,debug.h      ,src\print\tty\render  , debug.h      ,COPY
print\drivers\usermode\oemdrv\tty\render  ,kmode.h      ,src\print\tty\render  , kmode.h      ,COPY
print\drivers\usermode\oemdrv\tty\render  ,makefile     ,src\print\tty\render  , makefile     ,COPY
print\drivers\usermode\oemdrv\tty\render  ,oem.h        ,src\print\tty\render  , oem.h        ,COPY
print\drivers\usermode\oemdrv\tty\render  ,oemcom.cpp   ,src\print\tty\render  , oemcom.cpp   ,COPY
print\drivers\usermode\oemdrv\tty\render  ,oemcom.h     ,src\print\tty\render  , oemcom.h     ,COPY
print\drivers\usermode\oemdrv\tty\render  ,precomp.h    ,src\print\tty\render  , precomp.h    ,COPY
print\drivers\usermode\oemdrv\tty\render  ,resource.h   ,src\print\tty\render  , resource.h  ,COPY
print\drivers\usermode\oemdrv\tty\render  ,sources      ,src\print\tty\render  , sources      ,HSPLIT
print\drivers\usermode\oemdrv\tty\render  ,ttyud.cpp    ,src\print\tty\render  , ttyud.cpp    ,COPY
print\drivers\usermode\oemdrv\tty\render  ,ttyud.h      ,src\print\tty\render  , ttyud.h      ,COPY
print\drivers\usermode\oemdrv\tty\render  ,ttyud.rc     ,src\print\tty\render  , ttyud.rc     ,COPY
print\drivers\usermode\oemdrv\tty\render  ,tty.def      ,src\print\tty\render  , tty.def     ,COPY

print\drivers\usermode\oemdrv\tty\ui  ,debug.cpp        ,src\print\tty\ui  , debug.cpp    ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,debug.h          ,src\print\tty\ui  , debug.h      ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,kmode.h          ,src\print\tty\ui  , kmode.h      ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,makefile         ,src\print\tty\ui  , makefile     ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,oem.h            ,src\print\tty\ui  , oem.h        ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,oemcom.cpp       ,src\print\tty\ui  , oemcom.cpp   ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,oemcomui.h       ,src\print\tty\ui  , oemcomui.h   ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,precomp.h        ,src\print\tty\ui  , precomp.h    ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,resource.h       ,src\print\tty\ui  , resource.h   ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,sources          ,src\print\tty\ui  , sources      ,HSPLIT
print\drivers\usermode\oemdrv\tty\ui  ,ttyui.cpp        ,src\print\tty\ui  , ttyui.cpp    ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,ttyui.rc         ,src\print\tty\ui  , ttyui.rc     ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,ttyui.rcv        ,src\print\tty\ui  , ttyui.rcv    ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,ttyuihlp.h       ,src\print\tty\ui  , ttyuihlp.h   ,COPY
print\drivers\usermode\oemdrv\tty\ui  ,ttyui.def        ,src\print\tty\ui  , ttyui.def    ,COPY

print\drivers\usermode\oemdrv\tty\rc  ,makefile         ,src\print\tty\rc  , makefile       ,COPY
print\drivers\usermode\oemdrv\tty\rc  ,sources          ,src\print\tty\rc  , sources       ,COPY
print\drivers\usermode\oemdrv\tty\rc  ,tty.rc           ,src\print\tty\rc  , tty.rc       ,COPY

print\drivers\usermode\oemdrv\tty\inc  ,name.h          ,src\print\tty\inc   , name.h       ,COPY
print\drivers\usermode\oemdrv\tty\inc  ,tty.h           ,src\print\tty\inc   , tty.h       ,COPY
print\drivers\usermode\oemdrv\tty\inc  ,ttyui.h         ,src\print\tty\inc   , ttyui.h       ,COPY

;
; Vector minidriver samples
;

print\drivers\usermode\ddk\samples\mini\MDW\vector\hpgl2 ,HPGL2.GPD      ,src\print\mini\MDW\vector\hpgl2  , HPGL2.GPD      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\vector\hpgl2 ,HPGL2.INF      ,src\print\mini\MDW\vector\hpgl2  , HPGL2.INF      ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\vector\pcl6  ,P6SAMPLE.GPD   ,src\print\mini\MDW\vector\pcl6   , P6SAMPLE.GPD   ,COPY
print\drivers\usermode\ddk\samples\mini\MDW\vector\pcl6  ,P6SAMPLE.INF   ,src\print\mini\MDW\vector\pcl6   , P6SAMPLE.INF   ,COPY

;
; Old STI samples
;

;scan\scancam\ddk\sample\hpsjusd                                  , *           , src\wdm\scancam\dll\hpsjusd                       , *           , HSPLIT
;scan\scancam\ddk\sample\sampcpl                                  , *           , src\wdm\scancam\sampcpl                           , *           , HSPLIT
;scan\scancam\ddk\sample\sampusd                                  , *           , src\wdm\scancam\dll\sampusd                       , *           , HSPLIT
;scan\scancam\ddk\sample\stillvue                                 , *           , src\wdm\scancam\app                               , *           , HSPLIT
;scan\scancam\kernel\scsiscan                                     , *           , src\wdm\scancam\scsiscan                          , *           , HSPLIT


;
; WIA Samples and Tools
;
; Note: tools\wia\scanpanl.exe, tools\wia\wiatest.exe and tools\wia\wialogcfg.exe are
;       binplaced into the DDK by printscan\wia\placefil.txt
;

wia\ddk                                                           , *           , src\wdm\wia                                       , *           , HSPLIT

wia\drivers\scanner\microsft\wiascanr                             , *           , src\wdm\wia\wiascanr                              , *           , HSPLIT
wia\drivers\scanner\microsft\microdrv                             , *           , src\wdm\wia\microdrv                              , *           , HSPLIT
wia\drivers\camera\microsft\inc                                   , *           , src\wdm\wia\inc                                   , *           , HSPLIT
wia\drivers\camera\microsft\wiacam                                , *           , src\wdm\wia\wiacam                                , *           , HSPLIT
wia\drivers\camera\microsft\fakecam                               , *           , src\wdm\wia\microcam                              , *           , HSPLIT
ui\extend\dll                                                     , *           , src\wdm\wia\extend                                , *           , HSPLIT
wia\kernel\usbscn9x                                               , *           , src\wdm\wia\usbscn9x                              , *           , COPY

wia\inc                                                           , wiamindr.idl, src\wdm\wia\idl                                   , *           , HSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\coffbase.txt ===
;
; fax dlls
;

usermode    0x01000000  0x60000000
faxab32     0x64000000  0x000c0000
fxscfg      0x640c0000  0x000c0000
fxsdrv      0x64200000  0x000c0000
fxsext32    0x642c0000  0x000c0000
fxsmon      0x64300000  0x000c0000
fxsperf     0x643c0000  0x000c0000
fxst30      0x644c0000  0x000c0000
fxsui       0x64500000  0x000c0000
fxswiz      0x645c0000  0x000c0000
fxsxp32     0x64600000  0x000c0000
winfax      0x646c0000  0x000c0000
fxstiff     0x64700000  0x000c0000
fxsmapi     0x647c0000  0x000c0000
fxsroute    0x64800000  0x000c0000
fxsevent    0x648c0000  0x000c0000
winfaxp     0x64900000  0x000c0000
faxcfgd     0x649c0000  0x000c0000
faxitg      0x64a00000  0x000c0000
fxscom      0x64ac0000  0x000c0000
faxisapi    0x64b00000  0x000c0000
faxxp32w    0x64bc0000  0x000c0000
faxab32w    0x64c00000  0x000c0000
faxocm      0x64cc0000  0x000c0000
fxsadmin    0x64d00000  0x000c0000
fax         0x64dc0000  0x000c0000
routeext    0x64e00000  0x000c0000
fspext      0x64ec0000  0x000c0000
fxsctxt     0x64f00000  0x000c0000
fxsfsput    0x64fc0000  0x000c0000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\nt_coffbase.txt ===
;
; fax dlls
;

usermode    0x01000000  0x60000000
faxab32     0x64000000  0x000c0000
fxscfg      0x640c0000  0x000c0000
fxsst       0x641c0000  0x00120000
fxsdrv      0x64200000  0x000c0000
fxsext32    0x642c0000  0x000c0000
fxsmon      0x64300000  0x000c0000
fxsperf     0x643c0000  0x000c0000
fxst30      0x644c0000  0x16000000
fxsui       0x64500000  0x000f0000
fxswiz      0x645c0000  0x000c0000
fxsxp32     0x64600000  0x10000000
winfax      0x646c0000  0x000c0000
fxstiff     0x64700000  0x11000000
fxsroute    0x64800000  0x000c0000
fxsevent    0x648c0000  0x000c0000
winfaxp     0x64900000  0x000c0000
faxcfgd     0x649c0000  0x000c0000
faxitg      0x64a00000  0x000c0000
fxscom      0x64ac0000  0x000c0000
faxisapi    0x64b00000  0x000c0000
faxxp32w    0x64bc0000  0x10000000
faxab32w    0x64c00000  0x000c0000
faxocm      0x64cc0000  0x000c0000
fxsadmin    0x64d00000  0x00300000
fax         0x64dc0000  0x000c0000
routeext    0x64e00000  0x000c0000
fspext      0x64ec0000  0x000c0000
fxsctxt     0x64f00000  0x000c0000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\placew9x.txt ===
FxsApi.dll		faxclients\WIN9X
FxsDrv32.dll	faxclients\WIN9X
FxsXp32.dll		faxclients\WIN9X
FxsExt32.dll	faxclients\WIN9X
FxsTiff.dll		faxclients\WIN9X
FxsWzrd.dll		faxclients\WIN9X
FxsSend.exe		faxclients\WIN9X
FxsClnt.exe		faxclients\WIN9X
FxsCover.exe	faxclients\WIN9X
FxsDrv16.drv	faxclients\WIN9X
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\exchange\ext\faxext.ini ===
\registry\machine\software\microsoft\exchange\client\extensions
    FaxExtensions = 4.0;d:\winnt\system32\faxext32.dll;1;00000100000000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\help\install.txt ===
Last Revision Date 4/1/1997 - John Mikesell

Location: \\orville\razzle\src\fax\help\install.txt

This install.txt file provides file locations, installation instructions, and uninstall instructions for Windows NT fax help, Windows 95 and WFG/3.11 Fax Clients help.

*** WHAT'S NEW ***
4/1/97
    1. RELEASE folder removed.
    2. WFW, W95 relnotes & readme files renamed
    3. WFW, W95 relnotes & readme placeholder files added

3/28/97
    1. Notes/readme files added to each build folder and install instructions.
    3. Fax client hlp/cnt files added to SERVER installation.
    4. Instructions added for Win95
    5. Headings added for 3.11/WFW (F-G) install/uninstall instructions.
    6. Faxview cnt/hlp files removed.
    7. Fax0.hlp added, notation in NT Windows.Cnt changed :Index fax.hlp -> fax0.hlp.
       See note H.1 at end of this file.

*** CONTENTS ***
    A. Locations of Help files in SLM fax project
    B. Windows NT Installation Instructions
       1. For all Windows NT installations
       2. Files for NT Server installations
       3. Files for NT Client installations
       4. Files for NT Personal Fax installations
    C. Windows NT Uninstall Instructions
       1. For all Windows NT installations
       2. Files removed for NT Server installations
       3. Files removed for NT Client installations
       4. Files removed for NT Personal Fax installations
    D. Windows 95 Fax Client Install
    E. Windows 95 Fax Client Uninstall
    F. Windows WFW and 3.11 Fax Client Install
    G. Windows WFW and 3.11 Fax Client Uninstall
    H. Notes

A. Locations of All Help files in SLM fax project

\\orville\razzle\src\fax\help\.

Copy files for Fax Server/Clients help from these locations only. No other locations are guaranteed to have the latest help files for Fax Server & Clients. 

Release (REMOVED)
   RELEASE NOTES AND README ARE NOW IN BUILD FOLDERS.

.\
   Install.txt - this file

.\Build
   Fax0.hlp  (called from windows.hlp contents)
   Fax.hlp
   Fax.cnt
   Faxcover.hlp
   Faxcover.cnt
   Faxui.hlp

.\Build.Srv
   Faxsrv.hlp
   Faxsrv.cnt
   faxinfo.txt
   faxrelnt.txt

.\Build.Clt
   Faxclt.hlp
   Faxclt.cnt
   faxinfo.txt
   faxrelnt.txt

.\Build.Wks  (Personal Fax)
   Faxwks.hlp
   Faxwks.cnt
   faxinfo.txt
   faxrelnt.txt

.\Build.WFW
   Fax3.hlp
   faxinf3.txt
   faxrel3.txt

.\Build.95
   Fax40.hlp
   Fax4.hlp
   Fax4.cnt
   faxinf4.txt
   faxrel4.txt

B. Windows NT Installation Instructions:

HLP and CNT files should go into the sysroot\help folder.

B.1. For all Windows NT installations

The following entry should be inserted in alphabetical order in the text file sysroot\system32\windows.cnt if not already inserted:

    :Index Fax Help=fax0.hlp

The following files should be deleted from  the sysroot\system32 folder, if they are present:
  
   Windows.gid (hidden configuration file, may exist)
   Windows.fts (full-text search index file, may exist)
   Windows.ftg (full-text search group list, may exist)

Files to be added for ALL installations
   Fax0.hlp
   Fax.hlp
   Fax.cnt
   Faxcover.hlp
   Faxcover.cnt
   Faxui.hlp

B.2. Files for NT Server installations
   Faxsrv.hlp
   Faxsrv.cnt
   Faxclt.hlp
   Faxclt.cnt
   faxinfos.txt
   faxrelnts.txt

B.3. Files for NT Client installations
   Faxclt.hlp
   Faxclt.cnt
   faxinfoc.txt
   faxrelntc.txt

B.4. Files for NT Personal Fax installations
   Faxwks.hlp
   Faxwks.cnt
   faxinfo.txt
   faxrelnt.txt

C. Windows NT Uninstall Instructions:

Note: These instructions apply completely only if all installations (client, server, & workstation) are being removed. * marks items that don't apply if one is being removed and another one left on.

C.1. For all Windows NT installations

* The following entry should be removed from the text file sysroot\system32\windows.cnt file. This actually won't affect program operation if it is left in and fax.hlp isn't there.

    :Index Fax Help=fax.hlp

* The following files should be deleted from  the sysroot\system32 folder:
  
   Windows.gid (hidden configuration file, may exist)
   Windows.fts (full-text search index file, may exist)
   Windows.ftg (full-text search group list, may exist)

* Files to be removed if all installations (server, workstation and client) are removed:

   Fax0.hlp
   Fax.hlp
   Fax.cnt
   Fax.gid
   Fax.fts
   Fax.ftg
   Faxcover.hlp
   Faxcover.cnt
   Faxcover.gid
   Faxcover.fts
   Faxcover.ftg
   Faxui.hlp
   Faxview.hlp
   Faxview.cnt
   Faxview.gid
   Faxview.fts
   Faxview.ftg

C.2. Files removed for NT Server installations

   Faxsrv.hlp
   Faxsrv.cnt
   Faxsrv.gid
   Faxsrv.fts
   Faxsrv.ftg
   Faxclt.hlp
   Faxclt.cnt
   Faxclt.gid
   Faxclt.fts
   Faxclt.ftg
   faxinfos.txt
   faxrelnts.txt

C.3. Files removed for NT Client installations

   Faxclt.hlp
   Faxclt.cnt
   Faxclt.gid
   Faxclt.fts
   Faxclt.ftg
   faxinfoc.txt
   faxrelntc.txt

C.4. Files removed for NT Personal Fax installations

   Faxwks.hlp
   Faxwks.cnt
   Faxwks.gid
   Faxwks.fts
   Faxwks.ftg
   faxinfo.txt
   faxrelnt.txt

D. Windows 95 Install

HLP and CNT files should go into the sysroot\help folder.

The following entry should be inserted in alphabetical order in the text file sysroot\help\windows.cnt if not already inserted:

    :Index Fax Help=fax40.hlp

The following files should be deleted from  the sysroot\system32 folder, if they are present:
  
   Windows.gid (hidden configuration file, may exist)
   Windows.fts (full-text search index file, may exist)
   Windows.ftg (full-text search group list, may exist)

The following files should be installed:

   Fax40.hlp
   Fax4.hlp
   Fax4.cnt
   Faxui.hlp
   faxinfo4.txt
   faxrelnt4.txt

E. Windows 95 Uninstall

The following entry should be removed from the text file sysroot\system32\windows.cnt file. This actually won't affect program operation if it is left in and fax.hlp isn't there.

    :Index Fax Help=fax40.hlp

The following files should be deleted from  the sysroot\system32 folder:
  
   Windows.gid (hidden configuration file, may exist)
   Windows.fts (full-text search index file, may exist)
   Windows.ftg (full-text search group list, may exist)

The following files should be removed:

   Fax40.hlp
   Fax4.hlp
   Fax4.cnt
   Fax4.gid
   Fax4.fts
   Fax4.ftg
   Faxui.hlp
   faxinfo4.txt
   faxrelnt4.txt

F. Windows WFG and 3.11 Install
   Fax3.hlp
   Faxui.hlp
   faxinfo3.txt
   faxrelnt3.txt

G. Windows WFG and 3.11 Uninstall (tentative)
   Fax3.hlp
   Faxui.hlp
   faxinfo3.txt
   faxrelnt3.txt

H. NOTES

H.1 Right now we reference fax.hlp in the NT Windows.Cnt by adding an ":Index Fax0.Hlp" (changed from Fax.hlp in 3/28/97 version of install instructions). This file has a topic which creates entries for "fax procedures" in the Windows.Hlp index users open on the start menu. If installing (Personal, Client/Server) fax becomes standard in any release of Windows NT, then this should be added to the Windows.Cnt file, and steps for inserting it here should be removed.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\lib\obj\ia64\readme.txt ===
placeholder so that the empty folder will be created
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\lib\obj\i386\readme.txt ===
placeholder so that the empty folder will be created
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\lib\win95\obj\i386\readme.txt ===
placeholder so that the empty folder will be created
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\lib\win95\i386\readme.txt ===
placeholder so that the empty folder will be created
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\perfmon\faxperf.ini ===
[info]
drivername=fax
symbolfile=faxcount.h

[languages]
009=English

[text]
FAXOBJ_009_NAME=Shared Fax Service
FAXOBJ_009_HELP=Shared Fax Service
INBOUND_BYTES_009_HELP=Number of bytes received.
INBOUND_BYTES_009_NAME=Bytes received
INBOUND_FAILED_RECEIVE_009_HELP=Number of faxes that service failed to receive.
INBOUND_FAILED_RECEIVE_009_NAME=Failed receptions
INBOUND_FAXES_009_HELP=Number of successfully received faxes.
INBOUND_FAXES_009_NAME=Received faxes
INBOUND_MINUTES_009_HELP=Number of minutes that the service received faxes.
INBOUND_MINUTES_009_NAME=Minutes receiving
INBOUND_PAGES_009_HELP=Number of pages received.
INBOUND_PAGES_009_NAME=Received pages
OUTBOUND_BYTES_009_HELP=Number of bytes sent.
OUTBOUND_BYTES_009_NAME=Bytes sent
OUTBOUND_FAILED_CONNECTIONS_009_HELP=Number of outgoing connections that failed.
OUTBOUND_FAILED_CONNECTIONS_009_NAME=Failed outgoing connections
OUTBOUND_FAILED_XMIT_009_HELP=Number of faxes that failed.
OUTBOUND_FAILED_XMIT_009_NAME=Failed faxes
OUTBOUND_FAXES_009_HELP=Number of faxes successfully sent.
OUTBOUND_FAXES_009_NAME=Faxes sent
OUTBOUND_MINUTES_009_HELP=Number of minutes that the service sent faxes.
OUTBOUND_MINUTES_009_NAME=Minutes sending
OUTBOUND_PAGES_009_HELP=Number of pages sent.
OUTBOUND_PAGES_009_NAME=Pages sent
TOTAL_BYTES_009_HELP=Total number of bytes sent and received.
TOTAL_BYTES_009_NAME=Total bytes
TOTAL_FAXES_009_HELP=Total number of faxes sent and received.
TOTAL_FAXES_009_NAME=Total faxes
TOTAL_MINUTES_009_HELP=Total number of minutes that the service sent and received faxes.
TOTAL_MINUTES_009_NAME=Total minutes sending and receiving
TOTAL_PAGES_009_HELP=Total number of pages sent and received.
TOTAL_PAGES_009_NAME=Total pages
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\perfmon\fxsperf.ini ===
[info]
drivername=fax
symbolfile=fxscount.h

[languages]
009=English

[text]
FAXOBJ_009_NAME=Fax Services
FAXOBJ_009_HELP=Fax Services
INBOUND_BYTES_009_HELP=Number of bytes received.
INBOUND_BYTES_009_NAME=Bytes received
INBOUND_FAILED_RECEIVE_009_HELP=Number of faxes that service failed to receive.
INBOUND_FAILED_RECEIVE_009_NAME=Failed receptions
INBOUND_FAXES_009_HELP=Number of successfully received faxes.
INBOUND_FAXES_009_NAME=Received faxes
INBOUND_MINUTES_009_HELP=Number of minutes that the service received faxes.
INBOUND_MINUTES_009_NAME=Minutes receiving
INBOUND_PAGES_009_HELP=Number of pages received.
INBOUND_PAGES_009_NAME=Received pages
OUTBOUND_BYTES_009_HELP=Number of bytes sent.
OUTBOUND_BYTES_009_NAME=Bytes sent
OUTBOUND_FAILED_CONNECTIONS_009_HELP=Number of outgoing connections that failed.
OUTBOUND_FAILED_CONNECTIONS_009_NAME=Failed outgoing connections
OUTBOUND_FAILED_XMIT_009_HELP=Number of faxes that failed.
OUTBOUND_FAILED_XMIT_009_NAME=Failed faxes
OUTBOUND_FAXES_009_HELP=Number of faxes successfully sent.
OUTBOUND_FAXES_009_NAME=Faxes sent
OUTBOUND_MINUTES_009_HELP=Number of minutes that the service sent faxes.
OUTBOUND_MINUTES_009_NAME=Minutes sending
OUTBOUND_PAGES_009_HELP=Number of pages sent.
OUTBOUND_PAGES_009_NAME=Pages sent
TOTAL_BYTES_009_HELP=Total number of bytes sent and received.
TOTAL_BYTES_009_NAME=Total bytes
TOTAL_FAXES_009_HELP=Total number of faxes sent and received.
TOTAL_FAXES_009_NAME=Total faxes
TOTAL_MINUTES_009_HELP=Total number of minutes that the service sent and received faxes.
TOTAL_MINUTES_009_NAME=Total minutes sending and receiving
TOTAL_PAGES_009_HELP=Total number of pages sent and received.
TOTAL_PAGES_009_NAME=Total pages

[objects]
FAXOBJ_009_NAME=Fax Services
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\runcodes.txt ===
Table 1a. Terminating White Codes
Code            Lng     Run
---------------------------
00110101        8       0
000111          6       1
0111            4       2
1000            4       3
1011            4       4
1100            4       5
1110            4       6
1111            4       7
10011           5       8
10100           5       9
00111           5       10
01000           5       11
001000          6       12
000011          6       13
110100          6       14
110101          6       15
101010          6       16
101011          6       17
0100111         7       18
0001100         7       19
0001000         7       20
0010111         7       21
0000011         7       22
0000100         7       23
0101000         7       24
0101011         7       25
0010011         7       26
0100100         7       27
0011000         7       28
00000010        8       29
00000011        8       30
00011010        8       31
00011011        8       32
00010010        8       33
00010011        8       34
00010100        8       35
00010101        8       36
00010110        8       37
00010111        8       38
00101000        8       39
00101001        8       40
00101010        8       41
00101011        8       42
00101100        8       43
00101101        8       44
00000100        8       45
00000101        8       46
00001010        8       47
00001011        8       48
01010010        8       49
01010011        8       50
01010100        8       51
01010101        8       52
00100100        8       53
00100101        8       54
01011000        8       55
01011001        8       56
01011010        8       57
01011011        8       58
01001010        8       59
01001011        8       60
00110010        8       61
00110011        8       62
00110100        8       63
11011           5       64
10010           5       128
010111          6       192
0110111         7       256
00110110        8       320
00110111        8       384
01100100        8       448
01100101        8       512
01101000        8       576
01100111        8       640
011001100       9       704
011001101       9       768
011010010       9       832
011010011       9       896
011010100       9       960
011010101       9       1024
011010110       9       1088
011010111       9       1152
011011000       9       1216
011011001       9       1280
011011010       9       1344
011011011       9       1408
010011000       9       1472
010011001       9       1536
010011010       9       1600
011000          6       1664
010011011       9       1728
00000001000     11      1792
00000001100     11      1856
00000001101     11      1920
000000010010    12      1984
000000010011    12      2048
000000010100    12      2112
000000010101    12      2176
000000010110    12      2240
000000010111    12      2304
000000011100    12      2368
000000011101    12      2432
000000011110    12      2496
000000011111    12      2560


Table 2a. Terminating Black Codes
Code            Lng     Run
---------------------------
0000110111      10      0
010             3       1
11              2       2
10              2       3
011             3       4
0011            4       5
0010            4       6
00011           5       7
000101          6       8
000100          6       9
0000100         7       10
0000101         7       11
0000111         7       12
00000100        8       13
00000111        8       14
000011000       9       15
0000010111      10      16
0000011000      10      17
0000001000      10      18
00001100111     11      19
00001101000     11      20
00001101100     11      21
00000110111     11      22
00000101000     11      23
00000010111     11      24
00000011000     11      25
000011001010    12      26
000011001011    12      27
000011001100    12      28
000011001101    12      29
000001101000    12      30
000001101001    12      31
000001101010    12      32
000001101011    12      33
000011010010    12      34
000011010011    12      35
000011010100    12      36
000011010101    12      37
000011010110    12      38
000011010111    12      39
000001101100    12      40
000001101101    12      41
000011011010    12      42
000011011011    12      43
000001010100    12      44
000001010101    12      45
000001010110    12      46
000001010111    12      47
000001100100    12      48
000001100101    12      49
000001010010    12      50
000001010011    12      51
000000100100    12      52
000000110111    12      53
000000111000    12      54
000000100111    12      55
000000101000    12      56
000001011000    12      57
000001011001    12      58
000000101011    12      59
000000101100    12      60
000001011010    12      61
000001100110    12      62
000001100111    12      63
0000001111      10      64
000011001000    12      128
000011001001    12      192
000001011011    12      256
000000110011    12      320
000000110100    12      384
000000110101    12      448
0000001101100   13      512
0000001101101   13      576
0000001001010   13      640
0000001001011   13      704
0000001001100   13      768
0000001001101   13      832
0000001110010   13      896
0000001110011   13      960
0000001110100   13      1024
0000001110101   13      1088
0000001110110   13      1152
0000001110111   13      1216
0000001010010   13      1280
0000001010011   13      1344
0000001010100   13      1408
0000001010101   13      1472
0000001011010   13      1536
0000001011011   13      1600
0000001100100   13      1664
0000001100101   13      1728
00000001000     11      1792
00000001100     11      1856
00000001101     11      1920
000000010010    12      1984
000000010011    12      2048
000000010100    12      2112
000000010101    12      2176
000000010110    12      2240
000000010111    12      2304
000000011100    12      2368
000000011101    12      2432
000000011110    12      2496
000000011111    12      2560
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\ddk\printer\bin\unitool.ini ===
[Menu Settings]
Validate=1

[Memory Settings]
Entries=79
0=-1,-1
1=1024,700
2=2048,1645
3=2048,1931
4=3072,2590
5=3072,2995
6=4096,3535
7=4096,3979
8=5120,4480
9=5120,5003
10=6144,5425
11=6144,6027
12=7168,6370
13=7168,7051
14=8192,7315
15=8192,8075
16=9216,8260
17=9216,9099
18=10240,9205
19=10240,10123
20=11264,10150
21=11264,11147
22=12288,12171
23=13312,12040
24=13312,13195
25=14336,12985
26=14336,14219
27=15360,15243
28=16384,16267
29=17408,15820
30=17408,17291
31=18432,18315
32=19456,19339
33=20480,20363
34=21504,21378
35=22528,22411
36=23552,23435
37=24576,24459
38=25600,25483
39=26624,26507
40=27648,27531
41=28672,28555
42=29696,29579
43=30720,30603
44=31744,31627
45=32768,31000
46=32768,32651
47=33792,33675
48=34816,34699
49=35840,35723
50=36864,36747
51=37888,37771
52=38912,38795
53=39936,39819
54=40960,40843
55=41984,41867
56=43008,42890
57=44032,43915
58=45056,44939
59=46080,45963
60=47104,46987
61=48128,48011
62=49152,49035
63=50176,50059
64=51200,51083
65=52224,52107
66=53248,53131
67=54272,54155
68=55296,55179
69=56320,56203
70=57344,57227
71=58368,58251
72=59392,59275
73=60416,60299
74=61440,61323
75=62464,62347
76=63488,63371
77=64512,64395
78=65536,65419
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\w95bin\placew95.txt ===
UNIDRV.DLL		faxclients\Win9X\Win95
UNIDRV.HLP		faxclients\Win9X\Win95
ICONLIB.DLL		faxclients\Win9X\Win95
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\w98bin\placew98.txt ===
UNIDRV.DLL		faxclients\Win9X\Win98
UNIDRV.HLP		faxclients\Win9X\Win98
ICONLIB.DLL		faxclients\Win9X\Win98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\sdktools\msvc15\bin\cl.err ===
2001	"too many symbols predefined with /D"
2002    "memory-model conflict"
2003    "missing source filename"
2005    "%s requires /vmg"
2008	"limit of %s exceeded at '%s'"
2011	"only one floating-point option allowed"
2012	"too many linker arguments"
2013    "incomplete model specification"
2016    "%s and %s command-line options are incompatible"
2018	"cannot create linker response file"
2019	"cannot overwrite source or object file '%s'"
2020	"%s option requires extended keywords to be enabled (/Ze)"
2021	"invalid numeric argument '%s'"
2022	"cannot open '%s'"
2023    "invalid model specification - flat model only"
2027	"cannot execute '%s'"
2028    "too many open files; cannot redirect '%s'"
2030	"internal compiler error in '%s'"
2031    "too many command-line options"
2000	"unknown command-line error"

				

4001	"listing overrides assembly output"
4002	"ignoring unknown option '%s'"
4003	"processor-option conflict"
4004	"/G3 only available in optimizing compiler; assuming /G2"
4005	"cannot find '%s';\nPlease enter new filename (full path) or CTRL+C to quit: "
4007	"'%s' requires '%s'; option ignored"
4009	"threshold only for far or huge data; ignored"
4011	"preprocessing overrides source listing"
4012	"function declarations override source listing"
4013	"combined listing overrides object listing"
4014	"invalid value '%d' for '%s'; assuming '%d'"
4018	".DEF files supported for segmented executable files only"
4019	"string too long; truncated to %d characters"
4020    "'%s' : missing argument; option ignored"
4021    "no action performed"
4022	"option '%s' invalid for %d-bit target"
4023	"option '%s' forces use of optimizing compiler"
4000	"unknown command-line warning"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\sdktools\msvc15\bin\c23.err ===
1001	"internal compiler error\n\t\t(compiler file '%s', line %d)"
1002	"compiler is out of heap space in pass 2"
1003	"error count exceeds %d; stopping compilation"
1004	"unexpected end-of-file found"
1005	"string too big for buffer"
1006	"write error on compiler intermediate file"
1007	"unrecognized flag '%s' in '%s'"
1013	"cannot open source file '%s'"
1015	"compiler limit : too many segments"
1027	"DGROUP data allocation exceeds 64K"
1029	"there are > 512 bytes of arguments"
1030	"there are > 512 bytes of local variables"
1032	"cannot open object listing file '%s'"
1033	"cannot open assembly language output file '%s'"
1035	"expression too complex, please simplify"
1036	"cannot open source listing file '%s'"
1037	"cannot open object file '%s'"
1039	"unrecoverable heap overflow in pass 3"
1040	"unexpected end-of-file in source file '%s'"
1041	"cannot open compiler intermediate file - no more files"
1042	"cannot open compiler intermediate file - no such file or directory"
1043	"cannot open compiler intermediate file"
1044	"out of disk space for compiler intermediate file"
1045	"floating-point overflow"
1048	"unknown option '%c' in '%s'"
1049	"invalid numerical argument '%s'"
1050	"'%s' : code segment too large"

1055	"compiler limit : out of keys"
1067	"intrinsic not implemented"
1073	"bad '%s' flag, would overwrite '%s' with '%s'"
1074	"too many '%s' flags, '%s'"
1083	"Cannot open %Fs file: '%Fs': %Fs"
1084	"Cannot read %Fs file: '%Fs': %Fs"
1085	"Cannot write %Fs file: '%Fs': %Fs"
1090	"'%s' data allocation exceeds 64K"
1126	"'%s' : automatic allocation exceeds %s"
1127	"'%s' : segment redefinition"
1900	"Il mismatch between '%s' version '%ld' and '%s' version '%ld'"
1000	"UNKNOWN FATAL ERROR\n\t\tContact Microsoft Product Support Services"

						
	
2125	"'%s' : allocation exceeds 64K"
2127	"parameter allocation exceeds 32K"
2129	"static function '%s' not found"
2220	"warning treated as error - no object file generated"
2374    "'%s' redefinition; multiple initialization"
2418	"'%s' : not in a register"
2427	"'%s' : jump referencing label is out of range"
2900	"'%s' : huge array cannot be aligned to segment boundary"
2000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"

						
	
4700	"local variable '%s' used without having been initialized"
4701	"local variable '%s' may be used without having been initialized"
4702	"unreachable code"
4703	"'%s' : function too large for global optimizations"
4704	"'%s' : in-line assembler precludes global optimizations"
4705	"statement has no effect"
4706	"assignment within conditional expression"
4707	"'%s' : function too large for global optimizations (%s)"  
4708	"ran out of heap at: %s"  
4709	"comma operator within array index expression"
4710	"function '%s' not expanded"
4711	"function '%s' selected for automatic inline expansion"
4712	"'%s' : used as register - loss of debugging information"
4713	"%s: internal compiler error; restarting\n\t\t(compiler file '%s', line %d)"
4723	"potential divide by 0"
4724	"potential mod by 0"
4726	"'%c' : unknown memory-model command-line option"
4727	"conditional expression is constant"
4746	"'%s' : unsized array treated as '%s'"
4756	"overflow in constant arithmetic"
4757	"overflow in constant multiplication"
4758	"address of automatic (local) variable taken, DS != SS"
4759	"segment lost in conversion"
4760	"'%Fs' : segment lost in initialization"
4761	"integral size mismatch in argument; conversion supplied"
4762	"near/far mismatch in argument : conversion supplied"
4763	"'%s' : function too large for post-optimizer"
4765	"recoverable heap overflow in post-optimizer - some optimizations may be missed"
4766	"local symbol table overflow - some local symbols may be missing in listings"
4769	"conversion of near pointer to long integer"
4772	"'%s' : too many debug entry points, maximum %d"
4773	"scoping too deep, deepest scoping merged when debugging"
4785	"near call to '%s' in different segment"
4786	"string too long - truncated to %d characters"
4787	"unprototyped function '%s' called in exception"
4788	"'%Fs' : identifier was truncated to '%d' characters"
4790	"insufficient memory to process debugging information"
4791	"loss of debugging information caused by optimization"
4792	"long double type not supported by alternate math library"
4900	"Il mismatch between '%s' version '%ld' and '%s' version '%ld'"

4000	"UNKNOWN WARNING\n\t\tContact Microsoft Product Support Services"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\sdktools\msvc15\bin\hc31.err ===
/***************************************
*
*  File problems
*
***************************************/
1019	"Project file extension cannot be .HLP or .PH."
1030	"File name exceeds limit of 259 characters."
1079	"Out of file handles."

1100	"Cannot open file '%s':  permission denied."

1150	"Cannot overwrite file '%s'."
1170	"File '%s' is a directory."

1190	"Cannot use reserved MS-DOS file name '%s'."

1230	"File '%s' not found."

1292	"File '%s' is not a valid bitmap."

1319	"Disk full."

1513	"Bitmap name '%s' duplicated."

1536	"Not enough memory to compress bitmap '%s'."

1000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"


/***************************************
*
*  General HPJ problems
*
***************************************/
2010	"Include statements nested more than 5 deep."

/* Syntax */
2030	"Comment starting at line %d of file '%s' unclosed at end of file."
2050	"Invalid #include syntax."
2091	"Bracket missing from section heading [%s]."
2111	"Section heading missing."
2131	"Invalid OPTIONS syntax: 'option=value' expected."
2141	"Invalid ALIAS syntax: 'context=context' expected."
2151	"Incomplete line in [%s] section."
2171	"Unrecognized text."
2191	"Section heading [%s] unrecognized."
2214	"Line in .HPJ file exceeds length limit of 2047 characters."

/* general section problems */
2273	"[OPTIONS] should precede [FILES] and [BITMAPS] for all options to take effect."
2291	"Section [%s] previously defined."
2305	"No valid files in [FILES] section."

/* Alias/Map problems */
2322	"Context string '%s' cannot be used as alias string."
2331	"Context number already used in [MAP] section."
2341	"Invalid or missing context string."
2351	"Invalid context identification number."
2362	"Context string '%s' already assigned an alias."
2372	"Alias string '%s' already assigned."

/* Window section problems */

2391	"Limit of 6 window definitions exceeded."
2401	"Window maximization state must be 0 or 1."
2411	"Invalid syntax in window color."
2421	"Invalid window position."
2431	"Missing quote in window caption."
2441	"Window name '%s' is too long."
2451	"Window position value out of range 0..1023."
2461	"Window name missing."
2471	"Invalid syntax in [WINDOWS] section."
2481	"Secondary window position required."
2491	"Duplicate window name '%s'."
2501	"Window caption '%s' exceeds limit of 50 characters."

/***************************************
*
*  OPTIONS section problems
*
***************************************/
2511	"Unrecognized option '%s' in [OPTIONS] section."
2532	"Option '%s' previously defined."

/* root */
2550	"Invalid path '%s' in %s option."
2570	"Path in %s option exceeds %d characters."

/* Font range */
2591	"Invalid MAPFONTSIZE option."
2612	"Maximum of 5 font ranges exceeded."
2632	"Current font range overlaps previously defined range."

/* Force font */
2651	"Font name exceeds limit of 20 characters."
2672	"Unrecognized font name '%s' in FORCEFONT option."

/* Multikey */
2691	"Invalid MULTIKEY option."
2711	"Maximum of 5 keyword tables exceeded."
2732	"Character already used."
2752	"Characters 'K' and 'k' cannot be used."

/* other */
2771	"REPORT option must be 'ON' or 'OFF'."

2811	"OLDKEYPHRASE option must be 'ON' or 'OFF'."
2832	"COMPRESS option must be 'OFF', 'MEDIUM', or 'HIGH'."
2842	"OPTCDROM option must be 'TRUE' or 'FALSE'."
2852	"Invalid TITLE option."
2872	"Invalid LANGUAGE option."
2893	"WARNING option must be 1, 2, or 3."
2911	"Invalid icon file '%s'."
2932	"Copyright string exceeds limit of 50 characters."


2000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"

/***************************************
*
*  Build tag/expression problems
*
***************************************/
3011	"Maximum of 32 build tags exceeded."
3031	"Build tag length exceeds 32 characters."
3051	"Build tag '%s' contains invalid characters."
3076	"[BUILDTAGS] section missing."
3096	"Build expression too complex."
3116	"Invalid build expression."
3133	"Duplicate build tag in [BUILDTAGS] section."

3152	"Build tag '%s' not defined in [BUILDTAGS] section."
3178	"Build expression missing from project file."


/***************************************
*
*  Macro errors
*
***************************************/

3511	"Macro '%s' exceeds limit of 254 characters."
3532	"Undefined function in macro '%s'."
3552	"Undefined variable in macro '%s'."
3571	"Wrong number of parameters to function in macro '%s'."
3591	"Syntax error in macro '%s'."
3611	"Function parameter type mismatch in macro '%s'."
3631	"Bad macro prototype."
3652	"Empty macro string."
3672	"Macro '%s' nested too deeply."

3000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"


/***************************************
*
*  Context string problems
*
***************************************/
4011	"Context string '%s' already used."
4031	"Invalid context string '%s'."
4056	"Unresolved context string specified in CONTENTS option."
4072	"Context string exceeds limit of 255 characters."
4098	"Context string(s) in [MAP] section not defined in any topic."
4113	"Unresolved jump or popup '%s'."
4131	"Hash conflict between '%s' and '%s'."
4151	"Invalid secondary window name '%s'."
4171	"Cannot use secondary window with popup."
4196	"Jumps and lookups not verified."

/***************************************
*
*  Footnote problems
*
***************************************/
4211	"Footnote text exceeds limit of 1023 characters."

/* browse */
4251	"Browse sequence not in first paragraph."
4272	"Empty browse sequence string."
4292	"Missing sequence number."
4312	"Browse sequence already defined."

/* title */
4331	"Title not in first paragraph."
4352	"Empty title string."
4372	"Title defined more than once."
4393	"Title exceeds limit of 128 characters."

/* keyword */
4412	"Keyword string exceeds limit of 255 characters."
4433	"Empty keyword string."
4452	"Keyword(s) defined without title."

/* build */
4471	"Build tag footnote not at beginning of topic."
4492	"Build tag exceeds limit of 32 characters."

/* entry macro */
4551	"Entry macro not in first paragraph."


/***************************************
*
*  RTF problems
*
***************************************/
4616	"File '%s' is not a valid RTF topic file."
4639	"Error in file '%s' at byte offset 0x%lX."
4649	"File '%s' contains more than 32767 topics."
4652	"Table formatting too complex."
4662	"Side by side paragraphs not supported."
4671	"Table contains more than 32 columns."
4680	"Font %d in file '%s' not in RTF font table."
4692	"Unrecognized graphic format."
4733	"Hidden page break."
4753	"Hidden paragraph."
4763	"Hidden carriage return."
4774	"Paragraph exceeds limit of 64K."
4792	"Non-scrolling region defined after scrolling region."
4813	"Non-scrolling region crosses page boundary."

4000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"

/***************************************
*
*  Miscellaneous
*
***************************************/
5035	"File '%s' not created."
5059	"Not enough memory to build help file."
5075	"Help Compiler corrupted.  Please reinstall HC.EXE."
5098	"Using old key-phrase table."
5115	"Write failed."
5139	"Aborted by user."

5000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\sdktools\msvc15\bin\c1.err ===
4001	"nonstandard extension 'single line comment' was used"
4002	"too many actual parameters for macro '%s'"
4003	"not enough actual parameters for macro '%s'"
4004	"incorrect construction after 'defined'"
4005	"'%Fs' : macro redefinition"
4006	"#undef expected an identifier"
4007	"'%Fs' : must be '%Fs'"
4008	"'%Fs' : '%Fs' attribute ignored"
4009	"string too big; trailing characters truncated"
4010	"single-line comment contains line-continuation character"
4011	"'%Fs' : identifier was truncated to '%d' characters"
4012	"float constant in a cross compilation" 
4013	"'%Fs' undefined; assuming extern returning int"
4014	"concatenating mismatched wide strings"
4015	"'%Fs' : type of bit field must be integral"
4016	"'%s' : no function return type; using 'int' as default" 
4017	"cast of 'int' expression to far pointer"
4018	"'%Fs' : signed/unsigned mismatch"
4019	"empty statement at global scope"
4020	"'%Fs' : too many actual parameters"
4021	"'%Fs' : too few actual parameters"
4022	"'%Fs' : pointer mismatch for actual parameter %d"
4023	"'%Fs' : based pointer passed to unprototyped function : parameter %d"
4024	"'%Fs' : different types for formal and actual parameter %d"
4025	"'%Fs' : based pointer passed to function with variable arguments: parameter %d"
4026	"function declared with formal parameter list"
4027	"function declared without formal parameter list"
4028	"formal parameter %d different from declaration"
4029	"declared formal parameter list different from definition"
4030	"first formal parameter list longer than the second list"
4031	"second formal parameter list longer than the first list"
4032	"formal parameter %d has different type when promoted"
4033	"'%Fs' must return a value"
4034	"sizeof returns 0"
4035	"'%Fs' : no return value"
4036	"unnamed %Fs as actual parameter"
4037	"conflicting ambient class modifiers"
4038	"'%Fs' : illegal ambient class modifier"
4039	"ambient class modifier on reference ignored"
4040	"memory attribute on '%Fs' ignored"
4041	"compiler limit : terminating browser output"
4042	"'%Fs' : has bad storage class"
4043	"function specifier used more than once"
4044	"specifier __huge on '%Fs' ignored; can only be applied to array"
4045	"'%Fs' : array bounds overflow"
4046	"'%Fs' : unsized array treated as %Fs"
4047	"'%Fs' : different levels of indirection"
4048	"different declared array subscripts"
4049	"'%Fs' : indirection to different types"
4050	"'%Fs' : different code attributes"
4051	"type conversion; possible loss of data"
4052	"function declarations different; one contains variable arguments"
4053	"one void operand for '?:'"
4054	"'%Fs' : from function pointer '%Fs' to data pointer '%Fs'"
4055	"'%Fs' : from data pointer '%Fs' to function pointer '%Fs'"
4056	"overflow in floating-point constant arithmetic"
4057	"'%Fs' : indirection to slightly different base types"
4058	"unions are now aligned on alignment requirement, not size"
4059	"pascal string too big, length byte is length % 256"

4060	"switch statement contains no 'case' or 'default' labels"
4061	"enumerate '%Fs' in switch of enum '%Fs' is not explicitly handled by a case label"
4062	"enumerate '%Fs' in switch of enum '%Fs' is not handled"
4063	"case '%ld' is not a valid value for switch of enum '%Fs'"
4064	"switch of incomplete enum '%Fs'"
4065	"switch statement contains 'default' but no 'case' labels"

4067	"unexpected characters following '%Fs' directive - newline expected"
4068	"unknown pragma"
4069	"long double is the same precision as double"
4070	"return of a 'void' expression"
4071	"'%Fs' : no function prototype given"
4072	"'%Fs' : no function prototype on __fastcall function"
4073	"initializers put in library initialization area"
4074	"initializers put in compiler reserved initialization area"
4075	"initializers put in unrecognized initialization area"
4076	"'%Fs' : can be used on integral types only"
4077	"unknown check_stack option"
4078	"case constant '%ld' too big for the type of the switch expression"
4079	"unexpected token '%Fs'"
4080	"expected identifier for segment name; found '%Fs'"
4081	"expected a comma; found '%Fs'"
4082	"expected an identifier; found '%Fs'"
4083	"expected '('; found '%Fs'"
4084	"expected a pragma directive; found '%Fs'"
4085	"expected pragma parameter to be 'on' or 'off'"
4086	"expected pragma parameter to be '1', '2', '4', '8', or '16'"
4087	"'%Fs' : declared with 'void' parameter list"
4088	"'%Fs' : pointer mismatch in actual parameter %d, formal parameter %d"
4089	"'%Fs' : different types in actual parameter %d, formal parameter %d"
4090	"'%Fs' : different const or volatile qualifiers"
4091	"no symbols were declared"
4092	"sizeof returns 'unsigned long'"
4093	"unescaped newline in character constant in inactive code"
4094	"untagged '%Fs' declared no symbols"
4095	"expected ')'; found '%Fs'"
4096	"'%Fs' must be used with '%Fs'"
4097	"nonstandard extension : typedef-name '%Fs' used as synonym for class-name '%Fs'"
4098	"'%Fs' : 'void' function returning a value"
4099	"'%Fs' : type name first seen using '%Fs' now seen using '%Fs'"
4100	"'%Fs' : unreferenced formal parameter"
4101	"'%Fs' : unreferenced local variable"
4102	"'%Fs' : unreferenced label"
4103	"'%Fs' : used #pragma pack to change alignment"
4104	"'%Fs' : near data in same_seg pragma; ignored"
4105	"'%Fs' : code modifiers only on function or pointer to function"
4106	"pragma requires an integer between 1 and 127"
4107	"pragma requires an integer between 15 and 255"
4108	"pragma requires an integer between 79 and 132"
4109	"unexpected identifier '%Fs'"
4110	"unexpected token 'number'"
4111	"unexpected token 'string'"
4112	"#line requires an integer between 1 and 32767"
4113	"function parameter lists differed"
4114	"same type qualifier used more than once"
4115	"'%Fs' : named type definition in parentheses"
4116	"unnamed type definition in parentheses"
4117	"macro name '%Fs' is reserved, '%Fs' ignored"
4118	"pragma not supported during fast compile"
4119	"different bases '%Fs' and '%Fs' specified"
4120	"based/unbased mismatch"
4121	"'%Fs' : alignment of a member was sensitive to packing"
4122	"'%Fs' : alloc_text applicable only to functions with C linkage"
4123	"different base expressions specified"
4124	"__fastcall with stack checking is inefficient"
4125	"decimal digit terminates octal escape sequence"
4126	"'%c' : unknown memory-model command-line option"
4127	"conditional expression is constant"
4128	"storage-class specifier after type"
4129	"'%c' : unrecognized character escape sequence"
4130	"'%Fs' : logical operation on address of string constant"
4131	"'%Fs' : uses old-style declarator"
4132	"'%Fs' : const object should be initialized"
4133	"'%Fs' : incompatible types - pointer to 'void' combined with pointer to type"
4134	"conversion between pointers to members of same class"
4135	"conversion between different integral types"
4136	"conversion between different floating-point types"
4137	"'%Fs' : no return value from floating-point function"
4138	"'*/' found outside of comment"
4139	"'0x%lx' : hex escape sequence is out of range"
4140	"'%Fs' : redefined, preceding references may be invalid"  
4141	"'%Fs' : used more than once"
4142	"benign redefinition of type"
4143	"pragma 'same_seg' not supported; use __based allocation"
4144	"'%Fs' : relational expression as switch expression"
4145	"'%Fs' : relational expression as switch expression; possible confusion with '%Fs'"
4146	"unary minus operator applied to unsigned type, result still unsigned"
4147	"'%Fs' : '%Fs' ignored on pointer and reference declarations"
4148	"'%Fs' : DS != SS for '__near' '%Fs'"
4149	"'%Fs' : different ambient model than base class '%Fs'"
4150	"deletion of pointer to incomplete type '%Fs'; no destructor called"
4151	"'%Fs' : operator should be explicitly '%Fs'"
4152	"nonstandard extension, function/data pointer conversion in expression"
4153	"function/data pointer conversion in expression"
4154	"deletion of an array expression; conversion to pointer supplied"
4155	"deletion of an array expression without using the array form of 'delete'"
4156	"deletion of an array expression without using the array form of 'delete'; array form substituted"
4157	"pragma was ignored by C compiler"
4158	"assuming #pragma pointers_to_members(full_generality, %Fs_inheritance)"

4184	"near call to thunk for '%Fs' in a different segment"

4200	"nonstandard extension used : zero-sized array in struct/union"
4201	"nonstandard extension used : nameless struct/union"
4202	"nonstandard extension used : '...': prototype parameter in name list illegal"
4203	"nonstandard extension used : union with static member variable"
4204	"nonstandard extension used : non-constant aggregate initializer"
4205	"nonstandard extension used : static function declaration in function scope"
4206	"nonstandard extension used : translation unit is empty"
4207	"nonstandard extension used : extended initializer form"
4208	"nonstandard extension used : delete [exp] - exp evaluated but ignored"
4209	"nonstandard extension used : benign typedef redefinition"
4210	"nonstandard extension used : function given file scope"
4211	"nonstandard extension used : redefined extern to static"
4212	"nonstandard extension used : function declaration used ellipsis"
4213	"nonstandard extension used : cast on l-value"
4214	"nonstandard extension used : bit field types other than int"
4215	"nonstandard extension used : long float"
4216	"nonstandard extension used : float long"
4217	"nonstandard extension used : function declaration from a previous block"
4218	"nonstandard extension used : must specify at least a storage class or a type"
4219	"nonstandard extension used : trailing ',' used for variable argument list"
4220	"varargs matches remaining parameters"
4221	"nonstandard extension used : '%Fs' : cannot be initialized using address of automatic variable '%Fs'"
4222	"nonstandard extension used : '%Fs' : 'static' should not be used on member functions defined at file scope"
4223	"nonstandard extension used : non-lvalue array converted to pointer"

4241	"'%Fs' : member access is restricted"

4243	"%Fs conversion from '%Fs' to '%Fs' exists, but is inaccessible"

4245	"'friend' specified for nonexistent function '%Fs'"

4247	"'%Fs' not accessible because '%Fs' uses '%Fs' to inherit from '%Fs'"
4248	"'%Fs' : cannot access %Fs %Fs declared in class '%Fs'"
4249	"'%Fs' : no path to %Fs %Fs declared in virtual base '%Fs'"
4250	"'%Fs' : inherits '%Fs::%Fs' via dominance"
4251	"'%Fs' : base type '%Fs' should be exported to export %Fs '%Fs'"
4252	"'%Fs' is not defined; cannot specify CodeView information"

4260	"no override, '%Fs::%Fs' has %Fs 'this' memory model whereas '%Fs::%Fs' has %Fs 'this' memory model"
4261	"no override, '%Fs::%Fs' has %Fs calling convention whereas '%Fs::%Fs' has %Fs calling convention"
4262	"no override, '%Fs::%Fs' has %Fs 'this' whereas '%Fs::%Fs' has %Fs 'this'"

4270	"'%Fs' : do not initialize a non-const '%Fs' with a non-lvalue '%Fs' function return"

4300	"conversion of pointer to nonintegral type"

4305	"'%Fs' : truncation from '%Fs' to '%Fs'"
4306	"'%Fs' : conversion from '%Fs' to '%Fs' of greater size"
4307	"'%Fs' : integral constant overflow"
4308	"negative integral constant converted to unsigned type"
4309	"'%Fs' : truncation of constant value"

4341	"'%Fs' : signed value is out of range for enum constant"
4342	"precision lost in initialization of enum constant"

4354	"'%Fs' : initialization of reference to member requires a temporary variable"
4355	"'this' : used in base member initializer list"

4385	"%Fs the '%Fs' in base '%Fs'"
4386	"%Fs to the '%Fs' in base '%Fs'"
4387	"'%Fs' : was considered"

4401	"'%Fs' : member is bit field"
4402	"must use PTR operator"
4403	"illegal PTR operator"
4404	"period on directive ignored"
4405	"'%Fs' : identifier is reserved word"
4406	"operand on directive ignored"

4409	"illegal instruction size"
4410	"illegal size for operand"
4411	"'%Fs' : symbol resolves to displacement register"

4414	"'%Fs' : short jump to function converted to near"

4500	"'%Fs' : class has private/protected data members; user-defined constructor advised"
4501	"'%Fs' : use of '::' unnecessary here"
4502	"'linkage' requires use of keyword 'extern'"

4504	"type still ambiguous after parsing %d tokens, assuming declaration"
4505	"'%Fs' : unreferenced local function has been removed"
4506	"no definition for inline function '%Fs'"
4507	"explicit linkage specified after default linkage was used"
4508	"'%Fs' : function should return a value; 'void' return type assumed"

4510	"'%Fs' : default constructor could not be generated"
4511	"'%Fs' : copy constructor could not be generated"
4512	"'%Fs' : assignment operator could not be generated"
4513	"'%Fs' : destructor could not be generated"

4520	"'%Fs' : multiple default constructors specified"
4521	"'%Fs' : multiple copy constructors specified"
4522	"'%Fs' : multiple assignment operators specified"
4523	"'%Fs' : multiple destructors specified"
4524	"'%Fs' : redundant use of 'friend' on destructor"
4525	"'%Fs' : redundant use of 'friend' on constructor"

4527	"instances of %Fs '%Fs' can never be destroyed - user-defined destructor required"
4528	"illegal 'pure' syntax, must be '= 0'"

4607	"'%Fs' : must be initialized in constructor base/member initializer list"

4610	"%Fs '%Fs' can never be instantiated - user defined constructor required"

4612	"bad #pragma syntax, pragma ignored"
4613	"'%Fs' : class of segment cannot be changed"
4614	"'%Fs' : varargs parameters with this type were promoted"	
4615	"#pragma warning : unknown user warning type"
4616	"#pragma warning : warning number '%d' out of range, must be between '%d' and '%d'"
4617	"#pragma warning : invalid warning number"

4620	"no postfix form of 'operator ++' found for type '%Fs', using prefix form"
4621	"no postfix form of 'operator --' found for type '%Fs', using prefix form"
4622	"overwriting debug information formed during creation of the precompiled header in object file: '%s'"

4630	"'%Fs' : '%Fs' storage-class specifier illegal on member definition"

4650	"debugging information not in precompiled header; only global symbols from the header will be available"
4651	"'/D%s' specified for precompiled header but not for current compile"
4652	"command-line option '%Fs' inconsistent with precompiled header; precompiled header option ignored"

4699	"Note: %Fs"

4706	"assignment within conditional expression" 

4710	"'%Fs' : function not expanded" 

4726	"'%c' : unknown memory model command-line option"
4727	"conditional expression is constant"

4741	"/Oq option ignored for __fastcall function '%Fs'"

4746	"'%Fs' : unsized array given size %Fs"

4756	"overflow in constant arithmetic"	

4758	"address of automatic (local) variable taken, DS != SS" 
4759	"segment lost in conversion"	
4760	"'%Fs' : segment lost in initialization"	

4761	"integral size mismatch in argument : conversion supplied"	
4762	"near/far mismatch in argument : conversion supplied"	

4769	"conversion of near pointer to long integer"	

4785	"near call to '%Fs' in different segment" 

4788	"'%Fs' : identifier was truncated to '%d' characters"

4793	"native code generated for p-code function '%Fs' with inline assembly"

4900	"intermediate language mismatch between '%s' version '%ld' and '%s' version '%ld'"

4000	"UNKNOWN WARNING\n\t\tContact Microsoft Product Support Services"
						

2001	"newline in constant"
2002	"invalid wide-character constant"
2003	"expected 'defined id'"
2004	"expected 'defined(id)'"
2005	"#line expected a line number, found '%Fs'"
2006	"#include expected a filename, found '%Fs'"
2007	"#define syntax"
2008	"'%c' : unexpected in macro definition"
2009	"reuse of macro formal '%Fs'"
2010	"'%c' : unexpected in macro formal parameter list"
2011	"'%Fs' : '%Fs' type redefinition"
2012	"missing name following '<'"
2013	"missing '>'"
2014	"preprocessor command must start as first nonwhite space"
2015	"too many characters in constant"
2016	"no closing single quotation mark"
2017	"illegal escape sequence"
2018	"unknown character '0x%x'"
2019	"expected preprocessor directive, found '%c'"
2020	"'%Fs' : '%Fs' member redefinition"
2021	"expected exponent value, not '%c'"
2022	"'%ld' : too big for character"
2023	"divide by 0"
2024	"mod by 0"
2025	"'%s' : enum/struct/union type redefinition"		
2026	"string too big, trailing characters truncated"
2027	"use of undefined type '%Fs'"
2028	"struct/union member must be inside a struct/union"
2029	"left of '%s' specifies undefined class/struct/union '%Fs'"
2030	"'%Fs' : struct/union member redefinition"		
2031	"'%Fs' : function cannot be struct/union member"	
2032	"'%Fs' : function cannot be member of %Fs '%Fs'"
2033	"'%Fs' : bit field cannot have indirection"
2034	"'%Fs' : type of bit field too small for number of bits"
2035	"struct/union '%Fs' : unknown size"			
2036	"'%Fs' : unknown size"
2037	"left of '%s' specifies undefined struct/union '%Fs'"
2038	"'%s' : not struct/union member"			
2039	"'%Fs' : is not a member of '%Fs'"
2040	"'%Fs' : different levels of indirection"
2041	"illegal digit '%c' for base '%d'"
2042	"signed/unsigned keywords mutually exclusive"
2043	"illegal break"
2044	"illegal continue"
2045	"'%Fs' : label redefined"
2046	"illegal case"
2047	"illegal default"
2048	"more than one default"
2049	"case value '%ld' already used"
2050	"switch expression not integral"
2051	"case expression not constant"
2052	"case expression not integral"
2053	"'%Fs' : wide string mismatch"
2054	"expected '(' to follow '%Fs'"
2055	"expected formal parameter list, not a type list"
2056	"illegal expression"
2057	"expected constant expression"
2058	"constant expression is not integral"
2059	"syntax error : '%Fs'"
2060	"syntax error : end of file found"
2061	"syntax error : identifier '%Fs'"
2062	"type '%Fs' unexpected"
2063	"'%Fs' : not a function"
2064	"term does not evaluate to a function"
2065	"'%Fs' : undeclared identifier"
2066	"cast to function type is illegal"
2067	"cast to array type is illegal"
2068	"illegal cast from '%Fs' to '%Fs'"
2069	"cast of 'void' term to non-'void'"
2070	"illegal sizeof operand"
2071	"'%Fs' : illegal storage class"
2072	"'%Fs' : initialization of a function"
2073	"'%Fs' : partially initialized array requires a default constructor"
2074	"'%Fs' : '%Fs' initialization needs curly braces"
2075	"'%Fs' : array initialization needs curly braces"
2076	"'%Fs' : struct/union initialization needs curly braces" 
2077	"nonscalar field initializer '%Fs'"
2078	"too many initializers"
2079	"'%Fs' uses undefined class/struct/union '%Fs'"
2080	"illegal __far __fastcall function or __saveregs function"
2081	"'%Fs' : name in formal parameter list illegal"
2082	"redefinition of formal parameter '%Fs'"
2083	"%Fs comparison illegal"
2084	"function '%Fs' already has a body"
2085	"'%Fs' : not in formal parameter list"
2086	"'%Fs' : redefinition"
2087	"'%Fs' : missing subscript"
2088	"'%Fs' : illegal for %Fs"
2089	"'%Fs' : '%Fs' too large"
2090	"function returns array"
2091	"function returns function"
2092	"array element type cannot be function"
2093	"'%Fs' : cannot be initialized using address of automatic variable '%Fs'"
2094	"label '%Fs' was undefined"
2095	"'%Fs' : actual parameter has type 'void' : parameter %d"
2096	"struct/union comparison illegal"		
2097	"illegal initialization"
2098	"expression is not an address"
2099	"initializer is not a constant"
2100	"illegal indirection"
2101	"'%Fs' on constant"
2102	"'%Fs' requires l-value"
2103	"'%Fs' on register variable"
2104	"'%Fs' on bit field ignored"
2105	"'%Fs' needs l-value"
2106	"'%Fs' : left operand must be l-value"
2107	"illegal index, indirection not allowed"
2108	"subscript is not of integral type"
2109	"subscript requires array or pointer type"
2110	"cannot add two pointers"
2111	"pointer addition requires integral operand"
2112	"pointer subtraction requires integral or pointer operand"
2113	"pointer can only be subtracted from another pointer"
2114	"'%Fs' : pointer on left; needs integral value on right"
2115	"'%Fs' : incompatible types"
2116	"function parameter lists differed"
2117	"'%Fs' : array bounds overflow"
2118	"negative subscript"
2119	"typedef types both define indirection"
2120	"'void' illegal with all types"
2121	"'%Fs' : bad %Fs operand"
2122	"'%Fs' : prototype parameter in name list illegal"
2123	"'%Fs' : cannot call __fastcall function '%Fs' from p-code"
2124	"divide or mod by zero"
2125	"'%Fs' : allocation exceeds 64K"	
2126	"'%Fs' : incorrect operand"
2127	"parameter allocation exceeds 32K"	
2128	"'%Fs' : alloc_text/same_seg applicable only to functions with C linkage"
2129	"static function '%Fs' declared but not defined"
2130	"#line expected a string containing the filename, found '%Fs'"
2131	"more than one memory attribute"
2132	"syntax error : unexpected identifier"
2133	"'%Fs' : unknown size"
2134	"'%Fs' : struct/union too large"	
2135	"'%Fs' : illegal bit field operation"
2136	"'%Fs' : prototype must have parameter types"
2137	"empty character constant"
2138	"illegal to define an enumeration without any members"
2139	"type following '%s' is illegal"
2140	"parameter cannot be function type"
2141	"value out of range for enum constant"
2142	"function declarations differ, variable parameters specified only in one of them"
2143	"syntax error : missing '%Fs' before '%Fs'"
2144	"syntax error : missing '%Fs' before type '%Fs'"
2145	"syntax error : missing '%Fs' before identifier"
2146	"syntax error : missing '%Fs' before identifier '%Fs'"
2147	"'%Fs' : const array must be fully initialized"
2148	"array too large"
2149	"'%Fs' : named bit field cannot have zero width"
2150	"'%Fs' : bit field must have type 'int', 'signed int', or 'unsigned int'"
2151	"more than one language attribute"
2152	"'%Fs' : pointers to functions with different attributes"
2153	"hex constants must have at least one hex digit"
2154	"'%Fs' : does not refer to a segment name"
2155	"'?' : invalid left operand, expected arithmetic or pointer type"
2156	"pragma must be outside function"
2157	"'%Fs' : must be declared before use in pragma list"
2158	"'%Fs' : is a function"
2159	"more than one storage class specified"
2160	"'##' cannot occur at the beginning of a macro definition"
2161	"'##' cannot occur at the end of a macro definition"
2162	"expected macro formal parameter"
2163	"'%Fs' : not available as an intrinsic function"
2164	"'%Fs' : intrinsic function not declared"
2165	"'%Fs' : cannot modify pointers to data"
2166	"l-value specifies const object"
2167	"'%Fs' : too many actual parameters for intrinsic function"
2168	"'%Fs' : too few actual parameters for intrinsic function"
2169	"'%Fs' : intrinsic function, cannot be defined"
2170	"'%Fs' : not declared as a function, cannot be intrinsic"
2171	"'%Fs' : illegal operand"
2172	"'%Fs' : actual parameter is not a pointer : parameter %d"
2173	"'%Fs' : actual parameter is not a pointer : parameter %d, parameter list %d"
2174	"'%Fs' : actual parameter has type 'void' : parameter %d, parameter list %d"
2175	"'%Fs' : invalid locale"
2176	"static huge data not supported by '%Fs'"	 
2177	"constant too big"
2178	"'%Fs' : storage class for same_seg variables must be extern"
2179	"'%Fs' : was used in same_seg, but storage class is no longer extern"
2180	"controlling expression has type 'void'"
2181	"illegal else without matching if"
2182	"'%Fs' : has type 'void'"
2183	"syntax error: translation unit is empty"
2184	"illegal return of a 'void' value"
2185	"'%Fs' : illegal based allocation"
2186	"'%Fs' : illegal operand of type 'void'"
2187	"cast of near function pointer to far function pointer"
2188	"'%ld' : too big for wide character"
2189	"#error : %Fs"
2190	"first parameter list longer than second"
2191	"second parameter list longer than first"
2192	"parameter '%d' declaration different"
2193	"'%Fs' : already in a segment"
2194	"'%Fs' : is a text segment"
2195	"'%Fs' : is a data segment"
2197	"'%Fs' : too many actual parameters"
2198	"'%Fs' : too few actual parameters"
2199	"syntax error : found '%Fs (' at global scope (was a declaration intended?)"
2200	"'%Fs' : function has already been defined"
2201	"'%Fs' : cannot export static declarations"
2202	"'%Fs' : not all control paths return a value"
2203	"delete operator cannot specify bounds for an array"
2204	"'%Fs' : type definition found within parentheses"
2205	"'%Fs' : cannot initialize extern variables with block scope"
2206	"'%Fs' : typedef cannot be used for function definition"
2207	"'%Fs' in struct/union '%Fs' has a zero-sized array"	
2208	"'%Fs' : no members defined using this type"
2209	"type cast in __based construct must be (__segment)"
2210	"'%Fs' : must be near/far data pointer"
2211	"(__segment) applied to function identifier '%Fs'"
2212	"'%Fs' : __based not available for pointers to functions"
2213	"'%Fs' : illegal argument to __based"
2214	"pointers based on 'void' require the use of :>"
2215	"':>' operator only for objects based on 'void'"
2216	"'%Fs' cannot be used with '%Fs'"
2217	"'%Fs' must be used with '%Fs'"
2218	"type in __based construct must be 'void'"
2219	"syntax error : type qualifier must be after '*'"
2220	"warning treated as error - no object file generated"
2221	"'.' : left operand points to class/struct/union, use '->'" 
2222	"'->' : left operand has struct/union type, use '.'"	
2223	"left of '->%Fs' must point to class/struct/union"
2224	"left of '.%Fs' must have class/struct/union type"
2225    "'%Fs' : function allocation must be in a named segment"
2226	"syntax error : unexpected type '%Fs'"
2227	"left of '->%Fs' must point to class/struct/union"
2228	"left of '.%Fs' must have class/struct/union type"
2229	"%Fs '%Fs' has an illegal zero-sized array"
2230	"'%Fs' : indirection to different types"
2231	"'.' : left operand points to '%Fs', use '->'"
2232	"'->' : left operand has '%Fs' type, use '.'"
2233	"'%Fs' : arrays of objects containing zero-size arrays are illegal"
2234	"arrays of references are illegal"
2235	"';' in formal parameter list"
2236	"unexpected '%Fs' '%Fs'"
2237	"unexpected %Fs '%Fs'"
2238	"unexpected token[s] preceding '%s'"
2239	"unexpected token '%Fs' following declaration of '%Fs'"
2240	"unexpected '%Fs' following formal list (only modifiers are allowed)"
2241	"'%Fs' : member access is restricted"
2242	"typedef name cannot follow class/struct/union"
2243	"%Fs conversion from '%Fs' to '%Fs' exists, but is inaccessible"
2244	"'%Fs' : unable to resolve function overload"
2245	"nonexistent function '%Fs' specified as friend"
2246	"'%Fs' : illegal static data member in locally defined class"
2247	"'%Fs' not accessible because '%Fs' uses '%Fs' to inherit from '%Fs'"
2248	"'%Fs' : cannot access %Fs %Fs declared in class '%Fs'"
2249	"'%Fs' : no accessible path to %Fs %Fs declared in virtual base '%Fs'"
2250	"'%Fs' : ambiguous inheritance of '%Fs::%Fs'"
2251	"'%Fs' : defined but not declared"
2252	"'%Fs' : pure specifier can only be specified for functions"
2253	"'%Fs' : pure specifier only applies to virtual function - specifier ignored"
2254	"'%Fs' : pure specifier not allowed on friend functions"
2255	"'%Fs' : a friend function can only be declared in a class"
2256	"illegal use of friend specifier on '%Fs'"
2257	"p-code generation pragma not allowed without /Oq"
2258	"illegal pure syntax, must be '= 0'"
2259	"'%Fs' : illegal attempt to instantiate abstract class"
2260	"function pointer cast to a data pointer"
2261	"data pointer cast to a function pointer"
2262	"'%Fs' : cannot be destroyed"
2263	"function returns pointer based on __self"
2264	"'%Fs' : error in function definition or declaration; function not called"
2265	"'%Fs' : reference to a zero-sized array is illegal"
2266	"'%Fs' : reference to a nonconstant bounded array is illegal"
2267	"'%Fs' : static functions with block scope are illegal"
2268	"'%Fs' : different const or volatile qualifiers"
2269	"'%Fs' : different ambient model than base class '%Fs'"
2270	"'%Fs' : modifiers not allowed on nonmember functions"
2271	"'%Fs' : new/delete cannot have formal list modifiers"
2272	"'%Fs' : modifiers not allowed on static member functions"
2273	"'%Fs' : illegal as right side of '->' operator"
2274	"'%Fs' : illegal as right side of '.' operator"
2275	"'%Fs' : illegal use of this type as an expression"
2276	"'%Fs' : illegal operation on bound member function expression"
2277	"'%Fs' : cannot take the address of a constructor"
2278	"'%Fs' : no function with C linkage found"
2279	"cannot use braces to initialize default arguments"
2280	"missing '{' before identifier '%Fs'?"
2281	"'%Fs' : is not a function, but contains <function returning>; '%Fs' is unexpected"
2282	"'%Fs' is followed by '%Fs' (missing ','?)"
2283	"'%Fs' : pure specifier not allowed on unnamed %Fs"
2284	"unbalanced parenthesis found while processing a member function"
2285	"pointers to members representation has already been determined - pragma ignored"
2286	"pointers to members of '%Fs' representation is already set to %s inheritance - declaration ignored"
2287	"'%Fs': inheritance representation: '%Fs' is less general than the required '%Fs'"
2288	"typedef has a trailing __based which cannot be applied to the symbol's indirection"
2289	"same type qualifier used more than once"
2290	"C++ '%Fs' syntax is reserved for future use"
2291	"'%Fs' : illegal modifier '%Fs' for 'this' pointer"
2292	"'%Fs': best case inheritance representation: '%Fs' declared but '%Fs' required"
2293	"'%Fs': illegal to have a non-static member variable as a __based specifier"

2300	"'%Fs' : class does not have a destructor called '~%Fs'"
2301	"left of '->~%Fs' must point to class/struct/union"
2302	"left of '.~%Fs' must have class/struct/union type"

2350	"'%Fs' is not a static member"
2351	"obsolete C++ constructor initialization syntax"
2352	"'%Fs::%Fs' : illegal call of nonstatic member function"
2353	"'%Fs' : improper use of constructor initializers"
2354	"'%Fs' : initialization of reference member requires a temporary variable"
2355	"'this' : can only be referenced inside nonstatic member functions"
2356	"initialization segment must not change during translation unit"

2360	"initialization of '%Fs' is skipped by 'case' label"
2361	"initialization of '%Fs' is skipped by 'default' label"
2362	"initialization of '%Fs' is skipped by 'goto %Fs'"

2369	"'%Fs' : redefinition; different subscripts"
2370	"'%Fs' : redefinition; different storage class"
2371	"'%Fs' : redefinition; different basic types"
2372	"'%Fs' : redefinition; different types of indirection"
2373	"'%Fs' : redefinition; different type modifiers"
2374	"'%Fs' : redefinition; multiple initialization"
2375	"'%Fs' : redefinition; different linkage"
2376	"'%Fs' : redefinition; different based allocation"
2377	"'%Fs' : redefinition; typedef cannot be overloaded with any other symbol"
2378	"'%Fs' : redefinition; symbol cannot be overloaded with a typedef"
2379	"formal parameter %d has different type when promoted"
2380	"type[s] preceding '%Fs' (constructor with return type, or illegal redefinition of current class-name?)"

2385	"'%Fs::%Fs' is ambiguous"
2386	"ambiguous conversion from '%Fs*' to '%Fs*'"
2387	"ambiguous conversion from '%Fs&' to '%Fs&'"

2390	"'%Fs' : incorrect storage class '%Fs'"
2391	"'%Fs' : 'friend' cannot be used during type definition"

2400	"inline syntax error in '%Fs'; found '%Fs'"
2401	"'%Fs' : register must be base in '%Fs'"
2402	"'%Fs' : register must be index in '%Fs'"
2403	"'%Fs' : register must be base/index in '%Fs'"
2404	"'%Fs' : illegal register in '%Fs'"
2405	"illegal short forward reference with offset"
2406	"'%Fs' : name undefined in '%Fs'"
2407	"illegal 'float' register in '%Fs'"
2408	"illegal type on PTR operator in '%Fs'"
2409	"illegal type used as operator in '%s'"
2410	"'%Fs' : ambiguous member name in '%Fs'"
2411	"'%Fs' : illegal struct/union member in '%Fs'"
2412	"'%Fs' : case-insensitive label redefined"
2413	"'%Fs' : illegal align size"
2414	"illegal number of operands"
2415	"improper operand type"
2416	"'%Fs' : illegal opcode for processor"
2417	"divide by zero in '%Fs'"
2418	"'%Fs' : not in a register"
2419	"mod by zero in '%Fs'"
2420	"'%Fs' : illegal symbol in %Fs"
2421	"PTR operator used with register in '%Fs'"
2422	"illegal segment override in '%Fs'"
2423	"'%ld' : illegal scale"
2424	"'%Fs' : improper expression in '%Fs'"
2425	"'%Fs' : nonconstant expression in '%Fs'"
2426	"'%Fs' : illegal operator in '%Fs'"
2427	"'%Fs' : jump referencing label is out of range"	

2429	"'%Fs' : illegal far label reference"
2430	"more than one index register in '%Fs'"
2431	"illegal index register in '%Fs'"
2432	"illegal reference to 16-bit data in '%Fs'"
2433	"'%Fs' : '%Fs' not permitted on data declarations"
2434	"'%Fs' : cannot convert default argument from '%Fs' to '%Fs'"
2435	"'%Fs' : function called before default arguments were resolved"
2436	"'%Fs' : cannot initialize member functions"
2437	"'%Fs' : already initialized"
2438	"'%Fs' : cannot initialize static class data via constructor"
2439	"'%Fs' : member could not be initialized"
2440	"'%Fs' : cannot convert from '%Fs' to '%Fs'"
2441	"function call through pointer before default arguments were resolved"
2442	"p-code expression too complex for setjmp or Catch"
2443	"operand size conflict"

2446	"'%Fs' : no conversion from '%Fs' to '%Fs'"
2447	"missing function header (old-style formal list?)"
2448	"'%Fs' : function-style initializer appears to be a function definition"
2449	"found '{' at file scope (missing function header?)"
2450	"switch expression of type '%Fs' is illegal"
2451	"conditional expression of type '%Fs' is illegal"
2452	"array bound expression of type '%Fs' is illegal"
2453	"array bound expression uses function name"

2458	"'%Fs' : redefinition within definition"
2459	"'%Fs' : is being defined; cannot add as an anonymous member"
2460	"'%Fs' : uses '%Fs', which is being defined"
2461	"'%Fs' : constructor syntax missing formal parameters"
2462	"'%Fs' : cannot define a type in a 'new-expression'"
2463	"cannot define an anonymous type in a 'new-expression'"
2464	"'%Fs' : cannot use 'new' to allocate a reference"
2465	"cannot define an anonymous type inside parentheses"
2466	"cannot allocate an array of constant size 0"
2467	"illegal declaration of anonymous '%Fs'"
2468	"'new' : cannot allocate 'const'/'volatile' objects (type is '%Fs')"
2470	"cannot open database '%Fs'"
2471	"cannot update database '%Fs'"

2500	"'%Fs' : '%Fs' is already a direct base class"
2501	"'%Fs' : missing decl-specifiers"
2502	"'%Fs' : too many access modifiers on the base class"
2503	"'%Fs' : base classes cannot contain zero-sized arrays"
2504	"'%Fs' : base class undefined"
2505	"'%Fs' : is not a legal base class"
2506	"'%Fs' : ambiguous"
2507	"'%Fs' : too many virtual modifiers on the base class"
2508	"'%Fs' : access denied"
2509	"'%Fs' : member function not declared in '%Fs'"
2510	"'%Fs' : left of '::' must be a class/struct/union"
2511	"'%Fs' : overloaded member function not found in '%Fs'"
2512	"'%Fs' : no appropriate default constructor available"
2513	"'%Fs' : decl-specifier is missing a declarator before '='"
2514	"'%Fs' : class has no constructors"
2515	"'%Fs' : not in class '%Fs'"

2517	"'%Fs' : right of '::' is undefined"

2519	"cannot convert '%Fs *' to '%Fs *'"

2523	"'%Fs::~%Fs' : destructor tag mismatch"
2524	"'%Fs' : destructors must have a 'void' formal parameter list"
2525	"'%Fs' : explicit destructor is named but not called"

2527	"'%Fs' : array of references must be fully initialized"
2528	"illegal pointer to reference"
2529	"illegal reference to a reference"
2530	"'%Fs' : references must be initialized"
2531	"'%Fs' : reference to a bit field illegal"
2532	"'%s' : cannot modify references"
2533	"'%Fs' : constructors not allowed a return type"
2534	"'%Fs' : constructor cannot return a value"
2535	"'%Fs' : member function already defined or declared"
2536	"'%Fs::%Fs' : cannot specify explicit initializer for arrays"
2537	"'%Fs' : illegal linkage specification"
2538	"new : cannot specify initializer for arrays"
2539	"new : '%Fs' no default constructor to initialize arrays of objects"
2540	"nonconstant expression as array bound"
2541	"delete : cannot delete objects that are not pointers"
2542	"'%Fs' : class object has no constructor for initialization"
2543	"expected ']' for operator '[]'"
2544	"expected ')' for operator '()'"
2545	"'%Fs' : unable to find overloaded operator"
2546	"'%Fs' : illegal mix of 'void' pointer with pointer to type"
2547	"illegal cast of overloaded function"
2548	"'%Fs' : missing default parameter for parameter %s"
2549	"user-defined conversion cannot specify a return type"
2550	"'%Fs' : constructor initializer lists are only allowed on constructor definitions"
2551	"'void *' type needs explicit cast"
2552	"'%Fs' : nonaggregates cannot be initialized with initializer list"
2553	"no legal conversion of return value to return type '%Fs'"
2555	"'%Fs::%Fs' : overriding virtual function differs from '%Fs::%Fs' only by return type"
2556	"'%Fs' : overloaded functions only differ by return type"
2557	"'%Fs' : private and protected members cannot be initialized without a constructor"
2558	"'%Fs' : no copy constructor available"
2559	"'%Fs' : no match for specified operator"
2560	"'%Fs' : overloaded function differs only by calling convention/memory model"
2561	"'%Fs' : function must return a value"
2562	"'%Fs' : 'void' function returning a value"
2563	"mismatch in formal parameter list"
2564	"formal/actual parameters mismatch in call through pointer to function"
2565	"'::%Fs' was previously declared as a global function"
2566	"overloaded function in conditional expression"
2567	"'%Fs' : intrinsic function must have prototypes when using C++"
2568	"'%Fs' : unable to resolve function overload '%Fs'"
2569	"'%Fs' : union cannot be used as a base class"
2570	"'%Fs' : union cannot have base classes"
2571	"'%Fs' : union cannot have virtual function '%Fs'"
2572	"'%Fs' : redefinition of default parameter : parameter %s"
2573	"'%Fs' : simple type cast must have exactly one expression"
2574	"'%Fs' : illegal static destructor declaration"
2575	"'%Fs' : only member functions and bases can be virtual"
2576	"'%Fs' : virtual used for static member function"
2577	"'%Fs' : destructor cannot return a value"

2579	"'%Fs::%Fs(%s)' : parameter list not sufficiently different to '%Fs::%Fs(%s)'"
2580	"redefinition of class name '%Fs'"
2581	"'%Fs' : static 'operator =' function is illegal"
2582	"'%Fs' : 'operator =' function is unavailable"
2583	"'%Fs' : illegal const/volatile 'this' pointer used for constructors/destructors"
2584	"'%Fs' : direct base '%Fs' is inaccessible; already a base of '%Fs'"
2585	"explicit conversion to '%Fs' is ambiguous"
2586	"incorrect user-defined conversion syntax : illegal indirections"
2587	"'%Fs' : illegal use of local variable as default parameter"
2588	"'::~%Fs' : illegal global destructor"
2589	"'%Fs' : illegal token on right side of '::'"
2590	"'%Fs' : ambiguous user-defined conversions in switch expression"
2591	"'%Fs' : ambiguous user-defined conversions in conditional expression"
2592	"no legal conversion of initialization expression to type '%Fs'"
2593	"'operator %Fs' is ambiguous"
2594	"'%Fs' : ambiguous conversions from '%Fs' to '%Fs'"
2595	"'%Fs' : qualified name already has a constructor"
2596	"'%Fs' : qualified name already has a destructor"
2597	"'%Fs' : does not specify an object"
2598	"linkage specification must be at global scope"
2599	"'%Fs' : local functions are not supported"
2601	"functions cannot be defined in local classes"
2602	"'%Fs::%Fs' is not a member of a base of '%Fs'"
2603	"illegal access declaration: '%Fs' is not a direct base of '%Fs'"
2604	"cannot declare %Fs access to %Fs member '%Fs::%Fs'"
2605	"overloaded functions '%Fs::%Fs' do not have same access"
2606	"'%Fs::%Fs': illegal private access declaration"
2607	"'%Fs' : cannot implicitly convert a '%Fs' to a '%Fs' that is not const"
2608	"illegal reference cast - operand not an l-value"
2609	"'%Fs' : cannot implicitly convert a non-lvalue '%Fs' function return to a '%Fs' that is not const"
2610	"%Fs '%Fs' can never be instantiated; user-defined constructor is required"
2611	"'%Fs' : illegal following '~' (expected identifier)"
2612	"trailing '%Fs' illegal in base/member initializer list"
2613	"trailing '%Fs' illegal in base class list"
2614	"'%Fs' : illegal member initialization: '%Fs' is not a base or member"
2615	"memory attribute must appear before class name in pointer to member"
2617	"'%Fs' : inconsistent return statement"
2618	"'%Fs' : inconsistent return statement"
2619	"union '%Fs' : cannot have static member variable '%Fs'"
2620	"union '%Fs' : member '%Fs' has default constructor"
2621	"union '%Fs' : member '%Fs' has copy constructor"
2622	"union '%Fs' : member '%Fs' has assignment operator"
2623	"union '%Fs' : member '%Fs' has destructor"
2624	"'%Fs' : references to 'void' are illegal"
2625	"anonymous union did not declare any data members"
2626	"anonymous union defines %Fs member '%Fs'"
2627	"member function defined in unnamed class"
2628	"'%Fs' followed by '%Fs' is illegal (did you forget a ';'?)"
2629	"unexpected '%s ('"
2630	"'%Fs' found in what should be a comma-separated list"
2631	"'%Fs' : destructors not allowed a return type"
2632	"'%Fs' followed by '%Fs' is illegal"
2633	"'%Fs' : 'inline' is the only legal storage class for constructors"
2634	"'&%Fs::%Fs' : pointer to reference member is illegal"
2635	"cannot convert a '%Fs*' to a '%Fs*'; conversion from a virtual base class is implied"
2636	"pointer to reference member is illegal"
2637	"'%s' : cannot modify pointers to data members"
2638	"'%Fs' : memory model modifier illegal on pointer to data member"
2639	"compiler generated %Fs required by unnamed class"

2641	"illegal pointer to member cast across virtual inheritance path"
2642	"cast to pointer to member must be from related pointer to member"
2643	"illegal cast from pointer to member"
2644	"basis class '%Fs' for pointer to member has not been defined"
2645	"no qualified name for pointer to member (found ':: *')"
2646	"global anonymous unions must be declared static"
2647	"'%Fs' : cannot dereference a '%Fs' on a '%Fs'"
2648	"'%Fs' : use of member as default parameter requires static member"
2649	"'%Fs' : is not a '%Fs'"
2650	"'%Fs' : cannot be a virtual function"

2652	"'%Fs' : illegal copy constructor: first parameter must not be a '%Fs'"
2653	"'%Fs' : is not a class name"
2654	"'%Fs' : attempt to access member outside a member function"
2655	"'%Fs' : definition or redeclaration illegal in current scope"
2656	"'%Fs' : function not allowed as a bit field"
2657	"'%Fs::*' found at the start of a statement (did you forget to specify a type?)"
2658	"multiple conversions : %Fs(%Fs) and %Fs::operator %Fs()"
2659	"'%Fs' : overloaded function as left operand"
2660	"'%Fs' : function does not take %d parameters"
2661	"'%Fs' : no overloaded function takes %d parameters"
2662	"'%Fs' : cannot convert 'this' pointer from '%Fs' to '%Fs'"
2663	"'%Fs' : %d overloads have no legal conversion for 'this' pointer"
2664	"'%Fs' : cannot convert parameter %d from '%Fs' to '%Fs'"
2665	"'%Fs' : %d overloads have no legal conversion for parameter %d"
2666	"'%Fs' : %d overloads have similar conversions"
2667	"'%Fs' : none of %d overload have a best conversion"
2668	"'%Fs' : ambiguous call to overloaded function"

2671	"'%Fs' : static member functions do not have 'this' pointers"
2672	"'%Fs' : new/delete member functions do not have 'this' pointers"
2673	"'%Fs' : global functions do not have 'this' pointers"
2674	"'%Fs' : no acceptable conversions from '%Fs' to '%Fs'"
2675	"unary '%Fs' : '%Fs' does not define this operator or a conversion to a type acceptable to the predefined operator"
2676	"binary '%Fs' : '%Fs' does not define this operator or a conversion to a type acceptable to the predefined operator"
2677	"binary '%Fs' : no global operator defined which takes type '%Fs' (or there is no acceptable conversion)"

2701	"'%Fs' : __oldcall function defined with varargs"	
2702	" __try may not appear in termination block"	
2703	"illegal __leave statement"
2704	"'%Fs' : __va_start intrinsic only allowed in varargs"	
2705	"'%Fs' : illegal jump into __try scope"	

2707	"'%Fs' : bad context for intrinsic function"	
2708	"'%Fs' : actual parameters length in bytes differs from previous call or reference"
2709	"'%Fs' : formal parameters length in bytes differs from previous declaration"
2710	"cannot delete a pointer to a const object"
2711	"cannot delete a pointer to a function"

2720	"'%Fs' : '%Fs' storage-class specifier illegal on members"
2721	"'%Fs' : storage-class specifier illegal between operator keyword and type"
2722	"'::%Fs' : illegal following operator command; use 'operator %Fs'"
2723	"'%Fs' : '%Fs' storage-class specifier illegal on function definition"
2724	"'%Fs' : 'static' should not be used on member functions defined at file scope"

2730	"'%Fs' : cannot be a base class of itself"
2731	"'%Fs' : function cannot be overloaded"
2732	"linkage specification contradicts earlier specification for %Fs"
2733	"second C linkage of overloaded function '%Fs' not allowed"
2734	"'%Fs' : const object must be initialized if not extern"
2735	"'%Fs' keyword is not permitted in formal parameter type specifier"
2736	"'%Fs' keyword is not permitted in cast"
2737	"'%Fs' : base class '%Fs' must be exported"

2750	"'%Fs' : 'const T' to 'T' : '%Fs' to '%Fs'"
2751	"'%Fs' : 'volatile T' to 'T' : '%Fs' to '%Fs'"
2752	"'%Fs' : 'const T *' to 'T *' : '%Fs' to '%Fs'"
2753	"'%Fs' : 'volatile T *' to 'T *' : '%Fs' to '%Fs'"
2754	"'%Fs' : 'const T **' to 'T **' : '%Fs' to '%Fs'"
2755	"'%Fs' : 'volatile T **' to 'T **' : '%Fs' to '%Fs'"
2756	"'%Fs' : 'memory model mismatch' : '%Fs' to '%Fs'"
2757	"'%Fs' : 'language modifier mismatch: '%Fs' to '%Fs'"
2758	"'%Fs' : must be initialized in constructor base/member initializer list"

2800	"'operator %Fs' cannot be overloaded"
2801	"'operator %Fs' must be a %Fs member"
2802	"static member 'operator %Fs' has no formal parameters"
2803	"'operator %Fs' must have at least one formal parameter of class type"
2804	"binary 'operator %Fs' has too many parameters"
2805	"binary 'operator %Fs' has too few parameters"
2806	"'operator %Fs' has too many formal parameters"
2807	"the second formal parameter to postfix 'operator %Fs' must be 'int'"
2808	"unary 'operator %Fs' has too many formal parameters"
2809	"'operator %Fs' has no formal parameters"
2810	"second formal parameter for 'operator delete' must be 'unsigned int'"
2811	"too many formal parameters for based form of 'operator delete'"
2812	"second formal parameter required for based form of 'operator delete'"
2813	"too many formal parameters for 'operator delete'"
2814	"second actual parameter for based form of 'operator delete' must be '__based(void)*'"
2815	"first actual parameter for based form of 'operator delete' must be '__segment'"
2816	"alternative form of 'operator delete' must be a member"
2817	"return type for 'operator delete' must be 'void'"
2818	"incorrect return type for 'operator ->'"
2819	"recursive return type for 'operator ->'"
2820	"second formal parameter required for based form of 'operator new'"
2821	"first formal parameter to 'operator new' must be 'unsigned int'"
2822	"second formal parameter for huge form of 'operator new' must be 'unsigned int'"
2823	"return type for based form of 'operator new' must be 'void __based(void)*'"
2824	"return type for 'operator new' must be 'void *'"
2825	"first formal parameter for huge form of 'operator new' must be 'unsigned long'"
2826	"second formal parameter required for huge form of 'operator new'"
2827	"'operator %s' cannot be globally overridden with unary form"
2828	"'operator %s' cannot be globally overridden with binary form"
2829	"'operator %Fs' cannot have a variable parameter list"
2830	"only placement parameters to 'operator new' can have default values"
2831	"'operator %Fs' cannot have default parameters"
2832	"'%Fs' form of 'operator %Fs' cannot be a member"
2833	"'operator %Fs' is not a recognized operator or type"
2834	"'operator %Fs' must be globally qualified"
2835	"user-defined conversion '%Fs' takes no formal parameters"
2836	"cannot export '%Fs': a previous declaration did not export it"
2837	"'%Fs' : illegal local static variable in exported inline function"
2838	"illegal qualified name in member declaration"

2850	"#pragma hdrstop cannot be nested in a function or definition"
2851	"#pragma hdrstop required for /Yu command-line option without filename"
2852	"'%Fs' is not a valid precompiled header file"
2853	"'%Fs' is not a precompiled header file created with this compiler"
2854	"syntax error in #pragma hdrstop"
2855	"command-line option '%Fs' inconsistent with precompiled header"
2856	"#pragma hdrstop cannot be inside an #if block"
2857	"'#include' statement specified with the /Yc%Fs command-line option was not found in the source file"

2900	"'%Fs' : huge array cannot be aligned to segment boundary"

2910	"cannot call function from p-code with more than 255 bytes of arguments"
2911	"cannot define p-code function with more than 255 bytes of parameters"

2000	"UNKNOWN ERROR\n\t\tContact Microsoft Product Support Services"

		

1001	"internal compiler error\n\t\t(compiler file '%s', line %d)"

1003	"error count exceeds %d; stopping compilation"
1004	"unexpected end of file found"
1005	"string too big for buffer"
1006	"write error on compiler-generated file"
1007	"unrecognized flag '%Fs' in '%Fs'"
1008	"no input file specified"
1009	"compiler limit : macros nested too deeply"
1010	"unexpected end of file while looking for precompiled header directive"
1011	"compiler limit : '%Fs' : macro definition too big"
1012	"unmatched parenthesis : missing '%c'"
1013	"compiler limit : too many open parentheses"
1014	"too many include files : depth = %d"
1015	"compiler limit : too many segments"
1016	"#if[n]def expected an identifier"
1017	"invalid integer constant expression"
1018	"unexpected #elif"
1019	"unexpected #else"
1020	"unexpected #endif"
1021	"invalid preprocessor command '%Fs'"
1022	"expected #endif"
1023	"cannot open source file '%Fs'"
1024	"cannot open include file '%Fs'"
1025	"compiler terminated by user"	
1026	"parser stack overflow, program too complex"
1027	"DGROUP data allocation exceeds 64K"	
1028	"'%s' : segment allocation exceeds 64K" 
1029	"there are more than 512 bytes of arguments"
1030	"there are more than 512 bytes of local variables"
1031	"compiler limit : function calls nested too deeply"	
1032	"cannot open object code listing file '%s'"	

1034	"%Fs: no include path set"
1035	"expression too complex; simplify expression"	

1037	"cannot open object file '%s'"	
1038	"compiler limit : '%Fs' : control flow state too complex; simplify function"

1041	"cannot open compiler intermediate file - no more files"
1042	"cannot open compiler intermediate file - no such file or directory"
1043	"cannot open compiler intermediate file"
1044	"out of disk space for compiler intermediate file"
1045	"compiler limit : linkage specifications nested too deeply"
1046	"compiler limit : %Fs nested too deeply"
1047	"limit of %Fs exceeded at '%Fs'"
1048	"unknown option '%c' in '%s'"
1049	"invalid numerical argument '%s'"
1050	"'%Fs' : code segment too large"

1052	"compiler limit : #if or #ifdef blocks nested too deeply"
1053	"compiler limit : struct/union nested too deeply"	
1054	"compiler limit : initializers nested too deeply"
1055	"compiler limit : out of keys"
1056	"compiler limit : out of macro expansion space"
1057	"unexpected end of file in macro expansion"
1058	"compiler limit : too many formal arguments"
1059	"compiler is out of near heap space"
1060	"compiler is out of far heap space"
1061	"compiler limit : blocks nested too deeply"	
1062	"error while writing to preprocessor output file"
1063	"compiler limit : compiler stack overflow"
1064	"compiler limit : token overflowed internal buffer"
1065	"compiler limit : out of tags"
1066	"compiler limit : decorated name length exceeded"

1068	"cannot open file '%Fs'"
1069	"write error on file '%s'"	
1070	"mismatched #if/#endif pair in file '%Fs'"
1071	"unexpected end of file found in comment"
1072	"'%Fs' : cannot read file"

1082	"Cannot close %Fs file: '%Fs': %Fs (%Fs:%ld)"
1083	"Cannot open %Fs file: '%Fs': %Fs"
1084	"Cannot read %Fs file: '%Fs': %Fs"
1085	"Cannot write %Fs file: '%Fs': %Fs (%Fs:%ld)"
1086	"Cannot seek %Fs file: '%Fs': %Fs (%Fs:%ld)"
1087	"Cannot tell %Fs file: '%Fs': %Fs (%Fs:%ld)"
1088	"Cannot flush %Fs file: '%Fs': %Fs (%Fs:%ld)"

1090	"data allocation exceeds 64K"		

1126	"'%Fs' : automatic allocation exceeds %s" 
1127	"'%Fs' : segment redefinition"

1500	"'%Fs' : cannot open inline function definition file"
1501	"compiler limit : too many temporary variables"
1502	"inline member-function definition missing '}'"
1503	"default parameter definition missing ',' or ')'"
1504	"type still ambiguous after parsing %d tokens, unable to recover"
1505	"unrecoverable parser look-ahead error"
1506	"unrecoverable block scoping error"
1507	"previous user errors and subsequent error recovery halt further compilation"

1700	"%Fs compiler is out of far heap space" 

1852	"'%Fs' is not a valid precompiled header file"
1853	"'%Fs' is not a precompiled header file created with this compiler"
1855	 "command-line option '%Fs' inconsistent with precompiled header"

1900	"Il mismatch between '%s' version '%ld' and '%s' version '%ld'"
1000	"UNKNOWN FATAL ERROR\n\t\tContact Microsoft Product Support Services"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\sdktools\msvc15\bin\stress.ini ===
[STRESS]
; Initialization file for Stress.exe.  Must live in Windows directory to be
; have it's setting take affect. All settings (and ini file) are optional.
; For more information see the on-line Stress help file.

; Fixed settings, if ALLOCATIONS=Fixed set
GLOBAL=1500
USER=500
GDI=500
DISK=5
HANDLES=2

; Fixed or Random
ALLOCATIONS=random

; 1 - 4
STRESS_LEVEL=1

; Any #
SEED=17890

; disk gdi user kernel handles
RESOURCES=disk gdi user kernel handles

; 1 - 120 
TIME_INTERVAL=2

; Messages: WM_KEYUP, WM_KEYDOWN, WM_SYSKEYUP, WM_SYSKEYDOWN, WM_CHAR,  ; WM_LBUTTONDOWN, WM_LBUTTONUP, WM_LBUTTONDBLCLK, WM_RBUTTONDOWN, ;WM_RBUTTONUP, WM_RBUTTONDBLCLK, 
MESSAGE=WM_LBUTTONDOWN

; Filename or filename with path
FILENAME=c:\win31\mystress.log

; Log to a file? yes or no
FILE_ON=yes

; 1 - 4
COM=1

; yes or no
EXECUTER_ON=no

; Stress Levels for Executor mode: 
; LEVELn=GlobalMin GlobalMax UserMin UserMax GDIMin GDIMax DiskMin DiskMax FilesMin 
; FilesMax.  Disk is in Mb. Everything else in bytes. 
LEVEL1=0 1500 0 500 0 500 0 1 0 1
LEVEL2=0 2000 0 1000 0 1000 0 1 0 2
LEVEL3=100 10000 100 8000 100 8000 0 1 0 3
LEVEL4=500 32000 500 16000 500 16000 0 1 0 4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\publicnt4\placefil.txt ===
FXSAPI.DLL  faxclients\NT4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\client\ism\eula.rtf ===
{\rtf1\fbidis\ansi\ansicpg1252\deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}} {\stylesheet{ Normal;}{\s1 heading 1;}} \viewkind4\uc1\pard\ltrpar\qc\ul\b\f0\fs44\par \pard\ltrpar\keepn\s1\qc This is the EULA place holder\par \pard\ltrpar\qc\fs24\par Do check in this files as well\par CLIENT\par
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\setup\client\msi\fxssetu_.ini ===
[Info]
Name=INTL
Version=1.00.000
DiskSpace=8000	;DiskSpace requirement in KB

[Startup]
CmdLine=
Product=fxsclnt
PackageName=fxsclnt.msi
MsiVersion=1.20.1827.0
EnableLangDlg=N
SuppressWin2k=Y

[0x0409]
TITLE=Choose Setup Language
DESCRIPTION=Select the language for this installation from the choices below.
OK=OK
Cancel=Cancel
1100=Setup Initialization Error
1101=InstallShield Wizard
1102=%s Setup is preparing the InstallShield Wizard which will guide you through the program setup process.  Please wait.
1103=Checking Operating System Version
1104=Checking Windows(R) Installer Version
1105=Configuring Windows Installer
1106=Configuring InstallShield
1107=Setup has completed configuring the Windows Installer on your system. The system needs to be restarted in order to continue with the installation. Please click Restart to reboot the system.
1108=InstallShield
1150=Setup has detected an incompatible version of\nWindows. Please click OK and relaunch setup on\nWindows 95, Windows NT 4.0, or later
1151=Error writing to the temporary location
1152=Error extracting %s to the temporary location
1153=Error reading setup initialization file
1154=Installer not found in %s
1155=File %s not found
1156=Internal error in Windows Installer
1200=Restart
1603=General Windows Installer engine error. Increase DiskSpace requirement in Setup.ini and try again.
1201=Setup needs %lu KB free disk space in %s. Please free up some space and try again
1202=You do not have sufficient privileges to complete this installation for all users of the machine. Log on as administrator and then retry this installation
1203=Command line parameters:
1204=/L language ID
1205=/S silent mode
1206=/V parameters to MsiExec.exe
1207=Windows(R) Installer %s found. This is an older version of the Windows(R) Installer. Click OK to continue.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=This setup does not contain the Windows Installer engine (%s) required to run the installation on this operating system.

[0x0407]
TITLE=Whlen Sie eine Setup-Sprache aus
DESCRIPTION=Whlen Sie die Sprache dieser Installation aus der unten aufgefhrten Auswahl aus.
OK=OK
Cancel=Abbrechen
1100=Setup-Initialisierungsfehler
1101=InstallShield Wizard
1102=%s Setup bereitet den InstallShield Wizard vor, der Sie durch den Setup-Vorgang leiten wird. Bitte warten.
1103=berprfen der Betriebssystemversion
1104=berprfen der Version von Windows(R) Installer
1105=Konfigurieren von Windows Installer
1106=Konfigurieren von InstallShield
1107=Setup hat die Konfiguration von Windows Installer auf Ihrem Computer abgeschlossen. Um mit der Installation fortzufahren mu das System neu gestartet werden. Whlen Sie Neustarten, um Ihr System neu zu starten.
1108=InstallShield
1150=Setup hat eine inkompatible Version von Windows\nentdeckt. Klicken Sie auf OK und fhren Sie Setup\nauf Windows 95, Windows NT 4.0 oder hher aus.
1151=Fehler beim Schreiben in das temporre Verzeichnis
1152=Fehler beim Entpacken von %s in das temporre Verzeichnis
1153=Fehler beim Lesen der Setup-Initialisierungsdatei
1154=Installer in %s wurde nicht gefunden
1155=Datei %s wurde nicht gefunden
1156=Interner Fehler in Windows Installer
1200=Starten Sie erneut
1603=Allgemeiner Fehler in Windows Installer Engine. Erhhen Sie den Wert von DiskSpace in Setup.ini und versuchen Sie es erneut.
1201=Setup bentigt %lu kB freien Speicherplatz auf %s. Stellen Sie mehr Platz zur Verfgung und versuchen Sie es erneut.
1202=Sie besitzen keine ausreichenden Berechtigungen, um diese Installation fr alle Benutzer dieses Computers auszufhren. Melden Sie sich als Administrator an, und wiederholen Sie diese Installation.
1203=Parameter der Befehlszeile:
1204=/L Sprach-ID
1205=/S Silent Mode
1206=/V Parameter fr MsiExec.exe
1207=Windows(R) Installer %s wurde gefunden. Dies ist eine ltere Version von Windows(R) Installer. Klicken Sie auf OK, um fortzufahren.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Dieses Setup enthlt nicht die Windows Installer-Engine (%s ), die zum Ausfhren der Installation auf diesem Betriebssystem erforderlich ist.

[0x040c]
TITLE=Choisissez la langue d'installation
DESCRIPTION=Choisissez la langue d'installation dans la liste ci-dessous.
OK=OK
Cancel=Annuler
1100=Erreur lors de l'initialisation de l'installation
1101=InstallShield Wizard
1102=L'installation %s prpare InstallShield Wizard, lequel vous guidera pour l'installation du logiciel. Veuillez patienter.
1103=Vrification de la version de systme d'exploitation
1104=Vrification de la version de Windows(R) Installer
1105=Configuration de Windows(R) Installer
1106=Configuration d'InstallShield
1107=L'installation a termin la configuration de Windows Installer sur votre ordinateur. Pour pouvoir poursuivre l'installation, le systme doit tre redmarr. Veuillez cliquer sur Redmarrer pour rinitialiser le systme.
1108=InstallShield
1150=L'installation a dcel une version de\nWindows incompatible. Veuillez cliquer sur OK et relancer l'installation sur\nWindows 95, Windows NT 4.0, ou toute autre version de Windows ultrieure.
1151=Erreur lors de l'criture vers l'emplacement temporaire
1152=Erreur lors de l'extraction %s vers l'emplacement temporaire
1153=Erreur lors de la lecture du fichier d'initialisation de l'installation
1154=Programme d'installation introuvable dans %s
1155=Fichier %s introuvable
1156=Erreur interne dans Windows Installer.
1200=Redmarrer
1603=Erreur gnrale du moteur de Windows Installer. Augmentez la valeur de l'espace disque ncessaire dans Setup.ini et ressayez.
1201=Le programme d'installation ncessite %lu ko d'espace disque libre dans %s. Veuillez librer de l'espace et ressayer.
1202=Vous ne possdez pas les privilges ncessaires pour terminer cette installation pour tous les utilisateurs de l'ordinateur. Ouvrez une session en tant qu'administrateur puis ressayez cette installation.
1203=Paramtres de ligne de commande :
1204=/L Identification de langue
1205=/S mode silencieux
1206=/V paramtres  MsiExec.exe
1207=Windows(R) Installer %s trouv. Ceci est une ancienne version de Windows(R) Installer. Cliquez sur OK pour continuer.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Cette configuration ne contient pas le moteur (%s) requis de Windows Installer pour excuter l'installation sur ce systme d'exploitation.

[0x0410]
TITLE=Seleziona la lingua dell'installazione
DESCRIPTION=Selezionare la lingua per questa installazione tra le opzioni indicate di seguito.
OK=OK
Cancel=Annulla
1100=Errore di inizializzazione dell'installazione
1101=InstallShield Wizard
1102=Il programma di installazione %s sta preparando InstallShield Wizard.  Attendere.
1103=Verifica della versione del sistema operativo in corso
1104=Verifica della versione di Windows(R) Installer in corso
1105=Configurazione di Windows Installer in corso
1106=Configurazione di InstallShield in corso
1107=Il programma di installazione ha completato la configurazione di Windows Installer sul sistema. Riavviare il sistema per continuare. Scegliere Riavvia per riavviare il sistema.
1108=InstallShield
1150= stata rilevata una versione incompatibile di\nWindows. Scegliere OK e riavviare l'installazione su\nWindows 95, Windows NT 4.0 o una versione successiva
1151=Errore durante la scrittura nella posizione temporanea
1152=Errore durante l'estrazione di %s nella posizione temporanea
1153=Errore durante la lettura dei file di inizializzazione dell'installazione
1154=Installer non trovato in %s
1155=File %s non trovato
1156=Errore interno di Windows Installer
1200=Riavvia
1603=Errore generale del modulo Windows Installer. Aumentare il requisito di spazio su disco (DiskSpace) in Setup.ini e riprovare.
1201=Per l'installazione occorrono %lu KB di spazio su disco in %s. Liberare dello spazio e riprovare.
1202=I privilegi di cui si dispone non sono sufficienti per completare questa installazione per tutti gli utenti del computer. Eseguire l'accesso come amministratore e riprovare ad eseguire l'installazione
1203=Parametri della riga di comando:
1204=/L ID lingua
1205=/S Modalit invisibile all'utente
1206=/V parametri per MsiExec.exe
1207= stato rilevato Windows(R) Installer %s.  una versione precedente di Windows(R) Installer. Scegliere OK per continuare.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Questo programma di installazione non contiene il modulo di gestione di Windows Installer (%s) necessario per eseguire l'installazione su questo sistema operativo.

[0x040a]
TITLE=Elegir idioma de instalacin
DESCRIPTION=Seleccionar uno de los idiomas siguientes para la instalacin.
OK=Aceptar
Cancel=Cancelar
1100=Error de inicio de instalacin
1101=InstallShield Wizard
1102=El programa de instalacin %s est preparando InstallShield Wizard, que le guiar durante el resto del proceso de instalacin.  Espere por favor.
1103=Comprobando la versin del Sistema Operativo
1104=Comprobando la versin del instalador de Windows(R)
1105=Configurando el instalador de Windows
1106=Configurando InstallShield
1107=El programa de instalacin ha terminado de configurar el instalador de Windows en el sistema. El sistema se debe reiniciar para seguir con la instalacin. Haga clic en Reiniciar para reiniciar el sistema.
1108=InstallShield
1150=El programa de instalacin ha detectado una versin incompatible de \nWindows. Haga clic en Aceptar y vuelva a iniciar el programa de instalacin en \nWindows 95, Windows NT 4.0 o posterior.
1151=Error al escribir en la ubicacin temporal
1152=Error al extraer %s a la ubicacin temporal
1153=Error al leer el archivo de inicializacin
1154=El instalador no se ha encontrado en %s
1155=El archivo %s no se ha encontrado
1156=Error interno en el instalador de Windows
1200=Reinicie
1603=Error general del procesador del instalador de Windows. Aumente el valor del requisito de espacio en disco en Setup.ini e intntelo de nuevo.
1201=La instalacin necesita %lu KB de espacio en disco libre en %s. Libere espacio e intntelo de nuevo.
1202=No tiene privilegios suficientes para completar esta instalacin para todos los usuarios del equipo. Inicie la sesin como administrador y, a continuacin, intente de nuevo efectuar la instalacin.
1203=Parmetros de la lnea de comandos:
1204=/L Identificador de idioma
1205=/S modo silencioso
1206=/V parmetros para MsiExec.exe
1207=Se ha encontrado el instalador de Windows(R) %s. Se trata de una versin antigua del instalador de Windows(R). Haga clic en Aceptar para continuar.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Este programa de instalacin no incluye el Instalador de Windows (%s) necesario para ejecutar la instalacin en este sistema operativo.

[0x041d]
TITLE=Vlj installationssprk
DESCRIPTION=Vlj installationssprk bland valen nedan.
OK=OK
Cancel=Avbryt
1100=Initieringsfel vid installationen
1101=InstallShield Wizard
1102=%s startar InstallShield Wizard som kommer att leda dig genom installationen.  Vnta.
1103=Kontrollerar operativsystemversion
1104=Kontrollerar versionen av Windows(R) Installer
1105=Konfigurerar Windows Installer
1106=Konfigurerar InstallShield
1107=Installationsprogrammet har konfigurerat Windows Installer p datorn. Om du vill fortstta installationen mste datorn startas om. Starta om datorn genom att klicka p Starta om.
1108=InstallShield
1150=En inkompatibel version av\nWindows har upptckts. Klicka p OK och starta om installationen p\nWindows 95, Windows NT 4.0 eller senare
1151=Ett fel uppstod vid skrivning till den temporra platsen
1152=Det uppstod ett fel nr %s skulle extraheras till den temporra platsen.
1153=Ett fel uppstod vid lsning av initieringsfilen till installationsprogrammet.
1154=Installationsprogrammet finns inte i %s
1155=Filen %s finns inte
1156=Internt fel i Windows Installer
1200=Starta om
1603=Generellt fel i installationsprogrammet till Windows Installer. Frigr diskutrymme i Setup.ini och frsk igen.
1201=Installationen krver %lu kB diskutrymme i %s. Frigr minne och frsk igen.
1202=Du har inte de tkomstrttigheter som krvs fr att kunna ndra installationen fr alla anvndare. Logga p som administratr och frsk att installera p nytt.
1203=Kommandoradsparametrar:
1204=/L sprk-ID
1205=/S utan att tgrd frn anvndaren krvs
1206=/V parametrar till MsiExec.exe
1207=Windows(R) Installer %s hittades. Det hr r en ldre version av Windows(R) Installer. Klicka p OK om du vill fortstta.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Den hr installationen saknar programmet till Windows Installer (%s) som behvs fr att kra installationen p det hr operativsystemet.


[0x0416]
TITLE=Escolha o idioma para a Instalao
DESCRIPTION=Selecione o idioma para esta instalao entre as escolhas abaixo.
OK=OK
Cancel=Cancelar
1100=Erro de inicializao do InstallShield Wizard
1101=InstallShield Wizard
1102=%s A instalao est preparando o InstallShield Wizard, que ir conduzi-lo atravs do processo do programa de instalao.  Aguarde.
1103=Verificando a verso do sistema operacional
1104=Verificando a verso do instalador do Windows(R)
1105=Configurando o instalador do Windows
1106=Configurando o InstallShield
1107=A instalao completou a configurao do instalador do Windows em seu sistema. O sistema precisa ser reiniciado para poder continuar com a instalao. Clique em Reiniciar para reinicializar o sistema.
1108=InstallShield
1150=A instalao detectou um verso incompatvel do\nWindows. Clique em OK e reinicie a instalao no\nWindows 95, Windows NT 4.0, ou superior
1151=Erro ao gravar no local temporrio
1152=Erro ao extrair %s para o local temporrio
1153=Erro ao ler o arquivo de inicializao de instalao
1154=Instalador no encontrado em %s
1155=Arquivo %s no encontrado
1156=Erro interno no instalador do Windows
1200=Reiniciar
1603=Erro de mecanismo do instalador geral do Windows. Aumente requisito de espao em disco no Setup.ini e tente novamente.
1201=O Setup necessita de %lu KB espao livre em disco em %s. Libere algum espao e tente novamente
1202=Voc no tem privilgios suficientes para completar esta instalao para todos os usurios da mquina. Efetue o logon como administrador e tente novamente esta instalao
1203=Parmetros de linha de comando:
1204=/L ID de idioma
1205=/S modo silencioso
1206=/V parmetros para MsiExec.exe
1207=Encontrado o instalador do Windows(R) %s. Existe uma verso mais antiga do instalador do Windows(R). Clique em OK para continuar.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Esta instalao no contm o mecanismo Windows Installer (%s) requerido para executar a instalao nesse sistema operacional.

[0x0c0c]
TITLE=Choisissez la langue d'installation
DESCRIPTION=Choisissez la langue d'installation dans la liste ci-dessous.
OK=OK
Cancel=Annuler
1100=Erreur lors de l'initialisation de l'installation
1101=InstallShield Wizard
1102=L'installation %s prpare InstallShield Wizard, lequel vous guidera pour l'installation du logiciel. Veuillez patienter.
1103=Vrification de la version de systme d'exploitation
1104=Vrification de la version de Windows(R) Installer
1105=Configuration de Windows(R) Installer
1106=Configuration d'InstallShield
1107=L'installation a termin la configuration de Windows Installer sur votre ordinateur. Pour pouvoir poursuivre l'installation, le systme doit tre redmarr. Veuillez cliquer sur Redmarrer pour rinitialiser le systme.
1108=InstallShield
1150=L'installation a dcel une version de\nWindows incompatible. Veuillez cliquer sur OK et relancer l'installation sur\nWindows 95, Windows NT 4.0, ou toute autre version de Windows ultrieure.
1151=Erreur lors de l'criture vers l'emplacement temporaire
1152=Erreur lors de l'extraction %s vers l'emplacement temporaire
1153=Erreur lors de la lecture du fichier d'initialisation de l'installation
1154=Programme d'installation introuvable dans %s
1155=Fichier %s introuvable
1156=Erreur interne dans Windows Installer.
1200=Redmarrer
1603=Erreur gnrale du moteur de Windows Installer. Augmentez la valeur de l'espace disque ncessaire dans Setup.ini et ressayez.
1201=Le programme d'installation ncessite %lu ko d'espace disque libre dans %s. Veuillez librer de l'espace et ressayer.
1202=Vous ne possdez pas les privilges ncessaires pour terminer cette installation pour tous les utilisateurs de l'ordinateur. Ouvrez une session en tant qu'administrateur puis ressayez cette installation.
1203=Paramtres de ligne de commande :
1204=/L Identification de langue
1205=/S mode silencieux
1206=/V paramtres  MsiExec.exe
1207=Windows(R) Installer %s trouv. Ceci est une ancienne version de Windows(R) Installer. Cliquez sur OK pour continuer.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Cette installation ne contient pas le programme d'installation Windows (%s) requis pour laner la configuration sur ce systme d'exploitation.

[0x042d]
TITLE=Aukeratu instalazioa egiteko hizkuntza
DESCRIPTION=Hautatu hizkuntza bat beheko aukeren artean.
OK=Ados
Cancel=Utzi
1100=Setup Initialization Error
1101=InstallShield
1102=InstallShield(R) is preparing the Installation Wizard, which will install %s on your computer. Please wait.
1103=Checking Operating System Version
1104=Checking Windows(R) Installer Version
1105=Configuring Windows Installer
1106=Configuring InstallShield
1107=Setup has completed configuring the Windows Installer on your system. The system needs to be restarted in order to continue with the installation. Please click Restart to reboot the system.
1108=InstallShield
1150=Setup has detected an incompatible version of\nWindows. Please click OK and relaunch setup on\nWindows 95, Windows NT 4.0, or later
1151=Error writing to the temporary location
1152=Error extracting '%s' to the temporary location
1153=Error reading setup initialization file
1154=Installer not found in '%s'
1155=File '%s' not found
1156=Internal error in Windows Installer
1200=Restart
1603=You need administrator privileges to install the Windows Installer engine.
1604=This setup does not contain the Windows Installer engine (%s) required to run the installation on this operating system.

[0x0403]
TITLE=Esculli la llengua del Setup
DESCRIPTION=Seleccioni la llengua per a aquesta instal.laci?de la segent llista.
OK=D'acord
Cancel=Cancella
1100=Setup Initialization Error
1101=InstallShield
1102=InstallShield(R) is preparing the Installation Wizard, which will install %s on your computer. Please wait.
1103=Checking Operating System Version
1104=Checking Windows(R) Installer Version
1105=Configuring Windows Installer
1106=Configuring InstallShield
1107=Setup has completed configuring the Windows Installer on your system. The system needs to be restarted in order to continue with the installation. Please click Restart to reboot the system.
1108=InstallShield
1150=Setup has detected an incompatible version of\nWindows. Please click OK and relaunch setup on\nWindows 95, Windows NT 4.0, or later
1151=Error writing to the temporary location
1152=Error extracting '%s' to the temporary location
1153=Error reading setup initialization file
1154=Installer not found in '%s'
1155=File '%s' not found
1156=Internal error in Windows Installer
1200=Restart
1603=You need administrator privileges to install the Windows Installer engine.
1604=This setup does not contain the Windows Installer engine (%s) required to run the installation on this operating system.

[0x0405]
TITLE=Vybrat jazyk instalace
DESCRIPTION=Pomoc voleb uvedench ne vyberte jazyk pro tuto instalaci.
OK=OK
Cancel=Storno
1100=Chyba inicializace instalace
1101=InstallShield Wizard
1102=Instalan program %s pipravuje InstallShield Wizard, kter vs provede procesem instalace programu. ekejte, prosm.
1103=Probh kontrola verze operanho systmu
1104=Probh kontrola verze instalanho programu systmu Windows(R)
1105=Probh konfigurace instalanho programu systmu Windows
1106=Probh konfigurace programu InstallShield
1107=Byla dokonena konfigurace instalanho programu systmu Windows v systmu. Chcete-li v instalaci pokraovat, je nutn restartovat systm. Chcete-li znovu zavst systm, klepnte na tlatko Restartovat.
1108=InstallShield
1150=Byla zjitna nekompatibiln verze systmu\nWindows. Klepnte na tlatko OK a znovu spuste instalaci v systmu\nWindows 95, Windows NT 4.0 nebo vym 
1151=Pi zpisu na doasn msto dolo k chyb.
1152=Pi extrakci %s na doasn msto dolo k chyb.
1153=Pi ten inicializanho souboru instalace dolo k chyb.
1154=Instalan program nebyl v adresi %s nalezen.
1155=Soubor %s nebyl nalezen.
1156=Vnitn chyba instalanho programu systmu Windows
1200=Restartovat
1603=Dolo k obecn chyb jdra instalanho programu systmu Windows. Zvyte hodnotu parametru DiskSpace v souboru Setup.ini a akci opakujte.
1201=Instalan program vyaduje %lu kB volnho msta na jednotce %s. Uvolnte msto a akci opakujte.
1202=Nemte dostaten oprvnn k dokonen tto instalace pro vechny uivatele tohoto potae. Pihlate se jako sprvce a pak tuto instalaci zopakujte.
1203=Parametry pkazovho dku:
1204=/L ID jazyka
1205=/S reim bez obsluhy
1206=/V parametry programu MsiExec.exe
1207=Nalezen instalan program %s systmu Windows(R). Jedn se o star verzi instalanho programu systmu Windows(R). Pokraujte klepnutm na tlatko OK.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Tato instalace neobsahuje modul Windows Installer (%s) potebn pro bh instalace v tomto operanm systmu.

[0x0406]
TITLE=Vlg installationssproget
DESCRIPTION=Vlg installationssproget fra den flgende liste.
OK=OK
Cancel=Annuller
1100=Fejl under initialiseringen af installationsprogrammet
1101=InstallShield Wizard
1102=%s Installationsprogrammet forbereder InstallShield Wizard, som vil hjlpe dig gennem installationen af programmet.  Vent et jeblik.
1103=Kontrollerer versionsoplysningerne for operativsystemet
1104=Kontrollerer versionsoplysningerne for Windows(R) Installer
1105=Konfigurerer Windows Installer
1106=Konfigurerer InstallShield
1107=Installationsprogrammet har konfigureret Windows Installer p systemet. Systemet skal genstartes, fr installationen kan fortstte. Klik p Genstart for at genstarte systemet.
1108=InstallShield
1150=Installation har fundet en version af\nWindows, der ikke er kompatibel. Klik p OK, og kr Installation igen under\nWindows 95, Windows NT 4.0 eller en nyere version
1151=Der opstod en fejl under skrivning til den midlertidige placering.
1152=Der opstod en fejl under udpakning af %s til den midlertidige placering.
1153=Der opstod en fejl under lsning af initialiseringsfilen til installationsprogrammet.
1154=Installationsprogrammet blev ikke fundet i %s
1155=Filen %s blev ikke fundet
1156=Der opstod en intern fejl i Windows Installer
1200=Genstart
1603=Generel fejl i Windows Installer. Forg kravet til diskplads i Setup.ini, og prv igen.
1201=Installationsprogrammet skal bruge %lu KB ledig diskplads p %s. Frigr plads, og prv igen
1202=Du har ikke de ndvendige privilegier til at udfre installationen for alle brugere af maskinen. Log p som administrator, og kr installationen igen
1203=Kommandolinjeparametre:
1204=/L sprog-id
1205=/S automatiseret tilstand
1206=/V parametre for MsiExec.exe
1207=Windows(R) Installer %s blev fundet. Dette er en ldre version af Windows(R) Installer. Klik p OK for at fortstte.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Dette installationsprogram indeholder ikke Windows-installationsprogrammet (%s), der er ndvendigt for at kre installationen p dette operativsystem.

[0x0413]
TITLE=Setup-taal kiezen
DESCRIPTION=Selecteer de taal voor deze installatie uit de onderstaande lijst.
OK=OK
Cancel=Annuleren
1100=Initialisatiefout voor Setup
1101=InstallShield Wizard
1102=%s Setup is bezig met het voorbereiden van de InstallShield Wizard die u door de setup van het programma zal leiden. Een ogenblik geduld.
1103=Bezig met het controleren van de versie van het besturingssysteem
1104=Bezig met het controleren van de versie van Windows(R) Installer
1105=Bezig met het configureren van Windows Installer
1106=Bezig met het configureren van InstallShield
1107=Setup is klaar met het configureren van Windows Installer op uw systeem. Het systeem dient opnieuw te worden opgestart om verder te gaan met de installatie. Klik Opnieuw starten om het systeem opnieuw te starten.
1108=InstallShield
1150=Setup heeft een incompatibele versie van Windows\naangetroffen. Klik OK en start setup opnieuw binnen\nWindows 95, Windows NT 4.0 of later
1151=Er is een fout opgetreden bij het schrijven naar de tijdelijke locatie
1152=Er is een fout opgetreden bij het uitpakken van %s naar de tijdelijke locatie
1153=Er is een fout opgetreden bij lezen van het setup-initialisatiebestand
1154=Installatieprogramma niet gevonden in %s
1155=Bestand %s niet gevonden
1156=Interne fout in Windows Installer
1200=Opnieuw starten
1603=Algemene systeemfout in Windows Installer. Vergroot de specificatie van schijfruimte in Setup.ini en probeer opnieuw.
1201=Setup heeft %lu kB vrije schijfruimte nodig op %s. Maak schijfruimte vrij en probeer opnieuw
1202=U heeft onvoldoende bevoegdheid om voor alle gebruikers van de machine deze installatie te voltooien. Meld u aan als beheerder en probeer deze installatie opnieuw
1203=Opdrachtregelparameters:
1204=/L brontaal-id
1205=/S stille modus
1206=/V parameters voor MsiExec.exe
1207=Windows(R) Installer %s is gevonden. Dit is een ouderen versie van de Windows(R) Installer. Klik OK om verder te gaan.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=In deze setup ontbreekt de engine van het installatieprogramma voor Windows (%s) die benodigd is om de installatie op dit besturingssysteem uit te voeren.

[0x040b]
TITLE=Valitse asennuskieli
DESCRIPTION=Valitse asennuskieli alla olevista vaihtoehdoista.
OK=OK
Cancel=Peruuta
1100=Asennuksen alustusvirhe
1101=InstallShield Wizard
1102=%s Asennus valmistelee InstallShield Wizardia, joka opastaa sinua ohjelman asennuksessa.  Odota hetki.
1103=Kyttjrjestelmn versiotietoja tarkistetaan.
1104=Windows(R) Installer -ohjelman versiotietoja tarkistetaan.
1105=Windows Installer -ohjelman asetuksia mritetn.
1106=InstallShield-asetuksia mritetn.
1107=Asennuksessa on mritetty jrjestelmss kytettvn Windows Installer -ohjelman asetukset. Jrjestelm on kynnistettv uudelleen, jotta asennusta voitaisiin jatkaa. Kynnist jrjestelm uudelleen napsauttamalla Kynnist uudelleen.
1108=InstallShield
1150=Asennusohjelma on havainnut yhteensopimattoman \nWindows-version. Napsauta OK ja kynnist asennus uudelleen kyttmll \nWindows 95- tai Windows NT 4.0 -kyttjrjestelm tai uudempaa.
1151=Virhe kirjoitettaessa vliaikaiseen sijaintiin.
1152=Virhe purettaessa kohdetta %s vliaikaiseen sijaintiin.
1153=Virhe luettaessa asennuksen alustustiedostoa.
1154=Installer-ohjelmaa ei lydy kohteesta %s.
1155=Tiedostoa %s ei lydy.
1156=Windows Installer -ohjelman sisinen virhe.
1200=Kynnist uudelleen
1603=Yleinen virhe Windows Installer -ohjelmassa. Suurenna Setup.ini-tiedostossa olevaa levytilavaatimusta ja yrit uudelleen.
1201=Asennukseen tarvitaan %lu kt vapaata levytilaa kohteessa %s. Vapauta lis tilaa ja yrit uudelleen.
1202=Kyttoikeutesi eivt riit tmn asennuksen suorittamiseen kaikille kyttjille. Kirjaudu sisn pkyttjn ja yrit asennusta uudelleen.
1203=Komentorivin parametrit:
1204=/L kielitunnus
1205=/S vaimennus
1206=/V MsiExec.exe-parametrit
1207=Lydettiin Windows(R) Installer %s. Tm on Windows(R) Installer -ohjelman aikaisempi versio. Jatka napsauttamalla OK.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Tm asennus ei sisll asennuksen suorittamiseen tss kyttjrjestelmss tarvittavaa Windows Installer -ohjelmaa (%s).

[0x0408]
TITLE=   
DESCRIPTION=         .
OK=OK
Cancel=
1100=  
1101=InstallShield Wizard
1102=   %s   InstallShield Wizard,          .   .
1103=   
1104=      Windows(R)
1105=    Windows
1106= InstallShield
1107=         Windows   .     ,      .        .
1108=InstallShield
1150=       \nWindows.    OK     \nWindows 95, Windows NT 4.0  
1151=    
1152=   %s   
1153=    
1154=       %s
1155=     %s
1156=      Windows
1200=
1603=      Windows.         Setup.ini  .
1201=   %lu KB      %s.    
1202=               .         
1203=  :
1204=/L  
1205=/S  
1206=/V   MsiExec.exe
1207=   %s     Windows(R).         Windows(R).    OK  .
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=           Windows (%s)            .

[0x040e]
TITLE=A nyelv kivlasztsa
DESCRIPTION=Vlasszon egy nyelvet a teleptshez az albbiak kzl.
OK=OK
Cancel=Mgse
1100=Telepts-inicializlsi hiba
1101=InstallShield Wizard
1102=A(z) %s telept elkszti az InstallShield Wizard, amely vgigvezeti nt a programtelepts folyamatn. Vrjon.
1103=Az opercis rendszer verzijnak ellenrzse
1104=A Windows(R) Installer verzijnak ellenrzse
1105=A Windows Installer belltsa
1106=Az InstallShield belltsa
1107=A Telept befejezte a Windows Installer belltst a rendszeren. A telepts folytatshoz a rendszert jra kell indtani. Kattintson az jraindts gombra a rendszer jraindtshoz.
1108=InstallShield
1150=A Telept a Windows nem kompatbilis verzijt\nrzkelte. Kattintson az OK gombra s indtsa jra a teleptt\nWindows 95, Windows NT 4.0 vagy jabb rendszeren.
1151=Hiba az ideiglenes knyvtrba val rskor
1152=Hiba a(z) %s fjl ideiglenes knyvtrba val kibontsakor
1153=Hiba a teleptsinicializl fjl olvassakor
1154=Az Installer nem tallhat a kvetkez helyen: %s
1155=A(z) %s fjl nem tallhat
1156=Bels hiba a Windows Installerben
1200=jraindts
1603=ltalnos hiba a Windows Installer motorban. Nvelje meg a Setup.ini fjl DiskSpace felttelt, majd prblja jra.
1201=A Telept %lu KB szabad lemezterletet ignyel a kvetkez helyen: %s. szabadtson fel helyet, majd prblja jra.
1202=n nem rendelkezik megfelel jogokkal ahhoz, hogy a teleptst a szmtgp sszes felhasznlja szmra elvgezze. Lpjen be rendszergazdaknt, majd prblkozzon jra a teleptssel.
1203=A parancssor paramterei:
1204=/L nyelv ID
1205=/S csendes zemmd
1206=/V MsiExec.exe paramterei
1207=A(z) %s Windows(R) Installert taltam meg. Ez a Windows(R) Installer rgebbi verzija. A folytatshoz kattintson az OK-ra.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Ez a telept nem tartalmazza a Windows Installer engine (%s) alkalmazst, amely szksges, ha erre az opercis rendszerre telept.

[0x0414]
TITLE=Velg sprk for installasjonen
DESCRIPTION=Velg sprk for denne installasjonen blant alternativene nedenfor.
OK=OK
Cancel=Avbryt
1100=Initialiseringsfeil for installeringsprogram
1101=InstallShield Wizard
1102=Installere %s gjr klar InstallShield Wizard, som vil lede deg gjennom installeringen av programmet.  Vent litt.
1103=Kontrollerer operativsystem-versjon
1104=Kontrollerer versjon av Windows(R) Installer
1105=Konfigurerer Windows Installer
1106=Konfigurerer InstallShield
1107=Installeringsprogrammet har fullfrt konfigurering av Windows Installer p datamaskinen. Datamaskinen m startes p nytt fr installeringen kan fortsette. Klikk Start p nytt for  starte maskinen p nytt.
1108=InstallShield
1150=Installeringsprogrammet har funnet en ikke-kompatibel\nversjon av Windows. Velg OK og start installeringen p nytt i\nWindows 95, Windows NT 4.0 eller nyere
1151=Feil under skriving til midlertidig plass i minnet
1152=Feil under utpakking av %s til midlertidig plassering
1153=Feil under lesing av initialiseringsfil for installering
1154=Installeringsprogram ikke funnet i %s
1155=Fant ikke filen %s
1156=Intern feil i Windows Installer
1200=Start p nytt
1603=Generell feil i Windows Installer-motoren. k mengden ndvendig diskplass (DiskSpace) i Setup.ini og prv p nytt.
1201=Installasjonsprogrammet trenger %lu kB ledig diskplass i %s. Frigjr plass og prv p nytt
1202=Du har ikke de rette privilegiene til  fullfre denne installasjonen for alle brukerne av maskinen. Logg deg p som administrator og prv  utfre denne installasjonen p nytt
1203=Kommandolinjeparametere:
1204=/L sprk-ID
1205=/S stille modus
1206=/V parametere for MsiExec.exe
1207=Windows(R) Installer %s funnet. Dette er en eldre versjon av Windows(R) Installer. Velg OK for  fortsette.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Dette installasjonsprogrammet inneholder ikke Windows Installer-motoren (%s) som kreves for  kjre installeringen p dette operativsystemet.

[0x0415]
TITLE=Wybierz jzyk instalacji
DESCRIPTION=Wybierz jzyk dla tej instalacji spord dostpnych poniej.
OK=OK
Cancel=Anuluj
1100=Bd inicjowania Instalatora
1101=InstallShield Wizard
1102=Program instalacyjny %s przygotowuje Kreatora instalacji InstallShield Wizard, ktry pomoe zainstalowa program. Prosz czeka.
1103=Sprawdzanie wersji systemu operacyjnego
1104=Sprawdzanie wersji Instalatora Windows(R)
1105=Konfigurowanie Instalatora Windows
1106=Konfigurowanie Kreatora InstallShield
1107=Instalator zakoczy konfiguracj Instalatora Windows w systemie. Aby kontynuowa instalacj, system musi zosta ponownie uruchomiony. Kliknij przycisk Uruchom ponownie, aby ponownie uruchomi system.
1108=InstallShield
1150=Instalator wykry niezgodn wersj systemu\nWindows. Kliknij przycisk OK i ponownie uruchom Instalatora, w systemie\nWindows 95, Windows NT 4.0 lub nowszym
1151=Bd zapisu do lokalizacji tymczasowej
1152=Bd wyodrbniania %s do lokalizacji tymczasowej
1153=Bd odczytu pliku inicjujcego Instalatora
1154=W pliku %s nie znaleziono Instalatora
1155=Nie znaleziono pliku %s
1156=Bd wewntrzny Instalatora Windows
1200=Uruchom ponownie
1603=Bd oglny aparatu Instalatora Windows. Zwiksz warto parametru DiskSpace w pliku Setup.ini i sprbuj ponownie.
1201=Instalator wymaga %lu KB wolnego miejsca na dysku %s. Zwolnij troch miejsca i sprbuj ponownie.
1202=Nie posiadasz wystarczajcych uprawnie, aby dokona tej instalacji dla wszystkich uytkownikw tego komputera. Zaloguj si jako administrator i ponw prb instalacji
1203=Parametry wiersza polece:
1204=/L identyfikator jzyka
1205=/S tryb dyskretny
1206=/V parametry dla MsiExec.exe
1207=Znaleziony zosta Windows(R) Installer %s. Jest to starsza wersja programu. Kliknij OK, aby kontynuowa.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Ta konfiguracja nie obejmuje moduu Windows Installer (%s), wymaganego do uruchomienia instalacji w tym systemie operacyjnym.

[0x0816]
TITLE=Seleccionar o idioma de configurao
DESCRIPTION=Seleccione o idioma para esta instalao a partir das opes abaixo indicadas.
OK=OK
Cancel=Cancelar
1100=Erro na inicializao do programa de configurao
1101=InstallShield Wizard
1102=%s O programa de configurao est a preparar o InstallShield Wizard que o orientar ao longo do processo de configurao do programa.  Aguarde.
1103=Verificar a verso do sistema operativo
1104=Verificar a verso do programa de instalao do Windows(R)
1105=Configurar o programa de instalao do Windows
1106=Configurar o InstallShiled
1107=Configurao do programa do Windows Installer no sistema concluda.  necessrio reiniciar o sistema para continuar a instalao.  Faa clique sobre Reiniciar para reinicializar o sistema.
1108=InstallShield
1150=O programa de configurao detectou uma verso incompatvel do\nWindows.  Faa clique sobre OK e volte a iniciar o programa de configurao no\nWindows 95, Windows NT 4.0 ou superior
1151=Erro ao escrever para a localizao temporria
1152=Erro ao extrair %s para a localizao temporria
1153=Erro ao ler o ficheiro de inicializao da configurao
1154=O Installer no foi localizado em %s
1155=Ficheiro %s no localizado
1156=Erro interno no Windows Installer
1200=Reiniciar
1603=Erro geral do motor do Windows Installer. Aumente o requisito Espao em disco em Setup.ini e tente novamente.
1201=O programa de configurao necessita de %lu KB de espao livre em disco em %s. Liberte algum espao e tente novamente
1202=No tem privilgios suficientes para concluir a instalao para todos os utilizadores. Inicie a sesso como administrador e, em seguida, repita a instalao
1203=Parmetros da linha de comandos:
1204=/L ID do idioma
1205=/S modo silencioso
1206=/V parmetros para o MsiExec.exe
1207=O Windows(R) Installer %s foi localizado.  uma verso antiga do Windows(R) Installer. Faa clique sobre OK para continuar.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Esta configurao no contm o motor Windows Installer (%s) necessrio para executar a instalao neste sistema operativo.

[0x0424]
TITLE=Izberite jezik za namestitev
DESCRIPTION=Iz naslednjega izbora izberite jezik za to namestitev.
OK=V redu
Cancel=Preklii
1100=Napaka pri inicializaciji namestitve
1101=arovnik InstallShield
1102=%s namestitev pripravlja arovnika InstallShield, ki vas bo vodil skozi namestitev programa. Poakajte, prosim.
1103=Preverjam razliico operacijskega sistema
1104=Preverjam razliico Windows(R) namestitvenega programa
1105=Konfiguriram Windows namestitveni program
1106=Konfiguriram InstallShield
1107=Namestitveni program je zakljuil konfiguriranje Windows namestitvenega programa na vaem sistemu. Nadaljevanje namestitve zahteva vnovien zagon sistema. Za vnovien zagon sistema kliknite prosim Ponovno zaeni.
1108=InstallShield
1150=Namestitveni program je odkril nezdruljivo razliico\nWindows. Kliknite prosim V redu in ponovno zaenite namestitev\nWindows 95, Windows NT 4.0 oz. noveji.
1151=Napaka pri zapisovanju v zaasni imenik
1152=Napaka pri raztegovanju %s v zaasni imenik
1153=Napaka pri branju namestitvene inicializacijske datoteke
1154=Namestitvenega programa ni mogoe najti v %s
1155=Ne najdem datoteke %s
1156=Notranja napaka v Windows namestitvenem programu
1200=Ponovno zaeni
1603=Splona napaka Windows namestitvenega programa. Za datoteko Setup.ini zagotovite prazen prostor na disku in ponovno poizkusite.
1201=Namestitev zahteva %lu KB praznega prostora na disku v %s. Zagotovite nekaj prostora in ponovno poizkusite
1202=Nimate zadostnih pooblastil za izvedbo te namestitve za vse uporabnike delovne postaje. Prijavite se kot skrbnik in poizkusite ponoviti namestitev
1203=Parametri ukazne vrstice:
1204=/L identifikacijska tevilka jezika
1205=/S tihi nain
1206=/V parametri za MsiExec.exe
1207=Iskanje Windows(R) namestitvenega programa %s je bilo uspeno. To je stareja razlicica Windows(R) namestitvenega programa. Za nadaljevanje kliknite V redu.
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=Ta namestitveni program ne vsebuje Windows namestitvenega programa (%s), ki je potreben za izvedbo namestitve na ta operacijski sistem.

[0x041b]
TITLE=Vyberte jazyk
DESCRIPTION=Vyberte jazyk z uvedenej ponuky pre tto intalciu.
OK=OK
Cancel=Storno
1100=Setup Initialization Error
1101=InstallShield
1102=InstallShield(R) is preparing the Installation Wizard, which will install %s on your computer. Please wait.
1103=Checking Operating System Version
1104=Checking Windows(R) Installer Version
1105=Configuring Windows Installer
1106=Configuring InstallShield
1107=Setup has completed configuring the Windows Installer on your system. The system needs to be restarted in order to continue with the installation. Please click Restart to reboot the system.
1108=InstallShield
1150=Setup has detected an incompatible version of\nWindows. Please click OK and relaunch setup on\nWindows 95, Windows NT 4.0, or later
1151=Error writing to the temporary location
1152=Error extracting '%s' to the temporary location
1153=Error reading setup initialization file
1154=Installer not found in '%s'
1155=File '%s' not found
1156=Internal error in Windows Installer
1200=Restart
1603=You need administrator privileges to install the Windows Installer engine.
1604=This setup does not contain the Windows Installer engine (%s) required to run the installation on this operating system.

[0x0411]
TITLE=ZbgAbv̑I
DESCRIPTION=̃CXg[Ŏgp錾̃XgIĂB
OK=OK
Cancel=LZ
1100=ZbgAbvG[
1101=InstallShield EBU[h
1102=%s ZbgAbv́AvOZbgAbv̎菇ēInstallShield EBU[hĂ܂B΂炭҂...
1103=Iy[eBOVXẽo[WmFĂ܂
1104=Windows(R) Installer̃o[WmFĂ܂
1105=Windows Installerݒ肵Ă܂
1106=InstallShieldݒ肵Ă܂
1107=ZbgAbv́AVXeWindows Installer̐ݒ܂BCXg[𑱍sɂ́AVXeċNKv܂BuċNvNbNāAVXeċNĂB
1108=InstallShield
1150=ZbgAbv́AΉȂo[WWindowso܂B\nuOKvNbNāAZbgAbvWindows 95AWindows NT 4.0A܂\nȍ~̃o[WōēxsĂB 
1151=ꎞtH_ɏݒɃG[܂B
1152=%s ꎞtH_ɉ𓀒ɃG[܂B
1153=ZbgAbvt@Cǂݎ蒆ɃG[܂B
1154=Installer %s Ɍoł܂B
1155=t@C %s oł܂B
1156=Windows InstallerœG[Ă܂ 
1200=ċN
1603=ʓIWindows InstallerGW̃G[łBSetup.ini ̕KvȃfBXNeʂ̒l𑝂₵ĂAēxsĂB
1201=ZbgAbv́A%lu KoCg̋󂫃fBXNeʁihCu: %sjKvƂ܂B󂫃fBXNeʂ𑝂₵ĂAēxsĂB
1202=ׂẴ[Uɑ΂CXg[邽߂̌܂BAh~jXg[^ŃOIĂÃCXg[ēxsĂB
1203=R}hCp[^:
1204=/L  ID
1205=/S TCg[h
1206=/V p[^MsiExec.exe֑
1207=Windows(R) Installer %s o܂BÂo[WWindows(R) InstallerłBuOKvNbNđsĂB
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=̾ı߂ɂ́A̵ڰèݸ޼тŲݽİقŝɕKv Windows Installer ݼ (%s) ܂܂Ă܂B

[0x0419]
TITLE= 
DESCRIPTION=    .
OK=
Cancel=
1100=   
1101=InstallShield Wizard
1102=%s      InstallShield Wizard,   .  .
1103=   
1104=    Windows(R)
1105=   Windows
1106= InstallShield
1107=      Windows  .      .   """",   .
1108=InstallShield
1150=    \nWindows.   ""OK""      \nWindows 95, Windows NT 4.0    .
1151=     
1152=   %s   
1153=      
1154=      %s
1155= %s  
1156=     Windows
1200=
1603=     Windows.         Setup.ini   .
1201=   %lu        %s.       .
1202=   ,        .         .
1203=  :
1204=/L  
1205=/S  
1206=/V   MsiExec.exe
1207=   Windows(R) %s.       Windows(R).  ,   """".
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=        Windows (%s),         .

[0x0804]
TITLE=ѡװ
DESCRIPTION=ѡѡ˰װԡ
OK=ȷ
Cancel=ȡ
1100=װʼ
1101=InstallShield Wizard
1102=%s װ׼ InstallShield WizardInstallShield Wizard ִгװ̡  Ժ
1103=ڼϵͳ汾
1104=ڼ Windows(R) Installer 汾
1105= Windows Installer
1106= InstallShield
1107=װϵͳ Windows Installer á ҪϵͳԱװ 뵥ϵͳ
1108=InstallShield
1150=װ⵽ݵ\nWindows 汾 뵥ȷȻ Windows 95Windows NT 4.0 \n߰汾װ
1151=дʱλʱ
1152= %s ѹʱλʱ
1153=ȡװʼļʱ
1154= %s Ҳ Installer
1155=ļ %s δҵ
1156=Windows Installer еڲ
1200=
1603= Windows Installer   Setup.ini е DiskSpace ҪȻԡ
1201=װҪ %lu KB ô̿ռ %s СͷһЩռȻ
1202=û㹻ȨΪüûɴ˰װ ԹԱݵ¼Ȼ³Խд˰װ
1203=в
1204=/L  ID
1205=/S ģʽ
1206=/V MsiExec.exe 
1207=ҵ Windows(R) Installer %s Ǿɰ Windows(R) Installer ȷԼ
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=˰װ򲻰ڴ˲ϵͳаװ Windows Installer  (%s)

[0x0404]
TITLE=ܦw˻y
DESCRIPTION=qHUﶵܦw˵{yC
OK=Tw
Cancel=
1100=w˵{_l~
1101=InstallShield Wizard
1102=%s w˵{bǳ InstallShield WizardAInstallShield Wizard N޾ɱzqL{w˹L{C  еyԡC
1103=bˬd@~tΪ
1104=bˬd Windows(R) installer 
1105=b]w Windows installer
1106=b]w InstallShield
1107=w˵{wbztΤF Windows installer ]wC ݭnsҰʨtΥHK~wˡC Ы@UusҰʡvӭsҰʨtΡC
1108=InstallShield
1150=w˵{줣ۮe\nWindows C Ы@UuTwvAMb Windows 95BWindows NT 4.0 \nΧ󰪪sҰʦw˵{
1151=gJ{ɦmɥX
1152=N %s {ɦmɥX
1153=Ūw˵{_lɮ׮ɥX
1154=b %s 䤣 Installer
1155=ɮ %s 
1156=Windows installer ~
1200=sҰ
1603=@ Windows Installer ~C W[ Setup.ini  DiskSpace nDMZաC
1201=w˵{ݭn %lu KB iκϺЪŶb %s C@ǪŶMZ
1202=zSvҦϥΪ̪wˡC ХΨtκ޲z̨nJAswˤ@
1203=OѼơR 
1204=/L y ID
1205=/S wRҦ
1206=/V MsiExec.exe Ѽ
1207= Windows(R) Installer %sC oOª Windows(R) InstallerC @UuTwvH~C
1208=ANSI code page for %s is not installed on the system and therefore setup cannot run in the selected language. Run the setup and select another language.
1604=w˵{]tb@~tΤWw˩һݤ Windows Installer  (%s)C

[0x041f]
TITLE=Kurulum Dilini Se
DESCRIPTION=Bu ykleme dilini aadaki seenekler arasndan sein.
OK=Tamam
Cancel=ptal
1100=Kur Balatma Hatas
1101=InstallShield Wizard
1102=%s Kur, programn kurulum ilemi srasnda size yol gsterecek olan InstallShield Wizard' hazrlyor.  Ltfen bekleyin.
1103=letim Sistemi Srmn Denetleme
1104=Windows(R) Installer Srmn Denetleme
1105=Windows Installer Yaplandrma
1106=InstallShield Yaplandrma
1107=Kur, sisteminizdeki Windows Installer programn yaplandrmay tamamlad. Yklemeye devam edilebilmesi iin sistemin yeniden balatlmas gerekir. Sistem nyklemesi iin Yeniden Balat' tklatn.
1108=InstallShield
1150=Kur, Windows'un uyumsuz bir srmn\nalglad. Tamam' tklatn ve kurulum programn Windows 95,\nWindows NT 4.0 veya daha st iletim sisteminde yeniden balatn.
1151=Geici konuma yazma hatas
1152=Geici konuma %s ama hatas
1153=Kurulum balatma dosyas okuma hatas
1154=%s iinde ykleyici bulunamad
1155=%s dosyas bulunamad
1156=Windows Installer'da i hata
1200=Yeniden Balat
1603=Genel Windows Installer altyap hatas. Setup.ini dosyasndaki DiskSpace gereksinimini arttrn ve yeniden deneyin.
1201=Ku